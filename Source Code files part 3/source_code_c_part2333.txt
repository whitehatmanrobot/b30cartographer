cOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<6;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
		status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
		if (status == RM_OK)
			if (fpTim.HTotal > pDev->Dac.fpHActive) // new max?
			{
				mode_count++;
				pDev->Dac.fpPixClk = fpTim.PixClk;
				pDev->Dac.fpHActive = fpTim.HActive;
			 	pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
				pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
	 			pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
			 	pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
			 	pDev->Dac.fpHValidStart = fpTim.HValidStart;
			 	pDev->Dac.fpHTotal = fpTim.HTotal;
					
	 			pDev->Dac.fpVActive = fpTim.VActive;
			 	pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
			 	pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
			 	pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
		 		pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
			 	pDev->Dac.fpVValidStart = fpTim.VValidStart;
	 			pDev->Dac.fpVTotal = fpTim.VTotal;
				pDev->Dac.fpFlags = fpTim.Flags;
				pDev->Dac.fpHMax = pDev->Dac.fpHActive;
				pDev->Dac.fpVMax = pDev->Dac.fpVActive;
			}
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
		if (mode_count > 1)
			pDev->Dac.fpNative = 1;	
		return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
    // The EDID may contain "established timings", a bit map of flags showing supported 
	// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
	// or "detailed timings", an 18-byte description.
	// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }

    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}

//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We need to generate an EDID given the current BIOS default panel
    // info, but until the BIOS is ready for this, just return the
    // default EDID for the mobile panels
    //
    // 
    // We need to construct the EDID from the BIOS data, but for now just drop in a std panel EDID
    //
    U032 i, panel_type;
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCF
         // original 0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD4
    };

    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         // original 0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x9A
         // original 0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xA4
    };

    U008 dfp_edid_Toshiba_10x7[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4, 
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02, 
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B, 
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41, 
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
         0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 
         0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00, 
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3C, 0x3C, 0x1E,
         // original 0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x46, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00, 
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F, 
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x60
         // original 0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x65
    };


    // Toshiba?
    if (pDev->Power.MobileOperation == 2)
    {
        for (i=0;i<128;i++)
            //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_Toshiba_10x7[i];
            pEdid[i] = dfp_edid_Toshiba_10x7[i];
    } 
    else
    {

        //
        // Dell Strapping assignments
        //
        //- SXGA+ panels            Panel ID     Timing        
        //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
        //    Sharp 15"              0x8          SXGA+       
        //    Unknown supplier       0x2          SXGA+       
        //    Unknown supplier       0x7          SXGA+      
        //  
        //- UXGA panels                
        //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xA          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
    
        //
        // Strapped for UXGA???
        //
        panel_type = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE) & 0x0F; 
        if ((panel_type == 0x03) || (panel_type == 0x04) || (panel_type == 0x05) 
            || (panel_type == 0x0A) || (panel_type == 0x0B))
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_UXGA[i];
                pEdid[i] = dfp_edid_UXGA[i];
        }
        //
        // Strapped for SXGA+???
        //
        else    // assume SXGA+ if nothing else
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_SXGA[i];
                pEdid[i] = dfp_edid_SXGA[i];
        }
    }

    return RM_OK;

}

//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }
    // Currently we can access any device from Head 0, but in the future, who knows?
//    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        lock = ReadCRTCLock(pDev, Head);	// Unlock the registers
        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    }
    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\grayclk.c ===
#include <nvrm.h>
#include <nvhw.h>
#include <nvos.h>
#include <bios.h>            // need BIOS_ROM_CODE_SIZE
#include <nv10_ref.h>

#define __KERNEL__
#include <nv.h>
#include <Nvcm.h>

//doubled table length to avoid wasted effort of boundary checking for something so small
static const U032 GrayCodeLookupTable[16]={0,1,3,2,6,7,5,4,0,1,3,2,6,7,5,4};
static const U032 GrayCodeLookupTableLength=16;

static U032 GrayCodeLookup(U032 Value,U032 starting_position)
{
	U032 x;
	
	Value=Value&0x7;
	
	//looks up 3 bit value in lookup table and returns the position
	for(x=starting_position;x<GrayCodeLookupTableLength;x++)
	{
		if(GrayCodeLookupTable[x]==Value)
		{
			return x;
		}
	}
	
	return 0;
}

void RmProperClockPdivProgrammer(PHWINFO pDev,U032 ClockAddress,U032 NewValue)
{
	U032 OldValue;
	U032 OldPdiv;
	U032 NewPdiv;
	U032 PllValLessPdiv;
	U032 ListPosition;
	U032 TargetPosition;
	U032 CurrentPosition;
	
	//read old value
	OldValue=REG_RD32(ClockAddress);
	
	//obtain old pdiv (16 though 18)
	OldPdiv=(OldValue>>16)&0x7;
	
	//obtain the desired Pll value less the Pdiv
	PllValLessPdiv=NewValue&0xffff;
	
	//obtain the desired Pdiv
	NewPdiv=(NewValue>>16)&0x7;
	
	//lookup position of the items we have and want
	ListPosition=GrayCodeLookup(OldPdiv,0);
	TargetPosition=GrayCodeLookup(NewPdiv,ListPosition);
	
	//transition via gray code to desired setting
	for(CurrentPosition=ListPosition;CurrentPosition<=TargetPosition;CurrentPosition++)
	{
		REG_WR32(ClockAddress,(GrayCodeLookupTable[CurrentPosition]<<16)|PllValLessPdiv);
		
		//wait to allow settle before transitioning again
		osDelay(10);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACSTATE.C                                                        *
*   The DAC state is changed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"

VOID enableCursor(PHWINFO, U032);
VOID disableCursor(PHWINFO, U032);

//
// Change DAC hardware state.
//
RM_STATUS stateDac
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            //
            // Only the Dpm Level and APLL are changed here.  All other
            // updates occur in the VBlank interrupt handler.
            //
            if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_VPLL)
            {
                dacCalcPLL(pDev);
                pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_VPLL;
            }

            // NOTE: MCLK and NVCLK updates are done in mcState.c:stateMc
            
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {

                //
                // Program the new DAC settings
                //    
                // NT NOW calls dacSetMode to do the modesets !!! (Miniport no longer sets the mode)
                // However, the NT driver does NOT use the class interface to do the modeset.
                // Instead it calls RmSetMode.

                dacSetMode(pDev, 0);

#ifdef NTRM
                osSetVideoMode(pDev);
#endif                
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);

                pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            
            if (!pDev->Vga.Enabled)
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    enableCursor(pDev, i);
                    pDev->Dac.CrtcInfo[i].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                }
            }
            else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
                
            break;
        case STATE_LOAD:
            //
            // Initialize DAC cursor emulation.
            //
#ifdef NTRM
            for (i = 0; i < MAX_CRTCS; i++)
                pDev->Dac.CrtcInfo[i].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
#else
// Don't turn on cursor until asked to by Windows.
//            pDev->Dac.CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
#endif

            //
            // Make sure we enable the backend video overlay, if req'd
            //
            // KJK: Move this to the new video engine code
            //
            /*
            //
            // New DDraw protocol will enable the overlay on its own
            //
            if ((pDev->Video.Enabled == 1) && !pDev->Vga.Enabled)
                FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            */                

            if (!pDev->Vga.Enabled)
            {
#ifdef NTRM
                osSetVideoMode(pDev);
#endif            
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);
            
                //
                // Load cursor on head 0 only.
                //
                enableCursor(pDev, 0);
                pDev->Dac.CrtcInfo[0].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo

                //
                // Load pallette.
                //
                
				// set flag to update palette in vblank
#ifndef NTRM
                // There is a synchronization issue with NT/Win2K SMP where this code could
                // be running at the same time as the mode set code on another CPU which will
                // cause corruption in the LUT.  This code is, strictly speaking, not necessary 
                // for NT/Win2K.  However, the kernel code is NOT supposed to contain OS dependencies, 
                // so this must be changed to be OS independent.
	            pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_COLORMAP;
#endif            

                //
                // Enable the vertical blank interrupt on primary device.
                // XXXscottl - assume it's on head 0 for now.
                //
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, 0);
                
                pDev->Dac.CrtcInfo[0].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
            }
			else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                    disableCursor(pDev, i);
                }
            }
            break;
        case STATE_UNLOAD:

            // Disable the cursor and the vertical blank interrupt(s).
            //
            for (i = 0; i < MAX_CRTCS; i++)
            {
                disableCursor(pDev, i);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, i);
                DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                pDev->Dac.CrtcInfo[i].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
            }
            break;
        case STATE_INIT:
            initDac(pDev);
            break;
        case STATE_DESTROY:
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\mvision.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Macrovision support **************************\
*                                                                           *
* Module: MVISION.C                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <i2c.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include "mvision.h"


/*;==============================================================================
;
; Function:     HW_SetMacrovisionMode
;
; Purpose:      Sets the current Macrovision capable TV Out device to
;               the requested Macrovision copy protection mode.
;
; Arguments:    
;               
;		
;
; Returns:      
;               
;
;==============================================================================*/

#define REF(proc) (U008*)(&(proc[0]))

/*; First byte is the starting sub-address*/
U008 BtNtscMVDataMode0[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x00, 0x00};
U008 BtNtscMVDataMode1[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x67, 0xB5, 0x90, 0xB2, 0x7D, 0x63, 0x00};
U008 BtNtscMVDataMode2[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x6C, 0x31, 0x92, 0x32, 0xDD, 0xE3, 0x00};
U008 BtNtscMVDataMode3[] =  {0xDA, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C,
			    0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0xE3, 0x00};

U008 *BtNtscModeTable[] = {
    REF(BtNtscMVDataMode0), REF(BtNtscMVDataMode1), REF(BtNtscMVDataMode2), REF(BtNtscMVDataMode3)
};

U008 BtPalMVDataMode0[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, 0x00};
U008 BtPalMVDataMode1[]	=   {0xDA, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F,
			    0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x63, 0x00};

U008 *BtPalModeTable[] = {
    REF(BtPalMVDataMode0), REF(BtPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 PhNtscMVDataMode0[] =  {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhNtscMVDataMode1[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode2[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x1E, 0xC0, 0x03, 0x11, 0xC0, 0x04, 0x26, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x11, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 PhNtscMVDataMode3[] =  {0x5D, 0x1B, 0xC0, 0x5E, 0x0E, 0xC0, 0x5F, 0x2E, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xE8, 0x16,
			    0x01, 0x18, 0xC0, 0x03, 0x15, 0xC0, 0x04, 0x22, 0xC0, 0x05, 0x0A, 0x00, 0x06, 0xC5, 0x00,
			    0x07, 0xFF, 0x00, 0x08, 0x03, 0xFC, 0x10, 0x15, 0xC0, 0x11, 0xAD, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x0F, 0x00, 0x15, 0x78, 0x80, 0x20, 0x9B, 0x40, 0x21, 0x04, 0x00, 0x24, 0x00, 0x00,
			    0x25, 0x00, 0x80, 0x30, 0x1B, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0x0F, 0x00, 0x36, 0x0F, 0x00, 0xFF};

U008 *PhNtscModeTable[] = {
    REF(PhNtscMVDataMode0), REF(PhNtscMVDataMode1), REF(PhNtscMVDataMode2), REF(PhNtscMVDataMode3)
};

U008 PhPalMVDataMode0[] =   {0x5D, 0x3A, 0xC0, 0x5E, 0x2E, 0xC0, 0x7D, 0x00, 0x16, 0xFF};

U008 PhPalMVDataMode1[] =   {0x5D, 0x17, 0xC0, 0x5E, 0x19, 0xC0, 0x5F, 0x35, 0xC0, 0x60, 0x40, 0x80, 0x7D, 0xC8, 0x16,
			    0x01, 0x1B, 0xC0, 0x03, 0x22, 0xC0, 0x04, 0x2B, 0xC0, 0x05, 0x08, 0x00, 0x06, 0x74, 0x00,
			    0x07, 0x55, 0x00, 0x08, 0x01, 0xFC, 0x10, 0x22, 0xC0, 0x11, 0x15, 0x00, 0x12, 0x60, 0x00,
			    0x14, 0x07, 0x00, 0x15, 0x7E, 0x80, 0x20, 0xBB, 0x40, 0x21, 0x72, 0x00, 0x24, 0x02, 0x00,
			    0x25, 0x54, 0x80, 0x30, 0x2C, 0xC0, 0x31, 0x04, 0xF8, 0x33, 0xFE, 0x00, 0x36, 0x7E, 0x00, 0xFF};

U008 *PhPalModeTable[] = {
    REF(PhPalMVDataMode0), REF(PhPalMVDataMode1)
};

/*;Format is:  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND,  REG, OR, AND*/
U008 Ch_PAL_Mode00_APS1[] = { /*; MODE 0 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x2E,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0x9F,0x00,0x2D,0x9F,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xBA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x40,0x80,
        0x2B,0x10,0x0F,0x31,0x0A,0x00,0x32,0xEE,0x00,0x33,0x26,0x80,0x34,0x2A,0x80,0x35,0x7E,0x00,
        0x36,0x9A,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_APS0[] = { /*; MODE 0 APS=00*/
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS3[] = { /*; MODE3 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS2[] = { /*; MODE3 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x98,0x00,0x2D,0x98,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xBB,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x4A,0x80,
        0x2B,0x00,0x0F,0x31,0xBD,0x00,0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,
        0x36,0xBD,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode03_APS1[] = { /*; MODE3 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x30,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x4A,0x80,0x2B,0x00,0x0F,0x31,0xBD,0x00,
        0x32,0xBD,0x00,0x33,0x37,0x80,0x34,0x37,0x80,0x35,0xBD,0x00,0x36,0xBD,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_APS0[] = { /*; MODE3 APS=00 */
        0x10,0x00,0x0F,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,0x3D,0x00,0xF8,0xFF
};

U008 Ch_PAL_Mode08_APS1[] = { /*; MODE 8 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x37,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xBD,0x00,0x2D,0xBD,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xDE,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x4C,0x80,
        0x2B,0x30,0x0F,0x31,0x3C,0x00,0x32,0x1B,0x00,0x33,0x2E,0x80,0x34,0x32,0x80,0x35,0x96,0x00,
        0x36,0xB7,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS3[] = { /*; MODE11 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS2[] = { /*; MODE11 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0x67,0x00,0x2D,0x67,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xE2,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x59,0x80,
        0x2B,0xF0,0x0F,0x31,0x08,0x00,0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,
        0x36,0x08,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode11_APS1[] = { /*; MODE11 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x30,0x07,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x59,0x80,0x2B,0xF0,0x0F,0x31,0x08,0x00,
        0x32,0x08,0x00,0x33,0x42,0x80,0x34,0x42,0x80,0x35,0x08,0x00,0x36,0x08,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_PAL_Mode14_APS1[] = { /*; MODE 14 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x3A,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x00,0xF0,0x2C,0xC8,0x00,0x2D,0xC8,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0xEA,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x50,0x80,
        0x2B,0x30,0x0F,0x31,0x4C,0x00,0x32,0x29,0x00,0x33,0x30,0x80,0x34,0x34,0x80,0x35,0x9D,0x00,
        0x36,0xC0,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode17_APS3[] = { /*; MODE17 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS2[] = { /*; MODE17 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x01,0xF0,0x2C,0xAE,0x00,0x2D,0xAE,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0xD6,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x54,0x80,
        0x2B,0x00,0x0F,0x31,0xFA,0x00,0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,
        0x36,0xFA,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0x08,0x30,0x07,0xFF
};

U008 Ch_NTSC_Mode17_APS1[] = { /*; MODE17 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x37,0x00,0x06,0x80,0x7F,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x54,0x80,0x2B,0x00,0x0F,0x31,0xFA,0x00,
        0x32,0xFA,0x00,0x33,0x3F,0x80,0x34,0x3F,0x80,0x35,0xFA,0x00,0x36,0xFA,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,
	0x08,0x30,0x07,0xFF
};

U008 Ch_PAL_Mode20_APS1[] = { /*; MODE20 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x6C,0x00,0x04,0x00,0x7F,0x05,0x47,0x00,0x08,0x18,0x07,
        0x0C,0x33,0x00,0x0E,0x40,0x3F,0x16,0x38,0x00,0x2B,0x08,0xF0,0x2C,0xF3,0x00,0x2D,0xF3,0x00,
        0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x1C,0x00,0x0D,0x80,0x0F,0x0F,0x22,0xC0,0x13,0x40,0x1F,
        0x18,0x20,0x0F,0x19,0xA0,0x0F,0x1A,0x20,0x0F,0x2F,0x9B,0x00,0x30,0x64,0x00,0x2A,0x61,0x80,
        0x2B,0x30,0x0F,0x31,0x94,0x00,0x32,0x6A,0x00,0x33,0x3B,0x80,0x34,0x40,0x80,0x35,0xC0,0x00,
        0x36,0xEA,0x00,0x37,0x3F,0x80,0x38,0xE0,0x00,0x39,0x15,0x80,0x3A,0x40,0x00,0x3B,0xFE,0x00,
        0x3C,0x7E,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS3[] = { /*; MODE24 APS=11*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xB0,0x0F,0x0F,0x15,0xC0,0x13,0x80,0x1F,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2F,0x98,0x00,0x30,0x29,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS2[] = { /*; MODE24 APS=10*/
        0x10,0xF0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x2B,0x09,0xF0,0x2C,0xDD,0x00,0x2D,0xDD,0x00,
        0x11,0xC8,0x07,0x12,0xFF,0x00,0x2E,0x11,0x00,0x0D,0xD0,0x0F,0x0F,0x11,0xC0,0x13,0x40,0x1F,
        0x18,0x10,0x0F,0x19,0x50,0x0F,0x1A,0x10,0x0F,0x2F,0x9E,0x00,0x30,0x2D,0x00,0x2A,0x6B,0x80,
        0x2B,0xF0,0x0F,0x31,0x3F,0x00,0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,
        0x36,0x3F,0x00,0x37,0x0F,0x80,0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,
        0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 Ch_NTSC_Mode24_APS1[] = { /*; MODE24 APS=01*/
        0x10,0xE0,0x0F,0x01,0x80,0x3F,0x02,0x0B,0x00,0x04,0x40,0x3F,0x05,0x40,0x00,0x06,0x80,0x7F,
	0x08,0x30,0x07,0x1B,0x0B,0xF0,0x1C,0x04,0xF0,0x1D,0x01,0xF0,0x1E,0x06,0xF0,0x1F,0x05,0xF0,
        0x0C,0x05,0x00,0x0E,0x40,0x3F,0x16,0x0D,0x00,0x11,0x00,0x07,0x12,0x00,0x00,0x2E,0x00,0x00,
        0x18,0x50,0x0F,0x19,0x50,0x0F,0x1A,0x50,0x0F,0x2A,0x6B,0x80,0x2B,0xF0,0x0F,0x31,0x3F,0x00,
        0x32,0x3F,0x00,0x33,0x50,0x80,0x34,0x50,0x80,0x35,0x3F,0x00,0x36,0x3F,0x00,0x37,0x0F,0x80,
        0x38,0xF0,0x00,0x39,0x00,0x80,0x3A,0x00,0x00,0x3B,0x0F,0x00,0x3C,0x0F,0x00,0x3D,0x05,0xF8,0xFF
};

U008 *Ch_PAL_Table[] = { /*; PAL formats only support APS=01*/
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1), REF(Ch_PAL_Mode00_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1), REF(Ch_PAL_Mode08_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1), REF(Ch_PAL_Mode14_APS1),
        REF(Ch_PAL_APS0), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1), REF(Ch_PAL_Mode20_APS1)
};

U008 *Ch_NTSC_Table[] = { /*; NTSC formats support all Macrovision modes*/
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode03_APS1), REF(Ch_NTSC_Mode03_APS2), REF(Ch_NTSC_Mode03_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode11_APS1), REF(Ch_NTSC_Mode11_APS2), REF(Ch_NTSC_Mode11_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode17_APS1), REF(Ch_NTSC_Mode17_APS2), REF(Ch_NTSC_Mode17_APS3),
        REF(Ch_NTSC_APS0), REF(Ch_NTSC_Mode24_APS1), REF(Ch_NTSC_Mode24_APS2), REF(Ch_NTSC_Mode24_APS3)
};

U032 CH_Mode_Table[] = { 512, 384, 640, 400, 640, 480, 800, 600, 0 };

RM_STATUS ReadChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	*pData
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto RCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto RCR_Exit;

    /*  Next generate a RESTART and the DEVICE ID with READ */
    i2cStart(pDev, Head, dwPort);
    if ( i2cSendByte(pDev, Head, dwPort, (U008)(TVOutDeviceAddr+1)) )
		goto RCR_Exit;

    /* Finally, READ the data from the device */
    if( i2cReceiveByte(pDev, Head, dwPort, pData, 1) == -1 )
		goto RCR_Exit;

	rmStatus = RM_OK;

RCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS WriteChRegister(
    PHWINFO pDev,
    U032    Head,
    U032    dwPort,
    U008    TVOutDeviceAddr,
	U008	RegNum,
	U008	Data
	)
{
    RM_STATUS   rmStatus = RM_ERROR;

    i2cStart(pDev, Head, dwPort);

    /* First generate the DEVICE ID with WRITE */
    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
		goto WCR_Exit;

    /* Next generate the REGISTER ADDRESS */
    if ( i2cSendByte(pDev, Head, dwPort, RegNum) )
		goto WCR_Exit;

    /*  Finally, WRITE the DATA */
    if ( i2cSendByte(pDev, Head, dwPort, Data) )
		goto WCR_Exit;

	rmStatus = RM_OK;

WCR_Exit:
    i2cStop(pDev, Head, dwPort);
	return rmStatus;
}

RM_STATUS SetMacrovisionMode(
    PHWINFO pDev,
    U032    Head,
    RM_MACROVISION_CONTROL	*pCtrl
    )
{
    RM_STATUS   rmStatus;
    U032        dwCount;
    U008        *pReg, data, tb, brValue = 0;
    U032        i; 
    U032        dwNewMode, dwChangeBrightness, dwPort, dwEncoderType, dwTVStandard;
    U008        TVOutDeviceAddr;

    rmStatus = RM_OK;

    TVOutDeviceAddr = (U008)pCtrl->devAddr;
    dwNewMode = pCtrl->mode & 0x3;
	dwChangeBrightness = pCtrl->mode & 0x4;
    dwPort = pCtrl->port;
    dwEncoderType = pCtrl->encoderType;
    dwTVStandard = pCtrl->tvStandard;

    pCtrl->status = RM_OK;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }

    switch( dwEncoderType )
    {
	default:
#ifdef DEBUG
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown encoder type");
        DBG_BREAKPOINT();
#endif
	case NV_ENCODER_BROOKTREE_868:
	case NV_ENCODER_CHRONTEL_7003:
	case NV_ENCODER_CHRONTEL_7006:
	case NV_ENCODER_CHRONTEL_7008:
	    /* Macrovosion not supported */
	    pCtrl->status = RM_ERROR;
	    return RM_ERROR;

	case NV_ENCODER_BROOKTREE_869:
	case NV_ENCODER_BROOKTREE_871:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                dwNewMode = 3;
		    pReg = BtNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                dwNewMode = 1;
		    pReg = BtPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
            return RM_ERROR;
	    }

	    /*
	     * Unlock CRTC extended regs
	     */
	    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        i2cStart(pDev, Head, dwPort);
	    
	    /* First generate the DEVICE ID with WRITE */
	    if ( i2cSendByte(pDev, Head, dwPort, TVOutDeviceAddr) )
	    {
            pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
            break;
	    }

        /* Now, write the data */
	    for (dwCount = 0; dwCount < 19; dwCount++)
        {
            if ( i2cSendByte(pDev, Head, dwPort, pReg[dwCount]) )
            {
                pCtrl->status = RM_ERROR;
                rmStatus = RM_ERROR;
                break;
            }
        }

        i2cStop(pDev, Head, dwPort);
	    break;

	case TV_ENCODER_PHILIPS:
	case NV_ENCODER_PHILIPS_7102:
	case NV_ENCODER_PHILIPS_7103:
	case NV_ENCODER_PHILIPS_7108:
	case NV_ENCODER_PHILIPS_7109:

	    switch( dwTVStandard)
	    {
		case NTSC_M:
		case NTSC_J:
			brValue = 0;
		    /* Limit MV mode to [0,3] */
		    if( dwNewMode > 3 )
                dwNewMode = 3;
		    pReg = PhNtscModeTable[dwNewMode];
		    break;

		case PAL_M:
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue = 0;
		    /* Limit MV mode to 0 or 1 */
		    if( dwNewMode > 1 )
                dwNewMode = 1;
		    pReg = PhPalModeTable[dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
            return RM_ERROR;
	    }

		goto CommonForPhilipsAndChrontel;

	case NV_ENCODER_CHRONTEL_7005:
	case NV_ENCODER_CHRONTEL_7007:

	    for( i=0; ;i++ )
	    {
            if( !CH_Mode_Table[i*2] )
            {
                pCtrl->status = RM_ERROR;
                return RM_ERROR;
            }

            if( CH_Mode_Table[i*2] == pCtrl->resx && CH_Mode_Table[i*2+1] == pCtrl->resy )
                break;
	    }

	    dwNewMode &= 3;
	    switch( dwTVStandard)
	    {
		case NTSC_M:
			brValue = 2;
		case NTSC_J:
			brValue += 22;
		    pReg = Ch_NTSC_Table[i*4+dwNewMode];
		    break;

		case PAL_M:
			brValue = 2;
		case PAL_A:
		case PAL_N:
		case PAL_NC:
			brValue += 22;
		    pReg = Ch_PAL_Table[i*4+dwNewMode];
		    break;

		default:
#ifdef DEBUG
		    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Unknown TV Standard");
		    DBG_BREAKPOINT();
#endif
		    pCtrl->status = RM_ERROR;
                    return RM_ERROR;
	    }

CommonForPhilipsAndChrontel:
	    /*
	     * Unlock CRTC extended regs
	     */
	    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

	    for(; *pReg != 0xFF; pReg += 3 )
	    {
            data = 0;
            if( *(pReg+2) != 0 )
            {
				if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, &data) != RM_OK)
				{
			        pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
					break;
				}
            }

            tb = data;
            data = (data & *(pReg+2)) | *(pReg+1);

            if ( data == 0 || data != tb )
            {
				if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, *pReg, data) != RM_OK)
				{
			        pCtrl->status = RM_ERROR;
                    rmStatus = RM_ERROR;
					break;
				}
            }
	    }

		if(brValue == 0 || dwChangeBrightness == 0)
			break;

		/* Increase or decrease brightness */
		if(ReadChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, &data) != RM_OK)
		{
			pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
			break;
		}

        data = (U008)(dwNewMode ? data - brValue : data + brValue);
		if(WriteChRegister(pDev, Head, dwPort, TVOutDeviceAddr, 0x09, data) != RM_OK)
        {
            pCtrl->status = RM_ERROR;
            rmStatus = RM_ERROR;
            break;
        }

	    break;

    }

    /* Lock CRTC extended regs */
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\i2c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* I2C Control *******************************\
*                                                                           *
* Module: I2C.C                                                             *
*   The I2C port is managed within this module.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include "i2c.h"

#include <nvmisc.h>

//---------------------------------------------------------------------------
//
//  I2C support routines.
//
//---------------------------------------------------------------------------

// Serial Port Bits
#define I2C_SRCK        0x20    // Serial Clock write
#define I2C_SRD         0x10    // Serial Data  write
#define I2C_SRCK_IN     0x04    // Serial Clock read
#define I2C_SRD_IN      0x08    // Serial Data  read
#define I2C_ENABLE      0x01    // Enable Serial Port Function

///////////////////////////////////////////////////////////////////

// Constants used by I2C Protocoll:

#define SDA_REG         0x02
#define SCL_REG         0x01


#define ACK             0   // I2C Acknowledge
#define NACK            1   // I2C No Acknowledge

	
// Module Global Variables

// variables could be modified via INI file
// U008 iniFlag = FALSE;
#ifdef  IKOS
U032 wMaxWaitStates=2;     // max wait states for I2C bus syncronisation
#else   // IKOS
U032 wMaxWaitStates=3000;  // max wait states for I2C bus syncronisation
#endif  // IKOS
U032 wGpo=0;               // GPO bits for switching to I2C operation

//
// Insure register updates have been flushed out of the write buffer
// by performing a cpuid instruction
//
// XXX this should be in common/nvUtil/ or somewhere else
#ifdef WIN31

#ifdef NEWWIN31

void __cdecl FlushWB(void)
{
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
}

#else  //old win31

void FlushWB(void);
#pragma aux FlushWB =				\
            "mov    EAX, 0x0"			\
            0x0F 0xA2
#endif

#elif defined(__PPC__)

void FlushWB(void)
{
    __eieio();
}


#elif defined(__GNUC__)		// UNIX and DJPP
void FlushWB(void)
{
    // save regs (especially ebx) that might get stomped by 'cpuid'
    __asm__("push %esi");
    __asm__("push %edi");
    __asm__("push %ebx");
        __asm__("xorl %eax, %eax");
        __asm__("cpuid");
    __asm__("pop %ebx");
    __asm__("pop %edi");
    __asm__("pop %esi");
}

#else   // !WIN31 !UNIX !DJPP

void __cdecl FlushWB(void)
{
// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
#endif // IA-64 cannot tolerate inline asm
}

#endif

void i2cWriteCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 data
)
{
    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_WR(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_WR(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_WR(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
}

   
U008 i2cReadCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
    return data;
}
   

U008 i2cReadCRTCStatusIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryStatusIndex, data, Head);
        break;
    }
    return data;
}

U008 i2cHardwareInit
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    //
    // If the initialization has already been done then just return
    //
    // if (iniFlag == TRUE)
    //    return TRUE;

    i2cWriteCRTCWrIndex(pDev, Head, portID, 0x31);
	
	pDev->Dac.I2cIniFlag = TRUE;
	return TRUE;
}


VOID i2cWriteCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg,
    U008 bit
)
{
    U008 data;

    //
    // Get the current status and toggle
    //
	data = i2cReadCRTCWrIndex(pDev, Head, portID);

	data &= 0xf0;
    data |= I2C_ENABLE;
    
    if (reg == SCL_REG)
    {
      if (bit)
        data |=  I2C_SRCK;
      else
        data &= ~I2C_SRCK;
    }
    else
    {
      if (bit)
        data |=  I2C_SRD;
      else
        data &= ~I2C_SRD;
    }    

	i2cWriteCRTCWrIndex(pDev, Head, portID, data);
    FlushWB();
}

U008 i2cReadCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg
)
{
    U008 data;
   
    data = i2cReadCRTCStatusIndex(pDev, Head, portID);    

    if (reg == SCL_REG)
        return ( (data & I2C_SRCK_IN) != 0);
    else
        return ( (data & I2C_SRD_IN) != 0);
}
   
/**********************************************************************/

VOID ReadSDA(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SDA_REG);
}

VOID ReadSCL(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SCL_REG);
}   

VOID SetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 1);
}

VOID ResetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 0);
}

VOID SetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 1);
}

VOID ResetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 0);
} 
 
/*
 * waits for a specified line til it goes high
 * giving up after MAX_WAIT_STATES attempts
 * return:  0 OK
 *         -1 fail (time out)
 */
U008 WaitHighSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        ReadSDA(pDev, Head, portID, &data_in);      // wait for the line going high
        if (data_in)
            break;
        tmrDelay(pDev, 5000);         // 5us delay    
    } while (--retries);        // count down is running

    if (!retries)
        return((U008)-1);
    return 0;
}                    

U008 WaitHighSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        tmrDelay(pDev, 1000);              // 1.0 us delay    
        ReadSCL(pDev, Head, portID, (U008 *)&data_in);   // wait for the line going high
        if (data_in)
            break;
    } while (--retries);            // count down is running

    if (!retries)
        return((U008)-1);
    return(0);    
}


VOID i2cStart(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 5000); SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, 5000);
    ResetSCLLine(pDev, Head, portID);
}


VOID i2cStop(PHWINFO pDev, U032 Head, U032 portID)
{
    tmrDelay(pDev, 200000);
    ResetSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, 5000); SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID); 
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 5000);
}


/*
 * I2cAck() returns 1: fail
 *                  0: acknolege
 */

U008 i2cAck(PHWINFO pDev, U032 Head, U032 portID)
{
    U008 ack;

    ResetSCLLine(pDev, Head, portID); tmrDelay(pDev, 5000);
    SetSDALine(pDev, Head, portID); tmrDelay(pDev, 5000);
    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    ReadSDA(pDev, Head, portID, &ack);
    ResetSCLLine(pDev, Head, portID);
    return (ack);
}


VOID i2cInit(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
}


U008 i2cSendByte(PHWINFO pDev, U032 Head, U032 portID, U008 byte)
{
    U008 i;

    for (i=0;i<8;i++)
    {
	    ResetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, 2500);
        if (byte & 0x80)
		    SetSDALine(pDev, Head, portID);
	    else
		    ResetSDALine(pDev, Head, portID);
	    tmrDelay(pDev, 2500);
	    SetSCLLine(pDev, Head, portID); WaitHighSCLLine(pDev, Head, portID);
	    byte <<= 1;
    }
    
    return (i2cAck(pDev, Head, portID));
}


RM_STATUS i2cReceiveByte(PHWINFO pDev, U032 Head, U032 portID, U008 *byte, U008 ack)
{
    U008 data=0;
    U008 i;
    RM_STATUS status;

    ResetSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 1000);

    for (i=0;i<8;i++)
	{
	    ResetSCLLine(pDev, Head, portID);
	    ResetSCLLine(pDev, Head, portID);	/* this second reset seems to be needed, why? (jsun) */
	    SetSCLLine(pDev, Head, portID); 
        status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
        if (status != RM_OK)
            goto done;

	    ReadSDA(pDev, Head, portID, &data);
	    *byte <<= 1;
	    *byte  |= (data == 1);
	}

    ResetSCLLine(pDev, Head, portID);
    if (ack) 
    {
        SetSDALine(pDev, Head, portID);         // send Nack
	tmrDelay(pDev, 1000);
    }
    else
        ResetSDALine(pDev, Head, portID);       // send Ack
    
    SetSCLLine(pDev, Head, portID); 
    status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
    ResetSCLLine(pDev, Head, portID);

done:
    return status;
}


RM_STATUS i2cWrite(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            goto done;
        }
    }
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cSend(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data, U032 NoStopFlag)
{

    if ( ChipAdr ) {
        //
        // Enable writes to the I2C port
        //
        i2cHardwareInit(pDev, Head, portID);

        i2cStart(pDev, Head, portID);
        if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
        {
            i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }

    if ( NoStopFlag == 0 )
        i2cStop(pDev, Head, portID);

    return(RM_OK);
}


RM_STATUS i2cWrite_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1));        // send chip adr. with write bit
    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }
    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}


RM_STATUS i2cRead_ALT2(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            i2cStop(pDev, Head, portID);                      // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    i2cStop(pDev, Head, portID);
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }

    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}

RM_STATUS i2cAccess
(
    PHWINFO pDev,
    U032 Head,
    NVRM_I2C_ACCESS_CONTROL    *pCtrl
)
{

    RM_STATUS rmStatus = RM_OK;

    U032	startFlag;
    U032	stopFlag;
    U032	ackFlag;
    U032	port;
    U008	data = 0;

    /*
     * verify the token
     *
     * NOTE: we allow I2C Access if the token is 0 AND no one
     * else has acquired it.  The idea is that 3rd party vendors
     * will not be able to acquire/lock I2C; however, we can still
     * acquire/lock I2C internally and lock 3rd party access out.
     * The reason is that we don't a 3rd party app to crash while
     * still holding a lock on I2C and thus lock us out from internal
     * access.  We have priority in this scheme and 3rd party
     * apps must deal with contention by checking return codes for
     * errors.
     */
     
    if(pDev->Power.State == MC_POWER_LEVEL_3)
    {
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Attempted I2C access before waking up. Invalid request denied.\n");
    
    	//if we are at a state of power management, we need to reject this call
    	return NVRM_I2C_ACCESS_STATUS_ERROR;
    }
     
    if ((pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_NULL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_RESET) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SCL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SCL)) {

        if (pCtrl->token != pDev->I2CAcquired) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            return RM_ERROR;
        }

    }

    /*
     * Unlock CRTC extended regs
     */

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    /*
     * retrieve the flags and port
     */

    startFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_START;
    stopFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_STOP;
    ackFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_ACK;

    if ( pCtrl->port == NVRM_I2C_ACCESS_PORT_PRIMARY ) {
        port = NV_I2C_PORT_PRIMARY;
    }
    else {
        port = NV_I2C_PORT_SECONDARY;
    }

    /*
     * handle the command
     */

    pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;

    switch ( pCtrl->cmd ) {

      case NVRM_I2C_ACCESS_CMD_ACQUIRE:

        if ( pDev->I2CAcquired ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0xbeeffeed; /* arbtrary */
            pCtrl->token = pDev->I2CAcquired;
            i2cHardwareInit(pDev, Head, port);
        }

        break;

      case NVRM_I2C_ACCESS_CMD_RELEASE:

        if ( pDev->I2CAcquired != pCtrl->token ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0;
            pCtrl->token = 0;
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;
        }

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        data = (U008)(pCtrl->data);
        if ( i2cSendByte(pDev, Head, port,data) ) {
            i2cStop(pDev, Head, port);
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
            rmStatus = RM_ERROR;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        // check for restart read 
        if ( startFlag ) {
            data = (U008)(pCtrl->data);
            if ( i2cSendByte(pDev, Head, port,data) ) {
                i2cStop(pDev, Head, port);
                pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
                rmStatus = RM_ERROR;
            }
        }
        else {
            i2cReceiveByte(pDev, Head, port, &data, (U008)((ackFlag) ? 0 : 1));
            pCtrl->data = data;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_NULL:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_RESET:

        i2cStop(pDev, Head, port);

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_SDA:

        ReadSDA(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_READ_SCL:

        ReadSCL(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_SDA:

        if ( pCtrl->data ) {
            SetSDALine(pDev, Head, port);
        }
        else {
            ResetSDALine(pDev, Head, port);
        }

      case NVRM_I2C_ACCESS_CMD_WRITE_SCL:

        if ( pCtrl->data ) {
            SetSCLLine(pDev, Head, port);
        }
        else {
            ResetSCLLine(pDev, Head, port);
        }

        break;

      default:

        pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
        rmStatus = RM_ERROR;
        break;

    }

    /* Lock CRTC extended regs */
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);

    return rmStatus;

}

#if 0

///////////////////////////////////////////////////////////////////////////////////////
//
// The following routines were rewritten to not use the NV timer for 
// self-timing.  Don't use them, but keep them around in case we do need them 
// in the future.
//

//
//  delay
//
i2cdelay(int count)
{
	while(count) 
    {
        _asm {
            push dx
            mov  dx,0x80
            in   al,dx
            pop  dx
        }
		count--;
	}
}

//****************************************************************************************
//
//  Send a byte out the I2C interface
int sendbyte(int serial_data) {
	int i, rval=0;
	int readback=0 ; // clear the readback byte
	int r;

    r=0;

// send the bits
	for (i=128; i>=1; i=i/2)
    {

//set the data with clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// set clock hi
		if (serial_data & i) 
			DDCout(clock1_hi);
		else
			DDCout(clock1_lo);
		i2cdelay(I2C_DELAY);

// read the data port
#if DEBUG4
		r=input(read_port) ; printf ("port= %x",r);
		r=~r ; printf (", inv, %x",r);
		r=r & SDATA ; printf (", \&, %x",r);
		r=r/2 ; printf (", div, %x",r);
		r=r*i ; printf (", bit #, %x",r);
		readback=readback+r ; printf (", readback=%x \n",readback);
#else
		readback+=i * ( ( (~DDCin() ) & SDATA) >> SDATA_BIT ) ;  // read data in case this is a read
#endif

//return the clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);
	}

// ack bit
	DDCout(ack_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(ack_state1);
	i2cdelay(I2C_DELAY);

#if DEBUG2
	if ((input(read_port) & 0x02)) printf(" ack\n");
	else printf(" no ack\n");
#endif

	if ((DDCin() & data_in)) rval=ERR_I2C_COMM;	// return a fail.

//	printf (" readback=%x \n", readback );
	DDCout(ack_state2);
	i2cdelay(I2C_DELAY/2);
//   DDCout(i2c_state0);                 // bring both high
	return rval;
}

//****************************************************************************************
//
//  read a byte from the I2C interface
//  this is almost identical to the send byte function
int readbyte(int *read_data) {
	int i, rval=0;
	int readback=0 ; // clear the readback byte
    int serial_data = 0xff;
	int r;

    r=0;

// send the bits
	for (i=128; i>=1; i=i/2)
    {

// send all 1's, which tristates the line, and read back what the encoder is driving
//set the data with clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// set clock hi
		if (serial_data & i) 
			DDCout(clock1_hi);
		else
			DDCout(clock1_lo);
		i2cdelay(I2C_DELAY);

//return the clock low
		if (serial_data & i) 
			DDCout(clock0_hi);
		else
			DDCout(clock0_lo);
		i2cdelay(I2C_DELAY/2);

// read the data port
		readback+=i * ( ( (DDCin() ) & SDATA) >> SDATA_BIT) ;  
	}

// ack bit
	DDCout(ack_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(ack_state1);
	i2cdelay(I2C_DELAY);

	if ((DDCin() & data_in)) rval=ERR_I2C_COMM;	// return a fail.

//	printf (" readback=%x \n", readback );
	DDCout(ack_state2);
	i2cdelay(I2C_DELAY/2);
//   DDCout(i2c_state0);                 // bring both high
    *read_data = readback;
	return rval;
}

//****************************************************************************************
//
void clockStart() {	// creates the start condition

#if DEBUG3
      output(write_port,0x0C); // create a strobe on pin 16 & 17
	i2cdelay(I2C_DELAY);
#endif
	DDCout(i2c_state0);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state1);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state2);
	i2cdelay(I2C_DELAY/2);

}

//****************************************************************************************
//
void clockEnd() {	// creates the end condition

	DDCout(i2c_state2);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state1);
	i2cdelay(I2C_DELAY/2);
	DDCout(i2c_state0);
	i2cdelay(I2C_DELAY/2);
}

//****************************************************************************************
//
VOID DDCout(U008 data)
{
    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, data);
}

//****************************************************************************************
//
U008 DDCin()
{
U008 data;

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX, data);
    return data;
}

/////////////////////////////////////////////////////////////////////

#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv10\dacnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

//#include <nvd3dmac.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//LPL - memo to myself
// - clean-up to do: may not need default settings when pVidLutCurDac ptrs NULL.
// - clean up bpp overrides
// - with new top-of-buffer lwm approach, can some of the math be simplified?
// - does setting lwm based on pre-clipped burst size cause discrepancies?

//#define NV11_DEBUG

#ifdef NV11_DEBUG
U032 nv11Aware = 1;    //debug toggle between nv10/nv11 arb fns
#endif  //#ifdef NV11_DEBUG

//////////////////////////////////////////
//
// NV 11 arbitration routines
//

U032
adjust_scaler_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}

//LPL Moved from init.c area.
void
check_scaler_burstsize(scaler_t *scaler)
{
  U032 raw;

  if (!(scaler->enable)) 
    return;

  raw = adjust_scaler_burstsize(scaler->burst_size, scaler->min_burst_size, scaler->max_burst_size);

  if (raw != scaler->burst_size)
    scaler->burst_size = raw;
}


// Data structure init routines

void
check_crtc_burstsizes(crtc_t *crtc)
{
  U032 raw = crtc->burst_size;
  
  if (!crtc->enable) return;
 
  /* crtc burst sizes are a multiple of 16 bytes */
  raw = (raw + 15) / 16 * 16;
  /* burst sizes step by 16 up to 2048 bytes*/
  if (raw > crtc->max_burst_size)
    raw = crtc->max_burst_size;
  if (raw != crtc->burst_size)
    crtc->burst_size = raw;
}

void
init_crtc(crtc_t *crtc,
      U032 enable,
      U032 hres,
      U032 vres,
      U032 depth,
      U032 refresh,
      U032 request_delay_mclks,
      U032 request_delay_pclks,
      U032 burst_size,
      U032 min_burst_size,
      U032 max_burst_size,
      U032 cursor_burst_size,
      U032 pclk,
      U032 htotal,
      mem_t *mem
      )
{
  crtc->fifo.lwm = 0;
  crtc->enable = enable;
  crtc->hres = hres;
  crtc->vres = vres;
  crtc->depth = depth;
  crtc->drain_rate = depth*100 / 8;
  crtc->refresh = refresh;
  crtc->pclk = pclk;
  crtc->pclk_period = 1000000 / crtc->pclk; //now in ps, no longer ns
  crtc->request_delay = request_delay_mclks * mem->mclk_period + request_delay_pclks * crtc->pclk_period;
  crtc->burst_size = burst_size;
  crtc->min_burst_size = min_burst_size;
  crtc->max_burst_size = max_burst_size;
  crtc->cursor_burst_size = cursor_burst_size;
  /* make sure set burst sizes are legitimate */
  check_crtc_burstsizes(crtc);
  crtc->fifo.size = 0;
  crtc->hclk_period = crtc->pclk_period * htotal / 1000;
}

void
init_scaler(scaler_t *scaler,
        crtc_t *crtc,
        crtc_t *crtc2,
        U032 nvclk,
        U032 enable,
        U032 source_hres,
        U032 source_vres,
        U032 h2_owns_vs,
        U032 depth,
        U032 hres,
        U032 vres,
        U032 burst_size,
        U032 min_burst_size,
        U032 max_burst_size,
        U032 request_delay_nvclks,
        U032 request_delay_pclks,
        U032 max_fifo_size
        )
{
  if (h2_owns_vs)
    scaler->pclk_period = crtc2->pclk_period;
  else
    scaler->pclk_period = crtc->pclk_period;

  scaler->h2_owns_vs    = h2_owns_vs;
  scaler->max_fifo_size = max_fifo_size;
 
  scaler->enable = enable;
  if (!enable) {
    scaler->burst_size = 0;
    return;
  }
  scaler->depth = depth;

  scaler->source_hres = source_hres;
  scaler->source_vres = source_vres;

  /* assume full screen scaling */
  scaler->window_hres = (h2_owns_vs) ? crtc2->hres : crtc->hres;
  scaler->window_vres = (h2_owns_vs) ? crtc2->vres : crtc->vres;

  /* This code does not allow for distorted scaling.
   * I.e., the horizontal and vertical scale factors are 
   * forced to be the same such that the video window is as
   * large as possible on the display without any geometric
   * distortion.
   */
  scaler->hscale = (1000*scaler->window_hres) / scaler->source_hres;
  scaler->vscale = (1000*scaler->window_vres) / scaler->source_vres;
  if (scaler->hscale > scaler->vscale)
    scaler->hscale = scaler->vscale;
  else
    scaler->vscale = scaler->hscale;


  scaler->burst_size = burst_size;
  scaler->min_burst_size = min_burst_size;
  scaler->max_burst_size = max_burst_size;
  scaler->request_delay = request_delay_pclks * scaler->pclk_period + request_delay_nvclks * (1000000 / nvclk);
  /* note that we never read more than the source image,
     even if we're upscaling. that's why we take the MIN
     of 1 and hscale. */
  //scaler->drain_rate = ((scaler->depth / 8)*100000) / MIN(scaler->hscale, 1000);
  scaler->drain_rate = ((scaler->depth / 8)*100000) / ((scaler->hscale < 1000) ? scaler->hscale:1000);
  if ((scaler->vscale < 1000) || 
      ((max_fifo_size != 0) && 
       ((scaler->source_hres*(scaler->depth/8)) > max_fifo_size)
      ) 
     )
    /* we're going to decimate, so we may read 2 new lines for an output line */
    scaler->drain_rate *= 2;
  /* check for a legitimate burst size */
  check_scaler_burstsize(scaler);
  scaler->fifo.size = 0;
  scaler->fifo.lwm  = 0;
}

void
init_mem(mem_t *mem,
     U032 mclk,
     U032 ddr,
     arb_type arbiter,
     U032 partitions,
     U032 partition_data_width,
     U032 page_fault_penalty,
     U032 page_fault_width,
     U032 refresh_penalty,
     U032 arbitration_latency,
     U032 pipeline_latency,
     U032 stall_cycles,
     U032 depth_cmd,
     U032 depth_rw,
     U032 interrupt_rate
     )
{
  mem->mclk = mclk;
  mem->mclk_period = 1000000 / mclk;
  mem->partitions = partitions;
  mem->ddr = ddr;
  mem->arbiter = arbiter;
  mem->data_rate = ((ddr) ? 2 : 1) * partitions * partition_data_width / 8;
  mem->page_fault_penalty = page_fault_penalty;
  mem->page_fault_width = page_fault_width;
  mem->refresh_penalty = refresh_penalty;
  mem->arbitration_latency = arbitration_latency;
  mem->pipeline_latency = pipeline_latency;
  mem->stall_cycles = stall_cycles;
  mem->cmdq_depth_cmd = depth_cmd;
  mem->cmdq_depth_rw = depth_rw;
  /* the first number is the amount of time taken to process all the read/write
     commands; the second is to allow for bus turnaround from read->write.
     the third and fourth allow for two page faults and a refresh in the
     command queue. */
//the command_latency is included in the pipeline_latency of the FBI.
//mem->command_latency = depth_rw * ((ddr) ? 2 : 4) + (depth_rw / 2) + (depth_cmd - 1) * page_fault_penalty + refresh_penalty;
  mem->command_latency = 0;
  mem->interrupt_rate = interrupt_rate;
}

void
init_rtr(rtr_t *rtr,
     U032 burst_size,
     U032 request_delay_mclks,
     mem_t *mem
     )
{
  rtr->burst_size = burst_size;
  rtr->request_delay_mclks = request_delay_mclks;
  rtr->request_delay = request_delay_mclks * mem->mclk_period;
  rtr->latency = 0;
}


// Actual buffer size calculation routines


void
guess_scaler_burstsize(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2)
{
  U032 raw, raw1, raw2;
  
  /* take a simplistic approach to guess this */

  raw1 = ((scaler->drain_rate*1000)/crtc->drain_rate )*crtc->burst_size;
  raw2 = ((scaler->drain_rate*1000)/crtc2->drain_rate)*crtc2->burst_size;
  raw  = (scaler->h2_owns_vs) ? raw2/1000 : raw1/1000;
 
  if (raw < scaler->min_burst_size) raw = scaler->min_burst_size;
  scaler->burst_size = adjust_scaler_burstsize(raw, scaler->min_burst_size, scaler->max_burst_size);
}

U032
adjust_crtc2_burstsize(U032 raw, U032 min, U032 max)
{
  U032 adj;
  
  /* scaler burst sizes are a multiple of min bytes */
  adj = (raw + (min - 1)) / min * min;
  /* max burst size is 2048 bytes */
  if (adj > max)
    adj = max;  
  return adj;
}
    
void
guess_crtc2_burstsize(crtc_t *crtc2, crtc_t *crtc)
{
  U032 raw;
  U032 period_factorx100, drain_factorx100;
  /* take a simplistic approach to guess this */
  period_factorx100 = (100*crtc->pclk_period)/crtc2->pclk_period;
  drain_factorx100  = (100*crtc2->drain_rate)/crtc->drain_rate;
  raw = (crtc->burst_size*period_factorx100*drain_factorx100)/10000;
  if (raw < crtc2->min_burst_size) raw = crtc2->min_burst_size;
  crtc2->burst_size = adjust_crtc2_burstsize(raw, crtc2->min_burst_size, crtc->max_burst_size);
}

/************************************************/
U032
compute_fifo_size(fifo_params *fifo, U032 hres, U032 drain_rate, U032 burst_size, U032 request_delay, U032 dclk_period,
          U032 burst_latency, U032 bursts_during_active, mem_t *mem)
{
  U032 lwm, lwm_min;
  U032 fifo_size;
  U032 bursts_to_fill_lwm;
  
  /* figure out the low water mark in the fifo */
  if (((hres * drain_rate)/100) > (bursts_during_active * burst_size))
    lwm = (hres * drain_rate)/100 - bursts_during_active * burst_size;
  else
    lwm = 0;

  /* make sure we have enough data in the fifo to satisfy the
     initial wait in the active phase */
//LPL need:  NVASSERT((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size) >= 0);
  lwm_min = ((((request_delay + mem->pipeline_latency + mem->command_latency + burst_latency - burst_size)
      * mem->mclk_period) / mem->data_rate) * (drain_rate / dclk_period)
      +99)/100; //forces rounding up, needed because drain_rateis 100x

  //LPL: Eep!  How many loops are possible here?
  while (lwm < lwm_min) {
    lwm += burst_size;
    bursts_during_active--;
  }

  /*added because bursts during active could be more than necessary to fetch a line*/
  bursts_to_fill_lwm = lwm/burst_size;
  if (lwm%burst_size)
    bursts_to_fill_lwm++;

  while (((bursts_to_fill_lwm + bursts_during_active - 1)*burst_size) >= ((hres*drain_rate)/100)) {
    bursts_during_active--;
  }
  
  /* fifo_size is lwm + burst_size */
  fifo_size = lwm + burst_size;

  fifo->lwm_min = lwm_min;
  fifo->lwm     = lwm;
  fifo->size    = fifo_size;

  return bursts_during_active;
}




/************************************************/
/* check to see that we are consuming sufficient bandwidth. this
   is really just an approximation since it only really considers
   the bandwidth consumed by the crtc and scaler. */
U032
not_consuming_sufficient_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem, U032 burst_latency, U032 cursor_latency)
{
  U032 reqd_crtc_bw, reqd_crtc2_bw, reqd_scaler_bw;
  U032 actual_bw;
  U032 error;

  //LPL is this if needed? What's the correct return in case of error?
  //LPL Range check.
  if ((crtc->hclk_period > cursor_latency/1000) && (crtc2->hclk_period > cursor_latency/1000)) {
      reqd_crtc_bw   = (100*crtc->enable)  *crtc->hres *(crtc->depth /8) / (crtc->hclk_period  - cursor_latency/1000);
      reqd_crtc2_bw  = (100*crtc2->enable) *crtc2->hres*(crtc2->depth/8) / (crtc2->hclk_period - cursor_latency/1000);
      reqd_scaler_bw = (100*scaler->enable)*scaler->source_hres * (scaler->depth / 8) * ((scaler->vscale <= 500) ? 2 : 1) / 
                       (crtc->hclk_period - cursor_latency/1000);
      actual_bw = (1000*100*(crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size))
                  / (burst_latency * mem->mclk_period); //x1000000 because other bw as bytes/ns, not bytes/ps
    error = (actual_bw < (reqd_crtc_bw + reqd_crtc2_bw + reqd_scaler_bw)) ? 1 : 0;
  } else {
      error = 0;    //LPL: proper failure?
  }
//  if (actual_bw < 0) error = 0;//overflow in weird cases
  return error;
}

/*makes sure fifo size isn't larger than the maximum*/
U032 test_fifo_constraints(U032 fifo_size, crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler) 
{
  /* If dm ("Display Matrix") isn't specified at the command line, dm
   * (fifo_size here) will be 0.  In this case, no error will be returned since
   * any fifo size is OK.
   */
  if (fifo_size == 0)
    return (0);

  /* Note that fifo.size is initialized to zero for the CRTCs and scaler.
   * So, this function will not return an error just because a fifo size has 
   * yet to be computed.
   */
  return (( crtc->enable  && (crtc->fifo.size   > fifo_size))             || 
          ( crtc2->enable && (crtc2->fifo.size  > fifo_size))             || 
          (scaler->enable && (scaler->fifo.size > scaler->max_fifo_size))   );
}

/* check that there is sufficient total bandwidth available to
   support this resolution. */
U032
insufficient_total_bandwidth(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, mem_t *mem)
{
  U032 error;
  U032 video_bandwidth;
  U032 available_bandwidth;

  video_bandwidth = (crtc->enable  *(crtc->hres  * crtc->vres  * crtc->depth  / 8 ) *  crtc->refresh / 10 + 
                     crtc2->enable *(crtc2->hres * crtc2->vres * crtc2->depth / 8 ) * crtc2->refresh / 10 + 
                     scaler->enable*(scaler->source_hres * scaler->source_vres * 2) *
                       ((scaler->h2_owns_vs)?crtc2->refresh : crtc->refresh) / 10           );

  //LPL: this overflowed before, but switch to /10 and U032 should
  // give us plenty of breathing room
  available_bandwidth = mem->data_rate * mem->mclk * 90000;
  error = (video_bandwidth > available_bandwidth) ? 1 : 0;
  return error;
}

/* check to see that we can read sufficient data during active time assuming LWM is already reached*/
/* ASSUMES that LWM can be filled during blank.  That is, this function should always be used with 
   cant_fill_to_lwm.  Also assumes that bursts_during_active actually fits in active. */
U032
insufficient_data(U032 hres, U032 depth, U032 lwm, U032 bursts_during_active, U032 burst_size)
{
  U032 error;
  error = ((hres * depth / 8) > 
           ((lwm + burst_size - 1) / burst_size + bursts_during_active) * burst_size
          ) ? 1 : 0;
  return error;
}


/**************************************************/
/*use for NV11, NV20 and onward*/
/*should also be used for scaler NV10 onward*/
U032
new_cant_fill_to_lwm(crtc_t *crtc, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;

#if 1//def TWINHEAD_OPTS
    U032 temp;
    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency)
        * mem->mclk_period + crtc->request_delay;
    if ((crtc->hclk_period * 1000) >= temp) {
        bursts_during_available = (crtc->hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
    } else {
        error = 1;  //LPL: proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  bursts_during_available = ((crtc->hclk_period * 1000 -
                  bursts_during_active * burst_latency * mem.mclk_period -
                  cursor_latency                       * mem.mclk_period -
                  mem.pipeline_latency                 * mem.mclk_period -
                  crtc->request_delay
                 ) /
                 (burst_latency * mem.mclk_period)
                );
  error = (crtc->fifo.lwm > bursts_during_available * crtc->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



U032
scaler_cant_fill_to_lwm(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, mem_t *mem, U032 burst_latency, U032 cursor_latency, U032 bursts_during_active)
{
    U032 error;
    U032 bursts_during_available;
    U032 hclk_period;

#if 1//def TWINHEAD_OPTS
    U032 temp;

    if (scaler->h2_owns_vs) hclk_period = crtc2->hclk_period;
    else hclk_period = crtc->hclk_period;

    temp = (bursts_during_active * burst_latency + cursor_latency + mem->pipeline_latency) * mem->mclk_period
        + scaler->request_delay;

    if ((hclk_period * 1000) >= temp) {
        bursts_during_available = (hclk_period * 1000 - temp)
            / (burst_latency * mem->mclk_period);
        error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
    } else {
        error = 0;  //LPL proper error?
    }
#else    //#ifdef TWINHEAD_OPTS
  if (scaler->h2_owns_vs)
  {
    bursts_during_available = ((crtc2->hclk_period * 1000 -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    scaler->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  } else
  {
    bursts_during_available = ((crtc->hclk_period * 1000  -
                      bursts_during_active * burst_latency * mem.mclk_period -
                    cursor_latency                       * mem.mclk_period -
                    mem.pipeline_latency                 * mem.mclk_period -
                    crtc->request_delay
                   ) /
                   (burst_latency * mem.mclk_period)
                  );
  }
  error = (scaler->fifo.lwm > bursts_during_available * scaler->burst_size) ? 1 : 0;
#endif    //#ifdef TWINHEAD_OPTS

  return error;
}



/***********************************************/
/*Note: this function is analogous to test_scaler_constraints.  
  Any modifications here will often also need to be made to 
  test_scaler_constraints.
  "someday" the crtc_t and scaler_t data types should be unified so these
  two functions can also be unified.  OOP would have been nice here. . .
  */
U032
test_crtc_constraints(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 cursor_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;

  if (!crtc->enable) return 0;
 
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size =  crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable    * ((crtc->burst_size   + mem->page_fault_width - 1) / mem->page_fault_width) +
                   crtc2->enable   * ((crtc2->burst_size  + mem->page_fault_width - 1) / mem->page_fault_width) +
                   scaler->enable  * ((scaler->burst_size + mem->page_fault_width - 1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /*note that cursor_latency is a on a per-CRTC basis, not total cusor_latency.*/
  /*note also that NV11 needs to treat cursor latency as taking a CRTC burst.  */
  cursor_latency = mem->arbitration_latency + (crtc->cursor_burst_size) / mem->data_rate + mem->stall_cycles;
  if (not_consuming_sufficient_bandwidth(crtc, crtc2, scaler, mem, burst_latency, cursor_latency * mem->mclk_period)) {
    errors++;
  }
  if (errors)
    return errors;

  /* optimistic case */
#if 1
  burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 =  crtc->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

  if (burst_temp >= burst_temp2) {
      bursts_during_active =  (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
  } else {
      bursts_during_active = 0;
  }

#else
  bursts_during_active = (crtc->hres           * crtc->pclk_period -
                  crtc->request_delay                      -
                  mem->pipeline_latency * mem->mclk_period   -
                  mem->command_latency  * mem->mclk_period   -
                  100 * crtc->burst_size     * crtc->pclk_period / crtc->drain_rate +
                  crtc->burst_size     * mem->mclk_period   / mem->data_rate
                 ) /
                 (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                         crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period?
     note that we have to wait for the cursor burst to go first.
     for "new" mode operation, we can also start filling during
     the previous scan-out. */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case -- if this is the pessimistic case, why even try the previous case?*/
  //burst_latency += MAX(((100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
    burst_temp = crtc->hres * crtc->pclk_period + crtc->burst_size * mem->mclk_period / mem->data_rate;
    burst_temp2 = crtc->request_delay
        + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
        + 100 * crtc->burst_size * crtc->pclk_period / crtc->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
    bursts_during_active = (crtc->hres * crtc->pclk_period -
              crtc->request_delay -
              mem->pipeline_latency * mem->mclk_period -
              mem->command_latency * mem->mclk_period -
              100*crtc->burst_size * crtc->pclk_period / crtc->drain_rate +
              crtc->burst_size * mem->mclk_period / mem->data_rate
              ) /
             (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&crtc->fifo, crtc->hres, crtc->drain_rate, crtc->burst_size,
                       crtc->request_delay, crtc->pclk_period, burst_latency, bursts_during_active,
                         mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (new_cant_fill_to_lwm(crtc, mem, burst_latency, (crtc->enable+crtc2->enable)*cursor_latency, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(crtc->hres, crtc->depth, crtc->fifo.lwm, final_bursts_during_active, crtc->burst_size)) {
    errors++;
  }

  return errors;
}



/***********************************************/
U032
test_scaler_constraints(scaler_t *scaler, crtc_t *crtc, crtc_t *crtc2, rtr_t *rtr, mem_t *mem)
{
  U032 errors = 0;
  U032 burst_latency;
  U032 bursts_during_active;
  U032 final_bursts_during_active;
  U032 num_rtrs, total_burst_size;
  U032 burst_temp, burst_temp2;
      
  if (!scaler->enable) return 0;

  /*intermediate values used to calculate burst_latency*/
  num_rtrs         = crtc->enable + crtc2->enable + scaler->enable;
  total_burst_size = crtc->enable*crtc->burst_size + crtc2->enable*crtc2->burst_size + scaler->enable*scaler->burst_size;

  burst_latency = num_rtrs         * mem->arbitration_latency + 
                  total_burst_size / mem->data_rate           +
                  num_rtrs         * mem->stall_cycles        +
                  (crtc->enable   * ((crtc->burst_size  +mem->page_fault_width-1) / mem->page_fault_width) +
                   crtc2->enable  * ((crtc2->burst_size +mem->page_fault_width-1) / mem->page_fault_width) +
                   scaler->enable * ((scaler->burst_size+mem->page_fault_width-1) / mem->page_fault_width)
                  ) * mem->page_fault_penalty;

  
  /* optimistic case */
#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100*scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  if (errors) return errors;

  /* pessimistic case */
  //burst_latency += MAX((100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem.mclk_period) - burst_latency, 0);
  burst_temp = 100* scaler->burst_size * scaler->pclk_period / scaler->drain_rate / mem->mclk_period;
  if (burst_temp > burst_latency)
      burst_latency = burst_temp;

#if 1
  burst_temp = scaler->window_hres * scaler->pclk_period + scaler->burst_size * mem->mclk_period / mem->data_rate;
  burst_temp2 = scaler->request_delay
      + (mem->pipeline_latency + mem->command_latency) * mem->mclk_period
      + 100 * scaler->burst_size * scaler->pclk_period / scaler->drain_rate;

    if (burst_temp >= burst_temp2) {
        bursts_during_active = (burst_temp - burst_temp2) / (burst_latency * mem->mclk_period);
    } else {
      bursts_during_active = 0;
    }
#else
  bursts_during_active = (scaler->window_hres  * scaler->pclk_period -
                 scaler->request_delay -
                 mem->pipeline_latency * mem->mclk_period -
                 mem->command_latency  * mem->mclk_period -
                 100* scaler->burst_size   * scaler->pclk_period / scaler->drain_rate +
                 scaler->burst_size   * mem->mclk_period / mem->data_rate
                 ) /
                (burst_latency * mem->mclk_period);
#endif

  final_bursts_during_active = compute_fifo_size(&scaler->fifo, scaler->window_hres, scaler->drain_rate, scaler->burst_size,
               scaler->request_delay, scaler->pclk_period, burst_latency, bursts_during_active,
               mem);

  /* can we fill to the LWM mark in the blanking period? */
  if (scaler_cant_fill_to_lwm(scaler, crtc, crtc2, mem, burst_latency, 0, final_bursts_during_active)) {
    errors++;
  }
  
  /* can we get enough data? */
  if (insufficient_data(scaler->source_hres, scaler->depth, scaler->fifo.lwm, final_bursts_during_active, scaler->burst_size)) {
    errors++;
  }

  return errors;
}



/******************************/
U032
test_configuration(crtc_t *crtc, crtc_t *crtc2, scaler_t *scaler, rtr_t *rtr, U032 max_burst_size, mem_t *mem, U032 fifo_size)
{
  U032 error;

  error = insufficient_total_bandwidth(crtc, crtc2, scaler, mem);
  if (error) {
    return error;
  }

  for (crtc->burst_size = crtc->min_burst_size; crtc->burst_size <= max_burst_size; crtc->burst_size += 16) {

    error = 0;

    if (scaler->enable)
    guess_scaler_burstsize(scaler, crtc, crtc2);
    if (crtc2->enable)
    guess_crtc2_burstsize(crtc2, crtc);

    error = test_crtc_constraints(crtc, crtc2, scaler, rtr, mem);
    if (error)
      continue;
    if (crtc2->enable) {
      error = test_crtc_constraints(crtc2, crtc, scaler, rtr, mem);
      if (error)
        continue;
    }
    if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
      error++;
    if (scaler->burst_size > max_burst_size)
    error++;

    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) 
      break;

     if (scaler->enable) {
    for (scaler->burst_size += scaler->min_burst_size; scaler->burst_size <= max_burst_size; scaler->burst_size += 16) {
        if (test_scaler_constraints(scaler, crtc, crtc2, rtr, mem))
          error = 1;
        if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
          error++;
      if (!error) break;
    }
    if (!error) {
      if (test_crtc_constraints(crtc, crtc2, scaler, rtr, mem))
            error = 1;
      if (crtc2->enable && test_crtc_constraints(crtc2, crtc, scaler, rtr, mem))
            error++;
    }
    }
    if (test_fifo_constraints(fifo_size, crtc, crtc2, scaler))
      error++;
    if (!error) break;
  }

  return(error);
}

//
// Main NV11 arbitration routine
//
void NV11_dacCalculateArbitration(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state *arb)
{
  crtc_t crtc;
  crtc_t crtc2;
  scaler_t scaler;
  rtr_t rtr;
  mem_t mem;
//  U032 i;
//  U032 maxd, maxr;
  U032 error;
  U032 data_in_line1, data_in_line2, data_in_lineS;
 
  /*NV11 default values*/
  U032 page_fault_penalty   = 2;
  U032 page_fault_width     = 256;
  U032 arbitration_latency  = 10;
  U032 pipeline_latency     = 28;
  U032 stall_cycles         = 3;

  U032 min_burst_size   =   16;
  U032 max_burst_size   = 2048;
  U032 crtc_fifo_size   = 2048; /*CRTC fifo size in bytes*/
  U032 scaler_fifo_size = 1856; /*video scaler's fifo size*/
 
  U032 partition_data_width;
  U032 ddr;
 
  /* set up some default values for the CRTC ... */
  U032 hres    ;
  U032 htotal  ;
  U032 hres2   ;
  U032 htotal2 ;
  U032 vres    ;
  U032 vres2   ;
  U032 refresh ;
  U032 refresh2;
  U032 depth   ;
  U032 depth2  ;
  U032 crtc_request_delay_mclks = 6;
  U032 crtc_request_delay_pclks = 6;
  U032 crtc_burst_size = 0;
  U032 cursor_burst_size = 256;
  U032 crtc2_enable, crtc_enable;
  U032 video_source_hres;
  U032 video_source_vres;
  U032 h2_owns_vs  ;
  U032 mclk;
  U032 pclk, pclk2;
 
  /* ... the scaler ... */
  U032 scaler_disable;
  U032 scaler_depth = 16;
  U032 scaler_burst_size = 0;
  /*Same as FBI interface, in bytes*/
  U032 scaler_window_hres = 0;
  U032 scaler_window_vres = 0;
  U032 scaler_request_delay_mclks = 4;
  U032 scaler_request_delay_pclks = 6;
  
  /* ... the memory controller ... */
  U032 partitions = 1;
  U032 refresh_penalty = 9;
  arb_type arbiter = round_robin;
  U032 depth_cmd = 3;
  U032 depth_rw = 8;
  U032 rtr_interrupt_rate = 0;
  
  /* ... and the real-time requestor */
  /* to disable this, just leave the burst_size as 0 */
  U032 rtr_request_delay_mclks = 4;
  U032 rtr_burst_size = 0;

  U032 who_owns_scaler;

  crtc_enable       = arb->enable_h1;
  crtc2_enable      = arb->enable_h2;
  scaler_disable    = !(arb->enable_video);
  video_source_hres = arb->video_source_hres;
  video_source_vres = arb->video_source_vres;
  h2_owns_vs        = arb->h2_owns_vs;

  hres         = arb->hres;
  htotal       = arb->htotal;
  vres         = arb->vres;
  depth        = arb->pix_bpp;
  refresh      = arb->refresh;
  pclk         = arb->pclk_khz / 1000;

  hres2        = arb->hres2;
  htotal2      = arb->htotal2;
  vres2        = arb->vres2;
  depth2       = arb->pix_bpp_h2;
  refresh2     = arb->refresh2;
  pclk2        = arb->pclk2_khz / 1000;

  partition_data_width = arb->memory_width;
  ddr                  = arb->memory_type;
  mclk                 = arb->mclk_khz / 1000;

  init_mem(&mem, mclk, ddr, arbiter, partitions, partition_data_width, page_fault_penalty,
       page_fault_width, refresh_penalty, arbitration_latency, pipeline_latency, stall_cycles,
       depth_cmd, depth_rw, rtr_interrupt_rate);
  init_crtc(&crtc, crtc_enable,
            hres, vres, depth, refresh,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
        pclk, htotal, &mem);
  init_crtc(&crtc2, crtc2_enable,
            hres2, vres2, depth2, refresh2,
            crtc_request_delay_mclks, crtc_request_delay_pclks,
         crtc_burst_size, min_burst_size, max_burst_size, cursor_burst_size,
            pclk2, htotal2, &mem);
  init_scaler(&scaler, &crtc, &crtc2, mclk,
              (scaler_disable) ? 0 : 1, video_source_hres, video_source_vres, h2_owns_vs, scaler_depth,
              scaler_window_hres, scaler_window_vres,
           scaler_burst_size, min_burst_size, max_burst_size,
           scaler_request_delay_mclks, scaler_request_delay_pclks, scaler_fifo_size);
  init_rtr(&rtr, rtr_burst_size, rtr_request_delay_mclks, &mem);

//  if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period)) {
  who_owns_scaler = 0;
  if (crtc2.enable && crtc.enable) {
    if ((hres2*depth2*1000/crtc2.hclk_period) > (hres*depth*1000/crtc.hclk_period))
        who_owns_scaler = 1;
  } else {
      if (crtc2.enable)
        who_owns_scaler = 1;
  }

  if (who_owns_scaler) {
    if (crtc.enable) scaler.h2_owns_vs = !scaler.h2_owns_vs; /*swap which head scaler is owned by when swapping heads*/
    error = test_configuration(&crtc2, &crtc,  &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 
    if (crtc.enable) scaler.h2_owns_vs = !scaler.h2_owns_vs;
  } else
    error = test_configuration(&crtc,  &crtc2, &scaler, &rtr, max_burst_size, &mem, crtc_fifo_size); 

  //Compute the amount of data in a single horizontal line
  data_in_line1 = crtc.hres          * crtc.depth   / 8;
  data_in_line2 = crtc2.hres         * crtc2.depth  / 8; 
  data_in_lineS = scaler.source_hres * scaler.depth / 8;

  //It is really inefficent to have a burst size smaller than 256 bytes.
  if (crtc.burst_size   < 256)
    crtc.burst_size   = 256;
  if (crtc2.burst_size  < 256)
    crtc2.burst_size  = 256;
  if (scaler.burst_size < 256)
    scaler.burst_size = 256;

  //It is wasteful to have a burst size larger than the amount of data in a line
  if (crtc.burst_size   > data_in_line1)
    crtc.burst_size   = data_in_line1;
  if (crtc2.burst_size  > data_in_line2)
    crtc2.burst_size  = data_in_line2;
  if (scaler.burst_size > data_in_lineS)
    scaler.burst_size = data_in_lineS;


  //LPL: addition to set watermarks as high as possible instead
  // of as low as possible.  This presumably obviates the need
  // for some other calculation effort earler.

  //Get best performance for the real-time requestors by setting LWM
  //as high as possible without risking overflow.
  crtc.fifo.lwm   = crtc_fifo_size   - crtc.burst_size  ;
  crtc2.fifo.lwm  = crtc_fifo_size   - crtc2.burst_size ;
  scaler.fifo.lwm = scaler_fifo_size - scaler.burst_size;

  //LWM should not be larger than the amount of data in a line
  if (crtc.fifo.lwm > data_in_line1)
    crtc.fifo.lwm = data_in_line1;
  if (crtc2.fifo.lwm > data_in_line2)
    crtc2.fifo.lwm = data_in_line2;
  if (scaler.fifo.lwm > data_in_lineS)
    scaler.fifo.lwm = data_in_lineS;
 
  fifo->valid = !error;
  fifo->crtc1_lwm = crtc.fifo.lwm;
  fifo->crtc2_lwm = crtc2.fifo.lwm;
  fifo->video_lwm = scaler.fifo.lwm;
  fifo->crtc1_burst_size = crtc.burst_size;
  fifo->crtc2_burst_size = crtc2.burst_size;
  fifo->video_burst_size = scaler.burst_size;
}


//////////////////////////////////////////
//
// NV 10 arbitration routines
//
static
VOID NV10_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int nvclk_fill, us_extra;
  int found, mclk_extra, mclk_loop, cbs, m1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vus_m, vus_n, vus_p;
  int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
  int clwm_rnd_down;
  int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
  int pclks_2_top_fifo, min_mclk_extra;
  int us_min_mclk_extra;

  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width/64;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 1024;

  cbs = 512;
  vbs = 512;

  pclks = 4; // lwm detect.

  nvclks = 3; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)

  mclks  = 1;   // 2 edge sync.  may be very close to edge so just put one.

  mclks += 1;   // arb_hp_req
  mclks += 5;   // ap_hp_req   tiling pipeline

  mclks += 2;    // tc_req     latency fifo
  mclks += 2;    // fb_cas_n_  memory request to fbio block
  mclks += 7;    // sm_d_rdv   data returned from fbio block

  // fb.rd.d.Put_gc   need to accumulate 256 bits for read
  if (arb->memory_type == 0)
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 4;
    else
      mclks += 2;
  }
  else
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 2;
    else
      mclks += 1;
  }

  if ((!video_enable) && (arb->memory_width == 128))
  {  
    mclk_extra = (bpp == 32) ? 31 : 42; // Margin of error
    min_mclk_extra = 17;
  }
  else
  {
    mclk_extra = (bpp == 32) ? 8 : 4; // Margin of error
    //mclk_extra = 4; // Margin of error
    min_mclk_extra = 18;
  }

  nvclks += 1; // 2 edge sync.  may be very close to edge so just put one.
  nvclks += 1; // fbi_d_rdv_n
  nvclks += 1; // Fbi_d_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_m_min = mclks * 1000*1000 / mclk_freq; // Minimum Mclk latency in us
    us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = pclks*1000*1000 / pclk_freq;// nvclk latency in us
    us_pipe = us_m + us_n + us_p;
    us_pipe_min = us_m_min + us_n + us_p;
    us_extra = 0;

    vus_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    vus_n = (4)*1000*1000 / nvclk_freq;// nvclk latency in us
    vus_p = 0*1000*1000 / pclk_freq;// pclk latency in us
    vus_pipe = vus_m + vus_n + vus_p;

    if(video_enable) {
      video_drain_rate = pclk_freq * 4; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 1; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;

      us_video = vpm_us + vus_m; // Video has separate read return path

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
        us_video  // Wait for video
        +cpm_us // CRT Page miss
        +us_m + us_n +us_p // other latency
        ;

      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 1; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that

/*
        //
        // Another concern, only for high pclks so don't do this
        // with video:
        // What happens if the latency to fetch the cbs is so large that
        // fifo empties.  In that case we need to have an alternate clwm value
        // based off the total burst fetch
        //
        us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
        us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
        clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
        clwm_mt ++;
        if(clwm_mt > clwm)
            clwm = clwm_mt;
*/
        // Finally, a heuristic check when width == 64 bits
        if(width == 1){
            nvclk_fill = nvclk_freq * 8;
            if(crtc_drain_rate * 100 >= nvclk_fill * 102)
                    clwm = 0xfff; //Large number to fail

            else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
                clwm = 1024;
                cbs = 512;
                us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            }
        }
    }


    /*
      Overfill check:
    */

    clwm_rnd_down = ((int)clwm/8)*8;
    if (clwm_rnd_down < clwm)
        clwm += 8;
        
    m1 = clwm + cbs -  1024; /* Amount of overfill */
    m2us = us_pipe_min + us_min_mclk_extra;
    pclks_2_top_fifo = (1024-clwm)/(8*width);
    
    /* pclk cycles to drain */
    p1clk = m2us * pclk_freq/(1000*1000); 
    p2 = p1clk * bpp / 8; // bytes drained.
    
    if((p2 < m1) && (m1 > 0)) {
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   {
          if(cbs <= 32) {
            found = 1; // Can't adjust anymore!
          } else {
            cbs = cbs/2;  // reduce the burst size
          }
        } else {
          min_mclk_extra--;
        }
    } else {
      if (clwm > 1023){ // Have some margin
        fifo->valid = 0;
        found = 0;
        if(min_mclk_extra == 0)   
            found = 1; // Can't adjust anymore!
        else 
            min_mclk_extra--;
      }
    }
    craw = clwm;
    
    if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;

    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
  }
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV10_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;

}
*/

typedef struct tagNV10_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV10_DacAGPClockEntry;

NV10_DacAGPClockEntry NV10_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV10(VOID *);
RM_STATUS nvHalDacAlloc_NV10(VOID *);
RM_STATUS nvHalDacFree_NV10(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV10(VOID *);
RM_STATUS nvHalDacProgramMClk_NV10(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV10(VOID *);
RM_STATUS nvHalDacProgramPClk_NV10(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV10(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV10(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV10(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV10(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV10(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PDACHALINFO_NV10 pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV10)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:

            // set bus width
            if (REG_RD_DRF(_PFB, _CFG, _BUS) == NV_PFB_CFG_BUS_128)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            // initialize default crtc parameters
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            // if we're an nv11, we need to setup a second crtc
            // The capabilities of the second head should be determined by the BIOS,
            // but for now we will hard code them. These capabilities are such things 
            // as the presence of an external DAC, and the frequency specification.

            // The values set here will be replaced in dacinit.c/initDac if it is able
            // to find the proper tables in the BIOS
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo))
            {
                U032 i, data32, crtcAddr;
                U008 lock;

                //NVASSERT(pDacHalInfo->NumCrtcs == 2);
                pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = 150000000;
                pDacHalInfo->CrtcInfo[1].RegOffset = 0x00002000;

                //
                // Head 1 supports TV and flat panel, and CRT, if an external DAC is present
                //
                pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                    DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |      // assume external DAC
                    DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                    DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

                // turn on CRTC big endian on 2nd head if we're setup for big endian mode
                if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                {
                    U032 crtcOffset;
                    U032 config;
                    crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                    config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                    config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                    REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
                }

                //
                // While we're here, increase TV out latency.
                //
                for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
                {
                    crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                    // Unlock CRTC extended regs
                    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                    // Add 4 per Raj Rao...
                    HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                    data32 += 4;
                    HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                    // Relock if necessary...
                    if (lock == 0)
                        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
                }
            }

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV10(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify that class and head parameters are legal for this chip.
    //

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV10(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV10(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032    crtcOffset;
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV10 - Program MCLK based on the value in pDacHalInfo->MClk
//
// This routine uses the value in pDacHalInfo->MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV10(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // MPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Wait for M PLL to lock.
    osDelay(64 /* ms */);

    // Reset (resync) the frame buffer DRAM DLL.
    FLD_WR_DRF_DEF( _PFB, _MRS, _DLL, _RESET );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH ) * 32;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newCyclesPerRefresh / 32 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV10 - Program NVCLK based on the value in pDacHalInfo->NVClk
//
// This routine uses the value in pDacHalInfo->NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV10(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    U032 IsPllSlowed;
    U032 Head = 0;  // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Make sure to disable the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    {
        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
    }

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // Restore the clock slowdown circuit
    if (IsNV11_NV10(pMcHalInfo))
    	FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV10_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV10_dacAGPClockTable ) / sizeof( NV10_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV10_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV10
//
RM_STATUS
nvHalDacProgramPClk_NV10(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV10
//
RM_STATUS
nvHalDacProgramCursorImage_NV10(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PMCHALINFO  pMcHalInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
            if (IsNV15orBetter_NV10(pMcHalInfo))
            {
                // set bpp = 1, blend is already 0 (only supported in NV15 or later)
                cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            }
            // else fall through to default
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //            
    // If not driving a TV and we're on an NV15 or later, turn on the LONG_PIPE to extend the cursor FIFO
    // when running 32bpp or alpha cursors; otherwise, keep it short.
    //
    // Note that this means that 16bpp Alpha and 32bpp cursors are not allowed on a TV.
    //
    // TO DO: there is much unnecessary logic here -- can this all be collapsed into one write?
    if (IsNV15orBetter_NV10(pMcHalInfo))
    {   
        if (HAL_GETDISPLAYTYPE(pDacHalObj->Head) != DISPLAY_TYPE_TV)
        {
            if ((pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5) ||
                (pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8) ||
                (pDacProgramCursorImgArg->colorFormat == NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8))
            {    
                HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr);                
            }
            else
            {
                // forcing a long pipe works around a HW bug where inverted background causes screen tearing effects
                HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr); 
            }    
        }
        else
        {
            HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr); 
        }
    }

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV10
//
RM_STATUS
nvHalDacGetRasterPosition_NV10(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacRasterPosArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) HAL_DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, CurDacAdr);
                                        
    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV10(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U032        i, pclk_limit;
    U032        head = 0;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[head].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Build the sim table using current system settings
    //
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // NV11 params
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1 = (pVidLutCurDac0) ? 1 : 0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below
        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = pVidLutCurDac0->Dac[0].PixelClock * 10;   //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2        = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  // 768;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    =   32;
        sim_data.pclk2_khz    =  36000; //3404772;
    }

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
// end NV11

    //Override the bit plane depth with passed parameter.
    if (head) {
        sim_data.pix_bpp_h2 = pDacValidateArbSettingsArg->bpp;   //32;
    } else {
        sim_data.pix_bpp    = pDacValidateArbSettingsArg->bpp;   //bpp;
    }

    //What if we're still not sure?  Well, for now let's pick the worst case...
    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

    //
    // Run the numbers through the ringer
    //
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif  //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV10_dacCalculateVideoCaps(pDev);
    */
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}

#ifdef IKOS
U032 do_pvideo = 0;
#endif

RM_STATUS
nvHalDacUpdateArbSettings_NV10(VOID *arg)
{ 
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock0, lock1;
    U032        i;
    U032        M, N, O, P;

    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac0;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac1;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    pVidLutCurDac0 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[0].pVidLutCurDac;
    pVidLutCurDac1 = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacHalInfo->CrtcInfo[1].pVidLutCurDac;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    // Make sure any uninitialized sim data starts with 0's
    for (i = 0; i < sizeof(sim_data); i++)
        ((U008 *)&sim_data)[i] = 0x0;

    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = pDacHalInfo->Depth;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;

    // if (NV11_dacValidateArbitrationSettings(pHalHwInfo, pDacHalInfo->Depth, 1, 0, (pDacHalInfo->PixelClock * 10000), Head))
    nvHalDacValidateArbSettings_NV10(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;
    
    //sim_data.pix_bpp      = (char)pDacHalInfo->Depth;
    //sim_data.enable_video = pDev->Video.Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_aligned    = 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
    sim_data.mem_latency    = 3;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz
 
    // 
    // Get those new numbers
    //
    fifo_data.crtc1_lwm = 0;
    fifo_data.crtc2_lwm = 0;
    fifo_data.video_lwm = 0;
    fifo_data.crtc1_burst_size = 0;
    fifo_data.crtc2_burst_size = 0;
    fifo_data.video_burst_size = 0;
    fifo_data.valid = 0;

    sim_data.enable_h1        = (pVidLutCurDac0)?1:0;    //1
    if (pVidLutCurDac0) {
        sim_data.pix_bpp      = pVidLutCurDac0->Dac[0].PixelDepth;          //May override below

        sim_data.hres         = pVidLutCurDac0->Dac[0].VisibleImageWidth;   //2048;
        sim_data.htotal       = pVidLutCurDac0->Dac[0].TotalWidth;          //2832;
        sim_data.vres         = pVidLutCurDac0->Dac[0].VisibleImageHeight;  //1536;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh      = (pVidLutCurDac0->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac0->Dac[0].TotalWidth * pVidLutCurDac0->Dac[0].TotalHeight);    //75;

    //    sim_data.pix_bpp    =   32;
        sim_data.pclk_khz     =  pVidLutCurDac0->Dac[0].PixelClock * 10;    //3404772;
    } else {
        sim_data.hres         = 640;
        sim_data.htotal       = 832;
        sim_data.vres         = 480;
        sim_data.refresh      = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk_khz     = 36000;  //3404772;
    }
    
    sim_data.enable_h2    = (pVidLutCurDac1)?1:0;       //0
    if (pVidLutCurDac1) {
        sim_data.pix_bpp_h2   = pVidLutCurDac1->Dac[0].PixelDepth;          //May override below
        sim_data.hres2        = pVidLutCurDac1->Dac[0].VisibleImageWidth;   //1024;
        sim_data.htotal2      = pVidLutCurDac1->Dac[0].TotalWidth;          //1344;
        sim_data.vres2        = pVidLutCurDac1->Dac[0].VisibleImageHeight;  //768;

        //LPL: copied math below, but I don't get it... *10000?
        sim_data.refresh2     = (pVidLutCurDac1->Dac[0].PixelClock*10000) /
                                (pVidLutCurDac1->Dac[0].TotalWidth * pVidLutCurDac1->Dac[0].TotalHeight);    //60;

        sim_data.pclk2_khz    =   pVidLutCurDac1->Dac[0].PixelClock * 10;   //641088;
    } else {
        sim_data.hres2        = 640;
        sim_data.htotal2      = 832;
        sim_data.vres2        = 480;
        sim_data.refresh2     = 85;     //75;
    //    sim_data.pix_bpp    = 32;
        sim_data.pclk2_khz    = 36000;  //3404772;
    }

    if (!sim_data.pix_bpp) sim_data.pix_bpp = 32;
    if (!sim_data.pix_bpp_h2) sim_data.pix_bpp_h2 = 32;

//    sim_data.enable_video =    1;
//    sim_data.enable_mp    =    0;

//    sim_data.memory_width =  128;
//    sim_data.memory_type  =    0;
//    sim_data.mclk_mhz     =  166;

    //
    // If the overlay is active, use the head that owns the video scaler,
    // otherwise, for calculating if the overlay is allowed, assume this
    // head.
    //
	if (pVideoHalInfo->ActiveVideoOverlayObject)
        sim_data.h2_owns_vs = pVideoHalInfo->Head;
    else
        sim_data.h2_owns_vs = Head;

    sim_data.video_source_hres = 720;
    sim_data.video_source_vres = 480;
#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo) && nv11Aware)
#else  //#ifdef NV11_DEBUG
    if (IsNV11_NV10(pMcHalInfo))
#endif //#ifdef NV11_DEBUG
        NV11_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV10_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
    
//    For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//        not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size

#ifdef IKOS
        if (do_pvideo)
        {
#endif
        /*
        //
        // Check overlay capabilities.
        //
        if (!NV10_dacCalculateVideoCaps(pDev))
            pDev->Video.OverlayAllowed = 0;
        */

        if (IsNV11_NV10(pMcHalInfo)) {
            //Final clipping -- check with Jeff to see if the values are already 'safe'
            fifo_data.video_burst_size /= 32;
            if (!fifo_data.video_burst_size) fifo_data.video_burst_size = 1;
            if (fifo_data.video_burst_size > 16) fifo_data.video_burst_size = 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo_data.video_burst_size);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, fifo_data.video_burst_size);

            fifo_data.video_lwm /= 16;
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo_data.video_lwm);
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, fifo_data.video_lwm);
        } else {
            //
            // These are the PVIDEO burst/watermark hardcoded values
            // we've gotten from the HW engineers.
            //
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, 16);         // 512 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, 64);    // 1024 bytes
            FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, 64);    // 1024 bytes
        }

#ifdef IKOS
        }
#endif

        //
        // Update the CRTC watermarks
        // Note that for NV11 we've set the burst size registers to a different
        // operating mode -- therefore, the numbers written for NV11 and non-NV11
        // paths are not compatible.
        //
        if (IsNV11_NV10(pMcHalInfo)) {
            U032 CurDacAdr0, CurDacAdr1;

            CurDacAdr0 = pDacHalInfo->CrtcInfo[0].RegOffset;
            CurDacAdr1 = pDacHalInfo->CrtcInfo[1].RegOffset;

            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr0);
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr1);

            //
            // Set the CRTC watermarks and burst size
            //

            fifo_data.crtc1_lwm /= 8;
            if (fifo_data.crtc1_lwm > 255) fifo_data.crtc1_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc1_lwm, CurDacAdr0);

            fifo_data.crtc1_burst_size /= 32;
            if (fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size--;
            if (!fifo_data.crtc1_burst_size) fifo_data.crtc1_burst_size++;
            if (fifo_data.crtc1_burst_size >= (2048/32)) fifo_data.crtc1_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc1_burst_size, CurDacAdr0);

            fifo_data.crtc2_lwm /= 8;
            if (fifo_data.crtc2_lwm > 255) fifo_data.crtc2_lwm = 255;
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.crtc2_lwm, CurDacAdr1);

            fifo_data.crtc2_burst_size /= 32;
            if (fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size--;
            if (!fifo_data.crtc2_burst_size) fifo_data.crtc2_burst_size++;
            if (fifo_data.crtc2_burst_size >= (2048/32)) fifo_data.crtc2_burst_size = 2048/32 - 1;
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, fifo_data.crtc2_burst_size, CurDacAdr1);

            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr0);
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr1);

        } else {    //if (IsNV11(pDev))
            // Unlock CRTC extended regs
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
       
            //
            // Set the CRTC watermarks and burst size
            //
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);
            switch (fifo_data.crtc1_burst_size)
            {
                case 512:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
                    break;
                case 256:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;
                case 128:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;
                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;
                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;
                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        }

        //
        // Relock if necessary
        //
        return (RM_OK);
    }
    else    //if (fifo_data.valid)
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
        // Unlock CRTC extended regs
        if (IsNV11_NV10(pMcHalInfo)) {
            U032 CurDacAdr0, CurDacAdr1;

            CurDacAdr0 = pDacHalInfo->CrtcInfo[0].RegOffset;
            CurDacAdr1 = pDacHalInfo->CrtcInfo[1].RegOffset;

            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr0);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr0);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, CurDacAdr0);

            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock1, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr1);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr1);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1024/32 - 32, CurDacAdr1);

            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr0);
            if (lock1 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr1);

        } else {    //if (IsNV11(pDev))
            HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock0, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
        
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr);
            HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
         
            //
            // Relock if necessary
            //
            if (lock0 == 0)
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        }
        
        return (RM_ERROR);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv20\dacnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACNV20.C                                                         *
*   The DAC manager.                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

static
VOID NV20_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int nvclk_fill, us_extra;
  int found, mclk_extra, mclk_loop, cbs, m1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vus_m, vus_n, vus_p;
  int vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;
  int clwm_rnd_down;
  int craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;
  int pclks_2_top_fifo, min_mclk_extra;
  int us_min_mclk_extra;

  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width/64;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 1024;

  cbs = 512;
  vbs = 512;

  pclks = 4; // lwm detect.

  nvclks = 3; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)

  mclks  = 1;   // 2 edge sync.  may be very close to edge so just put one.

  mclks += 1;   // arb_hp_req
  mclks += 5;   // ap_hp_req   tiling pipeline

  mclks += 2;    // tc_req     latency fifo
  mclks += 2;    // fb_cas_n_  memory request to fbio block
  mclks += 7;    // sm_d_rdv   data returned from fbio block

  // fb.rd.d.Put_gc   need to accumulate 256 bits for read
  if (arb->memory_type == 0)
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 4;
    else
      mclks += 2;
  }
  else
  {
    if (arb->memory_width == 64) // 64 bit bus
      mclks += 2;
    else
      mclks += 1;
  }

  if ((!video_enable) && (arb->memory_width == 128))
  {  
    mclk_extra = (bpp == 32) ? 31 : 42; // Margin of error
    min_mclk_extra = 17;
  }
  else
  {
    mclk_extra = (bpp == 32) ? 8 : 4; // Margin of error
    //mclk_extra = 4; // Margin of error
    min_mclk_extra = 18;
  }

  nvclks += 1; // 2 edge sync.  may be very close to edge so just put one.
  nvclks += 1; // fbi_d_rdv_n
  nvclks += 1; // Fbi_d_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_m_min = mclks * 1000*1000 / mclk_freq; // Minimum Mclk latency in us
    us_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = pclks*1000*1000 / pclk_freq;// nvclk latency in us
    us_pipe = us_m + us_n + us_p;
    us_pipe_min = us_m_min + us_n + us_p;
    us_extra = 0;

    vus_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    vus_n = (4)*1000*1000 / nvclk_freq;// nvclk latency in us
    vus_p = 0*1000*1000 / pclk_freq;// pclk latency in us
    vus_pipe = vus_m + vus_n + vus_p;

    if(video_enable) {
      video_drain_rate = pclk_freq * 4; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 1; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;

      us_video = vpm_us + vus_m; // Video has separate read return path

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
        us_video  // Wait for video
        +cpm_us // CRT Page miss
        +us_m + us_n +us_p // other latency
        ;

      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 1; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      if(mp_enable)
          crtpagemiss += 1; // if MA0 conflict
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that

/*
        //
        // Another concern, only for high pclks so don't do this
        // with video:
        // What happens if the latency to fetch the cbs is so large that
        // fifo empties.  In that case we need to have an alternate clwm value
        // based off the total burst fetch
        //
        us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
        us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
        clwm_mt = us_crt * crtc_drain_rate/(1000*1000);
        clwm_mt ++;
        if(clwm_mt > clwm)
            clwm = clwm_mt;
*/
        // Finally, a heuristic check when width == 64 bits
        if(width == 1){
            nvclk_fill = nvclk_freq * 8;
            if(crtc_drain_rate * 100 >= nvclk_fill * 102)
                    clwm = 0xfff; //Large number to fail

            else if(crtc_drain_rate * 100  >= nvclk_fill * 98) {
                clwm = 1024;
                cbs = 512;
                us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            }
        }
    }


    /*
      Overfill check:

      */

    clwm_rnd_down = ((int)clwm/8)*8;
    if (clwm_rnd_down < clwm)
        clwm += 8;
        
    m1 = clwm + cbs -  1024; /* Amount of overfill */
    m2us = us_pipe_min + us_min_mclk_extra;
    pclks_2_top_fifo = (1024-clwm)/(8*width);
    
    /* pclk cycles to drain */
    p1clk = m2us * pclk_freq/(1000*1000); 
    p2 = p1clk * bpp / 8; // bytes drained.
    
    if((p2 < m1) && (m1 > 0)) {
    	fifo->valid = 0;
    	found = 0;
    	if(min_mclk_extra == 0)   {
    	  if(cbs <= 32) {
    	    found = 1; // Can't adjust anymore!
    	  } else {
    	    cbs = cbs/2;  // reduce the burst size
    	  }
    	} else {
    	  min_mclk_extra--;
    	}
    } else {
      if (clwm > 1023){ // Have some margin
    	fifo->valid = 0;
    	found = 0;
    	if(min_mclk_extra == 0)   
            found = 1; // Can't adjust anymore!
    	else 
            min_mclk_extra--;
      }
    }
    craw = clwm;
    
    if(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;

    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = 1024;  fifo->video_burst_size = 512;
  }
}

/*
//
// Determine if the video overlay is usable in the current configuration.  This
// routine will also update the global variables in pDev which determine the 
// maximum downscaling allowed at various source image sizes.
//
//  Return 0 if not capable (at any upscale or downscale factor)
//  Return ~0 if capable (see pDev for downscale limits)
//
U032 NV20_dacCalculateVideoCaps
(
    PHWINFO pDev
)
{
    //
    // First look for a match of memory type, resolution, and clocks.
    //
    // NOTE: For now, until I can straighten out all of the hardware data,
    // assume a conservative limit.
    //
    switch (pDev->Chip.HalInfo.MaskRevision)
    {
        case 0xA1:
        case 0xA2:
        case 0xA6:
        
            pDev->Video.OverlayMaxDownscale_768  = 2;
            pDev->Video.OverlayMaxDownscale_1280 = 2;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
            
        default:

            pDev->Video.OverlayMaxDownscale_768  = 8;
            pDev->Video.OverlayMaxDownscale_1280 = 4;
            pDev->Video.OverlayMaxDownscale_1920 = 2;
            break;
    }

    //
    // For now, always assume we can support some level of overlay
    // (although not to the same level of downscale ability)
    //
    return 1;

}
*/

typedef struct tagNV20_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV20_DacAGPClockEntry;

NV20_DacAGPClockEntry NV20_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//

// forwards
RM_STATUS nvHalDacControl_NV20(VOID *);
RM_STATUS nvHalDacAlloc_NV20(VOID *);
RM_STATUS nvHalDacFree_NV20(VOID *);
RM_STATUS nvHalDacSetStartAddr_NV20(VOID *);
RM_STATUS nvHalDacProgramMClk_NV20(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV20(VOID *);
RM_STATUS nvHalDacProgramPClk_NV20(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV20(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV20(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV20(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV20(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV20(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PDACHALINFO_NV20    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV20)pHalHwInfo->pDacHalInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
        {
            U032 i, data32, crtcAddr;
            U008 lock;

            // default to 128bit wide bus on nv20
            pDacHalInfo->InputWidth = 128;
            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 350000000;
            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 300000000;
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // Head 0 supports everything (?).
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // Head 1 supports TV and flat panel.
            //
            pDacHalInfo->CrtcInfo[1].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);


            // turn on CRTC big endian on 2nd head if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                U032 crtcOffset;
                U032 config;
                crtcOffset = pDacHalInfo->CrtcInfo[1].RegOffset;
                config = REG_RD32(NV_PCRTC_CONFIG + crtcOffset);
                config |= DRF_DEF(_PCRTC, _CONFIG, _ENDIAN, _BIG);
                REG_WR32(NV_PCRTC_CONFIG + crtcOffset, config);
            }

            //
            // While we're here, increase TV out latency.
            //
            for (i = 0; i < pDacHalInfo->NumCrtcs; i++)
            {
                crtcAddr = pDacHalInfo->CrtcInfo[i].RegOffset;

                // Unlock CRTC extended regs
                HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, crtcAddr);
                HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, crtcAddr);

                // Add 4 per Raj Rao...
                HAL_CRTC_RD(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);
                data32 += 4;
                HAL_CRTC_WR(NV_CIO_CRE_TVOUT_LATENCY, data32, crtcAddr);

                // Relock if necessary...
                if (lock == 0)
                    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, crtcAddr);
            }

            //
            // Set default downscale values.
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 8;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 8;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 8;

            // turn on CRTC big endian if we're setup for big endian mode
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
            {
                FLD_WR_DRF_NUM(_PCRTC, _CONFIG, _ENDIAN, NV_PCRTC_CONFIG_ENDIAN_BIG);
	    }
            break;
        }
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV20(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV20(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV20(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PDACHALINFO pDacHalInfo;
    U032        crtcOffset;

    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;

    crtcOffset = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    REG_WR32(NV_PCRTC_START + crtcOffset, pDacSetStartAddrArg->startAddr);

    return (RM_OK);
}

//
// nvHalDacProgramMClk_NV20 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV20(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // MPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Wait until M PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _MPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: M PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle
    
    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _TIMING2, _REFRESH ) * 32;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _TIMING2, _REFRESH, newCyclesPerRefresh / 32 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV20 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV20(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 i;
    U032 Loops;
    U032 IsPllLocked;
    U032 Head = 0; // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
	    REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Wait until NV PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _NVPLL_LOCK)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: NV PLL not locked\n");
        }
    }

    // Now we can write the final value
	REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV20_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV20_dacAGPClockTable ) / sizeof( NV20_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV20_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV20
//
RM_STATUS
nvHalDacProgramPClk_NV20(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV20
//
RM_STATUS
nvHalDacProgramCursorImage_NV20(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032        cursorConfig;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Read the cursorConfig register.
    cursorConfig = HAL_DAC_REG_RD32(NV_PCRTC_CURSOR_CONFIG, CurDacAdr);

    // Preserve the enable and scan_double bits. Clear the rest
    cursorConfig &= ((1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ENABLE)) |
                     (1 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_SCAN_DOUBLE)));

    // Mark the Address Space Indicator to indicate where the cursor image is, 
    // based on the param "asi".
    cursorConfig |= (pDacProgramCursorImgArg->asi << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE));

    // The supported cursor image sizes are 32x32 or 64x64.
    if (pDacProgramCursorImgArg->width == 32)
    {
        // 32x32
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_32);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_32);
    }
    else
    {
        //64x64
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_PIXELS, NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64);
        cursorConfig |= DRF_NUM(_PCRTC, _CURSOR_CONFIG, _CUR_LINES, NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64);
    }

    // The different color formats are implemented by two bits: The Blend bit and Bpp bit.
    //       Blend      Bpp        Format
    //       ----------------------------
    //         0         0     ->  ROP1R5G5B5
    //         0         1     ->  PM_A8R8G8B8  *** This format is only supported in NV15 or later.
    //         1         0     ->  A1R5G5B5
    //         1         1     ->  A8R8G8B8
    switch (pDacProgramCursorImgArg->colorFormat)
    {
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5:
            // Set blend = 0. Bpp is already 0
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            break;
        case NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8:
            // set blend = 1, bpp = 1
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BLEND_ALPHA << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BLEND));
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            break;
        case NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8:
                // set bpp = 1, blend is already 0 (only supported in NV15 or later)
            cursorConfig |= (NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32 << DRF_SHIFT(NV_PCRTC_CURSOR_CONFIG_CUR_BPP));
            // else fall through to default
        default:
            // Leave blend and bpp both 0 (ROP1R5G5B5)
            break;
    }

    // write the new cursor config register value.
    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR_CONFIG, cursorConfig, CurDacAdr);

    //            
    // If not driving a TV and we're on an NV15 or later, turn on the LONG_PIPE to extend the cursor FIFO
    // when running 32bpp or alpha cursors; otherwise, keep it short.
    //
    // Note that this means that 16bpp Alpha and 32bpp cursors are not allowed on a TV.
    // XXXscottl - But we've increased the TVOUT_LATENCY value, so 
    //             lets allow 32bpp cursors on tv for now.
    //
    // preset to short 
    HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _SHORT, CurDacAdr); 

    if (HAL_GETDISPLAYTYPE(pDacHalObj->Head) != DISPLAY_TYPE_TV)    
    {
        if ((pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A1R5G5B5) ||
            (pDacProgramCursorImgArg->colorFormat == NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_A8R8G8B8) ||
            (pDacProgramCursorImgArg->colorFormat == NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8))
        {    
            HAL_DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, CurDacAdr);
        }
    }

    // Program the start address.
    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PINST)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    HAL_DAC_REG_WR32(NV_PCRTC_CURSOR, pDacProgramCursorImgArg->startAddr, CurDacAdr);

    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV20
//
RM_STATUS
nvHalDacGetRasterPosition_NV20(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result =  (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//
//  Return 0  if not capable
//  Return ~0 if valid
//
RM_STATUS
nvHalDacValidateArbSettings_NV20(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

	fifo_info   fifo_data;
	sim_state   sim_data;
    U032        pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }

    //
    // If incoming clock is greater than DAC range, return failure
    //
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
	//
	// Build the sim table using current system settings
	//
	sim_data.pix_bpp	    = (char) pDacValidateArbSettingsArg->bpp;
	sim_data.enable_video	= pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
	sim_data.enable_mp	    = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
	sim_data.memory_width   = pDacHalInfo->InputWidth;
	sim_data.mem_latency	= 3;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0;    // 1=DD,0=SD
	sim_data.mem_aligned	= 1;
    sim_data.mem_page_miss  = 10;
	sim_data.gr_during_vid	= pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
	sim_data.pclk_khz	    = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
	sim_data.mclk_khz	    = pDacHalInfo->MClk / 1000;	                // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;                // in kHz, not MHz

    //
	// Run the numbers through the ringer
	//
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);

    /*
    //
    // If the CRTC can do this, double check to make sure the overlay is able as well
    //
    if (fifo_data.valid && video_enabled)
        fifo_data.valid = NV20_dacCalculateVideoCaps(pDev);
    */
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}

RM_STATUS
nvHalDacUpdateArbSettings_NV20(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock;
    U032        M, N, O, P;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    //
    // Check if we can support an overlay in this resolution.  If we can, set the default desktop timings
    // to assume we are running an overlay.
    //
    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = pHalHwInfo;
    dacValidateArbSettingsArg.bpp = pDacHalInfo->Depth;
    dacValidateArbSettingsArg.video_enabled = 1;
    dacValidateArbSettingsArg.mport_enabled = 0;
    dacValidateArbSettingsArg.vclk = pDacHalInfo->PixelClock * 10000;

    // if (NV20_dacValidateArbitrationSettings(pHalHwInfo, pDacHalInfo->Depth, 1, 0, (pDev->Dac.PixelClock * 10000)))
    nvHalDacValidateArbSettings_NV20(&dacValidateArbSettingsArg);
    if (dacValidateArbSettingsArg.result)
        sim_data.enable_video = 1;
    else
        sim_data.enable_video = 0;
    
	sim_data.pix_bpp	    = (char) pDacHalInfo->Depth;
	//sim_data.enable_video	= pDev->Video.Enabled ? 1 : 0;
	sim_data.enable_mp	    = pMpHalInfo->Enabled ? 1 : 0;
	sim_data.memory_width   = pDacHalInfo->InputWidth;
	sim_data.mem_aligned	= 1;
    sim_data.memory_type    = (pFbHalInfo->RamType == BUFFER_DDRAM) ? 1 : 0; //1=DD,0=SD
	sim_data.mem_latency	= 3;
    sim_data.mem_page_miss  = 10;
	sim_data.gr_during_vid	= pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
	sim_data.pclk_khz	    = pDacHalInfo->VClk / 1000;	    // in kHz, not MHz
	sim_data.mclk_khz	    = pDacHalInfo->MClk / 1000;	    // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
	// Get those new numbers
	//
    NV20_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    // for now, assume pass
    //fifo_data.valid = 1;
	
//	For TV, we should not change some of these. Gfx Fifo Low Water Mark in particular should
//		not be changed. 
//    if (pDev->Framebuffer.DisplayType != DISPLAY_TYPE_TV) // leave alone if TV

    //
	// If valid settings found, update the hardware
	//
	if (fifo_data.valid)
	{
        //
        // Set the DAC FIFO Thresholds and burst size

        /*
        //
        // Check overlay capabilities.
        //
        if (!NV20_dacCalculateVideoCaps(pDev))
            pDev->Video.OverlayAllowed = 0;
        */

        //
        // These are the PVIDEO burst/watermark hardcoded values
        // we've gotten from the HW engineers.
        //
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, 16);         // 512 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST2, 16);         // 512 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, 64);    // 1024 bytes
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK2, 64);    // 1024 bytes

		//
        // Update the CRTC watermarks
        //
		// Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

#if 0
        // XXX these are temporary CRTC burst/watermark hardcoded values
        // we've gotten from the HW engineers.
        CRTC_WR(NV_CIO_CRE_FF_INDEX, NV_CIO_CRE_FF_BURST_512);  // 512 bytes

        // XXX bump up the LWM if we're running a higher resolution (we base
        // this check on the primary surface display pitch). This is still too
        // simple a heuristic ... but it has shown to work for 1920x1440x32.

        //if (pDev->Framebuffer.DisplayPitch < 0x2000) {
        if (pDev->Dac.HalInfo.VClk < 170000000) {
		    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 64);               // 512 bytes
        } else {
		    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 80);               // 640 bytes
        }

#else
        //
        // Set the CRTC watermarks and burst size
        //
		HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);
		switch (fifo_data.crtc1_burst_size)
		{
			case 512:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
				break;
			case 256:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
				break;
			case 128:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
				break;
			case 64:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
				break;
			case 32:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
				break;
			case 16:
				HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
				break;
		}
#endif
        //
        // Relock if necessary
        //
		if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
		return (RM_OK);
	}
	else
    {
        //
        // No valid setting was found!!!
        //
        //  Make a conservative guess and fail.
        //
        
		// Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);
        
		HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x72, CurDacAdr);
		HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 5, CurDacAdr);
        
        //
        // Relock if necessary
        //
		if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
		return (RM_ERROR);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv4\dacnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

//
// Calculate the closest arbitration values for a given system configuration
//

static
VOID NV04_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO      pFbHalInfo = pHalHwInfo->pFbHalInfo;
    PMCHALINFO      pMcHalInfo = pHalHwInfo->pMcHalInfo;
    PVIDEOHALINFO   pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    mclk_freq = arb->mclk_khz;
    nvclk_freq = arb->nvclk_khz;
    pagemiss = arb->mem_page_miss;
    cas = arb->mem_latency;
    width = arb->memory_width/64;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    if (IsNV4_NV04(pMcHalInfo))
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 3; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq;    // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;       // nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;        // nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2;       // MB/s
            crtc_drain_rate = pclk_freq * bpp/8;    // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                //
                // Canopus specific code
                //      
                if (IsNV4_NV04(pMcHalInfo))
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-64))
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-27)) // 229
                            vbs = 32;
                    }
                }
                else
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 77)
                            vbs = 64;
                        if(vlwm > (256-64)) // 192
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 135)      // 146)
                            vbs = 64;
                        if(vlwm > 201)
                            vbs = 32;
                    }
                }

            } else {
                //
                // Generic code
                //
                if(vlwm > 256 - 64)
                    vbs = 32;
                else if(vlwm > 146) 
                    vbs = 64;
            }        

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                if(ram_conf == 0x0003)  
                {
                    clwm -= 32;     // SPECTRA Lite 
                    if(bpp == 32)
                        clwm -= 72; // SPECTRA Lite 
                }
            }

        } 
        else    // !video_enable
        {
        
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
            }         
        }
    
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {
            p2 = m1 * pclk_freq / mclk_freq;  // pclk cycles to drain
            p2 = p2 * bpp / 8;                // bytes drained.
        }
        else
        {
            // Generic coding
            //      
            m2us = us_pipe + us_extra;
            p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
            p2 = p1clk * bpp / 8; // bytes drained.
        }   
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Video tweaking specific to Canopus
                //
                if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
                {
                    if(mclk_extra ==0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
                else
                {         
                    //
                    // Generic coding
                    //   
                    if(mclk_extra ==0)   
                    {
                        if(cbs <= 32) 
                            found = 1;      // Can't adjust anymore!
                        else
                            cbs = cbs/2;    // reduce the burst size
                    } 
                    else 
                        mclk_extra--;
                }            
            }            
        }
        else if (video_enable)
        {

            //
            // Canopus specific code
            //
            if (IsNV4_NV04(pMcHalInfo) && (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS))
            {
                if ((clwm > 621) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra == 0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }
            else
            {
                //
                // Generic coding
                //
                if ((clwm > 511) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra <= 5)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }            
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)
                    {
                        if (h_size == 1408)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else if (h_size == 1024)
                        {
                            vlwm = 144;
                            vbs = 64;
                        }
                        else if (h_size < 1024)
                        {
                            vlwm = 128-16;
                        }
                        else
                        {
                            vlwm = 160;
                            vbs = 64;
                        }
                    }
                    else
                        vlwm = 128;
                }
            }
            else
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)  
                    {
                        if (h_size >= 1152)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else
                            vlwm = 144-16;
                    }
                    else
                        vlwm = 128;
                }

                if ((!video_enable) && (ram_conf == 0x0003))    
                {
                    if (bpp == 32)
                    {
                        if ((h_size >= 1024) && (h_size <= 1408))
                            clwm += 88;     // SPECTRA Lite 
                        else if (h_size == 960)
                            clwm += 48;
                        else
                            clwm += 32;
                    }
                    else if ((bpp == 16) && (h_size == 1920) && (v_size == 1440))
                    {
                        clwm += 8;
                    }
                }

                if (cbs == 256)    
                {
                    if (clwm > 271)    
                        clwm -= 16;
                    if ((!video_enable) && (ram_conf == 0x0003))    
                    {
                        if (clwm > 400)     // SP Lite
                            clwm = 400;
                    }
                    else
                    {
                        if (clwm > 384)     
                            clwm = 384; // 400;
                    }
                }

                // For 1920x1440x32 of Spectra5400PE
                if ((!video_enable) && (ram_conf != 0x0003) && (clwm < 384) &&
                    (h_size == 1920) && (v_size == 1440) && (bpp == 32))
                {
                    clwm = 384;
                }

            }
            
            if(clwm > 511)
                clwm = 511;
        } 
        else
        {    
            //
            // Generic coding
            //
            if(vlwm < 128) 
                vlwm = 128;
        }        
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        //    fifo->craw = craw;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
                data = (int)((vlwm+24));
            else
                data = (int)((vlwm+24));        // 15));

            if (data > 255)
                data = 255;
        }
        else      
        {
            // Generic coding    
            //
            data = (int)((vlwm+15));
            
            // Preset ranges for vlwm and vbs based on calculated vlwm
            if (vlwm > 256-32) 
            {
                data = 256;
                vbs = 32;
            } 
            else if (vlwm > 256-64) 
            {
                data = 256-32+16;
                vbs = 32;
            } 
            else if (vlwm > 256-128) 
            {
                data = 256-64+16;
                vbs = 64;
            } 
            else 
            {
                data = 256-128+16;
                vbs = 128;
            }
            
        }        

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


static
void NV04_dacCalculateArbitration_SMA
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO  pFbHalInfo = pHalHwInfo->pFbHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    //mclk_freq = arb->mclk_khz;
    mclk_freq = 100000;
    nvclk_freq = arb->nvclk_khz;
    //pagemiss = arb->mem_page_miss;
    pagemiss = 7;
    //cas = arb->mem_latency;
    cas = 3;
    width = 1;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    //if (IsNV4(pDev))
    if (/*IsNV4(pDev)*/ 1)
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 4; // prev burst
    mclks += 2; // ALI arb
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 2; // ALI rd pipe
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 12; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2; // MB/s
            crtc_drain_rate = pclk_freq * bpp/8; // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Generic code
            //
            if(vlwm > 256 - 64)
                vbs = 32;
            else if(vlwm > 146) 
                vbs = 64;

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

        } 
        else    // !video_enable
        {
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
        }         
        }
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        // Generic coding
        //      
        m2us = us_pipe + us_extra;
        p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
        p2 = p1clk * bpp / 8; // bytes drained.
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Generic coding
                //   
                if(mclk_extra ==0)   
                {
                    if(cbs <= 32) 
                        found = 1;      // Can't adjust anymore!
                    else
                        cbs = cbs/2;    // reduce the burst size
                } 
                else 
                    mclk_extra--;
            }            
        }
        else if (video_enable)
        {

            //
            // Generic coding
            //
            if ((clwm > 511) || (vlwm > 255)) 
            {
                fifo->valid = 0;
                found = 0;
                if(mclk_extra <= 5)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Generic coding
        //
        if(vlwm < 128) 
            vlwm = 128;
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        if (data > 511) fifo->valid = 0;
        //    fifo->craw = craw;

        //
        // Video tweaking 
        //
        data = (int)((vlwm+15));
        
        // Preset ranges for vlwm and vbs based on calculated vlwm
        if (vlwm > 256-32) 
        {
            data = 256;
            vbs = 32;
        } 
        else if (vlwm > 256-64) 
        {
            data = 256-32+16;
            vbs = 32;
        } 
        else if (vlwm > 256-128) 
        {
            data = 256-64+16;
            vbs = 64;
        } 
        else 
        {
            data = 256-128+16;
            vbs = 128;
        }
            

        if (data > 255) fifo->valid = 0;

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


typedef struct tagNV04_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV04_DacAGPClockEntry;

NV04_DacAGPClockEntry NV04_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//
 
// forwards
RM_STATUS nvHalDacAlloc_NV04(VOID *);
RM_STATUS nvHalDacFree_NV04(VOID *);
RM_STATUS nvHalDacControl_NV04(VOID *);
RM_STATUS nvHalDacUpdateStartAddress_NV04(VOID *);
RM_STATUS nvHalDacProgramMClk_NV04(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV04(VOID *);
RM_STATUS nvHalDacProgramPClk_NV04(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV04(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV04(VOID *);
RM_STATUS nvHalDacValidateArbSettings_NV04(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV04(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV04(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PFBHALINFO  pFbHalInfo;
    PMCHALINFO  pMcHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PDACHALINFO_NV04    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV04)pHalHwInfo->pDacHalPvtInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
            //
            // Set bus width.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _RAM_WIDTH_128) == NV_PFB_BOOT_0_RAM_WIDTH_128_ON)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            //
            // Initialize video clock.
            //
            pDacHalInfo->VClk = 0;

            //
            // Determine the maximum pixel clock for 8bpp, 16bpp, and 32bpp for this configuration.
            //
            // This will rely on silicon DAC speed, memory bandwidth, and arbitration limits.
            //
            // For now, hardcode the known values.
            //
            if (IsNV4_NV04(pMcHalInfo))
            {
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            else if (IsNV5_NV04(pMcHalInfo))
            {
                switch (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_FUNC))
                {
                    // Std TNT2
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA:
                    // Std Ultra
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_ALT1:
                    // Std TNT2 Model64
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC1:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 250000000;
                        break;

                    // Std Vanta
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC0:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 203000000;
                        break;

                    // Default
                    default:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
                        break;
                } 

                // 
                // If we're running in SMA mode, drop down the limits accordingly
                //
                if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
                {
                    //
                    // Determine how much bandwidth we probably have to system memory
                    //
                    if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;
                    }
                    else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 126000000;
                    }
                    else // (pProcessorHalInfo->SystemMemoryFreq == 66000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp =  85000000;
                    }
                }

            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: unknown chip; using pixelclock defaults\n");
                // defaults
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // All display types allowed.
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // No downscaling on nv4 and family...
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 1;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 1;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 1;

            break;
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV04(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV04(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV04(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032 StartAddress = pDacSetStartAddrArg->startAddr;
    U032 prev_bit24, curr_bit24;
    U008 lock, crtc_index, temp;
    U032 CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    
    // Only NV5 needs special treatment regarding PCRTC_START
    if (!IsNV5_NV04(pHalHwInfo->pMcHalInfo))
    {
        REG_WR32(NV_PCRTC_START, StartAddress);
        return (RM_OK);
    }

    //
    // NV5 Bug. Eventhough bit24 should be writable in PCRTC_START, it's not.
    // So, if we need to change its value (i.e. bit24 goes from 0->1 or 1->0),
    // then we'll set/clear bit24 value via the CRE_HEB CRTC reg.
    //
    prev_bit24 = REG_RD32(NV_PCRTC_START) & 0x1000000;
    curr_bit24 = StartAddress & 0x1000000;

    // For NV5, this will properly write bits 23:0
    REG_WR32(NV_PCRTC_START, StartAddress);
    if (prev_bit24 ^ curr_bit24)
    {
        // Save the current CRTC index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)          // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);     // save crtc index

        // Unlock CRTC extended regs (following is from ReadCRTCLock)
        // lock = ReadCRTCLock(pDev);
        CRTC_READ(NV_CIO_SR_LOCK_INDEX, temp);
        switch (temp)
        {
            case 0x03:
                lock = 0x57;
                break;
            case 0x01:
                lock = 0x75;
                break;
            case 0x00:
                lock = 0x99;
                break;
            default:
                lock = temp;
                break;
        }
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        // bit6 corresponds to StartAddress bit24. All other
        // bits were successfully written via PCRTC_START.
        CRTC_READ(NV_CIO_CRE_HEB__INDEX, temp);
        temp &= 0xBF;                           // mask off bit6
        temp |= ((curr_bit24 >> 24) << 6);      // set/clear bit6
        CRTC_WRITE(NV_CIO_CRE_HEB__INDEX, temp);

        // Relock extended regs
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, lock);
        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);     // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);      // restore crtc index
    }

    return (RM_OK);
}

//  Read extended CRTC lock register and return corresponding write value
static U008 ReadCRTCLock_NV04
(
    PHALHWINFO pHalHwInfo,
    U032    Head
)
{
    U008 data;

    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
            data = 0x99;
            break;
    }
    return data;
}

//
// nvHalDacProgramMClk_NV04 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV04(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _DEBUG_0, _REFRESH_COUNTX64 ) * 64;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _DEBUG_0, _REFRESH_COUNTX64, newCyclesPerRefresh / 64 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV04 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV04(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 i;
    U032 Head = 0; // NVPLL is on head 0
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV04_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV04_dacAGPClockTable ) / sizeof( NV04_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV04_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV04 - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramPClk_NV04(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV04
//
RM_STATUS
nvHalDacProgramCursorImage_NV04(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    U008    cr31, cr2f;
    U008    lock;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Unlock CRTC extended regs
    lock = ReadCRTCLock_NV04(pHalHwInfo, pDacHalObj->Head);
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

    // On chips < NV10, the cursor image is always assumed to be a 32x32 image with a color
    // format LE_ROP1R5G5B5. So we ignore the width, height and colorFormat parameters.

    // Mark the Address Space Indicator (bit 7 in NV_CIO_CRE_HCUR_ADDR0_INDEX) 
    // to indicate where the cursor image is based on the param "asi".

    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == DAC_ASI_INSTMEM)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    // The startAddr is programmed into two config registers as follows:
    // cr2f<0>   = startAddr<24>
    // cr30<6:0> = startAddr<23:17>
    // cr31<7:2> = startAddr<16:11>
    // startAddr<10:0> is assumed to be 0.
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    cr2f &= 0xFE;
    cr2f |= (U008)((pDacProgramCursorImgArg->startAddr >> 24) & 0x01);
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, 
               (U008) ( ((pDacProgramCursorImgArg->startAddr >> 17) & 0x7f) | (pDacProgramCursorImgArg->asi << DEVICE_BASE(NV_CIO_CRE_HCUR_ASI)) ),
               CurDacAdr);
            
    // store startAddr bits 16:11 in cr31 bits 7:2
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);
    cr31 &= 0x03; // Clear bits 7:2
    cr31 |= (U008)((pDacProgramCursorImgArg->startAddr >> 9) & 0xfc); // Set the new start address
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);

    // Restore original state of CRTC lock register
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
    
    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV04
//
RM_STATUS
nvHalDacGetRasterPosition_NV04(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result = (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}

//
// Attempt to validate the given parameters will work with the current configuration
//       
//  Return 0  if not capable
//  Return ~0 if valid  
//
RM_STATUS
nvHalDacValidateArbSettings_NV04(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info fifo_data;
    sim_state sim_data;
    U032 pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    //
    // First we must validate that the incoming vclk is within our DAC range.
    //
    switch (pDacValidateArbSettingsArg->bpp)
    {
        case 8:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp;
            break;
        case 15:
        case 16:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
        case 24:
        case 32:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp;
            break;
        default:
            pclk_limit = pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp;
            break;
    }            
    //
    // If incoming clock is greater than DAC range, return failure
    //        
    if (pDacValidateArbSettingsArg->vclk > pclk_limit)
    {
        pDacValidateArbSettingsArg->result = 0;
        return (RM_OK);
    }
        
    //
    // Although the memory arbiter may allow video accesses, we can't exceed
    // the video pipeline's circuit limits
    //
    // Hardcode NV4 to 163MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV4_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 163000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV5 to 235MHz.  32bpp video may fail due to arbiter failure
    // even under this rate, but that check comes next.
    //
    if (IsNV5_NV04(pMcHalInfo))
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->vclk > 235000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }
    //
    // Hardcode NV0A 8/16bpp to a 206MHz limit, or in the UMA mode, based on memory speed
    //
    // NOTE This is just for Crush level integrated products
    //
    if (IsNV0A_NV04(pMcHalInfo))
    {
        //
        // Never let Crush enable video above 206MHz
        //
        if ((pDacValidateArbSettingsArg->video_enabled) &&
            (pDacValidateArbSettingsArg->bpp < 32) &&
            (pDacValidateArbSettingsArg->vclk > 206000000))
        {
            pDacValidateArbSettingsArg->result = 0;
            return (RM_OK);
        }

        //
        // Further restrictions for UMA configurations due to limited bandwidth
        //
        if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        {
            // Is this 133MHz memory?
            if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
            {
                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }
            }
            // or 100MHz memory?
            else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 110000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }           

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 70000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
            else // we must be using 66MHz memory or lower
            {
                if ((pDacValidateArbSettingsArg->bpp < 32) &&
                    (pDacValidateArbSettingsArg->vclk > 60000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      

                if ((pDacValidateArbSettingsArg->bpp == 32) &&
                    (pDacValidateArbSettingsArg->vclk > 53000000))
                {
                    pDacValidateArbSettingsArg->result = 0;
                    return (RM_OK);
                }      
            }
        }
    }

    //
    // Current NV10 video has no limit in this range
    //            
            
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacValidateArbSettingsArg->bpp;
    sim_data.enable_video   = pDacValidateArbSettingsArg->video_enabled ? 1 : 0;
    sim_data.enable_mp      = pDacValidateArbSettingsArg->mport_enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char)REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int)REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacValidateArbSettingsArg->vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Run the numbers through the ringer
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    pDacValidateArbSettingsArg->result = (U032)fifo_data.valid;
    return (RM_OK);
}                
                                                      
RM_STATUS
nvHalDacUpdateArbSettings_NV04(VOID *arg)
{
    PDACUPDATEARBSETTINGSARG_000     pDacUpdateArbSettingsArg = (PDACUPDATEARBSETTINGSARG_000) arg;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;
    PMPHALINFO          pMpHalInfo;
    U032                Head;
    U032                CurDacAdr;

    fifo_info   fifo_data;
    sim_state   sim_data;
    U008        lock;
    U032        M, N, O, P;

    //
    // Verify interface revision.
    //
    if (pDacUpdateArbSettingsArg->id != DAC_UPDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacUpdateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacUpdateArbSettingsArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    Head = pDacHalObj->Head;

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //
    M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
    N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
    P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;
    
    pDacHalInfo->VPllM = M;
    pDacHalInfo->VPllN = N;
    pDacHalInfo->VPllO = O;
    pDacHalInfo->VPllP = P;
    pDacHalInfo->VClk  = (N * pMcHalInfo->CrystalFreq / (1 << P) / M);
    
    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char) pDacHalInfo->Depth;
    sim_data.enable_video   = pVideoHalInfo->Enabled ? 1 : 0;
    sim_data.enable_mp      = pMpHalInfo->Enabled ? 1 : 0;
    sim_data.memory_width   = pDacHalInfo->InputWidth;
    sim_data.mem_latency    = (char) REG_RD_DRF(_PFB, _CONFIG_1, _CAS_LATENCY); //3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char) (REG_RD_DRF(_PFB, _CONFIG_1, _RAS_RAS) + REG_RD_DRF(_PFB, _CONFIG_1, _READ_TO_PCHG)); //10;
    sim_data.ram_config     = (int) REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_RAMCFG); 
    sim_data.gr_during_vid  = pVideoHalInfo->ColorKeyEnabled ? 1 : 0;
    sim_data.pclk_khz       = pDacHalInfo->VClk / 1000;     // in kHz, not MHz
    sim_data.mclk_khz       = pDacHalInfo->MClk / 1000;     // in kHz, not MHz
    sim_data.nvclk_khz      = pDacHalInfo->NVClk / 1000;    // in kHz, not MHz

    // 
    // Get those new numbers
    //
    if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
        NV04_dacCalculateArbitration_SMA(pHalHwInfo, &fifo_data, &sim_data);
    else
        NV04_dacCalculateArbitration(pHalHwInfo, &fifo_data, &sim_data);
    
    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_TV)
        {
            REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        }
        else
        {
            // If we are upscaling video, we may not drain fast enough (fifo overflow), since
            // for every pixel from the framebuffer, we've got to send out more than one pixel. 
            // On 64 bit devices at high pixel clocks, the watermark will be set to maximum,
            // to solve the opposite problem (fifo underflow, draining faster than we fill),
            // This makes it more likely to overflow, so make sure we are not set to max 
            // low water mark. (At 16x12 > 60 Hz, we will get set to max lwm, causing us to
            // overflow when scaling the video to full screen.)
            if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled)
            {
                if (fifo_data.video_lwm == 128*2)           // if set to max
                    fifo_data.video_lwm -= 8*2;             // drop down one notch
                // We must also prevent underflow. Letting the CRTC fifo use max bursts can starve video.
                if (fifo_data.crtc1_burst_size == 256)      // if set to max
                    fifo_data.crtc1_burst_size >>= 1;       // drop down on notch
            }

            REG_WR32(NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
            switch (fifo_data.video_burst_size)
            {
                case 128:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 3);
                    break;

                case 64:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 2);
                    break;

                case 32:
                    REG_WR32(NV_PVIDEO_FIFO_BURST, 1);
                    break;
            }
        }

        //
        // If the video LWM is maxed out in a 64bit device, make sure to drop the graphics burst down
        // to provide additional bandwidth.
        //
        if ((pDacHalInfo->InputWidth == 64) && pVideoHalInfo->Enabled && ((fifo_data.video_lwm >> 1) == 0x80))
        {        
            // Make sure we've got room to drop
            if ((fifo_data.crtc1_burst_size > 128) && (pDacHalInfo->Depth==8)) 
                fifo_data.crtc1_burst_size >>= 2;
        }            
        
        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
        HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

        //
        // Set the CRTC watermarks and burst size
        //
        if (HAL_GETDISPLAYTYPE(Head) != DISPLAY_TYPE_TV) // leave alone if TV
        {       
            HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, (U008) (fifo_data.crtc1_lwm >> 3), CurDacAdr);

            switch (fifo_data.crtc1_burst_size)
            {
                // If the DFP uses shortened blanking, we may run out of time.
                // Limiting burst to 64 prevents starving the fifo when running video.
                // This is not a problem on NV10 because of larger fifo size.
                // We're not checking for shortened blanking, instead we'll always limit burst
                // size for video + DFP. This may reduce performance, but we assume no one cares.
                case 256:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    break;

                case 128:
                    if ((HAL_GETDISPLAYTYPE(Head) == DISPLAY_TYPE_FLAT_PANEL) && (pVideoHalInfo->Enabled))
                    {
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    }
                    else
                        HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 3, CurDacAdr);
                    break;

                case 64:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 2, CurDacAdr);
                    break;

                case 32:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 1, CurDacAdr);
                    break;

                case 16:
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 0, CurDacAdr);
                    break;
            }
            //
            // Manual override of LWM and Burst, if necessary and possible
            //
            if (pDacHalInfo->Enable256Burst && !pVideoHalInfo->Enabled && (pDacHalInfo->InputWidth == 128))
            {
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth == 16)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                    HAL_CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x0F, CurDacAdr);
                }            
        
                if ((pFbHalInfo->HorizDisplayWidth == 1024)
                    && (pFbHalInfo->VertDisplayWidth == 768)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            

                if ((pFbHalInfo->HorizDisplayWidth == 1280)
                    && (pFbHalInfo->VertDisplayWidth == 1024)
                    && (pDacHalInfo->Depth >= 24)
                    && ((pFbHalInfo->RefreshRate == 75) || (pFbHalInfo->RefreshRate == 85)))
                {
                    HAL_CRTC_WR(NV_CIO_CRE_FF_INDEX, 4, CurDacAdr);
                }            
            
            }
        }        
        //
        // Relock if necessary
        //
        if (lock == 0)
            HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, CurDacAdr);
        
        return (RM_OK);
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return (RM_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\bios.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: bios.c
*
*   Description:
*       generic bios read/write routines
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>

#include <bios.h>

RM_STATUS BiosReadBytes(
    PHWINFO pDev,
    U008    buffer[],
    U032    offset,
    U032    size
)
{
    U032 i;

    for (i = 0; i < size; i++)
    {
        buffer[i] = BIOS_RD08(pDev->biosOffset + offset + i);
    }

    return RM_OK;
}

RM_STATUS BiosCalculateSizes(
    const char *format,
    U032       *pPackedSize,
    U032       *pPaddedSize
)
{
    U032 packed_size = 0;
    U032 padded_size = 0;
    char fmt;

    while ((fmt = *format++))
    {
        U032 count;

        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        switch (fmt)
        {
            case 'b':
                packed_size += count * 1;
                padded_size += count * sizeof(bios_U008);
                break;
            case 'w':
                packed_size += count * 2;
                padded_size += count * sizeof(bios_U016);
                break;
            case 'd':
                packed_size += count * 4;
                padded_size += count * sizeof(bios_U032);
                break;
        }
    }

    if (pPackedSize) *pPackedSize = packed_size;
    if (pPaddedSize) *pPaddedSize = padded_size;

    return RM_OK;
}


/*
  Unpack little-endian byte stream data, and expand to an array of 32-bit values.
*/
RM_STATUS BiosUnpackLittleEndianStructure(
    U008 *packedLEData,
    U032 *unpackedData,
    const char *format,
    U032 *fields,
    U032 *unpacked_bytes
)
{
    U032 count;
    U032 unpacked;
    char fmt;

    *fields = 0;
    *unpacked_bytes = 0;

    for ( ; (fmt = *format++); )
    {
        count = 0;
        while ((fmt >= '0') && (fmt <= '9'))
        {
            count *= 10;
            count += fmt - '0';
            fmt = *format++;
        }
        if (count == 0) count = 1;

        while (count--)
        {
            switch (fmt)
            {
                case 'b':
                    unpacked = *packedLEData++;
                    *unpacked_bytes += 1;
                    break;

                case 'w':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    *unpacked_bytes += 2;
                    break;

                case 'd':
                    unpacked =  *packedLEData++;
                    unpacked |= *packedLEData++ << 8;
                    unpacked |= *packedLEData++ << 16;
                    unpacked |= *packedLEData++ << 24;
                    *unpacked_bytes += 4;
                    break;

                default:
                    return RM_ERROR;
            }
            *unpackedData++ = unpacked;
            (*fields)++;
        }
    }

    return RM_OK;
}

RM_STATUS BiosReadStructure(
    PHWINFO     pDev,
    void       *structure,
    U032        offset,
    U032       *ppacked_size,
    const char *format
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 packed_size;
    void *packed_data = 0;
    U032 fields;
    U032 unpacked_bytes;
    U008 small_buffer[256];

    // calculate the size of the data as indicated by its packed format.
    BiosCalculateSizes(format, &packed_size, (U032 *) 0);
    if (ppacked_size)
        *ppacked_size = packed_size;

    if (packed_size <= sizeof(small_buffer))
        packed_data = small_buffer;
    else
    {
        rmStatus = osAllocMem((VOID **) &packed_data, packed_size);
        if (rmStatus != RM_OK)
            goto done;
    }

    rmStatus = BiosReadBytes(pDev, (U008*) packed_data, offset, packed_size);
    if (rmStatus != RM_OK)
        goto done;

    rmStatus = BiosUnpackLittleEndianStructure(packed_data, structure, format, &fields, &unpacked_bytes);

 done:
    if (packed_data && (packed_data != small_buffer))
        osFreeMem(packed_data);

    return rmStatus;
}

RM_STATUS BiosReadArray(
    PHWINFO     pDev,
    void       *buffer,
    U032        offset,
    U032        count,
    U032       *ppacked_size,
    const char *format
)
{
    U032 packed_size, padded_size;
    U032 i;
    
    BiosCalculateSizes(format, &packed_size, &padded_size);

    for (i=0; i<count; i++)
    {
        if (RM_OK != BiosReadStructure(pDev,
                                       (U008*)buffer + (i * padded_size),
                                       offset + (i * packed_size),
                                       (U032 *) 0,
                                       format))
            return RM_ERROR;
    }

    // packed_size will be size of 1 element, what is total?
    if (ppacked_size) *ppacked_size = count * packed_size;

    return RM_OK;
}

U008 BiosRead8(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U008 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "b");

    return (U008) data;
}


U016 BiosRead16(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "w");
    return (U016) data;
}

U032 BiosRead32(
    PHWINFO  pDev,
    U032     offset
)
{
    bios_U032 data;     // BiosReadStructure expects 'bios' types

    (void) BiosReadStructure(pDev, &data, offset, (U032 *) 0, "d");

    return (U032) data;
}


RM_STATUS BiosFindString(
    PHWINFO pDev,
    U008 string[],
    U032 *offset,
    U032 string_size
)
{
    int i, j;
    int bios_size;

    bios_size = BIOS_ROM_CODE_SIZE - string_size + 1;
    for (i = 0; i < bios_size; i++)   /* i is offset into bios */
    {
        j = 0;  /* j is offset into search string */

        /* while the bios substring matches the desired string.. */
        while (string[j] == BIOS_RD08(i + j)) j++;

        /* if we're on the null character, we found the string.. */
        if (string[j] == NULL)
        {
            *offset = i;
            return RM_OK;
        }
    }
    return RM_ERROR;
}


RM_STATUS BiosGetMaxExternalPCLKFreq
(
    PHWINFO pDev,
    U032 head,
    U032* freq
)
{
    // Try to find the frequency of an external DAC for the given head
    // The frequency return is in freq(Mz)*100
    RM_STATUS status = RM_OK;
    DEV_HEAD dev_head;
    U032 dev_offset = 0; 
    U032 offset = 0;
    U032 size = 0;

    // Display_Devices offset is found at offset 0x0036
    offset = BiosRead16( pDev, 0x0036 );

    if ( offset == 0 )
    {
        status = RM_ERROR;
    }
    else
    {
        // Read header to check version
        status = BiosReadStructure( pDev, &dev_head, offset, &size, DEV_HEAD_FMT );
        dev_offset = offset + size;

        if ( status == RM_OK )
        {
            if ( dev_head.version >= 0x13 )
            {
                // Start reading DEVICE structures 1 at a time until we hit the end
                BOOL bDone = FALSE;
                int i = 0;

                while ( !bDone )
                {
                    DEV_REC_STRUC dev_rec_struc;

                    status = BiosReadStructure( pDev, &dev_rec_struc, dev_offset, &size, DEV_REC_STRUC_FMT );
                    dev_offset = dev_offset + size;
                    i++;

                    // Check for end 
                    if ( dev_rec_struc.dev_type == DEV_REC_UNUSED_DEV )
                    {
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                    else if ( ( dev_rec_struc.dev_type & DEV_REC_CRT_DEV_MASK ) == 
                        ( DEV_REC_CRT_DEV_EXTERNAL_DAC | ( head << DEV_REC_HEAD_SHIFT ) ) )
                    {
                        // We found an external DAC
                        *freq = dev_rec_struc.data_rsvr;
                        status = RM_OK;
                        bDone = TRUE;
                    }
                    else if ( i > 128 )
                    {
                        // This is a safety check for a bad BIOS
                        // We should never ever hit this!
                        status = RM_ERROR;
                        bDone = TRUE;
                    }
                }
            }
            else
            {
                status = RM_ERROR;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv15mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv15mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv15 and NV11.
*
*	Revision History:
*		Original -- 1/00 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>

#endif

RM_STATUS Nv15MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0;  // MPLL & NVPLL are on Head 0

    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // program NVCLK
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_NVPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P)
    );
                                        
    // program MCLK -- double the clock if flags indicate DDR memory
    clk = memInitTable[memInitTableIndex].MClk_PLL;
    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P));
            
    return rmStatus;
    
} // end of Nv15MemConfigureClocks()

    
RM_STATUS Nv15MemConfigureMemory
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV15 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    
    
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, 0);
    memInitTableIndex >>= 4;
    
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                if ((initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++]) != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv15MemConfigureMemory()



// end of nv15mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv04mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv04mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV4.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: the actual memory detection and sizing is device dependent
extern char strDevNodeRM[];

RM_STATUS Nv04MemResizeMemory
(
	PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 memoryType;
    U008 sgram_mem[] = "SGRAM";
    U008 sdram_mem[] = "SDRAM";
    U032 offset;

    // check for registry override of memory type
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "VideoMemoryTypeOverride", &memoryType) == RM_OK)
    {
        switch(memoryType)
        {
            case DEVINIT_SDRAM:
                rmStatus = Nv04MemResizeSdram(pDev);
                break;
                
            case DEVINIT_SGRAM:
                rmStatus = Nv04MemResizeSgram(pDev);
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    } else {
        rmStatus = BiosFindString(pDev, sgram_mem, &offset, sizeof(sgram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSgram(pDev);
            goto done;
        }
 
        rmStatus = BiosFindString(pDev, sdram_mem, &offset, sizeof(sdram_mem));
        if (rmStatus == RM_OK)
        {
            rmStatus = Nv04MemResizeSdram(pDev);
            goto done;
        } 

        rmStatus = RM_ERROR;
    }

done:
    return rmStatus;
                
} // end of DevinitResizeMemory()

RM_STATUS Nv04MemResizeSdram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
	// turn on refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

    // assume 16MB, 128-bit, 1024K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_1024K_2BANK);   
    Nv04MemLatchMemConfig(pDev);

    // write 128 bits of data for the test sequence
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
                                                 
    // if the lower 16 bits of 128-bit word is invalid, change to 8M
    if (FB_RD16(0x0000000C) != '4A')
    {
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...
    
    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SDRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SDRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SDRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSdram()

RM_STATUS Nv04MemResizeSgram
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 i, memDevSize;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
        
    // disable refresh for the entire routine 
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_DISABLED);

    // assume 16MB, 128-bit, 512K 2-bank
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_ON);
    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_TYPE,_512K_2BANK);    
    Nv04MemLatchMemConfig(pDev);

    // write 128-bit test data word at the beginning of FB
    for (i = 0; i < 4; i++)
    {
        FB_WR32(i * 4, 'NV4A');
    }    
    
    // determine the size of the memory devices, i.e. 8 or 16 Mbit
    memDevSize = (FB_RD32(0x00000000) == 'NV4A') ? 16 : 8;

    // determine the interface width
    if (FB_RD16(0x0e) == 'NV')
    {
        // 128-bit width detected
        
        // detect 8mbit or 16mbit @ 128-bits
        if (memDevSize == 16)
        {
            // 16mbit device, 128-bit width detected
            
            // detect 8MB or 16MB total RAM amount
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) != 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
        }
        else
        {
            // 8mbit device, 128-bit width detected
            
            // detect 4MB or 8MB total RAM amount
            // Note: unclear about 4/8M test -- write at 4Meg or 8Meg??? -- !!!!! TEST THIS !!!!!
            FB_WR32(0x00800000, 'A4VN');
            if (FB_RD32(0x00800000) == 'A4VN')
            {
                // 8MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
            }
            else
            {
                // 4MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
            }
        }
    }
    else
    {
        // 64-bit width detected
        
        // since 8MBit device is not valid at 64-bit width, 4MB detected, so change config
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
    }

    // insure the memory config gets set
    Nv04MemLatchMemConfig(pDev);

	// reenable refresh
    FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

	// TO DO: is this necessary?
	// turn off full CPU access
	//...

    // output results
    switch (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT))
    {
        case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   4MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   8MB SGRAM\n");
            break;
            
        case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM:   16MB SGRAM\n");
            break;
            
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unknown Size SGRAM\n");
            break;
    }

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv04MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\portable\nv_local.h ===
/*
 * nv_local.h
 *     placeholder for customer/OEM definitions for required
 *     macros for devinit() code.  It is hoped that all customer
 *     changes can be confined to this file.
 */

/*
 * read/write memory
 */

#define REG_WR32(a,d)   
#define REG_RD32(a)       0
#define REG_WR08(a,d)   
#define REG_RD08(a)       0

#define PRMCIO_REG_WR32(b,o,d)   
#define PRMCIO_REG_RD32(b,o)     0

#define CRTC_WR(i,d)    
#define CRTC_RD(i,d)       0


#ifdef DEBUG
#include <stdout.h>
#define DBG_PRINT_STR(s)  fprintf(stderr, (s))
#else
#define DBG_PRINT_STR(s)  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\devinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Module: devinit.c
*
*   Description:
*       Device POST code.
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/


#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else   /* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

// TO DO: this is a hack to avoid osallocmem() from an isr (the TMDS bip3 interpret is called during modeset)
static BIOS_BIP3_TABLES bip3_static_tables;


// ***** MAIN ENTRY POINT FOR DEVICE INITIALIZATIONS *****

RM_STATUS DevinitInitializeDevice
(
    PHWINFO pDev,
    PHWREG  externalBiosImage,
    BOOL   *pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 lock, offset;
    PHWREG tempBiosAddr;
    BMP_Control_Block bmpCtrlBlk;
    U032 Head = 0;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initializing device...\n");

    // enable VGA subsystem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_21,_VGA,_ENABLED);

    // Unlock CRTC extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // determine current strap crystal frequency (in Hz), if it has not already been set
    if (pDev->Chip.HalInfo.CrystalFreq == 0)
    {
        if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
            pDev->Chip.HalInfo.CrystalFreq = 13500000;
        else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
            pDev->Chip.HalInfo.CrystalFreq = 14318180;
    }

    // be pessimistic
    *pBiosUsedToInit = FALSE;

    // use the external bios image, if present
    tempBiosAddr = biosAddr;
    if (externalBiosImage)
    {
        biosAddr = externalBiosImage;
    }

    // pull in the BMP control block
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);

    // process the initialization code
    if (rmStatus == RM_OK)
    {
        // use the BIOS image to init
        if ((bmpCtrlBlk.CTL_Version >= BMP_INIT_TABLE_VER_5) &&
            (bmpCtrlBlk.CTL_Flags >= BMP_INIT_TABLE_SUBVER_0x10))
        {
            // initialize the device using BIP/3 code
            rmStatus = DevinitProcessBip3(pDev);
            if (rmStatus == RM_OK)
                *pBiosUsedToInit = TRUE;
        }
        else
        {
            // initialize the device using BIP/2 code
            rmStatus = DevinitProcessBip2(pDev, offset, bmpCtrlBlk, pBiosUsedToInit);
        }
    }
    else
    {
        // use the static tables to init
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot find BMP Control Block, using static tables...\n");
        rmStatus = DevinitProcessStaticTables(pDev);
    }

    // restore original biosAddr
    biosAddr = tempBiosAddr;

    // restore original extended CRTC register lock value
    if (lock == 0)
    {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

    // enable shadowing of BIOS
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_ENABLED);

    if (rmStatus == RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device initialization succeeded\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device initialization *** FAILED ***\n");
    }

    return rmStatus;

} // end of DevinitInitializeDevice()

RM_STATUS DevinitGetBMPControlBlock
(
    PHWINFO             pDev,
    BMP_Control_Block  *pControlBlock,
    U032               *offset
)
{
    RM_STATUS rmStatus = RM_ERROR;
    int i;

    // attempt to find the init info in the BIOS
    for (i = 0; i < MAX_BIOS_SCAN-3; i++)
        if (BIOS_RD32(i) == CTRL_BLK_ID)
            break;

    if (i < MAX_BIOS_SCAN-3)
    {
        int so;

        // going to recalc offset, so make sure it is zero now since the
        //   following read must happen at exactly 'i'
        pDev->biosOffset = 0;

        rmStatus = BiosReadStructure(pDev,
                                     (U008*) pControlBlock,
                                     i,
                                     (U032 *) 0,
                                     BMP_CONTROL_BLOCK_FMT);
        if (rmStatus != RM_OK)
            goto done;

        // The BMP tables have offsets with them relative to the beginning
        //   of the rom.  If the rom has been relocated, these offsets will
        //   be bogus.
        //   Calculate an 'extra offset' to compensate and save it in the pDev
        //
        //   This happens on Mac roms when the devinit portion is relocated
        //   from its normal location in the pc bios image to the end of the
        //   openforth image.
        //

        for (so = i-2; so >= 0; so--)
            if ((BIOS_RD08(so) == 0x55) && (BIOS_RD08(so+1) == 0xAA))
                break;
        if (so >= 0)
            pDev->biosOffset = so;

        // where did we get the table from?
        *offset = i - pDev->biosOffset;
    }

 done:
    return rmStatus;
}


// ***** CORE 2 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip2
(
    PHWINFO pDev,
    U032 offset,
    BMP_Control_Block bmpCtrlBlk,
    BOOL* pBiosUsedToInit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 genInitTableOffset, extraInitTableOffset, sizeInitTable, memInitTableOffset, SDRSeqTableOffset, DDRSeqTableOffset;
    devinit_tables_t *dt = 0;

    rmStatus = DevinitGetInitTableInfo(pDev,
                                       offset,
                                       &bmpCtrlBlk,
                                       &genInitTableOffset,
                                       &extraInitTableOffset,
                                       &sizeInitTable,
                                       &memInitTableOffset,
                                       &SDRSeqTableOffset,
                                       &DDRSeqTableOffset);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid BIOS init info version\n");
        goto fallback;
    }

    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: genInitData too large\n");
        goto fallback;
    }

    // allocate space for init tables
    rmStatus = osAllocMem((VOID **) &dt, sizeof(*dt));
    if (rmStatus != RM_OK)
        goto done;
    dt->genInitData   = (U008 *) 0;      // allocate later based on actual size
    dt->genInitCode   = (U032 *) 0;      // allocate later based on actual size
    dt->extraInitData = (U008 *) 0;      // allocate later based on actual size
    dt->extraInitCode = (U032 *) 0;      // allocate later based on actual size

    // allocate room for the genInitData
    rmStatus = osAllocMem((VOID **) &dt->genInitData, sizeInitTable);
    if (rmStatus != RM_OK)
        goto done;
    rmStatus = osAllocMem((VOID **) &dt->genInitCode, sizeInitTable * sizeof(U032));
    if (rmStatus != RM_OK)
        goto done;
    if (extraInitTableOffset)
    {
        // assume any extra init table no bigger than 'sizeInitTable'
        rmStatus = osAllocMem((VOID **) &dt->extraInitData, sizeInitTable);
        if (rmStatus != RM_OK)
            goto done;
        rmStatus = osAllocMem((VOID **) &dt->extraInitCode, sizeInitTable * sizeof(U032));
        if (rmStatus != RM_OK)
            goto done;
    }

    // extract the memory init code from the BIOS into a buffer
    if (memInitTableOffset)
    {
        int   padded_size_each;
        char *fmt;

        // figure out if using NV10 or NV15 format
        DevinitMeminitFormat(pDev, &fmt, &padded_size_each);

        // extract the array of memory formats
        // trick is that this array has to look right to the NV10 or NV15
        // routines which are expecting their own slice typedef
        BiosReadArray(pDev,
                      (VOID *) dt->memInitTable,
                      memInitTableOffset,
                      MEM_INIT_STRAP_MAX + 1,
                      (U032 *) 0,
                      fmt);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS,
                             "NVRM: could not unpack meminit table data\n");
            goto fallback;
        }
    }

    // extract the SDR init sequence from the BIOS into a buffer
    if (SDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*) dt->SDRSeqTable,
                                     SDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract SDR data\n");
            goto fallback;
        }
    }

    // extract the DDR init sequence from the BIOS into a buffer
    if (DDRSeqTableOffset)
    {
        rmStatus = BiosReadStructure(pDev,
                                     (U008*)dt->DDRSeqTable,
                                     DDRSeqTableOffset,
                                     (U032 *) 0,
                                     MEM_SEQ_FMT);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: could not extract DDR data\n");
            goto fallback;
        }
    }

    // Make sure we don't overflow the init code buffer
    if (sizeInitTable > BMP_INIT_CODE_SIZE_MAX)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Init table too large\n");
        rmStatus = RM_ERROR;
        goto fallback;
    }

    rmStatus = BiosReadBytes(pDev, dt->genInitData, genInitTableOffset, sizeInitTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete general init data found in BIOS\n");
        goto fallback;
    }

    // convert byte-wise init data from the BIOS to dword-wise init code
    rmStatus = DevinitInitDataToCode(dt->genInitCode, dt->genInitData);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS init data\n");
        goto fallback;
    }

    // initialize with the buffer of previously extracted code
    rmStatus = InitNV(pDev, dt->genInitCode, (VOID *) dt->memInitTable, dt->SDRSeqTable, dt->DDRSeqTable);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot initialize device using BIOS\n");
        goto fallback;
    }

    if (extraInitTableOffset)
    {
        rmStatus = BiosReadBytes(pDev, dt->extraInitData, extraInitTableOffset, sizeInitTable);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: invalid or incomplete extra init data found in BIOS\n");
            goto fallback;
        }

        // TO DO: change the code to byte-wise structs to remove the need for this
        // convert byte-wise init data from the BIOS to dword-wise init code
        rmStatus = DevinitInitDataToCode(dt->extraInitCode, dt->extraInitData);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: old or unusable BIOS extra init data\n");
            goto fallback;
        }

        // initialize with the buffer of previously extracted code
        rmStatus = InitNV(pDev, dt->extraInitCode, (VOID *) 0, (VOID *) 0, (VOID *) 0);
        if (rmStatus != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: cannot perform 'extra init' using BIOS\n");
            goto fallback;
        }

    }

    // Whew!
    *pBiosUsedToInit = TRUE;


 fallback:
    // could not rely on the init code in the BIOS, so use a static init table
    if ( ! *pBiosUsedToInit)
    {
        rmStatus = DevinitProcessStaticTables(pDev);
    }

 done:
    if (dt)
    {
        if (dt->genInitData)
            osFreeMem(dt->genInitData);
        if (dt->genInitCode)
            osFreeMem(dt->genInitCode);
        if (dt->extraInitData)
            osFreeMem(dt->extraInitData);
        if (dt->extraInitCode)
            osFreeMem(dt->extraInitCode);
        osFreeMem(dt);
    }

    return rmStatus;

} // end of DevinitProcessBip2()

RM_STATUS InitNV
(
    PHWINFO pDev,
    U032 genInitCode[],
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    char opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    U032 ip = 0;
    BOOL conditionFlag = TRUE;

    // execute the microcode referenced by the instruction pointer
    while ((opcode = DevinitFetchByte(genInitCode, &ip)) != INIT_DONE)
    {
        // extract the operands from the table and perform the operation
        opcodeStr[7] = opcode;
#ifndef UNIX
        // this debug printf to the VGA console messes up the init sequence
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif
        switch (opcode)
        {
            case INIT_NV_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, mask, data, conditionFlag);
                break;
            }

            case INIT_ZM_REG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, data, conditionFlag);
                break;
            }

            case INIT_ZM_WREG:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_NV(pDev, addr, 0, (U032)(data) & 0x0000ffff, conditionFlag);
                break;
            }

            case INIT_PLL:
            {
                // fetch the address
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U016 data = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_PLL_Values(pDev, addr, data, conditionFlag);
                break;
            }

            case INIT_TIME:
            {
                U032 ticks = DevinitFetchWord(genInitCode, &ip);
                rmStatus = init_TIME_Delay(pDev, ticks);
                break;
            }

            case INIT_INDEX_IO:
            {
                U016 addr = DevinitFetchWord(genInitCode, &ip);
                U008 index = DevinitFetchByte(genInitCode, &ip);
                U008 mask = DevinitFetchByte(genInitCode, &ip);
                U008 data = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_INDEX_IO_Write(pDev, addr, index, mask, data, conditionFlag);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                U032 mask = DevinitFetchByte(genInitCode, &ip);
                U032 value = DevinitFetchByte(genInitCode, &ip);
                rmStatus = init_MEM_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_STRAP_RESTRICT:
            {
                U032 mask = DevinitFetchDword(genInitCode, &ip);
                U032 value = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_STRAP_RESTRICT_SCRIPT(pDev, mask, value, &conditionFlag);
                break;
            }

            case INIT_RESUME:
            {
                conditionFlag = TRUE;
                break;
            }

            case INIT_CONFIGURE_CLK:
            {
                rmStatus = init_CONFIGURE_Clocks(pDev, memInitTable);
                break;
            }

            case INIT_CONFIGURE_MEM:
            {
                rmStatus = init_CONFIGURE_Memory(pDev, memInitTable, SDRSeqTable, DDRSeqTable);
                break;
            }

            case INIT_CONFIGURE_PREINIT:
            {
                rmStatus = init_CONFIGURE_PreInit(pDev);
                break;
            }

            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                U032 addr = DevinitFetchDword(genInitCode, &ip);
                U032 data1 = DevinitFetchDword(genInitCode, &ip);
                U032 data2 = DevinitFetchDword(genInitCode, &ip);
                rmStatus = init_Reset_Chip(pDev, addr, data1, data2);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }
    }

    return rmStatus;

} // end of InitNV()

// parse the little-endian init data to convert all opcodes and operands
// to big-endian 32-bit values
RM_STATUS DevinitInitDataToCode
(
    U032 *code,
    U008 *data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 codeIndex = 0, dataIndex = 0;
    U032 fields;
    U032 unpacked_bytes;

    // parse all instructions
    while (data[dataIndex] != INIT_DONE) // Byte quantity, no swap needed
    {
        // convert instruction based on the opcode
        // copy byte/word/dword of data into a dword of code
        switch (data[dataIndex])     // Byte quantity, no swap needed
        {
            case INIT_NV_REG:
            case INIT_RESET:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT1_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }
            case INIT_ZM_REG:
            case INIT_STRAP_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT2_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_ZM_WREG:
            case INIT_PLL:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT3_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_TIME:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT4_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_INDEX_IO:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT5_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT6_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            case INIT_RESUME:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_PREINIT:
            case INIT_COMPUTE_MEM:
            {
                rmStatus = BiosUnpackLittleEndianStructure(&data[dataIndex],
                                                           &code[codeIndex],
                                                           INIT_FMT7_FMT,
                                                           &fields,
                                                           &unpacked_bytes);
                break;
            }

            default:
                rmStatus = RM_ERROR;
                break;
        }

        if (rmStatus != RM_OK)
            break;

        dataIndex += unpacked_bytes;
        codeIndex += fields;
    }

    // append init code delimiter
    if (rmStatus == RM_OK)
        code[codeIndex] = (U032)INIT_DONE;

    return rmStatus;

} // end of DevinitInitDataToCode()


RM_STATUS DevinitProcessStaticTables
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifndef MACOS // no fallback tables for MAC
    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: using static tables for device init\n");

    // initialize with the proper device-specific initialization code table
    switch (REG_RD_DRF(_PBUS,_PCI_NV_0,_DEVICE_ID_CHIP))
    {
        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV4:
            rmStatus = InitNV(pDev, Nv04_bmp_GenInitTbl, NULL, NULL, NULL);
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV5:
            switch (REG_RD_DRF(_PBUS,_PCI_NV_11,_SUBSYSTEM_ID))
            {
                case NV_PBUS_PCI_NV_11_SUBSYSTEM_ID_TNT2PRO:
                    rmStatus = InitNV(pDev, Nv05Pro_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;

                default:
                    rmStatus = InitNV(pDev, Nv05_bmp_GenInitTbl, Nv05_bmp_MemInitTbl, NULL, NULL);
                    break;
            }
            break;

        case NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV10:
            rmStatus =
                InitNV
                (
                    pDev,
                    Nv10_bmp_GenInitTbl,
                    Nv10_bmp_MemInitTbl,
                    Nv10_SDR_Sequence_Table,
                    Nv10_DDR_Sequence_Table
                );
            break;

        default:
            rmStatus = RM_ERROR;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: no static tables for device\n");
            break;
    }
#endif // MACOS

    return rmStatus;

} // end of DevinitProcessStaticTables()


// extract the relavant values from any arbitrary version of BMP structure
RM_STATUS DevinitGetInitTableInfo
(
    PHWINFO pDev,
    U032    offset,
    PBMP_Control_Block pBmpCtrlBlk,
    U032*   pGenInitTable,
    U032*   pExtraInitTable,
    U032*   pSizeInitTable,
    U032*   pMemInitTable,
    U032*   pSDRSequenceTable,
    U032*   pDDRSequenceTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (pBmpCtrlBlk->CTL_Version)
    {
        // BMP init table version 0 is for Nv3
        case BMP_INIT_TABLE_VER_0:
            rmStatus = RM_ERROR;
            break;

        // BMP init table version 1 and 2 use the version 1 base-level functionality
        case BMP_INIT_TABLE_VER_1:
        case BMP_INIT_TABLE_VER_2:
        {
            BMP_Struc_Rev1 BMP_InitTableInfo;
            rmStatus = BiosReadStructure(pDev,
                                         (U008*) &BMP_InitTableInfo,
                                         offset,
                                         (U032 *) 0,
                                         BMP_INIT1_FMT);
            if (rmStatus != RM_OK)
                break;

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = 0;
            *pSDRSequenceTable = 0;
            *pDDRSequenceTable = 0;
            break;
        }

        // default is BMP init table version 3 base-level functionality
        default:
        {
            BMP_Struc_Rev3 BMP_InitTableInfo;
            BiosReadStructure(pDev,
                              (U008*) &BMP_InitTableInfo,
                              offset,
                              (U032 *) 0,
                              BMP_INIT3_FMT);

            *pGenInitTable = BMP_InitTableInfo.BMP_GenInitTable;
            *pExtraInitTable = BMP_InitTableInfo.BMP_ExtraInitTable;
            *pSizeInitTable = BMP_InitTableInfo.BMP_SizeInitTable;
            *pMemInitTable = BMP_InitTableInfo.BMP_MemInitTable;
            *pSDRSequenceTable = BMP_InitTableInfo.BMP_SDRSequenceTable;
            *pDDRSequenceTable = BMP_InitTableInfo.BMP_DDRSequenceTable;
            break;
        }
    }

    return rmStatus;

} // end of DevinitGetInitTableInfo()

U008 DevinitFetchByte(U032 code[], U032* pIp)
{
    return (U008)code[(*pIp)++];
}

U016 DevinitFetchWord(U032 code[], U032* pIp)
{
    return (U016)code[(*pIp)++];
}

U032 DevinitFetchDword(U032 code[], U032* pIp)
{
    return (U032)code[(*pIp)++];
}


// ***** CORE 3 SCRIPT PROCESSING *****

RM_STATUS DevinitProcessBip3
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus;
    EXECUTION_CONTEXT context;
    U032 scriptOffset;
    U032 scriptIndex = 0;

    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;
    context.tables = (VOID *) 0;


    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);
    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }

    // extract all tables from the BIOS image
    rmStatus = DevinitReadBIP3Tables(pDev, &context);
    if (rmStatus == RM_OK)
    {
        // interpret all scripts in the script table in order
        do
        {
            context.doJump = FALSE;
            scriptOffset = BiosRead16(pDev, context.scriptTableOffset + (scriptIndex * 2));
            if (scriptOffset != SCRIPT_TERMINATE)
            {
                // interpret the script at the script's offset into the BIP code
                DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
                rmStatus = DevinitInterpretBIP3Script(pDev, &context, scriptOffset);
                if (rmStatus == RM_OK)
                {
                    scriptIndex = (context.doJump) ? context.jumpIndex : scriptIndex + 1;
                }
                else
                {
                    DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret script...\n");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
                    break;
                }
            }
        }
        while (scriptOffset != SCRIPT_TERMINATE);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: number of scripts interpreted = ", scriptIndex);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: could not read BIP3 tables\n");
    }    

    // release all local tables
    DevinitCleanupBIP3Tables(pDev, &context);

    return rmStatus;

} // end of DevinitProcessBip3()

RM_STATUS DevinitInterpretBIP3Script
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT pContext,
    U032               ip
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 opcode;
    U008 opcodeStr[] = "NVRM: \' \' BMP operation...\n";
    BOOL done = FALSE;
    U032 packed_size, extra_packed_size;
    U008 instruction_buffer[BMP_MAX_PADDED_SIZE];
    VOID *instruction = instruction_buffer;

    // interpret the current script -- the instruction pointer, ip, always points to the next instruction
    do
    {
        // extract the operands from the current instruction and perform the operation
        opcode = 
            DevinitFetchInstruction
            (
                pDev,
                ip,
                instruction,
                &packed_size,
                &extra_packed_size
            );

        // go ahead and advance past the opcode proper.
        // After this we'll be pointing at the next instruction *or*
        //   any extra data as in BMP formats 12, 13, 14
        // At bottom we skip over any extra data associated with the opcode.
        ip += packed_size;

        if (opcode < ' ' || opcode > '~')
        {
            opcodeStr[7] = '?';
        }
        else
        {
            opcodeStr[7] = opcode;
        }
#ifndef UNIX // this debug printf to the VGA console messes up the init sequence
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, opcodeStr);
#endif

#if 0 && defined(MACOSX)
        // info only for those ports with decent printfs :-)
        DBG_PRINTF(DEBUGLEVEL_ERRORS,
                   "NVRM: op: %c, 0x%x, from 0x%x, packed: %d, extra: %d\n",
                   opcode, opcode,
                   ip - packed_size,     // already added in
                   packed_size,
                   extra_packed_size);
#endif

                        
        switch (opcode)
        {
            case INIT_COMPUTE_MEM:
            {
                rmStatus = init_COMPUTE_Memory(pDev);
                break;
            }

            case INIT_RESET:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_Reset_Chip
                (
                    pDev, 
                    bmp1->operand1, 
                    bmp1->operand2, 
                    bmp1->operand3
                );
                break;
            }

            case INIT_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_IO
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MEM_RESTRICT:
            {
                BMP_FORMAT_6 *bmp6 = instruction;
                init_MEM_RESTRICT_SCRIPT
                (
                    pDev,
                    bmp6->operand1,
                    bmp6->operand2,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NV_REG:
            {
                BMP_FORMAT_1 *bmp1 = instruction;
                init_NV
                (
                    pDev,
                    bmp1->operand1,
                    bmp1->operand2,
                    bmp1->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESUME:
            {
                pContext->conditionFlag = TRUE;
                break;
            }

            case INIT_TIME:
            {
                BMP_FORMAT_4 *bmp4 = instruction;
                init_TIME_Delay
                (
                    pDev, 
                    bmp4->operand1
                );
                break;
            }

            case INIT_INDEX_IO:
            {
                BMP_FORMAT_5 *bmp5 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp5->operand1,
                    bmp5->operand2,
                    bmp5->operand3,
                    bmp5->operand4,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_PLL:
            {
                BMP_FORMAT_3 *bmp3 = instruction;
                init_PLL_Values
                (
                    pDev,
                    bmp3->operand1,
                    bmp3->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_REG:
            {
                BMP_FORMAT_2 *bmp2 = instruction;
                init_NV
                (
                    pDev,
                    bmp2->operand1,
                    0,
                    bmp2->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_SUB:
            {
                BMP_FORMAT_8* bmp8 = instruction;
                init_Sub
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_INDEX_IO:
            {
                BMP_FORMAT_9 *bmp9 = instruction;
                init_INDEX_IO_Write
                (
                    pDev,
                    bmp9->operand1,
                    bmp9->operand2,
                    0,
                    bmp9->operand3,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_ZM_IO:
            {
                BMP_FORMAT_10 *bmp10 = instruction;
                init_ZM_IO
                (
                    pDev,
                    bmp10->operand1,
                    bmp10->operand2,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_MACRO:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Macro
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Condition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_FLAG_CONDITION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_IoFlagCondition
                (
                    pDev,
                    pContext,
                    bmp8->operand1,
                    &pContext->conditionFlag
                );
                break;
            }

            case INIT_NOT:
            {
                pContext->conditionFlag = !pContext->conditionFlag;
                break;
            }

            case INIT_COPY:
            {
                BMP_FORMAT_11 *bmp11 = instruction;
                init_Copy
                (
                    pDev,
                    pContext,
                    bmp11->operand1,
                    (S008) bmp11->operand2,
                    bmp11->operand3,
                    bmp11->operand4,
                    bmp11->operand5,
                    bmp11->operand6,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_RESTRICT_PROG:
            {
                BMP_FORMAT_12 *bmp12 = instruction;
                init_RestrictProg
                (
                    pDev,
                    pContext,
                    bmp12->operand1,
                    bmp12->operand2,
                    bmp12->operand3,
                    bmp12->operand4,
                    bmp12->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PROG:
            {
                BMP_FORMAT_13 *bmp13 = instruction;
                init_IoRestrictProg
                (
                    pDev,
                    pContext,
                    bmp13->operand1,
                    bmp13->operand2,
                    bmp13->operand3,
                    bmp13->operand4,
                    bmp13->operand5,
                    bmp13->operand6,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }

            case INIT_IO_RESTRICT_PLL:
            {
                BMP_FORMAT_14 *bmp14 = instruction;
                init_IoRestrictPll
                (
                    pDev,
                    pContext,
                    bmp14->operand1,
                    bmp14->operand2,
                    bmp14->operand3,
                    bmp14->operand4,
                    bmp14->operand5,
                    bmp14->operand6,
                    bmp14->operand7,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_INDEX_ADDRESS_LATCHED:
            {
                BMP_FORMAT_15 *bmp15 = instruction;
                init_IndexAddressLatched
                (
                    pDev,
                    bmp15->operand1,
                    bmp15->operand2,
                    bmp15->operand3,
                    bmp15->operand4,
                    bmp15->operand5,
                    ip,
                    pContext->conditionFlag
                );
                break;
            }
                
            case INIT_REPEAT:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Repeat
                (
                    pDev,
                    pContext,
                    ip,
                    bmp8->operand1
                );
                break;
            }

            case INIT_END_REPEAT:
            {
                init_EndRepeat
                (
                    pDev,
                    pContext,
                    &ip
                );
                break;
            }

            case INIT_FUNCTION:
            {
                BMP_FORMAT_8 *bmp8 = instruction;
                init_Function
                (
                    pDev,
                    pContext,
                    bmp8->operand1
                );
                break;
            }

            // all of these stop the processing of the current script
            case INIT_JUMP:
            {
                if (pContext->conditionFlag)
                {
                    // extract the destination script index and fall thru to end execution of the current script
                    BMP_FORMAT_8 *bmp8 = instruction;
                    pContext->doJump = TRUE;
                    pContext->jumpIndex = bmp8->operand1;
                    done = TRUE;
                }
                break;
            }

            case INIT_DONE:
            case INIT_EOS:
            case INIT_CONFIGURE_CLK:
            case INIT_CONFIGURE_MEM:
            case INIT_CONFIGURE_PREINIT:
                done = TRUE;
                break;

            default:
                if (opcode == 0x00)
                {
                    // screen out benign NULL opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Benign opcode found in BIP3 table, skipping...\n");
                }
                else
                {    
                    // fail on undefined opcodes
                    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Bad opcode encountered\n");
                    rmStatus = RM_ERROR;
                }
                break;
        }
        if (rmStatus != RM_OK)
        {
            break;
        }

        // adjust the instruction pointer for those instruction with variable-sized operands
        ip += extra_packed_size;

    } while (!done);

    return rmStatus;

} // end of DevinitInterpretBIP3Script()

RM_STATUS DevinitProcessBip3InternalTMDS
(
    PHWINFO pDev,
    U032    fpPixClk,
    U032    interfaceType
)
{
    RM_STATUS rmStatus = RM_OK;
    EXECUTION_CONTEXT context;
    U032 TableOffset;
    
    // initialize execution context
    context.conditionFlag = TRUE;
    context.loopStack.sp = 0;

    // get all table offsets
    rmStatus = DevinitGetBIP3TableOffsets(pDev, &context);

    if (rmStatus != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: invalid BIOS init info version\n");
        return rmStatus;
    }
    
    switch ( interfaceType )
    {
        case TMDSIT_TMDS_SINGLE_A:
        {
            TableOffset = context.TMDSSingleAOffset;
            break;
        }
        case TMDSIT_TMDS_SINGLE_B:
        {
            TableOffset = context.TMDSSingleBOffset;
            break;
        }
        case TMDSIT_TMDS_DUAL:
        {
            TableOffset = context.TMDSDualOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_A:
        {
            TableOffset = context.LVDSSingleAOffset;
            break;
        }
        case TMDSIT_LVDS_SINGLE_B:
        {
            TableOffset = context.LVDSSingleBOffset;
            break;
        }
        case TMDSIT_LVDS_DUAL:
        {
            TableOffset = context.LVDSDualOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_A:
        {
            TableOffset = context.OffSingleAOffset;
            break;
        }
        case TMDSIT_OFF_SINGLE_B:
        {
            TableOffset = context.OffSingleBOffset;
            break;
        }
        default:
        {
            return RM_ERROR;
        }
    }

    // Is this table present in the BIOS?
    if ( TableOffset == 0 )
    {
        return RM_ERROR;
    }

    // Find out which script index to use and process it
    rmStatus = DevinitProcessBip3InternalTMDSTable
        (
            pDev,
            &context,
            fpPixClk,
            TableOffset
        );

    return rmStatus;

} // end of DevinitProcessBip3InternalTMDS()


// Process an internal TMDS programming table
RM_STATUS DevinitProcessBip3InternalTMDSTable
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT context,
    U032               fpPixClk,
    U032               TableOffset
)
{
    RM_STATUS rmStatus = RM_OK;

    U032 scriptIndex = 0;

    U032 LastFreq;
    U032 Entries;
    BOOL Found = FALSE;

    U032 currentScriptOffset;
    TMDS_MODE_ENTRY tmdsModeEntry;
    U032            packed_size;

    LastFreq = 0;
    Entries = 0;

    // Scan for frequency
    do
    {
        // Because we don't know the size, extract one entry at a time
        rmStatus = BiosReadStructure(pDev,
                                     &tmdsModeEntry,
                                     TableOffset,
                                     &packed_size,
                                     TMDS_MODE_FORMAT);
        if (rmStatus != RM_OK)
        {
            return rmStatus;
        }
        // Is the pixel clock greater than or equal to this entries frequency
        if ( fpPixClk >= tmdsModeEntry.tmdsmFreq )
        {
            scriptIndex = tmdsModeEntry.tmdsmScript;
            Found = TRUE;
        }
        else if ( ( Entries > 0 ) && ( LastFreq <= tmdsModeEntry.tmdsmFreq ) )
        {
            // We didn't find a match yet, we saw at least two values,
            // and the frequencies are not decreasing
            return RM_ERROR;
        }
        else
        {
            LastFreq = tmdsModeEntry.tmdsmFreq;
            Entries++;
            TableOffset += packed_size;
        }
    } while ( ! Found);

    // interpret the script in the script table at the given index
    currentScriptOffset = BiosRead16(pDev, context->scriptTableOffset + (scriptIndex*2));
    return DevinitInterpretBIP3Script(pDev, context, currentScriptOffset);
}


// extract the relavant values from any arbitrary version of BIP/3 structure
RM_STATUS DevinitGetBIP3TableOffsets
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    cp->TMDSSingleAOffset = 0;
    cp->TMDSSingleBOffset = 0;
    cp->TMDSDualOffset = 0;
    cp->LVDSSingleAOffset = 0;
    cp->LVDSSingleBOffset = 0;
    cp->LVDSDualOffset = 0;
    cp->OffSingleAOffset = 0;  
    cp->OffSingleBOffset = 0; 

    // get the offset of the BMP init table
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // get the BMP init table
    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // Core 3 type devinit tables should only be used with BMP 0x05.0x10 or greater.
        if ( bmpCtrlBlk.CTL_Flags < 0x10 )
        {
            return RM_ERROR;
        }
        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;

                rmStatus = RM_OK;

                break;
            }


            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);
                cp->scriptTableOffset          = bmpInitTable.BMP_InitScriptTablePtr;
                cp->macroIndexTableOffset      = bmpInitTable.BMP_MacroIndexTablePtr;
                cp->macroTableOffset           = bmpInitTable.BMP_MacroTablePtr;
                cp->conditionTableOffset       = bmpInitTable.BMP_ConditionTablePtr;
                cp->ioConditionTableOffset     = bmpInitTable.BMP_IOConditionTablePtr;
                cp->ioFlagConditionTableOffset = bmpInitTable.BMP_IOFlagConditionTablePtr;
                cp->functionTableOffset        = bmpInitTable.BMP_InitFunctionTablePtr;
                
                cp->TMDSSingleAOffset          = bmpInitTable.BMP_TMDSSingleAPtr;
                cp->TMDSSingleBOffset          = bmpInitTable.BMP_TMDSSingleBPtr;
                cp->TMDSDualOffset             = bmpInitTable.BMP_TMDSDualPtr;   
                cp->LVDSSingleAOffset          = bmpInitTable.BMP_LVDSSingleAPtr;
                cp->LVDSSingleBOffset          = bmpInitTable.BMP_LVDSSingleBPtr;
                cp->LVDSDualOffset             = bmpInitTable.BMP_LVDSDualPtr;   
                cp->OffSingleAOffset           = bmpInitTable.BMP_OffSingleAPtr; 
                cp->OffSingleBOffset           = bmpInitTable.BMP_OffSingleBPtr; 

                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitGetBIP3TableOffsets()

RM_STATUS DevinitReadBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
    RM_STATUS rmStatus;

    // allocate space for the tables
    cp->tables = (VOID *) 0;

#ifdef USE_STATIC_BIP3_TABLES
    cp->tables = &bip3_static_tables;
#else
    rmStatus = osAllocMem((VOID *) &cp->tables, sizeof(*cp->tables));
    if (rmStatus != RM_OK)
        goto done;
#endif
        
    // go ahead and read entire macro index table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroIndexTable,
                             cp->macroIndexTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_INDEX_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read macro table itself into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->macroTable,
                             cp->macroTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             MACRO_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read condition table into memory
    rmStatus = BiosReadArray(pDev,
                             cp->tables->conditionTable,
                             cp->conditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;
    
    // read io condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioConditionTable,
                             cp->ioConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read io flag condition table    
    rmStatus = BiosReadArray(pDev,
                             cp->tables->ioFlagConditionTable,
                             cp->ioFlagConditionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             IO_FLAG_CONDITION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

    // read function table
    rmStatus = BiosReadArray(pDev,
                             cp->tables->functionTable,
                             cp->functionTableOffset,
                             256,
                             (U032 *) 0,        // packed size
                             FUNCTION_ENTRY_FMT);
    if (rmStatus != RM_OK)
        goto done;

 done:
    return rmStatus;
    
} // end of DevinitReadBIP3Tables()

VOID DevinitCleanupBIP3Tables
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp    
)
{
#ifndef USE_STATIC_BIP3_TABLES
    if (cp->tables)
    {
        osFreeMem(cp->tables);
    }
#endif
    cp->tables = (VOID *) 0;
    
} // end of DevinitCleanupBIP3Tables()

U008 DevinitFetchInstruction
(
    PHWINFO pDev,
    U032    ip,
    VOID   *pInstruction,
    U032   *pPackedSize,
    U032   *pExtraPackedSize
)
{
    U032 padded_size;
    U008 opcode;
    U032 extra_packed_size = 0;
    U032 count;
    U032 elementSize;
    char *format;
    RM_STATUS rmStatus;

    // set current instruction
    opcode = BiosRead8(pDev, ip);

    // figure out what we are looking at here...
    switch (opcode)
    {
        case INIT_RESET:
        case INIT_NV_REG:
            padded_size = sizeof(BMP_FORMAT_1);
            format = INIT_FMT1_FMT;
            break;

        case INIT_ZM_REG:
            padded_size = sizeof(BMP_FORMAT_2);
            format = INIT_FMT2_FMT;
            break;

        case INIT_PLL:
            padded_size = sizeof(BMP_FORMAT_3);
            format = INIT_FMT3_FMT;
            break;

        case INIT_TIME:
            padded_size = sizeof(BMP_FORMAT_4);
            format = INIT_FMT4_FMT;
            break;

        case INIT_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_5);
            format = INIT_FMT5_FMT;
            break;

        case INIT_MEM_RESTRICT:
            padded_size = sizeof(BMP_FORMAT_6);
            format = INIT_FMT6_FMT;
            break;

        case INIT_COMPUTE_MEM:
        case INIT_CONFIGURE_MEM:
        case INIT_CONFIGURE_CLK:
        case INIT_CONFIGURE_PREINIT:
        case INIT_DONE:
        case INIT_RESUME:
        case INIT_EOS:
        case INIT_END_REPEAT:
        case INIT_NOT:
            padded_size = sizeof(BMP_FORMAT_7);
            format = INIT_FMT7_FMT;
            break;

        case INIT_SUB:
        case INIT_JUMP:
        case INIT_MACRO:
        case INIT_CONDITION:
        case INIT_IO_CONDITION:
        case INIT_IO_FLAG_CONDITION:
        case INIT_REPEAT:
        case INIT_FUNCTION:
            padded_size = sizeof(BMP_FORMAT_8);
            format = INIT_FMT8_FMT;
            break;

        case INIT_IO:
        case INIT_ZM_INDEX_IO:
            padded_size = sizeof(BMP_FORMAT_9);
            format = INIT_FMT9_FMT;
            break;

        case INIT_ZM_IO:
            padded_size = sizeof(BMP_FORMAT_10);
            format = INIT_FMT10_FMT;
            break;

        case INIT_COPY:
            padded_size = sizeof(BMP_FORMAT_11);
            format = INIT_FMT11_FMT;
            break;

        case INIT_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_12);
            format = INIT_FMT12_FMT;
            break;

        case INIT_IO_RESTRICT_PROG:
            padded_size = sizeof(BMP_FORMAT_13);
            format = INIT_FMT13_FMT;
            break;

        case INIT_IO_RESTRICT_PLL:
            padded_size = sizeof(BMP_FORMAT_14);
            format = INIT_FMT14_FMT;
            break;

        case INIT_INDEX_ADDRESS_LATCHED:
            padded_size = sizeof(BMP_FORMAT_15);
            format = INIT_FMT15_FMT;
            break;
        
        default:
            // assume unknown opcodes are 1-byte instructions
            padded_size = sizeof(bios_U008);
            format = "b";
            break;
    }

    // now extract the instruction and convert it.
    rmStatus = BiosReadStructure(pDev,
                                 pInstruction,
                                 ip,
                                 pPackedSize,
                                 format);
    if (rmStatus != RM_OK)
        goto failed;

    // now find size of any 'extra' stuff that is part of this instruction...
    // we are not reading it in, just calculating its size

    switch (opcode)
    {
        case INIT_RESTRICT_PROG:
        {
            BMP_FORMAT_12 *bmp12 = pInstruction;
            count = bmp12->operand4;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PROG:
        {
            BMP_FORMAT_13 *bmp13 = pInstruction;
            count = bmp13->operand5;
            elementSize = 4;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_IO_RESTRICT_PLL:
        {
            BMP_FORMAT_14 *bmp14 = pInstruction;
            count = bmp14->operand6;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        case INIT_INDEX_ADDRESS_LATCHED:
        {
            BMP_FORMAT_15 *bmp15 = pInstruction;
            count = bmp15->operand5;
            elementSize = 2;
            extra_packed_size = count * elementSize;
            break;
        }

        default:
            extra_packed_size = 0;
            break;
    }

    *pExtraPackedSize = extra_packed_size;

    // return actual opcode
    if (rmStatus == RM_OK)
        return opcode;

 failed:
    // Error path
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: error in DevinitFetchInstruction\n");
    return 0;             // bad opcode

} // end of DevinitFetchInstruction()


// ***** SCRIPT INSTRUCTION IMPLEMENTATION *****

// NV register initialization
RM_STATUS init_NV
(
    PHWINFO pDev,
    U032 reg,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 value;

    // read, modify, and rewrite the value
    if (conditionFlag)
    {
        value = REG_RD32(reg);
        value = (value & mask) | data;
        REG_WR32(reg, value);
    }

    return rmStatus;

} // end of init_NV()

// NV PLL initialization
RM_STATUS init_PLL_Values
(
    PHWINFO pDev,
    U032 reg,
    U032 MhzX100,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if (conditionFlag)
    {
        // program the proper clock using the RM kernel
        switch (reg)
        {
            case NV_PRAMDAC_NVPLL_COEFF:
                pDev->Dac.HalInfo.NVClk = MhzX100 * 10000;
                rmStatus = dacProgramNVClk(pDev);
                break;
            
            case NV_PRAMDAC_MPLL_COEFF:
                pDev->Dac.HalInfo.MClk = MhzX100 * 10000;
                rmStatus = dacProgramMClk(pDev);
                break;
            
            case NV_PRAMDAC_VPLL_COEFF:
                rmStatus = dacProgramPClk(pDev, 0, MhzX100);
                break;
            
            default:
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Cannot program unknown clock\n");
                rmStatus = RM_ERROR;
                break;
        }
    }    

    return rmStatus;

} // end of init_PLL_Values()

// initialization time delay
RM_STATUS init_TIME_Delay
(
    PHWINFO pDev,
    U032 mSec
)
{
    return osDelay(mSec);

} // end of init_TIME_Delay()

// indexed I/O Register initialization
RM_STATUS init_INDEX_IO_Write
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 value;

    if (conditionFlag)
    {
        // read, modify, and write the value
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = (value & (U008) mask) | (U008) data;
            rmStatus = DevinitWritePort(pDev, port, index, value);
        }
    }

    return rmStatus;

} // end of init_INDEX_IO_Write()

//  inhibit processing based on memory size
RM_STATUS init_MEM_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PFB_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_MEM_RESTRICT_SCRIPT()

//  inhibit processing based on strapping
RM_STATUS init_STRAP_RESTRICT_SCRIPT
(
    PHWINFO pDev,
    U032 mask,
    U032 value,
    BOOL* pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    if ((REG_RD32(NV_PEXTDEV_BOOT_0) & mask) != value)
    {
        *pConditionFlag = FALSE;
    }

    return rmStatus;

} // end of init_STRAP_RESTRICT_SCRIPT()

RM_STATUS init_CONFIGURE_Clocks
(
    PHWINFO pDev,
    VOID* memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureClocks(pDev, (MEM_INIT_VALS_NV10*)memInitTable);
            break;

        default:
            rmStatus = Nv15MemConfigureClocks(pDev, (MEM_INIT_VALS_NV15*)memInitTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Clocks()

// configure the device memory
RM_STATUS init_CONFIGURE_Memory
(
    PHWINFO pDev,
    VOID* memInitTable,
    U032 SDRSeqTable[],
    U032 DDRSeqTable[]
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            rmStatus = Nv10MemConfigureMemory(pDev, (MEM_INIT_VALS_NV10*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;

        default:
            rmStatus = Nv15MemConfigureMemory(pDev, (MEM_INIT_VALS_NV15*)memInitTable, SDRSeqTable, DDRSeqTable);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_Memory()

// configure RAM type and specifiers
RM_STATUS init_CONFIGURE_PreInit
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        default:
            rmStatus = Nv10MemChipPreInit(pDev);
            break;
    }

    return rmStatus;

} // end of init_CONFIGURE_PreInit()

// compute the memory size of the device
RM_STATUS init_COMPUTE_Memory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (REG_RD32(NV_PBUS_PCI_NV_0) >> 16 & 0x0000ffff)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:
            rmStatus = Nv04MemResizeMemory(pDev);
            break;

        // TO DO: modify NV5 memory resizing to use data from the BIOS instead of static data
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3:
            rmStatus = Nv05MemResizeMemory(pDev);
            break;

        default:
            rmStatus = Nv10MemComputeMemory(pDev);
            break;
    }

    return rmStatus;

} // end of init_COMPUTE_Memory()

// reset the device
RM_STATUS init_Reset_Chip
(
    PHWINFO pDev,
    U032 reg,
    U032 enginesOff,
    U032 enginesOn
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 saveValue;

    // save and toggle the AGP command register (don't disturb the FW enable)
    saveValue = REG_RD32(NV_PBUS_PCI_NV_19);
    REG_WR32(NV_PBUS_PCI_NV_19,
             (saveValue & ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) |
                            DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, _ON))));

    // write out engines to turn off and on
    REG_WR32(reg, enginesOff);
    REG_WR32(reg, enginesOn);

    // restore AGP command register
    REG_WR32(NV_PBUS_PCI_NV_19, saveValue);

    // set access to the ROM thru instance mem
    FLD_WR_DRF_DEF(_PBUS,_PCI_NV_20,_ROM_SHADOW,_DISABLED);

    return rmStatus;

} // end of init_Reset_Chip()

RM_STATUS init_IO
(
    PHWINFO pDev,
    U032 port,
    U032 mask,
    U032 data,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg, value;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // read, modify, and rewrite the value
            value = REG_RD32(reg);
            value = (value & mask) | data;
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_IO()

// set the condition flag based on the results of the given condition
RM_STATUS init_Condition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;
    U032 mask;
    U032 comparison;
    U032 value;
    CONDITION_ENTRY *pCondEntry;

    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondEntry = &cp->tables->conditionTable[conditionId];
        reg         = pCondEntry->condAddress;
        mask        = pCondEntry->condMask;
        comparison  = pCondEntry->condCompare;

        // read, modify, reset condition flag on miscompare
        value = REG_RD32(reg);
        value = value & mask;
        if (value != comparison)
        {
            *pConditionFlag = FALSE;
        }
    }    

    return rmStatus;

} // end of init_Condition()

RM_STATUS init_IoCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pConditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 port;
    U032 index, mask, comparison;
    U008 value;
    IO_CONDITION_ENTRY* pCondition;

    // modify the flag only if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // grab out our fields
        pCondition = &cp->tables->ioConditionTable[conditionId];
        port        = pCondition->iocondPort;
        index       = pCondition->iocondIndex;
        mask        = pCondition->iocondMask;
        comparison  = pCondition->iocondCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &value);
        if (rmStatus == RM_OK)
        {
            value = value & (U008) mask;
            if (value != (U008) comparison)
            {
                *pConditionFlag = FALSE;
            }
        }
    }    

    return rmStatus;

} // end of init_IoCondition()

// set a flag based on the results of the given I/O flag condition
RM_STATUS init_IoFlagCondition
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               conditionId,
    BOOL              *pFlag
)
{
    U032 port;
    U032 index;
    U032 mask;
    U032 shift;
    U032 flagArrayOffset;
    U032 flag;
    U032 flagMask;
    U032 comparison;
    U008 flagIndex;
    IO_FLAG_CONDITION_ENTRY *pIoFlagCondEntry;
    RM_STATUS rmStatus = RM_OK;

    // set the flag if there is a valid condition
    if (conditionId != NO_CONDITION)
    {
        // grab our fields..
        pIoFlagCondEntry = &cp->tables->ioFlagConditionTable[conditionId];
        port            = pIoFlagCondEntry->iofcondPort;
        index           = pIoFlagCondEntry->iofcondIndex;
        mask            = pIoFlagCondEntry->iofcondMask;
        shift           = pIoFlagCondEntry->iofcondShift;
        flagArrayOffset = pIoFlagCondEntry->iofcondFlagArray;
        flagMask        = pIoFlagCondEntry->iofcondFlagMask;
        comparison      = pIoFlagCondEntry->iofcondFlagCompare;

        // read, modify, reset condition flag on miscompare
        rmStatus = DevinitReadPort(pDev, port, index, &flagIndex);
        if (rmStatus == RM_OK)
        {
            // set the flag based on the contents the flag array contents
            flagIndex = (flagIndex & (U008) mask) >> shift;
            flag = BiosRead8(pDev, flagArrayOffset + flagIndex);
            flag = flag & flagMask;
            if (flag != comparison)
            {
                *pFlag = FALSE;
            }
        }
    }

    return rmStatus;

} // end of init_IoFlagCondition()

RM_STATUS init_RestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               indexReg,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 dataIndex, data;

    // only perform the instruction if the condition flag is TRUE and the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        dataIndex = REG_RD32(indexReg);

        // write the register from the data table
        dataIndex = (dataIndex & mask) >> shift;
        if (dataIndex >= dataTableSize)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
            rmStatus = RM_ERROR;
        }
        else
        {
            data = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_IoRestrictProg()

RM_STATUS init_IoRestrictProg
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               dataTableSize,
    U032               reg,
    U032               dataTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 dataIndex;

    // only perform the instruction if the condition flag is TRUE and
    //   the register is defined, i.e. not 0
    if (conditionFlag && reg)
    {
        // get the index of the data table
        rmStatus = DevinitReadPort(pDev, port, index, &dataIndex);
        if (rmStatus == RM_OK)
        {
            U032 word32;

            // write the register from the data table
            dataIndex = (dataIndex & (U008) mask) >> shift;
            if (dataIndex >= dataTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictProg\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                word32 = BiosRead32(pDev, dataTableOffset + (dataIndex * sizeof(U032)));
                REG_WR32(reg, word32);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictProg()

RM_STATUS init_IoRestrictPll
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               port,
    U032               index,
    U032               mask,
    U032               shift,
    U032               doubleFlagCondition,
    U032               freqTableSize,
    U032               pllReg,
    U032               freqTableOffset,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U008 freqIndex;
    BOOL doubleFlag = FALSE;
    U032 freq;

    // only perform the instruction if the condition flag is TRUE and the
    //   register is defined, i.e. not 0

    if (conditionFlag && pllReg)
    {
        // get the index of the frequency table
        rmStatus = DevinitReadPort(pDev, port, index, &freqIndex);
        if (rmStatus == RM_OK)
        {
            // program the PLL register from the frequency table
            freqIndex = (freqIndex & (U008) mask) >> shift;
            init_IoFlagCondition(pDev, cp, doubleFlagCondition, &doubleFlag);
            if (freqIndex >= freqTableSize)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: range check failure in init_IoRestrictPll\n");
                rmStatus = RM_ERROR;
            }
            else
            {
                freq = BiosRead16(pDev, freqTableOffset + (freqIndex * 2));
                freq = (doubleFlag) ? freq * 2 : freq;
                rmStatus = init_PLL_Values(pDev, pllReg, freq, conditionFlag);
            }
        }
    }

    return rmStatus;

} // end of init_IoRestrictPll()

RM_STATUS init_IndexAddressLatched
(
    PHWINFO pDev,
    U032    controlReg,
    U032    dataReg,
    U032    mask,
    U032    writeOr,
    U032    dataTableSize,
    U032    dataTableOffset,
    BOOL    conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;

    // only perform the instruction if the condition flag is TRUE and
    //  the register is defined, i.e. not 0
    if (conditionFlag && (dataReg != 0))
    {
        U032 i;

        for ( i = 0; i < dataTableSize; i++ )
        {
            U032 index;
            U032 dataValue;
            U032 controlValue;

            index = BiosRead8(pDev, dataTableOffset + (i * 2));
            dataValue = BiosRead8(pDev, dataTableOffset + (i * 2) + 1);

            REG_WR32( dataReg, dataValue );

            controlValue = REG_RD32( controlReg );
            controlValue &= mask;
            controlValue |= writeOr;
            controlValue |= index;

            REG_WR32( controlReg, controlValue );
        }
    }    
    
    return rmStatus;

} // end of init_IndexAddressLatched()


RM_STATUS init_Sub
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               scriptIndex,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 scriptOffset;
    
    if (conditionFlag)
    {
        scriptOffset = BiosRead16(pDev, cp->scriptTableOffset + (scriptIndex * 2));
        if (scriptOffset != SCRIPT_TERMINATE)
        {
            // interpret the script at the script's offset into the BIP code
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: interpreting sub script...\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script table index: ", scriptIndex);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   script offset:      ", scriptOffset);
            rmStatus = DevinitInterpretBIP3Script(pDev, cp, scriptOffset);
            if (rmStatus != RM_OK)
            {
                DBG_PRINT_STRING      (DEBUGLEVEL_ERRORS, "NVRM: could not interpret sub script...\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script table index: ", scriptIndex);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:   script offset:      ", scriptOffset);
            }
        }
    }    
    
    return rmStatus;

} // end of init_Sub()

RM_STATUS init_Macro
(
    PHWINFO            pDev,
    EXECUTION_CONTEXT *cp,
    U032               macroId,
    BOOL               conditionFlag
)
{
    RM_STATUS           rmStatus = RM_OK;
    MACRO_ENTRY        *pMacro;
    U032                macroCount;
    U032                i, reg, data;
    MACRO_INDEX_ENTRY  *pMacroIndexEntry;

    if (conditionFlag)
    {
        pMacroIndexEntry = &cp->tables->macroIndexTable[macroId];

        macroCount = pMacroIndexEntry->macroCount;
        pMacro = &cp->tables->macroTable[pMacroIndexEntry->macroIndex];

        // perform the set of register writes defined in the macro
        for (i = 0; i < macroCount; i++)
        {
            reg = pMacro[i].macroAddress;
            data = pMacro[i].macroValue;
            REG_WR32(reg, data);
        }
    }

    return rmStatus;

} // end of init_Macro()

RM_STATUS init_ZM_IO
(
    PHWINFO pDev,
    U032 port,
    U032 value,
    BOOL conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 reg;

    if (conditionFlag)
    {
        // convert the CRTC port into a priv register
        rmStatus = DevinitPortToPrivReg(port, &reg);
        if (rmStatus == RM_OK)
        {
            // write the value
            REG_WR32(reg, value);
        }
    }

    return rmStatus;

} // end of init_ZM_IO()

RM_STATUS init_Copy
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               srcReg,
    S008               srcShift,
    U032               srcMask,
    U032               port,
    U032               index,
    U032               destMask,
    BOOL               conditionFlag
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 srcValue;
    U032 value;
    U008 destValue;

    if (conditionFlag)
    {
        srcValue = REG_RD32(srcReg);
        if (srcShift >= 0)
        {
            srcValue >>= srcShift;
        }
        else
        {
            srcValue <<= -srcShift;
        }
        value = srcValue & srcMask;
        rmStatus = DevinitReadPort(pDev, port, index, &destValue);
        if (rmStatus == RM_OK)
        {
            destValue = (destValue & (U008) destMask) | (U008) value;
            rmStatus = DevinitWritePort(pDev, port, index, destValue);
        }
    }

    return rmStatus;

} // end of init_Copy()

RM_STATUS init_Repeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               ip,
    U032               loopCount
)
{
    RM_STATUS rmStatus = RM_OK;

    // setup the loop stack to contain the loop offset and the current loop count
    DevinitStackPush(&cp->loopStack, ip);
    DevinitStackPush(&cp->loopStack, loopCount);
    
    return rmStatus;

} // end of init_Repeat()

RM_STATUS init_EndRepeat
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032*              pip
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 count;

    // pop the current loop count from the loop stack and decrement it
    count = DevinitStackPop(&cp->loopStack);
    if (--count > 0)
    {
        // continue looping -- adjust offset to the top of the loop and push the counter back on
        *pip = DevinitStackTop(&cp->loopStack);
        DevinitStackPush(&cp->loopStack, count);
    }
    else
    {
        // terminate looping -- clear the rest of loop stack and go on to the next instruction
        (VOID)DevinitStackPop(&cp->loopStack);
    }
    
    return rmStatus;

} // end of init_EndRepeat()

RM_STATUS init_Function
(
    PHWINFO            pDev,
    PEXECUTION_CONTEXT cp,
    U032               functionIndex
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 functionId;

    // call the HAL to execute this "escape" function
    functionId = cp->tables->functionTable[functionIndex];
    // HalExecuteFunction(functionId);

    return rmStatus;

} // end of init_Function()

VOID DevinitMeminitFormat
(
    PHWINFO   pDev,
    char    **fmt,
    int      *padded_size
)
{
    U032 value;

    value = REG_RD32(NV_PBUS_PCI_NV_0);
    value >>= 16;
    value &= 0xffff;

    switch (value)
    {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
            *padded_size = sizeof(MEM_INIT_VALS_NV10);
            *fmt = MEM_INIT_VALS_NV10_FMT;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2:
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3:

        default:

            *padded_size = sizeof(MEM_INIT_VALS_NV15);
            *fmt = MEM_INIT_VALS_NV15_FMT;
            break;
    }
}

RM_STATUS DevinitReadPort
(
    PHWINFO pDev,
    U032    port,
    U032    index,
    U008   *pValue
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // read the value
        REG_WR08(privReg, index);
        *pValue = REG_RD08(privReg + 1);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitReadPort()

RM_STATUS DevinitWritePort
(
    PHWINFO pDev,
    U032 port,
    U032 index,
    U032 value
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 privReg;
    U008 prevIndex;

    // convert the CRTC port into a priv register
    rmStatus = DevinitPortToPrivReg(port, &privReg);
    if (rmStatus == RM_OK)
    {
        // save the old index
        prevIndex = REG_RD08(privReg);

        // write the value
        REG_WR08(privReg, index);
        REG_WR08(privReg + 1, value);

        // restore the old index
        REG_WR08(privReg, prevIndex);
    }

    return rmStatus;

} // end of DevinitWritePort()

RM_STATUS DevinitPortToPrivReg
(
    U032 crtcReg, 
    U032* pPrivReg
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (crtcReg)
    {
        case CRTC_INDEX_MONO:
        case CRTC_INDEX_COLOR:
        case ATC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMCIO) + crtcReg;
            break;

        case SEQ_INDEX:
        case GDC_INDEX:
        //...
            *pPrivReg = DEVICE_BASE(NV_PRMVIO) + crtcReg;
            break;

        default:
            rmStatus = RM_ERROR;
            break;
    }

    return rmStatus;

} // end of DevinitPortToPrivReg()

VOID DevinitStackPush
(
    PDEVINIT_STACK pStack,
    U032 value
)
{
    if (pStack->sp < DEVINIT_STACK_MAX)
    {
        (*pStack).body[++pStack->sp] = value;
    }

} // end of DevinitStackPush()

U032 DevinitStackPop
(
    PDEVINIT_STACK pStack
)
{
    if (pStack->sp > 0)
    {
        return (*pStack).body[pStack->sp--];
    }

    // on stack underflow, return 0
    return 0;

} // end of DevinitStackPop()

U032 DevinitStackTop
(
    PDEVINIT_STACK pStack
)
{
    return (*pStack).body[pStack->sp];

} // end of DevinitStackTop()

RM_STATUS DevinitShadowBios
(
    PHWINFO pDev,
    PHWREG  externalBiosImage
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWREG tempBiosAddr;
    U032 i;

    if (externalBiosImage)
    {
        // setup for ROM reads
        tempBiosAddr = biosAddr;
        biosAddr = externalBiosImage;

        // copy the BIOS image into upper instance memory
        for (i = 0; i < BIOS_ROM_CODE_SIZE; i++)
        {
            REG_WR08(pDev->Pram.HalInfo.PraminOffset + i, BIOS_RD08(i));
        }

        // restore original biosAddr
        biosAddr = tempBiosAddr;
    }
    else
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

} // end of DevinitShadowBios()

// extract the FminVCO/FmaxVCO values from the BIOS, if available
RM_STATUS DevinitGetMinMaxVCOValues
(
    PHWINFO    pDev,
    U032       *FminVCO,
    U032       *FmaxVCO
)
{
    RM_STATUS rmStatus = RM_OK;
    BMP_Control_Block bmpCtrlBlk;
    U032 offset;

    *FminVCO = *FmaxVCO = 0x0;

    // determine if we've got the correct BIOS rev
    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    if (rmStatus != RM_OK)
        return rmStatus;

    if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5)
    {
        // FminVCO/FmaxVCO are only available in BMP 0x05.0x10 or greater
        if (bmpCtrlBlk.CTL_Flags < 0x10)
            return RM_ERROR;

        switch (bmpCtrlBlk.CTL_Flags)
        {
            // Version 0x10 did not have TMDS tables
            case 0x10:
            {
                BMP_Struc_Rev5_0x10 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x10_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }

            // default is BIP/3 BMP init table version 5, subversion 0x11 base-level functionality or above
            default:
            {
                BMP_Struc_Rev5_0x11 bmpInitTable;
                BiosReadStructure(pDev,
                                  &bmpInitTable,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_0x11_FMT);

                *FminVCO = bmpInitTable.BMP_FminVco;
                *FmaxVCO = bmpInitTable.BMP_FmaxVco;
                rmStatus = RM_OK;
                break;
            }
        }
    }
    else
        rmStatus = RM_ERROR;

    return rmStatus;

} // end of DevinitGetGetMinMaxVCOValues()

// end of devinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv05mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv05mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV5 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert "OR \" and "OR " to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

bmpMemInitData Nv05_bmp_MemInitTbl[] = 
/*
{
	{
		0x24,
		0x00
	},

	{
		0x28,
		0x00
	},

	{
		0x24,
		0x01
	},

	{
		0x1F,
		0x00
	},

	{
		0x0F,
		0x00
	},

	{
		0x17,
		0x00
	},

	{
		0x06,
		0x00
	},

	{
		0x00,
		0x00
	}
};
*/
{
    {
        // 0000 - 2Mx32 64Mbit 16/32mb
        0x00000024,             // bits 0-2 vary
        0x00000000              // Special 32 field
    },
    
    {
        // 0001 - 4Mx16 64Mbit 32mb
        0x00000028,        
        0x00000000              // Special 32 field
    },

    {
        // 0010 - 1Mx32 32Mbit 32mb + special32
        0x00000024,
        SPECIAL_32              // Flag field
    },

    {
        // 0011 - 1Mx16 16Mbit 8/16mb
        0x0000001F,
        0x00000000              // Special 32 field
    },
    
    {
        // 0100 - 512Kx32 16Mbit (2 bank) 4/8/16mb 
        0x0000000F,  
        0x00000000              // Special 32 field
    },
    
    {
        // 0101 - 512Kx32 16Mbit (4 bank) 4/8/16mb
        0x00000017,
        0x00000000              // Special 32 field
    },
    
    {
        // 0110 - 4Mx16 64Mbit 16MB (looks like 32MB) - "hokey rams"
        0x00000028,               
        SCRAMBLE_RAM            // Flag field
    },
                
    {
        // 0111 - whatever 0110 used to be... some 8mbit 4/8mb type
        0x00000006,             // This looks like 8mbit - 4/8mb
        0x00000000              // Flag field          
    }
};
        
U032 Nv05_bmp_ScrambleTbl[] = 
{
    0x03020100,     // SCRAMBLE_RAM_0 value
    0x07060504,     // SCRAMBLE_RAM_1 value
    0x0B0A0908,     // SCRAMBLE_RAM_2 value
    0x0F0E0D0C,     // SCRAMBLE_RAM_3 value
    0x03020100,     // SCRAMBLE_RAM_4 value
    0x07060504,     // SCRAMBLE_RAM_5 value
    0x0B0A0908,     // SCRAMBLE_RAM_6 value
    0x0F0E0D0C      // SCRAMBLE_RAM_7 value
};
        
U032 Nv05_bmp_GenInitTbl[] = 
{

	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
	DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	INIT_NV_REG,                          // Write register with Mask
	NV_PEXTDEV_BOOT_0,                    // Strap Register Update
	//
	//  +---------------------------------- OVERWRITE_ENABLED
	//  |++++++++++++++++------------------ UNUSED
	//  |||||||||||||||||+----------------- FB32MB
	//  ||||||||||||||||||++--------------- PCI_DEVID[1:0]
	//  ||||||||||||||||||||+-------------- RESERVED_11
	//  |||||||||||||||||||||+------------- AGP_SBA_DISABLED
	//  ||||||||||||||||||||||+------------ AGP_4X_DISABLED
	//  |||||||||||||||||||||||++---------- TVMODE[1:0]
	//  |||||||||||||||||||||||||+--------- CRYSTAL_14318180
	//  ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
	//  ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
	//  |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
	//  VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	//  3322222222221111111111
	//  10987654321098765432109876543210
	//11111111111111111111111111111111b    // AND Mask  
	0xFFFFFFFF,    
	//10000000000000000000100000000000b    // OR  Mask      
	0x80000800,
	                               
	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_PRIV_ASRC,
	//        00000000h                  // 2/26/99 per Quang - fixes TV shimmer
#ifdef ULTRA
	0xF0F000F0,                  // 4/07/99 per Dave Reed
#else                                                 
	0x00000000,                   // 4/07/99 per Dave Reed
#endif  // ULTRA                                       
                                          
	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,
	//        01020101h    // 1/29/99 - Per Dave Reed
#ifdef ULTRA
	0x01000105,           // 4/07/99 - Per Dave Reed
#else              
	0x01020101,           // 4/07/99 - Per Dave Reed
#endif  // ULTRA     

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_0,
	//       0F00BBA7h                   // 8x6 & 10x7 panels (as of 3/22/99)
	0x0800BBA7,                   // 04/07/99

	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_1,
	//       0h                          // as of 3/22/99
	0x0EFE00000,                   // 04/07/99
	                                 
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_2,
	//       0F8C98200h                  // 8x6 & 10x7 panels (as of 3/22/99)
	0x088C98200,                  // 04/07/99
	                                
	INIT_ZM_REG,                 // Write with mask
	NV_PBUS_DEBUG_CTRIM_3,
	//       0FF988AA9h                  // prior to 3/22/99
#ifdef ULTRA
	0x0FF988DDC,                  // 4/07/99
#else                                    
	0x0FF988AA9,                  // 4/07/99
#endif  // ULTRA                          
                           
	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef VANTA
	10000,       // 100Mhz
#else   // VANTA
#ifdef  ULTRA
	15000,       // 150Mhz
#else   // ULTRA
	12500,       // 125Mhz
#endif  // ULTRA           
#endif  // VANTA

	// In all of these cases, Model64 (/DM64) will use the TNT2 settings

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,
#ifdef VANTA
	12500,   // 125Mhz
#else   // VANTA
#ifdef ULTRA
	18300,   // 183Mhz
#else   // ULTRA
	15000,   // 150Mhz
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	//      20001D00h            // 7/23
#ifdef ULTRA
	0x20002D00,            // Per Dave R on 4/7/99
#else
	0x20002500,            // Per Dave R on 4/7/99
#endif  // ULTRA 
#endif 

	// Comment to fix assembler bug

	// Default Value - pre-memory config
	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0x41016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0x00000000,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !! undefined for NV5
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |				// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),					// !! exactly wrong
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO),

	// Comment to fix assembler bug

                               
	INIT_COMPUTE_MEM,             // Compute frame buffer size
          
	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask

	// Final value for running after sizing
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_CONFIG_1,
	0x00F00000,                  // AND Mask
	0x41016293,          // This value works for about everything
        
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        018h                        // Compare value = SDRAM
	//        
	//        INIT_RESUME                 // No more SDRAM stuff
	//                                         
	//        INIT_MEM_RESTRICT
	//        018h                        // Strip to memory type (AND MASK)
	//        010h                        // Compare value = SDRAM
	//             
	//        INIT_RESUME                 // No more SDRAM stuff
	        
	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	//public  bmp_FinalInit
	//bmp_FinalInit:
	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x00000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x000001F0,                // Per K^2 -  4/09/99
	//#ifdef OLD_BOARDS                                  
	//       000011F0h               // Per Jill S. -  5/12/98
	//#else   // OLD_BOARDS
	//       000001F1h               // Per Dave R. -  3/24/99
	//#endif  // OLD_BOARDS
                                               
	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
#ifdef VANTA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // VANTA
#ifdef  ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#else   // ULTRA
	NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
#endif  // ULTRA
#endif  // VANTA

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x01A,0x000,0x03F,
                       
	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x028,0x000,0x000,

	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x033,0x000,0x000,         // Clear slave registers

	// Comment to fix assembler bug
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x021,0x000,0x0FA,         // Force Lock register to 0FAh
        
   // Clear TV device selection
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	//        02Bh,000h,000h        // 
	0x02B,0x007,0x000,         // Amask to retain Strap or override
        
        // Replace the above line with one of the following
        // to override the default settings for TV
	//       02Bh,000h,000h         // Force NTSC_M (Std)
	//       02Bh,000h,001h         // Force NTSC_J (BT869 Only)
	//       02Bh,000h,002h         // Force PAL-M (NTSC w/PAL encoding) (BT869 Only)
	//       02Bh,000h,003h         // Force PAL_BDGHI (Std)
	//       02Bh,000h,004h         // Force PAL-N (BT869 Only)
	//       02Bh,000h,005h         // Force PAL-NC (BT869 Only)
                                                           
	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x02C,0x000,0x000,         // Clear all scratch bits for default
        
        // Old values for TV override selection
	//        02Ch,030h,000h         // Use this line to use straps
	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
                                                       
        // Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

        // Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	 // Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST
};

// raw BMP table for TNT2 Pro 
U032 Nv05Pro_bmp_GenInitTbl[] = 
{
    0x00000065, 0x00000200, 0x01010100, 0x01110100,
    0x0000006e, 0x00101000, 0xffff4c43, 0x8000018c,
    0x0000007a, 0x000010e0, 0xf0f000f0, 0x0000007a,
    0x00001080, 0x04040000, 0x0000007a, 0x000010b0,
    0x0800bba7, 0x0000007a, 0x000010b4, 0xefe00000,
    0x0000007a, 0x000010b8, 0x88c98200, 0x0000007a,
    0x000010bc, 0xff988aa9, 0x00000079, 0x00680500,
    0x00003778, 0x00000079, 0x00680504, 0x00003fac,

    0x0000007a, 0x00100200, 0x00001114, 0x00000079,
    0x00680508, 0x00000e10, 0x0000007a, 0x001000c0,
    0x00000000, 0x0000007a, 0x00100080, 0x20002800,
    0x0000007a, 0x00100204, 0x41016293, 0x0000007a,
    0x00100300, 0x00000000, 0x0000007a, 0x00001084,
    0x000057c8, 0x00000063, 0x0000006e, 0x00100000,
    0xffffffff, 0x00000000, 0x0000006e, 0x00100204,
    0x00f00000, 0x42216293, 0x0000007a, 0x0068050c,

    0x00000500, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000e1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,
    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,

    0x00000078, 0x000003d4, 0x0000002b, 0x00000007,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000071
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv05mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv05mem.c
*
*	Description:
*		Device-specific memory sizing code, for NV5.
*
*	Revision History:
*		Original -- 5/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv4_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv4_ref.h>
#include <os.h>
#include <devinit.h>

#endif

extern bmpMemInitData Nv05_bmp_MemInitTbl[];
extern U032 Nv05_bmp_ScrambleTbl[];

RM_STATUS Nv05MemResizeMemory
(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, data;

	// TO DO: is this necessary?
    // turn on full CPU access
	//...
     
    /*
        ; For UMA mode, we don't configure the memory
        ;
        mov     esi,NV_PFB_BOOT_0
        NV_DOS_GET      esi             ; Get Memory Config register
        test    ah,01h                  ; Is bit 8 set?
        jnz     @Exit                   ; Yep - UMA is on! Nada to configure!
        ;
        ; For UMA mode above.
        ;
    */
    // only size memory if UMA is disabled
    if (REG_RD_DRF(_PFB,_BOOT_0,_UMA) == NV_PFB_BOOT_0_UMA_DISABLE)
    {
	    // enable refresh for memory sizing
        FLD_WR_DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED);

        // TO DO: remove this when KevinM says OK
        // scramble the RAM from the table
        for (i = 0; i < 8; i++)
        {
            REG_WR32(NV_PFB_SCRAMBLE(i), Nv05_bmp_ScrambleTbl[i]);
        }
    
        // configure memory type by way of straps as follows:
        //   1.  get the strapping value from NV_PEXTDEV_BOOT_0
        //   2.  use that value as an index into the memory init table
        //   3.  the first member of the selected table element configures NV_PFB_BOOT_0
        //   4.  the second member of the selected table element configures PFB_CONFIG_1
        i = REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
        data = (REG_RD32(NV_PFB_BOOT_0) & 0xFFFFFFC0) | Nv05_bmp_MemInitTbl[i].PFB_BOOT_0_value;
        REG_WR32(NV_PFB_BOOT_0, data);
    
        // scramble the RAM, if indicated
    /*    
            ; Here, look for need to scramble RAM
            test    cl,SCRAMBLE_RAM                 ; Bit says to scramble the RAM?
            jz      @no_scramble
    
            ; Scramble the RAM according to the RAM table defined
            ; earlier.
            ;
            mov     di, offset bmp_ScrambleTbl      ; Point at table of RAM values
            mov     esi,NV_PFB_SCRAMBLE_RAM_0       ; Get strapping bits
            mov     cx,8                            ; Do 8 locations
    @@: 
            mov     eax,cs:[di]                     ; Read value 1
            NV_DOS_PUT      esi                     ; Write it out
            add     di,4                            ; Next DWORD
            add     esi,4                           ; Next DWORD
            loop    @b        
                                  ; and loop again
            ; Enable the scramble
            mov     esi,NV_PFB_CONFIG_0             ; Access Scramble RAM
            NV_DOS_GET      esi        
            or      eax, NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE
            NV_DOS_PUT      esi        
                   
    @no_scramble:
    */
        if (Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value == SCRAMBLE_RAM)
        {
    // TO DO: enable this code when Kevin M says OK
    #if 0
            for (i = 0; i < 8; i++)
            {
                REG_WR32(NV_PFB_SCRAMBLE_RAM_0 + (i * 4), Nv05_bmp_ScrambleTbl[i]);
            }
    #endif    
            FLD_WR_DRF_DEF(_PFB,_CONFIG_0,_SCRAMBLE,_ACTIVE);
        }
      
        // toggle latency bit to latch in the config, as follows:
        //   1. Clear to CL=2 and the SPECIAL32 bit or default SPECIAL32 value
        //   2. Set back to CL=3 
    /*
            pop     ecx                             ; Get flags back
            and     cl,SPECIAL_32                   ; Keep only SPECIAL_32 bit
            shl     ecx,20                          ; put in proper bit location
        
            ; Toggle PFB_CONFIG_1 CAS latency bit to generate MRS cycle.
            mov     esi,NV_PFB_CONFIG_1             ; Get Config1 bits
            NV_DOS_GET      esi
        
            and     eax,0FF8FFFFEh                  ; Clear to CL=2 and the SPECIAL32 bit
            or      eax,ecx                         ; Or default SPECIAL32 value in.
            NV_DOS_PUT      esi                     ; Write it back out
        
            or      al,01h                          ; Set back to CL=3
            NV_DOS_PUT      esi                     ; Write it back out
    */
        data = (REG_RD32(NV_PFB_CONFIG_1) & 0xFF8FFFFE) | ((Nv05_bmp_MemInitTbl[i].PFB_CONFIG_1_value & SPECIAL_32) << 20);
        REG_WR32(NV_PFB_CONFIG_1, data);
        data |= 0x00000001;
        REG_WR32(NV_PFB_CONFIG_1, data);
    
        // check for RAM width as follows:
        //   1.  assume width is 128 bits
        //   2.  write out a 128 bit test data word
        //   3.  attempt to read lower word
        //   4.  if not successful, change bus width to 64 bits
        //   5.  otherwise, bus width remains at default of 128 bits
        for (i = 0; i < 4; i++)
        {
            FB_WR32(i * 4, 'NV5A');
        }    
        if (FB_RD16(0x0000000C) != '5A')
        {
            FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_WIDTH_128,_OFF);
        }
    
        // determine the memory size -- default amount is 32Meg
        if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_32MB)
        {
            // write at 16Meg+1 to determine 32 or 16 Meg
            FB_WR32(0x01000000, 'NV5B');
            if (FB_RD32(0x01000000) == 'NV5B')
            {
                // read at 0 to determine if it wrapped on VANTA
                FB_WR32(0x00000000, 'A5VN');
                if (FB_RD32(0x00000000) != 'A5VN')
                {
                    // 16MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
                }
            }
            else
            {
                // 16MB detected, so change config
                FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_16MB);
            }
        }
        else
        {
            // test for 16 Meg
            if (REG_RD_DRF(_PFB,_BOOT_0,_RAM_AMOUNT) == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            {
                // write at 8Meg+1 to determine 16Meg or less
                FB_WR32(0x00800000, 'NV5C');
                if (FB_RD32(0x00800000) != 'NV5C')
                {
                    // write at 4Meg+1 to determine 8 or 4 Meg
                    FB_WR32(0x00400000, 'NV5D');
                    if (FB_RD32(0x00400000) == 'NV5D')
                    {
                        // 8MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                    }
                    else
                    {
                        // 4MB detected, so change config
                        FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                    }
                }
            }
            else
            {
                // write at 4Meg+1 to determine 8 or 4 Meg
                FB_WR32(0x00400000, 'NV5D');
                if (FB_RD32(0x00400000) == 'NV5D')
                {
                    // 8MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_8MB);
                }
                else
                {
                    // 4MB detected, so change config
                    FLD_WR_DRF_DEF(_PFB,_BOOT_0,_RAM_AMOUNT,_4MB);
                }
            }
        }
    }    
    
	// TO DO: is this necessary?
	// turn off full CPU access
	//...

	return rmStatus;

} // end of DevinitResizeSgram()

VOID Nv05MemLatchMemConfig
(
    PHWINFO pDev
)
{
    // save the original CAS latency
    U032 latency = REG_RD_DRF(_PFB,_CONFIG_1,_CAS_LATENCY);
    
    // toggle the LSB 1-0-1
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_2);
    FLD_WR_DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3);
    
    // restore original CAS latency
    FLD_WR_DRF_NUM(_PFB,_CONFIG_1,_CAS_LATENCY,latency);
    
} // end of Nv04MemLatchMemConfig()


// end of nv04mem.c


// end of nv05mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\event.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: EVENT.C                                                           *
*   Event notifications are handled in this module.  DMA report and OS      *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//---------------------------------------------------------------------------
//
//  Event Notification structure.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Event Object support.
//
//---------------------------------------------------------------------------

// Given the Parent Object, add the notify event.
RM_STATUS eventSetObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject,
   U032    NotifyIndex,
   U032    NotifyType,
   U064    Data
)
{
    PEVENTNOTIFICATION EventNotify;
    RM_STATUS          status;
    
    //
    // Create the event notification object
    //
    status = osAllocMem((VOID **)&EventNotify, sizeof(EVENTNOTIFICATION));
    if (status)
        return (status);

    //
    // Fill in the fields
    //
    EventNotify->Handle      = hObject;
    EventNotify->NotifyIndex = NotifyIndex;
    EventNotify->NotifyType  = NotifyType;
    EventNotify->Data        = Data;

    //
    // Now insert the event into the event chain of this object.  
    // Order doesn't really matter.
    //
    EventNotify->Next = ParentObject->NotifyEvent;
    ParentObject->NotifyEvent = EventNotify;
    
    return (RM_OK);        
}

//---------------------------------------------------------------------------
//
//  Event Notification support.
//
//---------------------------------------------------------------------------

//
// Given an object's name and fifo, insert a new event notifier into this object.
//
RM_STATUS eventSetEventNotify
(
    PHWINFO     pDev, 
    U032        ObjectName,
    U032        ChID,
    U032        NotifyIndex,
    U032        NotifyType,
    U064        Data
)
{
#ifdef LEGACY_ARCH
    POBJECT            Object;
    RM_STATUS          status;
    
    //
    // Find the parent object
    //
    if (fifoSearchObject(pDev, ObjectName, ChID, &Object) == RM_OK)
    {
        // Found the parent.
		status = eventSetObjectEventNotify(Object, 0/* object handle*/, 
		                                   NotifyIndex, NotifyType, Data);
    }
    else
		// Did not find the parent
        status = RM_ERROR;
        
    return status;        
#else
	// For the new architecture, this proc is not called.
    return RM_ERROR;
#endif
}    

RM_STATUS eventRemoveObjectEventNotify
(
   POBJECT ParentObject,
   U032    hObject
)
{
    PEVENTNOTIFICATION nextEvent, lastEvent;
    BOOL found = FALSE;
    
    // check for null list
    nextEvent = (void *) 0;
    if (ParentObject->NotifyEvent != NULL)
    {
        // check for head of list
        nextEvent = lastEvent = ParentObject->NotifyEvent;
        if ((nextEvent->Handle = hObject))
        {
            ParentObject->NotifyEvent = nextEvent->Next;
            found = TRUE;
        }
        else
        {
            // check for internal nodes
            nextEvent = nextEvent->Next;
            while (nextEvent)
            {
                if ((nextEvent->Handle = hObject))
                {
                    lastEvent->Next = nextEvent->Next;
                    found = TRUE;
                    break;
                }
                lastEvent = nextEvent;
                nextEvent = nextEvent->Next;
            }
        }
    }
    
    // delete the event if it was found
    if (found)
    {
        osFreeMem(nextEvent);
    }
    
    return (found) ? RM_OK : RM_ERROR;
        
} // end of eventRemoveObjectEventNotify()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv04mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv04mtbl.c
*
*	Description:
*		This file contains the initialization code used to POST an NV4 device.
*	The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 2/99 Jeff Westerinen
*
*
*	Steps to convert nvinit.inc to initcode.h
*
*		1.	enclose data in: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.	convert ; to //
*		3.  remove all db, dw, and dd, and add comma separaters
*		4.  convert IFDEF to #ifdef
*		5.	convert ELSE to #else
*		6.	convert ENDIF to #endif
*		7.	convert OR \ to |
*		8.	convert <num>h to 0x<num>
*		9 .	format -- at least line up data to left indent
*		10. comment out all table delimiters
*		11. remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv4_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv04_bmp_GenInitTbl[] = 
{

	//IFNDEF NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	//        DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//           DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)
	//#endif // NVIDIA_RESET

	// Comment to fix assembler bug
	INIT_RESET,
	NV_PMC_ENABLE,      // NV 32 bit address.
	// Off state
	DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),
		DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
		DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED),

	//#ifdef NVIDIA_RESET
	//        INIT_RESET
	//#else // NVIDIA_RESET
	//        // Reset engines
	//        INIT_ZM_REG
	//        NV_PMC_ENABLE      // NV 32 bit address.
	////#endif // NVIDIA_RESET
	//        DRF_DEF(_PMC,_ENABLE,_PFB,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PCRTC,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PPMI,_ENABLED) |
	//                DRF_DEF(_PMC,_ENABLE,_PFIFO,_ENABLED)

	// Comment to fix assembler bug

#ifdef DISABLE_SIDEBAND

	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000C00,                  // OR Mask
#else 
	INIT_NV_REG,                 // Write register with Mask
	NV_PEXTDEV_BOOT_0,               // Strap Register for Memory
	0xFFFFFBFF,                  // AND Mask
	0x00000800,                  // OR Mask

#endif  // DISABLE_SIDEBAND

	// Barry's memory fix for AGP
	INIT_ZM_REG,
	NV_PBUS_DEBUG_0,

	////        0E0F0000h    
	////        04050000h   // 7/23/98

	0x20F0000,    // 11/13/98 - New value from Dave Reed for 110Mhz MCLK

	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_NVPLL_COEFF,       // Actually, this is NVPLL (680500)
#ifdef INTEL 
	8500,        // 85Mhz
#else                      
	9000,        // 90Mhz
#endif 


	// Comment to fix assembler bug

	// 13,500,000 MHz - MCLK = M:11:0B, N:163:A3, P:4:04 LOG2P:2 50 MHz
	// 14,318,180 MHz - MCLK = M:14:0E, N:196:C4, P:4:04 LOG2P:2 50 MHz
	INIT_PLL,
	NV_PRAMDAC_MPLL_COEFF,

#ifdef INTEL 
	10000,   // 100Mhz
#else                  
	11000,   // 110Mhz
#endif 


	// Comment to fix assembler bug

	// NV_PFB_CONFIG_0
	INIT_ZM_REG,
	NV_PFB_CONFIG_0,      // NV 32 bit address.
	DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED) |
		DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED),

	// Comment to fix assembler bug

	// VCLK.
	// 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
	// 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
	INIT_PLL,
	NV_PRAMDAC_VPLL_COEFF,        // NV 32 bit address.
	3600,
	//        00001400Ch
	//        000028D0Eh

	// Comment to fix assembler bug

	// NV_PFB_GREEN_0
	INIT_ZM_REG,
	NV_PFB_GREEN_0,   // NV 32 bit address.
	DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED),   // NV 32 bit data.

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_DEBUG_0,
#ifdef IKOS
	//        20005000h            // IKOS value - turns on slow clock
	0x20000100,          // Per RussM on 10/14
#else   // IKOS                   
	0x20001D00,            // 7/23
#endif 

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,
	0xC1016293,          // This value works for about everything

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PFB_RTL,
	0,

	// Comment to fix assembler bug

	// Per Dave Reed
	// Setup more optimal PCI interface
	INIT_ZM_REG,
	NV_PBUS_DEBUG_1,
	DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP) |			// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED) |
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED) |		// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED) |
		//DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO) |
		DRF_DEF(_PBUS,_DEBUG_1,_FBI_DIFFERENTIAL,_DISABLED) |	// !!!!!!!!!!!
		DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ONE),

	// Comment to fix assembler bug

	INIT_COMPUTE_MEM,             // Compute frame buffer size

	//=============================================================
	//       Memory Dependent Initialization Table.
	//=============================================================

#ifdef  NV5
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFF00,                  // AND Mask
	0x00000024,                  // OR Mask - 32MB SDRAM
	//        00000001Fh                  // OR Mask - 16MB SDRAM
#else               
	INIT_NV_REG,                 // Write register with Mask
	NV_PFB_BOOT_0,               // Strap Register for Memory
	0xFFFFFFFF,                  // AND Mask
	0x00000000,                  // OR Mask
#endif     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x18,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif   

	INIT_RESUME,                 // No more SDRAM stuff
	     
	INIT_MEM_RESTRICT,
	0x18,                        // Strip to memory type (AND MASK)
	0x10,                        // Compare value = SDRAM

	INIT_ZM_REG,
	NV_PFB_CONFIG_1,

#ifdef  INTEL 
	0xC1016293,          // This value works for about everything
#else 
	0x31012132,                  // Set DRAM value
#endif 

	INIT_RESUME,                 // No more SDRAM stuff

	//------------------------------------------------------------
	//       Final Initialization Tables.
	//------------------------------------------------------------
	//
	//       Max allocated Final init space is
	//       INIT_ADDITION_REG_SPACE. This includes the FinalInit
	//       table and the FinalInit tables for all the FinalMem
	//       inits. OEM will utilize the BMP to maximize the
	//       utilization of addition table space.
	//

	// Comment to fix assembler bug

	INIT_ZM_REG,
	NV_PRAMDAC_PLL_COEFF_SELECT,   // NV 32 bit address.
	0x0000500,                   // PROG_MPLL & PROG_NVPLL

	// Comment to fix assembler bug

	// tbo
	INIT_ZM_REG,
	NV_PBUS_DEBUG_2,
	0x00011F0,               // Per Jill S. -  5/12

	INIT_ZM_REG,
	NV_PBUS_DEBUG_3,
	NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,
	// tbo

	// Comment to fix assembler bug

	// Force real mode window default state to off
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	NV_CIO_CRE_RMA__INDEX,0x00,0x00,

	// Make sure hsync and vsync are on (we only set them in DPMS calls)
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x1A,0x00,0x3F,

	// Comment to fix assembler bug

	// Boot with TV off, and set for NTSC if it was on.
	// Also set horizontal pixel adjustment
	// Sets pixel format to VGA
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x28,0x00,0x00,

	// Comment to fix assembler bug
#ifdef NV5 
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x21,0x00,0xFA,         // Force Lock register to 0FAh
#endif  // NV5                        

	// Clear scratch to default state
	INIT_INDEX_IO,
	CRTC_INDEX_COLOR,
	0x2C,0x30,0x00,         // Use this line to use straps

	//        02Ch,000h,010h          // Use this line to force NTSC Boot
	//        02Ch,000h,020h          // Use this line to force PAL Boot
	//        02Ch,000h,000h         // Use this line to force NOTV Boot
	                   
	// Float DDC pins high (not touched during a mode set or save/restore state)
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,033h

	// Disable DDC
	//        INIT_INDEX_IO
	//        CRTC_INDEX_COLOR
	//        03Fh,000h,032h

	// Comment to fix assembler bug

	INIT_DONE
	//        EOL //END OF LIST

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv10mem.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*	Module: nv10mem.c
*
*	Description:
*		Device-specific memory sizing code, for Nv10.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
**************************************************************************************************************/

#ifdef NV_PORTABLE

/* "portable" form for use outside resman and by external source customers */
/* look in devinit/portable/ for more details */
#include <nv_portable.h>
#include <nv_ref.h>
#include <nv10_ref.h>
#include <devinit.h>

#else	/* not NV_PORTABLE --> Nvidia internal */

#include <nvrm.h>
#include <nvhw.h>
#include <nv10_ref.h>
#include <os.h>
#include <devinit.h>

#endif

RM_STATUS Nv10MemConfigureClocks
(
    PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clk;
    U032 memInitTableIndex;
    U032 M,N,P;
    U032 Head = 0; // straps are on head 0; likewise NVPLL, MPLL
/*
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        shr     ax,12                           ; bits 0:3
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table

        ; Program NVCLK first, since we've always done it that way
        ;

        mov     ax, cs:[di].MEM_INIT_VALS._NVClk_PLL    ; Get MCLK value
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_NVPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program NVCLK
#ifdef FORCE_NVCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing NVCLK Mhz to ", FORCE_NVCLOCKMHZ);
    clk = FORCE_NVCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].NVClk_PLL;
#endif
// Use dacCalcMFP instead of DevinitCalcMNP,
// since the devinit version seems to be returning wrong values.
//    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DevinitCalcMNP(pDev, &clk));
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _MDIV, M) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _NDIV, N) |
             DRF_NUM(_PRAMDAC, _NVPLL_COEFF, _PDIV, P));
                                        
/*
        ; Now, get the sequence table and the MCLK value
        ;
        mov     ax, cs:[di].MEM_INIT_VALS._MClk_PLL     ; Get MCLK value
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr2
        shl     ax,1                            ; Double MCLK on DDR
@got_sdr2:
        
        ; Here, ax = the decimal MCLK value
                
        push    bx      ; BX returns data from this call that we won't use
        call    CalcMNP                         ; Get MNP parameters
        pop     bx
        
        ;       AL = M parameter
        ;       AH = N parameter
        ;       DL = P parameter
        mov     esi,NV_PRAMDAC_MPLL_COEFF
        call    ProgPLL                         ; Program the PLL's
*/
    // program MCLK -- double the clock if flags indicate DDR memory
#ifdef FORCE_MCLOCKMHZ
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: Nv10MemConfigureClocks: forcing MCLK Mhz to ", FORCE_MCLOCKMHZ);
    clk = FORCE_MCLOCKMHZ * 100;	// Clock MHz * 100
#else
    clk = memInitTable[memInitTableIndex].MClk_PLL;
#endif

    if (memInitTable[memInitTableIndex].Flags == DDR)
    {
        clk *= 2;
    }
    
    // use the RM kernel (dacCalcMFP()) to calculate M, N, and P values
    dacCalcMNP(pDev, Head, clk, &M, &N, &P);
    REG_WR32(
        NV_PRAMDAC_MPLL_COEFF, 
        DRF_NUM(_PRAMDAC, _MPLL_COEFF, _MDIV, M) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _NDIV, N) |
            DRF_NUM(_PRAMDAC, _MPLL_COEFF, _PDIV, P)
    );
    return rmStatus;
    
} // end of Nv10MemConfigureClocks()

    
RM_STATUS Nv10MemConfigureMemory
(
	PHWINFO pDev,
    MEM_INIT_TABLE_NV10 memInitTable, 
    U032 SDRSeqTable[], 
    U032 DDRSeqTable[]
)
{
	RM_STATUS rmStatus = RM_OK;
    U032* seqTable;
    U032 memInitTableIndex, initValue;
    U032 memInitDataIndex = 0; 
    U032 seqTableIndex = 0;
    
    U032 Head = 0;    
    
/*
        call    FullCpuOn               ; Turn on full CPU access
        
        ; Configure memory type by way of straps
        ;
        
        ; Get straps, and turn AL into an index to the table
        ;                       
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
;        shr    ah,4                            ; Move bits to AH[3:0]
;        shr    ax,8                            ; Move AH->AL
        shr     ax,12                           ; bits 0:3
        
;        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
;        NV_DOS_GET      esi
;        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG      ; Keep RAMCFG bits
;        shr     ax, RAMCFG_SHIFT
*/
    // get the index in the memory init table from scratch register 4
    CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, memInitTableIndex, Head);
    memInitTableIndex >>= 4;
    
/*
        ; Size of config structure
        mov     cl, SIZEOF MEM_INIT_VALS        ; Get the size of the config struct
        mul     cl
        
        ; Now point at the right structure with CS:SI
        mov     di, offset bmp_MemInitTbl
        add     di,ax                           ; Add offset into init table
        
        mov     bx, offset SDR_Sequence_Table
        test    cs:[di].MEM_INIT_VALS._Flags, 01h        ; SDR or DDR?
        jz      @got_sdr

        ; We have DDR memory - turn on FBI_DIFFERENTIAL
        ; 8/25/99
        ;
        mov     esi,NV_PBUS_DEBUG_1
        NV_DOS_GET      esi                     ; Read register
        and     eax,NOT (NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL)
        or      eax, NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL_ENABLED
        NV_DOS_PUT      esi                     ; Re-write register
        
        mov     bx, offset DDR_Sequence_Table
@got_sdr: 
*/
    // set proper sequence table
    switch (memInitTable[memInitTableIndex].Flags)
    {
        case SDR:
            seqTable = SDRSeqTable;
            break;
            
        case DDR:
            seqTable = DDRSeqTable;
            break;
            
        default:
            return RM_ERROR;
    }
    
/*
        add     di,6                            ; Skip Flags, MCLK, NVCLK values
        
        ; CS:BX = pointer to sequence list
        ; CS:DI = pointer to sequence data (MEM_INIT_VALS)
@next_sequence:
        mov     esi, cs:[bx]                    ; Get Sequence
        cmp     esi, 0FFFFFFFFh                 ; End of sequence?
        je      @end_sequence
        
        cmp     esi,NV_PFB_PRE                  ; Precharge command?
        jne     @f  
        
        mov     eax, NV_PFB_PRE_CMD_PRECHARGE   ; Issue precharge command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_PAD
        jne     @f            
        
        mov     eax, NV_PFB_PAD_CKE_NORMAL      ; Enable
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_REF                  ; Recharge command?
        jne     @f  
        
        mov     eax, NV_PFB_REF_CMD_REFRESH     ; Issue Refresh command
        jmp     @set_pfb_reg
@@:
        cmp     esi,NV_PFB_EMRS                 ; EMRS command?
        jne     @f  
        
        mov     eax, cs:[di]                    ; Read data value
        cmp     eax, 0FFFFFFFFh                 ; Is it a -1? (SDR)
        jne     @f                              ; Nope - program value
        
        add     di, 4                           ; Skip data value
        jmp     @skip_val                       ; Yep - skip the data value
@@:      
        mov     eax, cs:[di]                    ; Read data value
        add     di, 4                           ; Next data value
        
@set_pfb_reg:   
        NV_DOS_PUT      esi     
@skip_val:
        add     bx, 4                           ; Next sequence value
        jmp     @next_sequence
                
@end_sequence:
*/

    // execute the memory init sequence
    while (seqTable[seqTableIndex] != MEM_INIT_END_OF_SEQUENCE)
    {
        switch (seqTable[seqTableIndex])
        {
            case NV_PFB_PRE:
	            FLD_WR_DRF_DEF(_PFB,_PRE,_CMD,_PRECHARGE);
                break;
                
            case NV_PFB_PAD:
	            FLD_WR_DRF_DEF(_PFB,_PAD,_CKE,_NORMAL);
                break;
                
            case NV_PFB_REF:
	            FLD_WR_DRF_DEF(_PFB,_REF,_CMD,_REFRESH);
                break;
                
            case NV_PFB_EMRS:
                initValue = memInitTable[memInitTableIndex].data[memInitDataIndex++];
                if (initValue != 0xffffffff)
                {
                    REG_WR32(NV_PFB_EMRS, initValue);
                }
                break;
                
            default:
                REG_WR32(seqTable[seqTableIndex], memInitTable[memInitTableIndex].data[memInitDataIndex++]);
                break;
        }
        seqTableIndex++;
    }
    
    return rmStatus;
    
} // end of Nv10MemConfigureMemory()

RM_STATUS Nv10MemChipPreInit
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
    U016 crystalVal, ramcfgVal, data;
    U032 Head = 0;
/*
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        
        test    eax, NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180
        jz      @freq_13
                 
        ; Bit set - we're on 14.318 reference frequency
        mov     ax,((NV_CIO_SCRATCH4_14MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
        jmp     @f
        
@freq_13: 
        mov     ax,((NV_CIO_SCRATCH4_13MHZ SHL 8) OR (NV_CIO_SCRATCH4_INDEX))
@@:                                   
        call    WriteCRTCReg            ; Write the unlock   
        
        mov     esi,NV_PEXTDEV_BOOT_0           ; Get strapping bits
        NV_DOS_GET      esi
        and     ax, NV_PEXTDEV_BOOT_0_STRAP_RAMCFG ; Keep RAMCFG bits 5:2
        shl     ax, RAMCFG_SHIFT                ; Shift into bits 7:4
        mov     bh,al                           ; Put in BH a while
        mov     al,NV_CIO_SCRATCH4_INDEX        ; CR3C
        call    ReadCRTCReg                     ; Read current value
        or      ah,bh                           ; Or in new values
        call    WriteCRTCReg                    ; Write CR3C
*/
    // pack and save away the strapping values into scratch register 4
    crystalVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_CRYSTAL);
    ramcfgVal = (U016)REG_RD_DRF(_PEXTDEV,_BOOT_0,_STRAP_RAMCFG);
    data = (U008)(ramcfgVal << 4 & 0x00f0) | (crystalVal & 0x000f);
    CRTC_WR(NV_CIO_CRE_SCRATCH4__INDEX, data, Head);

    return rmStatus;
    
    
} // end of Nv10MemChipPreInit()

RM_STATUS Nv10MemComputeMemory
(
	PHWINFO pDev
)
{
	RM_STATUS rmStatus = RM_OK;
	U032 testAddress;
    
/*
        call    FullCpuOn               ; Turn on full CPU access
        
        ; Ensure refresh is on
        mov     eax,NV_PFB_REFCTRL_VALID_1  ; NV_PFB_REFCTRL
        mov     esi,NV_PFB_REFCTRL
        NV_DOS_PUT      esi             ; Set Memory Config register
        
        ;
        ; Check for RAM width
        ;           
*/
    // ensure refresh is on
	FLD_WR_DRF_DEF(_PFB,_REFCTRL,_VALID,_1);
    
/*
        ; Write to Frame Buffer.
        mov     esi,(NV_PDFB OR NV_PDFB_ACCESS)
        add     si,1Ch                  ; Write to NV_PDFB+1Ch
        mov     eax,'NV10'              ; Write value to test.
        mov     edx, eax                ; Save write value
        
        NV_DOS_PUT      esi
        
        add     si,20h                  ; Write to NV_PDFB+3Ch
        xor     eax,eax                 ; Write 0's to drive pads low
                                                           
        NV_DOS_PUT      esi
        
        sub     si,20h                  ; Move back to offset 1Ch
        
        ; Read 2 bytes at 0MB + 0x1C (Lower 16 bits of 128-bit word)
        NV_DOS_GET      esi                            
        cmp     eax,edx                 ; Is EAX = 'NV5A'?            
                                                    
        je      @GoodBusSize            ; Yep - it's 128-bit bus
                                                
        ; Set PFB_CFG with correct BUS size                                   
        mov     esi,NV_PFB_CFG
        NV_DOS_GET      esi             ; Get Memory Config register
        and     eax,0FFFFFFEFh          ; Clear RAM width bit to make 64-bit
        NV_DOS_PUT                      ; Write it back out
        
@GoodBusSize:                         
*/
    // check for RAM width as follows:
    //   1.  write non-zero test word to 0x0000001c
    //   2.  write out a zero word to 0x0000003c
    //   3.  attempt to read lower word at 0x0000001c
    //   4.  if not successful, change bus width to 64 bits
    //   5.  otherwise, bus width remains at default of 128 bits
    FB_WR32(0x0000001c, 'NV10');
    FB_WR32(0x0000003c, 0x00000000);
    if (FB_RD16(0x0000001c) != '10')
    {
        FLD_WR_DRF_DEF(_PFB,_CFG,_BUS,_64);
        //Nv05MemLatchMemConfig(pDev);
    }
    
/*
        ;
        ; Get memory size now
        ;
        
        ; Default value in PFB_CFG is largest memory buffer supported
        ;
        mov     esi,NV_PFB_CSTATUS
        NV_DOS_GET      esi             ; Get Memory Size register
        
        ; EAX now has the largest memory size supported, as calc'd by the HW
        shr     eax,1                   ; Make next size down - this will
                                        ; force a write at the MB just above
                                        ; the next smaller size.
        mov     esi,(NV_PDFB OR NV_PDFB_ACCESS)
        add     esi,eax                 ; Add in max size
                           
        mov     eax,'NVDA'              ; Write value to test.
        mov     edx, eax                ; Save write value
                           
        NV_DOS_PUT      esi             ; Write test value to memory
        add     si,20h                  ; Write another address w/diff data
        xor     eax,eax
        NV_DOS_PUT      esi             ; Force pad's low
        sub     si,20h                  ; Return to original address
        NV_DOS_GET      esi             ; Read it back        

        cmp     eax,edx                 ; Read back our original write value?
        je      @Exit                   ; Correct memory size is already set.
                                                              
        mov     esi,NV_PFB_CFG
        NV_DOS_GET      esi             ; Get Memory Config register
                                                     
        and     ah,0EFh                 ; Clear EXT_BANK to 1 bank
                                                                
        NV_DOS_PUT      esi             ; Set Memory Config register
@Exit:
*/    
    // check for RAM width as follows:
    //   1.  get what the HW thinks is the largest memory size supported
    //   2.  write test word to 1 byte beyond half the largest
    //   3.  write zero word to 16 bytes beyond half 
    //   4.  attempt to read the original test word
    //   5.  if successful, memory size is already correct;
    //       otherwise, adjust memory size
    testAddress = REG_RD32(NV_PFB_CSTATUS) / 2;
    FB_WR32(testAddress, 'NVDA');
    FB_WR32(testAddress + 0x10, 0x00000000);
    if (FB_RD32(testAddress) != 'NVDA')
    {
        FLD_WR_DRF_DEF(_PFB,_CFG,_EXTBANK,_0);
    }
    
	return rmStatus;

} // end of Nv10MemComputeMemory()


// end of nv10mem.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\nv\nv10mtbl.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*****************************************************************************
*
*	Header: nv10mtbl.c
*
*	Description:
*		This file contains the initialization code tables used to POST an NV10 device.
*   The init code was taken from the BIOS source file, nvinit.inc.
*
*	Revision History:
*		Original -- 6/99 Jeff Westerinen
*
*   Steps to convert all tables
*
*		1.	convert ; to //
*		2.  remove all db, dw, and dd, and add comma separaters
*		3.  convert IFDEF to #ifdef
*		4.	convert ELSE to #else
*		5.	convert ENDIF to #endif
*		6.	convert "OR \" and "OR " to "| "
*		7.	convert asm hex numbers to C hex numbers: ([0-9A-Fa-f]+)h\, to 0x\1\,
*       8.  convert asm binary numbers to C hex numbers
*		9.	format -- at least line up data to left indent
*		10. comment out all table delimiters
*
*   Steps to convert sequence tables from memcfg.asm
*
*		1.	convert SDR_Sequence_Table data to: U032 Nv10_SDR_Sequence_Table[] = { <data> }; 
*		2.	convert DDR_Sequence_Table data to: U032 Nv10_DDR_Sequence_Table[] = { <data> }; 
*
*   Steps to convert mem init table from memcfg.asm
*
*		1.	convert bmp_MemInitTbl data to: MEM_INIT_VALS Nv10_bmp_MemInitTbl[] = { <data> }; 
*       2.  remove MEM_INIT_VALS for each entry
*       3.  add defaults to elements 4, 10, and 14
*       4.  separate records with commas
*
*	Steps to convert bmp_GenInitTbl in nvinit.inc
*
*		1.	convert bmp_GenInitTbl data to: U032 Nv04_bmp_GenInitTbl[] = { <data> }; 
*		2.  remove bmp_ExtraInitTbl
*
******************************************************************************/

#include <nv10_ref.h>
#include <nvrm.h>
#include <bios.h>

U032 Nv10_SDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PRE,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_PRE,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
        
U032 Nv10_DDR_Sequence_Table[] = 
{
    NV_PFB_REFCTRL,
    NV_PFB_CFG,
    NV_PFB_TIMING0,
    NV_PFB_TIMING1,
    NV_PFB_TIMING2,
    NV_PBUS_DEBUG_CTRIM_4,
    NV_PFB_PIN,
    NV_PFB_PAD,
    NV_PFB_PRE,
    NV_PFB_EMRS,
    NV_PFB_MRS,
    NV_PFB_PRE,
    NV_PFB_REF,
    NV_PFB_REF,
    NV_PFB_MRS,
    NV_PFB_REFCTRL,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF,
    0xFFFFFFFF      // List terminator
};
   
MEM_INIT_TABLE_NV10 Nv10_bmp_MemInitTbl = 
{
    // Note - PFB_TIMING2: 61A = 100Mhz
    //                     91F = 150Mhz
    //                     **A2C = 166Mhz** old value
    //                     9FF = 166Mhz
    //                     B1F = 183Mhz
    //                       
    // 0000 = 64MBit x 32 SDR 166Mhz
    // Strap 0000 - 2M x 32 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 0001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 166MHz 
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 0010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 0011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 0100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 0101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 166Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 0110 =            
    // Strap 0110 - 8Mx16 SDR @ 100 Mhz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 0111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 166MHz
    {0, 16600, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x000009FF,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0111
                     
    // 1000 = 64MBit x 32 SDR 150Mhz
    // Strap 0000 - 2M x 32 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL,0xFFFFFFFF, 
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0000
    // 1001 =                                 
    // Strap 0001 - 4Mx16 SDR @ 150MHz 
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,    
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0001
    // 1010 =                                                       
    // Strap 0010 - 1Mx32 SDR @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0010
    // 1011 = 16MBit x 16 SDR 200Mhz
    // Strap 0011 - 16MBit x 16 SDR @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08B01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0011
    // 1100 =            
    // Strap 0100 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08A01110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0100
    // 1101 =            
    // Strap 0101 - 512Kx32(2-bank) SDR SGRAM @ 150Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x08911110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0101
    // 1110 =            
    // Strap 0110 - 8Mx16 SDR @ 150 Mhz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}},   // 0110
    // 1111 =            
    // Strap 0111 - 8M x 8 SDR SDRAM @ 150MHz
    {0, 15000, 12000,
                   { NV_PFB_REFCTRL_VALID_0, 0x09C11110, 
                     0x33070A0A, 0x02211150, 0x0000091F,
                     0x58761433, NV_PFB_PIN_CKE_NORMAL | NV_PFB_PIN_DQM_NORMAL, 0xFFFFFFFF,  
                     0x00000030, 0x00000030, NV_PFB_REFCTRL_VALID_1}}   // 0111
};
                         
U032 Nv10_bmp_GenInitTbl[] = 
{
#if 0
    //-----------------------------------------------------
    // Do a software reset here
    //-----------------------------------------------------
    INIT_RESET,                          // Sequence ID byte
    NV_PMC_ENABLE,                       // NV 32 bit address.
    // 
    // Off state
    NV_PMC_ENABLE_BUF_RESET_DISABLE | 
       NV_PMC_ENABLE_PMEDIA_DISABLED   | 
       NV_PMC_ENABLE_PFIFO_DISABLED    | 
       NV_PMC_ENABLE_PGRAPH_DISABLED   | 
       NV_PMC_ENABLE_PPMI_DISABLED     | 
       NV_PMC_ENABLE_PFB_DISABLED      | 
       NV_PMC_ENABLE_PCRTC_ENABLED     | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
                                  
    //
    // On state
    NV_PMC_ENABLE_BUF_RESET_DISABLE  | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    //-----------------------------------------------------
    // Configure the strap fields here
    //-----------------------------------------------------
    INIT_NV_REG,                          // Write with Mask
    NV_PEXTDEV_BOOT_0,                    // Strap Register Update
    // 
    //   +---------------------------------- OVERWRITE_ENABLED
    //   |++++++++++++++++------------------ UNUSED
    //   |||||||||||||||||+----------------- FB32MB
    //   ||||||||||||||||||++--------------- PCI_DEVID[1:0]
    //   ||||||||||||||||||||+-------------- RESERVED_11 (NV5)/AGP_FASTWR (NV10)
    //   |||||||||||||||||||||+------------- AGP_SBA_DISABLED
    //   ||||||||||||||||||||||+------------ AGP_4X_DISABLED
    //   |||||||||||||||||||||||++---------- TVMODE[1:0]
    //   |||||||||||||||||||||||||+--------- CRYSTAL_14318180
    //   ||||||||||||||||||||||||||++++----- RAMCFG[3:0]
    //   ||||||||||||||||||||||||||||||+---- SUB_VENDOR_BIOS              
    //   |||||||||||||||||||||||||||||||+--- PCI_AD_NORMAL
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //11111111111111111111011111111111b    // AND Mask      
    0xfffff7ff,    // AND Mask      
    //10000000000000000000000000000000b    // |  Mask - force write
    0x80000000,    // |  Mask - force write

    INIT_CONFIGURE_PREINIT,               // Read RAM type and Ref Freq
                                           // This also inits CR3C

    //-----------------------------------------------------
    // Make sure the NV10 fan is running
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x035,0x0FE,0x001,
                   
    //-----------------------------------------------------
    // Set Scratch4 to let the VESA interface know the fan is on
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03C,0x0F7,0x008,
                                              
    // Disable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_DISABLED       | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,
       
    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0FF,0x020,           // FullCPU Access On/CRTC Refresh off

    // Note: CRTC Refresh and the Framebuffer need to be disabled
    //       while programming NVCLK and MCLK
       
    INIT_PLL,
    NV_PRAMDAC_NVPLL_COEFF,              // Program default NVCLOCK
    10000,                               // 100Mhz   
                                              
    INIT_PLL,
    NV_PRAMDAC_MPLL_COEFF,               // Program default MCLOCK
    8300,                                // 83Mhz        
                                              
    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_0,                       
    0x03115223,                           // 05/26/99

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_1,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_2,                       
    0x000000000,
           
    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_CTRIM_3,                       
    0x0FF223003,

    //-----------------------------------------------------
    // Set per MK on 5/26/99
    //-----------------------------------------------------
    // INIT_ZM_REG                         // Write register
    // NV_PBUS_DEBUG_CTRIM_4               
    // 9CAB1433h                           // 05/26/99
    //
    // above now done in memcfg.asm
    //

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_5,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    //-----------------------------------------------------
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_CTRIM_6,                       
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask

    INIT_ZM_REG,                         // Write register
    NV_PRAMDAC_PLL_COEFF_SELECT,         // NV 32 bit address.
    0x00000500,                           // PROG_MPLL & PROG_NVPLL

    INIT_CONFIGURE_CLK,                  // Set MCLK/NVCLK

    // Enable Framebuffer
    INIT_ZM_REG,                         // Write register
    NV_PMC_ENABLE,                       // NV 32 bit address.
    NV_PMC_ENABLE_BUF_RESET_ENABLE   | 
       NV_PMC_ENABLE_PMEDIA_ENABLED     | 
       NV_PMC_ENABLE_PFIFO_ENABLED      | 
       NV_PMC_ENABLE_PGRAPH_DISABLED    | 
       NV_PMC_ENABLE_PPMI_ENABLED       | 
       NV_PMC_ENABLE_PFB_ENABLED        | 
       NV_PMC_ENABLE_PCRTC_ENABLED      | 
       NV_PMC_ENABLE_PVIDEO_DISABLED,

    //-----------------------------------------------------
    // Set the drive strengh register. The default AND/OR
    // mask causes the BIOS to initialize with the power
    // on default value.
    //-----------------------------------------------------
    INIT_NV_REG,                         // Write with Mask
    NV_PBUS_DEBUG_PRIV_ASRC,                      
    0x0FFFFFFFF,                          // AND Mask
    0x000000000,                          // | Mask
       
    //-----------------------------------------------------
    //-----------------------------------------------------

    // 8/25/99
    // Bit 7 (PCIS_RETRY is SPARE0, and has changed from 1 to 0 here)
    //
    INIT_ZM_REG,                         // Write register
    NV_PBUS_DEBUG_1,
    // 
    //   ++++++++++++++++------------------- SPARES
    //   ||||||||||||||||+------------------ AGPFW_DWOD_DISABLED
    //   |||||||||||||||||+----------------- FBI_DIFFERENTIAL_DISABLED
    //   ||||||||||||||||||+---------------- DPSH_DECODE_NV4
    //   |||||||||||||||||||+--------------- PCIS_CPUQ_ENABLED
    //   ||||||||||||||||||||+-------------- UNDEFINED
    //   |||||||||||||||||||||+------------- PCIS_EARLY_RTY_ENABLED
    //   ||||||||||||||||||||||+------------ PCIS_WR_BURST_ENABLED
    //   |||||||||||||||||||||||+----------- PCIS_RD_BURST_ENABLED
    //   ||||||||||||||||||||||||+---------- SPARE0_ZERO
    //   |||||||||||||||||||||||||+--------- PCIS_2_1_ENABLED
    //   ||||||||||||||||||||||||||+-------- PCIS_WRITE_0_CYCLE
    //   |||||||||||||||||||||||||||++------ AGPM_CMD_LP_ONLY
    //   |||||||||||||||||||||||||||||+----- HASH_DECODE_1FF
    //   ||||||||||||||||||||||||||||||+---- PCIM_CMD_SIZE_BASED
    //   |||||||||||||||||||||||||||||||+--- PCIM_THROTTLE_DISABLED
    //   VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV    
    //   3322222222221111111111
    //   10987654321098765432109876543210
    //00000000000000000101011101001000b,   // Write Value
    0x00005748,   // Write Value
                                   
    INIT_ZM_REG,                         // Write register
    NV_PFB_DEBUG_0,
    0,

    // New "Configure Memory" token
    INIT_CONFIGURE_MEM,                  // Configure the memory type

    INIT_COMPUTE_MEM,                    // Size the memory

    INIT_INDEX_IO,
    SEQ_INDEX,
    0x001,0x0DF,0x000,           // FullCPU Access Off

    //-----------------------------------------------------
    // Program VCLOCK
    //         
    // 13,500,000 MHz - VCLK = M:12:0C, N:064:40, P:2:02 LOG2P:1 36.00 MHz
    // 14,318,180 MHz - VCLK = M:14:0E, N:141:8D, P:4:04 LOG2P:2 36.05 MHz
    //-----------------------------------------------------
    INIT_PLL,
    NV_PRAMDAC_VPLL_COEFF,               // Program default VCLOCK
    3600,                                // 36Mhz   

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_2,
    0x000011F0,

    //-----------------------------------------------------
    // Set to NV5 values f| now
    //-----------------------------------------------------
    INIT_ZM_REG,
    NV_PBUS_DEBUG_3,
    NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ | NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES,

    //-----------------------------------------------------
    // Do CRTC IO default programming
    //-----------------------------------------------------
    //
    //-----------------------------------------------------
    // Force real mode window default state to off
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
	//NVRM_ACCESS,0x000,0x000,				// !! undefined
	NV_CIO_CRE_RMA__INDEX,0x000,0x000,

    //-----------------------------------------------------
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x01A,0x000,0x03F,
                   
    //-----------------------------------------------------
    // Boot with TV off, and set f| NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x028,0x000,0x000,

    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x033,0x000,0x000,         // Clear slave registers

    //-----------------------------------------------------
    // Force Lock register to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x021,0x000,0x0FA,         // Force Lock register to 0FAh

    //-----------------------------------------------------
    // Clear scratch registers - TV Selection
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02B,0x000,0x000,         // Clear all scratch bits f| default
                                        
    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x02C,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // Clear scratch registers to default state
    //-----------------------------------------------------
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03A,0x000,0x000,         // Clear all scratch bits f| default
    
    INIT_INDEX_IO,
    CRTC_INDEX_COLOR,
    0x03B,0x000,0x000,         // Clear all scratch bits f| default

    //-----------------------------------------------------
    // End of the list
    //-----------------------------------------------------
    INIT_DONE
    
#else

    // This data was extracted directly from a GeForce reference card.
    // It differs from the translated source code above and is the only
    // version between the two that actually works.  If necessary, we
    // must either create a development path from the actual BIOS source
    // code or create a tool that extracts the tables from a BIOS binary.
    0x00000065, 0x00000200, 0x01000000, 0x01110110,
    0x0000006e, 0x00101000, 0xfffff7ff, 0x80000000,
    0x00000068, 0x00000078, 0x000003d4, 0x00000035,
    0x000000fe, 0x00000001, 0x00000078, 0x000003d4,
    0x0000003a, 0x00000000, 0x00000001, 0x0000007a,
    0x00000200, 0x01010111, 0x00000078, 0x000003c4,
    0x00000001, 0x000000ff, 0x00000020, 0x00000079,
    0x00680500, 0x00002710, 0x00000079, 0x00680504,

    0x0000206c, 0x0000007a, 0x000010b0, 0x03115223,
    0x0000006e, 0x000010b4, 0xffffffff, 0x00000000,
    0x0000007a, 0x000010b8, 0x00000000, 0x0000007a,
    0x000010bc, 0xff223003, 0x0000006e, 0x000010c8,
    0xffffffff, 0x00000000, 0x0000006e, 0x000010cc,
    0xffffffff, 0x00000000, 0x0000007a, 0x0068050c,
    0x00000500, 0x00000067, 0x0000007a, 0x00000200,
    0x01110111, 0x0000006e, 0x000010e0, 0xffffffff,

    0x00000000, 0x0000007a, 0x00001084, 0x00005748,
    0x0000007a, 0x00100080, 0x00000000, 0x00000066,
    0x00000063, 0x00000078, 0x000003c4, 0x00000001,
    0x000000df, 0x00000000, 0x00000079, 0x00680508,
    0x00000e10, 0x0000007a, 0x00001088, 0x000011f0,
    0x0000007a, 0x0000108c, 0x000000d1, 0x00000078,
    0x000003d4, 0x00000038, 0x00000000, 0x00000000,
    0x00000078, 0x000003d4, 0x0000001a, 0x00000000,

    0x0000003f, 0x00000078, 0x000003d4, 0x00000028,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x00000033, 0x00000000, 0x00000000, 0x00000078,
    0x000003d4, 0x00000021, 0x00000000, 0x000000fa,
    0x00000078, 0x000003d4, 0x0000002b, 0x00000000,
    0x00000000, 0x00000078, 0x000003d4, 0x0000002c,
    0x00000000, 0x00000000, 0x00000078, 0x000003d4,
    0x0000003b, 0x00000000, 0x00000000, 0x00000071

#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\dmastate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************************* DMA Manager *******************************\
*                                                                           *
* Module: DMASTATE.C                                                        *
*   The DMA state is managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Initialize DMA hardware.
//
RM_STATUS stateDma
(
    PHWINFO pDev,
    U032    msg
)
{
#ifdef KJK
    PDMAOBJECT DmaObject;
#endif
#ifdef LEGACY_ARCH
    RM_STATUS  status;
#endif
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:

#ifdef LEGACY_ARCH
            //
            // Fill class-specific NULL DMA instances with something invalid
            //
            if (!pDev->Dma.DmaInMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaInMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_IN_MEMORY);
//                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaInMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaToMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaToMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_TO_MEMORY);
//                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaToMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
            if (!pDev->Dma.DmaFromMemEmptyInstance)
            {            
                status = fbAllocInstMem(pDev, &(pDev->Dma.DmaFromMemEmptyInstance), 1);
                if (status == RM_OK)
                {
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV1_CONTEXT_DMA_FROM_MEMORY);
//                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT),  0);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_CLASS), NV01_NULL);
                    INST_WR32(pDev->Dma.DmaFromMemEmptyInstance, SF_OFFSET(NV_DMA_LIMIT), 0xFFFFFFFF);
                }
            }                
#endif // LEGACY_ARCH

#ifdef KJK            
            //
            // Reload any DMA instances.
            //
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                DBG_VAL_PTR(DmaObject);
                //
                // Load instance.
                //    
                if (DmaObject->State & DMA_RELOAD)
                {
                    //
                    // Get DMA instance for page table mapping.
                    //
                    if (dmaAllocInstance(DmaObject))
                    {
                        DmaObject->Valid = FALSE;
                        osUnlockUserMem(DmaObject->Base.ChID,
                                        DmaObject->BufferBase,
                                        DmaObject->DescAddr,
                                        DmaObject->AddressSpace,
                                        DmaObject->DescLimit,
                                        DmaObject->PteCount,
                                        DmaObject->LockHandle,
                                        DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY ? TRUE : FALSE);
                        osFreeMem(DmaObject->PteArray);
                        DmaObject->PteArray = NULL;
                    }
                    DmaObject->State &= ~DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }
#endif //KJK
            break;
        case STATE_UNLOAD:
            //
            // Unload all DMA instances.
            //
#ifdef KJK            
            DmaObject = pDev->DBDmaList;
            while (DmaObject)
            {
                //
                // Unload instance.
                //    
                DBG_VAL_PTR(DmaObject);
                if (DmaObject->PteArray)
                {
                    dmaFreeInstance(pDev, DmaObject);
                    DmaObject->State |= DMA_RELOAD;
                }
                DmaObject = DmaObject->Next;
            }

            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif //KJK
            break;
        case STATE_INIT:
            pDev->DBDmaList = NULL;

#ifdef LEGACY_ARCH    
            pDev->Dma.DmaInMemEmptyInstance = 0;
            pDev->Dma.DmaToMemEmptyInstance = 0;
            pDev->Dma.DmaFromMemEmptyInstance = 0;
#endif // LEGACY_ARCH
            
            break;
        case STATE_DESTROY:
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\notify.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: NOTIFY.C                                                          *
*   Method notifications are handled in this module.  DMA report and OS     *
*   action are dealt with on a per-object basis.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Method notifications.
//
RM_STATUS mthdSetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    
    if (Object->NotifyTrigger)
        return (RM_ERR_DMA_IN_USE);
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (Object->NotifyXlate)
    {
        dmaEndXfer(Object->NotifyXlate, NULL);
        dmaDetach(Object->NotifyXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(Object->NotifyXlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaAttach(Object->NotifyXlate);
    if (status)
    {
        osError(Object, Offset, Data, status);
        Object->NotifyXlate   = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(Object->NotifyXlate, 0, 0x000F);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(Object->NotifyXlate, NULL);
    if (status)
    {
        Object->NotifyXlate   = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    Object->NotifyAction  = Data;
    Object->NotifyTrigger = TRUE;
    return (RM_OK);
}
//
// Dual buffer notifications.
//
RM_STATUS mthdSetBufferNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotifyCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}
RM_STATUS notifySetBufferNotifyCtxDma
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (pBuffer->NotifyXlate)
        dmaDetach(pBuffer->NotifyXlate);
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &(pBuffer->NotifyXlate));
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(pBuffer->NotifyXlate);
    if (status)
    {
        pBuffer->NotifyXlate = NULL;
        return (status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(notifySetBufferNotify(pDev, BuffObject, BuffNum, Offset, Data));
}
RM_STATUS notifySetBufferNotify
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    U032          Offset,
    U032          Data
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    //
    // Check for busy buffer.
    //
    if (pBuffer->State == BUFFER_BUSY)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
    pBuffer->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate(pBuffer->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->NotifyXlate, NULL);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Validate buffer parameters.
    //    
    status = dmaValidateXlate(pBuffer->Xlate,
                              pBuffer->Start,
                              pBuffer->Length);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        //KJK dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(pBuffer->Xlate, NULL);
    if (status)
    {
        notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, 0, status);
        dmaEndXfer(pBuffer->NotifyXlate, NULL);
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent((POBJECT)BuffObject,
            			  0,
                          Offset,
                          BuffObject->Base.Name,
                          status,
                          pBuffer->NotifyAction);
        }
        return (status);
    }
	*/
    //
    // Call the object specific routine to begin the transfer.
    //
    BuffObject->BufferComplete                     = notifyBufferComplete;
    pBuffer->State                                 = BUFFER_BUSY;
    pBuffer->NotifyCurrentCount                    = pBuffer->NotifyCount;
    if (pBuffer->Length == 0)
    {
        pBuffer->NotifyCurrentCount = 0;
        notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, RM_OK);
    }
    else
    {
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
            notifyBufferComplete(pDev, BuffObject, BuffNum, BuffObject->Base.Name, status);
    }
    return (status);
}
RM_STATUS mthdSetBufferNotifyCount
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    //
    // Update the count even if buffer is busy.
    //
    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    BuffObject->Buffer[BuffNum].NotifyCount        = Data;
    BuffObject->Buffer[BuffNum].NotifyCurrentCount = Data;
    return (RM_OK);
}
RM_STATUS mthdSetBufferPosNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    //
    // Check for previous dma buffer.
    //
	/* KJK
    if (BuffObject->Buffer[BuffNum].PosXlate)
    {
        dmaEndXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
        dmaDetach(BuffObject->Buffer[BuffNum].PosXlate);
    }
	*/

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(BuffObject->Buffer[BuffNum].PosXlate));
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	/* KJK
    status = dmaAttach(BuffObject->Buffer[BuffNum].PosXlate);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        return (status);
    }
	*/
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(BuffObject->Buffer[BuffNum].PosXlate, 0, 0x000F);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(BuffObject->Buffer[BuffNum].PosXlate, NULL);
    if (status)
    {
        BuffObject->Buffer[BuffNum].PosXlate = NULL;
        osError(Object, Offset, Data, status);
    }
	*/
    return (status);
}
RM_STATUS mthdSetBufferPosNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;
    U032          Position;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
    status     = BuffObject->BufferPos(pDev, BuffObject, BuffNum, &Position);
    if (status)
        return (status);
    notifyFillNotifier(pDev, BuffObject->Buffer[BuffNum].PosXlate, Position, 0, 0);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Notification completion.
//
//---------------------------------------------------------------------------

RM_STATUS notifyDefaultError
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      ChID,
    RM_STATUS CompletionStatus
)
{
    V032       ObjectName;
    PDMAOBJECT ErrNotifier;
    
    //
    // Check for error.
    //
    if (CompletionStatus & 0xFFFF)
    {
        //
        // Fill NV_ERROR_NOTIFIER if defined.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: method error ", CompletionStatus);
        if (Object)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            object ", (U032)Object->Name);
            ObjectName = Object->Name;
        }
        else    
        {
            DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "            object NULL");
            ObjectName = 0;
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "            offset ", Offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              data ", Data);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              chID ", ChID);
        if (fifoSearchObject(pDev, NV_CONTEXT_ERROR_TO_MEMORY, ChID, (POBJECT *)&ErrNotifier) == RM_OK)
        {
            if (ErrNotifier->Valid)
            {
                if (!dmaValidateXlate(ErrNotifier, 0, 0x000F))
                {
                    //KJK dmaAttach(ErrNotifier);
                    //KJK dmaBeginXfer(ErrNotifier, NULL);
                    notifyFillNotifier(pDev, ErrNotifier, ObjectName, (V016)Offset, CompletionStatus);
					/* KJK
                    dmaEndXfer(ErrNotifier, NULL);
                    dmaDetach(ErrNotifier);
					*/
                }
            }
        }
        //
        // Do any OS specific action.
        //
        if (Object)
            osError(Object, Offset, Data, CompletionStatus);
        else    
            osError(Object, Offset, ChID, CompletionStatus);
    }
    return (RM_OK);
}
RM_STATUS notifyMethodComplete
(
	PHWINFO	  pDev,
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    RM_STATUS CompletionStatus
)
{
    if ((Offset == 0x100) || (Offset >= 0x0200))
    {
        if (Object->NotifyTrigger)
        {
            Object->NotifyTrigger = FALSE;
            if (Object->NotifyXlate)
                notifyFillNotifier(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus);
            //
            // Do any OS specified action related to this notification.
            //
            if (Object->NotifyAction)
                osNotifyEvent(pDev, Object, 0, Offset, Data, CompletionStatus, Object->NotifyAction);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyBufferHWComplete
(
	PHWINFO	  pDev, 
    POBJECT   Object,
    U032      Offset,
    V032      Data,
    U032      Buffer,    
    RM_STATUS CompletionStatus
)
{
    if (Offset >= 0x0200)
    {
        if (Object->NotifyTrigger)
        {
            Object->NotifyTrigger = FALSE;
            if (Object->NotifyXlate)
                notifyFillNotifierArray(pDev, Object->NotifyXlate, Object->Name, (V016)Offset, CompletionStatus, Buffer);
            //
            // Do any OS specified action related to this notification.
            //
            if (Object->NotifyAction)
                osNotifyEvent(pDev, Object, Buffer, Offset, Data, CompletionStatus, Object->NotifyAction);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyBufferComplete
(
	PHWINFO       pDev,
    PBUFFEROBJECT BuffObject,
    U032          BuffNum,
    V032          OtherInfo,
    RM_STATUS     CompletionStatus
)
{
    RM_STATUS status;
    PBUFFER   pBuffer = &BuffObject->Buffer[BuffNum];

    if ((OtherInfo == NOTIFY_INFO16_BUFFER_YANK)
    ||  (pBuffer->NotifyCurrentCount == 0))
    {
        //
        // Complete buffer with any notify action requested.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate, 0, (V016)OtherInfo, CompletionStatus);
        pBuffer->State = BUFFER_IDLE;
        //
        // Do any OS specified action related to this notification.
        //
        if (pBuffer->NotifyAction)
        {
            osNotifyEvent(pDev,
                          (POBJECT)BuffObject,
            			  0,
                          pBuffer->NotifyMethod,
                          BuffObject->Base.Name,
                          CompletionStatus,
                          pBuffer->NotifyAction);
        }
    }
    else
    {
        //
        // Auto notify buffer again.
        //
        if (pBuffer->NotifyXlate)
            notifyFillNotifier(pDev, pBuffer->NotifyXlate,
                               pBuffer->NotifyCurrentCount,
                               NOTIFY_INFO16_BUFFER_LOOP,
                               CompletionStatus);
        if (pBuffer->NotifyCount != 0xFFFFFFFF)
            pBuffer->NotifyCurrentCount--;
        status = BuffObject->BufferXfer(pDev, BuffObject, BuffNum);
        if (status)
        {
            //
            // Stop looping and return error.
            //
            pBuffer->NotifyCurrentCount = 0;
            notifyBufferComplete(pDev, BuffObject, BuffNum, OtherInfo, status);
        }
    }
    return (RM_OK);
}
RM_STATUS notifyFillNotifier
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, 0, 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}

RM_STATUS notifyFillNotifierArray
(
	PHWINFO	   pDev,
    PDMAOBJECT NotifyXlate,
    V032       Info32,
    V016       Info16,
    RM_STATUS  CompletionStatus,
    U032       Index
)
{
    RM_STATUS     status;
    PNOTIFICATION NotifyBuffer;

    //
    // Fill in the notification structure.
    //
    status = dmaGetMappedAddress(pDev, NotifyXlate, (Index*0x10), 0x000F, (VOID **)&(NotifyBuffer));
    if (status)
        return (status);
    NotifyBuffer->OtherInfo32 = Info32;
    NotifyBuffer->OtherInfo16 = Info16;
    tmrGetCurrentTime(pDev, &NotifyBuffer->TimeHi, &NotifyBuffer->TimeLo);
    NotifyBuffer->Status = (V016)CompletionStatus;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\devinit\portable\nv_portable.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 /***************************************************************************\
|*                                 Typedefs                                  *|
 \***************************************************************************/

typedef unsigned char      NvV8;  /* "void": enumerated or multiple fields   */
typedef unsigned short     NvV16; /* "void": enumerated or multiple fields   */
typedef unsigned long      NvV32; /* "void": enumerated or multiple fields   */
typedef unsigned char      NvU8;  /* 0 to 255                                */
typedef unsigned short     NvU16; /* 0 to 65535                              */
typedef unsigned long      NvU32; /* 0 to 4294967295                         */
typedef signed char        NvS8;  /* -128 to 127                             */
typedef signed short       NvS16; /* -32768 to 32767                         */
typedef signed long        NvS32; /* -2147483648 to 2147483647               */
typedef float              NvF32; /* IEEE Single Precision (S1E8M23)         */
typedef double             NvF64; /* IEEE Double Precision (S1E11M52)        */


typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;



#define NULL 0

#define FALSE 0
#define TRUE  1


//
// Internal codes.
//

typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)

// Errors returned from the arch calls.
#define NV_ERROR_2                      0x0200
#define RM_ERR_OPERATING_SYSTEM         (0x00000001|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_PARENT        (0x00000002|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_HANDLE       	(0x00000003|NV_ERROR_2)
#define RM_ERR_OBJECT_IN_USE            (0x00000004|NV_ERROR_2)
#define RM_ERR_OBJECT_HAS_CHILDERN      (0x00000005|NV_ERROR_2)
#define RM_ERR_BAD_CLASS                (0x00000006|NV_ERROR_2)
#define RM_ERR_INSUFFICIENT_RESOURCES   (0x00000007|NV_ERROR_2)
#define RM_ERR_BAD_FLAGS                (0x00000008|NV_ERROR_2)
#define RM_ERR_BAD_BASE                 (0x00000009|NV_ERROR_2)
#define RM_ERR_BAD_LIMIT                (0x0000000A|NV_ERROR_2)
#define RM_ERR_PROTECTION_FAULT         (0x0000000B|NV_ERROR_2)
#define RM_ERR_MULTIPLE_MEMORY_TYPES    (0x0000000C|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_ERROR         (0x0000000D|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_BUFFER        (0x0000000E|NV_ERROR_2)
#define RM_ERR_BAD_OFFSET               (0x0000000F|NV_ERROR_2)


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))


// #include <nv_local.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv20\dmanv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv20.c                                                         *
*   The NV20 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV20(VOID *);
RM_STATUS nvHalDmaAlloc_NV20(VOID *);
RM_STATUS nvHalDmaFree_NV20(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV20(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV20(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV20(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
#ifdef IKOS
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: AGP on IKOS!!!!\n");
            DBG_BREAKPOINT();
#endif
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // Workaround a bug in the HOST's semaphore context dma checks.
    // It only accepts the SetContextDmaSemaphore method if the
    // ctxdma is marked COHERENCY_CACHED (even though the underlying
    // memory is NODE_NVM).  Since no other engine checks the
    // coherency flags (yet), this should be OK for now.
    //
    adjust |= SF_DEF(_DMA, _FLAGS_MAPPING_COHERENCY, _CACHED);

    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV20(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV20(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV20(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv\dma.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************************* DMA Manager *****************************\
*                                                                           *
* Module: DMA.C                                                             *
*   The DMA engine is managed in this module.  All priviledged state and    *
*   object interaction is handled here.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>   
#include <fb.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

RM_STATUS dmaCreate
(
    VOID*               pDevHandle,
    PCLASSOBJECT        ClassObject,
    U032                UserName,
    POBJECT             *NewObject,
    VOID*               pCreateParms
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status = RM_OK;
    PDMAOBJECT  DmaObject;

    status = osAllocMem((VOID **)&DmaObject, sizeof(DMAOBJECT));
    if (status)
        return (status);
    DmaObject->State      = 0;
    DmaObject->Valid      = FALSE;
    DmaObject->LockHandle = 0;

    //
    // Initialize HAL info data.
    //
    DmaObject->HalInfo.PteArray     = NULL;
    DmaObject->HalInfo.Instance     = NULL;
    DmaObject->HalInfo.classNum     = ClassObject->Base.ThisClass->Type;
    DmaObject->HalInfo.MemoryClass  = 0;
    DmaObject->HalInfo.Flags        = 0;

    //
    // Add to dma context table.
    //
    DmaObject->Next       = pDev->DBDmaList;
    pDev->DBDmaList       = DmaObject;
    *NewObject            = (POBJECT)DmaObject;
    
#ifdef RM20
    //
    // Initialize the DMA object's client handle
    //
    CliGetClientHandle(&DmaObject->ClientHandle);
#endif    
    //
    // Get the address space associated with this DMA object
    //
    // Assume this is a system memory context first.  We may
    // reassign it later when we're looking at the physical
    // page locations.
    //
    DmaObject->HalInfo.AddressSpace = ADDR_SYSMEM;
    
#ifdef LEGACY_ARCH    
    //
    // Since we're about to put this new (unallocated) dma context
    // in the hash table, we need to point it at some PTE.  Point it
    // at an empty one so if anyone attempts to use this context
    // before its allocated, we'll get an error.  The PTE will be
    // exchanged with a valid entry once the dma context gets
    // allocated (locked).
    //
    // This step will disappear once we have the all-in-one
    // NvAllocDma() routine.
    //
    switch (ClassObject->Base.ThisClass->Type)  //KJK
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif // LEGACY_ARCH
        
    DmaObject->Base.Name  = UserName;
    DmaObject->Base.ChID  = ClassObject->Base.ChID;
    
#ifdef LEGACY_ARCH    
    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &DmaObject->Base, 
                                      DmaObject->Base.ChID, 
                                      DmaObject->HalInfo.Instance);

    if (status)
        return (status);                               
#endif
    
    return (status);
    
}
//
// Delete NV_CONTEXT_DMA_??_MEMORY object.
//
RM_STATUS dmaDelete
(
    VOID*   pDevHandle,
    POBJECT DelObject
)
{
    PHWINFO     pDev = (PHWINFO) pDevHandle;
    RM_STATUS   status;
    PDMAOBJECT  DmaObject;
    PDMAOBJECT  DmaDelete;
    
    DmaObject = (PDMAOBJECT)DelObject;
    status = RM_OK;
    
#ifdef LEGACY_ARCH
    //
    // If there are objects that are currently using this context, we are not allowed
    // to remove the dma context from the chip (hash).  We can unlock it (leaving it 
    // at a NULL PTE), but we can't just yank the whole thing.
    //
    // We probably need to scan all of instance memory and all on-chip context caches
    // and clear out any usage of this object.
    //
    // KJK How do we handle this correctly????  For now, just yank it.
    //
    status = fifoDeleteObjectInstance(pDev, DelObject, DelObject->ChID);
    if (status)
        return (status);
#endif        
    //
    // NOTE: In the new architecture, it is assumed that this object has 
    //       been removed from the hash table (if necessary).
    
    //
    // Are we locked somewhere?
    //
    if (DmaObject->Valid)
    {
        //
        // Free all memory allocated to this object.
        //
        if (DmaObject->HalInfo.PteArray)
        {
            //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA buffer resoures still allocated at delete time!\n\r");
            //DBG_BREAKPOINT();
            dmaFreeInstance(pDev, DmaObject);
            osUnlockUserMem(
						    pDev,
						    DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.PteArray = NULL;
        }
        if (pDev->DBDmaList == NULL)        
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA list NULL in DMADELETE!\n\n");
            DBG_BREAKPOINT();
        }

        //
        // Detach from DMA list.
        //
        if (pDev->DBDmaList == DmaObject)
            pDev->DBDmaList = DmaObject->Next;
        else
        {
            DmaDelete = pDev->DBDmaList;
            while (DmaDelete->Next && DmaDelete->Next != DmaObject)
            {
                DBG_VAL_PTR(DmaDelete);
                DmaDelete = DmaDelete->Next;
            }
            if (DmaDelete->Next)
                DmaDelete->Next = DmaObject->Next;
        }    
        status = osFreeMem(DmaObject);
    }
    
    return (status);
}

//
// Find a specific DMA object based upon its instance
//
RM_STATUS dmaContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    PDMAOBJECT *DmaObject
)
{
    PDMAOBJECT TempDmaList;
    U032 hClient;
    RM_STATUS status;
    
    //
    // Are there any dma objects available?
    //
    if (!pDev->DBDmaList)
    {    
        *DmaObject = NULL;    
        return (RM_ERR_BAD_OBJECT);
    }        
        
#ifdef RM20  
    // First we must establish a client via the Channel ID.
    status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
    if (status)
    {
        *DmaObject = NULL;    
        return (status);
    }
      
    //
    // Walk the list looking for this object by matching the client and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->ClientHandle == hClient) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#else
    //
    // Walk the list looking for this object by matching the channel and the instance
    //
    TempDmaList = pDev->DBDmaList;
    while (TempDmaList)        
    {
        if ((TempDmaList->Base.ChID == ChID) && (TempDmaList->HalInfo.Instance == Instance))
        {
            //
            // Found it!
            //
            *DmaObject = TempDmaList;
            return (RM_OK);
        }
        TempDmaList = TempDmaList->Next;
    }
#endif
    *DmaObject = NULL;    
    return (RM_ERR_BAD_OBJECT);        
}

//
// Validate DMA object name.
//
RM_STATUS dmaValidateObjectName
(
    PHWINFO     pDev,
    V032        ObjectName,
    U032        ChID,
    PDMAOBJECT *DmaObject
)
{
    U032 hClient;
    RM_STATUS status;

    //
    // Check for NULL object.
    //
    if (ObjectName == NV1_NULL_OBJECT)
    {
        *DmaObject = NULL;
        return (RM_WARN_NULL_OBJECT);
    }
    status = fifoSearchObject(pDev, ObjectName, ChID, (POBJECT *)DmaObject);
    if (status)
    {
#ifdef RM20
        // attempt to find the object in the global DMA list
        // the client handle is also needed for this lookup
        status = CliGetClientHandleFromChID(pDev, ChID, &hClient);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        status = dmaFindContext(pDev, ObjectName, hClient, DmaObject);
        if (status)
        {
            *DmaObject = NULL;
            return (status);
        }
        
#ifdef LEGACY_ARCH
        // CWJ: DMA objects don't exist in the FIFO tree with the new arch.
        // add the DMA context to the FIFO's object tree if it is unused
        if ((*DmaObject)->Base.ChID == INVALID_CHID)
        {
            (*DmaObject)->Base.ChID = ChID;
            status = fifoAddObject(pDev, (POBJECT)*DmaObject);
            if (status)
            {
                return (status);
            }
        }
        else
        {
            // return RM_ERR_BAD_DMA_SPECIFIER;
        }
#endif
#else
        // not finding the object in the tree is an error
        *DmaObject = NULL;
        return (status);
#endif // RM20
    }
    if (((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  ((*DmaObject)->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
        return (RM_ERR_OBJECT_TYPE_MISMATCH);
    return (RM_OK);
}

#ifdef RM20
// find a DMA context in the list
RM_STATUS dmaFindContext(PHWINFO pDev, U032 id, U032 hClient, PDMAOBJECT *ppDmaObject)
{
    for (*ppDmaObject = pDev->DBDmaList; *ppDmaObject; *ppDmaObject = (*ppDmaObject)->Next)
        if (((*ppDmaObject)->Base.Name == id) &&
                ((*ppDmaObject)->ClientHandle == hClient))
            break;

    return (*ppDmaObject) ? RM_OK : 1;

} // end of dmaFindContext()
#endif // RM20

RM_STATUS dmaValidateXlate
(
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length
)
{
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
#if DEBUG
    if ((DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV1_CONTEXT_DMA_IN_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_TO_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_FROM_MEMORY)
    &&  (DmaObject->Base.Class->Type != NV_CONTEXT_DMA_IN_MEMORY))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Bad type in dmaValidateXlate\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
#endif // DEBUG
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    if ((Start + Length - 1) > DmaObject->DescLimit)
        return (RM_ERR_INVALID_START_LENGTH);
    return (RM_OK);
}

//
// Allocate and lock memory associated with this DMA object
//
RM_STATUS dmaAllocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA Allocate\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Make sure its valid.
    //
    if (!DmaObject->Valid)
        return (RM_ERR_INVALID_XLATE);
    //
    // Get memory translation.
    //
    if (!DmaObject->HalInfo.PteArray)
    {
        //
        // Save off class of this dma context object.
        //
        DmaObject->HalInfo.classNum      = DmaObject->Base.ThisClass->Type;

        //
        // These members are for future use to make sure we pass
        // any hardware error checking involving new context dma
        // class parameters.
        // 
        DmaObject->HalInfo.Flags      = 0;
        DmaObject->HalInfo.MemoryClass = 0;

        //
        // Calculate page table values.
        //    
        DmaObject->HalInfo.BufferSize = DmaObject->DescLimit  + 1;
        osCalculatePteAdjust(pDev, DmaObject->HalInfo.AddressSpace, DmaObject->DescAddr, &DmaObject->HalInfo.PteAdjust);
        DmaObject->HalInfo.PteLimit   = DmaObject->DescLimit; //DmaObject->BufferSize + DmaObject->PteAdjust;
        DmaObject->HalInfo.PteCount   =
            (DmaObject->HalInfo.PteLimit + DmaObject->HalInfo.PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        status = osAllocMem((VOID **)&(DmaObject->HalInfo.PteArray), DmaObject->HalInfo.PteCount * 4);
        if (status)
        {
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_NO_FREE_MEM);
        }

        //
        // Lock and map DMA buffer.
        //    
        if (osLockUserMem(
						  pDev,
						  DmaObject->Base.ChID,
                          DmaObject->DescSelector,
                          DmaObject->DescOffset,
                          DmaObject->DescAddr,
                          &(DmaObject->HalInfo.AddressSpace),
                          DmaObject->DescLimit,
                          DmaObject->HalInfo.PteCount,
                          DmaObject->HalInfo.PteArray,
                          (VOID**)&(DmaObject->HalInfo.BufferBase),
                          &(DmaObject->LockHandle)) != RM_OK)
        {
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_DMA_MEM_NOT_LOCKED);
        }
        //
        // Get DMA instance for page table mapping.
        //
        status = dmaAllocInstance(pDev, DmaObject);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (status);
        }

        //
        // Call into HAL to handle h/w-dependent initialization.
        //
        status = nvHalDmaAlloc(pDev, &DmaObject->HalInfo);
        if (status)
        {
            DmaObject->Valid = FALSE;
            osUnlockUserMem(
							pDev,
							DmaObject->Base.ChID,
                            (VOID*)DmaObject->HalInfo.BufferBase,
                            DmaObject->DescAddr,
                            DmaObject->HalInfo.AddressSpace,
                            DmaObject->DescLimit,
                            DmaObject->HalInfo.PteCount,
                            DmaObject->LockHandle,
                            (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                            (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
            osFreeMem(DmaObject->HalInfo.PteArray);
            DmaObject->HalInfo.BufferBase = NULL;
            DmaObject->HalInfo.PteArray   = NULL;
            return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
        }
    }

    return (RM_OK);
}

RM_STATUS dmaDeallocate
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    PNODE             node;
    U032              ChID;
    U032              Instance;
    U032              EngTag;

    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Dma Dealloc\n\r");

    DBG_VAL_PTR(DmaObject);
    //
    // Check for resources to free up.
    //
    if (DmaObject->HalInfo.PteArray)
    {
        //
        // If there are objects that are currently using this context, we cannot allow any
        // modifications!!
        //
        for (ChID = 0 ; ChID < NUM_FIFOS ; ChID++)
        {
            if (pDev->DBfifoTable[ChID].InUse)
            {

                // 
                // Go find the minimum value (>0) and start there.  That way we're
                // sure to visit every node.
                //
                btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

                while (node != NULL)
                {
                    //
                    // If this is a hardware object
                    //
                    EngTag = ENGDECL_FIELD(*((POBJECT)(node->Data))->Class->EngineDecl, _TAG);
                    if (EngTag == GR_ENGINE_TAG)
                    {
                        //
                        // Find the dma context field in this object's context instance
                        //
                        Instance = ((PCOMMONOBJECT)(node->Data))->Instance;
                        
                        //
                        // If it is currently being used by any object, don't allow
                        // any adjustments
                        //
                        if (Instance)
                        {
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_1, _NOTIFY_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_0_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                            if (RAM_RD_ISF(Instance, _PRAMIN_CTX_2, _DMA_1_INSTANCE) == DmaObject->HalInfo.Instance)
                                return(NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
                        }                            

                    }

                    btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
                }
            }
        }

        //
        // Now free the DMA object
        //
        dmaFreeInstance(pDev, DmaObject);
        osUnlockUserMem(
						pDev,
						DmaObject->Base.ChID,
                        (VOID*)DmaObject->HalInfo.BufferBase,
                        DmaObject->DescAddr,
                        DmaObject->HalInfo.AddressSpace,
                        DmaObject->DescLimit,
                        DmaObject->HalInfo.PteCount,
                        DmaObject->LockHandle,
                        (DmaObject->Base.Class->Type == NV1_CONTEXT_DMA_TO_MEMORY) ||
                        (DmaObject->Base.Class->Type == NV_CONTEXT_DMA_TO_MEMORY) ? TRUE : FALSE);
        osFreeMem(DmaObject->HalInfo.PteArray);
        DmaObject->HalInfo.BufferBase = NULL;
        DmaObject->HalInfo.PteArray   = NULL;
    }
    
#ifdef LEGACY_ARCH
    //
    // Point back to the NULL PTE
    //
    switch (DmaObject->Base.Class->Type)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaToMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaFromMemEmptyInstance;
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            DmaObject->HalInfo.Instance = pDev->Dma.DmaInMemEmptyInstance;
            break;
    }            
#endif LEGACY_ARCH
    

    return (RM_OK);
}

//
// Return the mapped address of a DMA buffer.
// We need to special case an ADDR_FBMEM mapping, since RmAllocContextDma converted
// the BufferBase field to an FB offset. So to return the correct mapping, we use our
// RM mapping to the FB memory.
//
RM_STATUS dmaGetMappedAddress
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject,
    U032       Start,
    U032       Length,
    VOID     **Address
)
{
    RM_STATUS status;

    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaGetMappedAddress\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    DBG_VAL_PTR(DmaObject);
    status = dmaValidateXlate(DmaObject, Start, Length);
    if (status)
        return (status);
    if (!DmaObject->HalInfo.PteArray ||
        (!DmaObject->HalInfo.BufferBase && DmaObject->HalInfo.AddressSpace != ADDR_FBMEM))
        return (RM_ERR_DMA_MEM_NOT_LOCKED);
	if (DmaObject->HalInfo.AddressSpace == ADDR_FBMEM)
        *Address = (U008*)fbAddr + (SIZE_PTR)DmaObject->HalInfo.BufferBase + Start;      // BufferBase is an FB offset
    else
	    *Address = (U008*)DmaObject->HalInfo.BufferBase + Start;
    return (RM_OK);
}

//
// Allocate a DMA instance in offscreen memory.  This involves locking
// the physical pages in memory, getting the translation table, and
// adding the object to the instance list.
//
RM_STATUS dmaAllocInstance
(
    PHWINFO pDev,
    PDMAOBJECT DmaObject
)
{
    RM_STATUS    status;

    DBG_VAL_PTR(DmaObject);
    //
    // Only alloc valid buffers.
    //    
    if ((DmaObject == NULL) || (!DmaObject->Valid))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid DMA context in dmaAllocInstance\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_INVALID_XLATE);
    }
    //
    // Allocate some instance memory.  Allocate an extra PTE so when the 
    // DMA engine prefetches, it won't fault on a last access to a page.
    //
    //
    status = nvHalDmaGetInstSize(pDev, &DmaObject->HalInfo);
    if (status)
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    status = fbAllocInstMem(pDev, &(DmaObject->HalInfo.Instance), DmaObject->HalInfo.NumUnits);
    if (status)
        return (status);
    
    //
    // Is this supposed to be a real AGP context?  We need to verify the addresses
    // fall within the GART space that DirectDraw has already told us about.  If not,
    // we must assume this is normal PCI memory and treat it as such.
    //
    // This check is not for the NV-specific AGP implementation.  That approach
    // uses our own GART.
    //
    // NOTE: This isn't needed anymore now that osGetAddressInfo does its own internal
    // scan for AGP memory.  But keep it around in case we need it back in the future.
    //
    /*
    if ((DmaObject->AddressSpace == ADDR_AGPMEM) && !pDev->Chip.NVAGPEnabled)
    {
        if (!((DmaObject->DescOffset >= pDev->Mapping.AGPLinearStart) 
            && (DmaObject->DescOffset <= (pDev->Mapping.AGPLinearStart + pDev->Mapping.AGPLimit))))
                // not really AGP memory
                DmaObject->AddressSpace = ADDR_SYSMEM;
    }
    */

    return (RM_OK);
}
//
// Free DAM instance memory associated with a DMA context and unlock the pages.
//
RM_STATUS dmaFreeInstance
(
    PHWINFO    pDev,
    PDMAOBJECT DmaObject
)
{
    DBG_VAL_PTR(DmaObject);
    if (DmaObject == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL object in dmaFreeInstance!\n\r");
        return (RM_OK);
    }
    //
    // Free instance page table plus guard page.
    //
    fbFreeInstMem(pDev, DmaObject->HalInfo.Instance, DmaObject->HalInfo.NumUnits);
    DmaObject->HalInfo.Instance   = 0;

    return (RM_OK);    
}

RM_STATUS dmaRegisterToDevice
(
    PHWINFO pDev, 
    PCLI_DMA_INFO pDmaInfo, 
    PDMAOBJECT *ppDmaObject
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLASS      DmaClass;
    CLASSOBJECT DmaClassObject;
    PDMAOBJECT  pDmaObject;

    rmStatus = classGetClass(&pDev->classDB, pDmaInfo->Access, &DmaClass);
    if (rmStatus)
        return rmStatus;

    // initialize parts of DmaClassObject for use in dmaCreate
    DmaClassObject.Base.ChID = INVALID_CHID;
    DmaClassObject.Base.ThisClass = DmaClass;
    rmStatus = dmaCreate((VOID*)pDev, &DmaClassObject, 0, (POBJECT *)&pDmaObject, NULL);

    if (rmStatus)
        return rmStatus;
    pDmaObject->Base.Name               = pDmaInfo->Handle;
    pDmaObject->Base.ChID               = INVALID_CHID;
    pDmaObject->Base.Class              = DmaClass;
    pDmaObject->Base.Subchannel         = 0;
    pDmaObject->Base.Next               = 0;
    pDmaObject->Base.NotifyXlate        = 0;
    pDmaObject->Base.NotifyAction       = 0;
    pDmaObject->Base.NotifyTrigger      = 0;
    pDmaObject->DescSelector            = pDmaInfo->DescSelector;
    pDmaObject->DescOffset              = pDmaInfo->DescOffset;
    pDmaObject->DescLimit               = pDmaInfo->DescLimit;
    pDmaObject->DescAddr                = pDmaInfo->DescAddr;
    pDmaObject->LockCount               = 0;
    pDmaObject->LockHandle              = pDmaInfo->LockHandle;
    pDmaObject->Valid                   = TRUE;
    pDmaObject->NotifyActionHandle      = 0;
    pDmaObject->HalInfo.BufferBase      = (VOID_PTR)pDmaInfo->BufferBase;
    pDmaObject->HalInfo.BufferSize      = pDmaInfo->BufferSize;
    pDmaObject->HalInfo.PteCount        = pDmaInfo->PteCount;

    pDmaObject->HalInfo.PteAdjust       = pDmaInfo->PteAdjust;
    pDmaObject->HalInfo.PteLimit        = pDmaInfo->PteLimit;
    pDmaObject->HalInfo.PteArray        = pDmaInfo->PteArray;
    pDmaObject->HalInfo.AddressSpace    = pDmaInfo->AddressSpace;

    // get DMA instance for page table mapping in the given device
    rmStatus = dmaAllocInstance(pDev, pDmaObject);
    if (rmStatus != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
        return rmStatus;
    }

    //
    // Call into HAL to handle h/w-dependent initialization.
    //
    if (nvHalDmaAlloc(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }

    // Success.
    *ppDmaObject = pDmaObject;
    return RM_OK;
}

RM_STATUS dmaUnregisterFromDevice
(
   PHWINFO     pDev,
   PDMAOBJECT  pDmaObject
)
{
    RM_STATUS rmStatus;

    //
    // Call into HAL to release h/w-dependent resources.
    //
    if (nvHalDmaFree(pDev, &pDmaObject->HalInfo) != RM_OK)
    {
        return (RM_ERR_BAD_DMA_SPECIFIER);      // ???
    }
    
    rmStatus = dmaFreeInstance(pDev, pDmaObject);
    if (rmStatus)
    {
        return rmStatus;
    }

    // delete DMA object for the device in the context of the device
    rmStatus = dmaDelete((VOID*)pDev, (POBJECT)pDmaObject);
    return rmStatus;
}

RM_STATUS dmaBindToChannel
(
    PHWINFO    pDev, 
    PDMAOBJECT pDmaObject, 
    U032       ChID
)
{
    RM_STATUS rmStatus = RM_OK;
    
    //
    // CWJ: don't add the DMA object to the pDev->DBfifoTable[ChID] in NV4. We don't
    // use the pDev->DBfifoTable[] for look-ups in NV4 and since there's a single
    // Node field it's unable to exist on more than a one fifoTable, just
    // skip it.
    //
    // rmStatus = fifoAddDmaObject(pDev, (POBJECT)pDmaObject, pFifoInfo->ChID);
    // if (rmStatus != RM_OK)
    // {
    //  return rmStatus;
    // }

    // update the hash table
    rmStatus = fifoUpdateObjectInstance(pDev,
                                        &pDmaObject->Base,
                                        ChID,
                                        pDmaObject->HalInfo.Instance);

    return rmStatus;
}

RM_STATUS dmaUnbindFromChannel
(
   PHWINFO    pDev,
   PDMAOBJECT pDmaObject,
   U032       ChID
)
{
    RM_STATUS rmStatus;
    
    // Delete this dma context object for this ChID from the hash table.
    rmStatus = fifoDeleteObjectInstance(pDev, (POBJECT)pDmaObject, ChID);
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  DMA object methods.
//
//---------------------------------------------------------------------------

//
// Validate and calculate new specifier parameters.
//
RM_STATUS mthdSetDmaSpecifier
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PDMAOBJECT DmaObject;
    PCLASS pClass;
    RM_STATUS  status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: mthdDmaSpecifier\n\r");

    DmaObject = (PDMAOBJECT)Object;
    pClass = Object->Class;

    //
    // Make sure the graphics engine is idle before we steal the DMA context
    //
    GR_IDLE();

    //
    // If already in use...
    //
    if (DmaObject->Valid)
    {
        //
        // Unallocate the previous lock
        //
        status = dmaDeallocate(pDev, DmaObject);
        if (status)
            return (status);
        //
        // And update the instance
        //
        status = fifoUpdateObjectInstance(pDev, 
                                          &DmaObject->Base, 
                                          DmaObject->Base.ChID, 
                                          DmaObject->HalInfo.Instance);
        if (status)
            return (status);                               
            
    }    
    //
    // Validate specifier.
    //
    DmaObject->Valid = FALSE;
    switch (Offset)
    {
        case 0x0300:
            DmaObject->State        = DMA_SET_DESC_0;
            // TO DO: this is a known truncation for IA64
            DmaObject->DescOffset   = (VOID*)Data;
            break;
        case 0x0304:
            if (DmaObject->State != DMA_SET_DESC_0)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State        = DMA_SET_DESC_1;
            DmaObject->DescSelector = Data;
            break;
        case 0x0308:
            if (DmaObject->State != DMA_SET_DESC_1)
                return (RM_ERR_METHOD_COUNT);
            DmaObject->State     = DMA_SET_DESC_2;
            DmaObject->DescLimit = Data;

            //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetDesc1 = ", Data);
            //
            // If the user sets a 0 limit on the DMA object, then
            // he is not using the buffer. Don't return an error
            // but also don't validate the buffer.
            //
            if (DmaObject->DescLimit != 0)
            {
               //
               // Validate DMA buffer address.
               //
               if (osGetAddressInfo(pDev,
                                    DmaObject->Base.ChID, 
                                    DmaObject->DescSelector,
                                    &(DmaObject->DescOffset),
                                    DmaObject->DescLimit,
                                    &(DmaObject->DescAddr), 
                                    &(DmaObject->HalInfo.AddressSpace)) != RM_OK)
                   return (RM_ERR_BAD_DMA_SPECIFIER);
                //
                // Now attempt to lock the context
                //                   
                DmaObject->Valid = TRUE;
                status = dmaAllocate(pDev, DmaObject);
                if (status)
                    return (status);
                //
                // And update the instance
                //
                status = fifoUpdateObjectInstance(pDev, 
                                                  &DmaObject->Base, 
                                                  DmaObject->Base.ChID, 
                                                  DmaObject->HalInfo.Instance);
                if (status)
                    return (status);                               
                                    
            }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA buffer object methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetBufferCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PBUFFEROBJECT BuffObject;
    U032          BuffNum;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum    = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferCtxDma(pDev, BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferCtxDma
(
    PHWINFO       pDev, 
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    //
    // Check for a previous translation.
    //
    //if (pBuffer->Xlate)
    //    dmaDetach(pBuffer->Xlate);
    //
    // Check for NULL object.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        pBuffer->Xlate = NULL;
        return (RM_OK);
    }
    //
    // Validate dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   BuffObject->Base.ChID,
                                   &pBuffer->Xlate);
    if (status)
    {
        osError(&BuffObject->Base, Offset, Data, status);
        return (status);
    }
    //
    // Set the method to be used for notification on this buffer
    //
    pBuffer->NotifyMethod = Offset;
    return (status);
}

RM_STATUS mthdSetBufferStart
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032          BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferStart(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferStart
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Start = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferLength
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferLength(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferLength
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Length = Data;
    return (RM_OK);
}

RM_STATUS mthdSetBufferPitch
(
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    U032 BuffNum;
    PBUFFEROBJECT BuffObject;

    BuffObject = (PBUFFEROBJECT)Object;
    BuffNum = (Offset - Method->Low) >> 2;
#ifdef DEBUG
    if (BuffNum > 1)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid buffer number!", BuffNum);
        DBG_BREAKPOINT();
    }
#endif
    return(dmaSetBufferPitch(BuffObject, &BuffObject->Buffer[BuffNum], Offset, Data));
}

RM_STATUS dmaSetBufferPitch
(
    PBUFFEROBJECT BuffObject,
    PBUFFER       pBuffer,
    U032          Offset,
    V032          Data
)
{
    //
    // Check for busy buffer.
    //
/*    
    if (pBuffer->State != BUFFER_IDLE)
    {
        osError(&BuffObject->Base, Offset, Data, RM_ERR_DMA_IN_USE);
        return (RM_ERR_DMA_IN_USE);
    }
*/    
    pBuffer->Pitch = Data;
    return (RM_OK);
}

RM_STATUS mthdSetSampleRate
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.Rate = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetSampleRateAdjust
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.RateAdjust = Data;
    ((PBUFFEROBJECT)Object)->Sample.RateUpdate((PBUFFEROBJECT)Object);
    return (RM_OK);
}
RM_STATUS mthdSetNumberChannels
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    ((PBUFFEROBJECT)Object)->Sample.NumChannels = Data;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  DMA service routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv4\dmanv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv04.c                                                         *
*   The NV04 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV04(VOID *);
RM_STATUS nvHalDmaAlloc_NV04(VOID *);
RM_STATUS nvHalDmaFree_NV04(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV04(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV04(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV04(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);
    
    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV04(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV04(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV04(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dma\nv10\dmanv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: dmanv10.c                                                         *
*   The NV10 HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalDmaControl_NV10(VOID *);
RM_STATUS nvHalDmaAlloc_NV10(VOID *);
RM_STATUS nvHalDmaFree_NV10(VOID *);
RM_STATUS nvHalDmaGetInstSize_NV10(VOID *);

//
// nvHalDmaControl
//
// Nothing to do here.
//
RM_STATUS
nvHalDmaControl_NV10(VOID *arg)
{
    PDMACONTROLARG_000 pDmaControlArg = (PDMACONTROLARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDmaControlArg->id != DMA_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    switch (pDmaControlArg->cmd)
    {
        case DMA_CONTROL_UPDATE:
        case DMA_CONTROL_LOAD:
        case DMA_CONTROL_UNLOAD:
        case DMA_CONTROL_DESTROY:
        case DMA_CONTROL_INIT:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalDmaAlloc
//
// Initialize dma instance.
//
RM_STATUS
nvHalDmaAlloc_NV10(VOID *arg)
{
    PDMAALLOCARG_000 pDmaAllocArg = (PDMAALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PDMAHALINFO pDmaHalInfo;
    PHWREG nvAddr;
    U032 adjust, i;

    //
    // Verify interface revision.
    //
    if (pDmaAllocArg->id != DMA_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pDmaHalObjInfo = pDmaAllocArg->pHalObjInfo;
    pHalHwInfo = pDmaAllocArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    adjust = 0;
    switch (pDmaHalObjInfo->classNum)
    {
        case NV1_CONTEXT_DMA_TO_MEMORY:     
        case NV_CONTEXT_DMA_TO_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_TO_MEMORY);
            break;
        case NV1_CONTEXT_DMA_FROM_MEMORY:     
        case NV_CONTEXT_DMA_FROM_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_FROM_MEMORY);
            break;
        case NV1_CONTEXT_DMA_IN_MEMORY:     
        case NV_CONTEXT_DMA_IN_MEMORY:
            adjust |= SF_NUM(_DMA, _CLASS, NV1_CONTEXT_DMA_IN_MEMORY);
            break;
    }
    adjust |= SF_NUM(_DMA, _ADJUST, pDmaHalObjInfo->PteAdjust);
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
        adjust |= SF_DEF(_DMA, _PAGE_ENTRY, _LINEAR);
    adjust |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
    switch (pDmaHalObjInfo->AddressSpace)
    {
        case ADDR_SYSMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _PCI);
            break;
        case ADDR_AGPMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _AGP);
            break;
        case ADDR_FBMEM:
            adjust |= SF_DEF(_DMA, _TARGET_NODE, _NVM);
            break;
        default:
#ifdef DEBUG
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Invalid address space type\n\r");
            DBG_BREAKPOINT();
#endif
            return (RM_ERR_BAD_ARGUMENT);
    }
    //
    // Fill the page translation array.
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || (pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM))
    {    
        INST_WR32(pDmaHalObjInfo->Instance, 8, pDmaHalObjInfo->PteArray[0]);
        INST_WR32(pDmaHalObjInfo->Instance, 12, pDmaHalObjInfo->PteArray[0]); // better guard
    }        
    else 
    {   
        for (i = 0; i < pDmaHalObjInfo->PteCount; i++)
        {
            INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[i]);
        }
        //
        // Fill in the guard page with bogus data.  Only accessed by DMA engine,
        // not used in any transfer to system memory.
        //
        INST_WR32(pDmaHalObjInfo->Instance, 8 + i*4, pDmaHalObjInfo->PteArray[0]);
    }
    //
    // Fill in rest of page table values.
    //
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_CLASS), adjust);
    INST_WR32(pDmaHalObjInfo->Instance, SF_OFFSET(NV_DMA_LIMIT), pDmaHalObjInfo->PteLimit);

    //
    // Add this dma context to the HAL table.
    //
    pDmaHalObjInfo->Next = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
    pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo;

    return (RM_OK);
}

//
// nvHalDmaFree
//
RM_STATUS
nvHalDmaFree_NV10(VOID *arg)
{
    PDMAFREEARG_000 pDmaFreeArg = (PDMAFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALINFO pDmaHalInfo;
    PDMAHALOBJINFO pDmaHalObjInfo, pDmaHalObjInfoDelete;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaFreeArg->id != DMA_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaFreeArg->pHalHwInfo;
    pDmaHalInfo = pHalHwInfo->pDmaHalInfo;
    pDmaHalObjInfo = pDmaFreeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Detach from DMA list.
    //
    if (pDmaHalInfo->pDmaHalObjInfos == (VOID_PTR)pDmaHalObjInfo)
        pDmaHalInfo->pDmaHalObjInfos = (VOID_PTR)pDmaHalObjInfo->Next;
    else
    {
        pDmaHalObjInfoDelete = (PDMAHALOBJINFO)pDmaHalInfo->pDmaHalObjInfos;
        while (pDmaHalObjInfoDelete->Next && pDmaHalObjInfoDelete->Next != pDmaHalObjInfo)
        {
            pDmaHalObjInfoDelete = pDmaHalObjInfoDelete->Next;
        }
        if (pDmaHalObjInfoDelete->Next)
            pDmaHalObjInfoDelete->Next = pDmaHalObjInfo->Next;
    }

    return (RM_OK);
}

//
// nvHalDmaGetInstSize
//
// Return number of *paragraphs* required for dma context in
// instance memory.
//
RM_STATUS
nvHalDmaGetInstSize_NV10(VOID *arg)
{
    PDMAGETINSTSIZEARG_000 pDmaGetInstSizeArg = (PDMAGETINSTSIZEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PDMAHALOBJINFO pDmaHalObjInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pDmaGetInstSizeArg->id != DMA_GET_INSTSIZE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDmaGetInstSizeArg->pHalHwInfo;
    pDmaHalObjInfo = pDmaGetInstSizeArg->pHalObjInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Factor in an extra PTE so when the DMA engine prefetches, it
    // won't fault on a last access to a page.
    //
    
    //
    // Local memory contexts require only 1 paragraph (they're linear).
    // So do single page contexts in other address spaces (i.e. system memory).
    //
    if ((pDmaHalObjInfo->AddressSpace == ADDR_FBMEM) || ((pDmaHalObjInfo->AddressSpace == ADDR_AGPMEM)))
        pDmaHalObjInfo->NumUnits = 1;
    else
    {
        if (pDmaHalObjInfo->PteCount == 1)
            pDmaHalObjInfo->NumUnits = 1;
        else
            pDmaHalObjInfo->NumUnits = 2 + (pDmaHalObjInfo->PteCount - 1) / 4;
    }
    
    return (RM_OK);
}

//
// dmaHalInstanceToHalInfo
//
RM_STATUS
dmaHalInstanceToHalInfo_NV10(U032 chid, U032 instance, PDMAHALOBJINFO *ppDmaHalObjInfo, PHALHWINFO pHalHwInfo)
{
    PDMAHALOBJINFO pDmaHalObjInfo;

    pDmaHalObjInfo = (PDMAHALOBJINFO)pHalHwInfo->pDmaHalInfo->pDmaHalObjInfos;
    while (pDmaHalObjInfo)
    {
        if (pDmaHalObjInfo->Instance == instance)
        {
            //
            // Found it!
            //
    	    *ppDmaHalObjInfo = pDmaHalObjInfo;
            return RM_OK;
        }
        pDmaHalObjInfo = pDmaHalObjInfo->Next;
    }

    *ppDmaHalObjInfo = NULL;  
    return RM_ERR_BAD_ARGUMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifoinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOINIT.C                                                        *
*   The FIFO is initialized in this module.  This is a one time occurance   *
*   and then the module is unloaded.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"


//
// Initialize FIFO data structures and hardware.
//
RM_STATUS initFifo
(
    PHWINFO pDev
)
{
    U032 i;
    
    //
    // Initilialize all global FIFO variables.
    //
    pDev->Fifo.HalInfo.AllocateCount    = 0;
    pDev->Fifo.UpdateFlags              = 0;

    //
    // Allocate FIFO table.
    //
    if (osAllocMem((VOID **)&pDev->DBfifoTable, sizeof(FIFO) * NUM_FIFOS) != RM_OK)
        return (RM_ERR_NO_FREE_MEM);
    for (i = 0; i < NUM_FIFOS; i++)
    {
        pDev->DBfifoTable[i].InUse = FALSE;
        pDev->DBfifoTable[i].ChID  = i;
        pDev->DBfifoTable[i].CacheDepth = 512;
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fbinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FBINIT.C                                                          *
*   The FrameBuffer is initialized in this module.  This is a one time      *
* occurance and then the module is unloaded.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"
#include <state.h>
#include <class.h>
#include <fb.h>
#include <vga.h>
#include <os.h>
#include <tv.h>
#include <vga.h>

//
// One time framebuffer initialization.
//
RM_STATUS initFb
(
    PHWINFO pDev
)
{
    U032 status;
    //
    // Turn off video.
    //
    // MUST BLANK MONITOR ... setting PFB_GREEN_0_VIDEO_DISABLED doesn't work.
    // The underlying routines (e.g. osSetVideoMode) need to do this before a
    // mode change.
    //
    // REG_WR_DRF_DEF(_PFB, _GREEN_0, _LEVEL, _VIDEO_DISABLED);

    //
    // Account for BIOS_IMAGE_PAD.  This could be made os-indepedendent
    // so we don't waste 64K on platforms that don't need the bios.
    //
    pDev->Pram.HalInfo.InstPadSize = BIOS_IMAGE_PAD;

    //
    // Let HAL establish FB parameters:
    //   - dram sizes/bank counts
    //   - fifo context/hash table/run out sizes
    //
    status = nvHalFbControl(pDev, FB_CONTROL_INIT);

    //Did we config the frame buffer correctly? 
    if (status != RM_OK)
    {
        return (RM_ERROR);
    }
    //
    // Locate and size the free instance area. This is the base where
    // allocations should start and size of the allocatable inst mem.
    //
    pDev->Pram.FreeInstSize = pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD - pDev->Pram.HalInfo.CurrentSize;
    pDev->Pram.FreeInstBase = (pDev->Pram.HalInfo.CurrentSize + BIOS_IMAGE_PAD) >> 4;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstSize ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FreeInstBase ", pDev->Pram.FreeInstBase);

    //
    // Default to 640X480X16X1 framebuffer w/ VGA timing.
    //
    pDev->Framebuffer.DpmLevel          = 0;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = 480;
    pDev->Dac.HalInfo.Depth     = 16;
    pDev->Framebuffer.HalInfo.RefreshRate       = 60;
    pDev->Framebuffer.Count             = 1;
    pDev->Framebuffer.Current           = 0;
    pDev->Framebuffer.FlipUsageCount    = 0;
    pDev->Framebuffer.FlipTo            = 0;
    pDev->Framebuffer.FlipFrom          = 0;
    pDev->Framebuffer.UpdateFlags       = 0;
    pDev->Framebuffer.HorizFrontPorch   = 0;
    pDev->Framebuffer.HorizSyncWidth    = 0;
    pDev->Framebuffer.HorizBackPorch    = 0;
    pDev->Framebuffer.VertFrontPorch    = 0;
    pDev->Framebuffer.VertSyncWidth     = 0;
    pDev->Framebuffer.VertBackPorch     = 0;
    pDev->Framebuffer.HSyncPolarity     = 0;
    pDev->Framebuffer.VSyncPolarity     = 0;
    pDev->Framebuffer.CSync             = 0;

    pDev->Framebuffer.HalInfo.Start[0] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[0] = pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize - 1;
    pDev->Framebuffer.HalInfo.Start[1] = 0x00000000;
    pDev->Framebuffer.HalInfo.Limit[1] = 0x00000000;

    //
    // Check for os-specific mode overrides.
    //
    initFbEx(pDev);

    //
    // Make sure our write protection is disabled for now
    //
    nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RamSize ", pDev->Framebuffer.HalInfo.RamSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: TotalInstSize ", pDev->Pram.HalInfo.TotalInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Limit[0] ", pDev->Framebuffer.HalInfo.Limit[0]);

    return (fbCheckConfig(pDev));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fbstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Framebuffer Module ******************************\
*                                                                           *
* Module: FBSTATE.C                                                         *
*   The Framebuffer state is changed in this module.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <nvhw.h>
#include <fb.h>
#include <heap.h>
#include <vga.h>


//
// Save registers for framebuffer.
//
// U032 fbSave[2];

//
// New routine to point to location of cursor in instance memory and enable it.
VOID fbEnableCursor(VOID);

// This should already be setup somewhere else
#define RM_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global\\System"

//
// Here's a definition of how these globals are being used:
//
//        FreeInstSize  - size in bytes of allocatable inst memory.
//                        Based on BIOS_IMAGE_PAD and the allocations for RAMHT, RAMFC and RAMRO.
//
//
//        FreeInstMax   - size in paragraphs of allocatable inst memory.
//                        fbInstBitmap is sized from this value and scanning for free
//                        instance memory uses this as the max available. This value
//                        is FreeInstBase + FreeInstSize in paragraphs.
//
//        FreeInstBase  - base where instance memory allocations begin.
//                        The base has already skipped beyond the BIOS_IMAGE_PAD
//                        and the allocations for RAMHT, RAMFC and RAMRO.
//
//        TotalInstSize - size in bytes of all of instance memory.
//                        This includes:
//                              allocatable instance memory
//                              RAMHT + RAMFC + RAMRO
//                              BIOS_PAD_IMAGE
//

//
// Change Frambuffer hardware state.
//
RM_STATUS stateFb
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
    S032      size;
    U032      entry;
    int       i;

    status = RM_OK;

    //
    // Deal with state change.
    //
    switch (msg)
    {
        case STATE_UPDATE:
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);
            }
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {
                //
                // Validate and calculate new framebuffer memory requirements.
                //
                fbCheckConfig(pDev);

                //
                // This usage flag will be cleared by the dac state routine
                // after the display is updated
                //
                // pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            break;
        case STATE_LOAD:

            //
            // Check for any os-specific fb overrides.  These overrides must be known now in case
            // we need to adjust how our framebuffer is aligned or tiled.
            //
			osStateFbEx(pDev);			// check for override on FilterEnable

            //
            // Verify framebuffer configuration.
            //
            fbCheckConfig(pDev);

            //
            // Call into HAL to finish setup of FB state.
            //
            nvHalFbControl(pDev, FB_CONTROL_LOAD);

            // Check if we need to create the heap
            if (pDev->Framebuffer.HeapHandle == NULL)
            {
                //
                // Allocate framebuffer heap.  All memory must be allocated from here to keep the world
                // consistent (N.B. the heap size has been reduced by the amount of instance memory).
                //
                if ((status = heapCreate(pDev,
                                         (U008 *)fbAddr,
                                         pDev->Framebuffer.HalInfo.RamSize - pDev->Pram.HalInfo.TotalInstSize,
                                         pDev->Framebuffer.HalInfo.BankCount,
                                         (PHEAP *)&(pDev->Framebuffer.HeapHandle))) != RM_OK)
                    return (status);
            }

            // Check if we need to allocate the primary surface
            // We don't need to if we are in 4 bpp (VGA.DRV is running).
            if ((pDev->Framebuffer.PrimarySurfaceAlloced == FALSE) && (pDev->Dac.HalInfo.Depth != 4))
            {
                U032 offset;

                // Allocate the primary surface
                nvHalFbGetSurfacePitch(pDev, pDev->Framebuffer.HalInfo.HorizDisplayWidth, pDev->Dac.HalInfo.Depth, &pDev->Dac.DisplayPitch);
                size = pDev->Dac.DisplayPitch * pDev->Framebuffer.HalInfo.VertDisplayWidth;

                // heapAlloc fills in pDev->Framebuffer.HalInfo.Start for MEM_TYPE_PRIMARY
                if ((status = heapAlloc(pDev,
                                        (PHEAP)pDev->Framebuffer.HeapHandle,
                                        'NVRM',
                                        (U032 *) &size,
                                        MEM_TYPE_PRIMARY,
                                        pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                        &pDev->Dac.DisplayPitch,
                                        &offset)) != RM_OK)
                    return (status);
            }
            
            // 
            // For a tiled primary surface, we delay setting the tiled bit in the hardware
            // until after we've modeswitched out of VGA to prevent a garbled splash screen.
            // Just in case we haven't set it yet, do it now.
            //
            for (i=0; i<MAX_CRTCS; i++) {
                if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
                    heapFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
                }
            }

            //
            // Since we're no longer maintaining the cache across mode changes, just
            // wipe the cache clean.
            //
            for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
            {
                pDev->Dac.CursorMaskCRC[entry] = 0;
            }
            pDev->Dac.CursorCached = 0;

            pDev->Framebuffer.UpdateFlags &= ~(UPDATE_HWINFO_BUFFER_PARAMS | UPDATE_HWINFO_DISPLAY_PARAMS);

            break;
        case STATE_UNLOAD:

            //
            // Turn off video.
            //
            // MUST BLANK MONITOR ... setting PFB_GREEN_0_VIDEO_DISABLED doesn't work.
            // The underlying routines (e.g. osSetVideoMode) need to do this before a
            // mode change.
            //
            // REG_WR_DRF_DEF(_PFB, _GREEN_0, _LEVEL, _VIDEO_DISABLED);
#if 0
            //
            // We're not calling heapDestroy as part of an state unload anymore.
            //           

#ifndef NTRM
            // Completely destroy the heap on mode switches. However, we don't want to destroy
            // the heap if we are going into or coming out of a full screen DOS box.
            if (!pDev->Vga.DOSBox)
#endif
            {
                // Free heap.
                heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle);
            }
#endif

            break;
        case STATE_INIT:
        {
            U032 data32, fb;

            //
            // Check the registry to see if we're not allowing pitch values to be rounded
            // up to what NV10 tiling requires (pitch must equal width for some old apps).
            // If so, we'll only tile a surface if the pitch is already aligned.
            //
            // We only want to not tile the lower resolutions with this flag, which means
            // just the 6x4 and 8x6 modes. But, we don't have width/height at all times
            // and checking against pitch has overlap with the other modes. So, we'll use
            // what we have at the time; width <= 800 or height <= 600 will be checked.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, RM_GLOBAL_BASE_PATH, "NoAdjustedPitch", &data32) == RM_OK)
                pDev->Framebuffer.NoAdjustedPitch = 0x1;    // surface height check
            else
                pDev->Framebuffer.NoAdjustedPitch = 0x0;

            status = initFb(pDev);
            if (status != RM_OK)
            {
                return (RM_ERROR);
            }

            //
            // Reserve high block of fb mem as instance space.
            //
            for (fb = 0; fb < ((pDev->Pram.HalInfo.TotalInstSize - BIOS_IMAGE_PAD) / 4); fb++)
                REG_WR32(NV_PRAMIN_DATA032(fb) + BIOS_IMAGE_PAD, 0);

            //
            // Setup bitmap.
            //
            status = fbInitializeInstMemBitMap(pDev);
            if (status)
                return (status);

            //
            // Now that the instance bitmap is setup, we can safely
            // claim any instance memory required by the chip's engines.
            //
            status = allocHalEngineInstMem(pDev);
            if (status)
                return (status);
            break;
        }
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfbInstBitmap);

            //
            // Restore framebuffer registers.
            //
            nvHalFbControl(pDev, FB_CONTROL_DESTROY);
            break;
    }
    return (status);
}

//
// Verify that we have enough fbmem to support the requested
// video mode.
//
RM_STATUS fbCheckConfig
(
    PHWINFO pDev
)
{
    S032 size;
	U032 normalized_depth;

    //
    // Normalize our framebuffer depth
    //
    switch (pDev->Dac.HalInfo.Depth)
    {
        case 32:
        case 30:
        case 24:
            normalized_depth = 32;
            break;
        case 16:
        case 15:
            normalized_depth = 16;
            break;
        case 8:
        default:
            normalized_depth = 8;
            break;
    }

    //
    // Force video parameters to proper values.
    //
    // Calculate PRAM, Hash Table, and Instance memory sizes.
    //
    size = normalized_depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * pDev->Framebuffer.Count;

    //
    // Now calculate the available offscreen memory
    //
    if (size > (S032)pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;

    if (size < (S032)pDev->Pram.HalInfo.TotalInstSize)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error - not enough PRAM!!!!!\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifostat.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOSTATE.C                                                       *
*   The FIFO state is changed in this module.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


//
// Change FIFO state in hardware.
//
RM_STATUS stateFifo
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            nvHalFifoControl(pDev, FIFO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_LOAD);

            //
            // Re-disable cache reassignment if we're in a full-screen DOS session.  In case
            // some driver goes crazy and starts writing its dma pointers before
            // we're back into hires, we don't want to render on the DOS screen.
            // By disabling the reassign, we lock the fifo at the unused channel
            // until we're ready to process more data.  They're welcome to fill their
            // buffer up -- it just won't go anywhere.
            //
            if (pDev->Vga.Enabled)
            {
                FIFOLOG(3, 1, 1);
                REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            }

            //
            // Enable all PFIFO interrupt conditions using value
            // setup by HAL (see FIFO_CONTROL_INIT code for each chip).
            //
            REG_WR32(NV_PFIFO_INTR_0,     0xFFFFFFFF);
            REG_WR32(NV_PFIFO_INTR_EN_0,  pDev->Fifo.HalInfo.IntrEn0);

            break;
        case STATE_UNLOAD:
            nvHalFifoControl(pDev, FIFO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
            initFifo(pDev);
            initFifoEx(pDev);
            
            //
            // Allocate Hash Table structure.
            //
            if (osAllocMem((VOID **)&pDev->DBhashTable, HASH_DEPTH * sizeof(SW_HASH_TABLE_ENTRY)) != RM_OK)
                return (RM_ERR_NO_FREE_MEM);

            //
            // Initialize Hash Table.
            //    
            for (i = 0; i < HASH_DEPTH; i++)
            {
                pDev->DBhashTable[i].Object = NULL;
            }

            nvHalFifoControl(pDev, FIFO_CONTROL_INIT);
            break;
        case STATE_DESTROY:
            //
            // Free up allocated memory.
            //
            osFreeMem(pDev->DBfifoTable);
            osFreeMem(pDev->DBhashTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv\fb.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FB Manager *********************************\
*                                                                           *
* Module: FB.C                                                              *
*   The FB is managed in this module.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <fb.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"


//---------------------------------------------------------------------------
//
//  Instance allocation bitmap.
//
//---------------------------------------------------------------------------

RM_STATUS fbInitializeInstMemBitMap
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    U008      *pbyte;
    U032      size;
    U032      entry;

    //
    // Initialize instance memory usage bitmap.  Each bit equals 1 paragraph (16 bytes)
    // of instance memory.
    //
    pDev->Pram.FreeInstMax = (pDev->Pram.FreeInstSize  / 16) & ~0x07;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Size       = ", pDev->Pram.FreeInstSize);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Base  = ", pDev->Pram.FreeInstBase);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB Free Inst Max   = ", pDev->Pram.FreeInstMax + pDev->Pram.FreeInstBase);

    size = (pDev->Pram.FreeInstMax / 8 + 4);
    status = osAllocMem((VOID **)&pbyte, size);
    if (status)
        return (status);

    pDev->DBfbInstBitmap = pbyte;

    //
    // Reserve instance 0 as the NULL instance.
    //    
    *pbyte++ = 0xFE;    
    while (--size)
        *pbyte++ = 0xFF;

    //
    // Allocate Instance memory for the cursor image - must be aligned to 2k.
    //
    // KJK This should be removed once the new cursor interface is enabled in the display
    // driver.
    //
    status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageInstance, 0x800 / 16, 0x800 / 16);
    if (status)
    {
        osFreeMem((void *)pDev->DBfbInstBitmap);
        pDev->DBfbInstBitmap = 0;
        return (status);
    }


    //
    // Allocate the cached cursors and clear all current state
    // 
    for (entry=0; entry < MAX_CACHED_CURSORS; entry++)
    {   
        status = fbAllocInstMemAlign(pDev, &pDev->Dac.CursorImageCacheInstance[entry], 0x800 / 16, 0x800 / 16);
        if (status)
        {
            osFreeMem((void *)pDev->DBfbInstBitmap);
            pDev->DBfbInstBitmap = 0;
            return (status);
        }
        //
        // Since we're no longer maintaining the cache across mode changes, just
        // wipe the cache clean.
        //
        pDev->Dac.CursorMaskCRC[entry] = 0;                    
    }                    

    return RM_OK;
} // end of fbInitializeInstMemBitMap 

//---------------------------------------------------------------------------
//
//  PRAM allocation and de-allocation.
//
//---------------------------------------------------------------------------

/*	alloc instance mem with specified alignment
*/
RM_STATUS fbAllocInstMemAlign
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size,
    U032    Align		
)
{
    U032 i;
    U032 j;
	U032 mask;

    if (pDev->Power.State != 0)
    {
        return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;
	i = pDev->Pram.FreeInstBase;		// get base of inst memory
	mask = Align - 1;
	while (mask & i)		 			// align i
		i += 0x1;						// try next page
	i -= pDev->Pram.FreeInstBase;		// offset from base
    for ( ; i < pDev->Pram.FreeInstMax; i += Align)
    {
		U032 k = i;

        if (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7))		// available?
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++k >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[k >> 3] & BIT(k & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = k - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    k--;
                    pDev->DBfbInstBitmap[k >> 3] &= ~BIT(k & 7);
                }
#if defined(NTRM) && defined(DBG)
				osLogInstMemAlloc(*Instance, Size, Align);
#endif
                return (RM_OK);
            }
        }
    }
    return (RM_ERR_NO_FREE_MEM);
}

RM_STATUS fbAllocInstMem
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size
)
{
    U032 i;
    U032 j;

    if (pDev->Power.State != 0)
    {
        return (RM_ERR_NO_FREE_MEM);
    }

    DBG_VAL_PTR(pDev->DBfbInstBitmap);
#if DEBUG
    if (Size == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Zero size in fbAllocInstMem!\n\r");
        DBG_BREAKPOINT();
    }
#endif
    *Instance = 0;
    for (i = 0; i < pDev->Pram.FreeInstMax; i++)
    {
        if (!pDev->DBfbInstBitmap[i >> 3])
        {
            i += 7;
        }
        else if (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= pDev->Pram.FreeInstMax) || (++j >= Size))
                    break;
            }
            while (pDev->DBfbInstBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Instance = i - j + pDev->Pram.FreeInstBase;
                while (j--)
                {
                    //
                    // Mark instance memory as allocated.
                    //
                    i--;
                    pDev->DBfbInstBitmap[i >> 3] &= ~BIT(i & 7);
                }
#if defined(NTRM) && defined(DBG)
				osLogInstMemAlloc(*Instance, Size, 0);
#endif
                return (RM_OK);
            }
        }
    }
    return (RM_ERR_NO_FREE_MEM);
}
RM_STATUS fbFreeInstMem
(
    PHWINFO pDev,
    U032    Instance,
    U032    Size
)
{
#if defined(NTRM) && defined(DBG)
	U032 actualInstance = Instance;
	U032 actualSize = Size;
#endif // DEBUG && NTRM

    //
    // If instance is already set to 0, then it has already been freed.  This can
    // happen in some cases when a mode switch is happening while MIDI is playing
    // using the timer alarm notifies.  Ignoring this case can potentially cause a
    // protection fault, so be careful.
    //
    if (!Instance)
        return (RM_OK);
    Instance -= pDev->Pram.FreeInstBase;
#if DEBUG
    if (Instance > pDev->Pram.FreeInstMax)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - Freed instance out of range!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG
    while (Size--)
    {
        //
        // Mark instance memory as free.
        //
        pDev->DBfbInstBitmap[Instance >> 3] |= BIT(Instance & 7);
        Instance++;
    }
#if defined(NTRM) && defined(DBG)
	osUnlogInstMemAlloc(actualInstance, actualSize);
#endif // DEBUG

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv4\fbnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: fbnv04.c                                                          *
*   The NV4 specific HAL FB routines reside in this file.                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "os.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV04(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV04(VOID *);
RM_STATUS nvHalFbAlloc_NV04(VOID *);
RM_STATUS nvHalFbFree_NV04(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV04(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV04(VOID *);
RM_STATUS nvHalFbLoadOverride_NV04(VOID *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV4 expects a 512byte alignment
#define FC_MIN_ALIGN_SHIFT      9

/*****************************************************************************
 * tetris tiling
 *****************************************************************************/
char tetris_tile_table_signature[] = "_TETRIS_TILE_TABLE_";
static U032 NvChipTetrisTileTable[] =
{
// width  depth input_width  shift                               mode
//   |    |     |            |                                   |
     320, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | (128 << 16),  0, 0,
    1024, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 16 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | (128 << 16),  0, 0,
    1024, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/3,
    1280, 32 | (128 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/0, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 16 | ( 64 << 16),  0, 0,
    1024, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 16 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

     320, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/1, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     640, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,
     800, 32 | ( 64 << 16),  0, 0,
    1024, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/2,
    1280, 32 | ( 64 << 16),  /*NV_PFB_CONFIG_0_TETRIS_SHIFT_*/2, /*NV_PFB_CONFIG_0_TETRIS_MODE*/6,

    /* all others are disabled */
};

static RM_STATUS
nvHalTetrisTileWrite_NV04(PHALHWINFO pHalHwInfo, U032 NewConfig0Value)
{
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    U032 OldConfig0Value;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;

    /*
     * check if we need to reprogram tiling
     */
    OldConfig0Value = REG_RD32(NV_PFB_CONFIG_0);
    NewConfig0Value = (NewConfig0Value & 0x000fffff) | (OldConfig0Value & 0xfff00000);
    if (NewConfig0Value != OldConfig0Value)
    {
        U032      reg0140;
        U032      reg2500;
        U032      reg3200;
        U032      reg3250;
        U032      size    = pPramHalInfo->TotalInstSize;
        VOID*     fbBase  = pHalHwInfo->fbBaseAddr;
        U032      fbSize  = pFbHalInfo->RamSize;
        U032      i;
        U008      *src, *dest;

        /*
         * save instance and driver memory
         */
        src = (U008 *)fbBase + fbSize - size;
        dest = (U008 *)pFbHalPvtInfo->bufferBase;

        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: src ", src);
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: dest ", dest);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTileWrite_NV04: count ", size);
        for (i = 0; i < size; i++)
        {
            dest[i] = src[i];
        }

        /*
         * disable chip
         */
        HAL_GR_IDLE(pHalHwInfo);
        WriteIndexed(NV_PRMVIO_SRX, 0x0000);  // _outp (0x3c4,0); _outp (0x3c5,0);
        reg2500 = REG_RD32(NV_PFIFO_CACHES);       REG_WR32(NV_PFIFO_CACHES, 0);
        reg3200 = REG_RD32(NV_PFIFO_CACHE1_PUSH0); REG_WR32(NV_PFIFO_CACHE1_PUSH0, 0);
        reg3250 = REG_RD32(NV_PFIFO_CACHE1_PULL0); REG_WR32(NV_PFIFO_CACHE1_PULL0, 0);
        reg0140 = REG_RD32(NV_PMC_INTR_EN_0);      REG_WR32(NV_PMC_INTR_EN_0, 0);

        /*
         * program tiling
         */
        REG_WR32(NV_PFB_CONFIG_0, NewConfig0Value);

        /*
         * restore instance and driver memory
         */
        for (i = 0; i < size; i++)
        {
            src[i] = dest[i];
        }

        /*
         * re-enable chip
         */
        REG_WR32(NV_PMC_INTR_EN_0, reg0140);
        REG_WR32(NV_PFIFO_CACHE1_PULL0, reg3250);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, reg3200);
        REG_WR32(NV_PFIFO_CACHES, reg2500);
        WriteIndexed(NV_PRMVIO_SRX, 0x0300); // _outp (0x3c4,0); _outp (0x3c5,3);
    }

    /*
     * done
     */
    return RM_OK;
}


static RM_STATUS
nvHalTetrisTile_NV04(PHALHWINFO pHalHwInfo)
{   
    PFBHALINFO pFbHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PDACHALINFO pDacHalInfo;
    U032 width, depth;
    U032 i;

    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalTetrisTile_NV04: tiling mode ", pFbHalPvtInfo->tilingDisabled);

    if (!pFbHalPvtInfo->tilingDisabled)
    {
        /*
         * determine if we should setup special tiling for this mode
         */
        width = pFbHalInfo->HorizDisplayWidth;
        depth = pDacHalInfo->Depth | (pDacHalInfo->InputWidth << 16);

#if 0
        /* DO NOT REMOVE - used for tiling tests */
        *((U032*)0xb0050) = (U032)NvChipTetrisTileTable;
#endif

        for (i = 0; i < sizeof(NvChipTetrisTileTable) / sizeof(U032); i += 4)
        {
            if ((NvChipTetrisTileTable[i + 0] == width)
             && (NvChipTetrisTileTable[i + 1] == depth)
             &&  NvChipTetrisTileTable[i + 2]
             &&  NvChipTetrisTileTable[i + 3])
            {
                U032 NewConfig0Value;

                /*
                 * calculate new tiling info
                 */
                NewConfig0Value = NV_PFB_CONFIG_0_TYPE_TETRIS
                                | (NvChipTetrisTileTable[i + 2] << 18)
                                | (NvChipTetrisTileTable[i + 3] << 15);

                /*
                 * program the tiling
                 */
                nvHalTetrisTileWrite_NV04(pHalHwInfo, NewConfig0Value);

                /*
                 * done
                 */
                return RM_OK;
            }
        }
    }  // Tiling is not disabled

    /*
     * disable tiling
     */
    nvHalTetrisTileWrite_NV04(pHalHwInfo, NV_PFB_CONFIG_0_TYPE_NOTILING);

    /*
     * done
     */
    return RM_OK;
}

//
// nvHalFbControl
//
//
RM_STATUS
nvHalFbControl_NV04(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CONFIG_0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CONFIG_1);

            //
            // Since this is only called from initFb(), we'll do this here
            // KJK Verify a valid RTL setting
            //
            REG_WR32(NV_PFB_RTL, 0);

            //
            // Setup pointer to our tiling save area.  It's immediately
            // after the FBHALINFO_NV04 structure in our engine
            // private data area setup by the RM.
            //
            pFbHalPvtInfo->bufferBase = (U008*)pFbHalPvtInfo + sizeof (FBHALINFO_NV04);

            //
            //  Set RamType
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_TYPE)) {
                //case NV_PFB_BOOT_0_RAM_TYPE_1024K_2BANK:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBIT:
                case NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBITX16:
                    pFbHalInfo->RamType = BUFFER_SDRAM;
                    break;
                default:
                    // Everything else is SGRAM
                    pFbHalInfo->RamType = BUFFER_SGRAM;
                    break;
            }

            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA)){
                pFbHalInfo->RamType = BUFFER_CRUSH_UMA;
            }

            //
            // Set RamSize (in bytes)
            //
            switch (REG_RD_DRF(_PFB, _BOOT_0, _RAM_AMOUNT)) {
                case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                    pFbHalInfo->RamSizeMb = 16;
                    pFbHalInfo->RamSize   = 0x01000000;
                    pFbHalInfo->BankCount = 4;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize   = 0x00800000;
                    pFbHalInfo->BankCount = 4;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                    pFbHalInfo->RamSizeMb = 4;
                    pFbHalInfo->RamSize   = 0x00400000;
                    pFbHalInfo->BankCount = 2;
                    break;
                case NV_PFB_BOOT_0_RAM_AMOUNT_2MB:
                    //
                    // This is overloaded in NV4.5 to denote 32meg.  We'll never see a 2meg NV4.
                    //
                    pFbHalInfo->RamSizeMb = 32;
                    pFbHalInfo->RamSize = 0x02000000;
                    pFbHalInfo->BankCount = 2;
                    break;
                default:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal RAM size in NV_PFB_BOOT_0\n\r");
                    DBG_BREAKPOINT();
                    pFbHalInfo->RamSizeMb = 8;
                    pFbHalInfo->RamSize = 0x00800000;
                    pFbHalInfo->BankCount = 4;
                    break;
            }

            //
            // Load config 0 value.
            //
            if (pFbHalInfo->RamSize == 0x00200000)
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _2M);
            else
                FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _BANK_SWAP, _4M);
            
            //
            // Check for UMA usage
            //
            // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
            // bit fields to zero.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
                switch (REG_RD_DRF(_PFB, _BOOT_0, _UMA_SIZE)) {
                    case NV_PFB_BOOT_0_UMA_SIZE_2M:
                        pFbHalInfo->RamSizeMb = 2;
                        pFbHalInfo->RamSize   = 0x00200000;
                        break;                 
                    case NV_PFB_BOOT_0_UMA_SIZE_4M:
                        pFbHalInfo->RamSizeMb = 4;
                        pFbHalInfo->RamSize   = 0x00400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_6M:
                        pFbHalInfo->RamSizeMb = 6;
                        pFbHalInfo->RamSize   = 0x00600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_8M:
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_10M:
                        pFbHalInfo->RamSizeMb = 10;
                        pFbHalInfo->RamSize   = 0x00A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_12M:
                        pFbHalInfo->RamSizeMb = 12;
                        pFbHalInfo->RamSize   = 0x00C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_14M:
                        pFbHalInfo->RamSizeMb = 14;
                        pFbHalInfo->RamSize   = 0x00E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_16M:
                        pFbHalInfo->RamSizeMb = 16;
                        pFbHalInfo->RamSize   = 0x01000000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_18M:
                        pFbHalInfo->RamSizeMb = 18;
                        pFbHalInfo->RamSize   = 0x01200000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_20M:
                        pFbHalInfo->RamSizeMb = 20;
                        pFbHalInfo->RamSize   = 0x01400000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_22M:
                        pFbHalInfo->RamSizeMb = 22;
                        pFbHalInfo->RamSize   = 0x01600000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_24M:
                        pFbHalInfo->RamSizeMb = 24;
                        pFbHalInfo->RamSize   = 0x01800000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_26M:
                        pFbHalInfo->RamSizeMb = 26;
                        pFbHalInfo->RamSize   = 0x01A00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_28M:
                        pFbHalInfo->RamSizeMb = 28;
                        pFbHalInfo->RamSize   = 0x01C00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_30M:
                        pFbHalInfo->RamSizeMb = 30;
                        pFbHalInfo->RamSize   = 0x01E00000;
                        break;
                    case NV_PFB_BOOT_0_UMA_SIZE_32M:
                        pFbHalInfo->RamSizeMb = 32;
                        pFbHalInfo->RamSize   = 0x02000000;
                        break;
                    default:
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Illegal UMA size in NV_PFB_BOOT_0\n\r");
                        DBG_BREAKPOINT();
                        pFbHalInfo->RamSizeMb = 8;
                        pFbHalInfo->RamSize   = 0x00800000;
                        break;
                }

            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV4, this is 128K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV04 * FC_SIZE_NV04;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            // We now do everything tiled (mode switches and fullscreen DOS boxes), so reverting
            // to a boot time non-tiled PFB_CONFIG_0 will corrupt the shutdown splash screen since
            // it was written to a tiled FB. If we're tiled at this point, we'll just stay tiled.
            if (pFbHalPvtInfo->tilingDisabled == TRUE) {
                REG_WR32(NV_PFB_CONFIG_0, pFbHalPvtInfo->fbSave[0]);
                REG_WR32(NV_PFB_CONFIG_1, pFbHalPvtInfo->fbSave[1]);
            }            
            break;
        case FB_CONTROL_INSTWR_DISABLE:
#if 0
            // We have a bug in NV4 hardware which makes the write protection also a read protection.
            // We'll depend on the save above to protect instance memory. If we turn on write protect, it may
            // cause problems on a restart, because either the BIOS image won't be found or can't be copied.
            // 
            //
            // Disable access to instance memory while a full-screen DOS VGA session is active, as they
            // may accidently (intentionally?) clear the entire framebuffer through VGA.
            //
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _DISABLED);
            FLD_WR_DRF_NUM(_PFB, _CONFIG_0, _PRAMIN_WR_MASK, 0x0001);
#endif
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _INIT);
            break;
        case FB_CONTROL_TILING_DISABLE:
            pFbHalPvtInfo->tilingDisabled = TRUE;
            break;
        case FB_CONTROL_TILING_ENABLE:
            pFbHalPvtInfo->tilingDisabled = FALSE;
            break;
        case FB_CONTROL_TILING_CONFIGURE:
            nvHalTetrisTile_NV04(pFbControlArg->pHalHwInfo);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//

// I don't like this #ifdef ... this is just for the nightly build
#ifdef NTRM
#define NV4_PITCHALIGN  0x1F
#else
#define NV4_PITCHALIGN  0x3F
#endif

RM_STATUS
nvHalFbGetSurfacePitch_NV04(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pFbGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfacePitchArg->pitch = ((pFbGetSurfacePitchArg->width * ((pFbGetSurfacePitchArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;

    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width, height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV04(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pFbGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (depending on who you talk to) 32byte/64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pFbGetSurfaceDimensionsArg->pitch = ((pFbGetSurfaceDimensionsArg->width * ((pFbGetSurfaceDimensionsArg->bpp+1) >> 3)) + NV4_PITCHALIGN) & ~NV4_PITCHALIGN;
    pFbGetSurfaceDimensionsArg->size  = pFbGetSurfaceDimensionsArg->pitch * pFbGetSurfaceDimensionsArg->height;

    return RM_OK;
}

//
// nvHalFbAlloc
//
// Reserve a tile if one is available.
//
RM_STATUS
nvHalFbSetAllocParameters_NV04(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

//
// nvHalFbAlloc
//
RM_STATUS
nvHalFbAlloc_NV04(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBALLOCINFO pFbAllocInfo;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbAllocInfo = pFbAllocArg->pAllocInfo;

    //
    // Set default alignment based on type.
    //
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:      
        pFbAllocInfo->align = 0x3f;     // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;     // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;     // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;    // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;      // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;      // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;    // 4096 byte alignment
        break;
    default:
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbFree
//
RM_STATUS
nvHalFbFree_NV04(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV04(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CONFIG_1, pFbLoadOverrideArg->value);
            break;
        case FB_LOAD_OVERRIDE_RTL:
            REG_WR32(NV_PFB_RTL, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp, actual_ram_size = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        base->Reg032[wp/4] = i;
        checksum1 += i;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifo.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFO.C                                                            *
*   The FIFO is managed in this module.  Allocating and controlling the     *
*   FIFO hardware and servicing FIFO exceptions belong here.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20\nv20_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "control.h"
#include "nvhw.h"
#include "smp.h"

#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif


#ifdef DEBUG
U032 findex = 0;
U032 fifolog[MAX_FIFOLOG_LENGTH];
#endif

//---------------------------------------------------------------------------
//
//  FIFO assignment and deassignment to a client.
//
//---------------------------------------------------------------------------

//
// Allocate a User FIFO and return its channel ID.
//
RM_STATUS fifoAlloc
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID
)
{
    U032       i;
    U032       ChID;
    U032       SemaState;
    PCLASS     pClass;
    U032       instSize, instAlign, instance;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // This is an API routine. Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    //
    // Look for unused FIFO.
    //    
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
            
            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r");
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocate FIFO #", ChID);
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create well-known names!\n");
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    nvHalFifoAllocPio(pDev, ChID, instance);
    osExitCriticalCode(pDev);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: fifoAllocate - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));
    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);
    *ChannelID = ChID;
    return (RM_OK);
}
//
// Allocate a User DMA FIFO and return its channel ID.
//
RM_STATUS fifoAllocDma
(
    PHWINFO pDev,
    U032    ClassNum,
    U032   *ChannelID,
    PDMAOBJECT pDmaObject
)
{
    U032       i;
    U032       ChID;
    U032       SemaState;
    U032       fetchTrigger, fetchSize, fetchRequests;
    U032       instSize, instAlign, instance;
    PCLASS     pClass;
    RM_STATUS  status;

    //
    // Make sure this channel class is supported on this chip.
    //
    if (classGetClass(&pDev->classDB, ClassNum, &pClass) == RM_ERROR)
        return RM_ERR_BAD_CLASS;

    //
    // If this class requires additional instance memory, get it now.
    //
    if (pClass->ClassInstMalloc)
    {
        instSize = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);

        if (instAlign)
            status = fbAllocInstMemAlign(pDev, &instance, instSize, instAlign);
        else
            status = fbAllocInstMem(pDev, &instance, instSize);
        if (status)
            return (status);
    }
    else
    {
        instance = 0; instSize = 0;
    }

    //
    // Get default fetch parameters.
    //
    if (osSetFifoDmaParams(pDev, &fetchTrigger, &fetchSize, &fetchRequests))
        return RM_ERR_OPERATING_SYSTEM;

    //
    // This is an API routine. Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    //
    // Look for unused FIFO.
    //    
    for (ChID = 0; ChID < NUM_FIFOS; ChID++)
    {
        if (!pDev->DBfifoTable[ChID].InUse)
        {
            pDev->DBfifoTable[ChID].ObjectCount             = 0;
            pDev->DBfifoTable[ChID].ObjectTree              = NULL;
            pDev->DBfifoTable[ChID].InUse                   = TRUE;
            pDev->DBfifoTable[ChID].IsStalledPendingVblank  = FALSE;
            pDev->DBfifoTable[ChID].StallNotifier           = NULL;
            pDev->DBfifoTable[ChID].Put                     = 0;
            pDev->DBfifoTable[ChID].LastIllegalMthdObject   = NULL;
            for (i=0; i<NUM_SUBCHANNELS; i++)
                pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
            pDev->DBfifoTable[ChID].Instance                = instance;
            pDev->DBfifoTable[ChID].InstanceSize            = instSize;
            break;
        }
    }
    if (ChID == NUM_FIFOS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No allocatable FIFO available.\n\r");
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_NO_FREE_FIFOS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocate FIFO #", ChID);
    //
    // Install CLASS objects into object tree.
    //
    // KJK This goes away once NvAllocObject() is implemented.
    //
    if (classCreateWellKnownObjects(pDev, ChID) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create well-known names!\n");
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (RM_ERR_CANT_CREATE_CLASS_OBJS);
    }

    osEnterCriticalCode(pDev);
    status = nvHalFifoAllocDma(pDev, ChID, instance, pDmaObject->HalInfo.Instance, fetchTrigger, fetchSize, fetchRequests);
    osExitCriticalCode(pDev);
    if (status != RM_OK)
    {
        pDev->DBfifoTable[ChID].InUse = FALSE;
        osSignalSemaphore(&SemaState);
        if (instance) fbFreeInstMem(pDev, instance, instSize);
        return (status);
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: fifoAllocateDma - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);
    *ChannelID = ChID;
    return (RM_OK);
}

//
// Free up a User FIFO to the available pool.
//
RM_STATUS fifoFree
(
    PHWINFO pDev,
    U032    ChID
)
{
    POBJECT           DeadObject;
    U032              SemaState;

    //
    // This is an API routine.  Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing FIFO on ChID: ", ChID);

    //
    // Reset the channel, so it's in an idle state and clear the hashTable
    // for this ChID.
    //
    fifoResetChannelState(pDev, ChID);

    //
    // Remove objects from object database.
    //
    while (pDev->DBfifoTable[ChID].ObjectTree)
    {
        //
        // Free up all remaining objects.
        //                            
        DeadObject = (POBJECT)pDev->DBfifoTable[ChID].ObjectTree->Data;
        fifoDelObject(pDev, DeadObject);
        //
        // Class specific delete procedure.
        //
        //DeadObject->Name = NV_ZOMBIE_OBJECT;
        classDestroy((VOID*)pDev, DeadObject);
    }

#ifdef DEBUG
    if (pDev->DBfifoTable[ChID].ObjectCount != 0)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Object count not zero after deleting object tree!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    pDev->DBfifoTable[ChID].InUse = FALSE;

    //
    // Release any instance memory.  State in fifo object is
    // cleared when it's reallocated.
    //
    if (pDev->DBfifoTable[ChID].Instance != 0)
    {
        fbFreeInstMem(pDev, pDev->DBfifoTable[ChID].Instance, pDev->DBfifoTable[ChID].InstanceSize);
    }
    
    //
    // This is an API routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  HASH table management.
//
//---------------------------------------------------------------------------

//
// Add entry into Hash Table.
//
RM_STATUS fifoAddHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    U032 Hash, Entry, Limit;

    //
    // Query HAL for starting entry for this <handle,chid> pair.
    //
    nvHalFifoHashFunc(pDev, Object->Name, ChID, &Hash);

    //
    // Search table for free slot.
    //
    // We can't exceed the hardware's search limit and we also can't wrap
    // since there's a bug in current chips that prevents the hardware from
    // wrapping on a search.
    //
    Limit = Hash + pDev->Pram.HalInfo.HashSearch;
    if (Limit > pDev->Pram.HalInfo.HashDepth)
        Limit = pDev->Pram.HalInfo.HashDepth;
    for (Entry = Hash; Entry < Limit; Entry++)
    {
        //
        // Find first empty entry.
        //
        if (pDev->DBhashTable[Entry].Object == NULL)
            break;
    }

    if (pDev->DBhashTable[Entry].Object != NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: FIFO Hash table is FULL!!\n\r");
        return (RM_ERROR);
    }

    //
    // Add object to the Hash Table.
    //
    pDev->DBhashTable[Entry].Object = Object;
    pDev->DBhashTable[Entry].ChID   = ChID;

    nvHalFifoHashAdd(pDev, Entry, Object->Name, ChID, Instance,
                     ENGDECL_FIELD(*Object->Class->EngineDecl, _OBJRAMHT));

    return (RM_OK);
}
//
// Remove entry from Hash Table.
//
RM_STATUS fifoDelHashEntry
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID    
)
{
    U032              Entry;
    
    //
    // Skip hashing since we scan the whole table.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object == Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            pDev->DBhashTable[Entry].Object = NULL;
            nvHalFifoHashDelete(pDev, Entry);
            return (RM_OK);
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  FIFO exception handling.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 fifoService
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    V032      intr;
    POBJECT   Object;
    FIFOEXCEPTIONDATA FifoExceptionData;
    U032 i;
#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    status = RM_OK;
    intr   = REG_RD32(NV_PFIFO_INTR_0);

    //
    // Get exception data from HAL.
    //
    nvHalFifoGetExceptionData(pDev, &FifoExceptionData);

    //
    // Here's where we'd bypass HAL fifo exception handling if needed.
    // 

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalFifoService(pDev, intr, &FifoExceptionData);

    //
    // HACK-O-RAMA: Work around a call/return bug where the call stack
    //  register does not get reset.
    //
    intr = REG_RD32(NV_PFIFO_INTR_0);

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        U032 State;

        State =  REG_RD32(NV_PFIFO_CACHE1_DMA_STATE);
 
        if (State == 0x2000D72C || State == 0x2000c054)
        {
            U032 GetPtr;
   
            // Clear condition.
            //
            REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);

            // Fix the bug.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, 0);

            // Wait until idle.
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY);

            // We've moved beyond the instruction that caused the failure.  Set the
            // get pointer back 4 bytes and try it again.
            //
            GetPtr = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, GetPtr-4);

            // Turn the push buffer back on
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

            intr = REG_RD32(NV_PFIFO_INTR_0);
        }
    }
    
    //
    // Refresh interrupt status value in case HAL cleared any exceptions.
    //
    if (intr & DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR, _PENDING))
    {
        //
        // Cache error handler.  We got here due to one of two issues.
        //
        // 1) The current object that was just hashed/routed is configured
        //    as a SW_ENGINE object
        // 2) There is no hash entry available for the current object
        //
                
        //
        // Disable the fifo
        //
        // Don't explicitly disable the puller -- it should already
        // be off by the time we get here.  Verify with an assert().
        //
        REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        FIFOLOG(1, 0, 0);

        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _CACHE_ERROR,  _RESET);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FIFO Cache miss Channel:", FifoExceptionData.ChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                  sub channel:", FifoExceptionData.SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                       method:", FifoExceptionData.Method);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                         data:", FifoExceptionData.Data);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                       reason:", FifoExceptionData.Reason);

        //
        // Timeout
        //
        i = 0xFFFF;
        while (i && (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH_STATE, _BUSY)))
        {
            i--;
            FifoExceptionData.Reason     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        }                

        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED))
        {
            U032 result;
            //
            // On IKOS, we sometimes see spurious hash errors (where looking manually we
            // find the hash entry). If so, clear FifoExceptionData.Reason and allow the HW
            // to retry.
            //
            nvHalFifoHashSearch(pDev, FifoExceptionData.Data, FifoExceptionData.ChID, &result);
            if (result) {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: HW missed valid hash entry:", FifoExceptionData.Data);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                FifoExceptionData.Reason = 0x0;
            } else {
                //
                // Hash failure.  This had better be a master class.
                //
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: FIFO Cache Error due to hash failure\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                     channel:", FifoExceptionData.ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                 sub channel:", FifoExceptionData.SubChannel);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                      offset:", FifoExceptionData.Method);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                        data:", FifoExceptionData.Data);
            }
        }

#ifdef IKOS
        //
        // This captures any unexpected strangeness on IKOS. In particular make
        // sure the engine bits for objects in subchannels agree.
        // 
        if (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
        {
            U032 pull1, engine1;

            // If we find a disagreement in the register engine bits, clear the reason and retry
            pull1   = REG_RD_DRF(_PFIFO, _CACHE1_PULL1, _ENGINE);
            engine1 = (REG_RD32(NV_PFIFO_CACHE1_ENGINE) >> (FifoExceptionData.SubChannel * 4)) & 0xF;

            if (pull1 ^ engine1)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 PULL1/ENGINE differ in engine bits\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                DBG_BREAKPOINT();
                FifoExceptionData.Reason = 0x0;
            } else {
                Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];
                if ((FifoExceptionData.Method >= 0x0100) && !Object)
                {
                    // Retry if this isn't a SetObject method and we never saw the SetObject
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: This should've been a HW method:", FifoExceptionData.Method);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1 get ptr:", FifoExceptionData.GetPtr);
                    DBG_BREAKPOINT();
                    FifoExceptionData.Reason = 0x0;
                }
            }
        }
#endif

        if ((FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _DEVICE, _SOFTWARE))
            || (FifoExceptionData.Reason & DRF_DEF(_PFIFO, _CACHE1_PULL0, _HASH, _FAILED)))
        {
            //
            // Software method
            //
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: FIFO Cache miss due to software object\n\r");
      
            if ((FifoExceptionData.ChID < NUM_FIFOS) && pDev->DBfifoTable[FifoExceptionData.ChID].InUse)
            {
                if (FifoExceptionData.Method < 0x0100)
                {
                    status = fifoSoftwareMethod(pDev, &FifoExceptionData);
                } 
                else
                {                        
                    // 
                    // First we need to find the object to send this method.
                    //
                    // Do this brute force.  Search the whole fifo tree for the object.
                    // 
                    // Go find the minimum value (>0) and start there.  That way we're
                    // sure to visit every node.
                    //
                    Object = pDev->DBfifoTable[FifoExceptionData.ChID].SubchannelContext[FifoExceptionData.SubChannel];
                        
                    //
                    // If we found a valid object, route the method
                    //
                    if (Object)
                    {
                        status = classSoftwareMethod(pDev, Object, FifoExceptionData.Method, FifoExceptionData.Data);

                        //if (status != RM_OK)
                        //    notifyDefaultError(pDev, Object, Method, Data, ChID, status);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: No valid object in subchannel:", FifoExceptionData.SubChannel);
                    }
                }                        
                        
            }    
            else
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", FifoExceptionData.ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", FifoExceptionData.SubChannel);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", FifoExceptionData.Method);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", FifoExceptionData.Data);
            }

            //
            // Advance the FIFO get pointer.
            //
            FifoExceptionData.GetPtr++;
            REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET, _ADDRESS, FifoExceptionData.GetPtr);    // no more gray coding
        }

        //
        // Clear the fifo's hash result
        //
        REG_WR32(NV_PFIFO_CACHE1_HASH, 0);

        //
        // Re-enable cache draining.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _ENABLED);
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _PENDING))
    {
        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT_OVERFLOW, _RESET);
        //
        // RunOut overflow.  Bad news.
        //
        // KJK: Do we wish to attempt to recover from this error?  Maybe close this channel
        // and attempt to recover to other valid channels?
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: ERROR = FIFO runout overflow! Bad News!!!\n\r", intr);
        REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        status = RM_ERR_FIFO_RUNOUT_OVERFLOW;
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _PENDING))
    {
        // create a write cycle to the FB (used as an analyzer trigger).
        fbAddr->Reg032[0] = 0xDEADCAFE;
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA Pusher encountered a parse error.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:     Push Error: ", REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:        Get Ptr: ", REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
//#ifdef MOVETOHAL
        if (IsNV5orBetter(pDev)) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:  Dwords Xfered: ", REG_RD32(NV_PFIFO_CACHE1_DMA_DCOUNT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:    Last jmp at: ", REG_RD32(NV_PFIFO_CACHE1_DMA_GET_JMP_SHADOW));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:       Last cmd: ", REG_RD32(NV_PFIFO_CACHE1_DMA_RSVD_SHADOW));
            //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Last data: ", REG_RD32(NV_PFIFO_CACHE1_DMA_DATA_SHADOW));
        }
//#endif
#ifdef BENSWORK // case 4
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)(PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,4,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif
    
        //
        // Clear condition.
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PUSHER, _RESET);
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        
        //
        // The dma pusher has faulted while processing the push buffer stream.  This is
        // probably due to an invalid jump or bad opcode.
        //
        // Move the get pointer forward if necessary to skip this bad data
        //
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
        {
            U032 GetPtr;

            GetPtr = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, GetPtr+4);
            //
            // This somehow needs to account for rollover, but without parsing the data, I don't
            // know where to roll to.
            //
        }                
    }

    if (intr & DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _PENDING))
    {
#ifdef TRAP_HOST_FIFO_SWITCHES
        // 
        // We're now expect this intr as a way to know what
        // the host FIFO is doing.
        //
        extern U032 dma_inst[32];
        static U032 prev_chid;
        U032 FifoCtxtPtr, fc_data;

        // turnoff reassign
        FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,      "Prev ChID: ", FifoExceptionData.ChID);

        // First, clear out prev_chid FIFO context inst addr, so he faults again
        FifoCtxtPtr = pDev->halHwInfo.pPramHalInfo->FifoContextAddr + (prev_chid * 32);
        fc_data = REG_RD32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)));
        fc_data &= 0xFFFF0000;    // mask off the inst addr
        REG_WR32((U032)(FifoCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), fc_data);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,      "New  ChID: ", FifoExceptionData.ChID);

        // load into HW the inst addr
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, dma_inst[FifoExceptionData.ChID]);

        // Force a reread of the DMA pusher address
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        prev_chid = FifoExceptionData.ChID;

        // turn reassign back on
        FLD_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
#endif

        //
        // Bad news if we get this -- the fifo engine must have attempted to fetch an invalid
        // dma page.  We could attempt to reconstruct what was meant to happen, or we can
        // just barf for now.  I vote for barfing...
        //
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _DMA_PT, _RESET);
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Invalid DMA pusher PTE fetch.\n\r");
#ifdef BENSWORK // case 5
        // external debugger registered?
        if (isDebuggerPresent)
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,5,4,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
        else
        {
            DBG_BREAKPOINT();
        }
#else
        DBG_BREAKPOINT();
#endif
    }
    
    //
    // If the dma pusher is currently suspended, wait until the CACHE1 is empty
    // and then set it running again.
    //
    if (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS) == NV_PFIFO_CACHE1_DMA_PUSH_STATUS_SUSPENDED)
    {
        while (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            // If there's a pending FIFO intr, make this check after servicing it
            if (REG_RD32(NV_PFIFO_INTR_0))
                break;

            // Check if GE needs servicing
            if (REG_RD32(NV_PGRAPH_INTR))
                grService(pDev);

            // Check if vblank needs servicing (for NV15 HW flip)
            if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                VBlank(pDev);
        }
        if (REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        {
            while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			    ;
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
        }
    }

#if 0
    //
    // Re-enable the dma pusher if this was a pusher channel
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {
        //
        // Wait til idle
        //
        while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY);

        //
        // Turn it back on (in the process will also clear DMA_PUSH_STATUS_SUSPENDED)
        //    
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
    }
#endif
    
    //
    // Re-enable FIFO CACHE1 if all conditions cleared.
    //
    if (REG_RD32(NV_PFIFO_INTR_0) == 0x00000000)
    {
#ifdef BENSWORK
        if (mustNotifyDebugger)
        {
            osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
        }
        else
        {
#endif
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
#ifdef BENSWORK
        }
#endif
    }
    intr = REG_RD32(NV_PFIFO_INTR_0);
    //
    // See if there is yet another FIFO exception to be handled.
    // Just need to make sure that "intr" is non-zero in order to
    // get more servicing done.
    //
    intr |= REG_RD_DRF(_PFIFO, _DEBUG_0, _CACHE_ERROR0);
    return (intr);
}

//
// Emulate the device access in software.
//
RM_STATUS fifoSoftwareMethod
(
    PHWINFO pDev,
    PFIFOEXCEPTIONDATA pFifoExceptionData
)
{
    U032 i;
  
    // Dispatch the requested software method
    for (i = 0; i < NvControlClass.MethodMax; i++)
        {
            if ((pFifoExceptionData->Method >= NvControlClass.Method[i].Low)
            &&  (pFifoExceptionData->Method <  NvControlClass.Method[i].High))
            {
            
                return(NvControlClass.Method[i].Proc(pDev,
                                                     pFifoExceptionData->ChID,
                                                     pFifoExceptionData->SubChannel,
                                                     &(NvControlClass.Method[i]),
                                                     pFifoExceptionData->Method,
                                                     pFifoExceptionData->Data));
            }
        }
    //
    // Method not found
    //
    DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: invalid control access ");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", pFifoExceptionData->Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", pFifoExceptionData->Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv10\fbnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV10.c                                                          *
*   The NV10 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV10(VOID *);
RM_STATUS nvHalFbAlloc_NV10(VOID *);
RM_STATUS nvHalFbFree_NV10(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV10(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV10(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV10(VOID *);
RM_STATUS nvHalFbLoadOverride_NV10(VOID *);

// statics
static VOID nvHalFbRoundTiledPitchSize_NV10(U032 *, U032, U032 *);
static U032 nvHalFbRealMemSize(U032, PHWREG);
static U032 calcChkSum(PHWREG, U032);
static void restoreFbSave(U032 *, PHWREG, U032);

// NV10 expects a 1024 byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV10(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i;
    U032 test_mem;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
            U032 extbank, intbank;

            // set ram size
            pFbHalInfo->RamSize = REG_RD32(NV_PFB_CSTATUS);
            pFbHalInfo->RamSizeMb = pFbHalInfo->RamSize / 0x100000;

            // set bank count
            extbank = REG_RD_DRF(_PFB, _CFG, _EXTBANK);
            intbank = REG_RD_DRF(_PFB, _CFG, _BANK);

            // record number of external banks
            if (extbank == NV_PFB_CFG_EXTBANK_1)
                pFbHalInfo->ExtBankCount = 2;
            else
                pFbHalInfo->ExtBankCount = 1;

            // set heap manager bank count
            if (extbank && intbank)
                pFbHalInfo->BankCount = 4;
            else if ((extbank && !intbank) || (!extbank && intbank))
                pFbHalInfo->BankCount = 2;
            else
                pFbHalInfo->BankCount = 1;

            // save off chip-dependent fb state
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG);

            // set ram type
            if (REG_RD_DRF(_PFB, _CFG, _TYPE) == NV_PFB_CFG_TYPE_SDR)
                pFbHalInfo->RamType = BUFFER_SDRAM;
            else
                pFbHalInfo->RamType = BUFFER_DDRAM;


            //CAH:Actually step through memory to verify we have as much there as the BIOS is 
            //telling us. On some "gray" market boards they may be strapped to report 
            //double the actual physical memory.This test will step through the framebuffer
            //to determine if it's actually there.
            test_mem = nvHalFbRealMemSize(pFbHalInfo->RamSizeMb, pHalHwInfo->fbBaseAddr);

            if (pFbHalInfo->RamSizeMb != test_mem) 
            {

                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: RamSize incorrectly read from BIOS\n\r");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resetting RamSize from Memory Test\n\r");
                return (RM_ERROR);
            }

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV10, this is 128K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x20000 + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;
            pFbHalPvtInfo->hashTableAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;
            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));

            //
            // Configure fifo context area.
            //
            pFbHalPvtInfo->fifoContextSize = NUM_FIFOS_NV10 * FC_SIZE_NV10;
            pFbHalPvtInfo->fifoContextAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize + pFbHalPvtInfo->hashTableSize;
            REG_WR_DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize +
                pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = pFbHalPvtInfo->hashTableSize + pFbHalPvtInfo->fifoContextSize + pFbHalPvtInfo->fifoRunoutSize + 512;

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG, pFbHalPvtInfo->fbSave[0]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            HAL_GR_IDLE(pHalHwInfo);
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV10(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    nvHalFbRoundTiledPitchSize_NV10(&pGetSurfacePitchArg->pitch, NULL, NULL);
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV10(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    nvHalFbRoundTiledPitchSize_NV10(&pGetSurfaceDimensionsArg->pitch,
                                    pGetSurfaceDimensionsArg->height,
                                    &pGetSurfaceDimensionsArg->size);
    return RM_OK;
}

static VOID
nvHalFbRoundTiledPitchSize_NV10(U032 *pitch, U032 height, U032 *size)
{

    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
	    ;
}

static VOID
nvHalTilingUpdateResume_NV10
(
    PHALHWINFO pHalHwInfo,
    U032       DmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV10(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbAllocArg->pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        pFbAllocInfo->align = 0x3f;         // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        return (RM_OK);
    }
        
    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;
    nvHalFbRoundTiledPitchSize_NV10(&pitch,
                                    pFbAllocInfo->height,
                                    &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    // tiles are 16K aligned.
    pFbAllocInfo->align = 0x4000 - 1;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV10(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbFreeArg->pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbFreeArg->pHalHwInfo, &dmapush);

    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    

    } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV10(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);


    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pFbSetAllocParamsArg->pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV10(pFbSetAllocParamsArg->pHalHwInfo, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 
    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PFB_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

    } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
             (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
             ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV10(pHalHwInfo, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV10(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
	PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;
    nvAddr = pFbLoadOverrideArg->pHalHwInfo->nvBaseAddr;

    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//CAH: Setup to detect possible alliasing of memory to tell us we have double
//the memory that we actually do. This algorithm will detect the case where
//memory addresses lay on top of eachother so as to make it appear that there
//is twice the memory available than is physically present. 
static U032 nvHalFbRealMemSize(U032 RamSizeMb, PHWREG base)
{
    U032 i, wp, actual_ram_size = 0;
    U032 checksum1 = 0, checksum2 = 0;
    U032 fb_save[128]; 

    //Write 0,1,2,3,...N on each 1mb boundry in the FB
    for (i = 0, wp = 0; i < RamSizeMb; i++, wp += 0x00100000) 
    {
        fb_save[i] = base->Reg032[wp/4];
        base->Reg032[wp/4] = i;
        checksum1 += i;
        checksum2 = calcChkSum(base, i);
        if (checksum1 != checksum2)
        {
            restoreFbSave(fb_save, base, i);
            return i; 
        }
    }

    restoreFbSave(fb_save, base, --i);
    return RamSizeMb; //This means we made it all the way through memory.
}

static void restoreFbSave(U032 *save, PHWREG base, U032 index)
{
    U032 i, wp;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        base->Reg032[wp/4] = save[i];
    }
}

static U032 calcChkSum(PHWREG base, U032 index)
{
    U032 i, wp, checksum = 0;

    for (i = 0, wp = 0; i <= index; i++, wp += 0x00100000)
    {
        checksum += base->Reg032[wp/4];
    }

    return checksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fb\nv20\fbnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Chip Specific HAL FB Routines ********************\
*                                                                           *
* Module: FBNV20.c                                                          *
*   The NV20 specific HAL FB routines reside in this file.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFbControl_NV20(VOID *);
RM_STATUS nvHalFbAlloc_NV20(VOID *);
RM_STATUS nvHalFbFree_NV20(VOID *);
RM_STATUS nvHalFbSetAllocParameters_NV20(VOID *);
RM_STATUS nvHalFbGetSurfacePitch_NV20(VOID *);
RM_STATUS nvHalFbGetSurfaceDimensions_NV20(VOID *);
RM_STATUS nvHalFbLoadOverride_NV20(VOID *);

// statics
static VOID _nvHalFbRoundTiledPitchSize(U032 *, U032, U032 *);
static RM_STATUS _nvHalFbAllocZtags(PHALHWINFO, U032 *, U032 *);
static RM_STATUS _nvHalFbFreeZtags(PHALHWINFO, U032, U032);

// NV20 expects a 1024byte alignment
#define FC_MIN_ALIGN_SHIFT      10

//
// Macro for mirroring PFB reg values into texture cache via RDI.
//
#define RDI_REG_WR32(select, addr, data)    \
    {                                       \
        REG_WR32(NV_PGRAPH_RDI_INDEX,       \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     \
        REG_WR32(NV_PGRAPH_RDI_DATA, data);                         \
    }

#define RDI_REG_RD32(select, addr, data)    \
    {                                       \
        REG_WR32(NV_PGRAPH_RDI_INDEX,       \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     \
        data = REG_RD32(NV_PGRAPH_RDI_DATA);                        \
    }

//
// nvHalFbControl
//
RM_STATUS
nvHalFbControl_NV20(VOID *arg)
{
    PFBCONTROLARG_000 pFbControlArg = (PFBCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO pFbHalInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbControlArg->id != FB_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbControlArg->pHalHwInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFbControlArg->cmd)
    {
        case FB_CONTROL_INIT:
        {
#if 0
            U032 cfg0, cfg1;
#endif
            U032 tmpAddr;

            //
            // Setup bank count.
            //
            pFbHalInfo->BankCount = REG_RD_DRF(_PFB, _CFG0, _PARTSENSE) + 1;

            //
            // Save off chip-dependent fb state.
            //
            pFbHalPvtInfo->fbSave[0] = REG_RD32(NV_PFB_CFG0);
            pFbHalPvtInfo->fbSave[1] = REG_RD32(NV_PFB_CFG1);

            //
            // Set ram type.
            //
            if (REG_RD_DRF(_PBUS, _FBIO_RAM, _TYPE) == NV_PBUS_FBIO_RAM_TYPE_SDR)
                pFbHalInfo->RamType = BUFFER_SDRAM;
            else
                pFbHalInfo->RamType = BUFFER_DDRAM;

            //
            // Set ram size.  Beginning with nv20, we need to
            // support external banks of possibly differing sizes.
            // Start by calculating size of primary bank and then
            // adding size of secondary bank if it exists.
            //
            // The formula (from James Van Dyke):
            //
            //  mem_in_bytes = (1 << (R + B + C + P)) * 4bytes, P=0,1,2
            //      R = row bits
            //      B = bank bits
            //      C = column bits
            //      P = partition count
            //

#if 0
            //
            // Set external bank count.
            //
            cfg0 = REG_RD32(NV_PFB_CFG0);
            cfg1 = REG_RD32(NV_PFB_CFG1);

            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
                pFbHalInfo->ExtBankCount = 2;
            else
                pFbHalInfo->ExtBankCount = 1;

            //
            // Calculate primary external bank size.
            //
            size = (1 << (DRF_VAL(_PFB, _CFG1, _COL, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _ROWA, cfg0) +
                          DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) +
                          DRF_VAL(_PFB, _CFG0, _PART, cfg0))) * 4;
            pFbHalInfo->ExtBanks[0].size = size;
            pFbHalInfo->ExtBanks[0].intBanks = DRF_VAL(_PFB, _CFG1, _BANKA, cfg0) + 1;

            //
            // Check for secondary external bank.
            //
            if (DRF_VAL(_PFB, _CFG0, _EXTBANK, cfg0) == NV_PFB_CFG0_EXTBANK_1)
            {
                size = (1 << (DRF_DEF(_PFB, _CFG1, _COL, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _ROWB, cfg1) +
                              DRF_DEF(_PFB, _CFG1, _BANKB, cfg1) +
                              DRF_DEF(_PFB, _CFG0, _PART, cfg0))) * 4;
                pFbHalInfo->ExtBanks[1].size = size;
                pFbHalInfo->ExtBanks[1].intBanks = DRF_VAL(_PFB, _CFG1, _BANKB, cfg0) + 1;
            }
#ifdef DEBUG
            //
            // Debug calculated size vs hard-wired value.
            //
            if (size != REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: framebuffer size miscalculation ", size);
                DBG_BREAKPOINT();
            }

            //
            // Generate a debug message if the MS bit is actually set.
            //
            if (REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_MS))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: > 4G of framebuffer indicated!!");
                DBG_BREAKPOINT();
            }
#endif
#endif

            pFbHalInfo->RamSizeMb = REG_RD_DRF(_PFB, _CSTATUS, _RAMAMOUNT_LS);
            pFbHalInfo->RamSize = pFbHalInfo->RamSizeMb * 0x100000;

            //
            // Initialize ZTAG bitmap (0=allocated, 1=free).
            //
            for (i = 0; i < MAX_ZTAG_BITS/8; i++)
                pFbHalPvtInfo->zTagPool[i] = 0xff;

            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
                pFbHalPvtInfo->zCompState[i].size = 0;
            }

            //
            // Set partition count.
            // 0=1partition, 1=2partitions, 3=4partitions (default).
            //
            pFbHalPvtInfo->partitions = REG_RD_DRF(_PFB, _CFG0, _PART) + 1;

            //
            // Set instance space size.  Add in whatever os-dependent
            // (i.e. BIOS) space is needed as well.
            //
            // For NV20, this is 576K allocatable.
            //
            pPramHalInfo->TotalInstSize = 0x90000 + pPramHalInfo->InstPadSize;

            //
            // The start of all of these space is after the BIOS
            // (denoted by InstPadSize).
            //
            tmpAddr = DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize;

            //
            // Configure hash table.
            //
            pFbHalPvtInfo->hashTableSize = 0x4000;
            pPramHalInfo->HashDepth = pFbHalPvtInfo->hashTableSize / sizeof (HASH_TABLE_ENTRY);
            pPramHalInfo->HashSearch = 128;

            pFbHalPvtInfo->hashTableAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->hashTableSize;

            REG_WR32(NV_PFIFO_RAMHT, (DRF_DEF(_PFIFO, _RAMHT, _SIZE, _16K) |
                                      DRF_NUM(_PFIFO, _RAMHT, _BASE_ADDRESS, (pFbHalPvtInfo->hashTableAddr - DEVICE_BASE(NV_PRAMIN)) >> 12) |
                                      DRF_DEF(_PFIFO, _RAMHT, _SEARCH, _128)));
            
            //
            // Configure fifo context areas.
            // NV20 has two distinct context areas.
            //
            pFbHalPvtInfo->fifoContextSize1 = NUM_FIFOS_NV20 * FC1_SIZE_NV20;
            pFbHalPvtInfo->fifoContextSize2 = NUM_FIFOS_NV20 * FC2_SIZE_NV20;

            pFbHalPvtInfo->fifoContextAddr1 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize1;
            pFbHalPvtInfo->fifoContextAddr2 = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoContextSize2;

            REG_WR32(NV_PFIFO_RAMFC,
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS, ((pFbHalPvtInfo->fifoContextAddr1 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))) |
                     DRF_DEF(_PFIFO, _RAMFC, _SIZE, _2K) |
                     (DRF_NUM(_PFIFO, _RAMFC, _BASE_ADDRESS2, ((pFbHalPvtInfo->fifoContextAddr2 - DEVICE_BASE(NV_PRAMIN)) >> FC_MIN_ALIGN_SHIFT))));

            //
            // Configure runout area.
            //
            pFbHalPvtInfo->fifoRunoutSize = 512;
            pFbHalPvtInfo->fifoRunoutAddr = tmpAddr;
            tmpAddr += pFbHalPvtInfo->fifoRunoutSize;
            pFbHalPvtInfo->fifoRunoutMask = pFbHalPvtInfo->fifoRunoutSize - 1;
            REG_WR32(NV_PFIFO_RAMRO, (DRF_DEF(_PFIFO, _RAMRO, _SIZE, _512) |
                                      DRF_NUM(_PFIFO, _RAMRO, _BASE_ADDRESS, (pFbHalPvtInfo->fifoRunoutAddr - DEVICE_BASE(NV_PRAMIN)) >> 9)));

            //
            // Sum of all allocations plus a little slop
            //
            pPramHalInfo->CurrentSize  = (tmpAddr + 512) - (DEVICE_BASE(NV_PRAMIN) + pPramHalInfo->InstPadSize);

            break;
        }
        case FB_CONTROL_LOAD:
            break;
        case FB_CONTROL_UNLOAD:
            break;
        case FB_CONTROL_UPDATE:
            break;
        case FB_CONTROL_DESTROY:
            REG_WR32(NV_PFB_CFG0, pFbHalPvtInfo->fbSave[0]);
            REG_WR32(NV_PFB_CFG1, pFbHalPvtInfo->fbSave[1]);
            break;
        case FB_CONTROL_INSTWR_DISABLE:
            // disable writes by enabling  protection
            switch (pPramHalInfo->TotalInstSize)
            {
                case 0xA0000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _640K);
                    break;
                case 0x30000:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _192K);
                    break;
                case 0x20000:
                default:
                    FLD_WR_DRF_DEF(_PFB, _NVM, _LIMIT, _128K);
                    break;
            }
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _ENABLE);
            break;
        case FB_CONTROL_INSTWR_ENABLE:
            // enable writes by disabling write protection
            FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
            break;
        case FB_CONTROL_TILING_DISABLE:
            HAL_GR_IDLE(pHalHwInfo);

            // TILE region registers
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
                REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                             NV_PFB_TILE_REGION_INVALID);
            }

            // ZCOMP_OFFSET register
            REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, NV_PFB_ZCOMP_OFFSET_EN_FALSE);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZOFFSET_ADDRESS,
                         NV_PFB_ZCOMP_OFFSET_EN_FALSE);

            // ZCOMP region registers
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                REG_WR32(NV_PFB_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                REG_WR32(NV_PGRAPH_ZCOMP(i), NV_PFB_ZCOMP_EN_FALSE);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             NV_PFB_ZCOMP_EN_FALSE);
            }
            break;
        case FB_CONTROL_TILING_ENABLE:
            // this is treated as an error on nv10 (???)
            return (RM_ERR_BAD_ARGUMENT);
        case FB_CONTROL_TILING_CONFIGURE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFbGetSurfacePitch
//
// Given a width and bits per pixel, return the surface pitch
//
RM_STATUS
nvHalFbGetSurfacePitch_NV20(VOID *arg)
{
    PFBGETSURFACEPITCHARG_000 pGetSurfacePitchArg = (PFBGETSURFACEPITCHARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfacePitchArg->id != FB_GET_SURFACE_PITCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfacePitchArg->pitch = ((pGetSurfacePitchArg->width * ((pGetSurfacePitchArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;

    if (pGetSurfacePitchArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    _nvHalFbRoundTiledPitchSize(&pGetSurfacePitchArg->pitch, NULL, NULL);
    return RM_OK;
}

//
// nvHalFbGetSurfaceDimensions
//
// Given a width/height and bits per pixel, return the surface pitch and size
//
RM_STATUS
nvHalFbGetSurfaceDimensions_NV20(VOID *arg)
{
    PFBGETSURFACEDIMENSIONSARG_000 pGetSurfaceDimensionsArg = (PFBGETSURFACEDIMENSIONSARG_000)arg;
    
    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGetSurfaceDimensionsArg->id != FB_GET_SURFACE_DIMENSIONS_000)
        return (RM_ERR_VERSION_MISMATCH);

    // surfaces are (at least) 64byte aligned
    // Watch out for bpp==15: add 1 here to force 15 to 16 for the shift
    pGetSurfaceDimensionsArg->pitch = ((pGetSurfaceDimensionsArg->width * ((pGetSurfaceDimensionsArg->bpp+1) >> 3)) + 0x3F) & ~0x3F;
    pGetSurfaceDimensionsArg->size  = pGetSurfaceDimensionsArg->pitch * pGetSurfaceDimensionsArg->height;
        
    if (pGetSurfaceDimensionsArg->flags & FB_GET_SURFACE_PITCH_NO_ADJUST)
        return RM_OK;

    _nvHalFbRoundTiledPitchSize(&pGetSurfaceDimensionsArg->pitch,
                                pGetSurfaceDimensionsArg->height,
                                &pGetSurfaceDimensionsArg->size);
    return RM_OK;
}

static VOID
_nvHalFbRoundTiledPitchSize(U032 *pitch, U032 height, U032 *size)
{

    // adjust the pitch, if necessary
    if (*pitch <= 0x200)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0200);
    else if (*pitch <= 0x400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0400);
    else if (*pitch <= 0x600)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0600);
    else if (*pitch <= 0x800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0800);
    else if (*pitch <= 0xA00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0A00);
    else if (*pitch <= 0xC00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0C00);
    else if (*pitch <= 0xE00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _0E00);
    else if (*pitch <= 0x1000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1000);
    else if (*pitch <= 0x1400)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1400);
    else if (*pitch <= 0x1800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1800);
    else if (*pitch <= 0x1C00)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _1C00);
    else if (*pitch <= 0x2000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2000);
    else if (*pitch <= 0x2800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _2800);
    else if (*pitch <= 0x3000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3000);
    else if (*pitch <= 0x3800)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _3800);
    else if (*pitch <= 0x4000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _4000);
    else if (*pitch <= 0x5000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _5000);
    else if (*pitch <= 0x6000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _6000);
    else if (*pitch <= 0x7000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _7000);
    else if (*pitch <= 0x8000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _8000);
    else if (*pitch <= 0xA000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _A000);
    else if (*pitch <= 0xC000)
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _C000);
    else
        *pitch = DRF_DEF(_PFB, _TSIZE, _PITCH, _E000);

    if (size) {
        U032 hzmult;

        // set size given possibly adjusted pitch
        *size = *pitch * height;

        //
        // Round size to an even multiple of horizontal tiles. Remapping occurs
        // within addresses of length (pitch * tile_height * 2) in the vertical
        // direction (where the max TILE_HEIGHT is 16 lines).
        //
        hzmult = *pitch * (16 * 2);
        *size = ((*size + (hzmult - 1)) / hzmult) * hzmult;
    }
}

//
// Before updating the tiling registers (in particular, the PGRAPH version),
// idle graphics as best as possible.
//
// If we're not GR_IDLE during these writes to the PGRAPH registers, these
// writes can be dropped leaving the PFB and PGRAPH regs inconsistent. The
// idle/resume routines are called during FreeTiledRange/ProgramTiledRange.
//
static VOID
nvHalTilingUpdateIdle_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       *pDmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Empty FIFO and runout.
    while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
        || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
    {
        // Make sure we process any fifo interrupts
        HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

        // Check if GE needs servicing.
        if (REG_RD32(NV_PGRAPH_INTR))
            HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

        // Check if vblank needs servicing.
        if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
            HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
    }

    // Disable the dma pusher
    *pDmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

    // Wait until the DMA pusher is idle
    while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
	    ;
}

static VOID
nvHalTilingUpdateResume_NV20
(
    PHALHWINFO pHalHwInfo,
    U032       DmaPush
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // Restore the dma pusher state
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, DmaPush);
}

//
// nvHalFbAlloc
//
// Update user alloc request parameter according to memory
// type and (possibly) reserve hw resources.
//
RM_STATUS
nvHalFbAlloc_NV20(VOID *arg)
{
    PFBALLOCARG_000 pFbAllocArg = (PFBALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    U032 i, pitch, size;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbAllocArg->id != FB_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbAllocArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbAllocArg->pAllocInfo;
    
    // Set default alignment based on type.
    switch (pFbAllocInfo->type) {
    case MEM_TYPE_IMAGE:
    case MEM_TYPE_OVERLAY:
        pFbAllocInfo->align = 0x3f;         // 64 byte alignment
        break;
    case MEM_TYPE_TEXTURE:
        pFbAllocInfo->align = 0xff;         // 256 byte alignment
        break;
    case MEM_TYPE_FONT:
        pFbAllocInfo->align = 0x1f;         // 32 byte alignment
        break;
    case MEM_TYPE_CURSOR:
        pFbAllocInfo->align = 0x7ff;        // 2048 byte alignment
        break;
    case MEM_TYPE_DMA:
        pFbAllocInfo->align = 0x3;          // 4 byte alignment
        break;
    case MEM_TYPE_INSTANCE:
        pFbAllocInfo->align = 0xf;          // 16 byte alignment
        break;
    case MEM_TYPE_DEPTH:
    case MEM_TYPE_DEPTH_COMPR16:
    case MEM_TYPE_DEPTH_COMPR32:
    case MEM_TYPE_PRIMARY:
    case MEM_TYPE_IMAGE_TILED:
        pFbAllocInfo->align = 0xfff;        // 4096 byte alignment
        break;
    default:
        // should this be 0xffffffff
        pFbAllocInfo->align = 0;
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // A non-zero pitch value indicates the user wants tiled memory
    // (if available).  If the pitch is 0, we're done.
    //
    if (pFbAllocInfo->pitch == 0)
    {
        return (RM_OK);
    }
        
    // Now allocate a TILE_RANGE
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        if ((pFbHalPvtInfo->usedTiles & MEM_TYPE_TILE_RANGE_SHIFT(i)) == 0)
        {
            pFbHalPvtInfo->usedTiles |= MEM_TYPE_TILE_RANGE_SHIFT(i);
            break;
        }
    }
    if (i == NV_PFB_TILE__SIZE_1)
    {
        return (RM_ERR_INSUFFICIENT_RESOURCES);
    }

    pitch = pFbAllocInfo->pitch;

    _nvHalFbRoundTiledPitchSize(&pitch, pFbAllocInfo->height, &size);

    //
    // If we're not allowing the pitch to be adjusted, we can only tile the surface
    // if the pitch is already HW aligned.
    // 
    if ((pFbAllocArg->flags & FB_ALLOC_NO_PITCH_ADJUST) && (pitch != pFbAllocInfo->pitch))
    {
        // requires rounding, so give back the range and fail the alloc
        pFbHalPvtInfo->usedTiles &= ~MEM_TYPE_TILE_RANGE_SHIFT(i);
        pFbAllocInfo->hwResId = 0;
        return (RM_OK);
    }

    // tiles are 16K aligned.
    pFbAllocInfo->align = 0x4000 - 1;

    // return adjusted pitch and size
    pFbAllocInfo->pitch = pitch;
    pFbAllocInfo->size  = size;

    pFbAllocInfo->hwResId = MEM_TYPE_TILE_RANGE_SHIFT(i);
    return (RM_OK);
}

//
// nvHalFbFree
//
// Release tile back to the free pool.
//
RM_STATUS
nvHalFbFree_NV20(VOID *arg)
{
    PFBFREEARG_000 pFbFreeArg = (PFBFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbFreeArg->id != FB_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbFreeArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pFbFreeArg->pHalHwInfo->nvBaseAddr;

    //
    // Bail out now if there's no resource id.
    if (!pFbFreeArg->hwResId)
        return (RM_OK);

    // convert range bits to a TILE index
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbFreeArg->hwResId & MEM_TYPE_TILE_RANGE_SHIFT(i))
                break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing TILE Range:   ", i);

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbFreeArg->pHalHwInfo, &dmapush);

    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pFbFreeArg->pHalHwInfo);

        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     NV_PFB_TILE_REGION_INVALID);
    } while (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)));

    //
    // Free any z compression resources.
    //
    if (pFbHalPvtInfo->zCompState[i].offset != MAX_ZTAG_BITS && pFbHalPvtInfo->zCompState[i].size != 0)
    {
        _nvHalFbFreeZtags(pHalHwInfo, pFbHalPvtInfo->zCompState[i].offset, pFbHalPvtInfo->zCompState[i].size);
        pFbHalPvtInfo->zCompState[i].offset = MAX_ZTAG_BITS;
        pFbHalPvtInfo->zCompState[i].size = 0;
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmapush);

    // mark it free
    pFbHalPvtInfo->usedTiles &= ~pFbFreeArg->hwResId;

    return (RM_OK);
}

//
// nvHalFbSetAllocParameters
//
// Associate memory block (base/limit) with hardware resources.
//
RM_STATUS
nvHalFbSetAllocParameters_NV20(VOID *arg)
{
    PFBSETALLOCPARAMSARG_000 pFbSetAllocParamsArg = (PFBSETALLOCPARAMSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PFBALLOCINFO pFbAllocInfo;
    PHWREG nvAddr;
    U032 i, dmapush;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFbSetAllocParamsArg->id != FB_SET_ALLOC_PARAMS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbSetAllocParamsArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFbAllocInfo = pFbSetAllocParamsArg->pAllocInfo;
    nvAddr = pFbSetAllocParamsArg->pHalHwInfo->nvBaseAddr;

    //
    // Bail out if this allocation didn't reserve any tiling regs.
    //
    if (pFbAllocInfo->hwResId == 0)
        return (RM_OK);

    //
    // Convert range bits to a TILE index.
    //
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
        if (pFbAllocInfo->hwResId == (U032)MEM_TYPE_TILE_RANGE_SHIFT(i))
            break;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Programming TILE Range:   ", i);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:          Base =   ", pFbAllocInfo->offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Limit =   ", pFbAllocInfo->offset + (pFbAllocInfo->size - 1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         Pitch =   ", pFbAllocInfo->pitch);

    if (pFbAllocInfo->offset & 0x3fff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Base\n");
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        return (RM_OK);
    }
    if (pFbAllocInfo->size & 0x3fff)
    {
        // mark it free
        pFbHalPvtInfo->usedTiles &= ~pFbAllocInfo->hwResId;
        // invalidate the range
        REG_WR32(NV_PFB_TILE(i), NV_PFB_TILE_REGION_INVALID);
        REG_WR32(NV_PGRAPH_TILE(i), NV_PFB_TILE_REGION_INVALID);    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: unaligned Limit\n");
        return (RM_OK);
    }

    // idle graphics, so we can update the PGRAPH registers
    nvHalTilingUpdateIdle_NV20(pFbSetAllocParamsArg->pHalHwInfo, &dmapush);

    //
    // Note: due to a PFB_TLIMIT readback bug, only compare the upper bits
    // when checking for PFB_TLIMIT/PGRAPH_TLIMIT consistency.
    // 
    do {
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        REG_WR32(NV_PFB_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PFB_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PFB_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        REG_WR32(NV_PGRAPH_TLIMIT(i), pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        REG_WR32(NV_PGRAPH_TSIZE(i), pFbAllocInfo->pitch);
        REG_WR32(NV_PGRAPH_TILE(i), pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));

        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TLIMIT_ADDRESS(i),
                     pFbAllocInfo->offset + pFbAllocInfo->size - 1);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TPITCH_ADDRESS(i),
                     pFbAllocInfo->pitch);
        RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                     NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                     pFbAllocInfo->offset | DRF_DEF(_PFB, _TILE, _REGION, _VALID));
    } while ((REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i))) ||
             (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i))) ||
             ((REG_RD32(NV_PFB_TLIMIT(i)) & ~0x3FFF) != (REG_RD32(NV_PGRAPH_TLIMIT(i)) & ~0x3FFF)));

    //
    // Handle Z compression.
    //
    if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR16 || pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
    {
        U032 offset, size, data;
       
        //
        // Find offset into ZTag table of range we'll associate with
        // this block of memory.
        //
        // Each Ztag maps to a single 64byte tile per partition.
        //
        size = pFbAllocInfo->size / (pFbHalPvtInfo->partitions * 64);
        if (_nvHalFbAllocZtags(pHalHwInfo, &size, &offset) == RM_OK)
        {
            // save off ztag region state
            pFbHalPvtInfo->zCompState[i].offset = offset;
            pFbHalPvtInfo->zCompState[i].size = size;

            // initialize offset into ztag pool
            data = DRF_NUM(_PFB, _ZCOMP, _BASE_TAG_ADR, offset) |
                DRF_DEF(_PFB, _ZCOMP, _EN, _TRUE);

            // mode (16 or 32bit)
            if (pFbAllocInfo->type == MEM_TYPE_DEPTH_COMPR32)
                data |= DRF_DEF(_PFB, _ZCOMP, _MODE, _32);

            // enable big endian mode if applicable
            if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
                data |= DRF_DEF(_PFB, _ZCOMP, _ENDIAN, _BIG);

            //
            // TODO: enable antialiasing...
            //

            do {
                // Now, wait until graphics is idle
                HAL_GR_IDLE(pHalHwInfo);

                REG_WR32(NV_PFB_ZCOMP(i), data);
                REG_WR32(NV_PGRAPH_ZCOMP(i), data);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             data);
            } while (REG_RD32(NV_PFB_ZCOMP(i)) != REG_RD32(NV_PGRAPH_ZCOMP(i)));
        }
    }

    // resume graphics, now that PFB/PGRAPH are consistent
    nvHalTilingUpdateResume_NV20(pHalHwInfo, dmapush);

    return (RM_OK);
}

RM_STATUS
nvHalFbLoadOverride_NV20(VOID *arg)
{
    PFBLOADOVERRIDEARG_000 pFbLoadOverrideArg = (PFBLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pFbLoadOverrideArg->id != FB_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFbLoadOverrideArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    switch (pFbLoadOverrideArg->cmd)
    {
        case FB_LOAD_OVERRIDE_MEMORY:
            REG_WR32(NV_PFB_CFG0, pFbLoadOverrideArg->value);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// Z Compression management.
//
// Here's some details from the _HOW_TO_MAP_Z_COMPRESS_TAG_BITS_
// document in the NV20 Architecture database:
//
// (1) Z tag bits only live in compressed regions.
// (2) Only tiled regions can be compressed.
// (3) There is one Z tag bit per (64byte) packet.
// (4) One packet maps to one partition.
// (5) A ZCOMP_BASE_TAG_ADR exists for each region.  They define the tag
//     bit offset into each partition's tag RAM.  All RAMs in each partition
//     get the same address.
// (6) A region uses RAM tag bits starting at the ZCOMP_BASE_TAG_ADR.
//     RAM tag bits are allocated until the end of the memory region, or
//     until they run out, whichever is first.
// (7) ZCOMP_MAX_TAG_ADR specifies how many bits exist in each
//     partition tag RAM.
//
// There are two new memory types that the drivers can use to request
// compressed depth buffers:
//
//  MEM_TYPE_DEPTH_COMPR16 - 16bit compression
//  MEM_TYPE_DEPTH_COMPR32 - 32bit compression
//
// When the tiling parameters are programmed up for one of these
// memory types, we scan the Z tag pool (a bitmap) for any free
// bits.  Because of (6), we can partially compress a region, which
// we will do as a last resort.
//
static RM_STATUS
_nvHalFbAllocZtags(PHALHWINFO pHalHwInfo, U032 *size, U032 *offset)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;
    U032 bestSize, bestOffset;
    U032 i, j;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Error check incoming size parameter.
    //
    if (*size == 0)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: zero size to ztag allocator\n");
        *offset = MAX_ZTAG_BITS;                // out of range value
        DBG_BREAKPOINT();
    }

    bestSize = 0;
    bestOffset = MAX_ZTAG_BITS;
    for (i = 0; i < MAX_ZTAG_BITS; i++)
    {
        if (!pFbHalPvtInfo->zTagPool[i >> 3])
        {
            i += 7;
        }
        else if (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;

            do
            {
                if ((++i >= MAX_ZTAG_BITS) || (++j >= *size))
                    break;
            }
            while (pFbHalPvtInfo->zTagPool[i >> 3] & BIT(i & 7));


            if (j == *size)
            {
                *offset = i - j;
                while (j--)
                {
                    i--;
                    pFbHalPvtInfo->zTagPool[i >> 3] &= ~BIT(i & 7);
                }
                return (RM_OK);
            }

            //
            // If this is the best range so far, save it off.
            //
            if (j != 0 && j > bestSize)
            {
                bestSize = j;
                bestOffset = i - j;
            }
        }
    }

    //
    // If we found _any_ ranges, use the biggest one...
    //
    if (bestSize != 0)
    {
        *offset = bestOffset;
        *size = bestSize;
        return (RM_OK);
    }

    *offset = MAX_ZTAG_BITS;
    *size = 0;

    return (RM_ERR_NO_FREE_MEM);
}


static RM_STATUS
_nvHalFbFreeZtags(PHALHWINFO pHalHwInfo, U032 offset, U032 size)
{
    PFBHALINFO_NV20 pFbHalPvtInfo;

    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;

    //
    // Validate range.
    //
    if (offset + size > MAX_ZTAG_BITS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad ZTag pool parameters: offset ", offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: size ", size);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // Mark range free.
    //
    while (size--)
    {
        pFbHalPvtInfo->zTagPool[offset >> 3] |= BIT(offset & 7);
        offset++;
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRSTATE.C                                                         *
*   The graphics state is changed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
//
// Externs.
//
extern char strDevNodeRM[];

//
// Change graphics hardware state.
//
RM_STATUS stateGr
(
    PHWINFO pDev,
    U032    msg
)
{
    U032    data32;

    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Disable data from fifo.
            //
            REG_WR32(NV_PGRAPH_FIFO, 0x0);

            // Ignore return code.
            (void) nvHalGrControl(pDev, GR_CONTROL_LOAD);

            // save off this registry value (to be loaded later)
            if (IsNV15orBetter(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "SwathMultWidth", &data32) == RM_OK))
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, data32 | SWATH_CONTROL_VALID_BIT);
            else
                nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_SWATHCTL, 0);

            //
            // Reset and enabled the interrupts.
            //
            REG_WR32(NV_PGRAPH_INTR,    0xFFFFFFFF);
            REG_WR32(NV_PGRAPH_INTR_EN, 0xFFFFFFFF);
            
            pDev->Graphics.Enabled = TRUE;
            
            break;
        case STATE_UNLOAD:
            if (pDev->Graphics.Enabled)
            {
                //
                // Set disabled flag.
                //
                pDev->Graphics.Enabled = FALSE;
                
                //
                // Idle the graphics engine.
                //
                // XXXscottl - Potential calls to any of the engine
                // interrupt service routines need to be mutexed.
                // We have a problem here because we can be called
                // as a result of a win9x class-driven modeset (in which
                // case the higher-level mcService routine will have
                // grabbed the spinlock) or because of a winnt-type
                // modeset (in which case no lock is held).
                //
                GR_IDLE();

                //
                // Pull out current graphics state.
                //
                (void) nvHalGrControl(pDev, GR_CONTROL_UNLOAD);
                
                //
                // Disable data access from fifo.
                //
                REG_WR32(NV_PGRAPH_FIFO,    0x00000000);
                REG_WR32(NV_PGRAPH_INTR_EN, 0x00000000);
            }
            break;
        case STATE_INIT:
        {
            U032 i;
            RM_STATUS status;

            //
            // Allocate/initialize the graphics engine class allocation
            // locks.
            //
            status = osAllocMem((VOID **)&pDev->Graphics.ClassLocks, sizeof (U032) * NUM_FIFOS);
            if (status)
                return (status);

            for (i = 0; i < NUM_FIFOS; i++)
            {
                ((U032 *)(pDev->Graphics.ClassLocks))[i] = 0;
            }

            pDev->Graphics.Enabled = FALSE;
            
            //
            // Handle any hardware dependent initialization now.
            //
            nvHalGrControl(pDev, GR_CONTROL_INIT);

            //
            // Clear VBlank list.
            //
            pDev->DBgrVBlankList[0] = NULL;
            pDev->DBgrVBlankList[1] = NULL;
            //
            // Load any overrides.
            //
            initGrEx(pDev);
            break;
        }
        case STATE_DESTROY:
            osFreeMem((VOID *)pDev->Graphics.ClassLocks);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv\fifoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFOOBJ.C                                                         *
*   The FIFO objects are managed in this module.  All modifications to the  *
*   object tree are handled here.  The object tree is a balanced tree       *
*   implementation.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <class.h>
#include <fifo.h>
#include <os.h>
#include "nvhw.h"

//
// Fifo object routines.
//

RM_STATUS fifoAddObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;
    PNODE     node;

    DBG_VAL_PTR(Object);
    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
    if (status == RM_OK)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    Object->Node.Value = Object->Name;
    Object->Node.Data  = Object;
    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
    {
        //
        // Balance tree after every 16th object addition.
        //
        if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
            btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
    }
    return (status);    
}

// jsw...
// 
// cwj: we don't add the DMA context object to the fifoTable
// in NV4 (not called from RmBindDmaContext).
//
//RM_STATUS fifoAddDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//    PNODE     node;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[Object->ChID].ObjectTree);
//    status = btreeSearch(Object->Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
//    if (status == RM_OK)
//        return (RM_ERR_INSERT_DUPLICATE_NAME);
//    Object->Node.Value = Object->Name;
//    Object->Node.Data  = Object;
//    //status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeInsert(&(Object->Node), &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//    {
//        //
//        // Balance tree after every 16th object addition.
//        //
//        //if ((++pDev->DBfifoTable[Object->ChID].ObjectCount & 0x0F) == 0x00)
//        if ((++pDev->DBfifoTable[ChID].ObjectCount & 0x0F) == 0x00)
//            //btreeBalance(&(pDev->DBfifoTable[Object->ChID].ObjectTree));
//            btreeBalance(&(pDev->DBfifoTable[ChID].ObjectTree));
//    }
//    return (status);    
//}

RM_STATUS fifoDelObject
(
	PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    DBG_VAL_PTR(Object);
    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
    if (status == RM_OK)
        pDev->DBfifoTable[Object->ChID].ObjectCount--;

    if (pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject == Object)
    {
        pDev->DBfifoTable[Object->ChID].LastIllegalMthdObject = NULL;
    }
    return (status);    
}

// jsw...
//
// cwj: wasn't added above, so no need to delete it.
//
//RM_STATUS fifoDelDmaObject
//(
//	PHWINFO pDev,
//    POBJECT Object,
//	U032 ChID
//)
//{
//    RM_STATUS status;
//
//    DBG_VAL_PTR(Object);
//    //status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[Object->ChID].ObjectTree));
//    status = btreeDelete(Object->Node.Value, &(pDev->DBfifoTable[ChID].ObjectTree));
//    if (status == RM_OK)
//        //pDev->DBfifoTable[Object->ChID].ObjectCount--;
//        pDev->DBfifoTable[ChID].ObjectCount--;
//    return (status);    
//}

RM_STATUS fifoSearchObject
(
	PHWINFO  pDev,
    U032     Name,
    U032     ChID,
    POBJECT *Object
)
{
    RM_STATUS status;
    PNODE     node;
    
    status = btreeSearch(Name, &node, pDev->DBfifoTable[ChID].ObjectTree);
    if (status == RM_OK)
    {
        *Object = node->Data;
        DBG_VAL_PTR(*Object);
    }
    return (status);    
}

//
// Update an objects' context
//
RM_STATUS fifoUpdateObjectInstance
(
	PHWINFO     pDev,
    POBJECT     Object,
    U032        ChID,
    U032        Instance
)
{
    RM_STATUS status;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Updating FIFO context on object: ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                 ChID: ", ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                             instance: ", Instance);

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    //
    // Add it back.
    //
    status = fifoAddHashEntry(pDev, Object, ChID, Instance);
    osExitCriticalCode(pDev);
    return (status);
}

RM_STATUS fifoDeleteObjectInstance
(
	PHWINFO pDev,
	POBJECT Object,
	U032    ChID    
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Deleting FIFO context on object: ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                 ChID: ", ChID);

    osEnterCriticalCode(pDev);
    //
    // Remove the object from the hash table.
    //
    fifoDelHashEntry(pDev, Object, ChID);
    osExitCriticalCode(pDev);
    return (RM_OK);
}

//
// Reset the channel, so it's in an idle state and clear the hash.
// This is called as part of fifoFree.
//
RM_STATUS fifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    U032 Entry;

    //
    // Reset the channel, so it's in an idle state.
    //
    osEnterCriticalCode(pDev);
    nvHalFifoFree(pDev, ChID, pDev->DBfifoTable[ChID].Instance);

    //
    // Clear the hash table for this ChID.
    //
    for (Entry = 0; Entry < pDev->Pram.HalInfo.HashDepth; Entry++)
    {
        if (pDev->DBhashTable[Entry].Object && pDev->DBhashTable[Entry].ChID == ChID)
        {
            // clear software entry
            pDev->DBhashTable[Entry].Object = NULL;
            // clear hardware entry
            nvHalFifoHashDelete(pDev, Entry);
        }
    }
    osExitCriticalCode(pDev);

    return (RM_OK);
}

//
// Clear out the SubchannelContext
//
RM_STATUS fifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    U032 i;
    U032 ChID = Object->ChID;

    for (i = 0; i < NUM_SUBCHANNELS; i++)
    {
        if (pDev->DBfifoTable[ChID].SubchannelContext[i] == Object)
        {
            pDev->DBfifoTable[ChID].SubchannelContext[i] = NULL;
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv4\fifonv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** Chip Specific HAL FIFO Routines **********************\
*                                                                           *
* Module: FIFONV04.C                                                        *
*   The NV4 specific HAL FIFO routines reside in this file.                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV04(VOID *);
RM_STATUS nvHalFifoAllocPio_NV04(VOID *);
RM_STATUS nvHalFifoAllocDma_NV04(VOID *);
RM_STATUS nvHalFifoFree_NV04(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV04(VOID *);
RM_STATUS nvHalFifoService_NV04(VOID *);
RM_STATUS nvHalFifoAccess_NV04(VOID *);
RM_STATUS nvHalFifoHashAdd_NV04(VOID *);
RM_STATUS nvHalFifoHashDelete_NV04(VOID *);
RM_STATUS nvHalFifoHashFunc_NV04(VOID *);

//
// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
//
static RM_STATUS nvHalFifoContextSwitch_NV04(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV04(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV04(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;
            
            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;

            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV04(pHalHwInfo, (NUM_FIFOS_NV04 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV04; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalFifoAllocPio_NV04(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV04(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

RM_STATUS
nvHalFifoAllocDma_NV04(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    U032 DmaContext;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
	pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Validate push buffer state.
    //
    DmaContext = INST_RD32(pFifoAllocDmaArg->dmaInstance, SF_OFFSET(NV_DMA_CLASS));
    if (SF_VAL(_DMA, _TARGET_NODE, DmaContext) == NV_DMA_TARGET_NODE_NVM)
        return (RM_ERR_BAD_OBJECT_BUFFER);

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalFifoAllocateDma_NV04 - CACHE1 currently mapped to ChID ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));
    
    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch = nvHalFifoCalcDmaFetch_NV04(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

RM_STATUS
nvHalFifoFree_NV04(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of the argument structure.
    //
	pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;

    //if (id != FIFO_CONTEXT_SWITCH)
    //    return (HAL_ERROR);

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV04 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV04(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV04(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV04 pFifoHalPvtInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
 	pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;

    //
    // Now service any exceptions that we'd like to handle w/i the HAL.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 GetPtr;
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Reason;
        U032 Method;
        U032 Data;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type   == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV04) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV04(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }
    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV04(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
        REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV04(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    PHWREG nvAddr;
    HASH_TABLE_ENTRY *hwHashTable;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo; 
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV04(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV04(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV04(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV04 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

	pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV04)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv20\fifonv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV20.C                                                        *
*   The NV20 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV20(VOID *);
RM_STATUS nvHalFifoAllocPio_NV20(VOID *);
RM_STATUS nvHalFifoAllocDma_NV20(VOID *);
RM_STATUS nvHalFifoFree_NV20(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV20(VOID *);
RM_STATUS nvHalFifoService_NV20(VOID *);
RM_STATUS nvHalFifoAccess_NV20(VOID *);
RM_STATUS nvHalFifoHashAdd_NV20(VOID *);
RM_STATUS nvHalFifoHashDelete_NV20(VOID *);
RM_STATUS nvHalFifoHashFunc_NV20(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV20(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV20(U032, U032, U032);

RM_STATUS
nvHalFifoControl_NV20(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
	PHWREG nvAddr;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _SEMAPHORE, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _ACQUIRE_TIMEOUT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));
            
            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                    HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV20(pHalHwInfo, (NUM_FIFOS_NV20 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV20; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr1 + (i * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV20(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocPioArg->instance, i*4, 0);

    //
    // Now load graphics channel context buffer address into both
    // the hardware table and our shadow copy.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    if (INST_RD32(grCtxTable, pFifoAllocPioArg->chid * 4) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null context instance", pFifoAllocPioArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance", pFifoAllocPioArg->chid);
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocPioArg->chid * 4, pFifoAllocPioArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocPioArg->chid] = pFifoAllocPioArg->instance;

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocPioArg->chid * FC1_SIZE_NV20);
    for (i = 0; i < FC1_SIZE_NV20/4; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV20(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //
    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV20(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 CacheData, InitCtxtPtr, grCtxTable;
    U032 DefaultFetch;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Clear graphics context buffer.
    //
    for (i = 0; i < NV20_GR_CONTEXT_SIZE/4; i++)
        INST_WR32(pFifoAllocDmaArg->instance, i*4, 0);

    //
    // Load graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;

#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently null.
    //
    if (INST_RD32(grCtxTable, pFifoAllocDmaArg->chid * 4) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dma channel has non-null context instance", pFifoAllocDmaArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has non-null shadow context instance", pFifoAllocDmaArg->chid);
        DBG_BREAKPOINT();
    }
#endif

    INST_WR32(grCtxTable, pFifoAllocDmaArg->chid * 4, pFifoAllocDmaArg->instance);
    pGrHalPvtInfo->CtxTable[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->instance;
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoAllocDmaArg->chid * FC1_SIZE_NV20);
    for (i = 0 ; i < FC1_SIZE_NV20/4; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV20(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV20(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
	PHWREG nvAddr;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr, grCtxTable;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr1 + (pFifoFreeArg->chid * FC1_SIZE_NV20);
        for (i = 0; i < FC1_SIZE_NV20/4; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Clear graphics channel context pointer.
    //
    grCtxTable = pGrHalPvtInfo->CtxTableBase;
#ifdef DEBUG
    //
    // ASSERT that the entry for this channel is currently non-null.
    //
    if (INST_RD32(grCtxTable, pFifoFreeArg->chid * 4) == 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: freed channel has null context instance!", pFifoFreeArg->chid);
        DBG_BREAKPOINT();
    }
    if (pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] == 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: pio channel has null shadow context instance", pFifoFreeArg->chid);
        DBG_BREAKPOINT();
    }
#endif
    INST_WR32(grCtxTable, pFifoFreeArg->chid * 4, 0);
    pGrHalPvtInfo->CtxTable[pFifoFreeArg->chid] = 0;

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV20 pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr1;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT)), REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA)), REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE)), REG_RD32(NV_PFIFO_CACHE1_DMA_SUBROUTINE));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_2, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_VALUE))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_1, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMESTAMP))));
    REG_WR32(NV_PFIFO_CACHE1_ACQUIRE_0, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_ACQUIRE_TIMEOUT))));
    REG_WR32(NV_PFIFO_CACHE1_SEMAPHORE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_SEMAPHORE_CTXDMA))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_SUBROUTINE, REG_RD32((U032)(CtxtPtr + (ChID * FC1_SIZE_NV20) + SF_OFFSET(NV_RAMFC_DMA_SUBROUTINE_STATE))));

         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV20 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV20(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 GetPtr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV20(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV20) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV20(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }

    //
    // Handle semaphore errors...
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _PENDING))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA semaphore pending\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_SEMAPHORE ", REG_RD32(NV_PFIFO_CACHE1_SEMAPHORE));
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _SEMAPHORE, _RESET);
        DBG_BREAKPOINT();
    }
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _PENDING))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: DMA acquire timeout pending\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_0 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_0));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_1 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_1));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CACHE1_ACQUIRE_2 ", REG_RD32(NV_PFIFO_CACHE1_ACQUIRE_2));
        DBG_BREAKPOINT();
        REG_WR_DRF_DEF(_PFIFO, _INTR_0, _ACQUIRE_TIMEOUT, _RESET);

    }

    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV20(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOACCESSINFO pFifoAccessInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
            ;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
		    ;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV20(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                                   (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                                   (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                                   (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS)));
    
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV20(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV20(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV20(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV20 pFbHalPvtInfo;
    PPRAMHALINFO pPramHalInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV20)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo; 
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\fifo\nv10\fifonv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* Chip Specific HAL FIFO Routines *********************\
*                                                                           *
* Module: FIFONV10.C                                                        *
*   The NV10 specific HAL FIFO routines reside in this file.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalFifoControl_NV10(VOID *);
RM_STATUS nvHalFifoAllocPio_NV10(VOID *);
RM_STATUS nvHalFifoAllocDma_NV10(VOID *);
RM_STATUS nvHalFifoFree_NV10(VOID *);
RM_STATUS nvHalFifoGetExceptionData_NV10(VOID *);
RM_STATUS nvHalFifoService_NV10(VOID *);
RM_STATUS nvHalFifoAccess_NV10(VOID *);
RM_STATUS nvHalFifoHashAdd_NV10(VOID *);
RM_STATUS nvHalFifoHashDelete_NV10(VOID *);
RM_STATUS nvHalFifoHashFunc_NV10(VOID *);

// The context switch interface is only used internally, but perhaps
// should be made available to the resource manager anyway.
static RM_STATUS nvHalFifoContextSwitch_NV10(PHALHWINFO, U032);

static U032 nvHalFifoCalcDmaFetch_NV10(U032, U032, U032);

#ifdef TRAP_HOST_FIFO_SWITCHES
U032 do_fifo_switch = 0;
U032 dma_inst[NUM_FIFOS_NV10];
#endif

RM_STATUS
nvHalFifoControl_NV10(VOID *arg)
{
    PFIFOCONTROLARG_000 pFifoControlArg = (PFIFOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoControlArg->id != FIFO_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoControlArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoControlArg->cmd) {
        case FIFO_CONTROL_INIT:
            //
            // Setup default parameters. 
            //
            pFifoHalInfo->RetryCount = 255;
            pFifoHalInfo->UserBase = DEVICE_BASE(NV_USER);
            pFifoHalPvtInfo->Mode = 0;
            pFifoHalPvtInfo->InUse = 0;

            //
            // Setup interrupt enable mask.
            //
            pFifoHalInfo->IntrEn0 =
                DRF_DEF(_PFIFO, _INTR_EN_0, _CACHE_ERROR, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _RUNOUT_OVERFLOW, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PUSHER, _ENABLED) |
                DRF_DEF(_PFIFO, _INTR_EN_0, _DMA_PT, _ENABLED);

            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            //
            // Zero DMA FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            //
            // Zero FIFO hash valid.
            //
            REG_WR32(NV_PFIFO_CACHE0_HASH, 0);
            REG_WR32(NV_PFIFO_CACHE1_HASH, 0);
            //
            // Zero engine assignments
            //
            //REG_WR32(NV_PFIFO_CACHE0_ENGINE, 0);
            //REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
            //
            // Make all FIFO's default
            //
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
            REG_WR32(NV_PFIFO_DMA, 0);
            REG_WR32(NV_PFIFO_SIZE, 0);
            //
            // Clear all pusher state
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            //
            // Zero run-out pointers.
            //
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_PUT, _ADDRESS, 0);
            REG_WR_DRF_NUM(_PFIFO, _RUNOUT_GET, _ADDRESS, 0);
            break;
        case FIFO_CONTROL_LOAD:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // We don't need to worry about the endianness bit here
            // because we're going to swap this channel out asap
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES) |
                     DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15));

            //
            // Enable default timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, 
                     DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _ENABLED)
                     | DRF_DEF(_PFIFO, _DMA_TIMESLICE, _SELECT, _128K));
            
            //
            // Set retry delay to match common hardware latency.
            //
            REG_WR_DRF_NUM(_PFIFO, _DELAY_0, _WAIT_RETRY, pFifoHalInfo->RetryCount);
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Disable the pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);

            //
            // Enable pusher and puller access to cache1.
            //
            FIFOLOG(3, 1, 0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _ENABLED);
            //
            // Delay for slow CACHE1_PULL.
            //
            //temp = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _ENABLED);
            //
            // Enable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _ENABLED);
            break;
        case FIFO_CONTROL_UNLOAD:
            //
            // Disable dma timeslicing
            //    
            REG_WR32(NV_PFIFO_DMA_TIMESLICE, DRF_DEF(_PFIFO, _DMA_TIMESLICE, _TIMEOUT, _DISABLED));

            //
            // Empty FIFO and runout.
            //
            while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY)
                   || (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
            {
                //
                // Make sure we process any fifo interrupts
                //
                HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, FIFO_ENGINE_TAG);
                
                //
                // Check if GE needs servicing.
                //
                if (REG_RD32(NV_PGRAPH_INTR))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, GR_ENGINE_TAG);

                // Check if vblank needs servicing.
                if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                    HALRMSERVICEINTR(pFifoControlArg->pHalHwInfo, DAC_ENGINE_TAG);
            }

            //
            // Disable the dma pusher, if active
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
			    ;
            
            //
            // Disable cache reassignment.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            //
            // Disable pusher and puller access to cache0.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE0_PULL0, _ACCESS, _DISABLED);
            //
            // Disable pusher and puller access to cache1.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(3, 0, 0);
            //
            // Force a context switch to PRAMIN.
            //
            // KJK This should be replaced with a full software-based context switch
            //
            nvHalFifoContextSwitch_NV10(pHalHwInfo, (NUM_FIFOS_NV10 - 1));
            
            //
            // Zero FIFO get/put.
            //
            REG_WR32(NV_PFIFO_CACHE1_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0);
            
            //
            // Flush all FIFOs.
            //
            FifoReassign = REG_RD32(NV_PFIFO_CACHES);
            FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
            FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
            REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Update the FIFO context and its dirty bits.  By moving the get pointer to the current
            // put value, we are flushing any pending push data that hasn't been fetched yet.
            //
            for (i = 0; i < NUM_FIFOS_NV10; i++)
            {
                if (pFifoHalPvtInfo->InUse & (1 << i))
                {
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), 
                             REG_RD32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));

                    //
                    // Also, when setting the channels get pointer equal to its put, ensure the next
                    // DWORD is interpreted as a command (and not data) by clearing RAMFC_DMA_METHOD.
                    //
                    REG_WR32((U032)(pFbHalPvtInfo->fifoContextAddr + (i * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), 0x0);
                }
            }

            //
            // Restore CACHE1 state.
            //
            FIFOLOG(1, FifoPull, FifoReassign);
            REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
            REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
            REG_WR32(NV_PFIFO_CACHES, FifoReassign);

            //
            // Flush all pending
            //
            REG_WR32(NV_PFIFO_DMA, 0);
            
            //
            // Disable all FIFO interrupts.
            //
            REG_WR32(NV_PFIFO_INTR_EN_0, 0);
            break;
        case FIFO_CONTROL_DESTROY:
            break;
        case FIFO_CONTROL_UPDATE:
            //
            // Update the dma fetch numbers using reasonable defaults.
            // Use FLD_WR_DRF_DEF so that we don't kill the endianness bit
			//
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, _128_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, _32_BYTES);
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, _15);
            break;

        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalFifoAllocPio
//
// Allocate PIO channel.
//
RM_STATUS
nvHalFifoAllocPio_NV10(VOID *arg)
{
    PFIFOALLOCPIOARG_000 pFifoAllocPioArg = (PFIFOALLOCPIOARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAllocPioArg->id != FIFO_ALLOC_PIO_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocPioArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);

    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocPioArg->chid * 32);
    for (i = 0; i < 8; i++)
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Set MODE to pio.
    //
    pFifoHalPvtInfo->Mode &= ~(1 << pFifoAllocPioArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocPioArg->chid))
    {
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,    pFifoAllocPioArg->chid);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT,   _ADDRESS, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_GET,   _ADDRESS, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        //
        // Enable cache1.
        //
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocPioArg->chid);

    return (RM_OK);
}

//
// nvHalFifoCalcDmaFetch
//
// Derive chip-dependent DMA fetch parameter register value
// from values specified at channel allocation time.
//
U032
nvHalFifoCalcDmaFetch_NV10(U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    U032 dmaFetch;

    //
    // Input trigger value is in bytes.
    // Hardware value must be specified in increments of 8 between
    // 8 - 256 bytes.
    //
    if (fetchTrigger < 8) fetchTrigger = 8;
    if (fetchTrigger > 256) fetchTrigger = 256;
    fetchTrigger = (fetchTrigger / 8) - 1;

    //
    // Input size value is in bytes.
    // Hardware value must be specified in increments of 32
    // between 32 - 256 bytes.
    //
    if (fetchSize < 32) fetchSize = 32;
    if (fetchSize > 256) fetchSize = 256;
    fetchSize = (fetchSize / 32) - 1;

    //
    // Requests must be between 0 and 15.
    //
    if (fetchRequests > 15) fetchRequests = 15;

    //
    // Put it all together.
    //

    dmaFetch = DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _TRIG, fetchTrigger) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _SIZE, fetchSize) |
        DRF_NUM(_PFIFO, _CACHE1_DMA_FETCH, _MAX_REQS, fetchRequests);

    return dmaFetch;
}

//
//
// nvHalFifoAllocDma
//
// Allocate DMA channel.
//
RM_STATUS
nvHalFifoAllocDma_NV10(VOID *arg)
{
    PFIFOALLOCDMAARG_000 pFifoAllocDmaArg = (PFIFOALLOCDMAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    U032 CacheData, InitCtxtPtr;
    U032 DefaultFetch;
    PHWREG nvAddr;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pFifoAllocDmaArg->id != FIFO_ALLOC_DMA_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoAllocDmaArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Disable cache reassignment.
    //
    CacheData = REG_RD32(NV_PFIFO_CACHES);
    REG_WR_DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _DISABLED);
    
    //
    // Initialize freshly allocated FIFO context.
    //
    InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoAllocDmaArg->chid * 32);
    for (i = 0 ; i < 8 ; i++ )
    {
        REG_WR32(InitCtxtPtr+(i*4), 0);
    }

    //
    // Insert the instance (note that the rest of the context can start as zero)
    //
#ifdef TRAP_HOST_FIFO_SWITCHES
    if (do_fifo_switch)
        dma_inst[pFifoAllocDmaArg->chid] = pFifoAllocDmaArg->dmaInstance;
    else
#endif
    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_INST)), pFifoAllocDmaArg->dmaInstance);
    
    //
    // Calculate the endianness for the channel
    // Each channel can have its own endian-ness, but the api does not
    // yet support that.  So for now the channel endianness follows
    // from the rest of the system
    //
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _BIG);
    else
        DefaultFetch = DRF_DEF(_PFIFO, _CACHE1_DMA_FETCH, _ENDIAN, _LITTLE);

    //
    // Adjust fetch max request (exception to the "all start as zero" rule)
    //
    DefaultFetch |= nvHalFifoCalcDmaFetch_NV10(pFifoAllocDmaArg->fetchTrigger, pFifoAllocDmaArg->fetchSize, pFifoAllocDmaArg->fetchRequests);

    REG_WR32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), DefaultFetch);
    
    //
    // Set channel mode to dma
    //
    pFifoHalPvtInfo->Mode |= (1 << pFifoAllocDmaArg->chid);
    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

    //
    // Is this channel in use?
    //
    if ((pFifoHalInfo->AllocateCount++ == 0)
     || (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoAllocDmaArg->chid))
    {
        //
        // KJK Warning!!  We're getting in here if this is the first (0)
        // channel allocated in the system due to the checks above.
        // We really shouldn't be...
        //
        
        //
        // Disable cache1.
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS, _DISABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _DISABLED);
        FIFOLOG(1, 0, 0);
        //
        // Set initial cache parameters.
        //
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID,   pFifoAllocDmaArg->chid);
        
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
        
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_PUT, _OFFSET, 0);
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_DMA_GET, _OFFSET, 0);
        
#ifdef TRAP_HOST_FIFO_SWITCHES
        if (!do_fifo_switch)
#endif
        REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, pFifoAllocDmaArg->dmaInstance);

        //
        // Force a reload of the PTE's
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_CTL, 0);
        
        //
        // Clear all pusher state
        //
        REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // Set default watermarks
        //
        //REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0x000F6068);
        REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, DefaultFetch);
        
        //
        // Enable cache1.
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoAllocDmaArg->chid))
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);
        
        FIFOLOG(1, 1, 1);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _ENABLED);
        REG_WR_DRF_DEF(_PFIFO_, CACHE1_PUSH0, _ACCESS,   _ENABLED);
        CacheData = DRF_DEF(_PFIFO_, CACHES, _REASSIGN, _ENABLED);
    }

    //
    // Restore previous cache reassignability.
    //
    REG_WR32(NV_PFIFO_CACHES, CacheData);

    //
    // Mark channel as allocated.
    //
    pFifoHalPvtInfo->InUse |= (1 << pFifoAllocDmaArg->chid);

    return (RM_OK);
}

//
// nvHalFifoFree
//
// Free fifo resources.
//
RM_STATUS
nvHalFifoFree_NV10(VOID *arg)
{
    PFIFOFREEARG_000 pFifoFreeArg = (PFIFOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOHALINFO pFifoHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 InitCtxtPtr;
    PHWREG nvAddr;
    U032 i;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoFreeArg->id != FIFO_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Pull what we need out of argument structure.
    //
    pHalHwInfo = pFifoFreeArg->pHalHwInfo;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush     = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull     = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
    FIFOLOG(4, 0, 0);

    //
    // Update the FIFO context and its dirty bits.
    //    
    if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) == pFifoFreeArg->chid)
    {
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, 0);
        
        //
        // If this is a dma channel, we need to shut him down and clear out
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Disable dma pusher activity
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, 0);
            
            //
            // Wait til idle
            //
            while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
                ;
            
            //
            // Now zero everything out
            //
            REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_GET, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, 0);
            REG_WR32(NV_PFIFO_CACHE1_DMA_TLB_PTE, 0);
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }        
    }
    else
    {
        //
        // Flush the context into the FIFO context RAM.
        //
        InitCtxtPtr = pFbHalPvtInfo->fifoContextAddr + (pFifoFreeArg->chid * 32);
        for (i = 0; i < 8; i++)
        {
            REG_WR32(InitCtxtPtr+(4*i), 0);
        }
        
        //
        // If this is a dma channel, make sure we clear any pending pushing
        //
        if (pFifoHalPvtInfo->Mode & (1 << pFifoFreeArg->chid))
        {
            //
            // Clear any pending transfers
            //
            REG_WR32(NV_PFIFO_DMA, REG_RD32(NV_PFIFO_DMA) & (~(1 << pFifoFreeArg->chid)));
            
            //
            // Move this channel back to PIO.  This way any inadvertant writes will go to runout.
            //
            pFifoHalPvtInfo->Mode &= ~(1 << pFifoFreeArg->chid);
            REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);
        }
    }

    //
    // Restore CACHE1 state.
    //
    FIFOLOG(4, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    //
    // Free up channel.
    //
    pFifoHalPvtInfo->InUse &= ~(1 << pFifoFreeArg->chid);

    pFifoHalInfo->AllocateCount--;

    return (RM_OK);
}

//
// nvHalFifoContextSwitch
//
// Context switch the fifo.
//
static RM_STATUS
nvHalFifoContextSwitch_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PFIFOHALINFO_NV10 pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    U032 FifoReassign, FifoPush, FifoPull;
    U032 CurrentChID;
    U032 PushPending;
    U032 CtxtPtr = (U032)pFbHalPvtInfo->fifoContextAddr;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Save CACHE1 state.
    //
    FifoReassign = REG_RD32(NV_PFIFO_CACHES);
    FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS, _DISABLED);
    FIFOLOG(1, 0, 0);
    
    //
    // Make sure our local (rm) contexts are up to date for the outgoing channel
    //
    CurrentChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually saving the FIFO context on ChID: ", CurrentChID);

    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT)), REG_RD32(NV_PFIFO_CACHE1_DMA_PUT));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET)), REG_RD32(NV_PFIFO_CACHE1_DMA_GET));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT)), REG_RD32(NV_PFIFO_CACHE1_REF));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST)), REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD)), REG_RD32(NV_PFIFO_CACHE1_DMA_STATE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG)), REG_RD32(NV_PFIFO_CACHE1_DMA_FETCH));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0)), REG_RD32(NV_PFIFO_CACHE1_ENGINE));
    REG_WR32((U032)(CtxtPtr + (CurrentChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE)), REG_RD32(NV_PFIFO_CACHE1_PULL1));
    
    //
    // If this is a push channel and put != get, make sure to set the push pending flag
    //
    if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
    {    
        PushPending = REG_RD32(NV_PFIFO_DMA) & ~(1 << CurrentChID);
        if (REG_RD32(NV_PFIFO_CACHE1_DMA_PUT) != REG_RD32(NV_PFIFO_CACHE1_DMA_GET))
            PushPending |= (1 << CurrentChID);
        REG_WR32(NV_PFIFO_DMA, PushPending);
    }                    
    
    //
    // Bring in the context for the new channel from the fifo context ram.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Manually restoring the FIFO context on ChID: ", ChID);

    //
    // Update the channel and if it's DMA, set the mode
    //
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUSH1, _CHID, ChID);
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        FLD_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA); 
    
    REG_WR32(NV_PFIFO_CACHE1_DMA_PUT, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_PUT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_GET, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_GET))));
    REG_WR32(NV_PFIFO_CACHE1_REF,REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_REF_CNT))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_INSTANCE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_INST))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_STATE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_METHOD))));
    REG_WR32(NV_PFIFO_CACHE1_DMA_FETCH, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_DMA_FETCH_TRIG))));
    REG_WR32(NV_PFIFO_CACHE1_ENGINE, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_ENGINE_SUB_0))));
    REG_WR32(NV_PFIFO_CACHE1_PULL1, REG_RD32((U032)(CtxtPtr + (ChID * 32) + SF_OFFSET(NV_RAMFC_PULL1_ENGINE))));
         
    //
    // If DMA, enable the DMA Pusher
    //
    if ((pFifoHalPvtInfo->Mode & (1 << ChID)) && (ChID != (NUM_FIFOS_NV10 - 1)))
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _ENABLED);

    //
    // In case there are dma pusher channels still pending, give this
    // new channel enough time to do something useful before it gets
    // yanked back out again.
    //
    REG_WR32(NV_PFIFO_TIMESLICE, 0x1fffff);     
           
    //
    // Restore CACHE1 state.
    //
    FIFOLOG(1, FifoPull, FifoReassign);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, FifoPull);
    REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    REG_WR32(NV_PFIFO_CACHES, FifoReassign);

    return (RM_OK);
}

//
// nvHalFifoGetExceptionData
//
RM_STATUS
nvHalFifoGetExceptionData_NV10(VOID *arg)
{
    PFIFOGETEXCEPTIONDATAARG_000 pFifoGetExceptionDataArg = (PFIFOGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    U032 GetPtr;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoGetExceptionDataArg->id != FIFO_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoGetExceptionDataArg->pHalHwInfo;
    pFifoExceptionData = pFifoGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pFifoExceptionData->Reason = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pFifoExceptionData->ChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    GetPtr = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    pFifoExceptionData->GetPtr = GetPtr;
    pFifoExceptionData->SubChannel =
        (((REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr))) >> DRF_SHIFT(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL)) & 
         DRF_MASK(NV_PFIFO_CACHE1_METHOD_SUBCHANNEL));
    pFifoExceptionData->Method = REG_RD32(NV_PFIFO_CACHE1_METHOD(GetPtr)) & 0x1FFC;
    pFifoExceptionData->Data = REG_RD32(NV_PFIFO_CACHE1_DATA(GetPtr));

    return (RM_OK);
}

//
// nvHalFifoService
//
RM_STATUS
nvHalFifoService_NV10(VOID *arg)
{
    PFIFOSERVICEARG_000 pFifoServiceArg = (PFIFOSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFIFOEXCEPTIONDATA pFifoExceptionData;
    PFIFOHALINFO pFifoHalInfo;
    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoServiceArg->id != FIFO_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);
    
    pHalHwInfo = pFifoServiceArg->pHalHwInfo;
    pFifoExceptionData = pFifoServiceArg->pExceptionData;
    pFifoHalInfo = pHalHwInfo->pFifoHalInfo;
    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalPvtInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Handle Runout.
    //
    if (pFifoServiceArg->intr & DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _PENDING))
    {
        U032 ChID;
        U032 SubChannel;
        U032 Type;
        U032 Method;
        U032 Data;
        U032 GetPtr = 0;  // some compilers think its uninitialized otherwise
        U032 Reason;
        U032 FifoPush, wasDmaChannel = 0;

        //
        // Deal with data in runout.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM: Cache ranout.  Waiting for cache to drain.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:         CACHE1 ChID = ", REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID));

        //
        // Don't allow another channel to switch in
        //
        REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);

        //
        // Disable CACHE1_PUSH0, so we're able to safely resubmit the runout method/data
        // back into the CACHE1 below.
        // 
        FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        
        //
        // If this is a DMA channel, start to shut down the current pushing
        //
        if (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & DRF_DEF(_PFIFO, _CACHE1_PUSH1, _MODE, _DMA))
        {
            FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);
            wasDmaChannel = 1;      // started this interrupt as a DMA channel
        }
            
        //
        // First wait for cache to drain and the dma pusher to be idle
        //
        if ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) == NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) &&
            (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE))
        {            
            //
            // Cache is empty.  Deal with data in runout.
            //
            REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);
            FIFOLOG(1, 0, 0);

            //
            // Since the CACHE1 has been idled, let's move its PUT/GET to the top
            // of the FIFO avoiding any overflow issues during the resubmit.
            //
#ifdef DEBUG
            if (REG_RD32(NV_PFIFO_CACHE1_PUT) != REG_RD32(NV_PFIFO_CACHE1_GET))
                DBG_BREAKPOINT();
#endif // DEBUG

            REG_WR32(NV_PFIFO_CACHE1_PUT, 0x0);
            REG_WR32(NV_PFIFO_CACHE1_GET, 0x0);

            //
            // Because we've taken the trouble to idle everything, rather than dump
            // a single method/data into the CACHE1 and wait, we'll resubmit all the
            // outstanding runout method/data back into the CACHE1.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_PUT        = ", REG_RD32(NV_PFIFO_RUNOUT_PUT));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut_GET        = ", REG_RD32(NV_PFIFO_RUNOUT_GET));

            while (REG_RD32(NV_PFIFO_RUNOUT_PUT) != REG_RD32(NV_PFIFO_RUNOUT_GET))
            {
                //
                // Read FIFO state.
                //
                GetPtr     = REG_RD32(NV_PFIFO_RUNOUT_GET);
                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Method = ", Data);

                ChID       = SF_VAL(_RAMRO, _CHID, Data);
                Type       = SF_VAL(_RAMRO, _TYPE, Data);
                Reason     = SF_VAL(_RAMRO, _REASON, Data);
                Method     = SF_VAL(_RAMRO, _METHOD, Data) & 0x1FFF;
                SubChannel = SF_VAL(_RAMRO, _SUBCHANNEL, Data) & 0x7;

                Data       = REG_RD32(pFbHalPvtInfo->fifoRunoutAddr + GetPtr + 4);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:       RunOut Data   = ", Data);

                //
                // Set user cache state to look just as if the runout came
                // from the bottom on the FIFO.  This keeps the OBJECT_CHANGED
                // bits in order.
                //
                if ((Type == NV_RAMRO_TYPE_WRITE)
                    && (Reason != NV_RAMRO_REASON_ILLEGAL_ACCESS)
                    && (Reason != NV_RAMRO_REASON_RESERVED_ACCESS))
                {
                    if ((ChID < NUM_FIFOS_NV10) && pFifoHalPvtInfo->InUse)
                    {
                        U032 Cache1Put;

                        //
                        // Since the fifo engine/resmgr no longer tracks object context on a per-subchannel
                        // basis, the only thing we can do with runout methods is to send them back down
                        // the main user fifo.
                        //
                        // Do we need to force a channel change?
                        //
                    
                        if (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID) != ChID)
                        {
                            nvHalFifoContextSwitch_NV10(pHalHwInfo, ChID);

                            //
                            // If we started out the interrupt as a DMA channel and have switched into
                            // a PIO channel, make sure to clear the SUSPEND bit (but don't reenable). 
                            // The HW likes to see this bit cleared after an intr and since we now look
                            // like a PIO channel, we'll just clear it here.
                            // 
                            if (wasDmaChannel && (REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _MODE) == 0))
                                FLD_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _STATUS, _RUNNING);
                        }

                        //
                        // Resubmit
                        //
                        Cache1Put = REG_RD_DRF(_PFIFO, _CACHE1_PUT, _ADDRESS);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,
                                                   "NVRM: Cache runout resubmit to CACHE1 addr:", Cache1Put << 2);

                        REG_WR32(NV_PFIFO_CACHE1_METHOD(Cache1Put), 
                            Method | DRF_NUM(_PFIFO, _CACHE0_METHOD, _SUBCHANNEL, SubChannel));
                        REG_WR32(NV_PFIFO_CACHE1_DATA(Cache1Put), Data);

                        //
                        // Update the CACHE1 Put ptr.
                        // There are no overflow worries, since we started at the top of the CACHE1
                        //
                        Cache1Put++;
                        REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, Cache1Put);
                    }
                    else
                    {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Access to free channel:", ChID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 sub channel:", SubChannel);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      offset:", Method);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                        data:", Data);
                        DBG_BREAKPOINT();
                    }
                }
            
                //
                // Advance the RunOut get pointer.
                //
                GetPtr = (GetPtr + 8) & pFbHalPvtInfo->fifoRunoutMask;
                REG_WR32(NV_PFIFO_RUNOUT_GET, GetPtr);
                GetPtr = REG_RD32(NV_PFIFO_RUNOUT_GET);      // flush delay to update runout_status
            }

            //
            // Clear condition if no more data in runout.
            //
            if (REG_RD32(NV_PFIFO_RUNOUT_STATUS) & DRF_DEF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK, _EMPTY))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut has CAUGHT UP:", GetPtr);
                REG_WR_DRF_DEF(_PFIFO, _INTR_0, _RUNOUT, _RESET);
            } else {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: RunOut should be CAUGHT UP:", GetPtr);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            //
            // Enable the puller to empty the cache.
            //
            FIFOLOG(1, 1, 0);
            REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS, _ENABLED);
        }

        // restore CACHE1_PUSH0 state
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, FifoPush);
    }
    return (RM_OK);
}

//
// nvHalFifoAccess
//
RM_STATUS
nvHalFifoAccess_NV10(VOID *arg)
{
    PFIFOACCESSARG_000 pFifoAccessArg = (PFIFOACCESSARG_000)arg;
    PFIFOACCESSINFO pFifoAccessInfo;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoAccessArg->id != FIFO_ACCESS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoAccessArg->pHalHwInfo;
    pFifoAccessInfo = pFifoAccessArg->pAccessInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (pFifoAccessArg->cmd) {
    case FIFO_ACCESS_DISABLE:
        //
        // This is the HW approved way of idling the FIFO, before changing its
        // context. After disabling reassign, wait for any pending channel changes
        // to complete. Also wait for the hash engine to idle then invalidate the
        // last lookup to avoid any miscompares (cleans up errors seen on IKOS).
        //
        pFifoAccessInfo->FifoReassign = REG_RD32(NV_PFIFO_CACHES);
        pFifoAccessInfo->FifoPush = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
        pFifoAccessInfo->FifoPull = REG_RD32(NV_PFIFO_CACHE1_PULL0);

        // disable reassign and wait for DMA_SUSPEND to go idle
        REG_WR_DRF_DEF(_PFIFO, _CACHES, _REASSIGN, _DISABLED);
        while (REG_RD_DRF(_PFIFO, _CACHES, _DMA_SUSPEND) == NV_PFIFO_CACHES_DMA_SUSPEND_BUSY)
			;

        // disable cache1 push access and the cache1 puller
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PUSH0, _ACCESS,   _DISABLED);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_PULL0, _ACCESS,   _DISABLED);

        // wait for the hash engine to idle and invalidate its previous lookup
        while (REG_RD_DRF(_PFIFO, _CACHE1_PULL0, _HASH_STATE) == NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY)
			;
        REG_WR_DRF_NUM(_PFIFO, _CACHE1_HASH, _VALID, 0x0);
        break;
    case FIFO_ACCESS_ENABLE:
        REG_WR32(NV_PFIFO_CACHE1_PULL0, pFifoAccessInfo->FifoPull);
        REG_WR32(NV_PFIFO_CACHE1_PUSH0, pFifoAccessInfo->FifoPush);
        REG_WR32(NV_PFIFO_CACHES, pFifoAccessInfo->FifoReassign);
        break;
    default:
        // invalid cmd
        return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalFifoHashAdd
//
RM_STATUS
nvHalFifoHashAdd_NV10(VOID *arg)
{
    PFIFOHASHADDARG_000 pFifoHashAddArg = (PFIFOHASHADDARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    U032 ht_Context;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashAddArg->id != FIFO_HASH_ADD_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashAddArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    // set hash entry's object handle
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle, pFifoHashAddArg->handle);

    ht_Context = (pFifoHashAddArg->instance & SF_MASK(NV_RAMHT_INSTANCE)) |
                                            (pFifoHashAddArg->engine << SF_SHIFT(NV_RAMHT_ENGINE)) |
                                            (pFifoHashAddArg->chid << SF_SHIFT(NV_RAMHT_CHID)) |
                                            (NV_RAMHT_STATUS_VALID << SF_SHIFT(NV_RAMHT_STATUS));

    // set hash entry's inst addr and valid bit
    REG_WR32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context, ht_Context);
             
    while ((REG_RD32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_ObjectHandle) != pFifoHashAddArg->handle) ||
           (REG_RD32_DIRECT(&hwHashTable[pFifoHashAddArg->entry].ht_Context) != ht_Context))
        ;
    return (RM_OK);
}

//
// nvHalHashDelete
//
RM_STATUS
nvHalFifoHashDelete_NV10(VOID *arg)
{
    PFIFOHASHDELETEARG_000 pFifoHashDeleteArg = (PFIFOHASHDELETEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashDeleteArg->id != FIFO_HASH_DELETE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashDeleteArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_Context, 0);
    REG_WR32_DIRECT(&hwHashTable[pFifoHashDeleteArg->entry].ht_ObjectHandle, 0);

    return (RM_OK);
}

RM_STATUS
nvHalFifoHashFunc_NV10(VOID *arg)
{
    PFIFOHASHFUNCARG_000 pFifoHashFuncArg = (PFIFOHASHFUNCARG_000)arg;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashFuncArg->id != FIFO_HASH_FUNC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pFifoHashFuncArg->result = FIFO_HASH(pFifoHashFuncArg->handle, pFifoHashFuncArg->chid);

    return (RM_OK);    
}

RM_STATUS
nvHalFifoHashSearch_NV10(VOID *arg)
{
    PFIFOHASHSEARCHARG_000 pFifoHashSearchArg = (PFIFOHASHSEARCHARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PPRAMHALINFO pPramHalInfo;
    PFBHALINFO_NV10 pFbHalPvtInfo;
    HASH_TABLE_ENTRY *hwHashTable;
    PHWREG nvAddr;
    U032 Entry;

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pFifoHashSearchArg->id != FIFO_HASH_SEARCH_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pFifoHashSearchArg->pHalHwInfo;
    pFbHalPvtInfo = (PFBHALINFO_NV10)pHalHwInfo->pFbHalPvtInfo;
    pPramHalInfo = pHalHwInfo->pPramHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    hwHashTable = (HASH_TABLE_ENTRY *)((U008*)(nvAddr) + pFbHalPvtInfo->hashTableAddr);

    pFifoHashSearchArg->result = 0x0;

    // Attempt to find a valid entry in the Hash (checking Name and ChID)
    for (Entry = 0; Entry < pPramHalInfo->HashDepth; Entry++)
    {
        if (REG_RD32_DIRECT(&hwHashTable[Entry].ht_ObjectHandle) == pFifoHashSearchArg->handle)
        {
            U032 chid, valid;
            U032 context = REG_RD32_DIRECT(&hwHashTable[Entry].ht_Context);
             
            chid  = context >> SF_SHIFT(NV_RAMHT_CHID) & SF_MASK(NV_RAMHT_CHID);
            valid = context >> SF_SHIFT(NV_RAMHT_STATUS) & SF_MASK(NV_RAMHT_STATUS);

            if ((valid == NV_RAMHT_STATUS_VALID) && (chid == pFifoHashSearchArg->chid))
            {
                pFifoHashSearchArg->result = context;
                break;
            }
        }
    }

    return (RM_OK);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grmethd.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRMETHD.C                                                         *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"


// extern PGRAPHICSCHANNEL grTable;


//---------------------------------------------------------------------------
//
//  Graphics video patchcord methods
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS       status;
    U032            InputIndex;
    U032            i;
    PVIDEOPATCHCORD *VideoInput;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoPatchcord;
    
    InputIndex = (Offset - Method->Low) / 4;

    /*
    KJK This is probably useless, since we wouldn't
        have been called if the method itself was
        out of range for this object.

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SWITCH:
            if (InputIndex >= 2)
                return (RM_ERR_INVALID_PATCH);
            break;
        default:
            if (InputIndex >= MAX_GRPATCH_INPUT)
                return (RM_ERR_INVALID_PATCH);
            break;
    }
    */

    switch (Object->Class->Type)
    {
        case NV_VIDEO_SINK:
            VideoInput  = &(((PVIDEOSINKOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput = NULL;
            break;
        case NV_VIDEO_COLORMAP:
            VideoInput  = &(((PVIDEOCOLORMAPOBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOCOLORMAPOBJECT)Object)->VideoOutput;
            break;
        case NV_VIDEO_SCALER:
            VideoInput  = &(((PVIDEOSCALEROBJECT)Object)->VideoInput);
            VideoOutput =   ((PVIDEOSCALEROBJECT)Object)->VideoOutput;
            break;
        /*            
        case NV_VIDEO_CAPTURE_TO_MEMORY:
            VideoInput  = &(((PVIDEOTOMEMOBJECT)Object)->VideoInput);
            VideoOutput = NULL;
            break;
        */            
        default:
            VideoInput  = &(((PVIDEOOBJECT)Object)->VideoInput[InputIndex]);
            VideoOutput =   ((PVIDEOOBJECT)Object)->VideoOutput;
            break;
    }

    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoInput)
    {
        DBG_VAL_PTR(*VideoInput);
        for (i = 0; (*VideoInput)->Destination[i] != (PVIDEOOBJECT)Object; i++);
        (*VideoInput)->FanOut--;
        (*VideoInput)->Destination[i] = NULL;
        *VideoInput                   = NULL;
    }

    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        if (VideoPatchcord->FanOut == MAX_GRPATCH_FANOUT)
            return (RM_ERR_MAX_PATCH_FANOUT);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && (VideoPatchcord->Destination[i] != (PVIDEOOBJECT)Object); i++);
        if (i == MAX_GRPATCH_FANOUT)
        {
            //
            // Insert this connection into the first available slot.
            //
            for (i = 0; VideoPatchcord->Destination[i]; i++);
            VideoPatchcord->FanOut++;
            VideoPatchcord->Destination[i] = (PVIDEOOBJECT)Object;
            *VideoInput                    = VideoPatchcord;
        }
    }

    return (RM_OK);
#endif // KJK    
}

RM_STATUS mthdSetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    return (RM_OK);

#ifdef KJK
    RM_STATUS        status;
    PVIDEOPATCHCORD *VideoOutput;
    PVIDEOPATCHCORD  VideoPatchcord;
    
    switch (Object->Class->Type)
    {
        /*
        case NV_IMAGE_TO_VIDEO:
            VideoOutput = &(((PIMAGEVIDEOOBJECT)Object)->VideoOutput);
            break;
        */            
        case NV_VIDEO_FROM_MEMORY:
            VideoOutput = &(((PVIDEOFROMMEMOBJECT)Object)->VideoOutput);
            break;
        /*            
        case NV_VIDEO_SOURCE:
            VideoOutput = &(((PVIDEOSOURCEOBJECT)Object)->VideoOutput);
            break;
        */            
        default:
            VideoOutput = &(((PVIDEOOBJECT)Object)->VideoOutput);
            break;
    }
    //
    // Disconnect old patchcord.  Break apart all patch information.
    //
    if (*VideoOutput)
    {
        DBG_VAL_PTR(*VideoOutput);
        grInvalidateVideoPatchcord(*VideoOutput);
        (*VideoOutput)->Source = NULL;
        *VideoOutput           = NULL;
    }
    if (Data)
    {
        //
        // Validate patchcord and connect.
        //
        status = fifoSearchObject(pDev, Data, Object->ChID, (POBJECT *)&VideoPatchcord);
        if (status)
            return (status);
        if (VideoPatchcord->Base.Class->Type != NV_PATCHCORD_VIDEO)
            return (RM_ERR_OBJECT_TYPE_MISMATCH);
        //
        // Unplug patchcord if already in use.
        //    
        if (VideoPatchcord->Source)
        {
            DBG_VAL_PTR(VideoPatchcord->Source);
            grInvalidateVideoPatchcord(VideoPatchcord);
            switch (VideoPatchcord->Source->Base.Class->Type)
            {
                /*
                case NV_IMAGE_TO_VIDEO:
                    ((PIMAGEVIDEOOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                case NV_VIDEO_FROM_MEMORY:
                    ((PVIDEOFROMMEMOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                /*                    
                case NV_VIDEO_SOURCE:
                    ((PVIDEOSOURCEOBJECT)VideoPatchcord->Source)->VideoOutput = NULL;
                    break;
                */                    
                default:
                    VideoPatchcord->Source->VideoOutput = NULL;
                    break;
            }
        }
        //
        // Insert this connection into the first available slot.
        //
        VideoPatchcord->Source = (PVIDEOOBJECT)Object;
        *VideoOutput = VideoPatchcord;
    }
    return (RM_OK);
#endif // KJK
}

//---------------------------------------------------------------------------
//
//  Graphics class methods that map directly to hardware.
//
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
//
//  Colormap methods.
//
//---------------------------------------------------------------------------

RM_STATUS mthdSetColormapCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS            status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Check for a previous translation.  Free its resource before overwriting.
    //
    if (Data == NV1_NULL_OBJECT)
    {
        ColormapObject->Xlate = NULL;
        return (RM_OK);
    }
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(ColormapObject->Xlate));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
    return (RM_OK);
}
RM_STATUS mthdSetColormapFormat
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->ColorFormat = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Start = Data;
    return (RM_OK);
}
RM_STATUS mthdSetColormapLength
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->Length = Data;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyStart
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    ((PVIDEOCOLORMAPOBJECT)Object)->DirtyStart = Data + ((PVIDEOCOLORMAPOBJECT)Object)->Start;
    return (RM_OK);
}
RM_STATUS mthdColormapDirtyLength
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    RM_STATUS       status;
    PVIDEOCOLORMAPOBJECT ColormapObject;
    U032           *ColormapBuffer, *ColormapBufferBase;
    U032            StartIndex;
    U032            StopIndex;
    
    ColormapObject = (PVIDEOCOLORMAPOBJECT)Object;
    //
    // Validate length.
    //
    if ((ColormapObject->DirtyStart + Data) > (ColormapObject->Start + ColormapObject->Length))
        return (RM_ERR_INVALID_START_LENGTH);
    ColormapObject->DirtyLength = Data;
    //
    // Validate enumeration parameters.
    //
    if (!ColormapObject->Xlate)
        return (RM_ERR_INVALID_XLATE);
	/* KJK
    status = dmaAttach(ColormapObject->Xlate);
    if (status)
        return (status);
	*/
    status = dmaValidateXlate(ColormapObject->Xlate,
                              ColormapObject->Start,
                              ColormapObject->Length);
    if (status)
        return (status);
	/* KJK
    status = dmaBeginXfer(ColormapObject->Xlate, NULL);
    if (status)
        return (status);
	*/
    //
    // Get buffer translation.
    //
    status = dmaGetMappedAddress(pDev, ColormapObject->Xlate,
                                 ColormapObject->DirtyStart,
                                 ColormapObject->DirtyLength,
                                 (VOID **)&ColormapBuffer);
    if (status)
        return (status);
        
    // save original ptr value    
	ColormapBufferBase = ColormapBuffer;
    
    //
    // Load new colormap into palette copy.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
    StartIndex = (ColormapObject->DirtyStart - ColormapObject->Start) >> 2;
    StopIndex  = StartIndex + ((ColormapObject->DirtyLength) >> 2);
    if (StopIndex > 255)
        StopIndex = 255;
    while (StartIndex <= StopIndex)
    {
        ColormapObject->ColorMap[StartIndex] = *ColormapBuffer;
        if (pDev->Dac.HalInfo.Depth == 8)
            pDev->Dac.Palette[StartIndex++]     = *ColormapBuffer++;
        else    
            pDev->Dac.Gamma[StartIndex++]       = *ColormapBuffer++;
    }
    pDev->colormapObjectToNotify = ColormapObject;
    pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_COLORMAP;
    //KJK dmaEndXfer(ColormapObject->Xlate, NULL);
    //dmaDetach(ColormapObject->Xlate);    
    return (RM_OK);
}

RM_STATUS mthdColormapDirtyNotify
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    RM_STATUS rmStatus;
    PVIDEOCOLORMAPOBJECT pColormapObj;
    
    pColormapObj = pDev->colormapObjectToNotify;
    
    if (pColormapObj == NULL)
        return RM_OK;
        
    rmStatus = notifyFillNotifierArray(pDev, pColormapObj->CBase.NotifyXlate,
                                       0 /* info32 */, 0 /* info16 */, 
                                       status,
                                       NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY);
    //
    // Do any OS specified action related to this notification.
    //
    if (pColormapObj->CBase.NotifyAction)
    {
        osNotifyEvent(pDev,
                      (POBJECT)pColormapObj, 
                      NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY,
                      0 /* Method */, 
                      0 /* Data */, 
                      status, 
                      pColormapObj->CBase.NotifyAction);
    }
                                       
    pDev->colormapObjectToNotify = NULL;
    return rmStatus;
}

//---------------------------------------------------------------------------
//
//  Graphics notification on completion of VBlank.
//
//---------------------------------------------------------------------------

RM_STATUS grVideoSwitchComplete
(
	PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    notifyFillNotifier(pDev, ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, 0, 0, Status);
    //KJK dmaEndXfer(((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Xlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action)
    {
        osNotifyEvent(pDev,
                      Object,
        			  0,
                      0x0400 + (Data << 2),
                      Object->Name,
                      Status,
                      ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Action);
    }
    ((PVIDEOSWITCHOBJECT)Object)->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Default HW method handler for graphics engine classes.
//
//---------------------------------------------------------------------------

RM_STATUS grHWMethod
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: grHWMethod class ", Object->Class->Type);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            chid ", Object->ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            handle ", Object->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            data ", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:            instance ", ((PCOMMONOBJECT)Object)->Instance);
    DBG_BREAKPOINT();

    //
    // THIS IS A HARDWARE METHOD...
    //
    // We'll only be here if we get an ILLEGAL_MTHD exception
    // from graphics.  We don't attempt any recovery, just drop
    // it on the floor and continue...
    //
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\gr.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GR.C                                                              *
*   The graphics engine is managed in this module.  All priviledged state   *
*   relating to the canvas and datapath is managed here.  Context switching *
*   is also contained here.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <gr.h>
#include <os.h>
#include "nvhw.h"
#ifdef WIN32
#include "nvwin32.h"   // XXX this shouldn't be needed
#else
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001
#endif

//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// Globals.
//
// PVBLANKNOTIFY grVBlankList[2];

//---------------------------------------------------------------------------
//
//  Graphics VBlank servicing.
//
//---------------------------------------------------------------------------

RM_STATUS grWaitVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBgrVBlankList[buffer];
    pDev->DBgrVBlankList[buffer] = VBlankNotify;
    return (RM_OK);
}
RM_STATUS grVBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    VBlankNotify = pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev, VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;
    }
    pDev->DBgrVBlankList[pDev->Framebuffer.FlipFrom] = NULL;
    pDev->Framebuffer.FinishFlags = 0;
    return (RM_OK);
}
RM_STATUS grCancelVBlank
(
    PHWINFO pDev,
    PVBLANKNOTIFY VBlankNotify
)
{
    U032          i;
    PVBLANKNOTIFY VBlankMatch;

    for (i = 0; i < 2; i++)
    {
        if (VBlankNotify == pDev->DBgrVBlankList[i])
        {
            pDev->DBgrVBlankList[i] = VBlankNotify->Next;
            VBlankNotify->Next = NULL;
            return (RM_OK);
        }
        else
        {
            VBlankMatch = pDev->DBgrVBlankList[i];
            while (VBlankMatch && VBlankMatch->Next != VBlankNotify)
                VBlankMatch = VBlankMatch->Next;
            if (VBlankMatch)
            {
                VBlankMatch->Next  = VBlankNotify->Next;
                VBlankNotify->Next = NULL;
                return (RM_OK);
            }
        }
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Helper functions.
//
//---------------------------------------------------------------------------

static RM_STATUS grGetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    U032    Instance,
    POBJECT *cachedObject
)
{
    POBJECT lastObject = pDev->DBfifoTable[ChID].LastIllegalMthdObject;

    *cachedObject = (POBJECT)NULL;
    if (lastObject != (POBJECT)NULL)
    {
        if (ENGDECL_FIELD(*lastObject->Class->EngineDecl, _TAG) == GR_ENGINE_TAG)
        {
            if ((((PCOMMONOBJECT)(lastObject))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // found it.
                *cachedObject = lastObject;
                return RM_OK;
            }
        }
    }

    // did not find a match.
    return RM_ERR_BAD_OBJECT; 
}

static VOID grSetLastIllegalMthdObject
(
    PHWINFO pDev,
    U032    ChID,
    POBJECT Object
)
{
    pDev->DBfifoTable[ChID].LastIllegalMthdObject = Object;
}
//---------------------------------------------------------------------------
//
//  Graphics engine service.
//
//---------------------------------------------------------------------------

#define BENSWORK

V032 grService
(
    PHWINFO pDev
)
{
    RM_STATUS   status = RM_OK;
    POBJECT     Object = NULL;
    POBJECT     Object2 = NULL;
    PDMAOBJECT  DmaObject;
    V032        Intr;
    U032        Instance, NotifyInstance;
    U032        ChID;
    U032        Class;
    U032        Offset;
    U032        Data;
    U032        NotifySource;
    GREXCEPTIONDATA ExceptionData;
#ifdef BENSWORK
    U032      isDebuggerPresent;
    U032      mustNotifyDebugger;

    isDebuggerPresent  = ((PRMINFO)pDev->pRmInfo)->Debugger.object != NULL;
    mustNotifyDebugger = 0;
#endif

    //
    // Disable FIFO from writing to GE and wait for GE idle.
    //
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    //
    // Waiting for everything in the graphics engine to go idle is too restrictive.  Some
    // exceptions are raised while the offending function has stalled part of the engine,
    // therefore making it impossible to wait for idle.
    //
    // Only wait for idle in the specific interrupt handlers.
    //
    //GR_DONE();

    Intr = REG_RD32(NV_PGRAPH_INTR);

    if (Intr == 0)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics empty interrupt!!\n\r");
    
    //
    // Query HAL for exception data.
    // any engine-based exceptions.
    //
    nvHalGrGetExceptionData(pDev, &ExceptionData);

    //
    // Here's where we'd bypass HAL gr exception handling if needed.
    // 

    //
    // Give HAL chance to service selected exceptions.
    //
    nvHalGrService(pDev, Intr, &ExceptionData);

    //
    // Refresh interrupt status since HAL may have resolved
    // some (or all) pending conditions.
    //
    if ((Intr = REG_RD32(NV_PGRAPH_INTR)) == 0)
    {
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        return (Intr);
    }

    //
    // Decode exception data.
    //
    Class = ExceptionData.classNum;
    NotifyInstance = ExceptionData.NotifyInstance;
    Instance = ExceptionData.Instance;
    Offset = ExceptionData.Offset;
    Data = ExceptionData.Data;
    ChID = ExceptionData.ChID;
    NotifySource = ExceptionData.Nsource;
    
    //
    // Reset interrupt registers before servicing them.
    //
    REG_WR32(NV_PGRAPH_INTR, Intr);

    //
    // If that was the only reason we're in here, let's leave now.  Most of the object
    // status updates that follow aren't valid when we just context switching.
    //
    if ((Intr == DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING)) || 
        (Intr == DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _PENDING)))
    {    
        //
        // Reset FIFO.
        //
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        return (REG_RD32(NV_PGRAPH_INTR));
    }
    
    //
    // The rest of the exceptions require that we know what object we're currently using.
    // Convert the object instance into the actual object pointer so we can route everything
    // appropriately.
    // 
    if (!Instance)
    {    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object instance is zero!!\n\r");
    }            
    else        
    {        
        status = grGetLastIllegalMthdObject(pDev, ChID, Instance, &Object);
        if (status != RM_OK)
        {
            status = grContextInstanceToObject(pDev, ChID, Instance, &Object);
            if (status)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics exception with NO valid object\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Status:", status);
            }
        }
        //
        // Let's take this opportunity to update this object's notify information (ctx and request).
        // This is important information if we (the resmgr) need to perform the notification that
        // wasn't completed by the hardware due to this error condition.
        //
        // We need to convert the instance into a dma object, then plug the dma object
        // into this graphics object.  Also see if a notify is currently pending.
        //
        if (Object && NotifyInstance)
        {        
            status = dmaContextInstanceToObject(pDev, ChID, NotifyInstance, &DmaObject);
            if (status)
                Object->NotifyXlate = NULL;
            else
                Object->NotifyXlate = DmaObject;            
        }                

        //
        // Is there a notify pending in the hardware?
        //
        if ((NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING)) && Object)
        {
            GRNOTIFYDATA grNotifyData;

            nvHalGrGetNotifyData(pDev, &grNotifyData);
            if (grNotifyData.trigger == TRUE)
            {
                Object->NotifyTrigger = TRUE;
                Object->NotifyAction = grNotifyData.action;
                if (Object->NotifyXlate == NULL)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Pending notification with NO valid notifier\n\r");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Object:", Object->Name);
                } else
                    status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);

                // we've handled the notify here, so clear the PENDING bit
                NotifySource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING);                
            }
        }
    }
    
    //
    // Missing hardware?  Must be a software method.  Route accordingly.
    //
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Check per-class valid method.
        //
        status = classSoftwareMethod(pDev, Object, Offset, Data);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software method.\n\r");
            if (Object)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Object:  ", Object->Name);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software ChID:    ", ChID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Class:   ", Class);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Offset:  ", Offset);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Data:    ", Data);
        }
    }

    //
    // Software assisted notification?
    //
    // Note: only NV10 has a PGRAPH_INTR_ERROR_PENDING bit which also flags
    // illegal method exceptions, but it should be safe to check this on NV4
    // since this'll read back as 0.
    //
    if (((Intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (Intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING))) && Object)
    {
        //
        // Notification.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics exception handler.\n\r");
        
        // KJK!! Missing hardware as a protection fault!!
        //
        // Check per-class valid method.
        //
        if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {        
        
            //
            // Wait for idle
            //
            GR_DONE();
        
            //
            // Convert the incoming data into the object id so the method can handle it.  Remember
            // that the FIFO has done a hash on the incoming data and passed the actual instance
            // pointer to the graphics engine.  Since we need to process based on the original data,
            // we need to convert it back to the original user data.
            //
            if (Offset < 0x200)
            {
                if (!Data)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object context data is zero!!\n\r");
                status = grContextInstanceToObject(pDev, ChID, Data, &Object2);
                if (status)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics exception with NO valid context\n\r");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Status:", status);
                }
                if (status == RM_OK && Object2 != NULL)    
                {
                    Data = Object2->Name;
                }
            }                
        
            // Cache this object as the lastIllegalMthdObject.
            grSetLastIllegalMthdObject(pDev, ChID, Object);
            status = classSoftwareMethod(pDev, Object, Offset, Data);
            if (status)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software method error!\n\r");
                if (Object)
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Object:  ", Object->Name);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software ChID:    ", ChID);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Class:   ", Class);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Offset:  ", Offset);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics software Data:    ", Data);

#ifdef BENSWORK // case 1
                // external debugger registered?
                if (isDebuggerPresent)
                {
                    NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,1,3,Object ? Object->Name : ~0,ChID,Class,Offset,Data,0);
                    mustNotifyDebugger = 1;
                }
#endif
            }
        }
        else if (NotifySource)
        {
            // 
            // Determine the notification type.  The hardware will only track the cause, not the
            // type of notification the client has requested.  What is actually be done with this
            // notify (action) is determined by per-object data.
            // 
            //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
            
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFICATION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics software notification pending!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics invalid data error!\n\r");
            }
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PROTECTION_ERROR, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics surface protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _RANGE_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics range exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_COLOR, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics color buffer limit error!\n\r");
            //if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _LIMIT_ZETA, _PENDING))
            //    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics zeta buffer limit error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_R_PROTECTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics dma read protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DMA_W_PROTECTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics dma write protection error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _FORMAT_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics format exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _PATCH_EXCEPTION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics patch exception error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _STATE_INVALID, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics object state invalid error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _DOUBLE_NOTIFY, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics double notify error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _NOTIFY_IN_USE, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics notify in use error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _METHOD_CNT, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics method count error!\n\r");
            if (NotifySource & DRF_DEF(_PGRAPH, _NSOURCE, _BFR_NOTIFICATION, _PENDING))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics buffer notification error!\n\r");
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:          ERROR:   ", NotifySource);
            if (Object)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:         Object:   ", Object->Name);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:           ChID:   ", ChID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:          Class:   ", Class);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:         Offset:   ", Offset);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:           Data:   ", Data);
            DBG_BREAKPOINT();
#ifdef BENSWORK // case 2
            // external debugger registered?
            if (isDebuggerPresent)
            {
                NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,2,3,0,0,0,0,0,0);
                mustNotifyDebugger = 1;
            }
            else
            {
                DBG_BREAKPOINT();
            }
#else
            DBG_BREAKPOINT();
#endif
            status = notifyMethodComplete(pDev, Object, Offset, Data, RM_OK);
        }            
    }
    
    //
    // Software assisted buffer notification?
    //    
    if ((Intr & DRF_DEF(_PGRAPH, _INTR, _BUFFER_NOTIFY, _PENDING)) && Object)
    {
    
        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Notification.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics buffer software notification\n\r");
        Object->NotifyTrigger = TRUE;
        // 
        // Determine the notification type.  The hardware will only track the cause, not the
        // type of notification the client has requested.  What is actually be done with this
        // notify (action) is determined by per-object data.
        // 
        //Object->NotifyAction = REG_RD_DRF(_PGRAPH, _NOTIFY, _TYPE);
        //
        // If the notify status is zero (no error), then this must have occurred due to
        // a WRITE_THEN_AWAKEN request
        //
        //if (!REG_RD32(NV_PGRAPH_NSTATUS))
            Object->NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
        status = notifyBufferHWComplete(pDev, Object, Offset, Data, 1, RM_OK);
    }

#ifdef BENSWORK // case 3
    // external debugger registered?
    if (isDebuggerPresent)
    {
        // check for DMA faults on channel A & B
        if ((Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
         || (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING)))
        {
            NvdeAppendEventForDebugger ((PNVDEOBJECT)((PRMINFO)pDev->pRmInfo)->Debugger.object,3,3,0,0,0,0,0,0);
            mustNotifyDebugger = 1;
        }
    }
#endif
#ifdef DEBUG
    //
    // DMA Fault on channel A?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_A, _PENDING))
    {
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (A)\n\r");
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_CONTROL    = ", REG_RD32(NV_PGRAPH_DMA_A_CONTROL));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_LIMIT      = ", REG_RD32(NV_PGRAPH_DMA_A_LIMIT));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_PTE    = ", REG_RD32(NV_PGRAPH_DMA_A_TLB_PTE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_TAG    = ", REG_RD32(NV_PGRAPH_DMA_A_TLB_TAG));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_ADJ_OFFSET = ", REG_RD32(NV_PGRAPH_DMA_A_ADJ_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_OFFSET     = ", REG_RD32(NV_PGRAPH_DMA_A_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_SIZE       = ", REG_RD32(NV_PGRAPH_DMA_A_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_Y_SIZE     = ", REG_RD32(NV_PGRAPH_DMA_A_Y_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_INSTANCE   = ", REG_RD32(NV_PGRAPH_DMA_A_XLATE_INST));
    }

    //
    // DMA Fault on channel B?
    //
    if (Intr & DRF_DEF(_PGRAPH, _INTR, _TLB_PRESENT_B, _PENDING))
    {
    
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Graphics DMA TLB not present or valid (B)\n\r");
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_CONTROL    = ", REG_RD32(NV_PGRAPH_DMA_B_CONTROL));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_LIMIT      = ", REG_RD32(NV_PGRAPH_DMA_B_LIMIT));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_PTE    = ", REG_RD32(NV_PGRAPH_DMA_B_TLB_PTE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_TLB_TAG    = ", REG_RD32(NV_PGRAPH_DMA_B_TLB_TAG));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_ADJ_OFFSET = ", REG_RD32(NV_PGRAPH_DMA_B_ADJ_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_OFFSET     = ", REG_RD32(NV_PGRAPH_DMA_B_OFFSET));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_SIZE       = ", REG_RD32(NV_PGRAPH_DMA_B_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_Y_SIZE     = ", REG_RD32(NV_PGRAPH_DMA_B_Y_SIZE));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DMA_INSTANCE   = ", REG_RD32(NV_PGRAPH_DMA_B_XLATE_INST));
    }
    
    if (REG_RD32(NV_PGRAPH_INTR) != 0)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Graphics interrupt not completely serviced = ", REG_RD32(NV_PGRAPH_INTR));
    }
#endif // DEBUG

    //
    // Reset FIFO.
    //
#ifdef BENSWORK
    if (mustNotifyDebugger)
    {
        osNotifyEvent(pDev, ((PRMINFO)pDev->pRmInfo)->Debugger.object, 0, 0, 0, RM_OK, NV_OS_WRITE_THEN_AWAKEN);
    }
    else
    {
#endif
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
#ifdef BENSWORK
    }
#endif

    return (REG_RD32(NV_PGRAPH_INTR));
}

//
//  Search for the object matching a given context instance.
//
RM_STATUS grContextInstanceToObject
(
    PHWINFO  pDev,
    U032     ChID,
    U032     Instance,
    POBJECT *GrObject
)
{
    PNODE node;
    U032  engineTag;
    
    *GrObject = NULL;
    
    //
    // Do this brute force.  Search the whole fifo tree for the object.
    // 
    // Go find the minimum value (>0) and start there.  That way we're
    // sure to visit every node.
    //
    btreeEnumStart(0, &node, pDev->DBfifoTable[ChID].ObjectTree);

    while (node != NULL)
    {
        //
        // Get engine tag associated with this object (see nvhal.h for
        // list of valid tags).
        //
        engineTag = ENGDECL_FIELD(*(((POBJECT)(node->Data))->Class)->EngineDecl, _TAG);

        //
        // We only want graphics/software objects, so prune out
        // everything else.
        //
        if (engineTag != CLASS_PSEUDO_ENGINE_TAG && engineTag != NO_ENGINE)
        {
            //
            // Verify the instance
            //
            if ((((PCOMMONOBJECT)(node->Data))->Instance & 0xFFFF) == (Instance & 0xFFFF))
            {
                // FOUND IT!!
                *GrObject = (POBJECT)(node->Data);
                return (RM_OK);
            }
        }

        btreeEnumNext(&node, pDev->DBfifoTable[ChID].ObjectTree);
    }
    
    return (RM_ERR_BAD_OBJECT);
}

//
// Delete the graphics context instance for a given object
//
RM_STATUS grDeleteObjectInstance
(
    PHWINFO       pDev,
    PCOMMONOBJECT Object
)
{
    RM_STATUS status = RM_OK;

    //
    // Free the instance
    //
    if (Object->Instance) {
        status = fbFreeInstMem(pDev, Object->Instance, 1);    // one paragraph
        if (status)
            return(status);

        //
        // Zero the fields, just in case
        //
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0);
        INST_WR32(Object->Instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), 0);
        
        Object->Instance = 0;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GROBJ.C                                                           *
*   The graphics engine is managed in this module.  Graphics objects are    *
*   created and deleted here.  Graphics object methods are implemented      *
*   also contained here.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <btree.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>   
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Degubbing macros.
//
#ifdef DEBUG
#define VALIDATE_GROBJ(go)  \
if (((POBJECT)go)->Name < 4096) \
{                           \
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid graphics object name!\n\r"); \
    DBG_BREAKPOINT();       \
}
#else
#define VALIDATE_GROBJ(go)
#endif //  DEBUG
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;
//
// The canvas tree.
//
// PNODE grCanvasTree;

//
// Class lock macros.
//

#define GRCLASSLOCK_ISSET(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] & (1 << bit))
#define GRCLASSLOCK_SET(pdev,chid,bit)      (((U032 *)(pDev->Graphics.ClassLocks))[chid] |= (1 << bit))
#define GRCLASSLOCK_CLEAR(pdev,chid,bit)    (((U032 *)(pDev->Graphics.ClassLocks))[chid] &= ~(1 << bit))

//---------------------------------------------------------------------------
//
//  Create/Delete graphics objects.
//
//---------------------------------------------------------------------------

//
// Ordinal to video switch.
//
RM_STATUS grCreateOrdinal
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *GrObject
)
{
    RM_STATUS status;
    U032      i;
    
    status = osAllocMem((VOID **)GrObject, sizeof(ORDINALOBJECT));
    if (status)
        return (status);
    ((PORDINALOBJECT)*GrObject)->Value               = 0;
    ((PORDINALOBJECT)*GrObject)->FanOut              = 0;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PORDINALOBJECT)*GrObject)->Switch[i]       = 0;
    //
    // Increment the number of ordinals (and thus double buffered apps) in
    // the system.
    //
    pDev->Framebuffer.FlipUsageCount &= 0x7FFFFFFF;
    pDev->Framebuffer.FlipUsageCount++;
    return (RM_OK);
}
RM_STATUS grDeleteOrdinal
(
    POBJECT GrObject
)
{
    return osFreeMem(GrObject);
}

//---------------------------------------------------------------------------
//
//  Canvas routines.
//
//---------------------------------------------------------------------------

VOID grInitCommon(
    PCOMMONOBJECT pCommon,
	U032 Device
)
{
    //
    // Load up the default settings for a new common hardware object
    //
    pCommon->Valid         = FALSE;    
    pCommon->NotifyPending = FALSE;
    pCommon->Instance      = 0;
    pCommon->NotifyObject  = NULL;
    pCommon->Dma0Object    = NULL;
    pCommon->Dma1Object    = NULL;
    pCommon->Next          = NULL;
}

VOID grInitRenderCommon(
    PRENDERCOMMON pRenderCommon
)
{
    //
    // Load up the default settings for a new common render object
    //
    pRenderCommon->Xlate        = NULL;

    //
    // Default out the full patch context
    //
    pRenderCommon->PatchContext.ColorKey    = NULL;
    pRenderCommon->PatchContext.Pattern     = NULL;
    pRenderCommon->PatchContext.Clip        = NULL;
    pRenderCommon->PatchContext.Rop         = NULL;
    pRenderCommon->PatchContext.Beta1       = NULL;
    pRenderCommon->PatchContext.Beta4       = NULL;
    pRenderCommon->PatchContext.Surface     = NULL;
    pRenderCommon->PatchContext.SurfaceSource = NULL;
    pRenderCommon->PatchContext.Operation   = NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND;
    
}

//
// grIsRenderObject
//
// This routine returns TRUE if the given class is a rendering
// object, FALSE otherwise.
//
static BOOL
grIsRenderObject(U032 class)
{
    switch (class)
    {
        case NV1_BETA_SOLID:
        case NV1_IMAGE_SOLID:
        case NV1_IMAGE_PATTERN:
        case NV1_IMAGE_BLACK_RECTANGLE:
        case NV3_CONTEXT_ROP:
        case NV3_CONTEXT_SURFACE_0:
        case NV3_CONTEXT_SURFACE_1:
        case NV3_CONTEXT_SURFACE_2:
        case NV3_CONTEXT_SURFACE_3:
        case NV4_CONTEXT_SURFACES_2D:
        case NV4_CONTEXT_PATTERN:
        case NV4_CONTEXT_SURFACE_SWIZZLED:
        case NV4_CONTEXT_SURFACES_ARGB_ZS:
        case NV4_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
            return FALSE;
        //default:
            // default action is to fall thru
    }
    return TRUE;
}

//
// grCreateObj
//
// Generic graphics engine object creation routine.
//
RM_STATUS
grCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID* pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status = RM_OK;
    PCOMMONOBJECT pCommonObject;
    PCLASS pClass = ClassObject->Base.ThisClass;
    U032 lockBit;
    U032 instSize, instAlign, size;
    BOOL isRenderObj;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: grCreateObj class ", pClass->Type);

    //
    // Check per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        if (GRCLASSLOCK_ISSET(pDev, ClassObject->Base.ChID, lockBit))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class already exists in channel ", ClassObject->Base.ChID);
            return (RM_ERR_ILLEGAL_OBJECT);
        }
        GRCLASSLOCK_SET(pDev, ClassObject->Base.ChID, lockBit);
    }

    //
    // Determine if this class is a rendering class (and therefore
    // represented by a RENDERCOMMONOBJECT structure).
    //
    isRenderObj = grIsRenderObject(pClass->Type);

    //
    // Allocate space for object.
    //
    size = (isRenderObj) ? sizeof (RENDERCOMMONOBJECT) : sizeof (COMMONOBJECT);
    status = osAllocMem((VOID **)Object, size);
    if (status)
    {
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Init render object data.
    //
    if (isRenderObj)
        grInitRenderCommon(&((PRENDERCOMMONOBJECT)pCommonObject)->RenderCommon);

    //
    // Allocate instance memory.  The amount allocated is based
    // on two values:  the default size from the engine declaration
    // entry plus any additional space that might be specified via
    // the class instance memory alloc entry.
    //
    // Note that graphics objects currently only use the default, but
    // on NV20 the Kelvin class is going to require more than a
    // single paragraph of instance memory.
    //
    // Also factor in any alignment requirements if necessary.
    //
    instSize = ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ);
    instAlign = 0;
    if (pClass->ClassInstMalloc) {
        instSize += CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _SIZE);
        instAlign = CLASSINSTMALLOC_FIELD(*pClass->ClassInstMalloc, _ALIGN);
    }

    if (instAlign)
        status = fbAllocInstMemAlign(pDev, &(pCommonObject->Instance), instSize, instAlign);
    else
        status = fbAllocInstMem(pDev, &(pCommonObject->Instance), instSize);

    if (status)
    {
        if (lockBit != NO_LOCK)
            GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        osFreeMem(*Object);
        return (status);
    }

    //
    // Let the HAL setup instance memory for the object.
    //
    status = nvHalGrAlloc(pDev, pCommonObject->Base.ChID, pCommonObject->Instance, pClass->Type);
    if (status == RM_OK)
    {
        //
        // Override any HAL initialization here.
        //

        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pCommonObject->Base, 
                                          pCommonObject->Base.ChID, 
                                          pCommonObject->Instance);
    }

    if (status != RM_OK)
    {
        fbFreeInstMem(pDev, pCommonObject->Instance, instSize);
        osFreeMem(*Object);
        GRCLASSLOCK_CLEAR(pDev, ClassObject->Base.ChID, lockBit);
        return (status);
    }
    
    //
    // Object allocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);     // no error recover required

    return (RM_OK);
}

RM_STATUS
grDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCOMMONOBJECT           pCommonObject;
    PCLASS                  pClass;
    U032                    lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: grDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalGrFree(pDev, pCommonObject->Base.ChID, pCommonObject->Instance);

    //
    // Invalidate any objects attached to this context
    //
    // !!KJK Only need to do this if we link the contexts to the objects
    //
    // Delete the instance data structure for this object
    //
    status = fbFreeInstMem(pDev, pCommonObject->Instance, ENGDECL_FIELD(*pClass->EngineDecl, _OBJINSTSZ));
    if (status)
        return (status);
        
    pCommonObject->Instance = 0;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pCommonObject->Base, pCommonObject->Base.ChID); 
    if (status)
        return (status);
  
    //
    // Clear per-channel allocation restrictions if applicable.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK) {
        //ASSERT(pDev->Graphics.ClassLocks[pCommonObject->Base.ChID] & (1 << lockBit))
        GRCLASSLOCK_CLEAR(pDev, pCommonObject->Base.ChID, lockBit);
    }
      
    //
    // Object deallocation is a possible power mgmt trigger.  Let's go check.
    //
    status = mcPowerStateTrigger(pDev);  // no error recovery required

    //
    // And finally delete the object itself.
    //    
    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grcxnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCTXT.C                                                          *
*   The graphics engine is managed in this module.  Context switching is    *
*   contained here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrLoadChannelContext_NV10(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV10(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
VOID nvHalGrLoadHW(PHALHWINFO, U032, PGRAPHICSCHANNEL_NV10);
RM_STATUS nvHalGrGetState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrPutState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrSetMaterialEmission_NV10(PHALHWINFO, PGREXCEPTIONDATA);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV10(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

static RM_STATUS grDelay_NV10(PHALHWINFO, U032);

// values for enabling passthrough modes
static U032 Vertex_Passthr_Mode[] = {
    0x10000000,
    0x00000000
};
#define VERTEX_COUNT            (sizeof(Vertex_Passthr_Mode) / sizeof(U032))
static U032 ScaleOffset_Passthr_Mode[] = {
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x3F800000,
    0x0,
    0x0,
    0x0,
    0x0
};
#define SCALEOFFSET_COUNT       (sizeof(ScaleOffset_Passthr_Mode) / sizeof(U032))

static U032 Fog_Passthr_Mode[2][3] = {
    { 0x0,        0x0,        0x0 },           // passthrough mode values for A01
    { 0x3F800000, 0x3F800000, 0x3F800000 }     // passthrough mode values for >= A02
};
#define FOG_COUNT               (sizeof(Fog_Passthr_Mode[0]) / sizeof(U032))

static U032 Fog_EyeDist_Passthr_Mode[] = {
    0x0,
    0x0,
    0x0
};
#define FOG_EYEDIST_COUNT        (sizeof(Fog_EyeDist_Passthr_Mode) / sizeof(U032))

//
// Second Inverse ModelViewMatrix location in the XF engine needed for HW
// workaround both for RM related context switching and GetState context
// switching (see notes in grLoadChannelContext for details).
// 
#define INV2_MATRIX_OFFSET    0x653C

//
// Load Pipe Context
//
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}

#define Z16_OVR_MASK (DRF_MASK(NV_PGRAPH_SURFACE_Z16_OVERRIDE) <<    \
                      DRF_SHIFT(NV_PGRAPH_SURFACE_Z16_OVERRIDE))

//
// We're in the midst of a context switch loading in a new 3D channel that
// needs a Celsius method resent to workaround a HW problem. We either need
// to resubmit a Vertex Buffer, or a NOP to setup a correct load of the
// Z16_OVERRIDE bit in PGRAPH_SURFACE.
//
//  1) switch to the Celsius subchannel for the new channel
//  2) save off the method in the stage 2 GR fifo
//  3) load the Celsius method in the stage 2 register
//  4) reenable enough of the GR fifo, so this method/data goes through
//  5) wait for the value to show-up, then disable the GR fifo again
//  6) reload the stage 2 register
//  7) switch back to the correct subchannel before the context switch
//
// Note: Eventhough we're checking for NV11_CELSIUS_PRIMITIVE, we'll never
//       match on that value, since the HW can only hold an 8 bit value and
//       a NV11's class number is 16 bits. But, because 0x1196 will look
//       like 0x96 (NV15's value), the class will match and should be ok.
//
static VOID
grResubmitCelsiusMethod(
    PHALHWINFO pHalHwInfo,
    U032       ChID,            // new ChID
    BOOL       resendDmaVtx
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan = &pGrHalPvtInfo->grChannels[ChID];    
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 grclass, celsius;
    U032 st2, datalo, datahi, z16_data=0;

    //
    // On the initial load of this channel, we don't have any saved context, so
    // applying one of these workarounds doesn't seem possible. But really, it's
    // unnecessary, since the HW's going to receive the state setting methods
    // anyways.
    //
    if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) != ChID)
        return;

    // mark this new channel as owning graphics
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);

    if (resendDmaVtx) {
        //
        // Determine which is the Celsius subchan and make it current
        //
        for (celsius = 0; celsius < NUM_SUBCHANNELS; celsius++)
        {
            grclass = DRF_VAL(_PGRAPH, _CTX_CACHE1, _GRCLASS, pGrChan->ContextCache1[celsius]);
            if ((grclass == NV10_CELSIUS_PRIMITIVE) ||
                (grclass == NV15_CELSIUS_PRIMITIVE) ||
                (grclass == NV11_CELSIUS_PRIMITIVE))
                    break;
        }
        if (celsius == NUM_SUBCHANNELS)
            return;     // couldn't find the Celsius object loaded

    } else {
        // use the existing subchan (all classes can handle a NOP)
        celsius = REG_RD_DRF(_PGRAPH, _CTX_USER, _SUBCH);
    }

    //
    // Make the Celsius object current by copying the saved subchan
    // state for CTX_CACHE(celsius) into the CTX_SWITCH registers.
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextCache1[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextCache2[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextCache3[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextCache4[celsius]);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextCache5[celsius]);

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _SUBCH, celsius);

    // save the stage2 values, which'll be reloaded after the method's been sent
    st2     = REG_RD32(NV_PGRAPH_FFINTFC_ST2);
    datalo  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DL);
    datahi  = REG_RD32(NV_PGRAPH_FFINTFC_ST2_DH);

    if (resendDmaVtx) {
        // Set an invalid instance address in GLOBALSTATE1
        FLD_WR_DRF_DEF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, _INVALID);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV056_SET_CONTEXT_DMA_VERTEX    |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL,
                 DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1));
    } else {    // resend Z16 override for NV11
        //        
        // Flip all the bits that are in trapped data currently, mask
        // off the bit we want and or in the bit we want to show up in
        // Z16 override
        //
        z16_data  =  (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) ^ 0xFFFFFFFF);
        z16_data  &= ~Z16_OVR_MASK;
        z16_data  |= (Z16_OVR_MASK & pGrChan->CurrentPatch.Surface);

        // Load the method/data into the stage2 register
        REG_WR32(NV_PGRAPH_FFINTFC_ST2,                         NV1196_NO_OPERATION             |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _SUBCH,         celsius)                        |
                 DRF_NUM(_PGRAPH, _FFINTFC_ST2, _CHID,          ChID)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _DATAHIGH,      _INVALID)                       |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _STATUS,        _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS,   _VALID)                         |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHSWITCH,      _SET)                           |
                 DRF_DEF(_PGRAPH, _FFINTFC_ST2, _FIFOHOLD,      _SET));

        // Method data is either 0x0 or 0x1, depending on desired value of Z16_OVERRIDE
        REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, z16_data);
    }

    // Briefly enable PGRAPH_FIFO_ACCESS (and mark the channel valid),
    // so our method can come through
    FLD_WR_DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID);
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);

    if (resendDmaVtx) {
        // spin until we see our instance address show up in the register
        while (REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2) !=
               DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
            ;
    } else {
        // spin until we see the NOP method and data in the trapped registers
        while ((REG_RD_DRF(_PGRAPH, _TRAPPED_ADDR, _MTHD) !=
                DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _MTHD, NV1196_NO_OPERATION)) ||
                (REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW) != z16_data))
                ;
    }

    // Disable PGRAPH_FIFO_ACCESS again
    FLD_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

    // Now, restore the stage2 method/data
    REG_WR32(NV_PGRAPH_FFINTFC_ST2,    st2);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DL, datalo);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2_DH, datahi);
}

//
// nvHalGrLoadChannelContext
//
RM_STATUS
nvHalGrLoadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 misc;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrLoadChannelContext_NV10\r\n");

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);
    
    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        nvHalGrUnloadChannelContext_NV10(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->grChannels[pGrHalPvtInfo->currentChID]);
    }

    if ((pGrHalPvtInfo->currentChID = ChID) == INVALID_CHID)
    {
        //
        // Set current channel to an invalid one.
        //
        FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

        //
        // Update current channel.
        //    
        REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
        //
        // Is the channel ID valid?
        //
    }
    else if (ChID >= NUM_FIFOS_NV10)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    // Reload the HW for the new channel
    nvHalGrLoadHW(pHalHwInfo,
                  ChID,
                  &pGrHalPvtInfo->grChannels[ChID]);

    // Update current channel.
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                                  
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    
    //
    // Clear the graphics fifo channel context.  This fixes a subtle hardware bug
    // when thrashing channel changes within the graphics fifo.  Ideally the fifo
    // would hold off pending data while a change is active, but it can actually
    // hold multiple changes.  In order to reduce hw confusion, they added a few
    // state bits within one stage fifo.  Clear those bits on channel changes.
    //
    // Since the bits are write only, they'll read as a zero.
    // Clear those bits on channel changes. Don't rely on these to read as zero
    // eventhough these bits are write only.
    //
    // XXX adding the comments from NV4/NV5 ... actually, we hit this on NV10
    // also (our FIFOHOLD bits were set, so we'll also mask these off on a read)
    // in case this explains the fifo hang we saw.
    //
    // We have to OR in the top bit to fool the Watcom compiler for the Win3.1 version
    // of the resmgr.
    //
    // REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) | 0x80000000);
    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    return (RM_OK);
}

U032 reset_delay = 0x0;

VOID
nvHalGrLoadHW(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    //
    // Because unloading the previous channel may not have reset GR
    // state, after the unload we'll manually reset the engines. In
    // doing this, we'll also need to restore the GR tiling registers,
    // since they get lost on a reset.
    //
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);

    // delay for at least 10 nvclks
    if (reset_delay == 0) {
        reset_delay = (1000000000 / pHalHwInfo->pDacHalInfo->NVClk);   // nvclk cycle time, in ns
        reset_delay *= 10;
    }
    grDelay_NV10(pHalHwInfo, reset_delay);
    
    // jump back out of reset
    REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _NORMAL);

    HAL_GR_IDLE(pHalHwInfo);

    // restore PGRAPH_TILE regs after PGRAPH_DEBUG_0_STATE_RESET
    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
    {
        REG_WR32(NV_PGRAPH_TLIMIT(i), REG_RD32(NV_PFB_TLIMIT(i)));
        REG_WR32(NV_PGRAPH_TSIZE(i),  REG_RD32(NV_PFB_TSIZE(i)));
        REG_WR32(NV_PGRAPH_TILE(i),   REG_RD32(NV_PFB_TILE(i)));
    }

    //
    // Apply context switch related workarounds after we've unloaded the
    // previous channels state, but before loading this new channels state.
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        //
        // Eventhough we're about to reload GLOBALSTATE1 which holds the inst addr for
        // the vertex buffers context DMA, neither the channel switch nor the priv write
        // invalidates a shadowed copy kept in the hardware. The only thing that does
        // is a SetContextDmaVertex method, so we'll send that before the priv write.
        //
        if (DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_2, pGrChan->CurrentPatch.GlobalState1))
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, TRUE);
        }

        //
        // With NV11, on a priv write to PGRAPH_SURFACE, the Z16_OVERRIDE bit is taken
        // from the last user method not from the RBI bus. To work around this, we'll
        // send down a NOP with the correct data pattern for the bit (0x0 or 0x1), so
        // the correct thing happens on the priv write to PGRAPH_SURFACE.
        // 
        REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

        if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface)
        {
            grResubmitCelsiusMethod(pHalHwInfo, ChID, FALSE);

            // wait for the pipe to go idle 
            HAL_GR_IDLE(pHalHwInfo);

            // rewrite PGRAPH_SURFACE to the correct value (done again below).
            REG_WR32(NV_PGRAPH_SURFACE, pGrChan->CurrentPatch.Surface);        

#ifdef DEBUG
            // make sure we've got the expected NV_PGRAPH_SURFACE value
            if (DRF_VAL(_PGRAPH, _CTX_USER, _CHID, pGrChan->ContextUser) == ChID) {
                if (REG_RD32(NV_PGRAPH_SURFACE) != pGrChan->CurrentPatch.Surface) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Incorrect Z16 override setting\r\n");
                    DBG_BREAKPOINT();
                }
            }
#endif
        }
    }

    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5, pGrChan->ContextSwitch5);

    for (i = 0; i < 8; i++)
    {    
        REG_WR32(NV_PGRAPH_CTX_CACHE1(i), pGrChan->ContextCache1[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE2(i), pGrChan->ContextCache2[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE3(i), pGrChan->ContextCache3[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE4(i), pGrChan->ContextCache4[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE5(i), pGrChan->ContextCache5[i]);
    }
    
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);
    
    //
    // Reload current dma registers
    //
    REG_WR32(NV_PGRAPH_DMA_START_0, pGrChan->DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1, pGrChan->DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,  pGrChan->DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,    pGrChan->DmaMisc);
    REG_WR32(NV_PGRAPH_DMA_PITCH,   pGrChan->DmaPitch);
            
    //
    // Reload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        REG_WR32(NV_PGRAPH_BOFFSET(i),  pGrChan->CurrentPatch.BufferOffset[i]);
        REG_WR32(NV_PGRAPH_BBASE(i),    pGrChan->CurrentPatch.BufferBase[i]);
        REG_WR32(NV_PGRAPH_BLIMIT(i),   pGrChan->CurrentPatch.BufferLimit[i]);
    }
    
    for (i = 0; i < 5; i++)
        REG_WR32(NV_PGRAPH_BPITCH(i),   pGrChan->CurrentPatch.BufferPitch[i]);
        
    REG_WR32(NV_PGRAPH_SURFACE,         pGrChan->CurrentPatch.Surface);        
    REG_WR32(NV_PGRAPH_STATE,           pGrChan->CurrentPatch.State);        
    REG_WR32(NV_PGRAPH_BSWIZZLE2,       pGrChan->CurrentPatch.BufferSwizzle[0]);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,       pGrChan->CurrentPatch.BufferSwizzle[1]);        
    REG_WR32(NV_PGRAPH_BPIXEL,          pGrChan->CurrentPatch.BufferPixel);

    REG_WR32(NV_PGRAPH_NOTIFY,          pGrChan->CurrentPatch.Notify);
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,     pGrChan->CurrentPatch.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,     pGrChan->CurrentPatch.PatternColor1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pGrChan->CurrentPatch.PatternColorRam[i]);
        
    REG_WR32(NV_PGRAPH_PATTERN(0),      pGrChan->CurrentPatch.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),      pGrChan->CurrentPatch.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,   pGrChan->CurrentPatch.PatternShape);
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,     pGrChan->CurrentPatch.MonoColor0);
    REG_WR32(NV_PGRAPH_ROP3,            pGrChan->CurrentPatch.Rop3);
    REG_WR32(NV_PGRAPH_CHROMA,          pGrChan->CurrentPatch.Chroma);
    REG_WR32(NV_PGRAPH_BETA_AND,        pGrChan->CurrentPatch.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,    pGrChan->CurrentPatch.BetaPremult);
    
    REG_WR32(NV_PGRAPH_CONTROL0,        pGrChan->CurrentPatch.Control0);
    REG_WR32(NV_PGRAPH_CONTROL1,        pGrChan->CurrentPatch.Control1);
    REG_WR32(NV_PGRAPH_CONTROL2,        pGrChan->CurrentPatch.Control2);
    REG_WR32(NV_PGRAPH_CONTROL3,        pGrChan->CurrentPatch.Control3);
    
    REG_WR32(NV_PGRAPH_BLEND,           pGrChan->CurrentPatch.Blend);
    REG_WR32(NV_PGRAPH_BLENDCOLOR,      pGrChan->CurrentPatch.BlendColor);
    REG_WR32(NV_PGRAPH_SETUPRASTER,     pGrChan->CurrentPatch.SetupRaster);
    REG_WR32(NV_PGRAPH_FOGCOLOR,        pGrChan->CurrentPatch.FogColor);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,  pGrChan->CurrentPatch.ColorKeyColor0);
    REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,  pGrChan->CurrentPatch.ColorKeyColor1);
    REG_WR32(NV_PGRAPH_POINTSIZE,       pGrChan->CurrentPatch.PointSize);

    REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,   pGrChan->CurrentPatch.ZOffsetFactor);
    REG_WR32(NV_PGRAPH_ZOFFSETBIAS,     pGrChan->CurrentPatch.ZOffsetBias);
    REG_WR32(NV_PGRAPH_ZCLIPMIN,        pGrChan->CurrentPatch.ZClipMin);
    REG_WR32(NV_PGRAPH_ZCLIPMAX,        pGrChan->CurrentPatch.ZClipMax);

    for (i = 0; i < 8; i++)
    {
        REG_WR32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i), pGrChan->CurrentPatch.WinClipHorz[i]);
        REG_WR32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i),   pGrChan->CurrentPatch.WinClipVert[i]);
    }

    REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
    REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

    REG_WR32(NV_PGRAPH_GLOBALSTATE0,         pGrChan->CurrentPatch.GlobalState0);
    REG_WR32(NV_PGRAPH_GLOBALSTATE1,         pGrChan->CurrentPatch.GlobalState1);

    REG_WR32(NV_PGRAPH_STORED_FMT,      pGrChan->CurrentPatch.StoredFmt);
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,    pGrChan->CurrentPatch.SourceColor);
    
    for (i = 0; i < 32; i++)
    {
        REG_WR32(NV_PGRAPH_ABS_X_RAM(i), pGrChan->CurrentPatch.AbsXRam[i]);
        REG_WR32(NV_PGRAPH_ABS_Y_RAM(i), pGrChan->CurrentPatch.AbsYRam[i]);
    }        
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,  pGrChan->CurrentPatch.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,  pGrChan->CurrentPatch.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,  pGrChan->CurrentPatch.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,  pGrChan->CurrentPatch.AbsUClipYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMIN, pGrChan->CurrentPatch.AbsUClip3DXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_XMAX, pGrChan->CurrentPatch.AbsUClip3DXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMIN, pGrChan->CurrentPatch.AbsUClip3DYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP3D_YMAX, pGrChan->CurrentPatch.AbsUClip3DYMax);

    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN, pGrChan->CurrentPatch.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX, pGrChan->CurrentPatch.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN, pGrChan->CurrentPatch.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX, pGrChan->CurrentPatch.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,  pGrChan->CurrentPatch.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,  pGrChan->CurrentPatch.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,  pGrChan->CurrentPatch.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,  pGrChan->CurrentPatch.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,  pGrChan->CurrentPatch.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,  pGrChan->CurrentPatch.XYLogicMisc3);

    REG_WR32(NV_PGRAPH_CLIPX_0,         pGrChan->CurrentPatch.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,         pGrChan->CurrentPatch.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,         pGrChan->CurrentPatch.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,         pGrChan->CurrentPatch.ClipY1);
    
    REG_WR32(NV_PGRAPH_COMBINE0ALPHAICW,   pGrChan->CurrentPatch.Combine0AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE0COLORICW,   pGrChan->CurrentPatch.Combine0ColorICW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAICW,   pGrChan->CurrentPatch.Combine1AlphaICW);
    REG_WR32(NV_PGRAPH_COMBINE1COLORICW,   pGrChan->CurrentPatch.Combine1ColorICW);
    
    REG_WR32(NV_PGRAPH_COMBINE0FACTOR,     pGrChan->CurrentPatch.Combine0Factor);
    REG_WR32(NV_PGRAPH_COMBINE1FACTOR,     pGrChan->CurrentPatch.Combine1Factor);

    REG_WR32(NV_PGRAPH_COMBINE0ALPHAOCW,   pGrChan->CurrentPatch.Combine0AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE0COLOROCW,   pGrChan->CurrentPatch.Combine0ColorOCW);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHAOCW,   pGrChan->CurrentPatch.Combine1AlphaOCW);
    REG_WR32(NV_PGRAPH_COMBINE1COLOROCW,   pGrChan->CurrentPatch.Combine1ColorOCW);

    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW0,   pGrChan->CurrentPatch.CombineSpecFogCW0);
    REG_WR32(NV_PGRAPH_COMBINESPECFOGCW1,   pGrChan->CurrentPatch.CombineSpecFogCW1);

    REG_WR32(NV_PGRAPH_TEXTUREOFFSET0,      pGrChan->CurrentPatch.TextureOffset0);
    REG_WR32(NV_PGRAPH_TEXTUREOFFSET1,      pGrChan->CurrentPatch.TextureOffset1);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE0,     pGrChan->CurrentPatch.TexturePalette0);
    REG_WR32(NV_PGRAPH_TEXTUREPALETTE1,     pGrChan->CurrentPatch.TexturePalette1);

    REG_WR32(NV_PGRAPH_TEXFORMAT0,         pGrChan->CurrentPatch.TexFormat0);
    REG_WR32(NV_PGRAPH_TEXFORMAT1,         pGrChan->CurrentPatch.TexFormat1);

    REG_WR32(NV_PGRAPH_TEXCONTROL0_0,      pGrChan->CurrentPatch.TexControl0_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL0_1,      pGrChan->CurrentPatch.TexControl0_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_0,      pGrChan->CurrentPatch.TexControl1_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL1_1,      pGrChan->CurrentPatch.TexControl1_1);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_0,      pGrChan->CurrentPatch.TexControl2_0);
    REG_WR32(NV_PGRAPH_TEXCONTROL2_1,      pGrChan->CurrentPatch.TexControl2_1);

    REG_WR32(NV_PGRAPH_IMAGERECT0,      pGrChan->CurrentPatch.ImageRect0);
    REG_WR32(NV_PGRAPH_IMAGERECT1,      pGrChan->CurrentPatch.ImageRect1);

    REG_WR32(NV_PGRAPH_FILTER0,         pGrChan->CurrentPatch.Filter0);
    REG_WR32(NV_PGRAPH_FILTER1,         pGrChan->CurrentPatch.Filter1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,      pGrChan->CurrentPatch.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,      pGrChan->CurrentPatch.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,      pGrChan->CurrentPatch.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,    pGrChan->CurrentPatch.DimxTexture);
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,   pGrChan->CurrentPatch.WdimxTexture);

    REG_WR32(NV_PGRAPH_DVD_COLORFMT,    pGrChan->CurrentPatch.DVDColorFormat);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,   pGrChan->CurrentPatch.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_MISC24_0,        pGrChan->CurrentPatch.Misc24_0);
    REG_WR32(NV_PGRAPH_MISC24_1,        pGrChan->CurrentPatch.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,        pGrChan->CurrentPatch.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,          pGrChan->CurrentPatch.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,          pGrChan->CurrentPatch.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,          pGrChan->CurrentPatch.Valid1);
    REG_WR32(NV_PGRAPH_VALID2,          pGrChan->CurrentPatch.Valid2);

    // wait for the pipe to go idle again after loading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    // restore pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);


        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            // set PrimType=NONE (0x0), which puts the following vertices into the vertex file
            i = 0x0;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
        }
        else
        {
            // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
            i = 0x8;
            grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);
            grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE, pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        REG_WR32(NV_PGRAPH_XFMODE0,         pGrChan->CurrentPatch.XFMode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         pGrChan->CurrentPatch.XFMode[1]);

        // load transform engine state
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);

        if (grclass == NV10_CELSIUS_PRIMITIVE)
        {
            U032 format, temp;

            //
            // The 8 FORMAT_SIZE values (bits 7:4) don't get saved correctly during an unload due
            // to a HW bug. To workaround this, the drivers shadow the values in the last DWORD of
            // the last row of the 2nd Inverse ModelViewMatrix (offset = 0x653C).
            // 
            // During a load of this ChID, we'll read the DWORD out of the matrix, unpack the bits
            // and put the correct values in grTable before they're restored into FORMAT_BASE.
            //
            format = pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS[(INV2_MATRIX_OFFSET - PIPE_CHEOPS_BASE)/4];
        
            for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
            {
                temp = pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i];
                temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
                pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[i] = temp;
            }
        }

        // load index DMA pipe state
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE,	pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

#ifdef NOTDEF
        //
        // Force an invalidate of the vertex cache. Since we force a
        // GR reset of the chip, this shouldn't be necessary anymore.
        //
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);
#endif
    }
}

RM_STATUS
nvHalGrUnloadChannelContext_NV10(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV10 pGrChan)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrUnloadChannelContext_NV10\r\n");

    //
    // No need to unload an invalid channel
    //
    if (ChID  == INVALID_CHID)
        return (RM_OK);

    //
    // Unload current context registers.
    //
    pGrChan->ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pGrChan->ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pGrChan->ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pGrChan->ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrChan->ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);

    for (i = 0; i < 8; i++)
    {    
        pGrChan->ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
        pGrChan->ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
        pGrChan->ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
        pGrChan->ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
        pGrChan->ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    }
    
    pGrChan->ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current dma registers
    //
    pGrChan->DmaStart0         = REG_RD32(NV_PGRAPH_DMA_START_0);
    pGrChan->DmaStart1         = REG_RD32(NV_PGRAPH_DMA_START_1);
    pGrChan->DmaLength         = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pGrChan->DmaMisc           = REG_RD32(NV_PGRAPH_DMA_MISC);
    pGrChan->DmaPitch          = REG_RD32(NV_PGRAPH_DMA_PITCH);
            
    //
    // Unload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        pGrChan->CurrentPatch.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
        pGrChan->CurrentPatch.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
        pGrChan->CurrentPatch.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    }
    
    for (i = 0; i < 5; i++)
        pGrChan->CurrentPatch.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
        
    pGrChan->CurrentPatch.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pGrChan->CurrentPatch.State               = REG_RD32(NV_PGRAPH_STATE);        
    pGrChan->CurrentPatch.BufferSwizzle[0]    = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pGrChan->CurrentPatch.BufferSwizzle[1]    = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    pGrChan->CurrentPatch.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pGrChan->CurrentPatch.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pGrChan->CurrentPatch.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pGrChan->CurrentPatch.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    
    // In NV10, we can access the pattern RAM anytime after the engine's been idled
    for (i = 0; i < 64; i++)
        pGrChan->CurrentPatch.PatternColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    pGrChan->CurrentPatch.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pGrChan->CurrentPatch.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pGrChan->CurrentPatch.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    pGrChan->CurrentPatch.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pGrChan->CurrentPatch.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pGrChan->CurrentPatch.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    pGrChan->CurrentPatch.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pGrChan->CurrentPatch.BetaPremult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    
    pGrChan->CurrentPatch.Control0            = REG_RD32(NV_PGRAPH_CONTROL0);
    pGrChan->CurrentPatch.Control1            = REG_RD32(NV_PGRAPH_CONTROL1);
    pGrChan->CurrentPatch.Control2            = REG_RD32(NV_PGRAPH_CONTROL2);
    pGrChan->CurrentPatch.Control3            = REG_RD32(NV_PGRAPH_CONTROL3);
    
    pGrChan->CurrentPatch.Blend               = REG_RD32(NV_PGRAPH_BLEND);
    pGrChan->CurrentPatch.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
    pGrChan->CurrentPatch.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
    pGrChan->CurrentPatch.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
    pGrChan->CurrentPatch.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
    pGrChan->CurrentPatch.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
    pGrChan->CurrentPatch.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);

    pGrChan->CurrentPatch.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
    pGrChan->CurrentPatch.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
    pGrChan->CurrentPatch.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
    pGrChan->CurrentPatch.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
    
    for (i = 0; i < 8; i++)
    {
        pGrChan->CurrentPatch.WinClipHorz[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i));
        pGrChan->CurrentPatch.WinClipVert[i]    = REG_RD32(NV_PGRAPH_WINDOWCLIP_VERTICAL(i));
    }

    pGrChan->CurrentPatch.XFMode[0]           = REG_RD32(NV_PGRAPH_XFMODE0);
    pGrChan->CurrentPatch.XFMode[1]           = REG_RD32(NV_PGRAPH_XFMODE1);

    pGrChan->CurrentPatch.GlobalState0        = REG_RD32(NV_PGRAPH_GLOBALSTATE0);
    pGrChan->CurrentPatch.GlobalState1        = REG_RD32(NV_PGRAPH_GLOBALSTATE1);

    pGrChan->CurrentPatch.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
    pGrChan->CurrentPatch.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    for (i = 0; i < 32; i++)
    {
        pGrChan->CurrentPatch.AbsXRam[i]      = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
        pGrChan->CurrentPatch.AbsYRam[i]      = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    }        
    
    pGrChan->CurrentPatch.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pGrChan->CurrentPatch.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pGrChan->CurrentPatch.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pGrChan->CurrentPatch.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pGrChan->CurrentPatch.AbsUClip3DXMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMIN);
    pGrChan->CurrentPatch.AbsUClip3DXMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_XMAX);
    pGrChan->CurrentPatch.AbsUClip3DYMin      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMIN);
    pGrChan->CurrentPatch.AbsUClip3DYMax      = REG_RD32(NV_PGRAPH_ABS_UCLIP3D_YMAX);
    
    pGrChan->CurrentPatch.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pGrChan->CurrentPatch.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pGrChan->CurrentPatch.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pGrChan->CurrentPatch.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pGrChan->CurrentPatch.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pGrChan->CurrentPatch.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pGrChan->CurrentPatch.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pGrChan->CurrentPatch.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pGrChan->CurrentPatch.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pGrChan->CurrentPatch.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);

    pGrChan->CurrentPatch.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pGrChan->CurrentPatch.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pGrChan->CurrentPatch.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pGrChan->CurrentPatch.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pGrChan->CurrentPatch.Combine0AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAICW);
    pGrChan->CurrentPatch.Combine1AlphaICW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAICW);
    pGrChan->CurrentPatch.Combine0ColorICW    = REG_RD32(NV_PGRAPH_COMBINE0COLORICW);
    pGrChan->CurrentPatch.Combine1ColorICW    = REG_RD32(NV_PGRAPH_COMBINE1COLORICW);

    pGrChan->CurrentPatch.Combine0Factor      = REG_RD32(NV_PGRAPH_COMBINE0FACTOR);
    pGrChan->CurrentPatch.Combine1Factor      = REG_RD32(NV_PGRAPH_COMBINE1FACTOR);

    pGrChan->CurrentPatch.Combine0AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE0ALPHAOCW);
    pGrChan->CurrentPatch.Combine1AlphaOCW    = REG_RD32(NV_PGRAPH_COMBINE1ALPHAOCW);
    pGrChan->CurrentPatch.Combine0ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE0COLOROCW);
    pGrChan->CurrentPatch.Combine1ColorOCW    = REG_RD32(NV_PGRAPH_COMBINE1COLOROCW);

    pGrChan->CurrentPatch.CombineSpecFogCW0   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW0);
    pGrChan->CurrentPatch.CombineSpecFogCW1   = REG_RD32(NV_PGRAPH_COMBINESPECFOGCW1);

    pGrChan->CurrentPatch.TextureOffset0      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET0);
    pGrChan->CurrentPatch.TextureOffset1      = REG_RD32(NV_PGRAPH_TEXTUREOFFSET1);
    pGrChan->CurrentPatch.TexturePalette0     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE0);
    pGrChan->CurrentPatch.TexturePalette1     = REG_RD32(NV_PGRAPH_TEXTUREPALETTE1);
    pGrChan->CurrentPatch.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFORMAT0);
    pGrChan->CurrentPatch.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFORMAT1);
    pGrChan->CurrentPatch.TexControl0_0       = REG_RD32(NV_PGRAPH_TEXCONTROL0_0);
    pGrChan->CurrentPatch.TexControl0_1       = REG_RD32(NV_PGRAPH_TEXCONTROL0_1);
    pGrChan->CurrentPatch.TexControl1_0       = REG_RD32(NV_PGRAPH_TEXCONTROL1_0);
    pGrChan->CurrentPatch.TexControl1_1       = REG_RD32(NV_PGRAPH_TEXCONTROL1_1);
    pGrChan->CurrentPatch.TexControl2_0       = REG_RD32(NV_PGRAPH_TEXCONTROL2_0);
    pGrChan->CurrentPatch.TexControl2_1       = REG_RD32(NV_PGRAPH_TEXCONTROL2_1);

    pGrChan->CurrentPatch.ImageRect0          = REG_RD32(NV_PGRAPH_IMAGERECT0);
    pGrChan->CurrentPatch.ImageRect1          = REG_RD32(NV_PGRAPH_IMAGERECT1);

    pGrChan->CurrentPatch.Filter0             = REG_RD32(NV_PGRAPH_FILTER0);
    pGrChan->CurrentPatch.Filter1             = REG_RD32(NV_PGRAPH_FILTER1);
    
    pGrChan->CurrentPatch.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pGrChan->CurrentPatch.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pGrChan->CurrentPatch.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pGrChan->CurrentPatch.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);
    pGrChan->CurrentPatch.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);

    pGrChan->CurrentPatch.DVDColorFormat      = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pGrChan->CurrentPatch.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pGrChan->CurrentPatch.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    pGrChan->CurrentPatch.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pGrChan->CurrentPatch.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pGrChan->CurrentPatch.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pGrChan->CurrentPatch.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pGrChan->CurrentPatch.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
    pGrChan->CurrentPatch.Valid2              = REG_RD32(NV_PGRAPH_VALID2);

    // save pipe context if a 3D object exists in the channel
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 grclass = INST_RD32(pGrHalPvtInfo->currentObjects3d[ChID],
                                 SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);

        if ((grclass == NV10_DX5_TEXTURED_TRIANGLE) || (grclass == NV10_DX6_MULTI_TEXTURE_TRIANGLE))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_FILE_BASE, pGrChan->CurrentPatch.CurrentPipe.VertexFile, VERTEX_FILE_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
        }
        else
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_VAB, XF_VAB_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,	pGrChan->CurrentPatch.CurrentPipe.PrimAssm, PRIM_ASSM_COUNT);
        }

        // unload transform engine state
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS, XF_CHEOPS_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER, XF_ZOSER_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C0_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0, XF_ZOSER_C0_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C1_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1, XF_ZOSER_C1_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C2_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2, XF_ZOSER_C2_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_C3_BASE, pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3, XF_ZOSER_C3_COUNT);

        // unload index DMA pipe state
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim, INDEX_DMA_PRIM_COUNT);

#ifdef CHECK_VTX_COUNT
{
        U032 InitCtxtPtr = pHalHwInfo->pPramHalInfo->FifoContextAddr + (ChID * 32);
        U032 vtxcount = pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim[0x3] & 0x1F00;

        if (vtxcount) {
            U032 method = REG_RD32((U032)(InitCtxtPtr + SF_OFFSET(NV_RAMFC_DMA_METHOD))) & 0x1FFF;
            if ((method < NV056_INLINE_ARRAY(0)) || (method >= NV056_INLINE_ARRAY(0x200)))
                _asm int 3;
        }
}
#endif
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat, INDEX_DMA_FORMAT_COUNT);

        // wait for the pipe to go idle again after unloading the pipeline context
        HAL_GR_IDLE(pHalHwInfo);
    }

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV10 - 1));

    return (RM_OK);
}

RM_STATUS
nvHalGrGetState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 ChID;
    U032 access, instance;
    U032 i, format, temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    nvAddr = pHalHwInfo->nvBaseAddr;
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
	REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma)
    {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    }
    else
    {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[ChID];
    }

    // copy out the data
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == ChID)
    {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL0);
        ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL1);
        ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL2);
        ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        grUnloadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);
        grUnloadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        ((U032 *)stateptr)[0] = pGrChannel->CurrentPatch.Control0;
        ((U032 *)stateptr)[1] = pGrChannel->CurrentPatch.Control1;
        ((U032 *)stateptr)[2] = pGrChannel->CurrentPatch.Control2;
        ((U032 *)stateptr)[3] = pGrChannel->CurrentPatch.Blend;
            
        // read the
        //      PerVertexState from the VAB,
        //      PrimitiveAssembly from PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag from PRIM_BASE
        //      VertexArrayState from PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)(&stateptr->PrimitiveAssmState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)(&stateptr->PerVertexState.pad3))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)(&stateptr->VertexArrayState))+i) = *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i);
    }

    // correct FORMAT_SIZE bits 7:4 for the HW context read bug (driver shadowed in INV2_MATRIX_OFFSET)
    grUnloadPipeContext(pHalHwInfo, INV2_MATRIX_OFFSET, &format, 0x1);

    for (i = 1; i < INDEX_DMA_FORMAT_COUNT; i += 2, format >>= 4)
    {
        temp = ((U032 *) &stateptr->VertexArrayState)[i];
        temp = (temp & 0xFFFFFF0F) | ((format & 0xF) << 4);
        ((U032 *) &stateptr->VertexArrayState)[i] = temp;
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    U032 access, instance;
    U032 i;
    NvGraphicsState *stateptr;
    RM_STATUS   status;
    PDMAHALOBJINFO pDmaHalInfo;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrPutState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    nvAddr = pHalHwInfo->nvBaseAddr;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    if (useCtxDma) {
        // determine where the ContextDmaState buffer resides (kept in GLOBALSTATE1)
        if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
            instance = REG_RD_DRF(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3);
        else
            instance = DRF_VAL(_PGRAPH, _GLOBALSTATE1, _DMA_INSTANCE_3, pGrChannel[pGrExceptionData->ChID].CurrentPatch.GlobalState1);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERROR;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV10(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // ensure DmaState buffer is large enough for the GetState data
        if (pDmaHalInfo->BufferSize < sizeof(NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    } else {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];
    }

    // copy data to the HW
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == pGrExceptionData->ChID)
    {
        U032 xfmode0, xfmode1;
        U032 scale[SCALEOFFSET_COUNT];
        U032 fog[FOG_COUNT];
        U032 fog_eyedist[FOG_EYEDIST_COUNT];

        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        REG_WR32(NV_PGRAPH_CONTROL0, ((U032 *)stateptr)[0]);
        REG_WR32(NV_PGRAPH_CONTROL1, ((U032 *)stateptr)[1]);
        REG_WR32(NV_PGRAPH_CONTROL2, ((U032 *)stateptr)[2]);
        REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

        // Because we'll need to change bits of the pipe state to put the engines
        // in passthrough mode, we'll need to keep the current values, so we can
        // restore them after we've reloaded PRIM_ASSM.

        // save current xfmode values (modified for passthrough)
        xfmode0 = REG_RD32(NV_PGRAPH_XFMODE0);
        xfmode1 = REG_RD32(NV_PGRAPH_XFMODE1);

        // save current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grUnloadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);

        // save current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grUnloadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // Now, change the pipe state so that the engines are in passthrough mode.

        // set vertex passthrough mode (pass data unchanged down the pipe)
        REG_WR32(NV_PGRAPH_XFMODE0,         Vertex_Passthr_Mode[0]);
        REG_WR32(NV_PGRAPH_XFMODE1,         Vertex_Passthr_Mode[1]);

        // set scale and offset constants in ModelViewMatrix1 for passthrough
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), ScaleOffset_Passthr_Mode, SCALEOFFSET_COUNT);

        // set fog constants for passthrough (different between A01 and A02)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[1], FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), Fog_EyeDist_Passthr_Mode, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), Fog_Passthr_Mode[0], FOG_COUNT);

        // set PrimType=QUAD (0x8), which puts the following vertices into primitive assembly
        i = 0x8;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE, &i, 0x1);

        // restore the PrimitiveAssembly
        grLoadPipeContext(pHalHwInfo, PIPE_ASSM_BASE,   (U032 *)(&stateptr->PrimitiveAssmState), PRIM_ASSM_COUNT);

        // After primitive assembly is restored, reload the original values we
        // modified to put the engines in passthrough mode.

        // restore current xfmode (modified for passthrough)
        REG_WR32(NV_PGRAPH_XFMODE0, xfmode0);
        REG_WR32(NV_PGRAPH_XFMODE1, xfmode1);

        // restore current scale/offset constants in ModelViewMatrix1 (modified for passthrough)
        grLoadPipeContext(pHalHwInfo, PIPE_CHEOPS_BASE + (3*64), scale, SCALEOFFSET_COUNT);
        
        // restore current fog constants (modified for passthrough)
        if (IsNV10MaskRevA02orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x28 << 4), fog_eyedist, FOG_EYEDIST_COUNT);
        } else
            grLoadPipeContext(pHalHwInfo, PIPE_ZOSER_BASE | (0x2b << 4), fog, FOG_COUNT);

        // restore the
        //      PerVertexState to the VAB,
        //      VertexArrayState to PIPE_FORMAT
        //      PerVertextState.EdgeFlag to PRIM_BASE
        grLoadPipeContext(pHalHwInfo, PIPE_VAB_BASE,    (U032 *)(&stateptr->PerVertexState), XF_VAB_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_FORMAT_BASE, (U032 *)(&stateptr->VertexArrayState), INDEX_DMA_FORMAT_COUNT);
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE,   (U032 *)(&stateptr->PerVertexState.pad3), INDEX_DMA_PRIM_COUNT);

		// force an invalidate of the vertex cache 
        i = 0x0;
        grLoadPipeContext(pHalHwInfo, PIPE_PRIM_BASE+0x80, &i, 0x1);
    } else {
        // first 4 DWORDS of NvGraphicsState is the PerFragment state
        pGrChannel->CurrentPatch.Control0 = ((U032 *)stateptr)[0];
        pGrChannel->CurrentPatch.Control1 = ((U032 *)stateptr)[1];
        pGrChannel->CurrentPatch.Control2 = ((U032 *)stateptr)[2];
        pGrChannel->CurrentPatch.Blend    = ((U032 *)stateptr)[3];

        // restore the
        //      PerVertexState to the VAB,
        //      PrimitiveAssembly to PIPE_ASSM_BASE
        //      PerVertextState.EdgeFlag to PRIM_BASE
        //      VertexArrayState to PIPE_FORMAT
        for (i = 0; i < (XF_VAB_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.XF_VAB)+i) = *(((char *)(&stateptr->PerVertexState))+i);

        for (i = 0; i < (PRIM_ASSM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.PrimAssm)+i) = *(((char *)(&stateptr->PrimitiveAssmState))+i);

        for (i = 0; i < (INDEX_DMA_PRIM_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaPrim)+i) = *(((char *)(&stateptr->PerVertexState.pad3))+i);

        for (i = 0; i < (INDEX_DMA_FORMAT_COUNT << 2); i++)
            *(((char *)pGrChannel->CurrentPatch.CurrentPipe.IndexDmaFormat)+i) = *(((char *)(&stateptr->VertexArrayState))+i);
    }

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

#define ZOSER_MATERIAL_COLOR_BASE   0x6aa0

//
// Workaround a HW problem where a Celsius SetMaterialEmission will be ignored in
// between a Begin/End. This is a SW method OGL calls to have us plugin the value.
// 
RM_STATUS nvHalGrSetMaterialEmission_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    PHWREG nvAddr;
    U032    pipeAddr = ZOSER_MATERIAL_COLOR_BASE + (pGrExceptionData->Offset - NV056_SET_MATERIAL_EMISSION_SW(0));

    nvAddr = pHalHwInfo->nvBaseAddr;
    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

//
// This method gives D3D access to the eye direction state.
//

#define ZOSER_EYE_DIR_BASE      0x6a80

RM_STATUS nvHalGrSetEyeDirection_NV10(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    PHWREG nvAddr;
    U032    pipeAddr = ZOSER_EYE_DIR_BASE + (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0));

    nvAddr = pHalHwInfo->nvBaseAddr;
    grLoadPipeContext(pHalHwInfo, pipeAddr, &pGrExceptionData->Data, 0x1);
    GR_DONE();

    return (RM_OK);
}

static RM_STATUS grDelay_NV10(
    PHALHWINFO pHalHwInfo,
    U032 nsec
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    
    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
        U032 TimeStart = REG_RD32(NV_PTIMER_TIME_0);
        while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
		    ;
        return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);

    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
        ;
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
                 ;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grmdnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCHIP.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV10(PHALHWINFO, PGREXCEPTIONDATA);

//
// Externs.
//
extern RM_STATUS nvHalGrGetState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrPutState_NV10(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrSetMaterialEmission_NV10(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrSetEyeDirection_NV10(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV10_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass056GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetMaterialEmission(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv10CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass056GetState,             0x010c, 0x010f},
    {_nvHalClass056SetMaterialEmission,  0x1628, 0x1633},
    {_nvHalClass056SetEyeDirection,      0x072c, 0x0737},
};

//
// NV15_CELSIUS / NV11_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass096GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass096SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv15CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass096GetState,             0x010c, 0x010f},
    {_nvHalClass096SetEyeDirection,      0x072c, 0x0737},
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV10[] =
{
    { NV10_CELSIUS_PRIMITIVE,           Nv10CelsiusPrimitiveHalMethods,
                                        sizeof (Nv10CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    { NV15_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    { NV11_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)}
};
#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV10) / sizeof (HALGRMETHODS)

RM_STATUS
nvHalGrClassSoftwareMethod_NV10(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 i, j;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV10[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV10[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV10[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV10[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV10[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}


static RM_STATUS
_nvHalClass056GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056GetState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV056_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass056SetMaterialEmission(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    // workaround for an NV10 bug (fixed in NV15)
    nvHalGrSetMaterialEmission_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass056SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass096GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056PutState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV096_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV10(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass096SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV10(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv10\grnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCHIP.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrControl_NV10(VOID *);
RM_STATUS nvHalGrAlloc_NV10(VOID *);
RM_STATUS nvHalGrFree_NV10(VOID *);
RM_STATUS nvHalGrGetExceptionData_NV10(VOID *);
RM_STATUS nvHalGrService_NV10(VOID *);
RM_STATUS nvHalGrGetNotifyData_NV10(VOID *);
RM_STATUS nvHalGrSetObjectContext_NV10(VOID *);
RM_STATUS nvHalGrLoadOverride_NV10(VOID *);

// statics
static RM_STATUS _nvHalGrInitObjectContext_NV10(PHALHWINFO, U032, U032);
static VOID _nvHalGrInitCelsius_NV10(PHALHWINFO, U032);
static VOID _nvHalGrInitDx5_NV10(PHALHWINFO, U032);

// externs
extern RM_STATUS nvHalGrClassSoftwareMethod_NV10(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrLoadChannelContext_NV10(PHALHWINFO, U032);
extern RM_STATUS nvHalGrUnloadChannelContext_NV10(PHALHWINFO, U032);

//
// nvHalGrControl
//
RM_STATUS
nvHalGrControl_NV10(VOID *arg)
{
    PGRCONTROLARG_000 pGrControlArg = (PGRCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrControlArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PHWREG nvAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrControl_NV10\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGrControlArg->id != GR_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrControlArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    
    switch (pGrControlArg->cmd)
    {
        case GR_CONTROL_INIT:
            //
            // Initialize graphics debug values.
            //
            switch (REG_RD_DRF(_PMC, _BOOT_0, _MAJOR_REVISION))
            {
                case NV_PMC_BOOT_0_MAJOR_REVISION_A:
                default:
                    pGrHalPvtInfo->Debug0 = 0x0;        // all DEBUG0 bits are RESET bits in NV10
                    pGrHalPvtInfo->Debug1 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_PTE,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_AUTO,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_Y,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _INSTANCE,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _CTX,              _INIT);
                    pGrHalPvtInfo->Debug2 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_CHECK,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_INT,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_INT,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_COALESCE_3D,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_COALESCE_2D,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TRIEND_FLUSH,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_3D,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILE3D2HIGH,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWALLOW_REQS,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_ALPHA_ABORT,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FIXED_ADRS,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_RANGE,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_2D, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_3D, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_TILEVIOL,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_3D,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_DITHER_2D,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_EARLY_ZABORT,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BLIT_MULTILINE,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BLIT_DST_LIMIT,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SDR_FAST_BLEND,    _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_2D_FAST_CONV,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_HPREQ,             _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_BITBUCKET,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FIXED_ADRS,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FAST_KEEP_DST,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FORCE_CREAD,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_FORCE_ZREAD,       _INIT);

                    pGrHalPvtInfo->Debug3 = (U032)
                        DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_STRTCH,      _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_SHADOW_DATA,   _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DMA_READ,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IDLE_FILTER,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _INHIBIT_IMCLASS_BLOCK, _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SYNCHRONIZE,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _D3D_STATE3D,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _OBJECT_RELOAD,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _PM_TRIGGER,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _ALTARCH,               _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_CYCLE_LOAD,     _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _BILINEAR_3D,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _VOLATILE_RESET,        _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK_FAIL,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FORMAT_CHECK,          _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DMA_CHECK,             _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _STATE_CHECK,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IMAGE_64BIT,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _CELSIUS_64BIT,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _STATE3D_CHECK,         _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _XFMODE_COALESCE,       _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _CTX_METHODS,           _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _OP_METHODS,            _INIT)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _IGNORE_PATCHVALID,     _INIT);

                    //
                    // Turn this bit on for nv15/nv11 to avoid problems when class07c
                    // writes NV_PGRAPH_INCREMENT_READ_3D when gfx isn't idle. The gfx
                    // engine can't be idled because it's stalled waiting for the
                    // increment trigger.
                    //
                    if (IsNV15_NV10(pHalHwInfo->pMcHalInfo) ||
                        IsNV11_NV10(pHalHwInfo->pMcHalInfo))
                        pGrHalPvtInfo->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _INHIBIT_IMCLASS_BLOCK, _ENABLED);

                    pGrHalPvtInfo->Debug4 = 0x0;       // all DEBUG4 bits are SPARES currently
                    break;
            }

            //
            // NV11 seems to be faster if we don't separate color/Z with SDR memory,
            // I still need to get confirmation from Jonah on this DEBUG bit though ...
            //
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo)) {
                pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _DISABLED);
            } else {
                // Separate color and Z reads on SDR memory configurations
                if (REG_RD_DRF(_PFB, _CFG, _TYPE) == NV_PFB_CFG_TYPE_SDR)
                    pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _ENABLED);
                else
                    pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_SEP_ZC_READS, _DISABLED);
            }

            // Also set some NV11 specific DEBUG bits (e.g. enable Z/C mix)
            if (IsNV11_NV10(pHalHwInfo->pMcHalInfo)) {
                pGrHalPvtInfo->Debug2 |= (DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_NV11_OPTS,   _INIT)
                                      |   DRF_DEF(_PGRAPH, _DEBUG_2, _ROP_ALLOW_ZCMIX, _INIT));
            }

            //
            // Set default channel to unused chid
            //
            pGrHalPvtInfo->currentChID = INVALID_CHID;
            break;
        case GR_CONTROL_LOAD:
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET, _LAST);
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY, _CANCEL);
            
            REG_WR32(NV_PGRAPH_DEBUG_0, pGrHalPvtInfo->Debug0);
            REG_WR32(NV_PGRAPH_DEBUG_1, pGrHalPvtInfo->Debug1);
            REG_WR32(NV_PGRAPH_DEBUG_2, pGrHalPvtInfo->Debug2);
            REG_WR32(NV_PGRAPH_DEBUG_3, pGrHalPvtInfo->Debug3);
            REG_WR32(NV_PGRAPH_DEBUG_4, pGrHalPvtInfo->Debug4);

            // FROM NV10_NvChipRestoreTiledRanges(pDev)

            // 
            // PGRAPH_TILE values will be reset after a PGRAPH_DEBUG_0_STATE_RESET.
            // Unfortunately, it may have had values we wanted (e.g. from stateFb),
            // so after a DEBUG_0_STATE_RESET, restore the PGRAPH values from PFB.
            //
            HAL_GR_IDLE(pHalHwInfo);

            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                REG_WR32(NV_PGRAPH_TLIMIT(i), REG_RD32(NV_PFB_TLIMIT(i)));
                REG_WR32(NV_PGRAPH_TSIZE(i), REG_RD32(NV_PFB_TSIZE(i)));
                REG_WR32(NV_PGRAPH_TILE(i), REG_RD32(NV_PFB_TILE(i)));
            }

            // FROM NV10_grStateLoadContext

            //
            // Load debug overrides.
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH2,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH3,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH4,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

            //
            // Reload current graphics context.
            //
            (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, pGrHalPvtInfo->currentChID);
            break;
        case GR_CONTROL_UNLOAD:
            //
            // Pull out current graphics state.
            //
            (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, INVALID_CHID);

            // FROM NV10_grStateUnLoadContext
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            break;
        case GR_CONTROL_DESTROY:
        case GR_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalGrAlloc
//
RM_STATUS
nvHalGrAlloc_NV10(VOID *arg)
{
    PGRALLOCARG_000 pGrAllocArg = (PGRALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrAllocArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrAlloc_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrAllocArg->id != GR_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrAllocArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrAllocArg->chid];
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // If we've got a 3d object, keep note of it.
    //
    if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV10_DX5_TEXTURED_TRIANGLE) ||
        (pGrAllocArg->classNum == NV10_DX6_MULTI_TEXTURE_TRIANGLE) ||
        (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE))
    {
        U032 currClass = 0;

        if (pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] != 0)
            currClass = DRF_VAL(_PGRAPH, _CTX_SWITCH1, _GRCLASS, INST_RD32(pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid], SF_OFFSET(NV_PRAMIN_CONTEXT_0)));

        //
        // For DX5/DX6, we're not able to handle a Celsius object in the same channel,
        // since their init graphics routines are different. Check that a Celsius 3D
        // object hasn't already been created (multiple DX5/DX6 are OK).
        //
        if ((pGrAllocArg->classNum == NV10_DX6_MULTI_TEXTURE_TRIANGLE ||
             pGrAllocArg->classNum == NV10_DX5_TEXTURED_TRIANGLE) &&
            (currClass == NV10_CELSIUS_PRIMITIVE ||
             currClass == NV15_CELSIUS_PRIMITIVE ||
             currClass == NV11_CELSIUS_PRIMITIVE))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: 3d state in use by celsius instance ", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]);
            return (RM_ERR_ILLEGAL_OBJECT);
        }

        //
        // For Celsius, we're not able to handle either DX5/DX6 or another Celsius
        // object in the same channel, since their init graphics routines (in gr\nv10 dir)
        // are different. Check that a current 3D object hasn't already been created.
        //
        if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE ||
             pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE ||
             pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE) &&
            (currClass == NV10_DX6_MULTI_TEXTURE_TRIANGLE ||
             currClass == NV10_DX5_TEXTURED_TRIANGLE))
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: 3d state in use by DX instance ", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]);
            return (RM_ERR_ILLEGAL_OBJECT);
        }

        pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] = pGrAllocArg->instance;

        if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
            (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE))
            _nvHalGrInitCelsius_NV10(pHalHwInfo, pGrAllocArg->chid);
        else
            _nvHalGrInitDx5_NV10(pHalHwInfo, pGrAllocArg->chid);
    }

    //
    // Initialize context.
    //
    _nvHalGrInitObjectContext_NV10(pHalHwInfo, pGrAllocArg->instance, pGrAllocArg->classNum);

    return (RM_OK);
}

//
// nvHalGrFree
//
RM_STATUS
nvHalGrFree_NV10(VOID *arg)
{
    PGRFREEARG_000 pGrFreeArg = (PGRFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChannel;
    PHWREG nvAddr;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrFreeArg->id != GR_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrFreeArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrFreeArg->chid];
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Clear 3d current object pointer if necessary.
    //
    if (pGrFreeArg->instance == pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid])
    {
        // we could ASSERT that this is a 3d object here as well
        pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid] = 0;

        // clear the Celsius bit (either never had one or it was just freed)
        pGrHalInfo->has3dObject &= ~(0x1 << pGrFreeArg->chid);
    }

    //
    // Zero out the object context for good measure.
    //
    for (i = 0; i < 4; i++)
    {
        INST_WR32(pGrFreeArg->instance, i, 0);
    }

    return (RM_OK);
}

//
// nvHalGrGetExceptionData
//
// Retrieve graphics engine exception data.
//
RM_STATUS
nvHalGrGetExceptionData_NV10(VOID *arg)
{
    PGRGETEXCEPTIONDATAARG_000 pGrGetExceptionDataArg = (PGRGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGREXCEPTIONDATA pGrExceptionData;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrGetExceptionDataArg->id != GR_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    pGrExceptionData = pGrGetExceptionDataArg->pExceptionData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Fill in exception data.
    //
    pGrExceptionData->Offset = REG_RD32(NV_PGRAPH_TRAPPED_ADDR);
    pGrExceptionData->ChID = DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _CHID, pGrExceptionData->Offset);
    pGrExceptionData->NotifyInstance = REG_RD_DRF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE);
    pGrExceptionData->classNum = REG_RD_DRF(_PGRAPH, _CTX_SWITCH1, _GRCLASS);
    pGrExceptionData->Data = REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW); 
    pGrExceptionData->Instance = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrExceptionData->Offset &= (DRF_MASK(NV_PGRAPH_TRAPPED_ADDR_MTHD) << DRF_SHIFT(NV_PGRAPH_TRAPPED_ADDR_MTHD));
    pGrExceptionData->Nsource = REG_RD32(NV_PGRAPH_NSOURCE);
    pGrExceptionData->MethodStatus = RM_OK;

    return (RM_OK);
}

//
// nvHalGrService
//
// Handle selected graphics object exceptions.
//
RM_STATUS
nvHalGrService_NV10(VOID *arg)
{
    PGRSERVICEARG_000 pGrServiceArg = (PGRSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PGREXCEPTIONDATA pGrExceptionData;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrServiceArg->id != GR_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrServiceArg->pHalHwInfo;
    pGrExceptionData = pGrServiceArg->pExceptionData;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure object is valid.
    //
    //if (pGrExceptionData->instance == 0)
    //    return (NV_HAL_ERROR_INVALID_STATE);

    //
    // Handle any exceptions...
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _PENDING))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "SingleStep method: ", REG_RD32(NV_PGRAPH_TRAPPED_ADDR));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "SingleStep data  : ", REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW));

        // turn on the single step bit for this channel
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _SINGLE_STEP, _RESET);
        DBG_BREAKPOINT();
    }

    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING))
    {
        //
        // Reset condition.
        //
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _RESET);

        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Graphics channel switch.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics context switch exception.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Previous graphics channel:",pGrHalPvtInfo->currentChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: New graphics channel:", pGrExceptionData->ChID);

        (void) nvHalGrLoadChannelContext_NV10(pHalHwInfo, pGrExceptionData->ChID);
    }

    //
    // Handle methods in software.
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING))
    {
        if (nvHalGrClassSoftwareMethod_NV10(pHalHwInfo, pGrExceptionData) == RM_OK)
        {
            // Reset condition.
            REG_WR_DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _RESET);
        }
    }

    if ((pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING)))
    {
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {
            if (nvHalGrClassSoftwareMethod_NV10(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING))
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
                else
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _ERROR, _RESET);
            }
        }
    }

    return (RM_OK);
}

//
// nvHalGrNotifyData
//
// Fill in notify data (trigger status and action).
//
RM_STATUS
nvHalGrGetNotifyData_NV10(VOID *arg)
{
    PGRGETNOTIFYDATAARG_000 pGrGetNotifyDataArg = (PGRGETNOTIFYDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    PGRNOTIFYDATA pGrNotifyData;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetNotifyData_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrGetNotifyDataArg->id != GR_GET_NOTIFY_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    pGrNotifyData = pGrGetNotifyDataArg->pGrNotifyData;
    nvAddr = pHalHwInfo->nvBaseAddr;

    if (REG_RD32(NV_PGRAPH_NOTIFY) &
        (DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _PENDING) |
         DRF_DEF(_PGRAPH, _NOTIFY, _STYLE, _WRITE_THEN_AWAKEN)))
    {
        pGrNotifyData->trigger = TRUE;
        pGrNotifyData->action =  REG_RD_DRF(_PGRAPH, _NOTIFY, _STYLE);
        // clear the notify condition
        FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);
    } else {
        pGrNotifyData->trigger = FALSE;
        pGrNotifyData->action = 0;
    }

    return (RM_OK);
}

//
// nvHalGrSetObjectContext
//
// Update various graphics object context bits.
// On NV10, these bits are managed by hardware so this
// routine does some error checking and returns.
//
RM_STATUS
nvHalGrSetObjectContext_NV10(VOID *arg)
{
    PGRSETOBJECTCONTEXTARG_000 pGrSetObjectContextArg = (PGRSETOBJECTCONTEXTARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    PHWREG nvAddr;
    U032 context, instance;
    U032 fifo;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrSetObjectContext_NV10\r\n");

    //
    // Verify interface revision.
    //
    if (pGrSetObjectContextArg->id != GR_SET_OBJECT_CONTEXT_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify chid.
    //
    if (pGrSetObjectContextArg->chid > NUM_FIFOS_NV10)
        return (RM_ERR_BAD_ARGUMENT);

    //
    // Verify instance (what else can we do here without
    // keeping track of all objects that pass through the
    // nvHalGrAlloc interface down in the HAL?).
    //
    if (pGrSetObjectContextArg->instance == 0)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    instance = pGrSetObjectContextArg->instance;
    
    //
    // Fetch current context.
    //
    context = INST_RD32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0));

    //
    // Make necessary adjustments.
    //
    context &= pGrSetObjectContextArg->andMask;
    context |= pGrSetObjectContextArg->orMask;

    //
    // Write it back out                   
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), context);
        
    //
    // Now we need to update the hardware context if appropriate.
    //
    if (pGrSetObjectContextArg->chid == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
            
        //
        // Walk to subchannels and see if we find a match; update when we do
        //
        for (i = 0 ; i < 8 ; i++)
        {            
            if (REG_RD32(NV_PGRAPH_CTX_CACHE4(i)) == instance)
            {   
                //
                // Get the current settings
                //
                context = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));

                //
                // Make necessary adjustments.
                //
                context &= pGrSetObjectContextArg->andMask;
                context |= pGrSetObjectContextArg->orMask;

                //
                // Write it back out                   
                //
                REG_WR32(NV_PGRAPH_CTX_CACHE1(i), context);
            }
        }                                    
                             
        //
        // See if the currently active subchannel also needs updating
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_SWITCH4, _USER_INSTANCE) == instance)
        {   
            //
            // Get the current settings
            //
            context = REG_RD32(NV_PGRAPH_CTX_SWITCH1);

            //
            // Make necessary adjustments.
            //
            context &= pGrSetObjectContextArg->andMask;
            context |= pGrSetObjectContextArg->orMask;

            //
            // Write it back out                   
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1, context);
        }
            
        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
        
    }    
    return (RM_OK);
}

RM_STATUS
nvHalGrLoadOverride_NV10(VOID *arg)
{
    PGRLOADOVERRIDEARG_000 pGrLoadOverrideArg = (PGRLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV10 pGrHalPvtInfo;
    PHWREG nvAddr;

    //
    // Verify interface revision.
    //
    if (pGrLoadOverrideArg->id != GR_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrLoadOverrideArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
    pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;

    switch (pGrLoadOverrideArg->cmd)
    {
        case GR_LOAD_OVERRIDE_DEBUG0:
            pGrHalPvtInfo->Debug0 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG1:
            pGrHalPvtInfo->Debug1 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG2:
            pGrHalPvtInfo->Debug2 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG3:
            pGrHalPvtInfo->Debug3 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_SWATHCTL:
            pGrHalPvtInfo->SwathControl = pGrLoadOverrideArg->value;
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}



static RM_STATUS
_nvHalGrInitObjectContext_NV10(
    PHALHWINFO  pHalHwInfo,
    U032        instance,
    U032        classNum
)
{
    U032 ctx1, ctx2, ctx3;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    // default _CTX_SWITCH1 value
    ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, classNum)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

    // turn on big endian for this class if supported and we're in big endian mode
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _BIG);

    // default _CTX_SWITCH2 value
    ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

    // default _CTX_SWITCH3 value
    ctx3 = DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_0, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_1, _INVALID);

    switch (classNum)
    {
        case NV01_CONTEXT_BETA:
        case NV01_CONTEXT_CLIP_RECTANGLE:
        case NV01_IMAGE_BLIT:
        case NV03_CONTEXT_ROP:
        case NV04_CONTEXT_SURFACES_2D:
        case NV03_DX3_TEXTURED_TRIANGLE:
        case NV04_CONTEXT_SURFACE_SWIZZLED:
        case NV04_CONTEXT_SURFACES_3D:
        case NV03_CONTEXT_SURFACE_2D_DESTINATION:
        case NV03_CONTEXT_SURFACE_2D_SOURCE:
        case NV03_CONTEXT_SURFACE_3D_COLOR:
        case NV03_CONTEXT_SURFACE_3D_DEPTH:
        case NV04_IMAGE_BLIT:
        case NV04_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
        case NV15_IMAGE_BLIT:
            // defaults are fine
            break;
        case NV01_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_CONTEXT_PATTERN:
        case NV04_CONTEXT_PATTERN:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_RENDER_SOLID_LIN:
        case NV01_RENDER_SOLID_TRIANGLE:
        case NV01_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_IMAGE_FROM_CPU:
        case NV03_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV1_NULL:
            //
            // The NULL object is really a pseudo-dma object, so it needs a valid
            // limit value and should also have the PAGE_TABLE_PRESENT bit set.
            //
            ctx1 |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
            ctx2 = 0xffffffff;
            //INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0xFFFFFFFF);
            //FLD_WR_ISF_DEF(instance, _DMA, _PAGE_TABLE, _PRESENT);
            break;
        case NV03_SCALED_IMAGE_FROM_MEMORY:
        case NV04_SCALED_IMAGE_FROM_MEMORY:
        case NV10_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_SCALED_IMAGE_FROM_MEMORY:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DVD_SUBPICTURE:
        case NV10_DVD_SUBPICTURE:
            //
            // DVD class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV03_MEMORY_TO_MEMORY_FORMAT:
            // Note that this object is always considered patch valid
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV03_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DX5_TEXTURED_TRIANGLE:
        case NV10_DX5_TEXTURED_TRIANGLE:
            //
            // DX5 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_DX6_MULTI_TEXTURE_TRIANGLE:
        case NV10_DX6_MULTI_TEXTURE_TRIANGLE:
            //
            // DX6 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_RENDER_SOLID_LIN:
        case NV04_RENDER_SOLID_TRIANGLE:
        case NV04_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_INDEXED_IMAGE_FROM_CPU:
        case NV04_IMAGE_FROM_CPU:
        case NV04_STRETCHED_IMAGE_FROM_CPU:
        case NV10_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_INDEXED_IMAGE_FROM_CPU:
        case NV05_IMAGE_FROM_CPU:
        case NV05_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_CELSIUS_PRIMITIVE:
            //
            // The above DRF_NUM macro on GRCLASS has already masked this class
            // number to an 8bit value, we just need to set the PERFORMANCE bit.
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
        case NV10_CELSIUS_PRIMITIVE:
        case NV15_CELSIUS_PRIMITIVE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV10_TEXTURE_FROM_CPU:
            // TEXTURE_FROM_CPU is similar to the IMAGE_FROM_CPU classes, but with
            // only a subset of the methods, so we'll need to make sure things are
            // initialized in a way that makes sense for this class.
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, _TRUNCATE);    
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        default:
            // assume defaults are cool
            break;
    }

    //
    // Write out the values.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance data for classNum ", classNum);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      instance offset ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx1 ", ctx1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx2 ", ctx2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx3 ", ctx3);

    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), ctx1);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), ctx2);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), ctx3);
    //
    // Be sure to clear this dword clear to keep the graphics method
    // trapped disabled.
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_3), 0);

    return (RM_OK);
}

//
// Given a pipe address and ChID return the corresponding pipe context save area in grTable.
// This way, pipe state can be preloaded in the grTable and put in the HW during the first
// grctxt switch.
//
static U032 *
grInitPipeContextAddr(
    PGRAPHICSCHANNEL_NV10 pGrChan,
    U032 base
)
{
    U032 index;

    if (base >= PIPE_FORMAT_BASE && base < (PIPE_FORMAT_BASE + (INDEX_DMA_FORMAT_COUNT*4)))
    {
        index = (base - PIPE_FORMAT_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.IndexDmaFormat[index];
    }
    if (base >= PIPE_PRIM_BASE && base < (PIPE_PRIM_BASE + (INDEX_DMA_PRIM_COUNT*4)))
    {
        index = (base - PIPE_PRIM_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.IndexDmaPrim[index];
    }
    if (base >= PIPE_ASSM_BASE && base < (PIPE_ASSM_BASE + (PRIM_ASSM_COUNT*4)))
    {
        index = (base - PIPE_ASSM_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.PrimAssm[index];
    }
    if (base >= PIPE_FILE_BASE && base < (PIPE_FILE_BASE + (VERTEX_FILE_COUNT*4)))
    {
        index = (base - PIPE_FILE_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.VertexFile[index];
    }
    if (base >= PIPE_VAB_BASE && base < (PIPE_VAB_BASE + (XF_VAB_COUNT*4)))
    {
        index = (base - PIPE_VAB_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_VAB[index];
    }
    if (base >= PIPE_CHEOPS_BASE && base < (PIPE_CHEOPS_BASE + (XF_CHEOPS_COUNT*4)))
    {
        index = (base - PIPE_CHEOPS_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_CHEOPS[index];
    }
    if (base >= PIPE_ZOSER_BASE && base < (PIPE_ZOSER_BASE + (XF_ZOSER_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER[index];
    }
    if (base >= PIPE_ZOSER_C0_BASE && base < (PIPE_ZOSER_C0_BASE + (XF_ZOSER_C0_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C0_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C0[index];
    }
    if (base >= PIPE_ZOSER_C1_BASE && base < (PIPE_ZOSER_C1_BASE + (XF_ZOSER_C1_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C1_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C1[index];
    }
    if (base >= PIPE_ZOSER_C2_BASE && base < (PIPE_ZOSER_C2_BASE + (XF_ZOSER_C2_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C2_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C2[index];
    }
    if (base >= PIPE_ZOSER_C3_BASE && base < (PIPE_ZOSER_C3_BASE + (XF_ZOSER_C3_COUNT*4)))
    {
        index = (base - PIPE_ZOSER_C3_BASE) / sizeof(U032);
        return &pGrChan->CurrentPatch.CurrentPipe.XF_ZOSER_C3[index];
    }

    return NULL;        // error
}

#define grInitPipeContextData(data)     *pipectx++ = data;

static VOID
_nvHalGrInitDx5_NV10(
    PHALHWINFO      pHalHwInfo,
    U032            ChID
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan;
    U032      i, *pipectx;
    U008      *ptr;

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];
    
    //
    // Load the channel with the desired initial state.
    //
    for (i = 0, ptr = (U008 *)pGrChan; i < sizeof (GRAPHICSCHANNEL_NV10); i++)
        *ptr++ = 0x0;

    // Load the non-zero initial values for DX5 classes
    // Initialize the register state
    pGrChan->CurrentPatch.TexFormat0           = 0x1000;
    pGrChan->CurrentPatch.TexFormat1           = 0x1000;
    pGrChan->CurrentPatch.TexControl0_0        = 0x4003ff80;
    pGrChan->CurrentPatch.ImageRect0           = 0x80008;
    pGrChan->CurrentPatch.ImageRect1           = 0x80008;
    pGrChan->CurrentPatch.Combine1ColorOCW     = 0x10000000;
    pGrChan->CurrentPatch.ZClipMax             = 0x4b7fffff;
    pGrChan->CurrentPatch.WinClipVert[0]       = 0x7ff0800;
    pGrChan->CurrentPatch.WinClipHorz[0]       = 0x7ff0800;

    // Initialize the internal XF constants
    pipectx = grInitPipeContextAddr(pGrChan, 0x6740);   // CHEOP_CTX, eye pos
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6750);   // CHEOP_CTX_CONST0
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6760);   // CHEOP_CTX_CONST1
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6770);   // CHEOP_CTX_CONST2
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6780);   // CHEOP_CTX, fog plane
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x67a0);   // CHEOP_CTX_CONST3
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ab0);   // FOG k0, k1, k2
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ac0);   // CHEOP_CTX_ZERO
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6c10);   // ZOSER_C0
    grInitPipeContextData(0xbf800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x7030);   // LIGHT0 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7040);   // LIGHT1 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7050);   // LIGHT2 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7060);   // LIGHT3 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7070);   // LIGHT4 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7080);   // LIGHT5 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x7090);   // LIGHT6 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x70a0);   // LIGHT7 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30

    pipectx = grInitPipeContextAddr(pGrChan, 0x6a80);   // ZOSER_EYE_DIR
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6aa0);   // ZOSER_FRONT_AMBIENT2
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x0040);   // begin-end
    grInitPipeContextData(0x00000005);                  // triangles

    pipectx = grInitPipeContextAddr(pGrChan, 0x6400);   // model/view matrix
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x4b7fffff);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6410);   // model/view matrix
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6420);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6430);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64c0);   // model/view matrix
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x4b7fffff);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64d0);   // model/view matrix
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0xc5000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64e0);   // model/view matrix
    grInitPipeContextData(0xc4fff000);
    grInitPipeContextData(0xc4fff000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x64f0);   // model/view matrix
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

}

static VOID
_nvHalGrInitCelsius_NV10(
    PHALHWINFO  pHalHwInfo,
    U032        ChID
)
{
    PGRHALINFO_NV10 pGrHalPvtInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV10 pGrChan;
    U032      i, *pipectx;
    U008      *ptr;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];
    pHalHwInfo->pGrHalInfo->has3dObject |= (0x1 << ChID);

    //
    // Load the channel with the desired initial state.
    //
    for (i = 0, ptr = (U008 *)pGrChan; i < sizeof (GRAPHICSCHANNEL_NV10); i++)
        *ptr++ = 0x0;

    // Load the non-zero initial values for Celsius classes
    // Initialize the register state
    pGrChan->CurrentPatch.TexFormat0           = 0x1000;
    pGrChan->CurrentPatch.TexFormat1           = 0x1000;
    pGrChan->CurrentPatch.ImageRect0           = 0x80008;
    pGrChan->CurrentPatch.ImageRect1           = 0x80008;
    pGrChan->CurrentPatch.ZClipMax             = 0x4b7fffff;
    pGrChan->CurrentPatch.SetupRaster          = DRF_DEF(_PGRAPH, _SETUPRASTER, _SWATHWIDTH, _32);

    // Check for an override for the swath width and width multiplier
    if (pGrHalPvtInfo->SwathControl & SWATH_CONTROL_VALID_BIT) {
        U032 data32 = pGrHalPvtInfo->SwathControl;

        // setup the swath width from the registry key
        pGrChan->CurrentPatch.SetupRaster      = DRF_NUM(_PGRAPH, _SETUPRASTER, _SWATHWIDTH, (data32 & 0xF));

        // setup the multiplier from the registry key
        pGrHalPvtInfo->Debug4 &= ~(DRF_MASK(NV_PGRAPH_DEBUG_4_SWATHCONTROL) << DRF_SHIFT(NV_PGRAPH_DEBUG_4_SWATHCONTROL));
        pGrHalPvtInfo->Debug4 |= DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, (data32 >> 4));

        FLD_WR_DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, (data32 >> 4));
    } else {
        // reset the width multiplier back to the default
        pGrHalPvtInfo->Debug4 &= ~(DRF_MASK(NV_PGRAPH_DEBUG_4_SWATHCONTROL) << DRF_SHIFT(NV_PGRAPH_DEBUG_4_SWATHCONTROL));
        pGrHalPvtInfo->Debug4 |= DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, 0x0);

        if (IsNV15orBetter_NV10(pHalHwInfo->pMcHalInfo))
        {
            FLD_WR_DRF_NUM(_PGRAPH, _DEBUG_4, _SWATHCONTROL, 0x0);
        }
    }

    // Initialize internal XF constants, also has side effect of initializing
    // upper half of passthrough slot for bundles.

    pipectx = grInitPipeContextAddr(pGrChan, 0x6740);   // CHEOP_CTX, eye pos
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6750);   // CHEOP_CTX_CONST0
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);
    grInitPipeContextData(0x40000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6760);   // CHEOP_CTX_CONST1
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6770);   // CHEOP_CTX_CONST2
    grInitPipeContextData(0x3f000000);
    grInitPipeContextData(0x3f000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6780);   // CHEOP_CTX (fog plane)
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x67a0);   // CHEOP_CTX_CONST3
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);
    grInitPipeContextData(0x3f800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6ac0);   // CHEOP_CTX_ZERO
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x6c10);   // ZOSER C0
    grInitPipeContextData(0xbf800000);

    pipectx = grInitPipeContextAddr(pGrChan, 0x7030);   // LIGHT0 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7040);   // LIGHT1 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7050);   // LIGHT2 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7060);   // LIGHT3 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7070);   // LIGHT4 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7080);   // LIGHT5 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x7090);   // LIGHT6 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x70a0);   // LIGHT7 range
    grInitPipeContextData(0x7149f2ca);                  // 1.0e30
          
    pipectx = grInitPipeContextAddr(pGrChan, 0x6a80);   // ZOSER_EYE_DIR
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x3f800000);
         
    pipectx = grInitPipeContextAddr(pGrChan, 0x6aa0);   // ZOSER_FRONT_AMBIENT2 (MCOL)
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
    grInitPipeContextData(0x00000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grcxnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grcxnv20.c                                                        *
*   The nv20 graphics engine context switching is managed in this module.   *
*   On nv20, context switching is handled in hardware, so all we really     *
*   have to do here is handle methods in the 3d classes that require        *
*   accessing internal pipe state.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
static VOID grUnloadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);
static VOID grLoadRdiContext(PHALHWINFO, U032, U032, U032, U032 *);
RM_STATUS nvHalGrGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
RM_STATUS nvHalGrPutState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);

RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO, U032);

// externs
extern RM_STATUS dmaHalInstanceToHalInfo_NV20(U032, U032, PDMAHALOBJINFO *, PHALHWINFO);

//
// Load Pipe Context
//
#if 0  // static, but never called
static RM_STATUS
grLoadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  REG_WR32(NV_PGRAPH_PIPE_DATA, SaveAddr[i]);
    }
    return (RM_OK);
}

//
// Unload Pipe Context
//
static RM_STATUS
grUnloadPipeContext(
    PHALHWINFO pHalHwInfo,
    U032       Base,
    U032      *SaveAddr,
    U032       Count
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, Base);
    for (i = 0; i < Count; i++) {
	  SaveAddr[i] = REG_RD32(NV_PGRAPH_PIPE_DATA);
    }
    return (RM_OK);
}
#endif

//
// Unload Rdi Context
//
static VOID
grUnloadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        saveAddr[i] = REG_RD32(NV_PGRAPH_RDI_DATA);
}

//
// Load RDI Context
//
static VOID
grLoadRdiContext(
    PHALHWINFO pHalHwInfo,
    U032       ramSel,
    U032       offset,
    U032       count,
    U032      *saveAddr
)
{
    U032 i;

    REG_WR32(NV_PGRAPH_RDI_INDEX, (ramSel<<16 | offset));
    for (i = 0; i < count; i++)
        REG_WR32(NV_PGRAPH_RDI_DATA, saveAddr[i]);
}

RM_STATUS
nvHalGrGetState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 ChID;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    ChID = pGrExceptionData->ChID;

#ifdef DEBUG
    // we're from a GR exception, so we should be idled/disable already
    if (REG_RD_DRF(_PGRAPH, _FIFO, _ACCESS) || REG_RD32(NV_PGRAPH_STATUS))
        DBG_BREAKPOINT();
#endif

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: GetState method issued on non-current channel ", ChID);
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    if (useCtxDma)
    {
        // determine where the ContextDmaState buffer resides
        instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);

        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV20(ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState invalid instance\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    }
    else
    {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[ChID];
    }

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    ((U032 *)stateptr)[0] = REG_RD32(NV_PGRAPH_CONTROL_0);
    ((U032 *)stateptr)[1] = REG_RD32(NV_PGRAPH_CONTROL_1);
    ((U032 *)stateptr)[2] = REG_RD32(NV_PGRAPH_CONTROL_2);
    ((U032 *)stateptr)[3] = REG_RD32(NV_PGRAPH_BLEND);

    //
    // Fetch PerVertexState from the VAB.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    stateptr->PerVertexState.edgeFlag = (temp >> 28) & 1;

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

RM_STATUS
nvHalGrPutState_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData, U032 useCtxDma)
{
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 access, instance;
    U032 temp;
    NvGraphicsState *stateptr;
    RM_STATUS status;
    PDMAHALOBJINFO pDmaHalInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrPutState\r\n");

    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    access = REG_RD32(NV_PGRAPH_FIFO);
    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
    GR_DONE();

    // make sure we're the current channel
    if (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) != pGrExceptionData->ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: PutState method issued on non-current channel ", pGrExceptionData->ChID);
        DBG_BREAKPOINT();
        return RM_ERR_INVALID_STATE;
    }

    if (useCtxDma) {
        // determine where the ContextDmaState buffer resides
        instance = REG_RD_DRF(_PGRAPH, _GETSTATE, _DMA_INSTANCE);
        if (!instance)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERROR;
        }

        // convert instance address to DmaHalInfo structure
        status = dmaHalInstanceToHalInfo_NV20(pGrExceptionData->ChID, instance, &pDmaHalInfo, pHalHwInfo);
        if (status)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid ContextDmaState buffer\n\r");
            DBG_BREAKPOINT();
            return RM_ERR_INVALID_STATE;
        }

        // ensure DmaState buffer is large enough for the GetState data
        if (pDmaHalInfo->BufferSize < sizeof (NvGraphicsState))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ContextDmaState smaller than GetState data\n\r");
            DBG_BREAKPOINT();
            return status;
        }

        stateptr = (NvGraphicsState *)pDmaHalInfo->BufferBase;
    } else {
        // use the local NvGraphicsState for the Snapshot/Reload interface
        stateptr = &pGrHalPvtInfo->grSnapShots[pGrExceptionData->ChID];
    }

    // first 4 DWORDS of NvGraphicsState is the PerFragment state
    REG_WR32(NV_PGRAPH_CONTROL_0, ((U032 *)stateptr)[0]);
    REG_WR32(NV_PGRAPH_CONTROL_1, ((U032 *)stateptr)[1]);
    REG_WR32(NV_PGRAPH_CONTROL_2, ((U032 *)stateptr)[2]);
    REG_WR32(NV_PGRAPH_BLEND,    ((U032 *)stateptr)[3]);

    //
    // Fetch PerVertexState from the VAB.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_DIFF<<4, 4, (U032 *)(&stateptr->PerVertexState.primaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_SPEC<<4, 3, (U032 *)(&stateptr->PerVertexState.secondaryColor[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_FOG<<4, 1, (U032 *)(&stateptr->PerVertexState.fogCoord));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT0<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[0][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_TXT1<<4, 4, (U032 *)(&stateptr->PerVertexState.texCoord[1][0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_NRM<<4, 3, (U032 *)(&stateptr->PerVertexState.normal[0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, NV_IGRAPH_XF_VAB_WGHT<<4, 1, (U032 *)(&stateptr->PerVertexState.vertexWeight));

    //
    // Fetch VertexArrayState from IDX_FMT.
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_POS<<3, 2, (U032 *)(&stateptr->VertexArrayState.vertexOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_DIFF<<3, 2, (U032 *)(&stateptr->VertexArrayState.diffuseOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_SPEC<<3, 2, (U032 *)(&stateptr->VertexArrayState.specularOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT0<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord0Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_TXT1<<3, 2, (U032 *)(&stateptr->VertexArrayState.texCoord1Offset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_NRM<<3, 2, (U032 *)(&stateptr->VertexArrayState.normalOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_WGHT<<3, 2, (U032 *)(&stateptr->VertexArrayState.weightOffset));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, NV_IGRAPH_XF_VAB_FOG<<3, 2, (U032 *)(&stateptr->VertexArrayState.fogOffset));

    //
    // Fetch edgeFlag from IDX_FMT (word 48, bit 28).
    //
    grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);
    temp &= ~0x10000000;
    temp |= ((stateptr->PerVertexState.edgeFlag & 1) << 28);
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, 48<<2, 1, &temp);

    //
    // Fetch PrimitiveAssmState from Cas0/Cas1/Cas2.
    //
    // The nv10 layout (16 word values):
    //
    //  X   Y   Z   W
    //  D   S   F   ef,ptsize
    //  S   T   R   Q
    //  S   T   R   Q
    //
    // The nv20 layout (spread out over 32 word values):
    //
    //  D   S   Z   W
    //  -   -   F   -
    //  S   T   R   Q
    //  S   T   R   Q
    //  -   -   -   -
    //  -   -   -   -
    //  X   Y   ef,ptsize -
    //
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[0+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[16+7]));

    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 0<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+4]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 1<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+5]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 2<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+2]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 3<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+3]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 6<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+6]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 8<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+8]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 12<<2, 4, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+12]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 24<<2, 2, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+0]));
    grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, 26<<2, 1, (U032 *)(&stateptr->PrimitiveAssmState.primAssm[32+7]));

    GR_DONE();
    REG_WR32(NV_PGRAPH_FIFO, access);

    return RM_OK;
}

//
// This method gives D3D access to the eye direction state.
// It would be nice to go thru RDI for this, but it turned
// out to be too problematic so we use PIPE_ADDRESS/PIPE_DATA
// instead.
//
RM_STATUS nvHalGrSetEyeDirection_NV20
(
    PHALHWINFO pHalHwInfo,
    PGREXCEPTIONDATA pGrExceptionData
)
{
    U032 offset = (pGrExceptionData->Offset - NV056_SET_EYE_DIRECTION_SW(0))/4;

    REG_WR32(NV_PGRAPH_PIPE_ADDRESS, NV_IGRAPH_XF2PIPE(NV_IGRAPH_XF_CMD_LTCTX,NV_IGRAPH_XF_LTCTX_EYED<<4) + (offset<<2));
    REG_WR32(NV_PGRAPH_PIPE_DATA, pGrExceptionData->Data);
    GR_DONE();

    return (RM_OK);
}

RM_STATUS
nvHalGrLoadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 misc;

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID) {
        (void) nvHalGrUnloadChannelContext_NV20(pHalHwInfo, pGrHalPvtInfo->currentChID);
    }

    //
    // If the incoming channel is our "invalid" channel, then
    // invalidate and we're done.
    //
    if ((pGrHalPvtInfo->currentChID = ChID) == NUM_FIFOS_NV20)
    {
        REG_WR32(NV_PGRAPH_CTX_CONTROL,
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
                 DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
		misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here

        return (RM_OK);
    }
    else if (ChID > NUM_FIFOS_NV20)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }

    //
    // If we have 3D state in this channel, then we need to
    // workaround a problem with FD state (see magnus' chsw3.c
    // diag in //hw/nv20/diag/tests/src for more info).
    //
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0)
    {
        U032 i;

        // Reset IDX/VTX/CAS state.
        REG_WR32(NV_PGRAPH_DEBUG_0,
                 DRF_DEF(_PGRAPH, _DEBUG_0, _IDX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _VTX_STATE, _RESET) |
                 DRF_DEF(_PGRAPH, _DEBUG_0, _CAS_STATE, _RESET));
        i = REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        i = REG_RD32(NV_PGRAPH_DEBUG_0);

        // Clear FD mode by writing 0 to all FD registers.
        REG_WR32(NV_PGRAPH_RDI_INDEX,
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, RDI_RAMSEL_FD_CTRL) |
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, 0));
        for (i = 0; i < 15; i++)
            REG_WR32(NV_PGRAPH_RDI_DATA, 0);
    }

    //
    // Invalidate tcache.
    //
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE, _INVALIDATE);

    REG_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    //
    // Load new context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _READ_IN, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Update hardware with new chid.
    // 
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _NOT_EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _VALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);

    REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
    return (RM_OK);
}

RM_STATUS
nvHalGrUnloadChannelContext_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // No need to unload an invalid channel
    //
    if (ChID == NUM_FIFOS_NV20)
        return (RM_OK);

    //
    // Unload context.
    //
    REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_POINTER, _INST, pGrHalPvtInfo->CtxTable[ChID]);
    REG_WR_DRF_DEF(_PGRAPH, _CHANNEL_CTX_TRIGGER, _WRITE_OUT, _ACTIVATE);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME, _EXPIRED) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID, _INVALID) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING, _IDLE) |
             DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE, _ENABLED));

    return (RM_OK);
}

#ifdef NV20_SW_CTX_SWITCH
RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV20 pSwCtxTable = (PGRAPHICSCHANNEL_NV20) pGrHalPvtInfo->SwCtxTable;

    int i, status;
    U032 debug_1;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrLoadChannelContext_NV20\r\n");

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

    HAL_GR_IDLE(pHalHwInfo);

    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID)
    {
        nvHalGrUnloadChannelContext_NV20(pHalHwInfo,
                                         pGrHalPvtInfo->currentChID,
                                         &pGrHalPvtInfo->SwCtxTable[pGrHalPvtInfo->currentChID]);
    }

    debug_1 = REG_RD32(NV_PGRAPH_DEBUG_1);
    REG_WR32(NV_PGRAPH_DEBUG_1, debug_1 | DRF_DEF(_PGRAPH,_DEBUG_1,_CACHE,_INVALIDATE));
    
    REG_WR32(NV_PGRAPH_CTX_USER, pSwCtxTable[ChID].grCtxCmn.ContextUser);
    
    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch4);
    REG_WR32(NV_PGRAPH_CTX_SWITCH5,       pSwCtxTable[ChID].grCtxCmn.ContextSwitch5);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE1(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache1[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE2(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache2[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE3(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache3[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE4(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache4[i]);
    
    for (i = 0; i < 8; i++)
      REG_WR32(NV_PGRAPH_CTX_CACHE5(i),   pSwCtxTable[ChID].grCtxCmn.ContextCache5[i]);
    
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,       pSwCtxTable[ChID].grCtxCmn.MonoColor0);
    REG_WR32(NV_PGRAPH_BSWIZZLE2,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle2);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,         pSwCtxTable[ChID].grCtxCmn.BufferSwizzle5);        
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BOFFSET(i),      pSwCtxTable[ChID].grCtxCmn.BufferOffset[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BBASE(i),        pSwCtxTable[ChID].grCtxCmn.BufferBase[i]);
    
    for (i = 0; i < 5; i++)
      REG_WR32(NV_PGRAPH_BPITCH(i),       pSwCtxTable[ChID].grCtxCmn.BufferPitch[i]);
    
    for (i = 0; i < 6; i++)
      REG_WR32(NV_PGRAPH_BLIMIT(i),       pSwCtxTable[ChID].grCtxCmn.BufferLimit[i]);
    
    REG_WR32(NV_PGRAPH_CHROMA,            pSwCtxTable[ChID].grCtxCmn.Chroma);
    REG_WR32(NV_PGRAPH_SURFACE,           pSwCtxTable[ChID].grCtxCmn.Surface);        
    REG_WR32(NV_PGRAPH_STATE,             pSwCtxTable[ChID].grCtxCmn.State);        
    REG_WR32(NV_PGRAPH_NOTIFY,            pSwCtxTable[ChID].grCtxCmn.Notify);
    
    REG_WR32(NV_PGRAPH_BPIXEL,            pSwCtxTable[ChID].grCtxCmn.BufferPixel);
    
    REG_WR32(NV_PGRAPH_DMA_PITCH,         pSwCtxTable[ChID].grCtxCmn.DmaPitch);
    
    REG_WR32(NV_PGRAPH_DVD_COLORFMT,      pSwCtxTable[ChID].grCtxCmn.DvdColorFmt);    
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,     pSwCtxTable[ChID].grCtxCmn.ScaledFormat);    
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,       pSwCtxTable[ChID].grCtxCmn.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,       pSwCtxTable[ChID].grCtxCmn.PatternColor1);
    
    REG_WR32(NV_PGRAPH_PATTERN(0),        pSwCtxTable[ChID].grCtxCmn.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),        pSwCtxTable[ChID].grCtxCmn.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,     pSwCtxTable[ChID].grCtxCmn.PatternShape);
    
    for (i = 0; i < 64; i++)
      REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pSwCtxTable[ChID].grCtxCmn.PattColorRam[i]);
    
    REG_WR32(NV_PGRAPH_ROP3,              pSwCtxTable[ChID].grCtxCmn.Rop3);
    REG_WR32(NV_PGRAPH_BETA_AND,          pSwCtxTable[ChID].grCtxCmn.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,      pSwCtxTable[ChID].grCtxCmn.BetaPreMult);
    
    REG_WR32(NV_PGRAPH_STORED_FMT,        pSwCtxTable[ChID].grCtxCmn.StoredFmt);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_X_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsXRam[i]);
    
    for (i = 0; i < 10; i++)
      REG_WR32(NV_PGRAPH_ABS_Y_RAM(i),    pSwCtxTable[ChID].grCtxCmn.AbsYRam[i]);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,    pSwCtxTable[ChID].grCtxCmn.AbsUClipYMax);
    
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX,   pSwCtxTable[ChID].grCtxCmn.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,      pSwCtxTable[ChID].grCtxCmn.SourceColor);
    REG_WR32(NV_PGRAPH_MISC24_0,          pSwCtxTable[ChID].grCtxCmn.Misc24_0);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,    pSwCtxTable[ChID].grCtxCmn.XYLogicMisc3);
    
    REG_WR32(NV_PGRAPH_CLIPX_0,           pSwCtxTable[ChID].grCtxCmn.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,           pSwCtxTable[ChID].grCtxCmn.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,           pSwCtxTable[ChID].grCtxCmn.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,           pSwCtxTable[ChID].grCtxCmn.ClipY1);
    
    REG_WR32(NV_PGRAPH_PASSTHRU_0,        pSwCtxTable[ChID].grCtxCmn.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,        pSwCtxTable[ChID].grCtxCmn.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,        pSwCtxTable[ChID].grCtxCmn.Passthru2);    
    
    REG_WR32(NV_PGRAPH_DIMX_TEXTURE,      pSwCtxTable[ChID].grCtxCmn.DimxTexture);    
    REG_WR32(NV_PGRAPH_WDIMX_TEXTURE,     pSwCtxTable[ChID].grCtxCmn.WdimxTexture);    
    
    REG_WR32(NV_PGRAPH_DMA_START_0,       pSwCtxTable[ChID].grCtxCmn.DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1,       pSwCtxTable[ChID].grCtxCmn.DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,        pSwCtxTable[ChID].grCtxCmn.DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,          pSwCtxTable[ChID].grCtxCmn.DmaMisc);
    
    REG_WR32(NV_PGRAPH_MISC24_1,          pSwCtxTable[ChID].grCtxCmn.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,          pSwCtxTable[ChID].grCtxCmn.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,            pSwCtxTable[ChID].grCtxCmn.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,            pSwCtxTable[ChID].grCtxCmn.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,            pSwCtxTable[ChID].grCtxCmn.Valid1);
    
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0007000); //reset IDX, VTX and CAS
        REG_RD32(NV_PGRAPH_DEBUG_0);
        REG_WR32(NV_PGRAPH_DEBUG_0, 0x0);
        
        REG_WR32(NV_PGRAPH_ANTIALIASING,      pSwCtxTable[ChID].grCtx3d.AntiAliasing);
        REG_WR32(NV_PGRAPH_BLEND,             pSwCtxTable[ChID].grCtx3d.Blend);
        REG_WR32(NV_PGRAPH_BLENDCOLOR,        pSwCtxTable[ChID].grCtx3d.BlendColor);
        REG_WR32(NV_PGRAPH_BORDERCOLOR0,      pSwCtxTable[ChID].grCtx3d.BorderColor0);
        REG_WR32(NV_PGRAPH_BORDERCOLOR1,      pSwCtxTable[ChID].grCtx3d.BorderColor1);
        REG_WR32(NV_PGRAPH_BORDERCOLOR2,      pSwCtxTable[ChID].grCtx3d.BorderColor2);
        REG_WR32(NV_PGRAPH_BORDERCOLOR3,      pSwCtxTable[ChID].grCtx3d.BorderColor3);
        
        REG_WR32(NV_PGRAPH_BUMPMAT00_1,       pSwCtxTable[ChID].grCtx3d.BumpMat00_1);
        REG_WR32(NV_PGRAPH_BUMPMAT00_2,       pSwCtxTable[ChID].grCtx3d.BumpMat00_2);
        REG_WR32(NV_PGRAPH_BUMPMAT00_3,       pSwCtxTable[ChID].grCtx3d.BumpMat00_3);
        REG_WR32(NV_PGRAPH_BUMPMAT01_1,       pSwCtxTable[ChID].grCtx3d.BumpMat01_1);
        REG_WR32(NV_PGRAPH_BUMPMAT01_2,       pSwCtxTable[ChID].grCtx3d.BumpMat01_2);
        REG_WR32(NV_PGRAPH_BUMPMAT01_3,       pSwCtxTable[ChID].grCtx3d.BumpMat01_3);
        REG_WR32(NV_PGRAPH_BUMPMAT10_1,       pSwCtxTable[ChID].grCtx3d.BumpMat10_1);
        REG_WR32(NV_PGRAPH_BUMPMAT10_2,       pSwCtxTable[ChID].grCtx3d.BumpMat10_2);
        REG_WR32(NV_PGRAPH_BUMPMAT10_3,       pSwCtxTable[ChID].grCtx3d.BumpMat10_3);
        REG_WR32(NV_PGRAPH_BUMPMAT11_1,       pSwCtxTable[ChID].grCtx3d.BumpMat11_1);
        REG_WR32(NV_PGRAPH_BUMPMAT11_2,       pSwCtxTable[ChID].grCtx3d.BumpMat11_2);
        REG_WR32(NV_PGRAPH_BUMPMAT11_3,       pSwCtxTable[ChID].grCtx3d.BumpMat11_3);
        
        REG_WR32(NV_PGRAPH_BUMPOFFSET1,       pSwCtxTable[ChID].grCtx3d.BumpOffset1);
        REG_WR32(NV_PGRAPH_BUMPOFFSET2,       pSwCtxTable[ChID].grCtx3d.BumpOffset2);
        REG_WR32(NV_PGRAPH_BUMPOFFSET3,       pSwCtxTable[ChID].grCtx3d.BumpOffset3);
        
        REG_WR32(NV_PGRAPH_BUMPSCALE1,        pSwCtxTable[ChID].grCtx3d.BumpScale1);
        REG_WR32(NV_PGRAPH_BUMPSCALE2,        pSwCtxTable[ChID].grCtx3d.BumpScale2);
        REG_WR32(NV_PGRAPH_BUMPSCALE3,        pSwCtxTable[ChID].grCtx3d.BumpScale3);
        
        REG_WR32(NV_PGRAPH_CLEARRECTX,        pSwCtxTable[ChID].grCtx3d.ClearRectX);
        REG_WR32(NV_PGRAPH_CLEARRECTY,        pSwCtxTable[ChID].grCtx3d.ClearRectY);
        
        REG_WR32(NV_PGRAPH_COLORCLEARVALUE,   pSwCtxTable[ChID].grCtx3d.ColorClearValue);
        
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR0,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor0);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR1,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor1);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR2,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor2);
        REG_WR32(NV_PGRAPH_COLORKEYCOLOR3,    pSwCtxTable[ChID].grCtx3d.ColorKeyColor3);
        
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR0_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor0_7);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_0,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_0);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_1,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_1);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_2,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_2);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_3,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_3);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_4,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_4);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_5,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_5);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_6,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_6);
        REG_WR32(NV_PGRAPH_COMBINEFACTOR1_7,  pSwCtxTable[ChID].grCtx3d.CombineFactor1_7);
        
        REG_WR32(NV_PGRAPH_COMBINEALPHAI0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAI7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaI7);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO0,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO0);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO1,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO1);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO2,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO2);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO3,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO3);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO4,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO4);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO5,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO5);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO6,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO6);
        REG_WR32(NV_PGRAPH_COMBINEALPHAO7,    pSwCtxTable[ChID].grCtx3d.CombineAlphaO7);
        
        REG_WR32(NV_PGRAPH_COMBINECOLORI0,    pSwCtxTable[ChID].grCtx3d.CombineColorI0);
        REG_WR32(NV_PGRAPH_COMBINECOLORI1,    pSwCtxTable[ChID].grCtx3d.CombineColorI1);
        REG_WR32(NV_PGRAPH_COMBINECOLORI2,    pSwCtxTable[ChID].grCtx3d.CombineColorI2);
        REG_WR32(NV_PGRAPH_COMBINECOLORI3,    pSwCtxTable[ChID].grCtx3d.CombineColorI3);
        REG_WR32(NV_PGRAPH_COMBINECOLORI4,    pSwCtxTable[ChID].grCtx3d.CombineColorI4);
        REG_WR32(NV_PGRAPH_COMBINECOLORI5,    pSwCtxTable[ChID].grCtx3d.CombineColorI5);
        REG_WR32(NV_PGRAPH_COMBINECOLORI6,    pSwCtxTable[ChID].grCtx3d.CombineColorI6);
        REG_WR32(NV_PGRAPH_COMBINECOLORI7,    pSwCtxTable[ChID].grCtx3d.CombineColorI7);
        REG_WR32(NV_PGRAPH_COMBINECOLORO0,    pSwCtxTable[ChID].grCtx3d.CombineColorO0);
        REG_WR32(NV_PGRAPH_COMBINECOLORO1,    pSwCtxTable[ChID].grCtx3d.CombineColorO1);
        REG_WR32(NV_PGRAPH_COMBINECOLORO2,    pSwCtxTable[ChID].grCtx3d.CombineColorO2);
        REG_WR32(NV_PGRAPH_COMBINECOLORO3,    pSwCtxTable[ChID].grCtx3d.CombineColorO3);
        REG_WR32(NV_PGRAPH_COMBINECOLORO4,    pSwCtxTable[ChID].grCtx3d.CombineColorO4);
        REG_WR32(NV_PGRAPH_COMBINECOLORO5,    pSwCtxTable[ChID].grCtx3d.CombineColorO5);
        REG_WR32(NV_PGRAPH_COMBINECOLORO6,    pSwCtxTable[ChID].grCtx3d.CombineColorO6);
        REG_WR32(NV_PGRAPH_COMBINECOLORO7,    pSwCtxTable[ChID].grCtx3d.CombineColorO7);
        
        REG_WR32(NV_PGRAPH_COMBINECTL,        pSwCtxTable[ChID].grCtx3d.CombineCtl);
        
        REG_WR32(NV_PGRAPH_COMBINESPECFOG0,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog0);
        REG_WR32(NV_PGRAPH_COMBINESPECFOG1,   pSwCtxTable[ChID].grCtx3d.CombineSpecFog1);
        
        REG_WR32(NV_PGRAPH_CONTROL_0,         pSwCtxTable[ChID].grCtx3d.Control0);
        REG_WR32(NV_PGRAPH_CONTROL_1,         pSwCtxTable[ChID].grCtx3d.Control1);
        REG_WR32(NV_PGRAPH_CONTROL_2,         pSwCtxTable[ChID].grCtx3d.Control2);
        REG_WR32(NV_PGRAPH_CONTROL_3,         pSwCtxTable[ChID].grCtx3d.Control3);
        
        REG_WR32(NV_PGRAPH_FOGCOLOR,          pSwCtxTable[ChID].grCtx3d.FogColor);
        REG_WR32(NV_PGRAPH_FOGPARAM0,         pSwCtxTable[ChID].grCtx3d.FogParam0);
        REG_WR32(NV_PGRAPH_FOGPARAM1,         pSwCtxTable[ChID].grCtx3d.FogParam1);
        REG_WR32(NV_PGRAPH_POINTSIZE,         pSwCtxTable[ChID].grCtx3d.PointSize);
        REG_WR32(NV_PGRAPH_SETUPRASTER,       pSwCtxTable[ChID].grCtx3d.SetupRaster);
        
        REG_WR32(NV_PGRAPH_SHADERCLIPMODE,    pSwCtxTable[ChID].grCtx3d.ShaderClipMode);
        REG_WR32(NV_PGRAPH_SHADERCTL,         pSwCtxTable[ChID].grCtx3d.ShaderCtl);
        REG_WR32(NV_PGRAPH_SHADERPROG,        pSwCtxTable[ChID].grCtx3d.ShaderProg);
        
        REG_WR32(NV_PGRAPH_SEMAPHOREOFFSET,   pSwCtxTable[ChID].grCtx3d.SemaphoreOffset);
        REG_WR32(NV_PGRAPH_SHADOWCTL,         pSwCtxTable[ChID].grCtx3d.ShadowCtl);
        REG_WR32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD, pSwCtxTable[ChID].grCtx3d.ShadowZSlopeThreshold);
        
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR0,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor0);
        REG_WR32(NV_PGRAPH_SPECFOGFACTOR1,    pSwCtxTable[ChID].grCtx3d.SpecFogFactor1);
        
        REG_WR32(NV_PGRAPH_SURFACECLIPX,      pSwCtxTable[ChID].grCtx3d.SurfaceClipX);
        REG_WR32(NV_PGRAPH_SURFACECLIPY,      pSwCtxTable[ChID].grCtx3d.SurfaceClipY);
        
        REG_WR32(NV_PGRAPH_TEXADDRESS0,       pSwCtxTable[ChID].grCtx3d.TexAddress0);
        REG_WR32(NV_PGRAPH_TEXADDRESS1,       pSwCtxTable[ChID].grCtx3d.TexAddress1);
        REG_WR32(NV_PGRAPH_TEXADDRESS2,       pSwCtxTable[ChID].grCtx3d.TexAddress2);
        REG_WR32(NV_PGRAPH_TEXADDRESS3,       pSwCtxTable[ChID].grCtx3d.TexAddress3);
        
        REG_WR32(NV_PGRAPH_TEXCTL0_0,         pSwCtxTable[ChID].grCtx3d.TexCtl0_0);
        REG_WR32(NV_PGRAPH_TEXCTL0_1,         pSwCtxTable[ChID].grCtx3d.TexCtl0_1);
        REG_WR32(NV_PGRAPH_TEXCTL0_2,         pSwCtxTable[ChID].grCtx3d.TexCtl0_2);
        REG_WR32(NV_PGRAPH_TEXCTL0_3,         pSwCtxTable[ChID].grCtx3d.TexCtl0_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL1_0,         pSwCtxTable[ChID].grCtx3d.TexCtl1_0);
        REG_WR32(NV_PGRAPH_TEXCTL1_1,         pSwCtxTable[ChID].grCtx3d.TexCtl1_1);
        REG_WR32(NV_PGRAPH_TEXCTL1_2,         pSwCtxTable[ChID].grCtx3d.TexCtl1_2);
        REG_WR32(NV_PGRAPH_TEXCTL1_3,         pSwCtxTable[ChID].grCtx3d.TexCtl1_3);
        
        REG_WR32(NV_PGRAPH_TEXCTL2_0,         pSwCtxTable[ChID].grCtx3d.TexCtl2_0);
        REG_WR32(NV_PGRAPH_TEXCTL2_1,         pSwCtxTable[ChID].grCtx3d.TexCtl2_1);
        
        REG_WR32(NV_PGRAPH_TEXFILTER0,        pSwCtxTable[ChID].grCtx3d.TexFilter0);
        REG_WR32(NV_PGRAPH_TEXFILTER1,        pSwCtxTable[ChID].grCtx3d.TexFilter1);
        REG_WR32(NV_PGRAPH_TEXFILTER2,        pSwCtxTable[ChID].grCtx3d.TexFilter2);
        REG_WR32(NV_PGRAPH_TEXFILTER3,        pSwCtxTable[ChID].grCtx3d.TexFilter3);
        
        REG_WR32(NV_PGRAPH_TEXFMT0,           pSwCtxTable[ChID].grCtx3d.TexFormat0);
        REG_WR32(NV_PGRAPH_TEXFMT1,           pSwCtxTable[ChID].grCtx3d.TexFormat1);
        REG_WR32(NV_PGRAPH_TEXFMT2,           pSwCtxTable[ChID].grCtx3d.TexFormat2);
        REG_WR32(NV_PGRAPH_TEXFMT3,           pSwCtxTable[ChID].grCtx3d.TexFormat3);
        
        REG_WR32(NV_PGRAPH_TEXIMAGERECT0,     pSwCtxTable[ChID].grCtx3d.TexImageRect0);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT1,     pSwCtxTable[ChID].grCtx3d.TexImageRect1);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT2,     pSwCtxTable[ChID].grCtx3d.TexImageRect2);
        REG_WR32(NV_PGRAPH_TEXIMAGERECT3,     pSwCtxTable[ChID].grCtx3d.TexImageRect3);
        
        REG_WR32(NV_PGRAPH_TEXOFFSET0,        pSwCtxTable[ChID].grCtx3d.TexOffset0);
        REG_WR32(NV_PGRAPH_TEXOFFSET1,        pSwCtxTable[ChID].grCtx3d.TexOffset1);
        REG_WR32(NV_PGRAPH_TEXOFFSET2,        pSwCtxTable[ChID].grCtx3d.TexOffset2);
        REG_WR32(NV_PGRAPH_TEXOFFSET3,        pSwCtxTable[ChID].grCtx3d.TexOffset3);
        
        REG_WR32(NV_PGRAPH_TEXPALETTE0,       pSwCtxTable[ChID].grCtx3d.TexPallete0);
        REG_WR32(NV_PGRAPH_TEXPALETTE1,       pSwCtxTable[ChID].grCtx3d.TexPallete1);
        REG_WR32(NV_PGRAPH_TEXPALETTE2,       pSwCtxTable[ChID].grCtx3d.TexPallete2);
        REG_WR32(NV_PGRAPH_TEXPALETTE3,       pSwCtxTable[ChID].grCtx3d.TexPallete3);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPX0,      pSwCtxTable[ChID].grCtx3d.WindowClipX[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX1,      pSwCtxTable[ChID].grCtx3d.WindowClipX[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX2,      pSwCtxTable[ChID].grCtx3d.WindowClipX[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX3,      pSwCtxTable[ChID].grCtx3d.WindowClipX[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX4,      pSwCtxTable[ChID].grCtx3d.WindowClipX[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX5,      pSwCtxTable[ChID].grCtx3d.WindowClipX[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX6,      pSwCtxTable[ChID].grCtx3d.WindowClipX[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPX7,      pSwCtxTable[ChID].grCtx3d.WindowClipX[7]);
        
        REG_WR32(NV_PGRAPH_WINDOWCLIPY0,      pSwCtxTable[ChID].grCtx3d.WindowClipY[0]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY1,      pSwCtxTable[ChID].grCtx3d.WindowClipY[1]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY2,      pSwCtxTable[ChID].grCtx3d.WindowClipY[2]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY3,      pSwCtxTable[ChID].grCtx3d.WindowClipY[3]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY4,      pSwCtxTable[ChID].grCtx3d.WindowClipY[4]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY5,      pSwCtxTable[ChID].grCtx3d.WindowClipY[5]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY6,      pSwCtxTable[ChID].grCtx3d.WindowClipY[6]);
        REG_WR32(NV_PGRAPH_WINDOWCLIPY7,      pSwCtxTable[ChID].grCtx3d.WindowClipY[7]);
        
        REG_WR32(NV_PGRAPH_ZCOMPRESSOCCLUDE,  pSwCtxTable[ChID].grCtx3d.ZCompressOcclude);
        REG_WR32(NV_PGRAPH_ZSTENCILCLEARVALUE,pSwCtxTable[ChID].grCtx3d.ZStencilClearValue);
        
        REG_WR32(NV_PGRAPH_ZCLIPMAX,          pSwCtxTable[ChID].grCtx3d.ZClipMax);
        REG_WR32(NV_PGRAPH_ZCLIPMIN,          pSwCtxTable[ChID].grCtx3d.ZClipMin);
        
        REG_WR32(NV_PGRAPH_CONTEXTDMAA,       pSwCtxTable[ChID].grCtx3d.ContextDmaA);
        REG_WR32(NV_PGRAPH_CONTEXTDMAB,       pSwCtxTable[ChID].grCtx3d.ContextDmaB);
        REG_WR32(NV_PGRAPH_CONTEXTVTXA,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxA);
        REG_WR32(NV_PGRAPH_CONTEXTVTXB,       pSwCtxTable[ChID].grCtx3d.ContextDmaVtxB);
        
        REG_WR32(NV_PGRAPH_ZOFFSETBIAS,       pSwCtxTable[ChID].grCtx3d.ZOffsetBias);
        REG_WR32(NV_PGRAPH_ZOFFSETFACTOR,     pSwCtxTable[ChID].grCtx3d.ZOffsetFactor);
        
        REG_WR32(NV_PGRAPH_EYEVEC0,           pSwCtxTable[ChID].grCtx3d.Eyevec0);
        REG_WR32(NV_PGRAPH_EYEVEC1,           pSwCtxTable[ChID].grCtx3d.Eyevec1);
        REG_WR32(NV_PGRAPH_EYEVEC2,           pSwCtxTable[ChID].grCtx3d.Eyevec2);
        
        REG_WR32(NV_PGRAPH_SHADOW,            pSwCtxTable[ChID].grCtx3d.Shadow);
        REG_WR32(NV_PGRAPH_FD_DATA,           pSwCtxTable[ChID].grCtx3d.FdData);
        REG_WR32(NV_PGRAPH_FD_SWATCH,         pSwCtxTable[ChID].grCtx3d.FdSwatch);
        REG_WR32(NV_PGRAPH_FD_EXTRAS,         pSwCtxTable[ChID].grCtx3d.FdExtras);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_0, pSwCtxTable[ChID].grCtx3d.Emission0);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_1, pSwCtxTable[ChID].grCtx3d.Emission1);
        REG_WR32(NV_PGRAPH_EMISSION_BACKUP_2, pSwCtxTable[ChID].grCtx3d.Emission2);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0, pSwCtxTable[ChID].grCtx3d.SceneAmb0);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1, pSwCtxTable[ChID].grCtx3d.SceneAmb1);
        REG_WR32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2, pSwCtxTable[ChID].grCtx3d.SceneAmb2);
        REG_WR32(NV_PGRAPH_GETSTATE,          pSwCtxTable[ChID].grCtx3d.ContextDmaGetState);
        REG_WR32(NV_PGRAPH_BEGINPATCH0,       pSwCtxTable[ChID].grCtx3d.BeginPatch0);
        REG_WR32(NV_PGRAPH_BEGINPATCH1,       pSwCtxTable[ChID].grCtx3d.BeginPatch1);
        REG_WR32(NV_PGRAPH_BEGINPATCH2,       pSwCtxTable[ChID].grCtx3d.BeginPatch2);
        REG_WR32(NV_PGRAPH_BEGINPATCH3,       pSwCtxTable[ChID].grCtx3d.BeginPatch3);
        REG_WR32(NV_PGRAPH_CURVE,             pSwCtxTable[ChID].grCtx3d.BeginCurve);
        REG_WR32(NV_PGRAPH_BEGINTRANS0,       pSwCtxTable[ChID].grCtx3d.BeginTrans0);
        REG_WR32(NV_PGRAPH_BEGINTRANS1,       pSwCtxTable[ChID].grCtx3d.BeginTrans1);
        REG_WR32(NV_PGRAPH_CSV0_D,            pSwCtxTable[ChID].grCtx3d.Csv0_D);
        REG_WR32(NV_PGRAPH_CSV0_C,            pSwCtxTable[ChID].grCtx3d.Csv0_C);
        REG_WR32(NV_PGRAPH_CSV1_B,            pSwCtxTable[ChID].grCtx3d.Csv1_B);
        REG_WR32(NV_PGRAPH_CSV1_A,            pSwCtxTable[ChID].grCtx3d.Csv1_A);
        REG_WR32(NV_PGRAPH_CHEOPS_OFFSET,     pSwCtxTable[ChID].grCtx3d.CheopsOffset);
        
        do {
          status = REG_RD32(NV_PGRAPH_STATUS);
        } while (status);
        
        // wait for the pipe to go idle 
        HAL_GR_IDLE(pHalHwInfo);

        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxFmt);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable[ChID].grCtxPipe.Cas2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable[ChID].grCtxPipe.AssmState);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache1);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache2);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable[ChID].grCtxPipe.IdxCache3);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile0);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable[ChID].grCtxPipe.VtxFile1);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable[ChID].grCtxPipe.XlP);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlXfCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtCtx);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable[ChID].grCtxPipe.XlLtc);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable[ChID].grCtxPipe.XlVab);
        
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable[ChID].grCtxPipe.CrstrStipp);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable[ChID].grCtxPipe.FdCtrl);
        grLoadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable[ChID].grCtxPipe.RopRegs);
    }
    
    
    REG_WR32(NV_PGRAPH_CTX_CONTROL,
        DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME,   _33US)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
        | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                      
    
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);

    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xCFFFFFFF);
    
    REG_WR_DRF_DEF(_PGRAPH,_FIFO,_ACCESS,_ENABLED);

    return (RM_OK);
}

RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO pHalHwInfo, U032 ChID, PGRAPHICSCHANNEL_NV20 pSwCtxTable)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20) pHalHwInfo->pGrHalPvtInfo;

    U032 ctxControl;
    int i;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrUnloadChannelContext_NV20\r\n");

    HAL_GR_IDLE(pHalHwInfo);

    ctxControl = REG_RD32(NV_PGRAPH_CTX_CONTROL);
    
    if (DRF_VAL(_PGRAPH,_CTX_CONTROL,_CHID, ctxControl) == NV_PGRAPH_CTX_CONTROL_CHID_INVALID)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: grUnloadCurrentChannelContext() current chid is invalid\n");
        return (RM_OK);
    }
    
    pSwCtxTable->grCtxCmn.ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current context registers.
    //
    pSwCtxTable->grCtxCmn.ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pSwCtxTable->grCtxCmn.ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pSwCtxTable->grCtxCmn.ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pSwCtxTable->grCtxCmn.ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pSwCtxTable->grCtxCmn.ContextSwitch5    = REG_RD32(NV_PGRAPH_CTX_SWITCH5);
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
    
    for (i = 0; i < 8; i++)
        pSwCtxTable->grCtxCmn.ContextCache5[i] = REG_RD32(NV_PGRAPH_CTX_CACHE5(i));
    
    pSwCtxTable->grCtxCmn.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pSwCtxTable->grCtxCmn.BufferSwizzle2      = REG_RD32(NV_PGRAPH_BSWIZZLE2);        
    pSwCtxTable->grCtxCmn.BufferSwizzle5      = REG_RD32(NV_PGRAPH_BSWIZZLE5);        
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
    
    for (i = 0; i < 5; i++)
        pSwCtxTable->grCtxCmn.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
    
    for (i = 0; i < 6; i++)
        pSwCtxTable->grCtxCmn.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    
    pSwCtxTable->grCtxCmn.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    
    pSwCtxTable->grCtxCmn.Surface             = REG_RD32(NV_PGRAPH_SURFACE);        
    pSwCtxTable->grCtxCmn.State               = REG_RD32(NV_PGRAPH_STATE);        
    pSwCtxTable->grCtxCmn.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
    pSwCtxTable->grCtxCmn.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    
    pSwCtxTable->grCtxCmn.DmaPitch            = REG_RD32(NV_PGRAPH_DMA_PITCH);
    pSwCtxTable->grCtxCmn.DvdColorFmt         = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pSwCtxTable->grCtxCmn.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pSwCtxTable->grCtxCmn.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pSwCtxTable->grCtxCmn.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    pSwCtxTable->grCtxCmn.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pSwCtxTable->grCtxCmn.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pSwCtxTable->grCtxCmn.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    for (i = 0; i < 64; i++)
        pSwCtxTable->grCtxCmn.PattColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    
    
    pSwCtxTable->grCtxCmn.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pSwCtxTable->grCtxCmn.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pSwCtxTable->grCtxCmn.BetaPreMult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    pSwCtxTable->grCtxCmn.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
      
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsXRam[i]        = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
    
    for (i = 0; i < 10; i++)
      pSwCtxTable->grCtxCmn.AbsYRam[i]        = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    
    pSwCtxTable->grCtxCmn.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pSwCtxTable->grCtxCmn.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pSwCtxTable->grCtxCmn.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pSwCtxTable->grCtxCmn.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pSwCtxTable->grCtxCmn.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    pSwCtxTable->grCtxCmn.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    
    pSwCtxTable->grCtxCmn.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pSwCtxTable->grCtxCmn.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pSwCtxTable->grCtxCmn.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pSwCtxTable->grCtxCmn.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);
    
    pSwCtxTable->grCtxCmn.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pSwCtxTable->grCtxCmn.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pSwCtxTable->grCtxCmn.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pSwCtxTable->grCtxCmn.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    pSwCtxTable->grCtxCmn.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pSwCtxTable->grCtxCmn.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pSwCtxTable->grCtxCmn.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pSwCtxTable->grCtxCmn.DimxTexture         = REG_RD32(NV_PGRAPH_DIMX_TEXTURE);    
    pSwCtxTable->grCtxCmn.WdimxTexture        = REG_RD32(NV_PGRAPH_WDIMX_TEXTURE);    
    
    pSwCtxTable->grCtxCmn.DmaStart0           = REG_RD32(NV_PGRAPH_DMA_START_0);
    pSwCtxTable->grCtxCmn.DmaStart1           = REG_RD32(NV_PGRAPH_DMA_START_1);
    pSwCtxTable->grCtxCmn.DmaLength           = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pSwCtxTable->grCtxCmn.DmaMisc             = REG_RD32(NV_PGRAPH_DMA_MISC);
    
    pSwCtxTable->grCtxCmn.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pSwCtxTable->grCtxCmn.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pSwCtxTable->grCtxCmn.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pSwCtxTable->grCtxCmn.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pSwCtxTable->grCtxCmn.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
      
    if (pGrHalPvtInfo->currentObjects3d[ChID] != 0) {
        // 3D stuff
        pSwCtxTable->grCtx3d.AntiAliasing        = REG_RD32(NV_PGRAPH_ANTIALIASING);
        pSwCtxTable->grCtx3d.Blend               = REG_RD32(NV_PGRAPH_BLEND);
        pSwCtxTable->grCtx3d.BlendColor          = REG_RD32(NV_PGRAPH_BLENDCOLOR);
        pSwCtxTable->grCtx3d.BorderColor0        = REG_RD32(NV_PGRAPH_BORDERCOLOR0);
        pSwCtxTable->grCtx3d.BorderColor1        = REG_RD32(NV_PGRAPH_BORDERCOLOR1);
        pSwCtxTable->grCtx3d.BorderColor2        = REG_RD32(NV_PGRAPH_BORDERCOLOR2);
        pSwCtxTable->grCtx3d.BorderColor3        = REG_RD32(NV_PGRAPH_BORDERCOLOR3);
        
        pSwCtxTable->grCtx3d.BumpMat00_1         = REG_RD32(NV_PGRAPH_BUMPMAT00_1);
        pSwCtxTable->grCtx3d.BumpMat00_2         = REG_RD32(NV_PGRAPH_BUMPMAT00_2);
        pSwCtxTable->grCtx3d.BumpMat00_3         = REG_RD32(NV_PGRAPH_BUMPMAT00_3);
        pSwCtxTable->grCtx3d.BumpMat01_1         = REG_RD32(NV_PGRAPH_BUMPMAT01_1);
        pSwCtxTable->grCtx3d.BumpMat01_2         = REG_RD32(NV_PGRAPH_BUMPMAT01_2);
        pSwCtxTable->grCtx3d.BumpMat01_3         = REG_RD32(NV_PGRAPH_BUMPMAT01_3);
        pSwCtxTable->grCtx3d.BumpMat10_1         = REG_RD32(NV_PGRAPH_BUMPMAT10_1);
        pSwCtxTable->grCtx3d.BumpMat10_2         = REG_RD32(NV_PGRAPH_BUMPMAT10_2);
        pSwCtxTable->grCtx3d.BumpMat10_3         = REG_RD32(NV_PGRAPH_BUMPMAT10_3);
        pSwCtxTable->grCtx3d.BumpMat11_1         = REG_RD32(NV_PGRAPH_BUMPMAT11_1);
        pSwCtxTable->grCtx3d.BumpMat11_2         = REG_RD32(NV_PGRAPH_BUMPMAT11_2);
        pSwCtxTable->grCtx3d.BumpMat11_3         = REG_RD32(NV_PGRAPH_BUMPMAT11_3);
        
        pSwCtxTable->grCtx3d.BumpOffset1         = REG_RD32(NV_PGRAPH_BUMPOFFSET1);
        pSwCtxTable->grCtx3d.BumpOffset2         = REG_RD32(NV_PGRAPH_BUMPOFFSET2);
        pSwCtxTable->grCtx3d.BumpOffset3         = REG_RD32(NV_PGRAPH_BUMPOFFSET3);
        
        pSwCtxTable->grCtx3d.BumpScale1          = REG_RD32(NV_PGRAPH_BUMPSCALE1);
        pSwCtxTable->grCtx3d.BumpScale2          = REG_RD32(NV_PGRAPH_BUMPSCALE2);
        pSwCtxTable->grCtx3d.BumpScale3          = REG_RD32(NV_PGRAPH_BUMPSCALE3);
        
        pSwCtxTable->grCtx3d.ClearRectX          = REG_RD32(NV_PGRAPH_CLEARRECTX);
        pSwCtxTable->grCtx3d.ClearRectY          = REG_RD32(NV_PGRAPH_CLEARRECTY);
        
        pSwCtxTable->grCtx3d.ColorClearValue     = REG_RD32(NV_PGRAPH_COLORCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ColorKeyColor0      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR0);
        pSwCtxTable->grCtx3d.ColorKeyColor1      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR1);
        pSwCtxTable->grCtx3d.ColorKeyColor2      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR2);
        pSwCtxTable->grCtx3d.ColorKeyColor3      = REG_RD32(NV_PGRAPH_COLORKEYCOLOR3);
        
        pSwCtxTable->grCtx3d.CombineFactor0_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_0);
        pSwCtxTable->grCtx3d.CombineFactor0_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_1);
        pSwCtxTable->grCtx3d.CombineFactor0_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_2);
        pSwCtxTable->grCtx3d.CombineFactor0_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_3);
        pSwCtxTable->grCtx3d.CombineFactor0_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_4);
        pSwCtxTable->grCtx3d.CombineFactor0_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_5);
        pSwCtxTable->grCtx3d.CombineFactor0_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_6);
        pSwCtxTable->grCtx3d.CombineFactor0_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR0_7);
        pSwCtxTable->grCtx3d.CombineFactor1_0    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_0);
        pSwCtxTable->grCtx3d.CombineFactor1_1    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_1);
        pSwCtxTable->grCtx3d.CombineFactor1_2    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_2);
        pSwCtxTable->grCtx3d.CombineFactor1_3    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_3);
        pSwCtxTable->grCtx3d.CombineFactor1_4    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_4);
        pSwCtxTable->grCtx3d.CombineFactor1_5    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_5);
        pSwCtxTable->grCtx3d.CombineFactor1_6    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_6);
        pSwCtxTable->grCtx3d.CombineFactor1_7    = REG_RD32(NV_PGRAPH_COMBINEFACTOR1_7);
        
        pSwCtxTable->grCtx3d.CombineAlphaI0      = REG_RD32(NV_PGRAPH_COMBINEALPHAI0);
        pSwCtxTable->grCtx3d.CombineAlphaI1      = REG_RD32(NV_PGRAPH_COMBINEALPHAI1);
        pSwCtxTable->grCtx3d.CombineAlphaI2      = REG_RD32(NV_PGRAPH_COMBINEALPHAI2);
        pSwCtxTable->grCtx3d.CombineAlphaI3      = REG_RD32(NV_PGRAPH_COMBINEALPHAI3);
        pSwCtxTable->grCtx3d.CombineAlphaI4      = REG_RD32(NV_PGRAPH_COMBINEALPHAI4);
        pSwCtxTable->grCtx3d.CombineAlphaI5      = REG_RD32(NV_PGRAPH_COMBINEALPHAI5);
        pSwCtxTable->grCtx3d.CombineAlphaI6      = REG_RD32(NV_PGRAPH_COMBINEALPHAI6);
        pSwCtxTable->grCtx3d.CombineAlphaI7      = REG_RD32(NV_PGRAPH_COMBINEALPHAI7);
        pSwCtxTable->grCtx3d.CombineAlphaO0      = REG_RD32(NV_PGRAPH_COMBINEALPHAO0);
        pSwCtxTable->grCtx3d.CombineAlphaO1      = REG_RD32(NV_PGRAPH_COMBINEALPHAO1);
        pSwCtxTable->grCtx3d.CombineAlphaO2      = REG_RD32(NV_PGRAPH_COMBINEALPHAO2);
        pSwCtxTable->grCtx3d.CombineAlphaO3      = REG_RD32(NV_PGRAPH_COMBINEALPHAO3);
        pSwCtxTable->grCtx3d.CombineAlphaO4      = REG_RD32(NV_PGRAPH_COMBINEALPHAO4);
        pSwCtxTable->grCtx3d.CombineAlphaO5      = REG_RD32(NV_PGRAPH_COMBINEALPHAO5);
        pSwCtxTable->grCtx3d.CombineAlphaO6      = REG_RD32(NV_PGRAPH_COMBINEALPHAO6);
        pSwCtxTable->grCtx3d.CombineAlphaO7      = REG_RD32(NV_PGRAPH_COMBINEALPHAO7);
        
        pSwCtxTable->grCtx3d.CombineColorI0      = REG_RD32(NV_PGRAPH_COMBINECOLORI0);
        pSwCtxTable->grCtx3d.CombineColorI1      = REG_RD32(NV_PGRAPH_COMBINECOLORI1);
        pSwCtxTable->grCtx3d.CombineColorI2      = REG_RD32(NV_PGRAPH_COMBINECOLORI2);
        pSwCtxTable->grCtx3d.CombineColorI3      = REG_RD32(NV_PGRAPH_COMBINECOLORI3);
        pSwCtxTable->grCtx3d.CombineColorI4      = REG_RD32(NV_PGRAPH_COMBINECOLORI4);
        pSwCtxTable->grCtx3d.CombineColorI5      = REG_RD32(NV_PGRAPH_COMBINECOLORI5);
        pSwCtxTable->grCtx3d.CombineColorI6      = REG_RD32(NV_PGRAPH_COMBINECOLORI6);
        pSwCtxTable->grCtx3d.CombineColorI7      = REG_RD32(NV_PGRAPH_COMBINECOLORI7);
        pSwCtxTable->grCtx3d.CombineColorO0      = REG_RD32(NV_PGRAPH_COMBINECOLORO0);
        pSwCtxTable->grCtx3d.CombineColorO1      = REG_RD32(NV_PGRAPH_COMBINECOLORO1);
        pSwCtxTable->grCtx3d.CombineColorO2      = REG_RD32(NV_PGRAPH_COMBINECOLORO2);
        pSwCtxTable->grCtx3d.CombineColorO3      = REG_RD32(NV_PGRAPH_COMBINECOLORO3);
        pSwCtxTable->grCtx3d.CombineColorO4      = REG_RD32(NV_PGRAPH_COMBINECOLORO4);
        pSwCtxTable->grCtx3d.CombineColorO5      = REG_RD32(NV_PGRAPH_COMBINECOLORO5);
        pSwCtxTable->grCtx3d.CombineColorO6      = REG_RD32(NV_PGRAPH_COMBINECOLORO6);
        pSwCtxTable->grCtx3d.CombineColorO7      = REG_RD32(NV_PGRAPH_COMBINECOLORO7);
        
        pSwCtxTable->grCtx3d.CombineCtl          = REG_RD32(NV_PGRAPH_COMBINECTL);
        
        pSwCtxTable->grCtx3d.CombineSpecFog0     = REG_RD32(NV_PGRAPH_COMBINESPECFOG0);
        pSwCtxTable->grCtx3d.CombineSpecFog1     = REG_RD32(NV_PGRAPH_COMBINESPECFOG1);
        
        pSwCtxTable->grCtx3d.Control0            = REG_RD32(NV_PGRAPH_CONTROL_0);
        pSwCtxTable->grCtx3d.Control1            = REG_RD32(NV_PGRAPH_CONTROL_1);
        pSwCtxTable->grCtx3d.Control2            = REG_RD32(NV_PGRAPH_CONTROL_2);
        pSwCtxTable->grCtx3d.Control3            = REG_RD32(NV_PGRAPH_CONTROL_3);
        
        pSwCtxTable->grCtx3d.FogColor            = REG_RD32(NV_PGRAPH_FOGCOLOR);
        pSwCtxTable->grCtx3d.FogParam0           = REG_RD32(NV_PGRAPH_FOGPARAM0);
        pSwCtxTable->grCtx3d.FogParam1           = REG_RD32(NV_PGRAPH_FOGPARAM1);
        pSwCtxTable->grCtx3d.PointSize           = REG_RD32(NV_PGRAPH_POINTSIZE);
        pSwCtxTable->grCtx3d.SetupRaster         = REG_RD32(NV_PGRAPH_SETUPRASTER);
        
        pSwCtxTable->grCtx3d.ShaderClipMode      = REG_RD32(NV_PGRAPH_SHADERCLIPMODE);
        pSwCtxTable->grCtx3d.ShaderCtl           = REG_RD32(NV_PGRAPH_SHADERCTL);
        pSwCtxTable->grCtx3d.ShaderProg          = REG_RD32(NV_PGRAPH_SHADERPROG);
        
        pSwCtxTable->grCtx3d.SemaphoreOffset     = REG_RD32(NV_PGRAPH_SEMAPHOREOFFSET);
        pSwCtxTable->grCtx3d.ShadowCtl           = REG_RD32(NV_PGRAPH_SHADOWCTL);
        pSwCtxTable->grCtx3d.ShadowZSlopeThreshold = REG_RD32(NV_PGRAPH_SHADOWZSLOPETHRESHOLD);
        
        pSwCtxTable->grCtx3d.SpecFogFactor0      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR0);
        pSwCtxTable->grCtx3d.SpecFogFactor1      = REG_RD32(NV_PGRAPH_SPECFOGFACTOR1);
        
        pSwCtxTable->grCtx3d.SurfaceClipX        = REG_RD32(NV_PGRAPH_SURFACECLIPX);
        pSwCtxTable->grCtx3d.SurfaceClipY        = REG_RD32(NV_PGRAPH_SURFACECLIPY);
        
        pSwCtxTable->grCtx3d.TexAddress0         = REG_RD32(NV_PGRAPH_TEXADDRESS0);
        pSwCtxTable->grCtx3d.TexAddress1         = REG_RD32(NV_PGRAPH_TEXADDRESS1);
        pSwCtxTable->grCtx3d.TexAddress2         = REG_RD32(NV_PGRAPH_TEXADDRESS2);
        pSwCtxTable->grCtx3d.TexAddress3         = REG_RD32(NV_PGRAPH_TEXADDRESS3);
        
        pSwCtxTable->grCtx3d.TexCtl0_0       = REG_RD32(NV_PGRAPH_TEXCTL0_0);
        pSwCtxTable->grCtx3d.TexCtl0_1       = REG_RD32(NV_PGRAPH_TEXCTL0_1);
        pSwCtxTable->grCtx3d.TexCtl0_2       = REG_RD32(NV_PGRAPH_TEXCTL0_2);
        pSwCtxTable->grCtx3d.TexCtl0_3       = REG_RD32(NV_PGRAPH_TEXCTL0_3);
        
        pSwCtxTable->grCtx3d.TexCtl1_0       = REG_RD32(NV_PGRAPH_TEXCTL1_0);
        pSwCtxTable->grCtx3d.TexCtl1_1       = REG_RD32(NV_PGRAPH_TEXCTL1_1);
        pSwCtxTable->grCtx3d.TexCtl1_2       = REG_RD32(NV_PGRAPH_TEXCTL1_2);
        pSwCtxTable->grCtx3d.TexCtl1_3       = REG_RD32(NV_PGRAPH_TEXCTL1_3);
        
        pSwCtxTable->grCtx3d.TexCtl2_0       = REG_RD32(NV_PGRAPH_TEXCTL2_0);
        pSwCtxTable->grCtx3d.TexCtl2_1       = REG_RD32(NV_PGRAPH_TEXCTL2_1);
        
        pSwCtxTable->grCtx3d.TexFilter0          = REG_RD32(NV_PGRAPH_TEXFILTER0);
        pSwCtxTable->grCtx3d.TexFilter1          = REG_RD32(NV_PGRAPH_TEXFILTER1);
        pSwCtxTable->grCtx3d.TexFilter2          = REG_RD32(NV_PGRAPH_TEXFILTER2);
        pSwCtxTable->grCtx3d.TexFilter3          = REG_RD32(NV_PGRAPH_TEXFILTER3);
        
        pSwCtxTable->grCtx3d.TexFormat0          = REG_RD32(NV_PGRAPH_TEXFMT0);
        pSwCtxTable->grCtx3d.TexFormat1          = REG_RD32(NV_PGRAPH_TEXFMT1);
        pSwCtxTable->grCtx3d.TexFormat2          = REG_RD32(NV_PGRAPH_TEXFMT2);
        pSwCtxTable->grCtx3d.TexFormat3          = REG_RD32(NV_PGRAPH_TEXFMT3);
        
        pSwCtxTable->grCtx3d.TexImageRect0       = REG_RD32(NV_PGRAPH_TEXIMAGERECT0);
        pSwCtxTable->grCtx3d.TexImageRect1       = REG_RD32(NV_PGRAPH_TEXIMAGERECT1);
        pSwCtxTable->grCtx3d.TexImageRect2       = REG_RD32(NV_PGRAPH_TEXIMAGERECT2);
        pSwCtxTable->grCtx3d.TexImageRect3       = REG_RD32(NV_PGRAPH_TEXIMAGERECT3);
        
        pSwCtxTable->grCtx3d.TexOffset0          = REG_RD32(NV_PGRAPH_TEXOFFSET0);
        pSwCtxTable->grCtx3d.TexOffset1          = REG_RD32(NV_PGRAPH_TEXOFFSET1);
        pSwCtxTable->grCtx3d.TexOffset2          = REG_RD32(NV_PGRAPH_TEXOFFSET2);
        pSwCtxTable->grCtx3d.TexOffset3          = REG_RD32(NV_PGRAPH_TEXOFFSET3);
        
        pSwCtxTable->grCtx3d.TexPallete0         = REG_RD32(NV_PGRAPH_TEXPALETTE0);
        pSwCtxTable->grCtx3d.TexPallete1         = REG_RD32(NV_PGRAPH_TEXPALETTE1);
        pSwCtxTable->grCtx3d.TexPallete2         = REG_RD32(NV_PGRAPH_TEXPALETTE2);
        pSwCtxTable->grCtx3d.TexPallete3         = REG_RD32(NV_PGRAPH_TEXPALETTE3);
        
        pSwCtxTable->grCtx3d.WindowClipX[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX0);
        pSwCtxTable->grCtx3d.WindowClipX[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX1);
        pSwCtxTable->grCtx3d.WindowClipX[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX2);
        pSwCtxTable->grCtx3d.WindowClipX[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX3);
        pSwCtxTable->grCtx3d.WindowClipX[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX4);
        pSwCtxTable->grCtx3d.WindowClipX[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX5);
        pSwCtxTable->grCtx3d.WindowClipX[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX6);
        pSwCtxTable->grCtx3d.WindowClipX[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPX7);
        
        pSwCtxTable->grCtx3d.WindowClipY[0]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY0);
        pSwCtxTable->grCtx3d.WindowClipY[1]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY1);
        pSwCtxTable->grCtx3d.WindowClipY[2]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY2);
        pSwCtxTable->grCtx3d.WindowClipY[3]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY3);
        pSwCtxTable->grCtx3d.WindowClipY[4]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY4);
        pSwCtxTable->grCtx3d.WindowClipY[5]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY5);
        pSwCtxTable->grCtx3d.WindowClipY[6]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY6);
        pSwCtxTable->grCtx3d.WindowClipY[7]      = REG_RD32(NV_PGRAPH_WINDOWCLIPY7);
        
        pSwCtxTable->grCtx3d.ZCompressOcclude    = REG_RD32(NV_PGRAPH_ZCOMPRESSOCCLUDE);
        pSwCtxTable->grCtx3d.ZStencilClearValue  = REG_RD32(NV_PGRAPH_ZSTENCILCLEARVALUE);
        
        pSwCtxTable->grCtx3d.ZClipMax            = REG_RD32(NV_PGRAPH_ZCLIPMAX);
        pSwCtxTable->grCtx3d.ZClipMin            = REG_RD32(NV_PGRAPH_ZCLIPMIN);
        
        pSwCtxTable->grCtx3d.ContextDmaA         = REG_RD32(NV_PGRAPH_CONTEXTDMAA);
        pSwCtxTable->grCtx3d.ContextDmaB         = REG_RD32(NV_PGRAPH_CONTEXTDMAB);
        pSwCtxTable->grCtx3d.ContextDmaVtxA      = REG_RD32(NV_PGRAPH_CONTEXTVTXA);
        pSwCtxTable->grCtx3d.ContextDmaVtxB      = REG_RD32(NV_PGRAPH_CONTEXTVTXB);
        
        pSwCtxTable->grCtx3d.ZOffsetBias         = REG_RD32(NV_PGRAPH_ZOFFSETBIAS);
        pSwCtxTable->grCtx3d.ZOffsetFactor       = REG_RD32(NV_PGRAPH_ZOFFSETFACTOR);
        
        pSwCtxTable->grCtx3d.Eyevec0             = REG_RD32(NV_PGRAPH_EYEVEC0);
        pSwCtxTable->grCtx3d.Eyevec1             = REG_RD32(NV_PGRAPH_EYEVEC1);
        pSwCtxTable->grCtx3d.Eyevec2             = REG_RD32(NV_PGRAPH_EYEVEC2);
        
        pSwCtxTable->grCtx3d.Shadow              = REG_RD32(NV_PGRAPH_SHADOW);
        pSwCtxTable->grCtx3d.FdData              = REG_RD32(NV_PGRAPH_FD_DATA);
        pSwCtxTable->grCtx3d.FdSwatch            = REG_RD32(NV_PGRAPH_FD_SWATCH);
        pSwCtxTable->grCtx3d.FdExtras            = REG_RD32(NV_PGRAPH_FD_EXTRAS);
        pSwCtxTable->grCtx3d.Emission0           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_0);
        pSwCtxTable->grCtx3d.Emission1           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_1);
        pSwCtxTable->grCtx3d.Emission2           = REG_RD32(NV_PGRAPH_EMISSION_BACKUP_2);
        pSwCtxTable->grCtx3d.SceneAmb0           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_0);
        pSwCtxTable->grCtx3d.SceneAmb1           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_1);
        pSwCtxTable->grCtx3d.SceneAmb2           = REG_RD32(NV_PGRAPH_SCENE_AMBIENT_BACKUP_2);
        pSwCtxTable->grCtx3d.ContextDmaGetState  = REG_RD32(NV_PGRAPH_GETSTATE);
        pSwCtxTable->grCtx3d.BeginPatch0         = REG_RD32(NV_PGRAPH_BEGINPATCH0);
        pSwCtxTable->grCtx3d.BeginPatch1         = REG_RD32(NV_PGRAPH_BEGINPATCH1);
        pSwCtxTable->grCtx3d.BeginPatch2         = REG_RD32(NV_PGRAPH_BEGINPATCH2);
        pSwCtxTable->grCtx3d.BeginPatch3         = REG_RD32(NV_PGRAPH_BEGINPATCH3);
        pSwCtxTable->grCtx3d.BeginCurve          = REG_RD32(NV_PGRAPH_CURVE);
        pSwCtxTable->grCtx3d.BeginTrans0         = REG_RD32(NV_PGRAPH_BEGINTRANS0);
        pSwCtxTable->grCtx3d.BeginTrans1         = REG_RD32(NV_PGRAPH_BEGINTRANS1);
        pSwCtxTable->grCtx3d.Csv0_D              = REG_RD32(NV_PGRAPH_CSV0_D);
        pSwCtxTable->grCtx3d.Csv0_C              = REG_RD32(NV_PGRAPH_CSV0_C);
        pSwCtxTable->grCtx3d.Csv1_B              = REG_RD32(NV_PGRAPH_CSV1_B);
        pSwCtxTable->grCtx3d.Csv1_A              = REG_RD32(NV_PGRAPH_CSV1_A);
        pSwCtxTable->grCtx3d.CheopsOffset        = REG_RD32(NV_PGRAPH_CHEOPS_OFFSET);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_FMT, RDI_ADDR_ZERO, IDX_FMT_COUNT, pSwCtxTable->grCtxPipe.IdxFmt);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS0, RDI_ADDR_ZERO, CAS0_COUNT, pSwCtxTable->grCtxPipe.Cas0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS1, RDI_ADDR_ZERO, CAS1_COUNT, pSwCtxTable->grCtxPipe.Cas1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CAS2, RDI_ADDR_ZERO, CAS2_COUNT, pSwCtxTable->grCtxPipe.Cas2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ASSM_STATE, RDI_ADDR_ZERO, ASSM_STATE_COUNT, pSwCtxTable->grCtxPipe.AssmState);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE0, RDI_ADDR_ZERO, IDX_CACHE0_COUNT, pSwCtxTable->grCtxPipe.IdxCache0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE1, RDI_ADDR_ZERO, IDX_CACHE1_COUNT, pSwCtxTable->grCtxPipe.IdxCache1);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE2, RDI_ADDR_ZERO, IDX_CACHE2_COUNT, pSwCtxTable->grCtxPipe.IdxCache2);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_IDX_CACHE3, RDI_ADDR_ZERO, IDX_CACHE3_COUNT, pSwCtxTable->grCtxPipe.IdxCache3);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE0, RDI_ADDR_ZERO, VTX_FILE0_COUNT, pSwCtxTable->grCtxPipe.VtxFile0);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_VTX_FILE1, RDI_ADDR_ZERO, VTX_FILE1_COUNT, pSwCtxTable->grCtxPipe.VtxFile1);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_P, RDI_ADDR_ZERO, XL_P_COUNT, pSwCtxTable->grCtxPipe.XlP);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_XFCTX, RDI_ADDR_ZERO, XL_XFCTX_COUNT, pSwCtxTable->grCtxPipe.XlXfCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTCTX, RDI_ADDR_ZERO, XL_LTCTX_COUNT, pSwCtxTable->grCtxPipe.XlLtCtx);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_LTC, RDI_ADDR_ZERO, XL_LTC_COUNT, pSwCtxTable->grCtxPipe.XlLtc);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_XL_VAB, RDI_ADDR_ZERO, XL_VAB_COUNT, pSwCtxTable->grCtxPipe.XlVab);
        
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_CRSTR_STIPP, RDI_ADDR_ZERO, CRSTR_STIPP_COUNT, pSwCtxTable->grCtxPipe.CrstrStipp);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_FD_CTRL, RDI_ADDR_ZERO, FD_CTRL_COUNT, pSwCtxTable->grCtxPipe.FdCtrl);
        grUnloadRdiContext(pHalHwInfo, RDI_RAMSEL_ROP_REGS, RDI_ADDR_ZERO, ROP_REGS_COUNT, pSwCtxTable->grCtxPipe.RopRegs);
    }

    // wait for the pipe to go idle again after unloading the pipeline context
    HAL_GR_IDLE(pHalHwInfo);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));

    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, (NUM_FIFOS_NV20 - 1));

    return (RM_OK);
}
#endif // #ifdef NV20_SW_CTX_SWITCH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv\grval.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRVAL.C                                                           *
*   The graphics engine is managed in this module.  Graphics patches are    *
*   validated here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <dac.h>
#include <gr.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
//
// Externs.
//
// extern PGRAPHICSCHANNEL grTable;

//---------------------------------------------------------------------------
//
//  Validate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grValidateVideoPatchcord
(
    // PHWINFO pDev,
    PVIDEOPATCHCORD   VideoPatchcord,
    PPATCHCONTEXT     PatchContext,
    U032              DestCount
)
{
    PVIDEOOBJECT VideoObject = (void *) 0;
    U032         i;
    
    //
    // Initialize context configuration.
    //
    PatchContext->VideoConfig  = BOTH_BUFFERS;
    PatchContext->ColorMap0    = NULL;
    PatchContext->ColorMap1    = NULL;
    PatchContext->VideoScaler  = NULL;
    PatchContext->VideoColorKey = NULL;

    //
    // Find output of patchcord.
    //
    if (VideoPatchcord && VideoPatchcord->FanOut)
    {
        //
        // Search for the first destination
        //
        DBG_VAL_PTR(VideoPatchcord);
        for (i = 0; (i < MAX_GRPATCH_FANOUT) && DestCount; i++)
        {
            if ((VideoObject = VideoPatchcord->Destination[i]))
            {
                DBG_VAL_PTR(VideoPatchcord->Destination[i]);
                DestCount--;
            }
        }
#if DEBUG
        if (DestCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid patchcord in VidPatchValidation!\n\r");
            DBG_BREAKPOINT();
            return (RM_ERROR);
        }
#endif // DEBUG
    }
    else
        return (RM_ERR_INCOMPLETE_PATCH);
    //
    // Accumulate video patch configuration.
    //
    while ( VideoObject && (VideoObject->Base.Class->Type != NV_VIDEO_SINK))
    {
        DBG_VAL_PTR(VideoObject);
        /* KJK
        if (VideoObject->Base.Class->Type == NV_VIDEO_SWITCH)
        {
            //
            // Check which buffers to read/write to.
            //
            if (PatchContext->VideoConfig != BOTH_BUFFERS)
                return (RM_ERR_INVALID_PATCH);
            //
            // Ordinal.
            //
            if (((PVIDEOSWITCHOBJECT)VideoObject)->Ordinal)
                PatchContext->VideoSwitch = (PVIDEOSWITCHOBJECT)VideoObject;
            else    
                return (RM_ERR_INCOMPLETE_PATCH);
            //
            // Initialize the buffer toggle for this patch if it hasn't
            //  already been done.
            //
            if (PatchContext->Canvas->BufferToggle == INVALID_BUFFER)
            {
                if (pDev->Framebuffer.ActiveCount == 1)
                    //
                    // If this is the only double buffered application, then buffer
                    // toggle is always 0 because the toggle does not actually
                    // toggle for single double bufferd clients.
                    //
                    PatchContext->Canvas->BufferToggle = 0;
                else
                    //
                    // When multiple double buffered sessions are active set it to be
                    // whatever the current buffer is.
                    //
                    PatchContext->Canvas->BufferToggle = pDev->Framebuffer.Current;
            }
            PatchContext->VideoConfig = 0;
            if (PatchContext->ColorMap0)
            {
                //
                // Video switch occurs after the colormap.
                //
                if (VideoObject->VideoInput[0] == PatchContext->ColorMap0->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == PatchContext->ColorMap1->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            else
            {
                //
                // Video switch occurs after imagevideo.
                //
                if (VideoObject->VideoInput[0] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig = 1;
                if (VideoObject->VideoInput[1] == ((PIMAGEVIDEOOBJECT)PatchContext->ImageObject)->VideoOutput)
                    PatchContext->VideoConfig += 2;
            }
            if (PatchContext->VideoConfig == 1)
                PatchContext->ColorMap1 = NULL;
            else if (PatchContext->VideoConfig == 2)
                PatchContext->ColorMap0 = NULL;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else*/
        if (VideoObject->Base.Class->Type == NV_VIDEO_COLORMAP)
        {
            //
            // Add the color map to the patch configuration.
            //
            PatchContext->ColorMap0 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            PatchContext->ColorMap1 = (PVIDEOCOLORMAPOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
            //VideoObject = VideoObject->VideoOutput->Destination;
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_SCALER)
        {
            //
            // Add the scaler to the patch configuration.
            //
            PatchContext->VideoScaler = (PVIDEOSCALEROBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else if (VideoObject->Base.Class->Type == NV_VIDEO_COLOR_KEY)
        {
            //
            // Add the color key to the patch configuration.
            //
            PatchContext->VideoColorKey = (PVIDEOCOLORKEYOBJECT)VideoObject;
            if (!VideoObject->VideoOutput)
                return (RM_ERR_INCOMPLETE_PATCH);
        }
        else
            return (RM_ERR_INVALID_PATCH);

        //
        // Follow patchcord to next video object.
        //
        VideoPatchcord = VideoObject->VideoOutput;
        if (VideoPatchcord && VideoPatchcord->FanOut)
        {
            DBG_VAL_PTR(VideoPatchcord);
            if (VideoPatchcord->FanOut > 1)
                return (RM_ERR_PATCH_TOO_COMPLEX);
            //
            // Search for the first destination.
            //    
            for (i = 0; !(VideoObject = VideoPatchcord->Destination[i]); i++)
			    ;
#if DEBUG
            if (!VideoObject)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid patchcord in VideoPatchcordValidation!\n\r");
                DBG_BREAKPOINT();
                return (RM_ERROR);
            }
#endif // DEBUG
        }
        else
            return (RM_ERR_INCOMPLETE_PATCH);

    }
    return (VideoObject ? RM_OK : RM_ERR_INCOMPLETE_PATCH);
}


//---------------------------------------------------------------------------
//
//  Invalidate graphics patchcords.
//
//---------------------------------------------------------------------------

RM_STATUS grInvalidateVideoPatchcord
(
    PVIDEOPATCHCORD VideoPatchcord
)
{
    U032            i;
    
    //
    // Find input of patchcord.
    //
    if (!VideoPatchcord || !VideoPatchcord->Source)
        return (RM_OK);
    DBG_VAL_PTR(VideoPatchcord);
    DBG_VAL_PTR(VideoPatchcord->Source);
    switch (VideoPatchcord->Source->Base.Class->Type)
    {
        case NV_VIDEO_COLORMAP:
            grInvalidateVideoPatchcord(((PVIDEOCOLORMAPOBJECT)VideoPatchcord->Source)->VideoInput);
            break;
        case NV_VIDEO_SINK:
            for (i = 0; i < MAX_GRPATCH_INPUT; i++)
                grInvalidateVideoPatchcord(((PVIDEOSINKOBJECT)VideoPatchcord->Source)->VideoInput[i]);
            break;
#ifdef DEBUG
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Invalid object type for InvalidateVideoPatchcord.\n\r");
            DBG_BREAKPOINT();
#endif
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Validate object context.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grmdnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: grmdnv20.c                                                        *
*   The graphics chip dependent method routines are kept here.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// Externs.
//
extern RM_STATUS nvHalGrGetState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrPutState_NV20(PHALHWINFO, PGREXCEPTIONDATA, U032);
extern RM_STATUS nvHalGrSetEyeDirection_NV20(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV10_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass056GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass056SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

static HALGRMETHOD Nv10CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass056GetState,             0x010c, 0x010f},
    {_nvHalClass056SetEyeDirection,      0x072c, 0x0737},
};

//
// NV15_CELSIUS / NV11_CELSIUS methods handled in the HAL.
//
static RM_STATUS _nvHalClass096GetState(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass096SetEyeDirection(PHALHWINFO, PGREXCEPTIONDATA);

static HALGRMETHOD Nv15CelsiusPrimitiveHalMethods[] =
{
    {_nvHalClass096GetState,             0x010c, 0x010f},
    {_nvHalClass096SetEyeDirection,      0x072c, 0x0737},
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV20[] =
{
    { NV10_CELSIUS_PRIMITIVE,           Nv10CelsiusPrimitiveHalMethods,
                                        sizeof (Nv10CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    { NV15_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    { NV11_CELSIUS_PRIMITIVE,           Nv15CelsiusPrimitiveHalMethods,
                                        sizeof (Nv15CelsiusPrimitiveHalMethods) / sizeof(HALGRMETHOD)}
};
#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV20) / sizeof (HALGRMETHODS)

RM_STATUS
nvHalGrClassSoftwareMethod_NV20(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 i, j;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV20[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV20[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV20[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV20[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV20[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}

static RM_STATUS
_nvHalClass056GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056GetState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV056_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV056_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV056_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass096GetState(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS retval;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass056PutState\r\n");

    switch (pGrExceptionData->Data)
    {
        case NV096_GET_STATE_GETSTATE_ALL_STATE:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_PUTSTATE_ALL_STATE:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, TRUE);
            break;

        case NV096_GET_STATE_GETSTATE_SNAPSHOT_PRIM_ASSM:
            retval = nvHalGrGetState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        case NV096_GET_STATE_GETSTATE_RELOAD_PRIM_ASSM:
            retval = nvHalGrPutState_NV20(pHalHwInfo, pGrExceptionData, FALSE);
            break;

        default:
            retval = RM_ERR_BAD_ARGUMENT;
    }    

    return retval;
}

static RM_STATUS
_nvHalClass056SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV20(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}

static RM_STATUS
_nvHalClass096SetEyeDirection(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    nvHalGrSetEyeDirection_NV20(pHalHwInfo, pGrExceptionData);
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv20\grnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRNV20.C                                                          *
*   The graphics chip dependent routines are kept here.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include <heap.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrControl_NV20(VOID *);
RM_STATUS nvHalGrAlloc_NV20(VOID *);
RM_STATUS nvHalGrFree_NV20(VOID *);
RM_STATUS nvHalGrGetExceptionData_NV20(VOID *);
RM_STATUS nvHalGrService_NV20(VOID *);
RM_STATUS nvHalGrGetNotifyData_NV20(VOID *);
RM_STATUS nvHalGrSetObjectContext_NV20(VOID *);

// statics
static RM_STATUS _nvHalGrInitObjectContext_NV20(PHALHWINFO, U032, U032);
static RM_STATUS _nvHalGrInit3d_NV20(PHALHWINFO, U032);
static RM_STATUS _nvHalGrDestroy3d_NV20(PHALHWINFO, U032);

// externs
extern RM_STATUS nvHalGrClassSoftwareMethod_NV20(PHALHWINFO, PGREXCEPTIONDATA);

extern RM_STATUS nvHalGrLoadChannelContext_NV20(PHALHWINFO, U032);
extern RM_STATUS nvHalGrUnloadChannelContext_NV20(PHALHWINFO, U032);

//
// Macro for mirroring PFB reg values into texture cache via RDI.
//
#define RDI_REG_WR32(select, addr, data)    \
    {                                       \
        REG_WR32(NV_PGRAPH_RDI_INDEX,       \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    \
                 DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     \
        REG_WR32(NV_PGRAPH_RDI_DATA, data);                         \
    }

//
// nvHalGrControl
//
RM_STATUS
nvHalGrControl_NV20(VOID *arg)
{
    PGRCONTROLARG_000 pGrControlArg = (PGRCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrControlArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrControl_NV20\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pGrControlArg->id != GR_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrControlArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    
    switch (pGrControlArg->cmd)
    {
        case GR_CONTROL_INIT:
            //
            // Initialize graphics debug values.
            //

            // all DEBUG0 bits are RESET bits in NV20
            pGrHalPvtInfo->Debug0 = 0x0;

            pGrHalPvtInfo->Debug1 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_PTE,          _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_AUTO,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _DRAWDIR_Y,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _INSTANCE,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_1, _CTX,              _INIT);

            pGrHalPvtInfo->Debug2 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_2D, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_BLT, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_CELS, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCH_CHECK_3D, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_CHECK,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_CHECK,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_MEMSIZE_CHECK,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWIZZLE_CHECK,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILEVIOL,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_ENDIAN_CHECK,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_LIMIT_INT,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_OVRFLW_INT,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PASS_VIOL,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_PITCHWRAP,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_3D,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_DITHER_2D,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SWALLOW_REQS,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_SBFILTER,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FASTCLEAR,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_FLUSH_HOLDOFF,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_2, _PREROP_TILEBIT_UPDATE, _INIT);

            pGrHalPvtInfo->Debug3 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_3, _FLUSHING,              _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _HW_CONTEXT_SWITCH,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FD_CHECK,              _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_STRTCH,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_SHADOW_DATA,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _CHECK_64BYTE_ALIGN,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_STEP,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _RDI_IDLE_WAIT,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _IDLE_FILTER,           _ENABLED) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SYNCHRONIZE,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _OBJECT_RELOAD,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _PM_TRIGGER,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _ALTARCH,               _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _SINGLE_CYCLE_LOAD,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _BILINEAR_3D,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _VOLATILE_RESET,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK_FAIL,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FORMAT_CHECK,          _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _DMA_CHECK,             _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _STATE_CHECK,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _KELVIN_HWFLIP,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_3D_RESTORE,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _STATE3D_CHECK,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _XFMODE_COALESCE,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _CTX_METHODS,           _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _OP_METHODS,            _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_3, _IGNORE_PATCHVALID,     _INIT);

            // all DEBUG_[4,5] bits are SPARES currently
            pGrHalPvtInfo->Debug4 = 0x0;
            pGrHalPvtInfo->Debug5 =
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_REQ_FULL_CVG,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_PUNT_FB_BUSY,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_PUNT_S_ON_Z,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_RETURN_COMP,     _INIT);

            pGrHalPvtInfo->Debug6 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_3D,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_DITHER_2D,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_EARLY_ZABORT,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_PASS_ROPFLUSH,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_DRAIN,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_HIGHWATER,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CBUF_HIGHWATER2,   _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_COALESCE_3D,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_COALESCE_2D,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FIXED_ADRS,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FAST_KEEP_DST,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_FORCE_CREAD,       _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ALLOW_3D_SKIP_READ, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCMP_ALWAYS_READ,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCOMPRESS_EN,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_BURST_CREADS,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_BURST_CWRITES,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_AUTO_INIT,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_HASH_TEST1,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_INTERLOCK,         _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZREAD,             _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCULL_DATA,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_CROP_SWALLOW,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_6, _SPARE_BIT31,           _INIT);

            pGrHalPvtInfo->Debug7 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_INIT_ZRD_TMSTAMP,  _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZCULL_NO_STALE,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZROP_INTERLOCK,    _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_VISIBLE, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_PURGE_PER_PKT, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_NO_16BYTE_WR, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_FSTCLR_EXPAND, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_FORCE_NO_RMW_DISABLE, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_INHIBIT_COMPRESS, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_CMPR_FULL_BE_ONLY, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_ALWAYS_WR_STENCIL, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_INHIBIT_SKIP_WR_EQ, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_SELECTPM,      _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA1,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA2,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA3,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_CROP_SELECTPM,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZWR_EXTRA4,        _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_ZRD_HASH_TAGS,     _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_7, _ROP_CROP_BLIT_HASH,    _INIT);

            pGrHalPvtInfo->Debug8 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_8, _SHADER_FIFO_WATERMARK, _INIT) |
                DRF_DEF(_PGRAPH, _DEBUG_8, _COMBINER_NEG_TEXTURE,  _INIT);

            pGrHalPvtInfo->Debug9 = (U032)
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH0_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH1_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH2_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_PATCH3_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _END_PATCH_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_END_SWATCH_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_END_CURVE_CHECK, _DISABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _CURVE_COEFF_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS0_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS1_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _BEGIN_TRANS2_CHECK, _ENABLE) | 
                DRF_DEF(_PGRAPH, _DEBUG_9, _END_TRANSITION_CHECK, _ENABLE);

            //
            // Have to use hybrid context switch mode to work around
            // FD bug...we'll do this here so it's easier to control
            // on future chips where we'll hopefully be able to
            // employ full hw context switching.
            //
            pGrHalPvtInfo->Debug3 &= ~(U032)DRF_DEF(_PGRAPH, _DEBUG_3, _HW_CONTEXT_SWITCH, _ENABLED);

            //
            // Separate color and Z reads on SDR memory configurations
            // (i.e. same dram bank).
            //
            if (REG_RD_DRF(_PBUS, _FBIO_RAM, _TYPE) == NV_PBUS_FBIO_RAM_TYPE_SDR)
                pGrHalPvtInfo->Debug6 |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS, _ENABLED);
            else
                pGrHalPvtInfo->Debug6 |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_SEP_ZC_READS, _DISABLED);

            //
            // Initialize graphics channel context table register.
            //
            pGrHalPvtInfo->CtxTableBase = pHalHwInfo->grInstMem;
            REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_TABLE, _INST, pHalHwInfo->grInstMem);
            for (i = 0; i < NUM_FIFOS_NV20; i++)
                INST_WR32(pGrHalPvtInfo->CtxTableBase, i*4, 0);

            //
            // Init channel id to invalid.
            //
            pGrHalPvtInfo->currentChID = NUM_FIFOS_NV20;

            //
            // Per Luke Chang...
            //
            // Fix 2D im_class (scaled class) zpipe overflow
            // bug by shortening the rbuffer in tcache by 9 entries
            //
            RDI_REG_WR32(NV_IGRAPH_TC_TPA_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            RDI_REG_WR32(NV_IGRAPH_TC_TPB_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            break;
        case GR_CONTROL_LOAD:
        {
            U032 misc;

            //
            // To reset graphics on nv20, we can't use
            // DEBUG_0, because the _CACHE_STATE bit will
            // cause a hang in the tcache.
            //
            // Instead, we use the PMC register.
            //
            FLD_WR_DRF_DEF(_PMC, _ENABLE, _PGRAPH, _DISABLED);
            FLD_WR_DRF_DEF(_PMC, _ENABLE, _PGRAPH, _ENABLED);

            //
            // Restore DEBUG registers.
            //
            REG_WR32(NV_PGRAPH_DEBUG_0, pGrHalPvtInfo->Debug0);
            REG_WR32(NV_PGRAPH_DEBUG_1, pGrHalPvtInfo->Debug1);
            REG_WR32(NV_PGRAPH_DEBUG_2, pGrHalPvtInfo->Debug2);
            REG_WR32(NV_PGRAPH_DEBUG_3, pGrHalPvtInfo->Debug3);
            REG_WR32(NV_PGRAPH_DEBUG_4, pGrHalPvtInfo->Debug4);
            REG_WR32(NV_PGRAPH_DEBUG_5, pGrHalPvtInfo->Debug5);
            REG_WR32(NV_PGRAPH_DEBUG_6, pGrHalPvtInfo->Debug6);
            REG_WR32(NV_PGRAPH_DEBUG_7, pGrHalPvtInfo->Debug7);
            REG_WR32(NV_PGRAPH_DEBUG_8, pGrHalPvtInfo->Debug8);
            REG_WR32(NV_PGRAPH_DEBUG_9, pGrHalPvtInfo->Debug9);

            //
            // Per Luke Chang...
            //
            // Fix 2D im_class (scaled class) zpipe overflow
            // bug by shortening the rbuffer in tcache by 9 entries
            //
            RDI_REG_WR32(NV_IGRAPH_TC_TPA_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);
            RDI_REG_WR32(NV_IGRAPH_TC_TPB_INDEX_SELECT,
                         NV_IGRAPH_TC_TPA_RBFRDEPTH_INDEX_ADDRESS,
                         0x30);

            //
            // Restore context buffer base address.
            //
            REG_WR_DRF_NUM(_PGRAPH, _CHANNEL_CTX_TABLE, _INST, pHalHwInfo->grInstMem);

            // 
            // PGRAPH_TILE values will be reset after a PGRAPH_DEBUG_0_STATE_RESET.
            // Unfortunately, it may have had values we wanted (e.g. from stateFb),
            // so after a DEBUG_0_STATE_RESET, restore the PGRAPH values from PFB.
            //
            HAL_GR_IDLE(pGrControlArg->pHalHwInfo);

            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++)
            {
                misc = REG_RD32(NV_PFB_TLIMIT(i));
                REG_WR32(NV_PGRAPH_TLIMIT(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TLIMIT_ADDRESS(i),
                             misc);
                
                misc = REG_RD32(NV_PFB_TSIZE(i));
                REG_WR32(NV_PGRAPH_TSIZE(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TPITCH_ADDRESS(i),
                             misc);

                misc = REG_RD32(NV_PFB_TILE(i));
                REG_WR32(NV_PGRAPH_TILE(i), REG_RD32(NV_PFB_TILE(i)));
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_TILE_ADDRESS(i),
                             misc);

#ifdef DEBUG
                // these registers need to agree
                if (REG_RD32(NV_PFB_TILE(i)) != REG_RD32(NV_PGRAPH_TILE(i)))
                    DBG_BREAKPOINT();
                if (REG_RD32(NV_PFB_TLIMIT(i)) != REG_RD32(NV_PGRAPH_TLIMIT(i)))
                    DBG_BREAKPOINT();
                if (REG_RD32(NV_PFB_TSIZE(i)) != REG_RD32(NV_PGRAPH_TSIZE(i)))
                    DBG_BREAKPOINT();
#endif
            }

            //
            // Restore zcompression table from fb engine.
            //
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++)
            {
                misc = REG_RD32(NV_PFB_ZCOMP(i));
                REG_WR32(NV_PGRAPH_ZCOMP(i), misc);
                RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                             NV_IGRAPH_TC_MINTFCDEBUG_ZCOMP_ADDRESS(i),
                             misc);
            }
            misc = REG_RD32(NV_PFB_ZCOMP_OFFSET);
            REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_ZOFFSET_ADDRESS,
                         misc);

            //
            // Restore framebuffer config registers from fb engine.
            //
            misc = REG_RD32(NV_PFB_CFG0);
            REG_WR32(NV_PGRAPH_FBCFG0, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_CFG0_ADDRESS,
                         misc);

            misc = REG_RD32(NV_PFB_CFG1);
            REG_WR32(NV_PGRAPH_FBCFG1, misc);
            RDI_REG_WR32(NV_IGRAPH_TC_MINTFCDEBUG_SELECT,
                         NV_IGRAPH_TC_MINTFCDEBUG_CFG1_ADDRESS,
                         misc);

            REG_WR32(NV_PGRAPH_CTX_SWITCH1,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH2,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH3,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH4,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

            //
            // Reload current graphics context.
            //
            (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, pGrHalPvtInfo->currentChID);
            break;
        }
        case GR_CONTROL_UNLOAD:
        {
            //
            // Force an unload of the current channel.
            //
            (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, NUM_FIFOS_NV20);
            break;
        }
        case GR_CONTROL_DESTROY:
        case GR_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalGrAlloc
//
RM_STATUS
nvHalGrAlloc_NV20(VOID *arg)
{
    PGRALLOCARG_000 pGrAllocArg = (PGRALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrAllocArg->pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrAlloc_NV20\r\n");

    //
    // Verify interface revision.
    //
    if (pGrAllocArg->id != GR_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrAllocArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // If we've got a 3d object, keep note of it.
    //
    if ((pGrAllocArg->classNum == NV10_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV15_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV11_CELSIUS_PRIMITIVE) ||
        (pGrAllocArg->classNum == NV20_KELVIN_PRIMITIVE))
    {
        //
        // Check that a current 3D object hasn't already been created.
        //
        if (pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] != 0) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: 3d state in use by instance ", pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid]);
            return (RM_ERR_ILLEGAL_OBJECT);
        }
        // ASSERT(pGrChannel->CurrentObject3d == 0)

        pGrHalPvtInfo->currentObjects3d[pGrAllocArg->chid] = pGrAllocArg->instance;

        pGrHalInfo->has3dObject |= (0x1 << pGrAllocArg->chid);

        _nvHalGrInit3d_NV20(pHalHwInfo, pGrAllocArg->chid);
    }

    //
    // Initialize generic object context.
    //
    _nvHalGrInitObjectContext_NV20(pHalHwInfo, pGrAllocArg->instance, pGrAllocArg->classNum);

    return (RM_OK);
}

//
// nvHalGrFree
//
RM_STATUS
nvHalGrFree_NV20(VOID *arg)
{
    PGRFREEARG_000 pGrFreeArg = (PGRFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrFreeArg->id != GR_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrFreeArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Clear 3d current object pointer if necessary.
    //
    if (pGrFreeArg->instance == pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid])
    {
        // we could ASSERT that this is a 3d object here as well
        pGrHalPvtInfo->currentObjects3d[pGrFreeArg->chid] = 0;

        // clear the Celsius bit (either never had one or it was just freed)
        pGrHalInfo->has3dObject &= ~(0x1 << pGrFreeArg->chid);
    }

    //
    // Zero out the object context for good measure.
    //
    for (i = 0; i < 4; i++)
    {
        INST_WR32(pGrFreeArg->instance, i, 0);
    }

    return (RM_OK);
}

//
// nvHalGrGetExceptionData
//
// Retrieve graphics engine exception data.
//
RM_STATUS
nvHalGrGetExceptionData_NV20(VOID *arg)
{
    PGRGETEXCEPTIONDATAARG_000 pGrGetExceptionDataArg = (PGRGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    PGREXCEPTIONDATA pGrExceptionData;

    //
    // Verify interface revision.
    //
    if (pGrGetExceptionDataArg->id != GR_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    pGrExceptionData = pGrGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pGrExceptionData->Offset = REG_RD32(NV_PGRAPH_TRAPPED_ADDR);
    pGrExceptionData->ChID = DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _CHID, pGrExceptionData->Offset);
    pGrExceptionData->NotifyInstance = REG_RD_DRF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE);
    pGrExceptionData->classNum = REG_RD_DRF(_PGRAPH, _CTX_SWITCH1, _GRCLASS);
    pGrExceptionData->Data = REG_RD32(NV_PGRAPH_TRAPPED_DATA_LOW); 
    pGrExceptionData->Instance = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrExceptionData->Offset &= (DRF_MASK(NV_PGRAPH_TRAPPED_ADDR_MTHD) << DRF_SHIFT(NV_PGRAPH_TRAPPED_ADDR_MTHD));
    pGrExceptionData->Nsource = REG_RD32(NV_PGRAPH_NSOURCE);
    pGrExceptionData->MethodStatus = RM_OK;

    return (RM_OK);
}

//
// nvHalGrService
//
// Handle selected graphics object exceptions.
//
RM_STATUS
nvHalGrService_NV20(VOID *arg)
{
    PGRSERVICEARG_000 pGrServiceArg = (PGRSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrServiceArg->pHalHwInfo;
    PGRHALINFO_NV20 pGrHalPvtInfo;
    PGREXCEPTIONDATA pGrExceptionData;

    //
    // Verify interface revision.
    //
    if (pGrServiceArg->id != GR_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrServiceArg->pHalHwInfo;
    pGrExceptionData = pGrServiceArg->pExceptionData;
    pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;

    //
    // Make sure object is valid.
    //
    //if (pGrExceptionData->instance == 0)
    //    return (NV_HAL_ERROR_INVALID_STATE);

    //
    // Handle any exceptions...
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING))
    {
        //
        // Reset condition.
        //
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _RESET);

        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Graphics channel switch.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics context switch exception.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Previous graphics channel:",pGrHalPvtInfo->currentChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: New graphics channel:", pGrExceptionData->ChID);

        (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, pGrExceptionData->ChID);
    }

    //
    // Handle methods in software.
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING))
    {
        if (nvHalGrClassSoftwareMethod_NV20(pHalHwInfo, pGrExceptionData) == RM_OK)
        {
            // Reset condition.
            REG_WR_DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _RESET);
        }
    }

    if ((pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING)) ||
        (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _ERROR, _PENDING)))
    {
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {
            if (nvHalGrClassSoftwareMethod_NV20(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING))
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
                else
                    REG_WR_DRF_DEF(_PGRAPH, _INTR, _ERROR, _RESET);
            }
        }
    }

    return (RM_OK);
}

//
// nvHalGrNotifyData
//
// Fill in notify data (trigger status and action).
//
RM_STATUS
nvHalGrGetNotifyData_NV20(VOID *arg)
{
    PGRGETNOTIFYDATAARG_000 pGrGetNotifyDataArg = (PGRGETNOTIFYDATAARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    PGRNOTIFYDATA pGrNotifyData;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrGetNotifyData_NV20\r\n");

    //
    // Verify interface revision.
    //
    if (pGrGetNotifyDataArg->id != GR_GET_NOTIFY_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    pGrNotifyData = pGrGetNotifyDataArg->pGrNotifyData;

    if (REG_RD32(NV_PGRAPH_NOTIFY) &
        (DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _PENDING) |
         DRF_DEF(_PGRAPH, _NOTIFY, _STYLE, _WRITE_THEN_AWAKEN)))
    {
        pGrNotifyData->trigger = TRUE;
        pGrNotifyData->action =  REG_RD_DRF(_PGRAPH, _NOTIFY, _STYLE);
        // clear the notify condition
        FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);
    } else {
        pGrNotifyData->trigger = FALSE;
        pGrNotifyData->action = 0;
    }

    return (RM_OK);
}

//
// nvHalGrSetObjectContext
//
// Update various graphics object context bits.
// On NV20, these bits are managed by hardware so this
// routine does some error checking and returns.
//
RM_STATUS
nvHalGrSetObjectContext_NV20(VOID *arg)
{
    PGRSETOBJECTCONTEXTARG_000 pGrSetObjectContextArg = (PGRSETOBJECTCONTEXTARG_000)arg;
    PHALHWINFO pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    U032 context, instance;
    U032 fifo;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrSetObjectContext_NV20\r\n");

    //
    // Verify interface revision.
    //
    if (pGrSetObjectContextArg->id != GR_SET_OBJECT_CONTEXT_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify chid.
    //
    if (pGrSetObjectContextArg->chid > NUM_FIFOS_NV20)
        return (RM_ERR_BAD_ARGUMENT);

    //
    // Verify instance (what else can we do here without
    // keeping track of all objects that pass through the
    // nvHalGrAlloc interface down in the HAL?).
    //
    if (pGrSetObjectContextArg->instance == 0)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    instance = pGrSetObjectContextArg->instance;
    
    //
    // Fetch current context.
    //
    context = INST_RD32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0));

    //
    // Make necessary adjustments.
    //
    context &= pGrSetObjectContextArg->andMask;
    context |= pGrSetObjectContextArg->orMask;

    //
    // Write it back out                   
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), context);
        
    //
    // Now we need to update the hardware context if appropriate.
    //
    if (pGrSetObjectContextArg->chid == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
            
        //
        // Walk to subchannels and see if we find a match; update when we do
        //
        for (i = 0 ; i < 8 ; i++)
        {            
            if (REG_RD32(NV_PGRAPH_CTX_CACHE4(i)) == instance)
            {   
                //
                // Get the current settings
                //
                context = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));

                //
                // Make necessary adjustments.
                //
                context &= pGrSetObjectContextArg->andMask;
                context |= pGrSetObjectContextArg->orMask;

                //
                // Write it back out                   
                //
                REG_WR32(NV_PGRAPH_CTX_CACHE1(i), context);
            }
        }                                    
                             
        //
        // See if the currently active subchannel also needs updating
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_SWITCH4, _USER_INSTANCE) == instance)
        {   
            //
            // Get the current settings
            //
            context = REG_RD32(NV_PGRAPH_CTX_SWITCH1);

            //
            // Make necessary adjustments.
            //
            context &= pGrSetObjectContextArg->andMask;
            context |= pGrSetObjectContextArg->orMask;

            //
            // Write it back out                   
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1, context);
        }
            
        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
        
    }    
    return (RM_OK);
}

static RM_STATUS
_nvHalGrInitObjectContext_NV20(
    PHALHWINFO  pHalHwInfo,
    U032        instance,
    U032        classNum
)
{
    U032 ctx1, ctx2, ctx3;

    // default _CTX_SWITCH1 value
    ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, classNum)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

    // turn on big endian for this class if supported and we're in big endian mode
    if (pHalHwInfo->pMcHalInfo->EndianControl & MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN)
        ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _ENDIAN_MODE, _BIG);

    // default _CTX_SWITCH2 value
    ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

    // default _CTX_SWITCH3 value
    ctx3 = DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_0, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_1, _INVALID);

    switch (classNum)
    {
        case NV01_CONTEXT_BETA:
        case NV01_CONTEXT_CLIP_RECTANGLE:
        case NV01_IMAGE_BLIT:
        case NV03_CONTEXT_ROP:
        case NV04_CONTEXT_SURFACES_2D:
        case NV03_DX3_TEXTURED_TRIANGLE:
        case NV04_CONTEXT_SURFACE_SWIZZLED:
        case NV04_CONTEXT_SURFACES_3D:
        case NV03_CONTEXT_SURFACE_2D_DESTINATION:
        case NV03_CONTEXT_SURFACE_2D_SOURCE:
        case NV03_CONTEXT_SURFACE_3D_COLOR:
        case NV03_CONTEXT_SURFACE_3D_DEPTH:
        case NV04_IMAGE_BLIT:
        case NV04_CONTEXT_BETA:
        case NV10_CONTEXT_SURFACES_2D:
        case NV10_CONTEXT_SURFACES_3D:
        case NV15_CONTEXT_SURFACE_SWIZZLED:
        case NV15_IMAGE_BLIT:
            // defaults are fine
            break;
        case NV20_IMAGE_BLIT:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            break;
        case NV01_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_CONTEXT_PATTERN:
        case NV04_CONTEXT_PATTERN:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_RENDER_SOLID_LIN:
        case NV01_RENDER_SOLID_TRIANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_IMAGE_FROM_CPU:
        case NV03_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV1_NULL:
            //
            // The NULL object is really a pseudo-dma object, so it needs a valid
            // limit value and should also have the PAGE_TABLE_PRESENT bit set.
            //
            ctx1 |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
            ctx2 = 0xffffffff;
            //INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0xFFFFFFFF);
            //FLD_WR_ISF_DEF(instance, _DMA, _PAGE_TABLE, _PRESENT);
            break;
        case NV03_SCALED_IMAGE_FROM_MEMORY:
        case NV04_SCALED_IMAGE_FROM_MEMORY:
        case NV10_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_SCALED_IMAGE_FROM_MEMORY:
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DVD_SUBPICTURE:
        case NV10_DVD_SUBPICTURE:
            //
            // DVD class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV03_MEMORY_TO_MEMORY_FORMAT:
            // Note that this object is always considered patch valid
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV03_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_RENDER_SOLID_LIN:
        case NV04_RENDER_SOLID_TRIANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_INDEXED_IMAGE_FROM_CPU:
        case NV04_IMAGE_FROM_CPU:
        case NV04_STRETCHED_IMAGE_FROM_CPU:
        case NV10_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_INDEXED_IMAGE_FROM_CPU:
        case NV05_IMAGE_FROM_CPU:
        case NV05_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV11_CELSIUS_PRIMITIVE:
            //
            // The above DRF_NUM macro on GRCLASS has already masked this class
            // number to an 8bit value, we just need to set the PERFORMANCE bit.
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CLASS_TYPE, _PERFORMANCE);
        case NV10_CELSIUS_PRIMITIVE:
        case NV15_CELSIUS_PRIMITIVE:
        case NV20_KELVIN_PRIMITIVE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV10_TEXTURE_FROM_CPU:
            // TEXTURE_FROM_CPU is similar to the IMAGE_FROM_CPU classes, but with
            // only a subset of the methods, so we'll need to make sure things are
            // initialized in a way that makes sense for this class.
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, _TRUNCATE);    
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

            break;
        default:
            // assume defaults are cool
            break;
    }


    //
    // Write out the values.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance data for classNum ", classNum);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      instance offset ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx1 ", ctx1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx2 ", ctx2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx3 ", ctx3);

    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), ctx1);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), ctx2);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), ctx3);
    //
    // Be sure to clear this dword clear to keep the graphics method
    // trapped disabled.
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_3), 0);

    return (RM_OK);
}

#if 0
//
// Given a pipe address and ChID return the corresponding pipe context save
// area in the channel context in instance memory.
//
static U032 *
grInitPipeContextAddr(
    PGRAPHICSCHANNEL_NV20 pGrChan,
    U032 base
)
{
    U032 index;

    if (base >= XL_XFREG_BASE && base < (XL_XFREG_BASE + (XL_XFREG_COUNT*4)))
    {
        index = (base - XL_XFREG_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlXfReg[index];
    }
    if (base >= XL_XFCTX_BASE && base < (XL_XFCTX_BASE + (XL_XFCTX_COUNT*4)))
    {
        index = (base - XL_XFCTX_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlXfCtx[index];
    }
    if (base >= XL_LTCTX_BASE && base < (XL_LTCTX_BASE + (XL_LTCTX_COUNT*4)))
    {
        index = (base - XL_LTCTX_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlLtCtx[index];
    }
    if (base >= XL_LTC0_BASE && base < (XL_LTC0_BASE + (XL_LTC0_COUNT*4)))
    {
        index = (base - XL_LTC0_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlLtc[index];
    }
    if (base >= XL_LTC1_BASE && base < (XL_LTC1_BASE + (XL_LTC1_COUNT*4)))
    {
        index = (base - XL_LTC1_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlLtc[index + XL_LTC0_COUNT];
    }
    if (base >= XL_LTC2_BASE && base < (XL_LTC2_BASE + (XL_LTC2_COUNT*4)))
    {
        index = (base - XL_LTC2_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlLtc[index + XL_LTC0_COUNT + XL_LTC1_COUNT];
    }
    if (base >= XL_LTC3_BASE && base < (XL_LTC3_BASE + (XL_LTC3_COUNT*4)))
    {
        index = (base - XL_LTC3_BASE) / sizeof (U032);
        return &pGrChan->grCtxPipe.XlLtc[index + XL_LTC0_COUNT + XL_LTC1_COUNT + XL_LTC2_COUNT];
    }

    return NULL;        // error
}

#define grInitPipeContextData(data)     *pipectx++ = data;
#endif

//
// Initialize 3d state in the specified channel.
// Note that both Celsius/Kelvin classes are initialized in the same
// manner.
//
// If we transition to supporting multiple 3d objects per channel,
// then this will need to be reworked.  We'll have to allocate the
// 3d context buffers with the 3d object and not with the channel.
//
// XXXscottl - Should we take steps to ensure we don't context switch
//             to this channel while we're in here?
//             Also, what if the specified channel is the current chid?
//
// See /hw/nv20/diag/common/commonIniLib.c for more info.
//
static RM_STATUS
_nvHalGrInit3d_NV20(
    PHALHWINFO  pHalHwInfo,
    U032        ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 grCtxBuffer;
    U032 offset;
    U032 ctxUser;
    U032 cheopsCtxOffset, zoserCtxOffset;
    U032 zoserC0Offset, zoserC1Offset;
    U032 i, dmaPush;

    grCtxBuffer = pGrHalPvtInfo->CtxTable[ChID];

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: initializing 3d state: chid ", ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      buffer offset ", grCtxBuffer);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      buffer size ", sizeof (GRAPHICSCHANNEL_NV20));
   
    //
    // If this is the current channel, then we need to flush the
    // current context out to instance memory where the following
    // initialization will occur.
    //
    if (pGrHalPvtInfo->currentChID == ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: unload current chid ", ChID);

        // Empty FIFO and runout.
        while ((REG_RD_DRF(_PFIFO, _CACHE1_STATUS, _LOW_MARK) != NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY) ||
               (REG_RD_DRF(_PFIFO, _RUNOUT_STATUS, _LOW_MARK) != NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY) ||
               (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY))
        {
            // Make sure we process any fifo interrupts
            HALRMSERVICEINTR(pHalHwInfo, FIFO_ENGINE_TAG);

            // Check if GE needs servicing.
            if (REG_RD32(NV_PGRAPH_INTR))
                HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);

            // Check if vblank needs servicing.
            if (REG_RD32(NV_PMC_INTR_0) & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
                HALRMSERVICEINTR(pHalHwInfo, DAC_ENGINE_TAG);
        }

        // Disable the dma pusher
        dmaPush = REG_RD32(NV_PFIFO_CACHE1_DMA_PUSH);
        REG_WR_DRF_DEF(_PFIFO, _CACHE1_DMA_PUSH, _ACCESS, _DISABLED);

        // Wait until the DMA pusher is idle
        while (REG_RD_DRF(_PFIFO, _CACHE1_DMA_PUSH, _STATE) == NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY)
            ;
    
        // Now, wait until graphics is idle
        HAL_GR_IDLE(pHalHwInfo);

        (void) nvHalGrUnloadChannelContext_NV20(pHalHwInfo, ChID);
    }

    //
    // Initialize 3d channel state.
    // Start by setting 3D present bit in CTX_USER
    // (offset 0 in ctx buffer).
    //
    ctxUser = INST_RD32(grCtxBuffer, 0);
    ctxUser |= DRF_DEF(_PGRAPH, _CTX_USER, _CHANNEL_3D, _TRUE);
    INST_WR32(grCtxBuffer, 0, ctxUser);
    
    // Offset starts after state common to 2d and 3d.
    offset = sizeof (GRCTXCMN_NV20)/4;

    INST_WR32(grCtxBuffer, offset++<<2, 0xffff0000);   //Antialiasing
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Blend
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BlendColor
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BorderColor0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BorderColor1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BorderColor2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BorderColor3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat00_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat00_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat00_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat01_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat01_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat01_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat10_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat10_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat10_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat11_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat11_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpMat11_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpOffset1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpOffset2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpOffset3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpScale1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpScale2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BumpScale3
    INST_WR32(grCtxBuffer, offset++<<2, 0x0fff0000);   //ClearRectX
    INST_WR32(grCtxBuffer, offset++<<2, 0x0fff0000);   //ClearRectY
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ColorClearValue
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ColorKeyColor0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ColorKeyColor1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ColorKeyColor2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ColorKeyColor3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor0_7
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineFactor1_7
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaI7
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineAlphaO7
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorI7
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO4
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO5
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO6
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineColorO7
    INST_WR32(grCtxBuffer, offset++<<2, 0x101);        //CombineCtl
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineSpecFog0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CombineSpecFog1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Control0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Control1
    INST_WR32(grCtxBuffer, offset++<<2, 0x111);        //Control2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Control3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FogColor
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FogParam0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FogParam1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //PointSize
    INST_WR32(grCtxBuffer, offset++<<2, 0x44400000);   //SetupRaster
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ShaderClipMode
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ShaderCtl
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ShaderProg
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SemaphoreOffset
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ShadowCtl
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ShadowZslopeThreshold
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SpecFogFactor0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SpecFogFactor1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SurfaceClipX
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SurfaceClipY
    INST_WR32(grCtxBuffer, offset++<<2, 0x30303);      //TexAddress0
    INST_WR32(grCtxBuffer, offset++<<2, 0x30303);      //TexAddress1
    INST_WR32(grCtxBuffer, offset++<<2, 0x30303);      //TexAddress2
    INST_WR32(grCtxBuffer, offset++<<2, 0x30303);      //TexAddress3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl0_0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl0_1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl0_2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl0_3
    INST_WR32(grCtxBuffer, offset++<<2, 0x80000);      //TexControl1_0
    INST_WR32(grCtxBuffer, offset++<<2, 0x80000);      //TexControl1_1
    INST_WR32(grCtxBuffer, offset++<<2, 0x80000);      //TexControl1_2
    INST_WR32(grCtxBuffer, offset++<<2, 0x80000);      //TexControl1_3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl2_0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexControl2_1
    INST_WR32(grCtxBuffer, offset++<<2, 0x01012000);   //TexFilter0
    INST_WR32(grCtxBuffer, offset++<<2, 0x01012000);   //TexFilter1
    INST_WR32(grCtxBuffer, offset++<<2, 0x01012000);   //TexFilter2
    INST_WR32(grCtxBuffer, offset++<<2, 0x01012000);   //TexFilter3
    INST_WR32(grCtxBuffer, offset++<<2, 0x105b8);      //TexFormat0
    INST_WR32(grCtxBuffer, offset++<<2, 0x105b8);      //TexFormat1
    INST_WR32(grCtxBuffer, offset++<<2, 0x105b8);      //TexFormat2
    INST_WR32(grCtxBuffer, offset++<<2, 0x105b8);      //TexFormat3
    INST_WR32(grCtxBuffer, offset++<<2, 0x00080008);   //TexImageRect0
    INST_WR32(grCtxBuffer, offset++<<2, 0x00080008);   //TexImageRect1
    INST_WR32(grCtxBuffer, offset++<<2, 0x00080008);   //TexImageRect2
    INST_WR32(grCtxBuffer, offset++<<2, 0x00080008);   //TexImageRect3

    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexOffset0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexOffset1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexOffset2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexOffset3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexPalette0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexPalette1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexPalette2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //TexPalette3

    for (i = 0; i < 8; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0x07ff0000);    //WindowClipX

    for (i = 0; i < 8; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0x07ff0000);    //WindowClipY

    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ZCompressOcclude
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ZStencilClearValue
    INST_WR32(grCtxBuffer, offset++<<2, 0x4b7fffff);   //ZClipMax
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ZClipMin
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ContextDmaA
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ContextDmaB
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ContextDmaVtxA
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ContextDmaVtxB
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ZOffsetBias
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ZOffsetFactor
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Eyevec0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Eyevec1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Eyevec2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Shadow
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FdData
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FdSwatch
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //FdExtras
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Emission0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Emission1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Emission2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SceneAmb0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SceneAmb1
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //SceneAmb2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //ContextDmaGetState
    INST_WR32(grCtxBuffer, offset++<<2, 0x1);          //BeginPatch0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BeginPatch1
    INST_WR32(grCtxBuffer, offset++<<2, 0x4000);       //BeginPatch2
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BeginPatch3
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BeginCurve
    INST_WR32(grCtxBuffer, offset++<<2, 0x1);          //BeginTrans0
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //BeginTrans1
    INST_WR32(grCtxBuffer, offset++<<2, 0x00040000);   //Csv0_D
    INST_WR32(grCtxBuffer, offset++<<2, 0x00010000);   //Csv0_C
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Csv1_B
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //Csv1_A
    INST_WR32(grCtxBuffer, offset++<<2, 0);            //CheopsOffset

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      pipe offset ", offset);

    for (i = 0; i < IDX_FMT_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //IDX_FMT
    for (i = 0; i < CAS0_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //CAS0
    for (i = 0; i < CAS1_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //CAS1
    for (i = 0; i < CAS2_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //CAS2
    for (i = 0; i < ASSM_STATE_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //ASSM_STATE
    for (i = 0; i < IDX_CACHE0_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //IDX_CACHE0
    for (i = 0; i < IDX_CACHE1_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //IDX_CACHE1
    for (i = 0; i < IDX_CACHE2_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //IDX_CACHE2
    for (i = 0; i < IDX_CACHE3_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //IDX_CACHE3
    for (i = 0; i < VTX_FILE0_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //VTX_FILE0
    for (i = 0; i < VTX_FILE1_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //VTX_FILE1
    for (i = 0; i < XL_P_COUNT; i+=4)
    {
        INST_WR32(grCtxBuffer, offset++<<2, 0x10700ff9); //XL_P
        INST_WR32(grCtxBuffer, offset++<<2, 0x0436086c);
        INST_WR32(grCtxBuffer, offset++<<2, 0x000c001b);
        INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    }
    cheopsCtxOffset = offset;
    for (i = 0; i < XL_XFCTX_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_XFCTX
    zoserCtxOffset = offset;
    for (i = 0; i < XL_LTCTX_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_LTCTX
    zoserC0Offset = offset;
    for (i = 0; i < XL_LTC0_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_LTC0
    zoserC1Offset = offset;
    for (i = 0; i < XL_LTC1_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_LTC1
    for (i = 0; i < XL_LTC2_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_LTC2
    for (i = 0; i < XL_LTC3_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_LTC3
    for (i = 0; i < XL_VAB_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //XL_VAB
    for (i = 0; i < CRSTR_STIPP_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //CRSTR_STIPP
    for (i = 0; i < FD_CTRL_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //FD_CTRL
    for (i = 0; i < ROP_REGS_COUNT; i++)
        INST_WR32(grCtxBuffer, offset++<<2, 0);         //ROP_REGS

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      end pipe offset ", offset);

    // CHEOP_CTX, eye pos
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_EYEP<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // CHEOP_CTX_CONST0
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_CONS0<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x40000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // CHEOP_CTX_CONST1
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_CONS1<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x40000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0xbf800000);

    // CHEOP_CTX_CONST2
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_CONS2<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0xbf800000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // CHEOP_CTX, fog plane
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_FOG<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // CHEOP_CTX_CONST3
    offset = cheopsCtxOffset + (NV_IGRAPH_XF_XFCTX_CONS3<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_CTX_ZERO
    offset = zoserCtxOffset + (NV_IGRAPH_XF_LTCTX_ZERO<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_EYE_DIR (22bit words) -- see Simon Moy about this
    offset = zoserCtxOffset + (NV_IGRAPH_XF_LTCTX_EYED<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000>>10);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_FRONT_AMBIENT1
    offset = zoserCtxOffset + (NV_IGRAPH_XF_LTCTX_FR_AMB<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_FRONT_AMBIENT2
    offset = zoserCtxOffset + (NV_IGRAPH_XF_LTCTX_CM_COL<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_EYE_DIR (22bit words) -- see Simon Moy about this
    offset = zoserCtxOffset + (NV_IGRAPH_XF_LTCTX_FOGLIN<<2);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x3f800000>>20);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);
    INST_WR32(grCtxBuffer, offset++<<2, 0x00000000);

    // ZOSER_C0 (22bit word) -- see Simon Moy about this
    offset = zoserC0Offset + (NV_IGRAPH_XF_LTC0_MONE);
    INST_WR32(grCtxBuffer, offset<<2, 0xbf800000>>10);

    // LIGHT0 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r0);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT1 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r1);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT2 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r2);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT3 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r3);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT4 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r4);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT5 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r5);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT6 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r6);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    // LIGHT7 range (22bit word) -- see Simon Moy about this
    offset = zoserC1Offset + (NV_IGRAPH_XF_LTC1_r7);
    INST_WR32(grCtxBuffer, offset<<2, 0x7149f2ca>>10);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      last offset ", offset);

#ifdef NOTYET
    //
    // Enable the texture cache performance counters.
    // Should this be on by default?
    //
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE_COUNTERS, _ENABLED);
#endif

    if (pGrHalPvtInfo->currentChID == ChID)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: reload current chid ", ChID);

        (void) nvHalGrLoadChannelContext_NV20(pHalHwInfo, ChID);

        // Restore the dma pusher state
        REG_WR32(NV_PFIFO_CACHE1_DMA_PUSH, dmaPush);
    }

    return (RM_OK);
}


//
// Destroy 3d state in specified channel.
//
static RM_STATUS
_nvHalGrDestroy3d_NV20
(
    PHALHWINFO  pHalHwInfo,
    U032        ChID
)
{
    PGRHALINFO_NV20 pGrHalPvtInfo = (PGRHALINFO_NV20)pHalHwInfo->pGrHalPvtInfo;
    U032 grCtxBuffer;
    U032 ctxUser, fifo;

    grCtxBuffer = pGrHalPvtInfo->CtxTable[ChID];

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: initializing 3d state: chid ", ChID);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      buffer offset ", grCtxBuffer);

    //
    // Clear 3d present bit in channel.
    //
    if (ChID == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);

        FLD_WR_DRF_DEF(_PGRAPH, _CTX_USER, _CHANNEL_3D, _FALSE);

        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
    }
    else
    {
        ctxUser = INST_RD32(grCtxBuffer, 0);
        ctxUser &= ~DRF_DEF(_PGRAPH, _CTX_USER, _CHANNEL_3D, _TRUE);
        INST_WR32(grCtxBuffer, 0, ctxUser);    
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv4\grmdnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRMDNV04.C                                                        *
*   The graphics chip dependent HAL GR method routines are kept here.       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// First level method handler.
//
RM_STATUS nvHalGrClassSoftwareMethod_NV04(PHALHWINFO, PGREXCEPTIONDATA);

//
// NV4_CONTEXT_SURFACES_ARGB_ZS methods handled in the HAL.
//
static RM_STATUS _nvHalClass053SetClipHorizontal(PHALHWINFO, PGREXCEPTIONDATA);
static RM_STATUS _nvHalClass053SetClipVertical(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv4ContextSurfacesArgbZsHalMethods[] =
{
    {_nvHalClass053SetClipHorizontal,           0x02f8, 0x02fb},
    {_nvHalClass053SetClipVertical,             0x02fc, 0x02ff},
};

//
// NV4_INDEXED_IMAGE_FROM_CPU methods handled in the HAL.
//
static RM_STATUS _nvHalClass060SetColorConversion(PHALHWINFO, PGREXCEPTIONDATA);

HALGRMETHOD Nv4IndexedImageFromCpuHalMethods[] =
{
    {_nvHalClass060SetColorConversion,           0x03e0, 0x03e3}
};

//
// HAL graphics method table.
//
HALGRMETHODS nvHalGrMethods_NV04[] =
{
    { NV4_CONTEXT_SURFACES_ARGB_ZS,     Nv4ContextSurfacesArgbZsHalMethods,
                                        sizeof (Nv4ContextSurfacesArgbZsHalMethods) / sizeof (HALGRMETHOD) },

    { NV4_INDEXED_IMAGE_FROM_CPU,       Nv4IndexedImageFromCpuHalMethods,
                                        sizeof (Nv4IndexedImageFromCpuHalMethods) / sizeof (HALGRMETHOD) },
};

#define NUM_HALGRMETHODS                sizeof (nvHalGrMethods_NV04) / sizeof(HALGRMETHODS)


RM_STATUS
nvHalGrClassSoftwareMethod_NV04(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    RM_STATUS status = RM_OK;
    U032 i, j;
    PHWREG nvAddr;

    nvAddr = pHalHwInfo->nvBaseAddr;
    for (i = 0; i < NUM_HALGRMETHODS; i++)
    {
        //
        // Find out if this class has any HAL methods.
        //
        if (nvHalGrMethods_NV04[i].classNum == pGrExceptionData->classNum)
        {
            //
            // See if this particular method is a HAL method.
            //
            for (j = 0; j < nvHalGrMethods_NV04[i].methodMax; j++)
            {
                if ((pGrExceptionData->Offset >= nvHalGrMethods_NV04[i].pMethods[j].Low) &&
                    (pGrExceptionData->Offset < nvHalGrMethods_NV04[i].pMethods[j].High))
                {
                    //
                    // Idle graphics.
                    //
                    GR_DONE();

                    //
                    // Route the method.
                    //
                    pGrExceptionData->MethodStatus = nvHalGrMethods_NV04[i].pMethods[j].Proc(pHalHwInfo, pGrExceptionData);
                    return (RM_OK);
                }
            }
        }
    }

    //
    // HAL didn't service this method.
    // This isn't really an error, since the RM may still want
    // to do something.
    //
    return (RM_ERROR);
}

static RM_STATUS
_nvHalClass053SetClipHorizontal(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    PHWREG nvAddr;
    U032 savedContext;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass053SetClipHorizontal\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // ERROR CHECKING??
    //
    
    //
    // HW HACK!!  NV4 contains internal error checking that limits the clip origin to zero
    // if the current object is the 3D_SURFACE.  We need to temporarily remove the current
    // context object, put in a dummy value, then place the original back.  Yuck.
    //
    savedContext = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, 0x0100004A);

    //
    // Force this X clip information into the hardware.  Note that MIN must be written
    // before MAX.
    //
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN, pGrExceptionData->Data & 0x7FFF);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX, ((pGrExceptionData->Data >> 16) & 0x7FFF) + (pGrExceptionData->Data & 0x7FFF));
    
    //
    // KJK: Need to update the valid bits here as well.
    //
    
    //
    // HW HACK!! Now put back the original context for this subchannel
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, savedContext);
    
    return (RM_OK);
}

static RM_STATUS
_nvHalClass053SetClipVertical(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)

{
    PHWREG nvAddr;
    U032 savedContext;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass053SetClipVertical\r\n");    

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // ERROR CHECKING??
    //
    
    //
    // HW HACK!!  NV4 contains internal error checking that limits the clip origin to zero
    // if the current object is the 3D_SURFACE.  We need to temporarily remove the current
    // context object, put in a dummy value, then place the original back.  Yuck.
    //
    savedContext = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, 0x0100004A);
    
    //
    // Force this Y clip information into the hardware.  Note that MIN must be written
    // before MAX.
    //
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN, pGrExceptionData->Data & 0x7FFF);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX, ((pGrExceptionData->Data >> 16) & 0x7FFF) + (pGrExceptionData->Data & 0x7FFF));    
    
    //
    // KJK: Need to update the valid bits here as well.
    //
    
    //
    // HW HACK!! Now put back the original context for this subchannel
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, savedContext);
    
    return (RM_OK);
}

static RM_STATUS
_nvHalClass060SetColorConversion(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)

{
    PGRHALINFO_NV04 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChannel;
    PHWREG nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalClass060SetColorConversion\r\n");    

    pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrExceptionData->ChID];
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Set the dither mode.
    //
    // Since this comes in as a synchronous graphics exception, we can
    // assume we own the channel and can change the dither mode.
    //
    // The resource manager will handle error checking, so all we're
    // concerned with here is updating the hardware.
    // 
    switch (pGrExceptionData->Data)
    {
        case NV064_SET_COLOR_CONVERSION_DITHER:
            pGrChannel->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED);
            break;
        case NV064_SET_COLOR_CONVERSION_TRUNCATE:
            pGrChannel->Debug3 &= ~DRF_MASK(NV_PGRAPH_DEBUG_3_POSTDITHER_2D);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _DISABLED);
            break;
        default:
            //
            // Data invalid.
            // Resource manager will catch this error and handle it
            // appropriately.
            //
            break;
    }
    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv\haleng.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** HAL Engine Manager *****************************\
*                                                                           *
* Module: haleng.c                                                          *
*   The HAL engine services are in this module.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <gr.h>
#include <nvhal.h>
#include "nvhw.h"

//
// Default per-engine method lists.
//
METHOD tmrDefaultMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {tmrStopTransfer,               0x0108, 0x010b},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetAlarmTime,              0x0300, 0x0307},
    {mthdSetAlarmNotify,            0x030c, 0x030f}
};

extern RM_STATUS grHWMethod(PHWINFO, POBJECT, PMETHOD, U032, U032);

METHOD grDefaultMethods[] =
{
    {grHWMethod,                    0x0100, 0x1fff},
};

//
// EngineInfos[]
//
// This table contains the per-engine stuff needed for
// class object operations such as create, destroy, and method
// handling.
//
ENGINEINFO EngineInfos[] =
{
    { MC_ENGINE_TAG, NULL, 0, NULL, NULL },

    { FB_ENGINE_TAG, NULL, 0, NULL, NULL },

    { DMA_ENGINE_TAG, NULL, 0, dmaCreate, dmaDelete },

    { FIFO_ENGINE_TAG, 0, NULL, NULL, },

    { TMR_ENGINE_TAG,
      tmrDefaultMethods, sizeof (tmrDefaultMethods) / sizeof (METHOD),
      tmrCreateTimer, tmrDeleteTimer },

    { GR_ENGINE_TAG,
      grDefaultMethods, sizeof (grDefaultMethods) / sizeof (METHOD),
      grCreateObj, grDestroyObj },

    { DAC_ENGINE_TAG, 
      NULL, 0,
      dacCreateObj, dacDestroyObj },

    { MP_ENGINE_TAG,
      NULL, 0,
      mpCreateObj, mpDestroyObj },

    { VIDEO_ENGINE_TAG,
      NULL, 0,
      videoCreateObj, videoDestroyObj },

    // NV_CLASS pseudo engine
    { CLASS_PSEUDO_ENGINE_TAG,
      NULL, 0,
      nopCreate, classDeleteWellKnownObjects },

    { NO_ENGINE, NULL, 0, NULL, NULL },
};

#define NUM_ENGINEINFOS         (sizeof (EngineInfos) / sizeof (ENGINEINFO))

U032 nvClassEngineDescriptor = MKENGDECL(CLASS_PSEUDO_ENGINE_TAG, 0, 0);
U032 nvNoEngineDescriptor = MKENGDECL(NO_ENGINE, 0, 0);

//
// engineGetInfo
//
// Given an engine tag, return pointers to the corresponding
// ENGINEINFO and ENGINEDESCRIPTOR data.
//
RM_STATUS
engineGetInfo(PENGINEDB pEngineDB, U032 engineTag, PENGINEINFO *pEngineInfo, PENGINEDESCRIPTOR *pEngineDecl)
{
    U032 i;

    for (i = 0; i < NUM_ENGINEINFOS; i++)
    {
        if (EngineInfos[i].Tag == engineTag)
        {
            *pEngineInfo = &EngineInfos[i];
            break;
        }
    }

    if (i == NUM_ENGINEINFOS)
    {
        if (engineTag == NO_ENGINE)
            *pEngineInfo = 0;
        else
        {
            *pEngineInfo = 0; *pEngineDecl = 0;
            return RM_ERROR;
        }
    }

    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if ((ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) == ENGDECL_INSTR) &&
            (engineTag == ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _TAG)))
        {
            *pEngineDecl = &pEngineDB->pEngineDescriptors[i];
            return RM_OK;
        }
    }

    //
    // Special case the NV_CLASS engine (used to create the
    // master classes in the fifo db for method-driven object
    // instantiation).
    //
    if (engineTag == CLASS_PSEUDO_ENGINE_TAG)
    {
        *pEngineDecl = &nvClassEngineDescriptor;
        return RM_OK;
    }

    //
    // Special case classes that bypass the engine info stuff
    // entirely (e.g. NV01_MEMOR_LOCAL_USER).  These classes are
    // typically instantiated by separate API calls (i.e. !RmAllocObject).
    if (engineTag == NO_ENGINE)
    {
        *pEngineDecl = &nvNoEngineDescriptor;
        return RM_OK;
    }


    *pEngineDecl = 0x0;
    return RM_ERROR;
}

//
// engineGetBufferSize
//
// This routine walks through the engine descriptor table to
// find a descriptor for the specified engine/type that lets
// us know how much (if any) "scratch" memory the resource
// manager should allocate/free.
//
U032
engineGetBufferSize(PENGINEDB pEngineDB, U032 tag, U032 type)
{
    U032 i;

    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if ((ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) == ENGMALLOC_INSTR) &&
            (ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TAG) == tag) &&
            (ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TYPE) == type))
        {
            return (ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE) * 4);
        }
    }

    return (0);
}

//
// engineGetInstMemSize
// 
// This routine walks through the engine descriptor table to
// find a descriptor for the specified engine that lets us 
// know how much (if any) instance memory the resource 
// manager should allocate/free.
//
U032
engineGetInstMemSize(PENGINEDB pEngineDB, U032 tag)
{
    U032 i;

    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if ((ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) == ENGINSTMALLOC_INSTR) &&
            (ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TAG) == tag))
        {
            return (ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE) * 4);
        }
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv4\grcxnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRCXNV04.C                                                        *
*   The graphics engine is managed in this module.  Context switching is    *
*   contained here.                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

RM_STATUS nvHalGrLoadChannelContext_NV04(PHALHWINFO, U032);
RM_STATUS nvHalGrUnloadChannelContext_NV04(PHALHWINFO, U032);

//
// nvHalGrLoadChannelContext
//
RM_STATUS
nvHalGrLoadChannelContext_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV04 pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChan;
    U032 i;
    U032 misc;
    U032 caches, fifo0, fifo1;

    //
    // Disable FIFO access.
    //
    // KJK Me thinks this shouldn't be necessary
    //
    caches = REG_RD32(NV_PFIFO_CACHES);
    fifo0  = REG_RD32(NV_PFIFO_CACHE0_PULL0);
    fifo1  = REG_RD32(NV_PFIFO_CACHE1_PULL0);
    REG_WR_DRF_DEF(_PFIFO_, CACHES,       _REASSIGN, _DISABLED);
    REG_WR_DRF_DEF(_PFIFO_, CACHE0_PULL0, _ACCESS,   _DISABLED);
    REG_WR_DRF_DEF(_PFIFO_, CACHE1_PULL0, _ACCESS,   _DISABLED);

    //
    // Service any outstanding graphics exceptions.
    //
    if (REG_RD32(NV_PGRAPH_INTR))
        HALRMSERVICEINTR(pHalHwInfo, GR_ENGINE_TAG);
        
    //
    // Save current graphics interface state.
    //
    GR_SAVE_STATE(misc);
    HAL_GR_IDLE(pHalHwInfo);
    
    //
    // Unload current context.
    //   
    if (pGrHalPvtInfo->currentChID != ChID)
        nvHalGrUnloadChannelContext_NV04(pHalHwInfo, pGrHalPvtInfo->currentChID);

    if ((pGrHalPvtInfo->currentChID = ChID) == INVALID_CHID)
    {
        //
        // Set current channel to an invalid one.
        //
        FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, 0x0F);
        //
        // Update current channel.
        //    
        REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                      | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
        REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

        //
        // Restore graphics interface state.
        //
        misc |= DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _ENABLED);
        GR_RESTORE_STATE(misc); // FIFO reenabled in here
        //
        // Restore FIFO access.
        //
        /*
        REG_WR32(NV_PFIFO_CACHE0_PULL0, fifo0);
        REG_WR32(NV_PFIFO_CACHE1_PULL0, fifo1);
        REG_WR32(NV_PFIFO_CACHES,       caches);
        */
        return (RM_OK);
        //
        // Is the channel ID valid?
        //
    }
    else if (ChID >= NUM_FIFOS_NV04)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Channel on Graphics Context Switch:", ChID);
        DBG_BREAKPOINT();
        return (RM_ERR_BAD_ARGUMENT);
    }

    //
    // Get pointer to correct channel context area.
    //
    pGrChan = &pGrHalPvtInfo->grChannels[ChID];

    //
    // Reload std user clip (NV4 dictates that this be restored before ctx switch)
    //
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMIN,  pGrChan->CurrentPatch.AbsUClipXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_XMAX,  pGrChan->CurrentPatch.AbsUClipXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMIN,  pGrChan->CurrentPatch.AbsUClipYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIP_YMAX,  pGrChan->CurrentPatch.AbsUClipYMax);

    //
    // Reload context state
    //
    REG_WR32(NV_PGRAPH_CTX_SWITCH1, pGrChan->ContextSwitch1);
    REG_WR32(NV_PGRAPH_CTX_SWITCH2, pGrChan->ContextSwitch2);
    REG_WR32(NV_PGRAPH_CTX_SWITCH3, pGrChan->ContextSwitch3);
    REG_WR32(NV_PGRAPH_CTX_SWITCH4, pGrChan->ContextSwitch4);

    for (i = 0; i < 8; i++)
    {    
        REG_WR32(NV_PGRAPH_CTX_CACHE1(i), pGrChan->ContextCache1[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE2(i), pGrChan->ContextCache2[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE3(i), pGrChan->ContextCache3[i]);
        REG_WR32(NV_PGRAPH_CTX_CACHE4(i), pGrChan->ContextCache4[i]);
    }
    
    REG_WR32(NV_PGRAPH_CTX_USER, pGrChan->ContextUser);
    
    //
    // Reload current dma registers
    //
    REG_WR32(NV_PGRAPH_DMA_START_0, pGrChan->DmaStart0);
    REG_WR32(NV_PGRAPH_DMA_START_1, pGrChan->DmaStart1);
    REG_WR32(NV_PGRAPH_DMA_LENGTH,  pGrChan->DmaLength);
    REG_WR32(NV_PGRAPH_DMA_MISC,    pGrChan->DmaMisc);
    REG_WR32(NV_PGRAPH_DMA_PITCH,   pGrChan->DmaPitch);
            
    //
    // Reload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        REG_WR32(NV_PGRAPH_BOFFSET(i),  pGrChan->CurrentPatch.BufferOffset[i]);
        REG_WR32(NV_PGRAPH_BBASE(i),    pGrChan->CurrentPatch.BufferBase[i]);
        REG_WR32(NV_PGRAPH_BLIMIT(i),   pGrChan->CurrentPatch.BufferLimit[i]);
    }
    
    for (i = 0; i < 5; i++)
        REG_WR32(NV_PGRAPH_BPITCH(i),   pGrChan->CurrentPatch.BufferPitch[i]);
        
    REG_WR32(NV_PGRAPH_SURFACE,         pGrChan->CurrentPatch.Surface);        
    REG_WR32(NV_PGRAPH_STATE,           pGrChan->CurrentPatch.State);        
    REG_WR32(NV_PGRAPH_BSWIZZLE2,       pGrChan->CurrentPatch.BufferSwizzle[0]);        
    REG_WR32(NV_PGRAPH_BSWIZZLE5,       pGrChan->CurrentPatch.BufferSwizzle[1]);        
    REG_WR32(NV_PGRAPH_BPIXEL,          pGrChan->CurrentPatch.BufferPixel);
    
    REG_WR32(NV_PGRAPH_NOTIFY,          pGrChan->CurrentPatch.Notify);
    
    REG_WR32(NV_PGRAPH_PATT_COLOR0,     pGrChan->CurrentPatch.PatternColor0);    
    REG_WR32(NV_PGRAPH_PATT_COLOR1,     pGrChan->CurrentPatch.PatternColor1);
    
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _ENABLED);
    for (i = 0; i < 64; i++)
        REG_WR32(NV_PGRAPH_PATT_COLORRAM(i), pGrChan->CurrentPatch.PatternColorRam[i]);
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _DISABLED);
        
    REG_WR32(NV_PGRAPH_PATTERN(0),      pGrChan->CurrentPatch.Pattern[0]);
    REG_WR32(NV_PGRAPH_PATTERN(1),      pGrChan->CurrentPatch.Pattern[1]);
    REG_WR32(NV_PGRAPH_PATTERN_SHAPE,   pGrChan->CurrentPatch.PatternShape);
    
    REG_WR32(NV_PGRAPH_MONO_COLOR0,     pGrChan->CurrentPatch.MonoColor0);
    REG_WR32(NV_PGRAPH_ROP3,            pGrChan->CurrentPatch.Rop3);
    REG_WR32(NV_PGRAPH_CHROMA,          pGrChan->CurrentPatch.Chroma);
    REG_WR32(NV_PGRAPH_BETA_AND,        pGrChan->CurrentPatch.BetaAnd);
    REG_WR32(NV_PGRAPH_BETA_PREMULT,    pGrChan->CurrentPatch.BetaPremult);
    
    REG_WR32(NV_PGRAPH_CONTROL0,        pGrChan->CurrentPatch.Control0);
    REG_WR32(NV_PGRAPH_CONTROL1,        pGrChan->CurrentPatch.Control1);
    REG_WR32(NV_PGRAPH_CONTROL2,        pGrChan->CurrentPatch.Control2);
    
    REG_WR32(NV_PGRAPH_BLEND,           pGrChan->CurrentPatch.Blend);
    
    REG_WR32(NV_PGRAPH_STORED_FMT,      pGrChan->CurrentPatch.StoredFmt);
    REG_WR32(NV_PGRAPH_SOURCE_COLOR,    pGrChan->CurrentPatch.SourceColor);
    
    for (i = 0; i < 32; i++)
    {
        REG_WR32(NV_PGRAPH_ABS_X_RAM(i), pGrChan->CurrentPatch.AbsXRam[i]);
        REG_WR32(NV_PGRAPH_ABS_Y_RAM(i), pGrChan->CurrentPatch.AbsYRam[i]);
    }        
    
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMIN, pGrChan->CurrentPatch.AbsUClipAXMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_XMAX, pGrChan->CurrentPatch.AbsUClipAXMax);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMIN, pGrChan->CurrentPatch.AbsUClipAYMin);
    REG_WR32(NV_PGRAPH_ABS_UCLIPA_YMAX, pGrChan->CurrentPatch.AbsUClipAYMax);
    
    REG_WR32(NV_PGRAPH_ABS_ICLIP_XMAX,  pGrChan->CurrentPatch.AbsIClipXMax);
    REG_WR32(NV_PGRAPH_ABS_ICLIP_YMAX,  pGrChan->CurrentPatch.AbsIClipYMax);
    
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC0,  pGrChan->CurrentPatch.XYLogicMisc0);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC1,  pGrChan->CurrentPatch.XYLogicMisc1);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC2,  pGrChan->CurrentPatch.XYLogicMisc2);
    REG_WR32(NV_PGRAPH_XY_LOGIC_MISC3,  pGrChan->CurrentPatch.XYLogicMisc3);

    REG_WR32(NV_PGRAPH_CLIPX_0,         pGrChan->CurrentPatch.ClipX0);
    REG_WR32(NV_PGRAPH_CLIPX_1,         pGrChan->CurrentPatch.ClipX1);
    REG_WR32(NV_PGRAPH_CLIPY_0,         pGrChan->CurrentPatch.ClipY0);
    REG_WR32(NV_PGRAPH_CLIPY_1,         pGrChan->CurrentPatch.ClipY1);
    
    for (i = 0; i < 16; i++)
    {
        REG_WR32(NV_PGRAPH_U_RAM(i),    pGrChan->CurrentPatch.URam[i]);
        REG_WR32(NV_PGRAPH_V_RAM(i),    pGrChan->CurrentPatch.VRam[i]);
        REG_WR32(NV_PGRAPH_M_RAM(i),    pGrChan->CurrentPatch.MRam[i]);
    }
    
    REG_WR32(NV_PGRAPH_COMBINE0ALPHA,   pGrChan->CurrentPatch.Combine0Alpha);
    REG_WR32(NV_PGRAPH_COMBINE0COLOR,   pGrChan->CurrentPatch.Combine0Color);
    REG_WR32(NV_PGRAPH_COMBINE1ALPHA,   pGrChan->CurrentPatch.Combine1Alpha);
    REG_WR32(NV_PGRAPH_COMBINE1COLOR,   pGrChan->CurrentPatch.Combine1Color);
    
    REG_WR32(NV_PGRAPH_FORMAT0,         pGrChan->CurrentPatch.Format0);
    REG_WR32(NV_PGRAPH_FORMAT1,         pGrChan->CurrentPatch.Format1);
    REG_WR32(NV_PGRAPH_FILTER0,         pGrChan->CurrentPatch.Filter0);
    REG_WR32(NV_PGRAPH_FILTER1,         pGrChan->CurrentPatch.Filter1);
    
    REG_WR32(NV_PGRAPH_D3D_XY,          pGrChan->CurrentPatch.D3D_XY);
    REG_WR32(NV_PGRAPH_D3D_U0,          pGrChan->CurrentPatch.D3D_U0);
    REG_WR32(NV_PGRAPH_D3D_V0,          pGrChan->CurrentPatch.D3D_V0);
    REG_WR32(NV_PGRAPH_D3D_U1,          pGrChan->CurrentPatch.D3D_U1);
    REG_WR32(NV_PGRAPH_D3D_V1,          pGrChan->CurrentPatch.D3D_V1);
    REG_WR32(NV_PGRAPH_D3D_ZETA,        pGrChan->CurrentPatch.D3D_ZETA);
    REG_WR32(NV_PGRAPH_D3D_RGB,         pGrChan->CurrentPatch.D3D_RGB);
    REG_WR32(NV_PGRAPH_D3D_S,           pGrChan->CurrentPatch.D3D_S);
    REG_WR32(NV_PGRAPH_D3D_M,           pGrChan->CurrentPatch.D3D_M);

    REG_WR32(NV_PGRAPH_PASSTHRU_0,      pGrChan->CurrentPatch.Passthru0);    
    REG_WR32(NV_PGRAPH_PASSTHRU_1,      pGrChan->CurrentPatch.Passthru1);    
    REG_WR32(NV_PGRAPH_PASSTHRU_2,      pGrChan->CurrentPatch.Passthru2);
    REG_WR32(NV_PGRAPH_DVD_COLORFMT,    pGrChan->CurrentPatch.DVDColorFormat);
    REG_WR32(NV_PGRAPH_SCALED_FORMAT,   pGrChan->CurrentPatch.ScaledFormat);
    REG_WR32(NV_PGRAPH_MISC24_0,        pGrChan->CurrentPatch.Misc24_0);
    REG_WR32(NV_PGRAPH_MISC24_1,        pGrChan->CurrentPatch.Misc24_1);
    REG_WR32(NV_PGRAPH_MISC24_2,        pGrChan->CurrentPatch.Misc24_2);
    REG_WR32(NV_PGRAPH_X_MISC,          pGrChan->CurrentPatch.XMisc);
    REG_WR32(NV_PGRAPH_Y_MISC,          pGrChan->CurrentPatch.YMisc);
    REG_WR32(NV_PGRAPH_VALID1,          pGrChan->CurrentPatch.Valid1);
    REG_WR32(NV_PGRAPH_VALID2,          pGrChan->CurrentPatch.Valid2);

    // restore the PGRAPH_DEBUG_3_POSTDITHER_2D setting
    REG_WR32(NV_PGRAPH_DEBUG_3,  pGrChan->Debug3);

    //
    // Update current channel.
    //    
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _NOT_EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _VALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
                                  
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, ChID);
    
    //
    // Clear the graphics fifo channel context.  This fixes a subtle hardware bug
    // when thrashing channel changes within the graphics fifo.  Ideally the fifo
    // would hold off pending data while a change is active, but it can actually
    // hold multiple changes.  In order to reduce hw confusion, they added a few
    // state bits within one stage fifo (bits 20 and 21).  
    // Clear those bits on channel changes. Don't rely on these to read as zero
    // eventhough these bits are write only.
    //
    // We have to OR in the top bit to fool the Watcom compiler for the Win3.1 version
    // of the resmgr.
    //
    REG_WR32(NV_PGRAPH_FFINTFC_ST2, REG_RD32(NV_PGRAPH_FFINTFC_ST2) & 0xffCfffff);

    // Restore graphics interface state.
    //
    GR_RESTORE_STATE(misc);
    
    //
    // Restore FIFO access.
    //
    REG_WR32(NV_PFIFO_CACHE0_PULL0, fifo0);
    REG_WR32(NV_PFIFO_CACHE1_PULL0, fifo1);
    REG_WR32(NV_PFIFO_CACHES, caches);

    return (RM_OK);
}


RM_STATUS
nvHalGrUnloadChannelContext_NV04(PHALHWINFO pHalHwInfo, U032 ChID)
{
    PGRHALINFO_NV04 pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChan;
    U032 i;

    //
    // No need to unload an invalid channel
    //
    if (ChID  == INVALID_CHID)
        return (RM_OK);

    pGrChan = &pGrHalPvtInfo->grChannels[ChID];

    //
    // Unload current context registers.
    //
    pGrChan->ContextSwitch1    = REG_RD32(NV_PGRAPH_CTX_SWITCH1);
    pGrChan->ContextSwitch2    = REG_RD32(NV_PGRAPH_CTX_SWITCH2);
    pGrChan->ContextSwitch3    = REG_RD32(NV_PGRAPH_CTX_SWITCH3);        
    pGrChan->ContextSwitch4    = REG_RD32(NV_PGRAPH_CTX_SWITCH4);

    for (i = 0; i < 8; i++)
    {    
        pGrChan->ContextCache1[i] = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));
        pGrChan->ContextCache2[i] = REG_RD32(NV_PGRAPH_CTX_CACHE2(i));
        pGrChan->ContextCache3[i] = REG_RD32(NV_PGRAPH_CTX_CACHE3(i));
        pGrChan->ContextCache4[i] = REG_RD32(NV_PGRAPH_CTX_CACHE4(i));
    }
    
    pGrChan->ContextUser       = REG_RD32(NV_PGRAPH_CTX_USER);
    
    //
    // Unload current dma registers
    //
    pGrChan->DmaStart0         = REG_RD32(NV_PGRAPH_DMA_START_0);
    pGrChan->DmaStart1         = REG_RD32(NV_PGRAPH_DMA_START_1);
    pGrChan->DmaLength         = REG_RD32(NV_PGRAPH_DMA_LENGTH);
    pGrChan->DmaMisc           = REG_RD32(NV_PGRAPH_DMA_MISC);
    pGrChan->DmaPitch          = REG_RD32(NV_PGRAPH_DMA_PITCH);
            
    //
    // Unload current graphics state
    //
    for (i = 0; i < 6; i++)
    {    
        pGrChan->CurrentPatch.BufferOffset[i] = REG_RD32(NV_PGRAPH_BOFFSET(i));
        pGrChan->CurrentPatch.BufferBase[i]   = REG_RD32(NV_PGRAPH_BBASE(i));
        pGrChan->CurrentPatch.BufferLimit[i]  = REG_RD32(NV_PGRAPH_BLIMIT(i));
    }
    
    for (i = 0; i < 5; i++)
        pGrChan->CurrentPatch.BufferPitch[i]  = REG_RD32(NV_PGRAPH_BPITCH(i));
        
    pGrChan->CurrentPatch.Surface             = REG_RD32(NV_PGRAPH_SURFACE);
    pGrChan->CurrentPatch.State               = REG_RD32(NV_PGRAPH_STATE);
    pGrChan->CurrentPatch.BufferSwizzle[0]    = REG_RD32(NV_PGRAPH_BSWIZZLE2);
    pGrChan->CurrentPatch.BufferSwizzle[1]    = REG_RD32(NV_PGRAPH_BSWIZZLE5);
    pGrChan->CurrentPatch.BufferPixel         = REG_RD32(NV_PGRAPH_BPIXEL);
    pGrChan->CurrentPatch.Notify              = REG_RD32(NV_PGRAPH_NOTIFY);
        pGrChan->CurrentPatch.PatternColor0       = REG_RD32(NV_PGRAPH_PATT_COLOR0);    
    pGrChan->CurrentPatch.PatternColor1       = REG_RD32(NV_PGRAPH_PATT_COLOR1);
    
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _ENABLED);
    for (i = 0; i < 64; i++)
        pGrChan->CurrentPatch.PatternColorRam[i] = REG_RD32(NV_PGRAPH_PATT_COLORRAM(i));
    FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK, _DISABLED);
    
    pGrChan->CurrentPatch.Pattern[0]          = REG_RD32(NV_PGRAPH_PATTERN(0));
    pGrChan->CurrentPatch.Pattern[1]          = REG_RD32(NV_PGRAPH_PATTERN(1));
    pGrChan->CurrentPatch.PatternShape        = REG_RD32(NV_PGRAPH_PATTERN_SHAPE);
    
    pGrChan->CurrentPatch.MonoColor0          = REG_RD32(NV_PGRAPH_MONO_COLOR0);
    pGrChan->CurrentPatch.Rop3                = REG_RD32(NV_PGRAPH_ROP3);
    pGrChan->CurrentPatch.Chroma              = REG_RD32(NV_PGRAPH_CHROMA);
    pGrChan->CurrentPatch.BetaAnd             = REG_RD32(NV_PGRAPH_BETA_AND);
    pGrChan->CurrentPatch.BetaPremult         = REG_RD32(NV_PGRAPH_BETA_PREMULT);
    
    pGrChan->CurrentPatch.Control0            = REG_RD32(NV_PGRAPH_CONTROL0);
    pGrChan->CurrentPatch.Control1            = REG_RD32(NV_PGRAPH_CONTROL1);
    pGrChan->CurrentPatch.Control2            = REG_RD32(NV_PGRAPH_CONTROL2);
    
    pGrChan->CurrentPatch.Blend               = REG_RD32(NV_PGRAPH_BLEND);
    
    pGrChan->CurrentPatch.StoredFmt           = REG_RD32(NV_PGRAPH_STORED_FMT);
    pGrChan->CurrentPatch.SourceColor         = REG_RD32(NV_PGRAPH_SOURCE_COLOR);
    
    for (i = 0; i < 32; i++)
    {
        pGrChan->CurrentPatch.AbsXRam[i]      = REG_RD32(NV_PGRAPH_ABS_X_RAM(i));
        pGrChan->CurrentPatch.AbsYRam[i]      = REG_RD32(NV_PGRAPH_ABS_Y_RAM(i));
    }        
    
    pGrChan->CurrentPatch.AbsUClipXMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMIN);
    pGrChan->CurrentPatch.AbsUClipXMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_XMAX);
    pGrChan->CurrentPatch.AbsUClipYMin        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMIN);
    pGrChan->CurrentPatch.AbsUClipYMax        = REG_RD32(NV_PGRAPH_ABS_UCLIP_YMAX);
    
    pGrChan->CurrentPatch.AbsUClipAXMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMIN);
    pGrChan->CurrentPatch.AbsUClipAXMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_XMAX);
    pGrChan->CurrentPatch.AbsUClipAYMin       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMIN);
    pGrChan->CurrentPatch.AbsUClipAYMax       = REG_RD32(NV_PGRAPH_ABS_UCLIPA_YMAX);
    
    pGrChan->CurrentPatch.AbsIClipXMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_XMAX);
    pGrChan->CurrentPatch.AbsIClipYMax        = REG_RD32(NV_PGRAPH_ABS_ICLIP_YMAX);
    
    pGrChan->CurrentPatch.XYLogicMisc0        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC0);
    pGrChan->CurrentPatch.XYLogicMisc1        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC1);
    pGrChan->CurrentPatch.XYLogicMisc2        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC2);
    pGrChan->CurrentPatch.XYLogicMisc3        = REG_RD32(NV_PGRAPH_XY_LOGIC_MISC3);

    pGrChan->CurrentPatch.ClipX0              = REG_RD32(NV_PGRAPH_CLIPX_0);
    pGrChan->CurrentPatch.ClipX1              = REG_RD32(NV_PGRAPH_CLIPX_1);
    pGrChan->CurrentPatch.ClipY0              = REG_RD32(NV_PGRAPH_CLIPY_0);
    pGrChan->CurrentPatch.ClipY1              = REG_RD32(NV_PGRAPH_CLIPY_1);
    
    for (i = 0; i < 16; i++)
    {
        pGrChan->CurrentPatch.URam[i]         = REG_RD32(NV_PGRAPH_U_RAM(i));
        pGrChan->CurrentPatch.VRam[i]         = REG_RD32(NV_PGRAPH_V_RAM(i));
        pGrChan->CurrentPatch.MRam[i]         = REG_RD32(NV_PGRAPH_M_RAM(i));
    }
    
    pGrChan->CurrentPatch.Combine0Alpha       = REG_RD32(NV_PGRAPH_COMBINE0ALPHA);
    pGrChan->CurrentPatch.Combine0Color       = REG_RD32(NV_PGRAPH_COMBINE0COLOR);
    pGrChan->CurrentPatch.Combine1Alpha       = REG_RD32(NV_PGRAPH_COMBINE1ALPHA);
    pGrChan->CurrentPatch.Combine1Color       = REG_RD32(NV_PGRAPH_COMBINE1COLOR);
    
    pGrChan->CurrentPatch.Format0             = REG_RD32(NV_PGRAPH_FORMAT0);
    pGrChan->CurrentPatch.Format1             = REG_RD32(NV_PGRAPH_FORMAT1);
    pGrChan->CurrentPatch.Filter0             = REG_RD32(NV_PGRAPH_FILTER0);
    pGrChan->CurrentPatch.Filter1             = REG_RD32(NV_PGRAPH_FILTER1);
    
    pGrChan->CurrentPatch.D3D_XY              = REG_RD32(NV_PGRAPH_D3D_XY);
    pGrChan->CurrentPatch.D3D_U0              = REG_RD32(NV_PGRAPH_D3D_U0);
    pGrChan->CurrentPatch.D3D_V0              = REG_RD32(NV_PGRAPH_D3D_V0);
    pGrChan->CurrentPatch.D3D_U1              = REG_RD32(NV_PGRAPH_D3D_U1);
    pGrChan->CurrentPatch.D3D_V1              = REG_RD32(NV_PGRAPH_D3D_V1);
    pGrChan->CurrentPatch.D3D_ZETA            = REG_RD32(NV_PGRAPH_D3D_ZETA);
    pGrChan->CurrentPatch.D3D_RGB             = REG_RD32(NV_PGRAPH_D3D_RGB);
    pGrChan->CurrentPatch.D3D_S               = REG_RD32(NV_PGRAPH_D3D_S);
    pGrChan->CurrentPatch.D3D_M               = REG_RD32(NV_PGRAPH_D3D_M);

    pGrChan->CurrentPatch.Passthru0           = REG_RD32(NV_PGRAPH_PASSTHRU_0);    
    pGrChan->CurrentPatch.Passthru1           = REG_RD32(NV_PGRAPH_PASSTHRU_1);    
    pGrChan->CurrentPatch.Passthru2           = REG_RD32(NV_PGRAPH_PASSTHRU_2);    
    
    pGrChan->CurrentPatch.DVDColorFormat      = REG_RD32(NV_PGRAPH_DVD_COLORFMT);    
    pGrChan->CurrentPatch.ScaledFormat        = REG_RD32(NV_PGRAPH_SCALED_FORMAT);    
    
    pGrChan->CurrentPatch.Misc24_0            = REG_RD32(NV_PGRAPH_MISC24_0);
    pGrChan->CurrentPatch.Misc24_1            = REG_RD32(NV_PGRAPH_MISC24_1);
    pGrChan->CurrentPatch.Misc24_2            = REG_RD32(NV_PGRAPH_MISC24_2);
    pGrChan->CurrentPatch.XMisc               = REG_RD32(NV_PGRAPH_X_MISC);
    pGrChan->CurrentPatch.YMisc               = REG_RD32(NV_PGRAPH_Y_MISC);
    pGrChan->CurrentPatch.Valid1              = REG_RD32(NV_PGRAPH_VALID1);
    pGrChan->CurrentPatch.Valid2              = REG_RD32(NV_PGRAPH_VALID2);
    
    // save the PGRAPH_DEBUG_3_POSTDITHER_2D setting
    pGrChan->Debug3              = REG_RD32(NV_PGRAPH_DEBUG_3);

    //
    // Invalidate hw's channel ID.
    //
    REG_WR32(NV_PGRAPH_CTX_CONTROL, DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                                  | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
    FLD_WR_DRF_NUM(_PGRAPH, _CTX_USER, _CHID, 0x0F);

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\gr\nv4\grnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GRNV04.C                                                          *
*   The graphics chip dependent HAL GR routines are kept here.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// forwards
RM_STATUS nvHalGrControl_NV04(VOID *);
RM_STATUS nvHalGrAlloc_NV04(VOID *);
RM_STATUS nvHalGrFree_NV04(VOID *);
RM_STATUS nvHalGrGetExceptionData_NV04(VOID *);
RM_STATUS nvHalGrService_NV04(VOID *);
RM_STATUS nvHalGrGetNotifyData_NV04(VOID *);
RM_STATUS nvHalGrSetObjectContext_NV04(VOID *);
RM_STATUS nvHalGrLoadOverride_NV04(VOID *);

// statics
static RM_STATUS _nvHalGrInitInstance_NV04(PHALHWINFO, U032, U032);
static RM_STATUS _nvHalGrSetContextColorKeyWar_NV04(PHALHWINFO, PGREXCEPTIONDATA);

// externs
extern RM_STATUS nvHalGrClassSoftwareMethod_NV04(PHALHWINFO, PGREXCEPTIONDATA);
extern RM_STATUS nvHalGrLoadChannelContext_NV04(PHALHWINFO, U032);
extern RM_STATUS nvHalGrUnloadChannelContext_NV04(PHALHWINFO, U032);

//
// nvHalGrControl
//
RM_STATUS
nvHalGrControl_NV04(VOID *arg)
{
    PGRCONTROLARG_000 pGrControlArg = (PGRCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV04 pGrHalPvtInfo;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrControlArg->id != GR_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrControlArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;

    switch (pGrControlArg->cmd)
    {
        case GR_CONTROL_INIT:
            //
            // Some of these bits will be dynamically modified.
            //
            switch (REG_RD_DRF(_PMC, _BOOT_0, _MAJOR_REVISION))
            {
                case NV4_REV_A_00:
                    pGrHalPvtInfo->Debug0 = DRF_DEF(_PGRAPH, _DEBUG_0, _LIMIT_CHECK,     _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _LIMIT_INT,       _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _OVRFLW_INT,      _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _WRITE_ONLY_ROPS_2D, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _WRITE_ONLY_ROPS_3D, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _DRAWDIR_AUTO,    _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _DRAWDIR_Y,       _INCR)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _ALPHA_ABORT,     _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _MINUSD5,         _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_0, _BLIT_DST_LIMIT,  _ENABLED);
        
                    pGrHalPvtInfo->Debug1 = DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,  _NOT_LAST)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY,    _IGNORE) 
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _PATCH_INV,       _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _TRI_OPTS,        _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _TRICLIP_OPTS,    _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _INSTANCE,        _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _CTX,             _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE,           _IGNORE)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _CACHE_MODE,      _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _ZCLAMP,          _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _UCLAMP,          _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_1, _RCLAMP,          _ENABLED);

                    pGrHalPvtInfo->Debug2 = DRF_DEF(_PGRAPH, _DEBUG_2,  _PINGPONG,        _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ZBUF_SEQ,        _AUTO)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _FAST_VERTEX_LOAD, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _BILINEAR_3D,     _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ANISOTROPIC_3D,  _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _FOG_3D,          _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _SPECULAR_3D,     _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _ALPHA_3D,        _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _COELESCE_D3D,    _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _COELESCE_2D,     _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _BLIT_MULTILINE,  _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _VOLATILE_RESET,  _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _SPARE1,          _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _SPARE2,          _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_2, _SPARE3,          _ENABLED);

                    pGrHalPvtInfo->Debug3 = DRF_DEF(_PGRAPH, _DEBUG_3, _CULLING,         _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _CULLING_TYPE,    _DX3)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_STRTCH, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_D3D,   _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _ZFLUSH,          _IGNORE)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _AUTOZFLUSH_PTZ,  _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _AUTOZFLUSH_D3D,  _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D,   _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_3D,   _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D,    _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D,    _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_3D,    _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SLOT_CONFLICT_PTZ, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _SLOT_CONFLICT_D3D, _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _EARLYZ_ABORT,    _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FORCE_CREAD,     _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FORCE_ZREAD,     _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _FORMAT_CHECK,    _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _TRIEND_FLUSH,    _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DMA_CHECK,       _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK,      _ENABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _DATA_CHECK_FAIL, _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _RAMREADBACK,     _DISABLED)
                        | DRF_DEF(_PGRAPH, _DEBUG_3, _STATE_CHECK,     _ENABLED);
                    break;
            }

            if (IsNV5orBetter_NV04(pHalHwInfo->pMcHalInfo)) {
                pGrHalPvtInfo->Debug1 |= DRF_DEF(_PGRAPH, _DEBUG_1, _BIDIR_DRAIN,         _DISABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _EARLY_POST,          _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _FIXED_ADRS,          _DISABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _ALT_RW_SEQ,          _DISABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _DITHER_RANGE_ADJ_2D, _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _DITHER_RANGE_ADJ_3D, _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_1, _DX6_2PIXMODE,        _ENABLED);

                /* Uncomment this after the hardware is fixed.
                   pDev->Graphics.Debug1 |= DRF_DEF(_PGRAPH, _DEBUG_1, _ALOM_BURST,          _ENABLED);
                   */

                pGrHalPvtInfo->Debug2 |= DRF_DEF(_PGRAPH, _DEBUG_2, _MCLK_RECTS,        _ENABLED);

                //
                // Disable HONOR_SRCFMT.  Note this is overloaded from PINGPONG in NV4
                //
                pGrHalPvtInfo->Debug2 &= ~DRF_DEF(_PGRAPH, _DEBUG_2, _HONOR_SRCFMT,      _ENABLED);

                pGrHalPvtInfo->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _EXCLUDE_ROP_IN_IDLE, _ENABLED);

                // Enable setContext, SetOpetaion, and setClip methods in hardware.
                pGrHalPvtInfo->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D,        _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_3, _CLIP_METHODS,        _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_3, _CONTEXT_METHODS,     _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_3, _OPERATION_METHOD,    _ENABLED)
                    | DRF_DEF(_PGRAPH, _DEBUG_3, _IGNORE_PATCHVALID,   _ENABLED);
                /* Uncomment this after the hardware is fixed.
                   // Enable fast image_from_memory.
                   pGrHalInfo->Debug3 |= DRF_DEF(_PGRAPH, _DEBUG_3, _FAST_DATA_IMAGE, _ENABLED);
                   */
            }

            //
            // We're now context switching PGRAPH_DEBUG_3, in order to support SetColorConversion
            // for NV4_INDEXED_IMAGE (NV5_INDEXED_IMAGE has a real method/context state). Load the
            // grTable version of Debug3 with what we've figured out above.
            //
            for (i = 0; i < NUM_FIFOS_NV04; i++)
            {
                pGrHalPvtInfo->grChannels[i].Debug3 = pGrHalPvtInfo->Debug3;
            }

            //
            // Set default channel to unused chid
            //
            pGrHalPvtInfo->currentChID = INVALID_CHID;
            break;
        case GR_CONTROL_LOAD:
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET, _LAST);
            REG_WR_DRF_DEF(_PGRAPH, _DEBUG_0, _STATE, _RESET);
            FLD_WR_DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY, _CANCEL);

            //
            // Load debug overrides.
            //            
            REG_WR32(NV_PGRAPH_DEBUG_0, pGrHalPvtInfo->Debug0);
            REG_WR32(NV_PGRAPH_DEBUG_1, pGrHalPvtInfo->Debug1);
            REG_WR32(NV_PGRAPH_DEBUG_2, pGrHalPvtInfo->Debug2);
            REG_WR32(NV_PGRAPH_DEBUG_3, pGrHalPvtInfo->Debug3);

            REG_WR32(NV_PGRAPH_CTX_SWITCH1,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH2,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH3,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_SWITCH4,  0x00000000);
            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            REG_WR_DRF_DEF(_PGRAPH, _FFINTFC_ST2, _CHID_STATUS, _VALID);

            //
            // Reload current graphics context.
            //
            (void) nvHalGrLoadChannelContext_NV04(pHalHwInfo, pGrHalPvtInfo->currentChID);
            break;
        case GR_CONTROL_UNLOAD:
            //
            // Pull out current graphics state.
            //
            (void) nvHalGrLoadChannelContext_NV04(pHalHwInfo, INVALID_CHID);

            REG_WR32(NV_PGRAPH_CTX_CONTROL,
                     DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _33US)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                     | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));
            break;
        case GR_CONTROL_DESTROY:
        case GR_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}


//
// nvHalGrAlloc
//
RM_STATUS
nvHalGrAlloc_NV04(VOID *arg)
{
    PGRALLOCARG_000 pGrAllocArg = (PGRALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pGrAllocArg->id != GR_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Initialize instance memory.
    //
    _nvHalGrInitInstance_NV04(pGrAllocArg->pHalHwInfo, pGrAllocArg->instance, pGrAllocArg->classNum);

    return (RM_OK);
}

//
// nvHalGrFree
//
RM_STATUS
nvHalGrFree_NV04(VOID *arg)
{
    PGRFREEARG_000 pGrFreeArg = (PGRFREEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO pGrHalInfo;
    PGRHALINFO_NV04 pGrHalPvtInfo;
    PGRAPHICSCHANNEL_NV04 pGrChannel;
#ifdef NOTYET
    U032 classNum;
#endif
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrFreeArg->id != GR_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);

    if (pGrFreeArg->chid > NUM_FIFOS_NV04)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrFreeArg->pHalHwInfo;
    pGrHalInfo = pHalHwInfo->pGrHalInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;
    pGrChannel = &pGrHalPvtInfo->grChannels[pGrFreeArg->chid];

#ifdef NOTYET
    //
    // Get class out of instance memory.
    //
    classNum = DRF_VAL(_PGRAPH, _CTX_SWITCH1, _GRCLASS, INST_RD32(pGrFreeArg->instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0)));
#endif

    //
    // Zero the out the object context for good measure.
    //
    for (i = 0; i < 3; i++)
    {
        INST_WR32(pGrFreeArg->instance, i, 0);
    }

    return (RM_OK);
}

//
// nvHalGrGetExceptionData
//
// Retrieve graphics engine exception data.
//
RM_STATUS
nvHalGrGetExceptionData_NV04(VOID *arg)
{
    PGRGETEXCEPTIONDATAARG_000 pGrGetExceptionDataArg = (PGRGETEXCEPTIONDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGREXCEPTIONDATA pGrExceptionData;

    //
    // Verify interface revision.
    //
    if (pGrGetExceptionDataArg->id != GR_GET_EXCEPTION_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetExceptionDataArg->pHalHwInfo;
    pGrExceptionData = pGrGetExceptionDataArg->pExceptionData;

    //
    // Fill in exception data.
    //
    pGrExceptionData->Offset = REG_RD32(NV_PGRAPH_TRAPPED_ADDR);
    pGrExceptionData->ChID = DRF_VAL(_PGRAPH, _TRAPPED_ADDR, _CHID, pGrExceptionData->Offset);
    pGrExceptionData->NotifyInstance = REG_RD_DRF(_PGRAPH, _CTX_SWITCH2,
                                        _NOTIFY_INSTANCE);
    pGrExceptionData->classNum = REG_RD_DRF(_PGRAPH, _CTX_SWITCH1, _GRCLASS);
    pGrExceptionData->Data = REG_RD32(NV_PGRAPH_TRAPPED_DATA);
    pGrExceptionData->Instance = REG_RD32(NV_PGRAPH_CTX_SWITCH4);
    pGrExceptionData->Offset &= (DRF_MASK(NV_PGRAPH_TRAPPED_ADDR_MTHD) << DRF_SHIFT(NV_PGRAPH_TRAPPED_ADDR_MTHD));
    pGrExceptionData->Nsource = REG_RD32(NV_PGRAPH_NSOURCE);
    pGrExceptionData->MethodStatus = RM_OK;

    return (RM_OK);
}

//
// nvHalGrService
//
// Handle selected graphics object exceptions.
//
RM_STATUS
nvHalGrService_NV04(VOID *arg)
{
    PGRSERVICEARG_000 pGrServiceArg = (PGRSERVICEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV04 pGrHalPvtInfo;
    PGREXCEPTIONDATA pGrExceptionData;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrServiceArg->id != GR_SERVICE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrServiceArg->pHalHwInfo;
    pGrExceptionData = pGrServiceArg->pExceptionData;
    pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;

    //
    // Handle any exceptions...
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _PENDING))
    {
        //
        // Reset condition.
        //
        REG_WR_DRF_DEF(_PGRAPH, _INTR, _CONTEXT_SWITCH, _RESET);

        if (IsNV4_NV04(pHalHwInfo->pMcHalInfo))
        {
            //*****  workaround for NV4 MP DMA channel change HW bug -- jsw...
            // According to Rick I. this bug was fixed both for nv5/nv10
            PFIFOHALINFO_NV04 pFifoHalInfo;
            U032 currentCh, get, put, pushPending;
            BOOL isDma, isInUse;

            pFifoHalInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalInfo;
            // determine current channel
            currentCh = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 

            // analyze all DMA channels other than the current channel that are in use 
            for (i = 0; i < NUM_FIFOS_NV04; i++)
            {
                isDma = REG_RD32(NV_PFIFO_MODE) & (1 << i);
                isInUse = pFifoHalInfo->InUse & (1 << i);
                if (isInUse && isDma && i != currentCh)
                {
                    // look for a channel where (put != get) yet is not flagged as pending
                    put = REG_RD32(0x714000 + i * 32);
                    get = REG_RD32(0x714000 + i * 32 + 4);
                    pushPending = REG_RD32(NV_PFIFO_DMA);
                    if (put != get && !(pushPending & (1 << i)))
                    {
                        pushPending |= (1 << i);
                        REG_WR32(NV_PFIFO_DMA, pushPending);
                    }
                }
            }
        }
        //***** ...jsw

        //
        // Wait for idle
        //
        GR_DONE();
    
        //
        // Graphics channel switch.
        //
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Graphics context switch exception.\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Previous graphics channel:", pGrHalPvtInfo->currentChID);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: New graphics channel:", pGrExceptionData->ChID);

        (void) nvHalGrLoadChannelContext_NV04(pHalHwInfo, pGrExceptionData->ChID);
    }

    //
    // Handle methods in software.
    //
    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _PENDING))
    {
        if (nvHalGrClassSoftwareMethod_NV04(pHalHwInfo, pGrExceptionData) == RM_OK)
        {
            // Reset condition.
            REG_WR_DRF_DEF(_PGRAPH, _INTR, _MISSING_HW, _RESET);
        }   
    }

    if (pGrServiceArg->intr & DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _PENDING))
    {
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING))
        {
            if (nvHalGrClassSoftwareMethod_NV04(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
            }
        }

        //
        // Handle context color key workaround if necessary.
        //
        if (pGrExceptionData->Nsource & DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING))
        {
            if (_nvHalGrSetContextColorKeyWar_NV04(pHalHwInfo, pGrExceptionData) == RM_OK)
            {
                // Reset condition.
                REG_WR_DRF_DEF(_PGRAPH, _INTR, _NOTIFY, _RESET);
            }
        }
    }

    return (RM_OK);
}

RM_STATUS
nvHalGrGetNotifyData_NV04(VOID *arg)
{
    PGRGETNOTIFYDATAARG_000 pGrGetNotifyDataArg = (PGRGETNOTIFYDATAARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRNOTIFYDATA pGrNotifyData;

    //
    // Verify interface revision.
    //
    if (pGrGetNotifyDataArg->id != GR_GET_NOTIFY_DATA_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrGetNotifyDataArg->pHalHwInfo;
    pGrNotifyData = pGrGetNotifyDataArg->pGrNotifyData;

    if (REG_RD32(NV_PGRAPH_NOTIFY) &
        (DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _PENDING) |
         DRF_DEF(_PGRAPH, _NOTIFY, _STYLE, _WRITE_THEN_AWAKEN)))
    {
        pGrNotifyData->trigger = TRUE;
        pGrNotifyData->action =  REG_RD_DRF(_PGRAPH, _NOTIFY, _STYLE);
        // clear the notify condition
        FLD_WR_DRF_DEF(_PGRAPH, _NOTIFY, _REQ, _NOT_PENDING);
    } else {
        pGrNotifyData->trigger = FALSE;
        pGrNotifyData->action = 0;
    }

    return (RM_OK);
}

RM_STATUS
nvHalGrSetObjectContext_NV04(VOID *arg)
{
    PGRSETOBJECTCONTEXTARG_000 pGrSetObjectContextArg = (PGRSETOBJECTCONTEXTARG_000)arg;
    PHALHWINFO pHalHwInfo;
    U032 context, instance;
    U032 fifo;
    U032 i;

    //
    // Verify interface revision.
    //
    if (pGrSetObjectContextArg->id != GR_SET_OBJECT_CONTEXT_000)
        return (RM_ERR_VERSION_MISMATCH);

    //
    // Verify chid.
    //
    if (pGrSetObjectContextArg->chid > NUM_FIFOS_NV04)
        return (RM_ERR_BAD_ARGUMENT);

    //
    // Verify instance (what else can we do here without
    // keeping track of all objects that pass through the
    // nvHalGrAlloc interface down in the HAL?).
    //
    if (pGrSetObjectContextArg->instance == 0)
        return (RM_ERR_BAD_ARGUMENT);

    pHalHwInfo = pGrSetObjectContextArg->pHalHwInfo;
    instance = pGrSetObjectContextArg->instance;
    
    //
    // Fetch current context.
    //
    context = INST_RD32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0));

    //
    // The context surface valid bit is managed by sw on nv4, so
    // be sure it's clear when updating object context.
    //
    // Bits 31:29 in NV_PGRAPH_DEBUG_3 indicate if SetContext is being
    // handled by hardware.
    //
    if (IsNV5orBetter_NV04(pHalHwInfo->pMcHalInfo) && REG_RD32(NV_PGRAPH_DEBUG_3) & 0xe0000000)
    {
        // Context_Surface is managed by SW.
        context &= ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CONTEXT_SURFACE, _VALID));
    }

    //
    // Make necessary adjustments.
    //
    context &= pGrSetObjectContextArg->andMask;
    context |= pGrSetObjectContextArg->orMask;

    //
    // Write it back out                   
    //
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), context);
        
    //
    // Now we need to update the hardware context if appropriate.
    //
    if (pGrSetObjectContextArg->chid == REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID))
    {
        //
        // First disable the graphics fifo so we can get to the context rams
        //
        fifo = REG_RD32(NV_PGRAPH_FIFO);
        REG_WR_DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED);
            
        //
        // Walk to subchannels and see if we find a match; update when we do
        //
        for (i = 0 ; i < 8 ; i++)
        {            
            if (REG_RD32(NV_PGRAPH_CTX_CACHE4(i)) == instance)
            {   
                //
                // Get the current settings
                //
                context = REG_RD32(NV_PGRAPH_CTX_CACHE1(i));

                //
                // The context surface valid bit is managed by sw on nv4, so
                // be sure it's clear when updating object context.
                //
                // Bits 31:29 in NV_PGRAPH_DEBUG_3 indicate if SetContext is being
                // handled by hardware.
                //
                if (IsNV5orBetter_NV04(pHalHwInfo->pMcHalInfo) && REG_RD32(NV_PGRAPH_DEBUG_3) & 0xe0000000)
                {
                    // Context_Surface is managed by SW.
                    context &= ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CONTEXT_SURFACE, _VALID));
                }

                //
                // Make necessary adjustments.
                //
                context &= pGrSetObjectContextArg->andMask;
                context |= pGrSetObjectContextArg->orMask;

                //
                // Write it back out                   
                //
                REG_WR32(NV_PGRAPH_CTX_CACHE1(i), context);
            }
        }                                    
                             
        //
        // See if the currently active subchannel also needs updating
        //
        if (REG_RD_DRF(_PGRAPH, _CTX_SWITCH4, _USER_INSTANCE) == instance)
        {   
            //
            // Get the current settings
            //
            context = REG_RD32(NV_PGRAPH_CTX_SWITCH1);

            //
            // The context surface valid bit is managed by sw on nv4, so
            // be sure it's clear when updating object context.
            //
            // Bits 31:29 in NV_PGRAPH_DEBUG_3 indicate if SetContext is being
            // handled by hardware.
            //
            if (IsNV5orBetter_NV04(pHalHwInfo->pMcHalInfo) && REG_RD32(NV_PGRAPH_DEBUG_3) & 0xe0000000)
            {
                // Context_Surface is managed by SW.
                context &= ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CONTEXT_SURFACE, _VALID));
            }

            //
            // Make necessary adjustments.
            //
            context &= pGrSetObjectContextArg->andMask;
            context |= pGrSetObjectContextArg->orMask;

            //
            // Write it back out                   
            //
            REG_WR32(NV_PGRAPH_CTX_SWITCH1, context);
        }
            
        //
        // Restore the fifo state
        //
        REG_WR32(NV_PGRAPH_FIFO, fifo);
        
    }    
    return (RM_OK);
}

RM_STATUS
nvHalGrLoadOverride_NV04(VOID *arg)
{
    PGRLOADOVERRIDEARG_000 pGrLoadOverrideArg = (PGRLOADOVERRIDEARG_000)arg;
    PHALHWINFO pHalHwInfo;
    PGRHALINFO_NV04 pGrHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pGrLoadOverrideArg->id != GR_LOAD_OVERRIDE_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pGrLoadOverrideArg->pHalHwInfo;
    pGrHalPvtInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalPvtInfo;

    switch (pGrLoadOverrideArg->cmd)
    {
        case GR_LOAD_OVERRIDE_DEBUG0:
            pGrHalPvtInfo->Debug0 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG1:
            pGrHalPvtInfo->Debug1 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG2:
            pGrHalPvtInfo->Debug2 = pGrLoadOverrideArg->value;
            break;
        case GR_LOAD_OVERRIDE_DEBUG3:
            pGrHalPvtInfo->Debug3 = pGrLoadOverrideArg->value;
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalGrSetContextColorKeyWar
//
// This routine implements the workaround for the nv5 context color
// key bug.  On nv5, the NV01_CONTEXT_COLOR_KEY class is not accepted
// by classes with the SetContextColorKey method (a _DATA_ERROR
// exception is raised).
//
// If that's the case here, we munge the PGREXCEPTIONDATA structure
// to make it look like a legal method, and allow the resource manager
// to field it accordingly.
//
static RM_STATUS
_nvHalGrSetContextColorKeyWar_NV04(PHALHWINFO pHalHwInfo, PGREXCEPTIONDATA pGrExceptionData)
{
    U032 grClass;

    //
    // This WAR applies to NV5.
    //
    if (!(IsNV5orBetter_NV04(pHalHwInfo->pMcHalInfo) && REG_RD32(NV_PGRAPH_DEBUG_3) & 0xe0000000) ||
        pGrExceptionData->Instance == 0)
    {
        //
        // This isn't really an error, but by returning RM_ERROR
        // we're going to avoid clearing the pending interrupt
        // condition.
        //
        return RM_ERROR;
    }

    //
    // First determine if this is a class that requires this war.
    // The following classes supported on NV5 accept a
    // SetContextColorKey argument=NV01_CONTEXT_COLOR_KEY:
    //  NV01_IMAGE_BLIT
    //  NV01_IMAGE_FROM_CPU
    //  NV03_STRETCHED_IMAGE_FROM_CPU
    //
    if (((pGrExceptionData->classNum != NV01_IMAGE_BLIT) ||
         (pGrExceptionData->Offset != NV01F_SET_CONTEXT_COLOR_KEY)) &&
        ((pGrExceptionData->classNum != NV01_IMAGE_FROM_CPU) ||
         (pGrExceptionData->Offset != NV021_SET_CONTEXT_COLOR_KEY)) &&
        ((pGrExceptionData->classNum != NV03_STRETCHED_IMAGE_FROM_CPU) ||
         (pGrExceptionData->Offset != NV036_SET_CONTEXT_COLOR_KEY)))
    {
        return RM_ERROR;
    }

    //
    // Now check to see if Data is the instance pointer to an
    // NV01_CONTEXT_COLOR_KEY object.
    //
    grClass = INST_RD32(pGrExceptionData->Data, SF_OFFSET(NV_PRAMIN_CONTEXT_0)) & DRF_MASK(NV_PGRAPH_CTX_SWITCH1_GRCLASS);
    if (grClass == NV01_CONTEXT_COLOR_KEY)
    {
        //
        // Mark the NotifySource as an _ILLEGAL_METHOD, which will cause
        // the RM to handle it in software (which will turn on the
        // CHROMA_ENABLE bit and refresh the PATCH_STATUS bit).
        //
        pGrExceptionData->Nsource &= ~DRF_DEF(_PGRAPH, _NSOURCE, _DATA_ERROR, _PENDING);
        pGrExceptionData->Nsource |= DRF_DEF(_PGRAPH, _NSOURCE, _ILLEGAL_MTHD, _PENDING);
        return RM_OK;
    }

    return RM_ERROR;
} 

static RM_STATUS
_nvHalGrInitInstance_NV04(
    PHALHWINFO  pHalHwInfo,
    U032        instance,
    U032        classNum
)
{
    U032 ctx1, ctx2, ctx3;

    // default _CTX_SWITCH1 value
    ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, classNum)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

    // default _CTX_SWITCH2 value
    ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);

    // default _CTX_SWITCH3 value
    ctx3 = DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_0, _INVALID)
        | DRF_DEF(_PGRAPH, _CTX_SWITCH3, _DMA_INSTANCE_1, _INVALID);

    switch (classNum)
    {
        case NV01_CONTEXT_BETA:
        case NV01_CONTEXT_CLIP_RECTANGLE:
        case NV01_IMAGE_BLIT:
        case NV03_CONTEXT_ROP:
        case NV04_CONTEXT_SURFACES_2D:
        case NV03_DX3_TEXTURED_TRIANGLE:
        case NV04_CONTEXT_SURFACE_SWIZZLED:
        case NV04_CONTEXT_SURFACES_3D:
        case NV03_CONTEXT_SURFACE_2D_DESTINATION:
        case NV03_CONTEXT_SURFACE_2D_SOURCE:
        case NV03_CONTEXT_SURFACE_3D_COLOR:
        case NV03_CONTEXT_SURFACE_3D_DEPTH:
        case NV04_IMAGE_BLIT:
        case NV04_CONTEXT_BETA:
            // defaults are fine
            break;
        case NV01_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_CONTEXT_PATTERN:
        case NV04_CONTEXT_PATTERN:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16A8Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_RENDER_SOLID_LIN:
        case NV01_RENDER_SOLID_TRIANGLE:
        case NV01_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV01_IMAGE_FROM_CPU:
        case NV03_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV1_NULL:
            //
            // The NULL object is really a pseudo-dma object, so it needs a valid
            // limit value and should also have the PAGE_TABLE_PRESENT bit set.
            //
            ctx1 |= SF_DEF(_DMA, _PAGE_TABLE, _PRESENT);
            ctx2 = 0xffffffff;
            //INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), 0xFFFFFFFF);
            //FLD_WR_ISF_DEF(instance, _DMA, _PAGE_TABLE, _PRESENT);
            break;
        case NV03_SCALED_IMAGE_FROM_MEMORY:
        case NV04_SCALED_IMAGE_FROM_MEMORY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DVD_SUBPICTURE:
            //
            // DVD class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV03_MEMORY_TO_MEMORY_FORMAT:
            // Note that this object is always considered patch valid
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV03_GDI_RECTANGLE_TEXT:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _CGA6_M1)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X24Y8)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_DX5_TEXTURED_TRIANGLE:
            //
            // DX5 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_DX6_MULTI_TEXTURE_TRIANGLE:
            //
            // DX6 class is patchless, so it is always considered valid.  HW doesn't
            // use this bit, but let's set it anyway to be consistent with other
            // objects
            //
            ctx1 |= DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID);
            break;
        case NV04_CONTEXT_COLOR_KEY:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_RENDER_SOLID_LIN:
        case NV04_RENDER_SOLID_TRIANGLE:
        case NV04_RENDER_SOLID_RECTANGLE:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_X16R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV04_INDEXED_IMAGE_FROM_CPU:
        case NV04_IMAGE_FROM_CPU:
        case NV04_STRETCHED_IMAGE_FROM_CPU:
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_SCALED_IMAGE_FROM_MEMORY:
            //
            // NOTE: Eventhough we are creating an object of class NV5_SCALED_IMAGE_FROM_CPU,
            //       we have to tell the hardware we are creating the NV4 object. The hardware
            //       does not know the new object class. The only difference between the NV5 and NV4
            //       objects is a new method to set the dithering that is valid for an NV5 object.
            //       The hardware will generate an illegal method interrupt for that method and is 
            //       handled by the RM.
            //
            ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV04_SCALED_IMAGE_FROM_MEMORY)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);    

            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_A1R5G5B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_INDEXED_IMAGE_FROM_CPU:
            //
            // NOTE: Eventhough we are creating an object of class NV05_INDEXED_IMAGE_FROM_CPU,
            //       we have to tell the hardware we are creating the NV4 object. The hardware
            //       does not know the new object class. The only difference between the NV5 and NV4
            //       objects is a new method to set the dithering that is valid for an NV5 object.
            //       The hardware will generate an illegal method interrupt for that method and is 
            //       handled by the RM.
            //
            ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV04_INDEXED_IMAGE_FROM_CPU)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);

            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_IMAGE_FROM_CPU:
            //
            // NOTE: Eventhough we are creating an object of class NV05_IMAGE_FROM_CPU,
            //       we have to tell the hardware we are creating the NV4 object. The hardware
            //       does not know the new object class. The only difference between the NV5 and NV4
            //       objects is a new method to set the dithering that is valid for an NV5 object.
            //       The hardware will generate an illegal method interrupt for that method and is 
            //       handled by the RM.
            //
            ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV04_IMAGE_FROM_CPU)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        case NV05_STRETCHED_IMAGE_FROM_CPU:
            //
            // NOTE: Eventhough we are creating an object of class NV05_STRETCHED_IMAGE_FROM_CPU,
            //       we have to tell the hardware we are creating the NV4 object. The hardware
            //       does not know the new object class. The only difference between the NV5 and NV4
            //       objects is a new method to set the dithering that is valid for an NV5 object.
            //       The hardware will generate an illegal method interrupt for that method and is 
            //       handled by the RM.
            //
            ctx1 = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _GRCLASS, NV04_STRETCHED_IMAGE_FROM_CPU)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, _SRCCOPY_AND)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _INVALID);
            ctx2 = DRF_DEF(_PGRAPH, _CTX_SWITCH2, _MONO_FORMAT, _INVALID)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _COLOR_FORMAT, _LE_R5G6B5)
                | DRF_DEF(_PGRAPH, _CTX_SWITCH2, _NOTIFY_INSTANCE, _INVALID);
            break;
        default:
            return (RM_ERR_CREATE_BAD_CLASS);
    }

    //
    // Write out the values.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance data for classNum ", classNum);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      instance offset ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx1 ", ctx1);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx2 ", ctx2);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "      ctx3 ", ctx3);

    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_0), ctx1);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_1), ctx2);
    INST_WR32(instance, SF_OFFSET(NV_PRAMIN_CONTEXT_2), ctx3);

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv\halwrap.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* HAL Interface Wrappers **************************\
*                                                                           *
* Module: halwrap.c                                                         *
*                                                                           *
* This source module contains wrappers around the HAL interfaces that       *
* are useful for packaging up arguments into the proper revision-specific   *
* data structure.                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>

#undef  nvAddr
#undef  ChipBugs
#define ChipBugs pHalHwInfo->pMcHalInfo->ChipBugs

//-------------------------------------------------------------------
// MC interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalMcControl(PHWINFO pDev, U032 cmd)
{
    MCCONTROLARG_000 mcControlArg;

    mcControlArg.id = MC_CONTROL_000;
    mcControlArg.cmd = cmd;
    mcControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalMcControl)((VOID *)&mcControlArg));
}

RM_STATUS
nvHalMcPower(PHWINFO pDev, U032 newLevel, U032 oldLevel)
{
    MCPOWERARG_000 mcPowerArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcPower oldLevel ", oldLevel);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcPower newLevel ", newLevel);

    mcPowerArg.id = MC_POWER_000;
    mcPowerArg.newLevel = newLevel;
    mcPowerArg.oldLevel = oldLevel;
    mcPowerArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalMcPower)((VOID *)&mcPowerArg));
}

//-------------------------------------------------------------------
// Fifo interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalFifoControl(PHWINFO pDev, U032 cmd)
{
    FIFOCONTROLARG_000 fifoControlArg;

    fifoControlArg.id = FIFO_CONTROL_000;
    fifoControlArg.cmd = cmd;
    fifoControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoControl)((VOID *)&fifoControlArg));
}

RM_STATUS
nvHalFifoAllocPio(PHWINFO pDev, U032 chid, U032 instance)
{
    FIFOALLOCPIOARG_000 fifoAllocArg;

    fifoAllocArg.id = FIFO_ALLOC_PIO_000;
    fifoAllocArg.chid = chid;
    fifoAllocArg.instance = instance;
    fifoAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoAllocPio)((VOID *)&fifoAllocArg));
}

RM_STATUS
nvHalFifoAllocDma(PHWINFO pDev, U032 chid, U032 instance, U032 dmaInstance, U032 fetchTrigger, U032 fetchSize, U032 fetchRequests)
{
    FIFOALLOCDMAARG_000 fifoAllocArg;

    fifoAllocArg.id = FIFO_ALLOC_DMA_000;
    fifoAllocArg.chid = chid;
    fifoAllocArg.instance = instance;
    fifoAllocArg.dmaInstance = dmaInstance;
    fifoAllocArg.fetchTrigger = fetchTrigger;
    fifoAllocArg.fetchSize = fetchSize;
    fifoAllocArg.fetchRequests = fetchRequests;
    fifoAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoAllocDma)((VOID *)&fifoAllocArg));
}

RM_STATUS
nvHalFifoFree(PHWINFO pDev, U032 chid, U032 instance)
{
    FIFOFREEARG_000 fifoFreeArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "nvHalFifoFree: chid ", chid);

    fifoFreeArg.id = FIFO_FREE_000;
    fifoFreeArg.chid = chid;
    fifoFreeArg.instance = instance;
    fifoFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoFree)((VOID *)&fifoFreeArg));
}

RM_STATUS
nvHalFifoGetExceptionData(PHWINFO pDev, PFIFOEXCEPTIONDATA pFifoExceptionData)
{
    FIFOGETEXCEPTIONDATAARG_000 fifoGetExceptionDataArg;

    fifoGetExceptionDataArg.id = FIFO_GET_EXCEPTION_DATA_000;
    fifoGetExceptionDataArg.pExceptionData = pFifoExceptionData;
    fifoGetExceptionDataArg.pHalHwInfo = &pDev->halHwInfo;
    
    return (HALFUNC_000(_nvHalFifoGetExceptionData)((VOID *)&fifoGetExceptionDataArg));
}

RM_STATUS
nvHalFifoService(PHWINFO pDev, U032 intr, PFIFOEXCEPTIONDATA pFifoExceptionData)
{
    FIFOSERVICEARG_000 fifoServiceArg;

    fifoServiceArg.id = FIFO_SERVICE_000;
    fifoServiceArg.intr = intr;
    fifoServiceArg.pExceptionData = pFifoExceptionData;
    fifoServiceArg.pHalHwInfo = &pDev->halHwInfo;
    
    return (HALFUNC_000(_nvHalFifoService)((VOID *)&fifoServiceArg));
}

RM_STATUS
nvHalFifoAccess(PHWINFO pDev, U032 cmd, PFIFOACCESSINFO pFifoAccessInfo)
{
    FIFOACCESSARG_000 fifoAccessArg;

    fifoAccessArg.id = FIFO_ACCESS_000;
    fifoAccessArg.cmd = cmd;
    fifoAccessArg.pAccessInfo = pFifoAccessInfo;
    fifoAccessArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoAccess)((VOID *)&fifoAccessArg));
}

RM_STATUS
nvHalFifoHashAdd(PHWINFO pDev, U032 entry, U032 handle, U032 chid, U032 instance, U032 engine)
{
    FIFOHASHADDARG_000 fifoHashAddArg;

    fifoHashAddArg.id = FIFO_HASH_ADD_000;
    fifoHashAddArg.entry = entry;
    fifoHashAddArg.handle = handle;
    fifoHashAddArg.chid = chid;
    fifoHashAddArg.instance = instance;
    fifoHashAddArg.engine = engine;
    fifoHashAddArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoHashAdd)((VOID *)&fifoHashAddArg));
}

RM_STATUS
nvHalFifoHashDelete(PHWINFO pDev, U032 entry)
{
    FIFOHASHDELETEARG_000 fifoHashDeleteArg;

    fifoHashDeleteArg.id = FIFO_HASH_DELETE_000;
    fifoHashDeleteArg.entry = entry;
    fifoHashDeleteArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFifoHashDelete)((VOID *)&fifoHashDeleteArg));
}

RM_STATUS
nvHalFifoHashFunc(PHWINFO pDev, U032 handle, U032 chid, U032 *result)
{
    FIFOHASHFUNCARG_000 fifoHashFuncArg;
    RM_STATUS status;

    fifoHashFuncArg.id = FIFO_HASH_FUNC_000;
    fifoHashFuncArg.handle = handle;
    fifoHashFuncArg.chid = chid;
    fifoHashFuncArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalFifoHashFunc)((VOID *)&fifoHashFuncArg);
    *result = fifoHashFuncArg.result;

    return (status);
}

RM_STATUS
nvHalFifoHashSearch(PHWINFO pDev, U032 handle, U032 chid, U032 *result)
{
    FIFOHASHSEARCHARG_000 fifoHashSearchArg;
    RM_STATUS status;

    fifoHashSearchArg.id = FIFO_HASH_SEARCH_000;
    fifoHashSearchArg.handle = handle;
    fifoHashSearchArg.chid = chid;
    fifoHashSearchArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalFifoHashSearch)((VOID *)&fifoHashSearchArg);
    *result = fifoHashSearchArg.result;

    return (status);
}

//-------------------------------------------------------------------
// Fb interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalFbControl(PHWINFO pDev, U032 cmd)
{
    FBCONTROLARG_000 fbControlArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalFbControl cmd ", cmd);

    fbControlArg.id = FB_CONTROL_000;
    fbControlArg.cmd = cmd;
    fbControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFbControl)((VOID *)&fbControlArg));
}

RM_STATUS
nvHalFbAlloc(PHWINFO pDev, PFBALLOCINFO pFbAllocInfo)
{
    FBALLOCARG_000 fbAllocArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalFbAlloc type ", pFbAllocInfo->type);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                   height ", pFbAllocInfo->height);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                   pitch ", pFbAllocInfo->pitch);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                   size ", pFbAllocInfo->size);

    fbAllocArg.id = FB_ALLOC_000;
    if (pDev->Framebuffer.NoAdjustedPitch) {
        if (pFbAllocInfo->height <= 600)
            fbAllocArg.flags = FB_ALLOC_NO_PITCH_ADJUST;
        else
            fbAllocArg.flags = 0;
    } else
        fbAllocArg.flags = 0;
    fbAllocArg.pAllocInfo = pFbAllocInfo;
    fbAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFbAlloc)((VOID *)&fbAllocArg));
}

RM_STATUS
nvHalFbFree(PHWINFO pDev, U032 hwResId)
{
    FBFREEARG_000 fbFreeArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalFbFree hwresid ", hwResId);

    fbFreeArg.id = FB_FREE_000;
    fbFreeArg.hwResId = hwResId;
    fbFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFbFree)((VOID *)&fbFreeArg));
}

RM_STATUS
nvHalFbSetAllocParameters(PHWINFO pDev, PFBALLOCINFO pFbAllocInfo)
{
    FBSETALLOCPARAMSARG_000 fbSetAllocParamsArg;

    fbSetAllocParamsArg.id = FB_SET_ALLOC_PARAMS_000;
    fbSetAllocParamsArg.pAllocInfo = pFbAllocInfo;
    fbSetAllocParamsArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFbSetAllocParameters)((VOID *)&fbSetAllocParamsArg));
}

RM_STATUS
nvHalFbGetSurfacePitch(PHWINFO pDev, U032 width, U032 bpp, U032 *pitch)
{
    FBGETSURFACEPITCHARG_000 fbGetSurfacePitchArg;
    RM_STATUS status;

    fbGetSurfacePitchArg.id = FB_GET_SURFACE_PITCH_000;
    if (pDev->Framebuffer.NoAdjustedPitch) {
        if (width <= 800)
            fbGetSurfacePitchArg.flags = FB_GET_SURFACE_PITCH_NO_ADJUST;
        else
            fbGetSurfacePitchArg.flags = 0;
    } else
        fbGetSurfacePitchArg.flags = 0;
    fbGetSurfacePitchArg.width = width;
    fbGetSurfacePitchArg.bpp = bpp;
    fbGetSurfacePitchArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalFbGetSurfacePitch)((VOID *)&fbGetSurfacePitchArg);
    *pitch = fbGetSurfacePitchArg.pitch;

    return (status);
}

RM_STATUS
nvHalFbGetSurfaceDimensions(PHWINFO pDev, U032 width, U032 height, U032 bpp, U032 *pitch, U032 *size)
{
    FBGETSURFACEDIMENSIONSARG_000 fbGetSurfaceDimensionsArg;
    RM_STATUS status;

    fbGetSurfaceDimensionsArg.id = FB_GET_SURFACE_DIMENSIONS_000;
    if (pDev->Framebuffer.NoAdjustedPitch) {
        if (width <= 800)
            fbGetSurfaceDimensionsArg.flags = FB_GET_SURFACE_PITCH_NO_ADJUST;
        else
            fbGetSurfaceDimensionsArg.flags = 0;
    } else
        fbGetSurfaceDimensionsArg.flags = 0;
    fbGetSurfaceDimensionsArg.width = width;
    fbGetSurfaceDimensionsArg.height = height;
    fbGetSurfaceDimensionsArg.bpp = bpp;
    fbGetSurfaceDimensionsArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalFbGetSurfaceDimensions)((VOID *)&fbGetSurfaceDimensionsArg);
    *pitch = fbGetSurfaceDimensionsArg.pitch;
    *size  = fbGetSurfaceDimensionsArg.size;

    return (status);
}

RM_STATUS
nvHalFbLoadOverride(PHWINFO pDev, U032 cmd, U032 value)
{
    FBLOADOVERRIDEARG_000 fbLoadOverrideArg;

    fbLoadOverrideArg.id = FB_LOAD_OVERRIDE_000;
    fbLoadOverrideArg.cmd = cmd;
    fbLoadOverrideArg.value = value;
    fbLoadOverrideArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalFbLoadOverride)((VOID *)&fbLoadOverrideArg));
}

//-------------------------------------------------------------------
// Gr interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalGrControl(PHWINFO pDev, U032 cmd)
{
    GRCONTROLARG_000 grControlArg;

    grControlArg.id = GR_CONTROL_000;
    grControlArg.cmd = cmd;
    grControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrControl)((VOID *)&grControlArg));
}

RM_STATUS
nvHalGrAlloc(PHWINFO pDev, U032 chid, U032 instance, U032 classNum)
{
    GRALLOCARG_000 grAllocArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrAlloc chid ", chid);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:              instance ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:              classNum ", classNum);

    grAllocArg.id = GR_ALLOC_000;
    grAllocArg.classNum = classNum;
    grAllocArg.instance = instance;
    grAllocArg.chid = chid; 
    grAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrAlloc)((VOID *)&grAllocArg));
}

RM_STATUS
nvHalGrFree(PHWINFO pDev, U032 chid, U032 instance)
{
    GRFREEARG_000 grFreeArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrFree instance ", instance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalGrFree chid ", chid);

    grFreeArg.id = GR_FREE_000;
    grFreeArg.chid = chid;
    grFreeArg.instance = instance;
    grFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrFree)((VOID *)&grFreeArg));
}

RM_STATUS
nvHalGrGetExceptionData(PHWINFO pDev, PGREXCEPTIONDATA pGrExceptionData)
{
    GRGETEXCEPTIONDATAARG_000 grGetExceptionDataArg;

    grGetExceptionDataArg.id = GR_GET_EXCEPTION_DATA_000;
    grGetExceptionDataArg.pExceptionData = pGrExceptionData;
    grGetExceptionDataArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrGetExceptionData)((VOID *)&grGetExceptionDataArg));
}

RM_STATUS
nvHalGrService(PHWINFO pDev, U032 intr, PGREXCEPTIONDATA pGrExceptionData)
{
    GRSERVICEARG_000 grServiceArg;

    grServiceArg.id = GR_SERVICE_000;
    grServiceArg.intr = intr;
    grServiceArg.pExceptionData = pGrExceptionData;
    grServiceArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrService)((VOID *)&grServiceArg));
}

RM_STATUS
nvHalGrGetNotifyData(PHWINFO pDev, PGRNOTIFYDATA pGrNotifyData)
{
    GRGETNOTIFYDATAARG_000 grGetNotifyDataArg;

    grGetNotifyDataArg.id = GR_GET_NOTIFY_DATA_000;
    grGetNotifyDataArg.pGrNotifyData = pGrNotifyData;
    grGetNotifyDataArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrGetNotifyData)((VOID *)&grGetNotifyDataArg));
}

RM_STATUS
nvHalGrSetObjectContext(PHWINFO pDev, U032 andMask, U032 orMask, U032 chid, U032 instance)
{
    GRSETOBJECTCONTEXTARG_000 grSetObjectContextArg;

    grSetObjectContextArg.id = GR_SET_OBJECT_CONTEXT_000;
    grSetObjectContextArg.andMask = andMask;
    grSetObjectContextArg.orMask = orMask;
    grSetObjectContextArg.instance = instance;
    grSetObjectContextArg.chid = chid;
    grSetObjectContextArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrSetObjectContext)((VOID *)&grSetObjectContextArg));
}

RM_STATUS
nvHalGrLoadOverride(PHWINFO pDev, U032 cmd, U032 value)
{
    GRLOADOVERRIDEARG_000 grLoadOverrideArg;

    grLoadOverrideArg.id = GR_LOAD_OVERRIDE_000;
    grLoadOverrideArg.cmd = cmd;
    grLoadOverrideArg.value = value;
    grLoadOverrideArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalGrLoadOverride)((VOID *)&grLoadOverrideArg));
}

//-------------------------------------------------------------------
// Dma interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalDmaControl(PHWINFO pDev, U032 cmd)
{
    DMACONTROLARG_000 dmaControlArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalDmaControl cmd ", cmd);

    dmaControlArg.id = DMA_CONTROL_000;
    dmaControlArg.cmd = cmd;
    dmaControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDmaControl)((VOID *)&dmaControlArg));

}

RM_STATUS
nvHalDmaAlloc(PHWINFO pDev, PDMAHALOBJINFO pDmaHalObjInfo)
{
    DMAALLOCARG_000 dmaAllocArg;
    
    dmaAllocArg.id = DMA_ALLOC_000;
    dmaAllocArg.pHalObjInfo = pDmaHalObjInfo;
    dmaAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDmaAlloc)((VOID *)&dmaAllocArg));
}

RM_STATUS
nvHalDmaFree(PHWINFO pDev, PDMAHALOBJINFO pDmaHalObjInfo)
{
    DMAFREEARG_000 dmaFreeArg;
    
    dmaFreeArg.id = DMA_FREE_000;
    dmaFreeArg.pHalObjInfo = pDmaHalObjInfo;
    dmaFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDmaFree)((VOID *)&dmaFreeArg));
}

RM_STATUS
nvHalDmaGetInstSize(PHWINFO pDev, PDMAHALOBJINFO pDmaHalObjInfo)
{
    DMAGETINSTSIZEARG_000 dmaGetInstSizeArg;
    
    dmaGetInstSizeArg.id = DMA_GET_INSTSIZE_000;
    dmaGetInstSizeArg.pHalObjInfo = pDmaHalObjInfo;
    dmaGetInstSizeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDmaGetInstSize)((VOID *)&dmaGetInstSizeArg));
}

//-------------------------------------------------------------------
// Dac interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalDacControl(PHWINFO pDev, U032 cmd)
{
    DACCONTROLARG_000 dacControlArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalDacControl cmd ", cmd);

    dacControlArg.id = DAC_CONTROL_000;
    dacControlArg.cmd = cmd;
    dacControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacControl)((VOID *)&dacControlArg));
}

RM_STATUS
nvHalDacAlloc(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    DACALLOCARG_000 dacAllocArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "nvHalDacAlloc: classNum ", classNum);

    dacAllocArg.id = DAC_ALLOC_000;
    dacAllocArg.chid = chid;
    dacAllocArg.instance = instance;
    dacAllocArg.classNum = classNum;
    dacAllocArg.pHalObjInfo = pHalObj;
    dacAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacAlloc)((VOID *)&dacAllocArg));
}

RM_STATUS
nvHalDacFree(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    DACFREEARG_000 dacFreeArg;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "nvHalDacFree: classNum ", classNum);

    dacFreeArg.id = DAC_FREE_000;
    dacFreeArg.chid = chid;
    dacFreeArg.instance = instance;
    dacFreeArg.classNum = classNum;
    dacFreeArg.pHalObjInfo = pHalObj;
    dacFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacFree)((VOID *)&dacFreeArg));
}

RM_STATUS
nvHalDacSetStartAddr(PHWINFO pDev, U032 startAddr, VOID *pHalObj)
{
    DACSETSTARTADDRARG_000 dacSetStartAddrArg;

    dacSetStartAddrArg.id = DAC_SET_START_ADDR_000;
    dacSetStartAddrArg.startAddr = startAddr;
    dacSetStartAddrArg.pHalObjInfo = pHalObj;
    dacSetStartAddrArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacSetStartAddr)((VOID *)&dacSetStartAddrArg));
}

RM_STATUS
nvHalDacProgramMClk(PHWINFO pDev)
{
    DACPROGRAMMCLKARG_000   dacProgramMClkArg;

    dacProgramMClkArg.id = DAC_PROGRAMMCLK_000;
    dacProgramMClkArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacProgramMClk)((VOID *)&dacProgramMClkArg));
}

RM_STATUS
nvHalDacProgramNVClk(PHWINFO pDev)
{
    DACPROGRAMNVCLKARG_000  dacProgramNVClkArg;

    dacProgramNVClkArg.id = DAC_PROGRAMNVCLK_000;
    dacProgramNVClkArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalDacProgramNVClk)((VOID *)&dacProgramNVClkArg));
}

RM_STATUS
nvHalDacProgramPClk(PHWINFO pDev, U032 PixelClock, VOID *pHalObj)
{
    DACPROGRAMPCLKARG_000   dacProgramPClkArg;

    dacProgramPClkArg.id = DAC_PROGRAMPCLK_000;
    dacProgramPClkArg.pHalHwInfo = &pDev->halHwInfo;
    dacProgramPClkArg.pHalObjInfo = pHalObj;
    dacProgramPClkArg.PixelClock = PixelClock;

    return (HALFUNC_000(_nvHalDacProgramPClk)((VOID *)&dacProgramPClkArg));
}

RM_STATUS
nvHalDacProgramCursorImage(PHWINFO pDev, U032 startAddr, U032 asi,
                           U032 width, U032 height, U032 colorFormat, VOID *pHalObj)
{
    DACPROGRAMCURSORARG_000     dacProgramCursorImgArg;
    
    dacProgramCursorImgArg.id = DAC_PROGRAMCURSOR_000;
    dacProgramCursorImgArg.pHalHwInfo = &pDev->halHwInfo;
    dacProgramCursorImgArg.pHalObjInfo = pHalObj;
    dacProgramCursorImgArg.startAddr = startAddr;
    dacProgramCursorImgArg.asi = asi;
    dacProgramCursorImgArg.width = width;
    dacProgramCursorImgArg.height = height;
    dacProgramCursorImgArg.colorFormat = colorFormat;

    return (HALFUNC_000(_nvHalDacProgramCursorImage)((VOID *)&dacProgramCursorImgArg));
}

RM_STATUS
nvHalDacGetRasterPosition(PHWINFO pDev, U016 *result, VOID *pHalObj)
{
    DACRASTERPOSARG_000    dacRasterPosArg;
    RM_STATUS status;

    dacRasterPosArg.id = DAC_RASTERPOS_000;
    dacRasterPosArg.pHalHwInfo = &pDev->halHwInfo;
    dacRasterPosArg.pHalObjInfo = pHalObj;

    // fills in dacRasterPosArg.result
    status = HALFUNC_000(_nvHalDacGetRasterPosition)((VOID *)&dacRasterPosArg);

    *result = dacRasterPosArg.result;

    return status;
}

RM_STATUS
nvHalDacValidateArbSettings(PHWINFO pDev, U032 bpp, U032 video_enabled, U032 mport_enabled, U032 vclk, U032 *result)
{
    DACVALIDATEARBSETTINGSARG_000   dacValidateArbSettingsArg;
    RM_STATUS status;

    dacValidateArbSettingsArg.id = DAC_VALIDATEARBSETTINGS_000;
    dacValidateArbSettingsArg.pHalHwInfo = &pDev->halHwInfo;
    dacValidateArbSettingsArg.bpp = bpp;
    dacValidateArbSettingsArg.video_enabled = video_enabled;
    dacValidateArbSettingsArg.mport_enabled = mport_enabled;
    dacValidateArbSettingsArg.vclk = vclk;

    // fills in dacValidateArbSettingsArg.result
    status = HALFUNC_000(_nvHalDacValidateArbSettings)((VOID *)&dacValidateArbSettingsArg);

    *result = dacValidateArbSettingsArg.result;

    return status;
}

RM_STATUS
nvHalDacUpdateArbSettings(PHWINFO pDev, VOID *pHalObj)
{
    DACUPDATEARBSETTINGSARG_000     dacUpdateArbSettingsArg;
    
    dacUpdateArbSettingsArg.id = DAC_UPDATEARBSETTINGS_000;
    dacUpdateArbSettingsArg.pHalHwInfo = &pDev->halHwInfo;
    dacUpdateArbSettingsArg.pHalObjInfo = pHalObj;

    return (HALFUNC_000(_nvHalDacUpdateArbSettings)((VOID *)&dacUpdateArbSettingsArg));
}

//-------------------------------------------------------------------
// Mediaport interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalMpControl(PHWINFO pDev, U032 cmd)
{
    MPCONTROLARG_000 mpControlArg;

    mpControlArg.id = MP_CONTROL_000;
    mpControlArg.cmd = cmd;
    mpControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalMpControl)((VOID *)&mpControlArg));
}

RM_STATUS
nvHalMpAlloc(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    MPALLOCARG_000 mpAllocArg;

    mpAllocArg.id = MP_ALLOC_000;
    mpAllocArg.chid = chid;
    mpAllocArg.instance = instance;
    mpAllocArg.classNum = classNum;
    mpAllocArg.pHalObjInfo = pHalObj;
    mpAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalMpAlloc)((VOID *)&mpAllocArg));
}

RM_STATUS
nvHalMpFree(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    MPFREEARG_000 mpFreeArg;

    mpFreeArg.id = MP_FREE_000;
    mpFreeArg.chid = chid;
    mpFreeArg.instance = instance;
    mpFreeArg.classNum = classNum;
    mpFreeArg.pHalObjInfo = pHalObj;
    mpFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalMpFree)((VOID *)&mpFreeArg));
}

RM_STATUS
nvHalMpMethod(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 offset, U032 data, U032 *mthdStatus)
{
    MPMETHODARG_000 mpMethodArg;
    RM_STATUS status;

    mpMethodArg.id = MP_METHOD_000;
    mpMethodArg.classNum = classNum;
    mpMethodArg.pHalObjInfo = pHalObj;
    mpMethodArg.offset = offset;
    mpMethodArg.data = data;
    mpMethodArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalMpMethod)((VOID *)&mpMethodArg);

    if (mthdStatus)
        *mthdStatus = mpMethodArg.mthdStatus;

    return status;
}

RM_STATUS
nvHalMpGetEventStatus(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 *pEventsPending, V032 *pIntrStatus)
{
    RM_STATUS status;
    MPGETEVENTSTATUSARG_000 mpGetEventStatusArg;

    mpGetEventStatusArg.id = MP_GET_EVENT_STATUS_000;
    mpGetEventStatusArg.classNum = classNum;
    mpGetEventStatusArg.pHalObjInfo = pHalObj;
    mpGetEventStatusArg.events = *pEventsPending;
    mpGetEventStatusArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalMpGetEventStatus)((VOID *)&mpGetEventStatusArg);
    *pEventsPending = mpGetEventStatusArg.events;
    *pIntrStatus = mpGetEventStatusArg.intrStatus;

    return status;
}

RM_STATUS
nvHalMpServiceEvent(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 eventPending, V032 *pIntrStatus)
{
    RM_STATUS status;
    MPSERVICEEVENTARG_000 mpServiceEventArg;

    mpServiceEventArg.id = MP_SERVICE_EVENT_000;
    mpServiceEventArg.classNum = classNum;
    mpServiceEventArg.pHalObjInfo = pHalObj;
    mpServiceEventArg.event = eventPending;
    mpServiceEventArg.intrStatus = *pIntrStatus;
    mpServiceEventArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalMpServiceEvent)((VOID *)&mpServiceEventArg);
    *pIntrStatus = mpServiceEventArg.intrStatus;

    return status;
}

//-------------------------------------------------------------------
// Video interface wrappers
//-------------------------------------------------------------------
RM_STATUS
nvHalVideoControl(PHWINFO pDev, U032 cmd)
{
    VIDEOCONTROLARG_000 videoControlArg;

    videoControlArg.id = VIDEO_CONTROL_000;
    videoControlArg.cmd = cmd;
    videoControlArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalVideoControl)((VOID *)&videoControlArg));
}

RM_STATUS
nvHalVideoAlloc(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    VIDEOALLOCARG_000 videoAllocArg;

    videoAllocArg.id = VIDEO_ALLOC_000;
    videoAllocArg.chid = chid;
    videoAllocArg.instance = instance;
    videoAllocArg.classNum = classNum;
    videoAllocArg.pHalObjInfo = pHalObj;
    videoAllocArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalVideoAlloc)((VOID *)&videoAllocArg));
}

RM_STATUS
nvHalVideoFree(PHWINFO pDev, U032 chid, U032 instance, U032 classNum, VOID *pHalObj)
{
    VIDEOFREEARG_000 videoFreeArg;

    videoFreeArg.id = VIDEO_FREE_000;
    videoFreeArg.chid = chid;
    videoFreeArg.instance = instance;
    videoFreeArg.classNum = classNum;
    videoFreeArg.pHalObjInfo = pHalObj;
    videoFreeArg.pHalHwInfo = &pDev->halHwInfo;

    return (HALFUNC_000(_nvHalVideoFree)((VOID *)&videoFreeArg));
}

RM_STATUS
nvHalVideoMethod(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 offset, U032 data, U032 *mthdStatus)
{
    VIDEOMETHODARG_000 videoMethodArg;
    RM_STATUS status;

    videoMethodArg.id = VIDEO_METHOD_000;
    videoMethodArg.classNum = classNum;
    videoMethodArg.pHalObjInfo = pHalObj;
    videoMethodArg.offset = offset;
    videoMethodArg.data = data;
    videoMethodArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalVideoMethod)((VOID *)&videoMethodArg);
    if (mthdStatus)
        *mthdStatus = videoMethodArg.mthdStatus;
    
    return (status);
}

RM_STATUS
nvHalVideoGetEventStatus(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 *pEvents, V032 *pIntrStatus)
{
    RM_STATUS status;
    VIDEOGETEVENTSTATUSARG_000 videoGetEventStatusArg;

    videoGetEventStatusArg.id = VIDEO_GET_EVENT_STATUS_000;
    videoGetEventStatusArg.classNum = classNum;
    videoGetEventStatusArg.pHalObjInfo = pHalObj;
    videoGetEventStatusArg.events = 0;
    videoGetEventStatusArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalVideoGetEventStatus)((VOID *)&videoGetEventStatusArg);
    *pEvents = videoGetEventStatusArg.events;
    *pIntrStatus = videoGetEventStatusArg.intrStatus;

    return status;
}

RM_STATUS
nvHalVideoServiceEvent(PHWINFO pDev, U032 classNum, VOID *pHalObj, U032 events, V032 *pIntrStatus)
{
    RM_STATUS status;
    VIDEOSERVICEEVENTARG_000 videoServiceEventArg;

    videoServiceEventArg.id = VIDEO_SERVICE_EVENT_000;
    videoServiceEventArg.classNum = classNum;
    videoServiceEventArg.pHalObjInfo = pHalObj;
    videoServiceEventArg.events = events;
    videoServiceEventArg.intrStatus = *pIntrStatus;
    videoServiceEventArg.pHalHwInfo = &pDev->halHwInfo;

    status = HALFUNC_000(_nvHalVideoServiceEvent)((VOID *)&videoServiceEventArg);
    *pIntrStatus = videoServiceEventArg.intrStatus;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv\halinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** HAL Initialization/Destruction *********************\
*                                                                           *
* Module: halinit.c                                                         *
*                                                                           *
* This source module contains the HAL initialize and tear-down code.        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <fb.h>
#include <nvhal.h>
#include "nvhw.h"

// statics
static RM_STATUS allocHalEngineMem(PHWINFO);
RM_STATUS allocHalEngineInstMem(PHWINFO);
RM_STATUS freeHalEngineInstMem(PHWINFO);

//
// initHal
//
// It all starts here.  Id the chip represented by pDev and
// wire up the correct hal data/code. Generate the class database
// and allocate any engine-specific resources (e.g. instance memory).
//
RM_STATUS
initHal(PHWINFO pDev)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    U032 pmcBoot0;
    RM_STATUS status;
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;

    //
    // Hook up chip-dependent data.
    //
    pmcBoot0 = REG_RD32(NV_PMC_BOOT_0);

#ifdef DEBUG
    //
    // This check will catch the case where we haven't yet mapped the regs.
    //
    if (pmcBoot0 == 0xffffffff)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: registers not mapped in initHal\n\r!");
        DBG_BREAKPOINT();
        return RM_ERROR;
    }
#endif

    //
    // Check for nv4 and family using the old-style PMC_BOOT_0 format.
    // Check for nv10 and beyond using new-style format.
    //
    if (DRF_VAL(_PMC, _BOOT_0, _ARCHITECTURE, pmcBoot0) == NV_PMC_BOOT_0_ARCHITECTURE_NV4)
    {
        U032 impl = REG_RD_DRF(_PMC, _BOOT_0, _MASK_REVISION);  // implementation

        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: hooking up NV4 HAL\n");
        pDev->pHalFuncs = (PHALFUNCS)&NV04_HalFuncs_000;
        pDev->engineDB.pEngineDescriptors = NV04_EngineDescriptors;
        pDev->engineDB.numEngineDescriptors = NV04_NumEngineDescs;
        if (impl == MC_IMPLEMENTATION_NV04) {
            pDev->classDB.pClassDescriptors = NV04_ClassDescriptors;
            pDev->classDB.numClassDescriptors = NV04_NumClassDescs;
        } else {
            pDev->classDB.pClassDescriptors = NV05_ClassDescriptors;
            pDev->classDB.numClassDescriptors = NV05_NumClassDescs;
        }
    }
    else if (MC_GET_ARCHITECTURE(pmcBoot0) == MC_ARCHITECTURE_NV10)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: hooking up NV10 HAL\n");
        pDev->pHalFuncs = (PHALFUNCS)&NV10_HalFuncs_000;
        pDev->engineDB.pEngineDescriptors = NV10_EngineDescriptors;
        pDev->engineDB.numEngineDescriptors = NV10_NumEngineDescs;
        if (MC_GET_IMPLEMENTATION(pmcBoot0) == MC_IMPLEMENTATION_NV10) {
            pDev->classDB.pClassDescriptors =   NV10_ClassDescriptors;
            pDev->classDB.numClassDescriptors = NV10_NumClassDescs;
        } else if (MC_GET_IMPLEMENTATION(pmcBoot0) == MC_IMPLEMENTATION_NV15) {
            pDev->classDB.pClassDescriptors =   NV15_ClassDescriptors;
            pDev->classDB.numClassDescriptors = NV15_NumClassDescs;
        } else if (MC_GET_IMPLEMENTATION(pmcBoot0) == MC_IMPLEMENTATION_NV11) {
            pDev->classDB.pClassDescriptors =   NV11_ClassDescriptors;
            pDev->classDB.numClassDescriptors = NV11_NumClassDescs;
        }
    }
    else if (MC_GET_ARCHITECTURE(pmcBoot0) == MC_ARCHITECTURE_NV20)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: hooking up NV20 HAL\n");
        pDev->pHalFuncs = (PHALFUNCS)&NV20_HalFuncs_000;
        pDev->engineDB.pEngineDescriptors = NV20_EngineDescriptors;
        pDev->engineDB.numEngineDescriptors = NV20_NumEngineDescs;
        pDev->classDB.pClassDescriptors = NV20_ClassDescriptors;
        pDev->classDB.numClassDescriptors = NV20_NumClassDescs;
    }
    else
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: unknown architecture in pmcboot0", pmcBoot0);
        DBG_BREAKPOINT();
        return RM_ERROR;
    }

    //
    // Allocate space for HAL private areas (ENGMALLOC_TYPE_PRIVATE buffers).
    //
    status = allocHalEngineMem(pDev);

    //
    // Initialize mapped device/fb addresses.  Note that on some
    // platforms (i.e. nt), we'll be asked to setup the HAL before
    // the framebuffer is mapped.  The initHalMappings call can be
    // used to handle such cases (see below).
    //
    pHalHwInfo->nvBaseAddr = pDev->DBnvAddr;
    pHalHwInfo->fbBaseAddr = pDev->DBfbAddr;

    //
    // Setup up RM services table pointer.
    //
    pHalHwInfo->pHalRmFuncs = (PHALRMFUNCS)&HalRmFuncs_000;

    //
    // Save off (opaque) device identifier.
    //
    pHalHwInfo->pDeviceId = (VOID_PTR)pDev;

    //
    // Initialize HAL info pointers.
    //
    pHalHwInfo->pProcessorHalInfo = &pRmInfo->Processor.HalInfo;
    pHalHwInfo->pMcHalInfo = &pDev->Chip.HalInfo;
    pHalHwInfo->pPramHalInfo = &pDev->Pram.HalInfo;
    pHalHwInfo->pFifoHalInfo = &pDev->Fifo.HalInfo;
    pHalHwInfo->pFbHalInfo = &pDev->Framebuffer.HalInfo;
    pHalHwInfo->pGrHalInfo = &pDev->Graphics.HalInfo;
    pHalHwInfo->pDacHalInfo = &pDev->Dac.HalInfo;
    pHalHwInfo->pDmaHalInfo = &pDev->Dma.HalInfo;
    pHalHwInfo->pVideoHalInfo = &pDev->Video.HalInfo;
    pHalHwInfo->pMpHalInfo = &pDev->MediaPort.HalInfo;

    //
    // Now create class database.
    //
    status = classBuildDB(&pDev->engineDB, &pDev->classDB);
    if (status != RM_OK)
    {   
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: classBuildDB failure ", status);
        osFreeMem((VOID *)pDev->pHalEngineMem);
        pDev->pHalEngineMem = 0;
    }
    return (status);
}

RM_STATUS
destroyHal(PHWINFO pDev)
{
    classDestroyDB(&pDev->classDB);
    freeHalEngineInstMem(pDev);
    osFreeMem((VOID *)pDev->pHalEngineMem);

    return (RM_OK);
}

//
// initHalMappings
//
// This routine moves the mapped register/framebuffer addresses into
// into the HwInfo struct (pDev) into the HalHwInfo struct.
//
RM_STATUS
initHalMappings(PHWINFO pDev)
{
    //
    // Initialize mapped device/fb addresses.
    //
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: initHal: nvAddr ", pDev->DBnvAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: initHal: fbAddr ", pDev->DBfbAddr);

    pDev->halHwInfo.nvBaseAddr = pDev->DBnvAddr;
    pDev->halHwInfo.fbBaseAddr = pDev->DBfbAddr;
    
    return (RM_OK);
}

//
// allocHalEngineMem
//
// Setup HAL engine private data areas using info from
// engine descriptor table.
//
static RM_STATUS
allocHalEngineMem(PHWINFO pDev)
{
    U008 *pHalData;
    RM_STATUS status;
    U032 i, tag, size;
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PENGINEDB pEngineDB  = &pDev->engineDB;

    //
    // Start by scanning engine descriptor table for number of ENGMALLOC
    // instructions.
    //
    size = 0; pHalData = NULL;
    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if ((ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) != ENGMALLOC_INSTR) ||
            (ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TYPE) != ENGMALLOC_TYPE_PRIVATE))
            continue;

        // Value is in dwords, so adjust to get bytes
        // In addition, align to a pointer boundary to avoid unaligned
        // reference faults on the IA64.

        size += NV_ALIGN_UP((ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE) * 4), sizeof(void *));
    }
    if (size == 0)
        return (RM_OK);

    status = osAllocMem((VOID *)&pHalData, size);
    if (status)
        return (status);

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: HAL private area base ", pHalData);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: total HAL private area size ", size);

    //
    // Clear this memory out.
    //
    for (i = 0; i < size; i++)
    {
        pHalData[i] = 0;
    }

    //
    // Wire up engine-specific private info pointers.
    //
    pDev->pHalEngineMem = (VOID_PTR)pHalData;
    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if ((ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) != ENGMALLOC_INSTR) ||
            (ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TYPE) != ENGMALLOC_TYPE_PRIVATE))
            continue;

        tag = ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TAG);
        size = NV_ALIGN_UP((ENGMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE) * 4), sizeof(void *));

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: engine tag ", tag);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: engine pvt size ", size);
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: engine pvt base ", pHalData);

        switch (tag)
        {
            case MC_ENGINE_TAG:
                pHalHwInfo->pMcHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case FB_ENGINE_TAG:
                pHalHwInfo->pFbHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case DAC_ENGINE_TAG:
                pHalHwInfo->pDacHalPvtInfo = (VOID_PTR)pHalData;
                break;
#if 0
            case TMR_ENGINE_TAG:
                pHalHwInfo->pTmrHalPvtInfo = (VOID_PTR)pHalData;
                break;
#endif
            case DMA_ENGINE_TAG:
                pHalHwInfo->pDmaHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case GR_ENGINE_TAG:
                pHalHwInfo->pGrHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case FIFO_ENGINE_TAG:
                pHalHwInfo->pFifoHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case MP_ENGINE_TAG:
                pHalHwInfo->pMpHalPvtInfo = (VOID_PTR)pHalData;
                break;
            case VIDEO_ENGINE_TAG:
                pHalHwInfo->pVideoHalPvtInfo = (VOID_PTR)pHalData;
                break;
            default:
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: unknown engine tag ", tag);
                break;
        }
        pHalData += size;
    }

    return (RM_OK);
}

//
// allocHalEngineInstMem
//
// Setup HAL engine instance memory areas using info from
// engine descriptor table.
//
RM_STATUS
allocHalEngineInstMem(PHWINFO pDev)
{
    RM_STATUS status;
    U032 i, tag, size, align;
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PENGINEDB pEngineDB = &pDev->engineDB;
    U032 instance = 0;

    //
    // Start by scanning engine descriptor table for number of ENGINSTMALLOC
    // instructions.
    //
    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if (ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) != ENGINSTMALLOC_INSTR)
            continue;

        //
        // Get size/alignment (specified in paragraphs).
        //
        tag = ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TAG);
        size = ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE);
        align = ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _ALIGN);
        if (align == 0)
            align = 1;
#ifdef DEBUG
        if (size == 0)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: ENGINSTMALLOC has zero size!", tag);
            DBG_BREAKPOINT();
            continue;
        }
#endif

        if (align == 1)
            status = fbAllocInstMem(pDev, &instance, size);
        else
            status = fbAllocInstMemAlign(pDev, &instance, size, align);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: engine tag ", tag);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance size ", size);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: instance align ", align);

        //
        // Save instance offset in corresponding engine state.
        // 
        switch (tag)
        {
            case MC_ENGINE_TAG:
                pHalHwInfo->mcInstMem = instance;
                break;
            case FB_ENGINE_TAG:
                pHalHwInfo->fbInstMem = instance;
                break;
            case DAC_ENGINE_TAG:
                pHalHwInfo->dacInstMem = instance;
                break;
#if 0
            case TMR_ENGINE_TAG:
                pHalHwInfo->tmrInstMem = instance;
                break;
#endif
            case DMA_ENGINE_TAG:
                pHalHwInfo->dmaInstMem = instance;
                break;
            case GR_ENGINE_TAG:
                pHalHwInfo->grInstMem = instance;
                break;
            case FIFO_ENGINE_TAG:
                pHalHwInfo->fifoInstMem = instance;
                break;
            case MP_ENGINE_TAG:
                pHalHwInfo->mpInstMem = instance;
                break;
            case VIDEO_ENGINE_TAG:
                pHalHwInfo->videoInstMem = instance;
                break;
            default:
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: unknown engine tag ", tag);
                break;
        }
    }

    return (RM_OK);
}

//
// freeHalEngineInstMem
//
// Release HAL engine instance memory areas using info from
// engine descriptor table.  This routine really isn't needed
// because the only time it's called is when the device is
// being "destroyed".
//
RM_STATUS
freeHalEngineInstMem(PHWINFO pDev)
{
    U032 i, tag, size;
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PENGINEDB pEngineDB = &pDev->engineDB;

    //
    // Start by scanning engine descriptor table for number of ENGINSTMALLOC
    // instructions.
    //
    for (i = 0; i < pEngineDB->numEngineDescriptors; i++)
    {
        if (ENGDECL_FIELD(pEngineDB->pEngineDescriptors[i], _OPCODE) != ENGINSTMALLOC_INSTR)
            continue;

        //
        // Get size/alignment (specified in paragraphs).
        //
        tag = ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _TAG);
        size = ENGINSTMALLOC_FIELD(pEngineDB->pEngineDescriptors[i], _SIZE);
        
        //
        // Save instance offset in corresponding engine state.
        // 
        switch (tag)
        {
            case MC_ENGINE_TAG:
                if (pHalHwInfo->mcInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->mcInstMem, size);
                break;
            case FB_ENGINE_TAG:
                if (pHalHwInfo->fbInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->fbInstMem, size);
                break;
            case DAC_ENGINE_TAG:
                if (pHalHwInfo->dacInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->dacInstMem, size);
                break;
#if 0
            case TMR_ENGINE_TAG:
                if (pHalHwInfo->tmrInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->tmrInstMem, size);
                break;
#endif
            case DMA_ENGINE_TAG:
                if (pHalHwInfo->dmaInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->dmaInstMem, size);
                break;
            case GR_ENGINE_TAG:
                if (pHalHwInfo->grInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->grInstMem, size);
                break;
            case FIFO_ENGINE_TAG:
                if (pHalHwInfo->fifoInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->fifoInstMem, size);
                break;
            case MP_ENGINE_TAG:
                if (pHalHwInfo->mpInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->mpInstMem, size);
                break;
            case VIDEO_ENGINE_TAG:
                if (pHalHwInfo->videoInstMem)
                    fbFreeInstMem(pDev, pHalHwInfo->videoInstMem, size);
                break;
            default:
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: unknown engine tag ", tag);
                break;
        }
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv10\halnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** HAL Data *********************************\
*                                                                           *
* Module: HALNV10.C                                                         *
*   The chip dependent HAL data is kept here.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <nv10_ref.h>
#include <nv10_hal.h>
#include "nvhw.h"

//-----------------------------------------------------------------------
// NV10 HAL engine descriptor table.
//-----------------------------------------------------------------------

//
// Engine default per-object instance memory sizes (16byte units).
//
#define GR_OBJINSTSZ                    0x1

ENGINEDESCRIPTOR NV10_EngineDescriptors[] =
{
    MKENGDECL(MC_ENGINE_TAG, 0, 0),
    MKENGMALLOC(MC_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MCHALINFO_NV10)/4),

    MKENGDECL(FB_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FB_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (FBHALINFO_NV10)/4),

    MKENGDECL(DAC_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    MKENGDECL(TMR_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    // dma object size is determined by separate HAL call
    MKENGDECL(DMA_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    MKENGDECL(GR_ENGINE_TAG, NV_RAMHT_ENGINE_GRAPHICS, GR_OBJINSTSZ),
    MKENGMALLOC(GR_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (GRHALINFO_NV10)/4),

    MKENGDECL(FIFO_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FIFO_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (FIFOHALINFO_NV10)/4),

    MKENGDECL(MP_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),
    MKENGMALLOC(MP_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MPHALINFO_NV10)/4),

    MKENGDECL(VIDEO_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0)
};

U032 NV10_NumEngineDescs = (sizeof (NV10_EngineDescriptors) / sizeof (ENGINEDESCRIPTOR));

//-----------------------------------------------------------------------
// NV10 HAL class descriptor table.
//-----------------------------------------------------------------------

//
// The base classes supported for all NV10 Architectures
// 
#define NV10_ARCHITECTURE_CLASS_DESCRIPTORS                                                         \
    /* fifo engine classes */                                                                       \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_PIO),                                              \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_DMA),                                              \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_PIO),                                              \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_DMA),                                              \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV10_CHANNEL_DMA),                                              \
                                                                                                    \
    /* graphics engine classes */                                                                   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA_SOLID, NV01_BETA_SOLID),                        \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV01_IMAGE_SOLID),                        \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV01_IMAGE_PATTERN),                        \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_CLIP, NV1_IMAGE_BLACK_RECTANGLE),                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_RENDER_SOLID_LIN),                                      \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_RENDER_SOLID_TRIANGLE),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_RENDER_SOLID_RECTANGLE),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_IMAGE_BLIT),                                            \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_IMAGE_FROM_CPU),                                        \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_NULL),                                                  \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV3_STRETCHED_IMAGE_FROM_CPU),                              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV3_SCALED_IMAGE_FROM_MEMORY),                              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV3_MEMORY_TO_MEMORY_FORMAT),                               \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_ROP, NV3_CONTEXT_ROP),                               \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV3_DX3_TEXTURED_TRIANGLE),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV3_GDI_RECTANGLE_TEXT),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_DESTINATION),   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_SOURCE),        \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_DEPTH),         \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_COLOR),         \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_DVD, NV4_DVD_SUBPICTURE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV4_CONTEXT_SURFACES_2D),               \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV4_CONTEXT_PATTERN),                       \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_GDI_RECTANGLE_TEXT),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_SWIZZLED, NV4_CONTEXT_SURFACE_SWIZZLED),    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV4_CONTEXT_SURFACES_ARGB_ZS),          \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV4_CONTEXT_COLOR_KEY),                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_RENDER_SOLID_LIN),                                      \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_RENDER_SOLID_TRIANGLE),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_RENDER_SOLID_RECTANGLE),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_IMAGE_BLIT),                                            \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_IMAGE_FROM_CPU),                                        \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_SCALED_IMAGE_FROM_MEMORY),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_INDEXED_IMAGE_FROM_CPU),                               \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_IMAGE_FROM_CPU),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_STRETCHED_IMAGE_FROM_CPU),                             \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA, NV4_CONTEXT_BETA),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_STRETCHED_IMAGE_FROM_CPU),                              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV4_SCALED_IMAGE_FROM_MEMORY),                              \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV10_CONTEXT_SURFACES_2D),              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_TEXTURE_FROM_CPU),                                     \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_DVD, NV10_DVD_SUBPICTURE),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_SCALED_IMAGE_FROM_MEMORY),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_IMAGE_FROM_CPU),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV10_CONTEXT_SURFACES_3D),              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_DX5_TEXTURED_TRIANGLE),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_DX6_MULTI_TEXTURE_TRIANGLE),                           \
                                                                                                    \
    /* dac engine classes */                                                                        \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV04_VIDEO_LUT_CURSOR_DAC),                                      \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV05_VIDEO_LUT_CURSOR_DAC),                                      \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV10_VIDEO_LUT_CURSOR_DAC),                                      \
                                                                                                    \
    /* mediaport engine classes */                                                                  \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECODER, NV03_EXTERNAL_VIDEO_DECODER),                       \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECOMPRESSOR, NV03_EXTERNAL_VIDEO_DECOMPRESSOR),             \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV01_EXTERNAL_PARALLEL_BUS),                                \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV03_EXTERNAL_MONITOR_BUS),                                 \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV04_EXTERNAL_SERIAL_BUS),                                  \
                                                                                                    \
    /* video engine classes */                                                                      \
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV04_VIDEO_OVERLAY),                                     \
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV10_VIDEO_OVERLAY),

//
// The classes supported on NV10
//
CLASSDESCRIPTOR NV10_ClassDescriptors[] =
{
    NV10_ARCHITECTURE_CLASS_DESCRIPTORS
};

U032 NV10_NumClassDescs = (sizeof (NV10_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//
// The classes supported on NV15
// 
#define NV15_IMPLEMENTATION_CLASS_DESCRIPTORS                                                       \
    /* graphics engine classes */                                                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV15_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV15_IMAGE_BLIT),                                           \
                                                                                                    \
    /* dac engine classes */                                                                        \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV15_VIDEO_LUT_CURSOR_DAC),                                      \

CLASSDESCRIPTOR NV15_ClassDescriptors[] =
{
    NV10_ARCHITECTURE_CLASS_DESCRIPTORS
    NV15_IMPLEMENTATION_CLASS_DESCRIPTORS
};

U032 NV15_NumClassDescs = (sizeof (NV15_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//
// The classes supported on NV11
// 
#define NV11_IMPLEMENTATION_CLASS_DESCRIPTORS                                                       \
    /* graphics engine classes */                                                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV11_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV11_SCALED_IMAGE_FROM_MEMORY),

CLASSDESCRIPTOR NV11_ClassDescriptors[] =
{
    NV10_ARCHITECTURE_CLASS_DESCRIPTORS
    NV15_IMPLEMENTATION_CLASS_DESCRIPTORS
    NV11_IMPLEMENTATION_CLASS_DESCRIPTORS
};

U032 NV11_NumClassDescs = (sizeof (NV11_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//-----------------------------------------------------------------------
// NV10 HAL function table layout.
//-----------------------------------------------------------------------

// mc interfaces
extern RM_STATUS nvHalMcControl_NV10(VOID *);
extern RM_STATUS nvHalMcPower_NV10(VOID *);

// fifo interfaces
extern RM_STATUS nvHalFifoControl_NV10(VOID *);
extern RM_STATUS nvHalFifoAllocPio_NV10(VOID *);
extern RM_STATUS nvHalFifoAllocDma_NV10(VOID *);
extern RM_STATUS nvHalFifoFree_NV10(VOID *);
extern RM_STATUS nvHalFifoGetExceptionData_NV10(VOID *);
extern RM_STATUS nvHalFifoService_NV10(VOID *);
extern RM_STATUS nvHalFifoAccess_NV10(VOID *);
extern RM_STATUS nvHalFifoHashAdd_NV10(VOID *);
extern RM_STATUS nvHalFifoHashDelete_NV10(VOID *);
extern RM_STATUS nvHalFifoHashFunc_NV10(VOID *);
extern RM_STATUS nvHalFifoHashSearch_NV10(VOID *);

// framebuffer interfaces
extern RM_STATUS nvHalFbControl_NV10(VOID *);
extern RM_STATUS nvHalFbAlloc_NV10(VOID *);
extern RM_STATUS nvHalFbFree_NV10(VOID *);
extern RM_STATUS nvHalFbSetAllocParameters_NV10(VOID *);
extern RM_STATUS nvHalFbGetSurfacePitch_NV10(VOID *);
extern RM_STATUS nvHalFbGetSurfaceDimensions_NV10(VOID *);
extern RM_STATUS nvHalFbLoadOverride_NV10(VOID *);

// graphics interfaces
extern RM_STATUS nvHalGrControl_NV10(VOID *);
extern RM_STATUS nvHalGrAlloc_NV10(VOID *);
extern RM_STATUS nvHalGrFree_NV10(VOID *);
extern RM_STATUS nvHalGrGetExceptionData_NV10(VOID *);
extern RM_STATUS nvHalGrService_NV10(VOID *);
extern RM_STATUS nvHalGrGetNotifyData_NV10(VOID *);
extern RM_STATUS nvHalGrSetObjectContext_NV10(VOID *);
extern RM_STATUS nvHalGrLoadOverride_NV10(VOID *);

// dma interfaces
extern RM_STATUS nvHalDmaControl_NV10(VOID *);
extern RM_STATUS nvHalDmaAlloc_NV10(VOID *);
extern RM_STATUS nvHalDmaFree_NV10(VOID *);
extern RM_STATUS nvHalDmaGetInstSize_NV10(VOID *);

// dac interfaces
extern RM_STATUS nvHalDacControl_NV10(VOID *);
extern RM_STATUS nvHalDacAlloc_NV10(VOID *);
extern RM_STATUS nvHalDacFree_NV10(VOID *);
extern RM_STATUS nvHalDacSetStartAddr_NV10(VOID *);
extern RM_STATUS nvHalDacProgramMClk_NV10(VOID *);
extern RM_STATUS nvHalDacProgramNVClk_NV10(VOID *);
extern RM_STATUS nvHalDacProgramPClk_NV10(VOID *);
extern RM_STATUS nvHalDacProgramCursorImage_NV10(VOID *);
extern RM_STATUS nvHalDacGetRasterPosition_NV10(VOID *);
extern RM_STATUS nvHalDacValidateArbSettings_NV10(VOID *arg);
extern RM_STATUS nvHalDacUpdateArbSettings_NV10(VOID *arg);


// mediaport interfaces
extern RM_STATUS nvHalMpControl_NV10(VOID *);
extern RM_STATUS nvHalMpAlloc_NV10(VOID *);
extern RM_STATUS nvHalMpFree_NV10(VOID *);
extern RM_STATUS nvHalMpMethod_NV10(VOID *);
extern RM_STATUS nvHalMpGetEventStatus_NV10(VOID *);
extern RM_STATUS nvHalMpServiceEvent_NV10(VOID *);

// mediaport interfaces
extern RM_STATUS nvHalVideoControl_NV10(VOID *);
extern RM_STATUS nvHalVideoAlloc_NV10(VOID *);
extern RM_STATUS nvHalVideoFree_NV10(VOID *);
extern RM_STATUS nvHalVideoMethod_NV10(VOID *);
extern RM_STATUS nvHalVideoGetEventStatus_NV10(VOID *);
extern RM_STATUS nvHalVideoServiceEvent_NV10(VOID *);

HALFUNCS_000 NV10_HalFuncs_000 =
{
    // mc interfaces
    nvHalMcControl_NV10,
    nvHalMcPower_NV10,

    // fifo interfaces
    nvHalFifoControl_NV10,
    nvHalFifoAllocPio_NV10,
    nvHalFifoAllocDma_NV10,
    nvHalFifoFree_NV10,
    nvHalFifoGetExceptionData_NV10,
    nvHalFifoService_NV10,
    nvHalFifoAccess_NV10,
    nvHalFifoHashAdd_NV10,
    nvHalFifoHashDelete_NV10,
    nvHalFifoHashFunc_NV10,
    nvHalFifoHashSearch_NV10,

    // framebuffer interfaces
    nvHalFbControl_NV10,
    nvHalFbAlloc_NV10,
    nvHalFbFree_NV10,
    nvHalFbSetAllocParameters_NV10,
    nvHalFbGetSurfacePitch_NV10,
    nvHalFbGetSurfaceDimensions_NV10,
    nvHalFbLoadOverride_NV10,

    // graphics interfaces
    nvHalGrControl_NV10,
    nvHalGrAlloc_NV10,
    nvHalGrFree_NV10,
    nvHalGrGetExceptionData_NV10,
    nvHalGrService_NV10,
    nvHalGrGetNotifyData_NV10,
    nvHalGrSetObjectContext_NV10,
    nvHalGrLoadOverride_NV10,

    // dma interface
    nvHalDmaControl_NV10,
    nvHalDmaAlloc_NV10,
    nvHalDmaFree_NV10,
    nvHalDmaGetInstSize_NV10,

    // dac interfaces
    nvHalDacControl_NV10,
    nvHalDacAlloc_NV10,
    nvHalDacFree_NV10,
    nvHalDacSetStartAddr_NV10,
    nvHalDacProgramMClk_NV10,
    nvHalDacProgramNVClk_NV10,
    nvHalDacProgramPClk_NV10,
    nvHalDacProgramCursorImage_NV10,
    nvHalDacGetRasterPosition_NV10,
    nvHalDacValidateArbSettings_NV10,
    nvHalDacUpdateArbSettings_NV10,

    // mp interfaces
    nvHalMpControl_NV10,
    nvHalMpAlloc_NV10,
    nvHalMpFree_NV10,
    nvHalMpMethod_NV10,
    nvHalMpGetEventStatus_NV10,
    nvHalMpServiceEvent_NV10,

    // mp interfaces
    nvHalVideoControl_NV10,
    nvHalVideoAlloc_NV10,
    nvHalVideoFree_NV10,
    nvHalVideoMethod_NV10,
    nvHalVideoGetEventStatus_NV10,
    nvHalVideoServiceEvent_NV10
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\all_incs.h ===
#ifndef _ALL_INCS_H
#define _ALL_INCS_H

#include "nv32.h"
//#include "nvhw.h"
//#include "nvrmwin.h"
//#include "class.h"
//#include "gr.h"
//#include "dma.h"
//#include "modular.h"
//#include "mp.h"
//#include "tmr.h"
//#include "fifo.h"
//#include "au.h"
//#include "vnvrmd.h"
//#include "oswin.h"
#include "nvtypes.h"
#include "nv_ref.h"
#include "nvromdat.h"
#include "class.h"
// #include "nv1a_ref.h"
// #include "nv1b_ref.h"
// #include "nv1c_ref.h"
// #include "nv2_ref.h"
// #include "nv3_ref.h"

//#include "nvhw.h"

#include "fifo.h"
#include "gr.h"
#include "modular.h"
#include "control.h"
#include "cursor.h"
#include "dac.h"
#include "dma.h"
#include "dmapush.h"
#include "fb.h"
#include "mc.h"
#include "mp.h"
#include "vid.h"
//#include "nvrm.h"
#include "os.h"
#include "state.h"
#include "tmr.h"
#include "tv.h"
#include "vblank.h"
#include "vga.h"
#include "btree.h"

#ifndef LEGACY_ARCH
#include "client.h"
#endif

#ifdef NEWWIN31
#include "client.h"
#endif

#include "arb_fifo.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv\halrm.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** HAL/RM Interfaces ******************************\
*                                                                           *
* Module: halrm.c                                                           *
*   The Resource Manager service routines for the HAL are in this module.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//
// halrm.c
//
// RM service entry points needed by HAL.
//

#include <nv_ref.h>
#include <nvrm.h>
#include <nvhal.h>
#include "nvhw.h"
#include <i2c.h>


//
// nvHalRmPrintString
//
//
VOID nvHalRmPrintString(VOID *pDeviceId, U032 debugLevel, char* str)
{
   	PHWINFO pDev = (PHWINFO)pDeviceId;
	DBG_PRINT_STRING(debugLevel, str);
}

//
// nvHalRmPrintValue
//
//
VOID nvHalRmPrintValue(VOID *pDeviceId, U032 debugLevel, U032 value)
{
   	PHWINFO pDev = (PHWINFO)pDeviceId;
  	DBG_PRINT_VALUE(debugLevel, value);
}

//
// nvHalRmPrintStringValue
//
//
VOID nvHalRmPrintStringValue(VOID *pDeviceId, U032 debugLevel, char* str, U032 value)
{
  	PHWINFO pDev = (PHWINFO)pDeviceId;
    DBG_PRINT_STRING_VALUE(debugLevel, str, value);
}

//
// nvHalRmPrintStringPtr
//
//
VOID nvHalRmPrintStringPtr(VOID *pDeviceId, U032 debugLevel, char* str, VOID* value)
{
   	PHWINFO pDev = (PHWINFO)pDeviceId;
	DBG_PRINT_STRING_PTR(debugLevel, str, value);
}

//
// nvHalRmPrintStringVal64
//
//
VOID nvHalRmPrintStringVal64(VOID *pDeviceId, U032 debugLevel, char* str, U064 value)
{
   	PHWINFO pDev = (PHWINFO)pDeviceId;
    DBG_PRINT_STRING_VAL64(debugLevel, str, value);
}

//
// nvHalRmRegWr08
//
//
VOID nvHalRmRegWr08(VOID *pDeviceId, U032 offset, U008 value)
{
	PHWINFO pDev = (PHWINFO)pDeviceId;
	REG_WR08(offset, value);
}

//
// nvHalRmRegRd08
//
//
U008 nvHalRmRegRd08(VOID *pDeviceId, U032 offset)
{
	PHWINFO pDev = (PHWINFO)pDeviceId;
	return (REG_RD08(offset));
}

//
// nvHalRmRegWr32
//
//
VOID nvHalRmRegWr32(VOID *pDeviceId, U032 offset, U032 value)
{
	PHWINFO pDev = (PHWINFO)pDeviceId;
	REG_WR32(offset, value);
}

//
// nvHalRmRegRd32
//
//
U032 nvHalRmRegRd32(VOID *pDeviceId, U032 offset)
{
	PHWINFO pDev = (PHWINFO)pDeviceId;
	return (REG_RD32(offset));
}

//
// nvHalRmBreakPoint
//
//
VOID nvHalRmBreakPoint(VOID *pDeviceId)
{
   	PHWINFO pDev = (PHWINFO)pDeviceId;
	DBG_BREAKPOINT();
}

//
// nvHalRmDelay
//
//
RM_STATUS nvHalRmDelay(VOID *pDeviceId, U032 milliSeconds)
{
    PHWINFO pDev = (PHWINFO)pDeviceId;
	return (osDelay(milliSeconds));
}

//
// nvHalRmServiceIntr
//
// Service a pending condition on the specified engine on the
// specified device.
//
RM_STATUS
nvHalRmServiceIntr(VOID *pDeviceId, U032 engineTag)
{
    PHWINFO pDev = (PHWINFO)pDeviceId;

    switch (engineTag)
    {
        case MC_ENGINE_TAG:
            (void) mcService(pDev);
            break;
        case GR_ENGINE_TAG:
            (void) grService(pDev);
            break;
        case FIFO_ENGINE_TAG:
            (void) fifoService(pDev);
            break;
        case DAC_ENGINE_TAG:
            (void) VBlank(pDev);
            break;
        default:
            break;
    };
    return (RM_OK);
}

//
// nvHalRmI2cRead
//
// Issue i2c bus read request on behalf of the HAL.
//
RM_STATUS nvHalRmI2cRead(VOID *pDeviceId, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    PHWINFO pDev = (PHWINFO)pDeviceId;
    U032    Head =0; // for now, always use head 0
    return (i2cRead(pDev, Head, portID, ChipAdr, AdrLen, Adr, DataLen, Data));
}

//
// nvHalRmI2cWrite
//
// Issue i2c bus write request on behalf of the HAL.
//
RM_STATUS nvHalRmI2cWrite(VOID *pDeviceId, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    PHWINFO pDev = (PHWINFO)pDeviceId;
    U032    Head =0; // for now, always use head 0

    return (i2cWrite(pDev, Head, portID, ChipAdr, AdrLen, Adr, DataLen, Data));
}

//
// RM/HAL services table.
//
HALRMFUNCS_000 HalRmFuncs_000 =
{
    // interrupt service entry point
    nvHalRmServiceIntr,

    // debug print routines
    nvHalRmPrintString,
    nvHalRmPrintValue,
    nvHalRmPrintStringValue,
    nvHalRmPrintStringPtr,
    nvHalRmPrintStringVal64,

    // register io entry points
    nvHalRmRegWr08,
    nvHalRmRegRd08,

    nvHalRmRegWr32,
    nvHalRmRegRd32,

    nvHalRmBreakPoint,
    nvHalRmDelay,

    nvHalRmI2cRead,
    nvHalRmI2cWrite,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\btree.h ===
#ifndef _BTREE_H_
#define _BTREE_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/*********************** Balanced Tree data structure **********************\
*                                                                           *
* Module: BTREE.H                                                           *
*       API to BTREE routines.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    01/21/95 - broke into seperate file.    *
*                                                                           *
\***************************************************************************/

//
// BTREE structure.
//
typedef struct _def_node
{
    U032              Value;
    VOID             *Data;
    U032              LeftCount;
    U032              RightCount;
    struct _def_node *LeftBranch;
    struct _def_node *RightBranch;
} NODE, *PNODE;

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS btreeInsertBranch(PNODE, PNODE);
RM_STATUS btreeInsert(PNODE, PNODE *);
RM_STATUS btreeDelete(U032, PNODE *);
RM_STATUS btreeSearch(U032, PNODE *, PNODE);
RM_STATUS btreeEnumStart(U032, PNODE *, PNODE);
RM_STATUS btreeEnumNext(PNODE *, PNODE);
RM_STATUS btreeBalanceBranch(PNODE *);
RM_STATUS btreeBalance(PNODE *);

#endif // _BTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv4\halnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** HAL Data *********************************\
*                                                                           *
* Module: HALNV04.C                                                         *
*   The chip dependent HAL data is kept here.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"

//-----------------------------------------------------------------------
// NV4 HAL engine descriptor table.
//-----------------------------------------------------------------------

//
// Engine default per-object instance memory sizes (16byte units).
//
#define GR_OBJINSTSZ                    0x1

ENGINEDESCRIPTOR NV04_EngineDescriptors[] =
{
    MKENGDECL(MC_ENGINE_TAG, 0, 0),
    MKENGMALLOC(MC_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MCHALINFO_NV04)/4),

    MKENGDECL(FB_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FB_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, (0x20000 + BIOS_IMAGE_PAD + sizeof (FBHALINFO_NV04))/4),

    MKENGDECL(DAC_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    MKENGDECL(TMR_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    // dma object size is determined by separate HAL call
    MKENGDECL(DMA_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    MKENGDECL(GR_ENGINE_TAG, NV_RAMHT_ENGINE_GRAPHICS, GR_OBJINSTSZ),
    MKENGMALLOC(GR_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (GRHALINFO_NV04)/4),

    MKENGDECL(FIFO_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FIFO_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (FIFOHALINFO_NV04)/4),

    MKENGDECL(MP_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),
    MKENGMALLOC(MP_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MPHALINFO_NV04)/4),

    MKENGDECL(VIDEO_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),
};

U032 NV04_NumEngineDescs = (sizeof (NV04_EngineDescriptors) / sizeof (ENGINEDESCRIPTOR));

//-----------------------------------------------------------------------
// NV04 HAL class descriptor table.
//-----------------------------------------------------------------------

//
// The base classes supported for all NV4 Architectures
// 
#define NV4_ARCHITECTURE_CLASS_DESCRIPTORS                                                              \
    /* fifo engine classes */                                                                           \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_PIO),                                                  \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_DMA),                                                  \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_PIO),                                                  \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_DMA),                                                  \
                                                                                                        \
    /* graphics engine classes */                                                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA_SOLID, NV01_CONTEXT_BETA),                          \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV01_CONTEXT_COLOR_KEY),                      \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV01_CONTEXT_PATTERN),                          \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_CLIP, NV01_CONTEXT_CLIP_RECTANGLE),                      \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_RENDER_SOLID_LIN),                                         \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_RENDER_SOLID_TRIANGLE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_RENDER_SOLID_RECTANGLE),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_IMAGE_BLIT),                                               \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_IMAGE_FROM_CPU),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_NULL),                                                     \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_STRETCHED_IMAGE_FROM_CPU),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_SCALED_IMAGE_FROM_MEMORY),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_MEMORY_TO_MEMORY_FORMAT),                                  \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_ROP, NV03_CONTEXT_ROP),                                  \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_DX3_TEXTURED_TRIANGLE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_GDI_RECTANGLE_TEXT),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_DESTINATION),       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_SOURCE),            \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_DEPTH),             \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_COLOR),            \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_DVD, NV04_DVD_SUBPICTURE),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV04_CONTEXT_SURFACES_2D),                  \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV04_CONTEXT_PATTERN),                          \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_GDI_RECTANGLE_TEXT),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED),       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV04_CONTEXT_SURFACES_3D),                  \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_DX5_TEXTURED_TRIANGLE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_DX6_MULTI_TEXTURE_TRIANGLE),                               \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV04_CONTEXT_COLOR_KEY),                      \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_RENDER_SOLID_LIN),                                         \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_RENDER_SOLID_TRIANGLE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_RENDER_SOLID_RECTANGLE),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_IMAGE_BLIT),                                               \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_INDEXED_IMAGE_FROM_CPU),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_IMAGE_FROM_CPU),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA, NV04_CONTEXT_BETA),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_STRETCHED_IMAGE_FROM_CPU),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_SCALED_IMAGE_FROM_MEMORY),                                 \
                                                                                                        \
    /* dac engine classes */                                                                            \
    MKCLASSDECL(DAC_ENGINE_TAG, NO_LOCK, NV04_VIDEO_LUT_CURSOR_DAC),                                    \
                                                                                                        \
    /* mediaport engine classes */                                                                      \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECODER, NV03_EXTERNAL_VIDEO_DECODER),                           \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECOMPRESSOR, NV03_EXTERNAL_VIDEO_DECOMPRESSOR),                 \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV01_EXTERNAL_PARALLEL_BUS),                                    \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV03_EXTERNAL_MONITOR_BUS),                                     \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV04_EXTERNAL_SERIAL_BUS),                                      \
                                                                                                        \
    /* video engine classes */                                                                          \
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV04_VIDEO_OVERLAY),

//
// The classes supported on NV4
//
CLASSDESCRIPTOR NV04_ClassDescriptors[] =
{
    NV4_ARCHITECTURE_CLASS_DESCRIPTORS
};

U032 NV04_NumClassDescs = (sizeof (NV04_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//
// The classes supported on NV5
// 
#define NV5_IMPLEMENTATION_CLASS_DESCRIPTORS                                                            \
    /* graphics engine classes */                                                                       \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_SCALED_IMAGE_FROM_MEMORY),                                 \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_INDEXED_IMAGE_FROM_CPU),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_IMAGE_FROM_CPU),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_STRETCHED_IMAGE_FROM_CPU),                                 \
                                                                                                        \
    /* dac engine classes */                                                                            \
    MKCLASSDECL(DAC_ENGINE_TAG, NO_LOCK, NV05_VIDEO_LUT_CURSOR_DAC),

CLASSDESCRIPTOR NV05_ClassDescriptors[] =
{
    NV4_ARCHITECTURE_CLASS_DESCRIPTORS
    NV5_IMPLEMENTATION_CLASS_DESCRIPTORS
};

U032 NV05_NumClassDescs = (sizeof (NV05_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//-----------------------------------------------------------------------
// NV4 HAL function table layout.
//-----------------------------------------------------------------------

// mc interfaces
RM_STATUS nvHalMcControl_NV04(VOID *);
RM_STATUS nvHalMcPower_NV04(VOID *);

// fifo interfaces
extern RM_STATUS nvHalFifoControl_NV04(VOID *);
extern RM_STATUS nvHalFifoAllocPio_NV04(VOID *);
extern RM_STATUS nvHalFifoAllocDma_NV04(VOID *);
extern RM_STATUS nvHalFifoFree_NV04(VOID *);
extern RM_STATUS nvHalFifoGetExceptionData_NV04(VOID *);
extern RM_STATUS nvHalFifoService_NV04(VOID *);
extern RM_STATUS nvHalFifoAccess_NV04(VOID *);
extern RM_STATUS nvHalFifoHashAdd_NV04(VOID *);
extern RM_STATUS nvHalFifoHashDelete_NV04(VOID *);
extern RM_STATUS nvHalFifoHashFunc_NV04(VOID *);
extern RM_STATUS nvHalFifoHashSearch_NV04(VOID *);

// framebuffer interfaces
extern RM_STATUS nvHalFbControl_NV04(VOID *);
extern RM_STATUS nvHalFbAlloc_NV04(VOID *);
extern RM_STATUS nvHalFbFree_NV04(VOID *);
extern RM_STATUS nvHalFbSetAllocParameters_NV04(VOID *);
extern RM_STATUS nvHalFbGetSurfacePitch_NV04(VOID *);
extern RM_STATUS nvHalFbGetSurfaceDimensions_NV04(VOID *);
extern RM_STATUS nvHalFbLoadOverride_NV04(VOID *);

// graphics interfaces
extern RM_STATUS nvHalGrControl_NV04(VOID *);
extern RM_STATUS nvHalGrAlloc_NV04(VOID *);
extern RM_STATUS nvHalGrFree_NV04(VOID *);
extern RM_STATUS nvHalGrGetExceptionData_NV04(VOID *);
extern RM_STATUS nvHalGrService_NV04(VOID *);
extern RM_STATUS nvHalGrGetNotifyData_NV04(VOID *);
extern RM_STATUS nvHalGrSetObjectContext_NV04(VOID *);
extern RM_STATUS nvHalGrLoadOverride_NV04(VOID *);

// dma interfaces
extern RM_STATUS nvHalDmaControl_NV04(VOID *);
extern RM_STATUS nvHalDmaAlloc_NV04(VOID *);
extern RM_STATUS nvHalDmaFree_NV04(VOID *);
extern RM_STATUS nvHalDmaGetInstSize_NV04(VOID *);

// dac interfaces
extern RM_STATUS nvHalDacControl_NV04(VOID *);
extern RM_STATUS nvHalDacAlloc_NV04(VOID *);
extern RM_STATUS nvHalDacFree_NV04(VOID *);
extern RM_STATUS nvHalDacSetStartAddr_NV04(VOID *);
extern RM_STATUS nvHalDacProgramMClk_NV04(VOID *);
extern RM_STATUS nvHalDacProgramNVClk_NV04(VOID *);
extern RM_STATUS nvHalDacProgramPClk_NV04(VOID *);
extern RM_STATUS nvHalDacProgramCursorImage_NV04(VOID *);
extern RM_STATUS nvHalDacGetRasterPosition_NV04(VOID *);
extern RM_STATUS nvHalDacValidateArbSettings_NV04(VOID *arg);
extern RM_STATUS nvHalDacUpdateArbSettings_NV04(VOID *arg);


// mediaport interfaces
extern RM_STATUS nvHalMpControl_NV04(VOID *);
extern RM_STATUS nvHalMpAlloc_NV04(VOID *);
extern RM_STATUS nvHalMpFree_NV04(VOID *);
extern RM_STATUS nvHalMpMethod_NV04(VOID *);
extern RM_STATUS nvHalMpGetEventStatus_NV04(VOID *);
extern RM_STATUS nvHalMpServiceEvent_NV04(VOID *);

// video interfaces
extern RM_STATUS nvHalVideoControl_NV04(VOID *);
extern RM_STATUS nvHalVideoAlloc_NV04(VOID *);
extern RM_STATUS nvHalVideoFree_NV04(VOID *);
extern RM_STATUS nvHalVideoMethod_NV04(VOID *);
extern RM_STATUS nvHalVideoGetEventStatus_NV04(VOID *);
extern RM_STATUS nvHalVideoServiceEvent_NV04(VOID *);

HALFUNCS_000 NV04_HalFuncs_000 =
{
    // mc interfaces
    nvHalMcControl_NV04,
    nvHalMcPower_NV04,

    // fifo interfaces
    nvHalFifoControl_NV04,
    nvHalFifoAllocPio_NV04,
    nvHalFifoAllocDma_NV04,
    nvHalFifoFree_NV04,
    nvHalFifoGetExceptionData_NV04,
    nvHalFifoService_NV04,
    nvHalFifoAccess_NV04,
    nvHalFifoHashAdd_NV04,
    nvHalFifoHashDelete_NV04,
    nvHalFifoHashFunc_NV04,
    nvHalFifoHashSearch_NV04,

    // framebuffer interfaces
    nvHalFbControl_NV04,
    nvHalFbAlloc_NV04,
    nvHalFbFree_NV04,
    nvHalFbSetAllocParameters_NV04,
    nvHalFbGetSurfacePitch_NV04,
    nvHalFbGetSurfaceDimensions_NV04,
    nvHalFbLoadOverride_NV04,

    // graphics interfaces
    nvHalGrControl_NV04,
    nvHalGrAlloc_NV04,
    nvHalGrFree_NV04,
    nvHalGrGetExceptionData_NV04,
    nvHalGrService_NV04,
    nvHalGrGetNotifyData_NV04,
    nvHalGrSetObjectContext_NV04,
    nvHalGrLoadOverride_NV04,

    // dma interface
    nvHalDmaControl_NV04,
    nvHalDmaAlloc_NV04,
    nvHalDmaFree_NV04,
    nvHalDmaGetInstSize_NV04,

    // dac interfaces
    nvHalDacControl_NV04,
    nvHalDacAlloc_NV04,
    nvHalDacFree_NV04,
    nvHalDacSetStartAddr_NV04,
    nvHalDacProgramMClk_NV04,
    nvHalDacProgramNVClk_NV04,
    nvHalDacProgramPClk_NV04,
    nvHalDacProgramCursorImage_NV04,
    nvHalDacGetRasterPosition_NV04,
    nvHalDacValidateArbSettings_NV04,
    nvHalDacUpdateArbSettings_NV04,

    // mp interfaces
    nvHalMpControl_NV04,
    nvHalMpAlloc_NV04,
    nvHalMpFree_NV04,
    nvHalMpMethod_NV04,
    nvHalMpGetEventStatus_NV04,
    nvHalMpServiceEvent_NV04,

    // video interfaces
    nvHalVideoControl_NV04,
    nvHalVideoAlloc_NV04,
    nvHalVideoFree_NV04,
    nvHalVideoMethod_NV04,
    nvHalVideoGetEventStatus_NV04,
    nvHalVideoServiceEvent_NV04
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\heap\nv\heap.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Balanced Tree *******************************\
*                                                                           *
* Module: HEAP.C                                                            *
*   A generic library for heap management is provided.                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    05/19/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <class.h>
#include <heap.h>
#include <os.h>
#include <rmfail.h>
#include <smp.h>

//
// Globals.
//
static U032 memTypeFlags[13] =
{
    MEM_FLAG_IMAGE,
    MEM_FLAG_DEPTH      | MEM_GROW_DOWN,
    MEM_FLAG_TEXTURE,
    MEM_FLAG_OVERLAY,
    MEM_FLAG_FONT,
    MEM_FLAG_CURSOR     | MEM_GROW_DOWN,
    MEM_FLAG_DMA        | MEM_GROW_DOWN,
    MEM_FLAG_INSTANCE   | MEM_GROW_DOWN,
    MEM_FLAG_PRIMARY,
    MEM_FLAG_IMAGE_TILED,
    MEM_FLAG_DEPTH_COMPR16  | MEM_GROW_DOWN,
    MEM_FLAG_DEPTH_COMPR32  | MEM_GROW_DOWN,
    0
};

//
// Statics.
//
static RM_STATUS heapFbFree(PHWINFO, U032);

#ifdef DEBUG
/****************************************************************************/
/*                                                                          */
/*                             DEBUG support!                               */
/*                                                                          */
/****************************************************************************/
U032 dbgDumpHeap = 0;
#define HEAP_VALIDATE(h)    {heapValidate(h);if(dbgDumpHeap)heapDump(h);}

void heapDump
(
    PHEAP heap
)
{
    U032      i;
    U032      free;
    PMEMBLOCK block;

    if (!heap) return;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"Heap dump.  Size = ", heap->total);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"            Free = ", heap->free);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"=================================================================\r\n");
    for (i = 0; i < heap->numBanks; i++)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"Bank: ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tType flags = ", heap->Bank[i].flags);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tOffset     = ", heap->Bank[i].offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tSize       = ", heap->Bank[i].size);
    }
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Block List Forward:\r\n");
    block = heap->pBlockList;
    do
    {
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tHwres = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tEnd   = ", block->end);
        block = block->next;
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Block List Reverse:\r\n");
    block = heap->pBlockList;
    do
    {
        block = block->prev;
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tHwres  = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tEnd   = ", block->end);
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"FREE Block List Forward:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
            block = block->u1.nextFree;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tCalculated free count = ", free);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"FREE Block List Reverse:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            block = block->u0.prevFree;
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"\tCalculated free count = ", free);
}

void heapValidate
(
    PHEAP heap
)
{
    PMEMBLOCK block, blockFree;
    U032      free, used;

    if (!heap) return;
    /*
     * Scan the blocks and check for consistency.
     */
    free      = 0;
    used      = 0;
    block     = heap->pBlockList;
    blockFree = heap->pFreeBlockList;
    do
    {
        if (block->owner == FREE_BLOCK)
        {
            if (!blockFree)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: Invalid free list with free blocks found.\r\n");
                heapDump(heap);
                DBG_BREAKPOINT();
            }
            free += block->end - block->begin + 1;
            if (block != blockFree)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: Free list not consistent with block list.\r\n");
                heapDump(heap);
                DBG_BREAKPOINT();
            }
            blockFree = blockFree->u1.nextFree;
        }
        else
            used += block->end - block->begin + 1;
        if (block->next != heap->pBlockList)
        {
            if (block->end != block->next->begin - 1)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"Validate: Hole between blocks at offset = ", block->end);
                heapDump(heap);
                DBG_BREAKPOINT();
            }
        }
        else
        {
            if (block->end != heap->total - 1)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: Last block doesn't end at top.\r\n");
                heapDump(heap);
                DBG_BREAKPOINT();
            }
            if (block->next->begin != 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: First block doesn't start at bottom.\r\n");
                heapDump(heap);
                DBG_BREAKPOINT();
            }
        }
        if (block->end < block->begin)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"Validate: Invalid block begin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"                        end   = ", block->end);
            heapDump(heap);
            DBG_BREAKPOINT();
        }
        block = block->next;
    } while (block != heap->pBlockList);
    if (free != heap->free)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: Calculated free count not consistent with heap free count.\r\n");
        heapDump(heap);
        DBG_BREAKPOINT();
    }
    if ((used + free) > heap->total)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Validate: Calculated used count not consistent with heap size.\r\n");
        heapDump(heap);
        DBG_BREAKPOINT();
    }
}
#else
#define HEAP_VALIDATE(h)
#endif // DEBUG

//
// Create a unique memhandle by incrementing the handle, and if it's about
// to overflow into the upper 2 bytes, reset it back to 0.
//
#define UNIQUE_MEMHANDLE()      \
        heap->memHandle = ((heap->memHandle + 1) % 0x10000) ? (heap->memHandle + 1) : 0xcafe0000


/****************************************************************************/
/*                                                                          */
/*                             Heap Manager                                 */
/*                                                                          */
/****************************************************************************/
//
// Create a heap.
//
RM_STATUS heapCreate
(
	PHWINFO pDev,
    U008   *pMem,
    U032   size,
    U032   numBanks,
    PHEAP  *heap
)
{
    PMEMBLOCK block;
    U032      sizeBank, i;

    //
    // Simply create a free heap with the indicated number of banks.
    //
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Heap Manager: HEAP ABOUT TO BE CREATED.\r\n");

    if (!numBanks) numBanks = 1;
    if (osAllocMem((VOID **)heap, sizeof(HEAP) + (numBanks - 1)*sizeof(MEMBANK)) == RM_OK)
    {
        (*heap)->base  = pMem;
        (*heap)->total = size;
        (*heap)->free  = size;
        if (osAllocMem((VOID **)&block, sizeof(MEMBLOCK)) != RM_OK)
        {
            osFreeMem((VOID *)*heap);
            return (RM_ERR_NO_FREE_MEM);
        }
        block->owner    = FREE_BLOCK;
        block->begin    = 0;
        block->align    = 0;
        block->end      = size - 1;
        block->u0.prevFree = block;
        block->u1.nextFree = block;
        block->next     = block;
        block->prev     = block;
        //
        // Fill in the heap bank info.
        //
        (*heap)->pBlockList     = block;
        (*heap)->pFreeBlockList = block;
        (*heap)->numBanks       = numBanks;
        (*heap)->memHandle      = 0xcafe0000;

        //We may modify the memory property table, so we make a per-device copy.
        for (i = 0; i < 11; i++) {
            (*heap)->memTypeFlags[i] = memTypeFlags[i];
        }

        sizeBank                = pDev->Framebuffer.HalInfo.RamSize / numBanks;
        for (i = 0; i < numBanks; i++)
        {
            (*heap)->Bank[i].offset = i * sizeBank;
            (*heap)->Bank[i].size   = sizeBank;
            (*heap)->Bank[i].flags  = 0;
        }

        (*heap)->Bank[0].flags             = (*heap)->memTypeFlags[MEM_TYPE_PRIMARY];
        (*heap)->Bank[numBanks - 1].flags  = (*heap)->memTypeFlags[MEM_TYPE_INSTANCE]
                                          |  (*heap)->memTypeFlags[MEM_TYPE_CURSOR]
                                          |  (*heap)->memTypeFlags[MEM_TYPE_DEPTH]
                                          |  (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR16]
                                          |  (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR32]
                                          |  (*heap)->memTypeFlags[MEM_TYPE_DMA];
        if (numBanks > 1)
        {
            if (numBanks > 2)
            {
                if (IsNV10orBetter(pDev) && (pDev->Framebuffer.HalInfo.RamType == BUFFER_DDRAM))
                {
                    /*
                     * With DDR, there's a penalty for switching external banks, so we'll try to keep
                     * important allocations (IMAGE/DEPTH) in the same external bank. The layout will be
                     *
                     *  bank0:          PRIMARY/IMAGE
                     *  bank1:          DEPTH
                     *  bank2:          IMAGE
                     *  bank3:          IMAGE and everything else
                     *
                     * Note, we'll set MEM_GROW_DOWN on any non-IMAGE/DEPTH buffers, so these start at the
                     * end of memory growing toward the middle leaving as big a block as possible unfragmented
                     * for IMAGE/DEPTH buffer allocs to grow into.
                     *
                     * Also, change IMAGE buffers to grow down and DEPTH buffers grow up. This fixes 2
                     * problems when an IMAGE/DEPTH buffer doesn't fit in their internal bank:
                     *
                     *  . in 10x7x32 triple buffered, when the 3rd IMAGE buffer doesn't fit in bank0,
                     *      we won't put it in with the DEPTH buffer in bank1 ... growing down will cause
                     *      it to be in bank2 or bank3.
                     *
                     *  . in 16x12x32 double buffered, when the DEPTH buffer doesn't fit in bank1, the 2nd
                     *      heapAlloc loop will place it as close as possible to the PRIMARY surface buffer.
                     *      The means it'll mostly fit in the first external bank, so we switch external banks
                     *      only 1/2 the time when flipping. In frontbuffer rendering we'll switch banks only
                     *      for the portion that's above 8MB.
                     */

                    (*heap)->memTypeFlags[MEM_TYPE_TEXTURE]  |= MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_OVERLAY]  |= MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_FONT]     |= MEM_GROW_DOWN;

                    (*heap)->memTypeFlags[MEM_TYPE_IMAGE]        |= MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_IMAGE_TILED]  |= MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_DEPTH]        &= ~MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR16]   &= ~MEM_GROW_DOWN;
                    (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR32]   &= ~MEM_GROW_DOWN;

                    (*heap)->Bank[0].flags             |= MEM_FLAG_IMAGE
                                                       |  MEM_FLAG_IMAGE_TILED;
                    (*heap)->Bank[1].flags             |= (*heap)->memTypeFlags[MEM_TYPE_DEPTH]
                                                       | (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR16]
                                                       | (*heap)->memTypeFlags[MEM_TYPE_DEPTH_COMPR32];

                    (*heap)->Bank[numBanks - 1].flags  |= (*heap)->memTypeFlags[MEM_TYPE_TEXTURE]
                                                       |  (*heap)->memTypeFlags[MEM_TYPE_OVERLAY]
                                                       |  (*heap)->memTypeFlags[MEM_TYPE_FONT];
                    (*heap)->Bank[numBanks - 1].flags  &= ~(MEM_FLAG_DEPTH
                                                       | MEM_FLAG_DEPTH_COMPR16
                                                       | MEM_FLAG_DEPTH_COMPR32);  // may not be necessary
                }
                else
                {
                    (*heap)->Bank[1].flags            |= (*heap)->memTypeFlags[MEM_TYPE_IMAGE];
                    (*heap)->Bank[numBanks - 2].flags |= (*heap)->memTypeFlags[MEM_TYPE_OVERLAY]
                                                      |  (*heap)->memTypeFlags[MEM_TYPE_TEXTURE];
                }
            }
            else
            {
                (*heap)->Bank[0].flags            |= (*heap)->memTypeFlags[MEM_TYPE_IMAGE]
                                                  |  (*heap)->memTypeFlags[MEM_TYPE_IMAGE_TILED];
                (*heap)->Bank[1].flags            |= (*heap)->memTypeFlags[MEM_TYPE_TEXTURE]
                                                  |  (*heap)->memTypeFlags[MEM_TYPE_OVERLAY]
                                                  |  (*heap)->memTypeFlags[MEM_TYPE_FONT];
            }
        }
        else
        {
            (*heap)->Bank[0].flags             = (*heap)->memTypeFlags[MEM_TYPE_TEXTURE]
                                              |  (*heap)->memTypeFlags[MEM_TYPE_IMAGE]
                                              |  (*heap)->memTypeFlags[MEM_TYPE_IMAGE_TILED]
                                              |  (*heap)->memTypeFlags[MEM_TYPE_OVERLAY]
                                              |  (*heap)->memTypeFlags[MEM_TYPE_FONT];
        }
    }
    return (RM_OK);
}

RM_STATUS heapDestroy
(
	PHWINFO pDev,
    PHEAP heap
)
{
    PMEMBLOCK block, blockFirst, blockNext;
    BOOL headptr_updated;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Heap Manager: HEAP ABOUT TO BE DESTROYED.\r\n");

    if ((!heap)) return (RM_ERROR);


    // we need to figure out what is preventing the w2k display driver from getting a primary surface allocation
    //  at offset zero after a mode switch -  added by C. Moidel
#ifdef DEBUG
    heapDump(heap);
#endif

    //
    // Free all allocated blocks, but preserving non-NVRM primary surfaces.
    // If the head of our list changes, restart the search, since our terminating
    // block pointer may not be in the list anymore.
    //
    do {
        block = blockFirst = heap->pBlockList;
        headptr_updated = FALSE;

        do {
            blockNext = block->next;

            if ((block->owner != FREE_BLOCK) &&
                ((block->u0.type != MEM_TYPE_PRIMARY) || (block->owner == 'NVRM'))) {

                blockFree(pDev, heap, block);

                // restart scanning the list, if the heap->pBlockList changed
                if (blockFirst != heap->pBlockList) {
                    headptr_updated = TRUE;
                    break;
                }
            }
            block = blockNext;

        } while (block != heap->pBlockList);

    } while (headptr_updated);

    //
    // Free the heap structure, if we freed everything
    // (the first block represents the entire free space of the heap).
    //
    if ((heap->pBlockList->begin == 0) &&
        (heap->pBlockList->end == heap->total - 1)) {
#if 0
        //
        // This is now a callable function and so, we can't assume we'll get
        // a chance to recreate it ... so don't free the one free block at the
        // head of the block list or the heap struct itself.
        //

        osFreeMem((VOID *)heap->pBlockList);
        osFreeMem((VOID *)heap);
        pDev->Framebuffer.HeapHandle = NULL;
#endif
    }

    return (RM_OK);
}

RM_STATUS heapAlloc
(
	PHWINFO pDev,
    PHEAP heap,
    U032  owner,
    U032 *size,
    U032  type,
    U032  height,
    U032 *pitch,
    U032 *offset
)
{
    U032      alignment, i, typeFlags, headNum;
    U032      bankLo, bankHi, freeLo, freeHi, allocLo, allocAl, allocHi;
    PMEMBLOCK blockFirstFree, blockFree, blockNew, blockSplit;
    PFBALLOCINFO pFbAllocInfo;
    FBALLOCINFO localFbAllocInfo;
    RM_STATUS status;
    BOOL ignoreBankPlacement = FALSE;

    if ((!heap)) return (RM_ERROR);
    *offset = 0;

    // no-op failure for now
    RM_FAILURE_HEAP(1, offset = offset);

    //
    // Check for valid size.
    //
    if (*size == 0) return (RM_ERROR);

    //
    // If this is a new primary surface alloc (and it's not us), we'll want to
    // free up the primary surface we allocated. Doing a heapPurge should be fine,
    // since we've made no other allocations. Make sure this is done before the
    // free check below.
    //
    if (((type & MEM_TYPE_MASK) == MEM_TYPE_PRIMARY) && (owner != 'NVRM'))
    {
        heapPurge(pDev, heap, 'NVRM');
    }

    //
    // First check for enough memory to satisfy this request.
    //
    if (heap->free < *size) return (RM_ERR_NO_FREE_MEM);

    //
    // Check if IGNORE_BANK_PLACEMENT_FLAG was passed in with the type to
    // ignore placing this allocation in a particular bank. This means we
    // default to the second loop where we choose first fit.
    //
    if (type & MEM_TYPE_IGNORE_BANK_PLACEMENT_FLAG)
        ignoreBankPlacement = TRUE;

    // Set default type flags (includes type and MEM_GROW dir)
    typeFlags = heap->memTypeFlags[type & MEM_TYPE_MASK];

    //
    // Check if FORCE_MEM_GROWS_UP or FORCE_MEM_GROWS_DOWN was passed in
    // to override the MEM_GROWS direction for this allocation.
    //
    if (type & MEM_TYPE_FORCE_MEM_GROWS_UP_FLAG)
        typeFlags = (typeFlags & ~MEM_GROW_MASK) | MEM_GROW_UP;
    if (type & MEM_TYPE_FORCE_MEM_GROWS_DOWN_FLAG)
        typeFlags = (typeFlags & ~MEM_GROW_MASK) | MEM_GROW_DOWN;

    // extract head number from the type argument
    headNum = (type & MEM_TYPE_HEAD_MASK) >> MEM_TYPE_HEAD_SHIFT;

    // Mask off any flags passed in with the type
    type &= MEM_TYPE_MASK;

    //
    // Force type into known values.
    //
    if (type > MEM_TYPE_MAX) type = 0;

    if (type == MEM_TYPE_PRIMARY) {
        pFbAllocInfo = &(pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[headNum]);
    } else {
        pFbAllocInfo = &localFbAllocInfo;
    }

    //
    // Request any chip-specific resources for memory of this
    // type (e.g. tiles). This call may adjust size, pitch and
    // alignment as necessary.
    //
    pFbAllocInfo->type = type;
    pFbAllocInfo->hwResId = 0;
    pFbAllocInfo->height = height;
    pFbAllocInfo->pitch = (pitch) ? (*pitch) : 0;
    pFbAllocInfo->size = *size;
    pFbAllocInfo->align = 0;

#if 0
    //
    // If we're in VGA mode, set pitch to 0 to ensure the HAL
    // doesn't do anything squirrely (i.e. allocate and use
    // tile resources).
    //
    if (pDev->Vga.Enabled)
        pFbAllocInfo->pitch = 0;
#endif

    //
    // Call into HAL to reserve any hardware resources for
    // the specified memory type.  We'll ignore any
    // insufficient resources errors for now.
    //
    status = nvHalFbAlloc(pDev, pFbAllocInfo);
    if (status != RM_OK && status != RM_ERR_INSUFFICIENT_RESOURCES)
    {
        // probably means we passed in a bogus type
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: nvHalFbAlloc failure!\n");
        return (RM_ERROR);
    }

    //
    // Refresh search parameters.
    //
    *size = pFbAllocInfo->size;
    if (pitch)
        *pitch = pFbAllocInfo->pitch;
    alignment = pFbAllocInfo->align;

    //
    // Find the best bank to start looking in for this type.
    //
    for (i = 0; (i < heap->numBanks) && (ignoreBankPlacement == FALSE); i++)
    {
        if ((heap->Bank[i].flags & typeFlags) & ~MEM_GROW_DOWN)
        {
            bankLo    = heap->Bank[i].offset;
            bankHi    = heap->Bank[i].offset + heap->Bank[i].size - 1;
            if (!(blockFirstFree = heap->pFreeBlockList))
            {
                heapFbFree(pDev, pFbAllocInfo->hwResId);
                return (RM_ERR_NO_FREE_MEM);
            }
            if (heap->Bank[i].flags & MEM_GROW_DOWN)
            {
                //
                // Search top down for the first free block in this range.
                //
                do
                {
                    blockFirstFree = blockFirstFree->u0.prevFree;
                } while ((blockFirstFree != heap->pFreeBlockList) && (blockFirstFree->begin > bankHi));
            }
            else
            {
                //
                // Search bottom up for the first free block in this range.
                //
                while (blockFirstFree->end < bankLo)
                    if ((blockFirstFree = blockFirstFree->u1.nextFree) == heap->pFreeBlockList) break;
            }
            //
            //  Start scanning for a free block.  Continue through all memory until
            // something (hopefully) is found.
            //
            blockFree = blockFirstFree;
            do
            {
                if ((blockFree->begin <= bankHi) && (blockFree->end >= bankLo))
                {
                    //
                    // Found some overlap. Check if it is big enough.
                    //
                    freeLo = (bankLo < blockFree->begin) ? blockFree->begin : bankLo;
                    freeHi = (bankHi > blockFree->end)   ? blockFree->end   : bankHi;
                    if (heap->Bank[i].flags & MEM_GROW_DOWN)
                    {
                        //
                        // Allocate from the top of the memory block.
                        //
                        allocLo = (freeHi - *size + 1) & ~alignment;
                        allocAl = allocLo;
                        allocHi = freeHi;
                    }
                    else
                    {
                        //
                        // Allocate from the bottom of the memory block.
                        //
                        allocLo = freeLo;
                        allocAl = (freeLo + alignment) & ~alignment;
                        allocHi = allocAl + *size - 1;
                    }
                    //
                    // Check for wrap-around.
                    //
                    if (allocLo > allocHi)
                        continue;
                    if ((allocLo == blockFree->begin) && (allocHi == blockFree->end))
                    {
                        //
                        // Wow, exact match so replace free block.
                        // Remove from free list.
                        //
                        blockFree->u1.nextFree->u0.prevFree = blockFree->u0.prevFree;
                        blockFree->u0.prevFree->u1.nextFree = blockFree->u1.nextFree;
                        if (heap->pFreeBlockList == blockFree)
                        {
                            //
                            // This could be the last free block.
                            //
                            if (blockFree->u1.nextFree == blockFree)
                                heap->pFreeBlockList = 0;
                            else
                                heap->pFreeBlockList = blockFree->u1.nextFree;
                        }
                        //
                        // Set owner/type values here.  Don't move because some fields are unions.
                        //
                        blockFree->owner   = owner;
                        blockFree->mhandle = UNIQUE_MEMHANDLE();
                        blockFree->u0.type = type;
                        blockFree->u1.hwres = pFbAllocInfo->hwResId;
                        blockFree->align   = allocAl;
                        //
                        // Reduce free amount by allocated block size.
                        //
                        heap->free -= blockFree->end - blockFree->begin + 1;
                        *offset     = blockFree->align;
                        pFbAllocInfo->offset = *offset;
                        //pFbAllocInfo->size = *size - 1;
                        if (type == MEM_TYPE_PRIMARY)
                        {
                            pDev->Framebuffer.PrimarySurfaceAlloced = 0x1;
                            pDev->Framebuffer.HalInfo.Start[headNum] = *offset;
                        }
                        heapFbSetAllocParameters(pDev, pFbAllocInfo);
                        HEAP_VALIDATE(heap);
                        return (RM_OK);
                    }
                    else if ((allocLo >= freeLo) && (allocHi <= freeHi))
                    {
                        //
                        // Budah-boom, found a match.
                        //
                        if (osAllocMem((VOID **)&blockNew, sizeof(MEMBLOCK)) != RM_OK)
                        {
                            heapFbFree(pDev, pFbAllocInfo->hwResId);
                            return (RM_ERR_NO_FREE_MEM);
                        }
                        blockNew->owner   = owner;
                        blockNew->mhandle = UNIQUE_MEMHANDLE();
                        blockNew->u0.type = type;
                        blockNew->u1.hwres = pFbAllocInfo->hwResId;
                        blockNew->begin   = allocLo;
                        blockNew->align   = allocAl;
                        blockNew->end     = allocHi;
                        if ((blockFree->begin < blockNew->begin) && (blockFree->end > blockNew->end))
                        {
                            //
                            // Split free block in two.
                            //
                            if (osAllocMem((VOID **)&blockSplit, sizeof(MEMBLOCK)) != RM_OK)
                            {
                                heapFbFree(pDev, pFbAllocInfo->hwResId);
                                osFreeMem((VOID *)blockNew);
                                return (RM_ERR_NO_FREE_MEM);
                            }
                            blockSplit->owner = FREE_BLOCK;
                            blockSplit->begin = blockNew->end + 1;
                            blockSplit->align = blockSplit->begin;
                            blockSplit->end   = blockFree->end;
                            blockFree->end    = blockNew->begin - 1;
                            //
                            // Insert free split block into free list.
                            //
                            blockSplit->u1.nextFree = blockFree->u1.nextFree;
                            blockSplit->u0.prevFree = blockFree;
                            blockSplit->u1.nextFree->u0.prevFree = blockSplit;
                            blockFree->u1.nextFree = blockSplit;
                            //
                            //  Insert new and split blocks into block list.
                            //
                            blockNew->next   = blockSplit;
                            blockNew->prev   = blockFree;
                            blockSplit->next = blockFree->next;
                            blockSplit->prev = blockNew;
                            blockFree->next  = blockNew;
                            blockSplit->next->prev = blockSplit;
                        }
                        else if (blockFree->end == blockNew->end)
                        {
                            //
                            // New block inserted after free block.
                            //
                            blockFree->end = blockNew->begin - 1;
                            blockNew->next = blockFree->next;
                            blockNew->prev = blockFree;
                            blockFree->next->prev = blockNew;
                            blockFree->next = blockNew;
                        }
                        else if (blockFree->begin == blockNew->begin)
                        {
                            //
                            // New block inserted before free block.
                            //
                            blockFree->begin = blockNew->end + 1;
                            blockFree->align = blockFree->begin;
                            blockNew->next   = blockFree;
                            blockNew->prev   = blockFree->prev;
                            blockFree->prev->next = blockNew;
                            blockFree->prev = blockNew;
                            if (heap->pBlockList == blockFree)
                                heap->pBlockList  = blockNew;
                        }
                        else
                        {
                            heapFbFree(pDev, pFbAllocInfo->hwResId);
                            osFreeMem((VOID *)blockNew);
                            HEAP_VALIDATE(heap);
                            return (RM_ERR_NO_FREE_MEM);
                        }
                        //
                        // Reduce free amount by allocated block size.
                        //
                        heap->free -= blockNew->end - blockNew->begin + 1;
                        *offset     = blockNew->align;
                        pFbAllocInfo->offset = *offset;
                        //pFbAllocInfo->size = *size - 1;
                        if (type == MEM_TYPE_PRIMARY)
                        {
                            pDev->Framebuffer.PrimarySurfaceAlloced = 0x1;
                            pDev->Framebuffer.HalInfo.Start[headNum] = *offset;
                        }
                        heapFbSetAllocParameters(pDev, pFbAllocInfo);
                        HEAP_VALIDATE(heap);
                        return (RM_OK);
                    }
                }
                blockFree = blockFree->u0.prevFree;
            } while (blockFree != blockFirstFree);
        }
    }

    //
    // Bummer, no nice bank blocks were found.  Try again, only look for anything.
    //
    if (!(blockFirstFree = heap->pFreeBlockList))
    {
        heapFbFree(pDev, pFbAllocInfo->hwResId);
        return (RM_ERR_NO_FREE_MEM);
    }

    //
    // When scanning upwards, start at the bottom - 1 so the following loop looks symetrical.
    //
    if (!(typeFlags & MEM_GROW_DOWN))
        blockFirstFree = blockFirstFree->u0.prevFree;
    blockFree = blockFirstFree;
    do
    {
        if (typeFlags & MEM_GROW_DOWN)
        {
            //
            // Allocate from the top of the memory block.
            //
            blockFree = blockFree->u0.prevFree;
            allocLo   = (blockFree->end - *size + 1) & ~alignment;
            allocAl   = allocLo;
            allocHi   = blockFree->end;
        }
        else
        {
            //
            // Allocate from the bottom of the memory block.
            //
            blockFree = blockFree->u1.nextFree;
            allocLo   = blockFree->begin;
            allocAl   = (blockFree->begin + alignment) & ~alignment;
            allocHi   = allocAl + *size - 1;
        }
        //
        // Check for wrap-around.
        //
        if (allocLo > allocHi)
            continue;
        if ((allocLo == blockFree->begin) && (allocHi == blockFree->end))
        {
            //
            // Wow, exact match so replace free block.
            // Remove from free list.
            //
            blockFree->u1.nextFree->u0.prevFree = blockFree->u0.prevFree;
            blockFree->u0.prevFree->u1.nextFree = blockFree->u1.nextFree;
            if (heap->pFreeBlockList == blockFree)
            {
                //
                // This could be the last free block.
                //
                if (blockFree->u1.nextFree == blockFree)
                    heap->pFreeBlockList = 0;
                else
                    heap->pFreeBlockList = blockFree->u1.nextFree;
            }
            blockFree->owner   = owner;
            blockFree->mhandle = UNIQUE_MEMHANDLE();
            blockFree->u0.type = type;
            blockFree->u1.hwres  = pFbAllocInfo->hwResId;
            blockFree->align   = allocAl;
            //
            // Reduce free amount by allocated block size.
            //
            heap->free -= blockFree->end - blockFree->begin + 1;
            *offset     = blockFree->align;
            pFbAllocInfo->offset = *offset;
            //pFbAllocInfo->size = *size - 1;
            if (type == MEM_TYPE_PRIMARY)
            {
                pDev->Framebuffer.PrimarySurfaceAlloced = 0x1;
                pDev->Framebuffer.HalInfo.Start[headNum] = *offset;
            }
            heapFbSetAllocParameters(pDev, pFbAllocInfo);
            HEAP_VALIDATE(heap);
            return (RM_OK);
        }
        else if ((allocLo >= blockFree->begin) && (allocHi <= blockFree->end))
        {
            //
            // Found a fit.
            //
            if (osAllocMem((VOID **)&blockNew, sizeof(MEMBLOCK)) != RM_OK)
            {
                heapFbFree(pDev, pFbAllocInfo->hwResId);
                return (RM_ERR_NO_FREE_MEM);
            }
            blockNew->owner   = owner;
            blockNew->mhandle = UNIQUE_MEMHANDLE();
            blockNew->u0.type = type;
            blockNew->u1.hwres = pFbAllocInfo->hwResId;
            blockNew->begin   = allocLo;
            blockNew->align   = allocAl;
            blockNew->end     = allocHi;
            if (blockFree->end == blockNew->end)
            {
                //
                // New block inserted after free block.
                //
                blockFree->end = blockNew->begin - 1;
                blockNew->next = blockFree->next;
                blockNew->prev = blockFree;
                blockFree->next->prev = blockNew;
                blockFree->next       = blockNew;
            }
            else if (blockFree->begin == blockNew->begin)
            {
                //
                // New block inserted before free block.
                //
                blockFree->begin = blockNew->end + 1;
                blockFree->align = blockFree->begin;
                blockNew->next   = blockFree;
                blockNew->prev   = blockFree->prev;
                blockFree->prev->next = blockNew;
                blockFree->prev       = blockNew;
                if (heap->pBlockList == blockFree)
                    heap->pBlockList  = blockNew;
            }
            else
            {
                heapFbFree(pDev, pFbAllocInfo->hwResId);
                osFreeMem((VOID *)blockNew);
                HEAP_VALIDATE(heap);
                return (RM_ERR_NO_FREE_MEM);
            }
            //
            // Reduce free amount by allocated block size.
            //
            heap->free -= blockNew->end - blockNew->begin + 1;
            *offset     = blockNew->align;
            pFbAllocInfo->offset = *offset;
            //pFbAllocInfo->size = *size - 1;
            if (type == MEM_TYPE_PRIMARY)
            {
                pDev->Framebuffer.PrimarySurfaceAlloced = 0x1;
                pDev->Framebuffer.HalInfo.Start[headNum] = *offset;
            }
            heapFbSetAllocParameters(pDev, pFbAllocInfo);
            HEAP_VALIDATE(heap);
            return (RM_OK);
        }
    } while (blockFree != blockFirstFree);
    //
    // Sorry Charlie, out of memory.  Could in theory try to compact mem and try again. Later.
    //
    heapFbFree(pDev, pFbAllocInfo->hwResId);
    HEAP_VALIDATE(heap);
    return (RM_ERR_NO_FREE_MEM);
}

RM_STATUS blockFree
(
	PHWINFO   pDev,
    PHEAP     heap,
    PMEMBLOCK block
)
{
    PMEMBLOCK blockTmp;

    //
    // Check for valid owner.
    //
    if (block->owner == FREE_BLOCK) return (RM_ERROR);
    //
    // Update free count.
    //
    heap->free += block->end - block->begin + 1;
    //
    // Release any tiling HW resources that might've been in use
    //
    heapFbFree(pDev, block->u1.hwres);

    // Has the primary surface gone away?
    if (block->u0.type == MEM_TYPE_PRIMARY)
        pDev->Framebuffer.PrimarySurfaceAlloced = 0x0;

    //
    //
    // Can this merge with any surrounding free blocks?
    //
    if ((block->prev->owner == FREE_BLOCK) && (block != heap->pBlockList))
    {
        //
        // Merge with previous block.
        //
        block->prev->next = block->next;
        block->next->prev = block->prev;
        block->prev->end  = block->end;
        blockTmp = block;
        block    = block->prev;
        osFreeMem((VOID *)blockTmp);
    }
    if ((block->next->owner == FREE_BLOCK) && (block->next != heap->pBlockList))
    {
        //
        // Merge with next block.
        //
        block->prev->next    = block->next;
        block->next->prev    = block->prev;
        block->next->begin   = block->begin;
        if (heap->pBlockList == block)
            heap->pBlockList  = block->next;
        if (block->owner == FREE_BLOCK)
        {
            if (heap->pFreeBlockList == block)
                heap->pFreeBlockList  = block->u1.nextFree;
            block->u1.nextFree->u0.prevFree = block->u0.prevFree;
            block->u0.prevFree->u1.nextFree = block->u1.nextFree;
        }
        blockTmp = block;
        block    = block->next;
        osFreeMem((VOID *)blockTmp);
    }
    if (block->owner != FREE_BLOCK)
    {
        //
        // Nothing was merged.  Add to free list.
        //
        if (!(blockTmp = heap->pFreeBlockList))
        {
            heap->pFreeBlockList = block;
            block->u1.nextFree      = block;
            block->u0.prevFree      = block;
        }
        else
        {
            if (blockTmp->begin > block->begin)
                //
                // Insert into beginning of free list.
                //
                heap->pFreeBlockList = block;
            else if (blockTmp->u0.prevFree->begin > block->begin)
                //
                // Insert into free list.
                //
                do
                {
                    blockTmp = blockTmp->u1.nextFree;
                } while (blockTmp->begin < block->begin);
                /*
            else
                 * Insert at end of list.
                 */
            block->u1.nextFree = blockTmp;
            block->u0.prevFree = blockTmp->u0.prevFree;
            block->u0.prevFree->u1.nextFree = block;
            blockTmp->u0.prevFree        = block;
        }
    }
    block->owner   = FREE_BLOCK;
    block->mhandle = 0x0;
    block->align   = block->begin;
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapFree
(
	PHWINFO pDev,
    PHEAP heap,
    U032  owner,
    U032  offsetAlign,
    U032  *memHandle
)
{
    PMEMBLOCK block;

    if ((!heap)) return (RM_ERROR);
    if (owner == FREE_BLOCK) return (RM_ERROR);
    //
    // This requires a search through the heap of this memory block.
    // Try and be somewhat intelligent about it.
    //
    block = heap->pBlockList;
    if (offsetAlign > heap->total / 2)
        //
        // Search backward.
        //
        do
        {
            block = block->prev;
            if ((block->align == offsetAlign) && (block->owner == owner))
            {
                //
                // Found it.  Free it. Return the associated memory handle.
                //
                *memHandle = block->mhandle;
                return (blockFree(pDev, heap, block));
            }
        } while ((block != heap->pBlockList) && (block->align > offsetAlign));
    else
        //
        // Search forward.
        //
        do
        {
            if ((block->align == offsetAlign) && (block->owner == owner))
            {
                //
                // Found it.  Free it. Return the associated memory handle.
                //
                *memHandle = block->mhandle;
                return (blockFree(pDev, heap, block));
            }
            block = block->next;
        } while ((block != heap->pBlockList) && (block->align <= offsetAlign));
    HEAP_VALIDATE(heap);
    return (RM_ERROR);
}

RM_STATUS heapPurge
(
	PHWINFO pDev,
    PHEAP heap,
    U032  owner
)
{
    PMEMBLOCK block, blockNext;

    if ((!heap)) return (RM_ERROR);
    //
    // Scan for all the blocks belonging by this owner.
    //
    block = heap->pBlockList;
    do
    {
        blockNext = block->next;
        if (block->owner == owner)
            blockFree(pDev, heap, block);
        block = blockNext;
    } while (block->next != heap->pBlockList);
    //
    // Check the last one.
    //
    if (block->owner == owner)
        blockFree(pDev, heap, block);
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapCompact
(
    PHEAP heap
)
{
    if ((!heap)) return (RM_ERROR);
    //
    // Not implemented.
    //
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapGetSize
(
    PHEAP heap,
    U032 *size
)
{
    if ((!heap)) return (RM_ERROR);
    *size = heap->total;
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapGetFree
(
    PHEAP heap,
    U032 *free
)
{
    if ((!heap)) return (RM_ERROR);
    *free = heap->free;
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapGetBase
(
    PHEAP  heap,
    U008 **base
)
{
    if ((!heap)) return (RM_ERROR);
    *base = heap->base;
    HEAP_VALIDATE(heap);
    return (RM_OK);
}

RM_STATUS heapGetMaxFree
(
    PHEAP heap,
    U032 *maxOffset,
    U032 *maxFree
)
{
    PMEMBLOCK blockFirstFree, blockFree;
    U032 freeBlockSize;

    *maxFree = 0;
    if ((!heap)) return (RM_ERROR);

    if (!(blockFirstFree = heap->pFreeBlockList))
        // There are no free blocks. Max free is already set to 0
        return (RM_OK);

    // Walk the free block list.
    blockFree = blockFirstFree;
    do {
        freeBlockSize = blockFree->end - blockFree->begin + 1;
        if (freeBlockSize > *maxFree)
        {
            *maxOffset = blockFree->begin;
            *maxFree = freeBlockSize;
        }
        blockFree = blockFree->u1.nextFree;
    } while (blockFree != blockFirstFree);

    return (RM_OK);
}

RM_STATUS heapInfo
(
    PHEAP heap,
    U032 *bytesFree,
    U032 *bytesTotal,
    VOID** base,
    U032 *largestOffset,      // largest free blocks offset
    U032 *largestFree         // largest free blocks size
)
{
    RM_STATUS status;

    if ((!heap)) return (RM_ERROR);

    *bytesFree  = heap->free;
    *bytesTotal = heap->total;
    *base  = heap->base;
    status = heapGetMaxFree(heap, largestOffset, largestFree);
    HEAP_VALIDATE(heap);
    return status;
}

RM_STATUS heapInfoFreeBlocks
(
    PHEAP heap,
    U032 *bytesFree,
    U032 *bytesTotal,
    U032  freeOffset1,
    U032  freeOffset2,
    U032  *largestFree
)
{
    PMEMBLOCK blockArg1, blockArg2, blockArgRM; 
    PMEMBLOCK pLocalFreeBlockList = NULL;
    PMEMBLOCK block = NULL, blockFree;
    PMEMBLOCK mergedBlock = NULL, mergedBlock1 = NULL, mergedBlock2 = NULL;
    U032 freeBlockSize;
    BOOL mergedArg1, mergedArg2, mergedArgRM;
    RM_STATUS status = RM_OK;

    if ((!heap)) return (RM_ERROR);

    RM_ASSERT(heap->pBlockList->begin == 0);

    // Find where the block pointers are for the offset arguments
    block = heap->pBlockList;
    blockArg1 = blockArg2 = blockArgRM = NULL;
    do {
        if (block->align == freeOffset1) {
            blockArg1 = block;
            if (blockArg1->owner == FREE_BLOCK)
                return RM_ERROR;    // can't be an already free block
        } else if (block->align == freeOffset2) {
            blockArg2 = block;
            if (blockArg2->owner == FREE_BLOCK)
                return RM_ERROR;    // can't be an already free block
        } else if (!blockArgRM && block->owner == 'NVRM' &&
                   (block->u0.type = MEM_TYPE_PRIMARY)) {
            blockArgRM = block;     // checking only 1 RM primary surface
        }
        block = block->next;
    } while (block != heap->pBlockList);

    // Check if we found the block for offset1
    if ((freeOffset1 != (U032)-1) && (blockArg1 == NULL))
        return RM_ERROR;

    // Check if we found the block for offset2
    if ((freeOffset2 != (U032)-1) && (blockArg2 == NULL))
        return RM_ERROR;

    //
    // Handle the special case where both freeOffsets map to adjacent blocks.
    // Create a combined blockArg that describes both blocks (clearing the other
    // blockArg pointer). This doesn't disturb the active freelist block ptrs.
    //
    if (blockArg1 && blockArg2) {
        if (((blockArg1->next == blockArg2) && (blockArg2 != heap->pBlockList)) ||
            ((blockArg2->next == blockArg1) && (blockArg1 != heap->pBlockList))) {

            // Create a combined block for both blockArgs
            if (osAllocMem((VOID **)&mergedBlock, sizeof(MEMBLOCK)) != RM_OK) {
                status = RM_ERR_NO_FREE_MEM;
                goto Done;
            }

            // Copy the merged values
            if (blockArg1->next == blockArg2) {
                mergedBlock->begin = blockArg1->begin;
                mergedBlock->prev  = blockArg1->prev;
                mergedBlock->end   = blockArg2->end;
                mergedBlock->next  = blockArg2->next;
            } else {
                mergedBlock->begin = blockArg2->begin;
                mergedBlock->prev  = blockArg2->prev;
                mergedBlock->end   = blockArg1->end;
                mergedBlock->next  = blockArg1->next;
            }

            // Now, we're down to one less block to check
            blockArg1 = mergedBlock;
            blockArg2 = NULL;
        }
    }
    if (blockArg1 && blockArgRM) {
        if (((blockArg1->next == blockArgRM) && (blockArgRM != heap->pBlockList)) ||
            ((blockArgRM->next == blockArg1) && (blockArg1 != heap->pBlockList))) {

            // Create a combined block for both blockArgs
            if (osAllocMem((VOID **)&mergedBlock1, sizeof(MEMBLOCK)) != RM_OK) {
                status = RM_ERR_NO_FREE_MEM;
                goto Done;
            }

            // Copy the merged values
            if (blockArg1->next == blockArgRM) {
                mergedBlock1->begin = blockArg1->begin;
                mergedBlock1->prev  = blockArg1->prev;
                mergedBlock1->end   = blockArgRM->end;
                mergedBlock1->next  = blockArgRM->next;
            } else {
                mergedBlock1->begin = blockArgRM->begin;
                mergedBlock1->prev  = blockArgRM->prev;
                mergedBlock1->end   = blockArg1->end;
                mergedBlock1->next  = blockArg1->next;
            }

            // Now, we're down to one less block to check
            blockArg1 = mergedBlock1;
            blockArgRM = NULL;
        }
    }
    if (blockArgRM && blockArg2) {
        if (((blockArgRM->next == blockArg2) && (blockArg2 != heap->pBlockList)) ||
            ((blockArg2->next == blockArgRM) && (blockArgRM != heap->pBlockList))) {

            // Create a combined block for both blockArgs
            if (osAllocMem((VOID **)&mergedBlock2, sizeof(MEMBLOCK)) != RM_OK) {
                status = RM_ERR_NO_FREE_MEM;
                goto Done;
            }

            // Copy the merged values
            if (blockArgRM->next == blockArg2) {
                mergedBlock2->begin = blockArgRM->begin;
                mergedBlock2->prev  = blockArgRM->prev;
                mergedBlock2->end   = blockArg2->end;
                mergedBlock2->next  = blockArg2->next;
            } else {
                mergedBlock2->begin = blockArg2->begin;
                mergedBlock2->prev  = blockArg2->prev;
                mergedBlock2->end   = blockArgRM->end;
                mergedBlock2->next  = blockArgRM->next;
            }

            // Now, we're down to a single blockArg to check
            blockArgRM = mergedBlock2;
            blockArg2 = NULL;
        }
    }

    mergedArg1 = mergedArg2 = mergedArgRM = FALSE;

    //
    // Setup our freelist by duplicating the real heap->pBlockFreeList. We'll
    // also coalesce the blockArgs with surrounding free blocks as we go.
    //
    if (heap->pFreeBlockList) {
        blockFree = heap->pFreeBlockList;
        do {
            // Create a copy of this free block
            status = osAllocMem((VOID **)&block, sizeof(MEMBLOCK));
            if (status != RM_OK)
                goto Done;    // failed to dup, so cleanup and return

            // Copy the blockFree's initial values
            block->begin    = blockFree->begin;
            block->end      = blockFree->end;

            // 
            // Check if free block precedes blockArg1, blockArg2 or blockArgRM
            //
            // N.B., comparing (blockArg->begin != 0x0) should be equivalent to
            // checking for (blockArg != heap->pBlockList), both are trying to
            // determine if we're at the beginning of the list.
            //
            if (blockArg1 && ((blockArg1->prev == blockFree) && blockArg1->begin)) {
                mergedArg1 = TRUE;
                block->end = blockArg1->end;
            }
            if (blockArg2 && ((blockArg2->prev == blockFree) && blockArg2->begin)) {
                mergedArg2 = TRUE;
                block->end = blockArg2->end;
            }
            if (blockArgRM && ((blockArgRM->prev == blockFree) && blockArgRM->begin)) {
                mergedArgRM = TRUE;
                block->end = blockArgRM->end;        // include a RM primary surface
            }

            // 
            // Check if free block succeeds blockArg1, blockArg2 or blockArgRM
            //
            if (blockArg1 &&
                ((blockArg1->next == blockFree) && (blockFree != heap->pBlockList))) {
                //
                // If a free block also preceded blockArg, then we want to concatenate
                // the two free blocks and can free up the dup block we already allocated
                //
                if (pLocalFreeBlockList &&
                    ((pLocalFreeBlockList->u0.prevFree->end+1) == blockFree->begin)) {
                    pLocalFreeBlockList->u0.prevFree->end = block->end;
                    osFreeMem((VOID *)block);
                    block = NULL;
                } else
                    block->begin = blockArg1->begin;
                mergedArg1 = TRUE;
            }
            if (blockArg2 &&
                ((blockArg2->next == blockFree) && (blockFree != heap->pBlockList))) {
                //
                // If a free block also preceded blockArg, then we want to concatenate
                // the two free blocks and can free up the dup block we already allocated
                //
                if (pLocalFreeBlockList &&
                    ((pLocalFreeBlockList->u0.prevFree->end+1) == blockFree->begin)) {
                    pLocalFreeBlockList->u0.prevFree->end = block->end;
                    osFreeMem((VOID *)block);
                    block = NULL;
                } else
                    block->begin = blockArg2->begin;
                mergedArg2 = TRUE;
            }
            if (blockArgRM &&
                ((blockArgRM->next == blockFree) && (blockFree != heap->pBlockList))) {
                //
                // If a free block also preceded blockArgRM, then we want to concatenate
                // the two free blocks and can free up the dup block we already allocated
                // 
                if (pLocalFreeBlockList &&
                    ((pLocalFreeBlockList->u0.prevFree->end+1) == blockFree->begin)) {
                    pLocalFreeBlockList->u0.prevFree->end = block->end;
                    osFreeMem((VOID *)block);
                    block = NULL;
                } else 
                    block->begin = blockArgRM->begin;
                mergedArgRM = TRUE;
            }

            // Add this block to our list of free blocks
            if (block) {
                if (pLocalFreeBlockList == NULL) {
                    block->u0.prevFree  = block;
                    block->u1.nextFree  = block;
                    pLocalFreeBlockList = block;
                } else {
                    block->u0.prevFree  = pLocalFreeBlockList->u0.prevFree;
                    block->u1.nextFree  = pLocalFreeBlockList;
                    pLocalFreeBlockList->u0.prevFree->u1.nextFree = block;
                    pLocalFreeBlockList->u0.prevFree = block;
                }
            }

            blockFree = blockFree->u1.nextFree;
        } while (blockFree != heap->pFreeBlockList);
    }

    //
    // At this point, we have a built up a pLocalFreeBlockList, that has
    // taken into account any blocks that we can consider freed. Now, find
    // the largest contiguous block that would be availble.
    //
    *bytesFree  = *largestFree = 0;
    *bytesTotal = heap->total;

    blockFree = pLocalFreeBlockList;
    if (blockFree) {
        // Walk the free block list.
        do {
            freeBlockSize = blockFree->end - blockFree->begin + 1;
            *bytesFree += freeBlockSize;
            if (freeBlockSize > *largestFree)
                *largestFree = freeBlockSize;
            blockFree = blockFree->u1.nextFree;
        } while (blockFree != pLocalFreeBlockList);
    }

    //
    // Since the blockArgs weren't added to the pLocalFreeBlockList, if
    // there was no coalescing that occurred, the blockArgs may hold the
    // largest free block (and are added into the total free amount).
    //
    if (blockArg1 && (mergedArg1 == FALSE)) {
        freeBlockSize = blockArg1->end - blockArg1->begin + 1;
        *bytesFree += freeBlockSize;
        if (freeBlockSize > *largestFree)
            *largestFree = freeBlockSize;
    }
    if (blockArg2 && (mergedArg2 == FALSE)) {
        freeBlockSize = blockArg2->end - blockArg2->begin + 1;
        *bytesFree += freeBlockSize;
        if (freeBlockSize > *largestFree)
            *largestFree = freeBlockSize;
    }
    if (blockArgRM && (mergedArgRM == FALSE)) {
        freeBlockSize = blockArgRM->end - blockArgRM->begin + 1;
        *bytesFree += freeBlockSize;
        if (freeBlockSize > *largestFree)
            *largestFree = freeBlockSize;
    }

Done:
    // Free up whatever is on our pLocalFreeBlockList
    blockFree = pLocalFreeBlockList;
    if (blockFree) {
        do {
            block = blockFree->u1.nextFree;
            osFreeMem((VOID *)blockFree);
            blockFree = block;
        } while (blockFree != pLocalFreeBlockList);
    }
    // Free up the mergedBlock, if one was created
    if (mergedBlock)
        osFreeMem((VOID *)mergedBlock);
    if (mergedBlock1)
        osFreeMem((VOID *)mergedBlock1);
    if (mergedBlock2)
        osFreeMem((VOID *)mergedBlock2);

    HEAP_VALIDATE(heap);
    return status;
}

//
// These routines may need to be mutexed if there are hardware
// resources involved.
//
RM_STATUS heapFbSetAllocParameters
(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
)
{
    RM_STATUS status;

    //
    // If we're in VGA mode, do not set tiling parameters until after we've
    // done a modeset into an accelerated mode to prevent from corrupting
    // the VGA splash screen on win9x (see fbstate.c for when this
    // happens).
    //
    if (pDev->Vga.Enabled && (pFbAllocInfo->type == MEM_TYPE_PRIMARY) && (pFbAllocInfo->hwResId != 0))
        return (RM_OK);

    if (pFbAllocInfo->hwResId)
        osEnterCriticalCode(pDev);

    status = nvHalFbSetAllocParameters(pDev, pFbAllocInfo);

    if (pFbAllocInfo->hwResId)
        osExitCriticalCode(pDev);

    return status;
}

static RM_STATUS heapFbFree
(
	PHWINFO pDev,
    U032 hwResId
)
{
    U032 i;
    RM_STATUS status;

    if (hwResId)
        osEnterCriticalCode(pDev);

    status = nvHalFbFree(pDev, hwResId);

    // Also, reset PrimaryFbAllocInfo if the hwResID matches
    if (hwResId) {
        for (i = 0; i < MAX_CRTCS; i++) {
            if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId == hwResId)
                pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId = 0;
        }
    }

    if (hwResId)
        osExitCriticalCode(pDev);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\Ahal.h ===
#if !defined _AHALH_
#define _AHALH_

#if defined __cplusplus
extern "C"
{
#endif

// can be max 255
#define MAX_CLIENTS		            8

typedef struct
{
    PISRCALLBACK	pFn;
    INTR_MASK		Mask;
    VOID			*pContext;
} MCP1_CLIENT_INFO, *PMCP1_CLIENT_INFO;


RM_STATUS InitAudioHal(U008 uRevID, HWINFO_COMMON_FIELDS *pDev);
VOID DestroyAudioHal(HWINFO_COMMON_FIELDS *pDev);

RM_STATUS AllocDevice(HWINFO_COMMON_FIELDS *pDev);
RM_STATUS FreeDevice(HWINFO_COMMON_FIELDS *pDev);

RM_STATUS DeviceAddClient(HWINFO_COMMON_FIELDS *pDev, VOID *pParam, U008 *pClientRef);
RM_STATUS DeviceRemoveClient(HWINFO_COMMON_FIELDS *pDev, U008 uClientRef);

RM_STATUS AllocContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam);
RM_STATUS FreeContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam);

RM_STATUS AllocObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam);
RM_STATUS FreeObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam);

RM_STATUS InterruptService(HWINFO_COMMON_FIELDS *pDev);

#if defined __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\hal\nv20\halnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** HAL Data *********************************\
*                                                                           *
* Module: HALNV20.C                                                         *
*   The chip dependent HAL data is kept here.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <nv20_ref.h>
#include <nv20_hal.h>
#include <nv20_gr.h>
#include "nvhw.h"

//-----------------------------------------------------------------------
// NV20 HAL engine descriptor table.
//-----------------------------------------------------------------------

//
// Engine default per-object instance memory sizes (16byte units).
//
#define GR_OBJINSTSZ                    0x1

ENGINEDESCRIPTOR NV20_EngineDescriptors[] =
{
    //
    // master controller
    //
    MKENGDECL(MC_ENGINE_TAG, 0, 0),
    MKENGMALLOC(MC_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MCHALINFO_NV20)/4),

    //
    // frame buffer
    //
    MKENGDECL(FB_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FB_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (FBHALINFO_NV20)/4),

    //
    // dac
    //
    MKENGDECL(DAC_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    //
    // timer
    //
    MKENGDECL(TMR_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    //
    // dma -- the size of a DMA object is setup via nvHalDmaAlloc
    //
    MKENGDECL(DMA_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),

    //
    // graphics
    //
    MKENGDECL(GR_ENGINE_TAG, NV_RAMHT_ENGINE_GRAPHICS, GR_OBJINSTSZ),
    MKENGMALLOC(GR_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (GRHALINFO_NV20)/4),
    // channel_ctx_table is 32 channels * 4bytes
    MKENGINSTMALLOC(GR_ENGINE_TAG, 1, (32 * 4)/16),

    //
    // fifo
    //
    MKENGDECL(FIFO_ENGINE_TAG, 0, 0),
    MKENGMALLOC(FIFO_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (FIFOHALINFO_NV20)/4),

    //
    // mediaport
    //
    MKENGDECL(MP_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0),
    MKENGMALLOC(MP_ENGINE_TAG, ENGMALLOC_TYPE_PRIVATE, sizeof (MPHALINFO_NV20)/4),

    //
    // video
    //
    MKENGDECL(VIDEO_ENGINE_TAG, NV_RAMHT_ENGINE_SW, 0)
};

U032 NV20_NumEngineDescs = (sizeof (NV20_EngineDescriptors) / sizeof (ENGINEDESCRIPTOR));

//-----------------------------------------------------------------------
// NV20 HAL class descriptor table.
//-----------------------------------------------------------------------

//
// The base classes supported for all NV20 Architectures
//
#define NV20_ARCHITECTURE_CLASS_DESCRIPTORS                                                         \
    /* fifo engine classes */                                                                       \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_PIO),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV03_CHANNEL_DMA),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_PIO),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV04_CHANNEL_DMA),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV10_CHANNEL_DMA),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
    MKCLASSDECL(FIFO_ENGINE_TAG, 0, NV20_CHANNEL_DMA),                                              \
    MKCLASSINSTMALLOC(1, (NV20_GR_CONTEXT_SIZE/16)),                                                \
                                                                                                    \
    /* graphics engine classes */                                                                   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA_SOLID, NV01_CONTEXT_BETA),                      \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV01_CONTEXT_COLOR_KEY),                  \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV01_CONTEXT_PATTERN),                      \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_CLIP, NV01_CONTEXT_CLIP_RECTANGLE),                  \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_RENDER_SOLID_LIN),                                     \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_RENDER_SOLID_TRIANGLE),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_IMAGE_BLIT),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV01_IMAGE_FROM_CPU),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV1_NULL),                                                  \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_STRETCHED_IMAGE_FROM_CPU),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_SCALED_IMAGE_FROM_MEMORY),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_MEMORY_TO_MEMORY_FORMAT),                              \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_ROP, NV03_CONTEXT_ROP),                              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV03_GDI_RECTANGLE_TEXT),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_DESTINATION),   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV03_CONTEXT_SURFACE_2D_SOURCE),        \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_DEPTH),         \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_3D, NV03_CONTEXT_SURFACE_3D_COLOR),         \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_DVD, NV04_DVD_SUBPICTURE),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV04_CONTEXT_SURFACES_2D),              \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_PATTERN, NV04_CONTEXT_PATTERN),                      \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_GDI_RECTANGLE_TEXT),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED),   \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_COLOR_KEY, NV04_CONTEXT_COLOR_KEY),                  \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_RENDER_SOLID_LIN),                                     \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_RENDER_SOLID_TRIANGLE),                                \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_IMAGE_BLIT),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_IMAGE_FROM_CPU),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_BETA, NV04_CONTEXT_BETA),                            \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_STRETCHED_IMAGE_FROM_CPU),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV04_SCALED_IMAGE_FROM_MEMORY),                             \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_SCALED_IMAGE_FROM_MEMORY),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_INDEXED_IMAGE_FROM_CPU),                               \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_IMAGE_FROM_CPU),                                       \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV05_STRETCHED_IMAGE_FROM_CPU),                             \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_2D, NV10_CONTEXT_SURFACES_2D),              \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_TEXTURE_FROM_CPU),                                     \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_DVD, NV10_DVD_SUBPICTURE),                                   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_SCALED_IMAGE_FROM_MEMORY),                             \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV10_IMAGE_FROM_CPU),                                       \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV11_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV11_SCALED_IMAGE_FROM_MEMORY),                             \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV15_CELSIUS_PRIMITIVE),                                    \
    MKCLASSDECL(GR_ENGINE_TAG, GR_LOCK_CONTEXT_SURFACES_SWIZZLED, NV15_CONTEXT_SURFACE_SWIZZLED),   \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV15_IMAGE_BLIT),                                           \
                                                                                                    \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV20_IMAGE_BLIT),                                           \
    MKCLASSDECL(GR_ENGINE_TAG, NO_LOCK, NV20_KELVIN_PRIMITIVE),                                     \
    MKCLASSINSTMALLOC(NV20_KELVIN_CONTEXT_ALIGN/16, NV20_KELVIN_CONTEXT_SIZE/16),                   \
                                                                                                    \
    /* dac engine classes */                                                                        \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV04_VIDEO_LUT_CURSOR_DAC),                                      \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV05_VIDEO_LUT_CURSOR_DAC),                                      \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV10_VIDEO_LUT_CURSOR_DAC),                                      \
    MKCLASSDECL(DAC_ENGINE_TAG, 0, NV15_VIDEO_LUT_CURSOR_DAC),                                      \
                                                                                                    \
    /* mediaport engine classes */                                                                  \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECODER, NV03_EXTERNAL_VIDEO_DECODER),                       \
    MKCLASSDECL(MP_ENGINE_TAG, MP_LOCK_DECOMPRESSOR, NV03_EXTERNAL_VIDEO_DECOMPRESSOR),             \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV01_EXTERNAL_PARALLEL_BUS),                                \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV03_EXTERNAL_MONITOR_BUS),                                 \
    MKCLASSDECL(MP_ENGINE_TAG, NO_LOCK, NV04_EXTERNAL_SERIAL_BUS),                                  \
                                                                                                    \
    /* video engine classes */                                                                      \
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV04_VIDEO_OVERLAY),                                     \
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV10_VIDEO_OVERLAY),

CLASSDESCRIPTOR NV20_ClassDescriptors[] =
{
    NV20_ARCHITECTURE_CLASS_DESCRIPTORS
};

U032 NV20_NumClassDescs = (sizeof (NV20_ClassDescriptors) / sizeof (CLASSDESCRIPTOR));

//-----------------------------------------------------------------------
// NV20 HAL function table layout.
//-----------------------------------------------------------------------

//
// temporary stub routine
// 
RM_STATUS nvHalStub_NV20(VOID *arg) { return RM_ERROR; }

// mc interfaces
extern RM_STATUS nvHalMcControl_NV20(VOID *);
extern RM_STATUS nvHalMcPower_NV20(VOID *);

// fifo interfaces
extern RM_STATUS nvHalFifoControl_NV20(VOID *);
extern RM_STATUS nvHalFifoAllocPio_NV20(VOID *);
extern RM_STATUS nvHalFifoAllocDma_NV20(VOID *);
extern RM_STATUS nvHalFifoFree_NV20(VOID *);
extern RM_STATUS nvHalFifoGetExceptionData_NV20(VOID *);
extern RM_STATUS nvHalFifoService_NV20(VOID *);
extern RM_STATUS nvHalFifoAccess_NV20(VOID *);
extern RM_STATUS nvHalFifoHashAdd_NV20(VOID *);
extern RM_STATUS nvHalFifoHashDelete_NV20(VOID *);
extern RM_STATUS nvHalFifoHashFunc_NV20(VOID *);
extern RM_STATUS nvHalFifoHashSearch_NV20(VOID *);

// framebuffer interfaces
extern RM_STATUS nvHalFbControl_NV20(VOID *);
extern RM_STATUS nvHalFbAlloc_NV20(VOID *);
extern RM_STATUS nvHalFbFree_NV20(VOID *);
extern RM_STATUS nvHalFbSetAllocParameters_NV20(VOID *);
extern RM_STATUS nvHalFbGetSurfacePitch_NV20(VOID *);
extern RM_STATUS nvHalFbGetSurfaceDimensions_NV20(VOID *);
extern RM_STATUS nvHalFbLoadOverride_NV20(VOID *);

// graphics interfaces
extern RM_STATUS nvHalGrControl_NV20(VOID *);
extern RM_STATUS nvHalGrAlloc_NV20(VOID *);
extern RM_STATUS nvHalGrFree_NV20(VOID *);
extern RM_STATUS nvHalGrGetExceptionData_NV20(VOID *);
extern RM_STATUS nvHalGrService_NV20(VOID *);
extern RM_STATUS nvHalGrGetNotifyData_NV20(VOID *);
extern RM_STATUS nvHalGrSetObjectContext_NV20(VOID *);
#define nvHalGrLoadOverride_NV20 nvHalStub_NV20

// dma interfaces
extern RM_STATUS nvHalDmaControl_NV20(VOID *);
extern RM_STATUS nvHalDmaAlloc_NV20(VOID *);
extern RM_STATUS nvHalDmaFree_NV20(VOID *);
extern RM_STATUS nvHalDmaGetInstSize_NV20(VOID *);

// dac interfaces
extern RM_STATUS nvHalDacControl_NV20(VOID *);
extern RM_STATUS nvHalDacAlloc_NV20(VOID *);
extern RM_STATUS nvHalDacFree_NV20(VOID *);
extern RM_STATUS nvHalDacSetStartAddr_NV20(VOID *);
extern RM_STATUS nvHalDacProgramMClk_NV20(VOID *);
extern RM_STATUS nvHalDacProgramNVClk_NV20(VOID *);
extern RM_STATUS nvHalDacProgramPClk_NV20(VOID *);
extern RM_STATUS nvHalDacProgramCursorImage_NV20(VOID *);
extern RM_STATUS nvHalDacGetRasterPosition_NV20(VOID *);
extern RM_STATUS nvHalDacValidateArbSettings_NV20(VOID *arg);
extern RM_STATUS nvHalDacUpdateArbSettings_NV20(VOID *arg);

// mediaport interfaces
extern RM_STATUS nvHalMpControl_NV20(VOID *);
extern RM_STATUS nvHalMpAlloc_NV20(VOID *);
extern RM_STATUS nvHalMpFree_NV20(VOID *);
extern RM_STATUS nvHalMpMethod_NV20(VOID *);
extern RM_STATUS nvHalMpGetEventStatus_NV20(VOID *);
extern RM_STATUS nvHalMpServiceEvent_NV20(VOID *);

// mediaport interfaces
extern RM_STATUS nvHalVideoControl_NV20(VOID *);
extern RM_STATUS nvHalVideoAlloc_NV20(VOID *);
extern RM_STATUS nvHalVideoFree_NV20(VOID *);
extern RM_STATUS nvHalVideoMethod_NV20(VOID *);
extern RM_STATUS nvHalVideoGetEventStatus_NV20(VOID *);
extern RM_STATUS nvHalVideoServiceEvent_NV20(VOID *);

HALFUNCS_000 NV20_HalFuncs_000 =
{
    // mc interfaces
    nvHalMcControl_NV20,
    nvHalMcPower_NV20,

    // fifo interfaces
    nvHalFifoControl_NV20,
    nvHalFifoAllocPio_NV20,
    nvHalFifoAllocDma_NV20,
    nvHalFifoFree_NV20,
    nvHalFifoGetExceptionData_NV20,
    nvHalFifoService_NV20,
    nvHalFifoAccess_NV20,
    nvHalFifoHashAdd_NV20,
    nvHalFifoHashDelete_NV20,
    nvHalFifoHashFunc_NV20,
    nvHalFifoHashSearch_NV20,

    // framebuffer interfaces
    nvHalFbControl_NV20,
    nvHalFbAlloc_NV20,
    nvHalFbFree_NV20,
    nvHalFbSetAllocParameters_NV20,
    nvHalFbGetSurfacePitch_NV20,
    nvHalFbGetSurfaceDimensions_NV20,
    nvHalFbLoadOverride_NV20,

    // graphics interfaces
    nvHalGrControl_NV20,
    nvHalGrAlloc_NV20,
    nvHalGrFree_NV20,
    nvHalGrGetExceptionData_NV20,
    nvHalGrService_NV20,
    nvHalGrGetNotifyData_NV20,
    nvHalGrSetObjectContext_NV20,
    nvHalGrLoadOverride_NV20,

    // dma interface
    nvHalDmaControl_NV20,
    nvHalDmaAlloc_NV20,
    nvHalDmaFree_NV20,
    nvHalDmaGetInstSize_NV20,

    // dac interfaces
    nvHalDacControl_NV20,
    nvHalDacAlloc_NV20,
    nvHalDacFree_NV20,
    nvHalDacSetStartAddr_NV20,
    nvHalDacProgramMClk_NV20,
    nvHalDacProgramNVClk_NV20,
    nvHalDacProgramPClk_NV20,
    nvHalDacProgramCursorImage_NV20,
    nvHalDacGetRasterPosition_NV20,
    nvHalDacValidateArbSettings_NV20,
    nvHalDacUpdateArbSettings_NV20,

    // mp interfaces
    nvHalMpControl_NV20,
    nvHalMpAlloc_NV20,
    nvHalMpFree_NV20,
    nvHalMpMethod_NV20,
    nvHalMpGetEventStatus_NV20,
    nvHalMpServiceEvent_NV20,

    // mp interfaces
    nvHalVideoControl_NV20,
    nvHalVideoAlloc_NV20,
    nvHalVideoFree_NV20,
    nvHalVideoMethod_NV20,
    nvHalVideoGetEventStatus_NV20,
    nvHalVideoServiceEvent_NV20
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\control.h ===
#ifndef _CONTROL_H_
#define _CONTROL_H_
/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: CONTROL.H                                                         *
*       Control method implementation.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Bruce Thompson (brucet)    02/22/96 - wrote it.                     *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
// Miscellaneous structure definitions.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Control object defines.
//
//---------------------------------------------------------------------------
typedef struct _def_ctrlmethod CTRLMETHOD, *PCTRLMETHOD;
typedef struct _def_ctrlclass  CTRLCLASS,  *PCTRLCLASS;

// Control method structure
typedef RM_STATUS (*CTRLMETHODPROC)(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
struct _def_ctrlmethod
{
    CTRLMETHODPROC Proc;
    U032           Low;
    U032           High;
};

// Control class structure
struct _def_ctrlclass
{
    PCTRLMETHOD Method;
    U032        MethodMax;
};

// The class which defines the NV control area
extern CTRLCLASS NvControlClass;

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------
RM_STATUS mthdSetObject(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);

#ifdef OBSOLETE_FUNCTIONS
RM_STATUS mthdSetStallNotifier(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
RM_STATUS mthdStallChannel(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
RM_STATUS mthdPush(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
RM_STATUS mthdPop(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
RM_STATUS mthdPasswd(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
RM_STATUS mthdDmaPusher(PHWINFO, U032, U032, PCTRLMETHOD, U032, U032);
#endif

#endif // _CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\clinklist.h ===
#if !defined _CLINKLISTH_
#define _CLINKLISTH_

// C++ class that can be used as a base class by objects that
// are links in a linked list

class CLinkList
{
public:
    CLinkList() { m_pNext = m_pPrev = NULL; }

public:
    virtual VOID Add(CLinkList **ppHead)
    {
        m_pPrev = NULL;
        m_pNext = *ppHead;

        if (*ppHead)
            (*ppHead)->SetPrev(this);

        *ppHead = this;
    }

    virtual VOID Remove(CLinkList **ppHead)
    {
        if (m_pPrev)
            m_pPrev->SetNext(m_pNext);

        if (m_pNext)
            m_pNext->SetPrev(m_pPrev);
    
        if (*ppHead == this)
            *ppHead = m_pNext;
    }
    
    virtual BOOL Exists(CLinkList *pElem)
    {
        CLinkList *pTemp = this;

        while (pTemp)
        {
            if (pTemp == pElem)
                return TRUE;

            pTemp = pTemp->GetNext();
        }
        
        return FALSE;
    }

    CLinkList *GetNext() { return m_pNext; }
    CLinkList *GetPrev() { return m_pPrev; }

    virtual VOID SetNext(CLinkList *pNext) { m_pNext = pNext; }
    virtual VOID SetPrev(CLinkList *pPrev) { m_pPrev = pPrev; }

private:
    CLinkList *m_pNext;
    CLinkList *m_pPrev;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\cursor.h ===
#ifndef _CURSOR_H_
#define _CURSOR_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1997. All rights reserved.
//
/******************************* Cursor Module ******************************\
*                                                                           *
* Module: cursor.h                                                          *
*       cursor image and DAC support routines.                              *                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Putnam (putnam)    12/05/97 - genesis                           *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Function prototypes for the cursor class.
//
//---------------------------------------------------------------------------

RM_STATUS cursLutDacCreate(PCLASSOBJECT, POBJECT *);
RM_STATUS cursLutDacDestroy(PCLASSOBJECT);
RM_STATUS cursLutDacSetNotifyCtxDma(POBJECT, PMETHOD, U032, U032);
RM_STATUS cursLutDacSetNotify(POBJECT, PMETHOD, U032, U032);

RM_STATUS cursLutNtscCreate(PCLASSOBJECT, POBJECT *);
RM_STATUS cursLutNtscDestroy(PCLASSOBJECT);
RM_STATUS cursLutNtscSetNotifyCtxDma(POBJECT, PMETHOD, U032, U032);
RM_STATUS cursLutNtscSetNotify(POBJECT, PMETHOD, U032, U032);

RM_STATUS cursLutOvlDacCreate(PCLASSOBJECT, POBJECT *);
RM_STATUS cursLutOvlDacDestroy(PCLASSOBJECT);
RM_STATUS cursLutOvlDacSetNotifyCtxDma(POBJECT, PMETHOD, U032, U032);
RM_STATUS cursLutOvlDacSetNotify(POBJECT, PMETHOD, U032, U032);

#endif // _CURSOR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\arb_fifo.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** ARB Structures ****************************\
*                                                                           *
* Module: ARB_FIFO.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _ARB_FIFO_H
#define _ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {

  U032 crtc1_lwm;    // GR LWM
  U032 crtc2_lwm;    // GR LWM (NV11)
  U032 video_lwm;    // Video LWM

  U032 crtc1_burst_size;
  U032 crtc2_burst_size;
  U032 video_burst_size;

  U032 valid;  // good values

} fifo_info;

typedef struct {
  U032 hres;     //horizontal resolution, for head 1, in pixels
  U032 htotal;   //Total number of horizontal pixels, including blanking and sync pixels.
                //Used to calculate horizontal line period from PClk.
  U032 vres;     //vertical resolution, for head 1, in lines
  U032 refresh;  //refresh rate for head 1, in Hz

  //Same values, but for head 2:
  U032 hres2;
  U032 htotal2;
  U032 vres2;
  U032 refresh2;

  U032 pclk_khz;
  U032 pclk2_khz;
  U032 mclk_khz;
  U032 nvclk_khz;
  U032 memory_width;   //FBI width, in bits (e.g., 256)
  U032 memory_type;    //0=sdr, 1=ddr

  U032 h2_owns_vs;     //1 = scaler is displaying on head 2.  0 = scaler is displaying on head 1.
  U032 video_source_hres; //number of pixels/texels/samples in the video source horizontally, and
  U032 video_source_vres; //vertically.

//  U032  memory_width;
//  char memory_type;
  //8, 16 or 32 bits per pixel
  U032 pix_bpp;        //color depth on head 1
  U032 pix_bpp_h2;     //color depth on head 2
  //(scaler is always 16 bpp)
//  char pix_bpp;

  //Are these engines in use?  1=yes, 0=no.
  char enable_h1;     //First head
  char enable_h2;     //Second head
  char enable_video;
  char enable_mp;
  U032  ram_config;

  //No longer used (NV11)
  char mem_page_miss;
  char mem_latency; //cas_latency
  char gr_during_vid;
  char mem_aligned;
} sim_state;


//    new NV11
typedef struct {
  U032 hres;
  U032 vres;
  U032 depth;
  U032 refresh;
} screen_t;

typedef struct {
  U032 lwm;
  U032 lwm_min;
  U032 size;
} fifo_params;
  
typedef enum { CRTC_MODE_OLD, CRTC_MODE_NEW } crtc_mode;

typedef struct {
  U032 enable;
  U032 hres;
  U032 vres;
  U032 depth;
  U032 refresh;
  U032 pclk;         //in MHz
  U032 pclk_period;  //in ps (no longer ns!!!)
  U032 hclk_period;  //in ns
  U032 drain_rate;
  crtc_mode mode;
  U032 burst_size;
  U032 min_burst_size;
  U032 max_burst_size;
  U032 cursor_burst_size;
  U032 request_delay;
  fifo_params fifo;
} crtc_t;

typedef struct {
  U032 enable;
  U032 source_hres;
  U032 source_vres;
  U032 depth;
  U032 window_hres;
  U032 window_vres;
  U032 hscale; //now in 1000x units?
  U032 vscale;
  U032 burst_size;
  U032 min_burst_size;
  U032 max_burst_size;
  U032 request_delay;
  U032 drain_rate;
  fifo_params fifo;
  U032 h2_owns_vs;
  U032 max_fifo_size;
  U032 pclk_period;//now in ps, not ns
} scaler_t;

typedef enum { round_robin, rtr_interleave, rtr_interrupt, rtr_priority } arb_type;

typedef struct {
  U032 mclk;
  U032 mclk_period; //now in ps, no longer ns
  U032 partitions;
  U032 ddr;
  U032 data_rate;
  U032 page_fault_penalty;
  U032 page_fault_width;
  U032 refresh_penalty;
  U032 arbitration_latency;
  arb_type arbiter;
  U032 pipeline_latency;
  U032 stall_cycles;
  U032 cmdq_depth_rw;
  U032 cmdq_depth_cmd;
  U032 command_latency;
  U032 interrupt_rate;
} mem_t;

typedef struct {
  U032 burst_size;
  U032 request_delay_mclks;
  U032 request_delay;
  U032 latency;
} rtr_t;


#define VIDEO       0
#define GRAPHICS    1
#define MPORT       2
#define ENGINE      3


#define GFIFO_SIZE      320     /* Graphics Fifo Sizes */
#define GFIFO_SIZE_128  256     /* Graphics Fifo Sizes */
#define MFIFO_SIZE      120     /* MP  Fifo Sizes */
#define VFIFO_SIZE      256     /* Video Fifo Sizes */

#define    ABS(a)    (a>0?a:-a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\AudioHw.h ===
#if !defined _AUDIODEF_H_
#define _AUDIODEF_H_

#pragma pack (push, _store_)
#pragma pack (1)

#include <nvtypes.h>

#define VOLU32		U032 volatile
#define VOLU16		U016 volatile
#define VOLU8		U08 volatile

// interrupt registers
typedef union
{
	struct
	{	
		VOLU32 General		: 1;
		VOLU32 DeltaWarning : 1;
		VOLU32 RetriggerEvent : 1;		/* not in INTERRUPT_ENABLE  */
		VOLU32 DeltaPanic	: 1;
		VOLU32 FETrap		: 1;
		VOLU32 FENotify		: 1;
		VOLU32 FEVoice		: 1;
		VOLU32 FEMethodOverFlow : 1;
		VOLU32 GPMailbox	: 1;
		VOLU32 GPNotify		: 1;
		VOLU32 EPMailbox	: 1;
		VOLU32 EPNotify		: 1;
		VOLU32				: 21;
	};
	
	VOLU32 uValue;
} R_INTR;

// front end
typedef union
{
	struct
	{	
		VOLU32 NotifyISO	: 1;
		VOLU32 ReadISO		: 1;
		VOLU32 WriteISO		: 1;
		VOLU32 TrapOnNotifier : 1;
		VOLU32 Lock			: 1;
		VOLU32 Mode			: 3;
		VOLU32 TrapReason	: 4;
        VOLU32 PIOClass     : 1;
        VOLU32 EnableLock   : 1;
		VOLU32 MethodOrigin : 1;
		VOLU32 ValidSESSL   : 1;
		VOLU32 ValidSESGE   : 1;
		VOLU32 ValidGPSGE   : 1;
		VOLU32				: 14;
	};
	
	VOLU32 uValue;
} R_FE_CONTROL;

// setup engine
typedef union
{
	struct
	{	
		VOLU32 ReadISO		: 1;
		VOLU32 WriteISO		: 1;
		VOLU32 SampleReadISO : 1;
		VOLU32 GSCUpdate	: 2;
		VOLU32 DeltaWarn	: 1;
		VOLU32 Retriggered	: 1;
		VOLU32 DeltaPanic	: 1;
		VOLU32				: 24;
	};
	
	VOLU32 uValue;
} R_SE_CONTROL;

typedef union
{
	struct
	{	
		VOLU32 Global   : 1;
		VOLU32 DSP      : 1;
		VOLU32 NMI      : 1;
		VOLU32 Abort   	: 1;
		VOLU32          : 28;
	};
	
	VOLU32 uValue;
} R_GP_RESET;

typedef union
{
	struct
	{	
		VOLU32 Start		: 1;
		VOLU32 Ready		: 1;
		VOLU32 ReqIOC       : 1;
		VOLU32 ReqEOL   	: 1;
		VOLU32 ReqErr	    : 1;
		VOLU32				: 27;
	};
	
	VOLU32 uValue;
} R_GPDMA_CONFIG;

typedef union
{
	struct
	{	
		VOLU32 Idle         : 1;
		VOLU32 Stopped      : 1;
		VOLU32 EnableStop   : 1;
		VOLU32 IntrNotify   : 1;
		VOLU32				: 28;
	};
	
	VOLU32 uValue;
} R_GP_CONTROL;

typedef struct
{
    VOLU32  uAddr;

    union
    {
        struct
        {
            VOLU32 Length   : 16;
            VOLU32 ContSize : 2;
            VOLU32 Samples  : 5;
            VOLU32 Stereo   : 1;
            VOLU32 Owner    : 1;
            VOLU32          : 6;
            VOLU32 Intr     : 1;
        };

        VOLU32 uValue;
    }Control;

} MCP1_PRD;

// word format for DSP commands

typedef union
{
    struct
    {
        U032 nextCommand    : 14;
        U032 EOL            : 1;
        U032                : 17;
    } field;

    U032 uValue;
} WORD0;

typedef union
{
    struct
    {
        U032 interleave     : 1;
        U032 dspToSys       : 1;
        U032 IOC            : 2;
        U032 smOffWrBack    : 1;
        U032 smBufId        : 4;
        U032 iso            : 1;
        U032 smDataFormat   : 3;
        U032                : 1;
        U032 increment      : 11;
        U032                : 7;
    } field;

    U032 uValue;
} WORD1;

typedef union
{
    struct
    {
        U032 count0     : 4;
        U032 count1     : 10;
        U032            : 18;
    } field;

    U032 uValue;
} WORD2;

typedef union
{
    struct
    {
        U032 dspStart   : 14;
        U032 nul        : 1;
        U032            : 17;
    } field;

    U032 uValue;
} WORD3;

typedef union
{
    struct
    {
        U032 smOffset   : 24;
        U032            : 8;
    } field;

    U032 uValue;
} WORD4;

typedef union
{
    struct
    {
        U032 smBaseAddr : 24;
        U032            : 8;
    } field;

    U032 uValue;
} WORD5;

typedef union
{
    struct
    {
        U032 smSizeMinus1   : 24;
        U032                : 8;
    } field;

    U032 uValue;
} WORD6;

typedef struct
{
    WORD0 w0;
    WORD1 w1;
    WORD2 w2;
    WORD3 w3;
} DSP_CONTROL;

#define INCR(x,limit)		(((x) < ((limit)-1))?((x)++):0)
#define DECR(x,limit)		((x)?((x)--):((limit)-1))

#define APU_INVALID_METHOD		0xFFFF

typedef struct _memdesc
{
	void	*pLinAddr;
	void	*pPhysAddr;
	U032	Size;
} MEM_DESC, *PMEM_DESC;


typedef struct 
{
	U032	GSCNT;
	U032	CurrentOffset;
	U032	Zero;
	U008	Res0;
	U008	SamplesAvailable;       // not in sync
	U008	EnvelopeActive;         // not in sync
	U008	Status;
} NV1BA0NOTIFICATION, *PNV1BA0NOTIFICATION;

#define LOW16(x)								(U016)(0x0000ffff & (U032)(x))
#define LOW08(x)								(U008)(0x000000ff & (U032)(x))

#define MIN(x,y)								(((x)<(y))?(x):(y))
#define MAX(x,y)								(((x)>(y))?(x):(y))

// codec defines
#define ACI_OFFSET                              0x100
#define MIXER_OFFSET                            0x000

// revision IDs of the hardware
#define REV_MCP1								0xA1

// sizes of various HW structures (in bytes)
// #define SIZEOF_PRD                              8
// #define SIZEOF_VOICE                            128
#define SIZEOF_TARGET_HRTF                      64
#define SIZEOF_CURRENT_HRTF                     96

// all EP methods are in NV_PAPU_NV1BA0 + PIO_EP_OFFSET
#define PIO_EP_OFFSET                           0x8000

// all debug methods are in NV_PAPU_NV1BA0 + PIO_DEBUG_OFFSET
#define PIO_DEBUG_OFFSET                        0x4000

#pragma pack (pop, _store_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\dmapush.h ===
#ifndef _DMAPUSH_H_
#define _DMAPUSH_H_
/**************************** DMA Pusher *****************************\
*                                                                           *
* Module: DMAPUSH.H                                                         *
*       Control method implementation.                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Bruce Thompson (brucet)    02/22/96 - wrote it.                     *
*                                                                           *
\***************************************************************************/

#include "dma.h"

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
// Miscellaneous structure definitions.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Control object defines.
//
//---------------------------------------------------------------------------
typedef struct _def_dmapush_object  DMAPUSHER,  *PDMAPUSHER;

// The object which represents the state of the DMA pusher
struct _def_dmapush_object
{
    BUFFEROBJECT    BufferObject;
	U032            CurrentBuffer;
	U032            AddressSpace;
	U032            TlbPtBase;
	U032            Offset;
};

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

// Allocate and init new DMA pusher object
RM_STATUS dmaCreateDmaPusher
(
    PDMAPUSHER *DmaPushObject,    // Ptr to object to initialize
	U032       ChID               // Channel this object will be used on
);

// Delete a DMA pusher object
RM_STATUS dmaDeleteDmaPusher
(
    PDMAPUSHER DmaPushObject      // Ptr to object to delete
);

// Start a DMA pusher transfer
RM_STATUS dmaPushStartXfer
(
    PBUFFEROBJECT BuffObject,     // The buffer object to use
    U032          BuffNum         // The buffer to start transfer on
);

// Start/Continue a DMA pusher transfer
RM_STATUS dmaPushXfer
(
   PBUFFER  pBuffer               // The buffer used for transfer
);

// Set the DMA pusher Dma specification object
RM_STATUS mthdSetPushBufferCtxDma
(
    POBJECT Object,               // Ptr to DMA push object for this channel
    PMETHOD Method,               // Ptr to method structure
    U032    Offset,               // Method offset
    V032    Data                  // Method data
);

// Set the DMA pusher notify Dma specification object
RM_STATUS mthdSetPushBufferNotifyCtxDma
(
    POBJECT Object,               // Ptr to DMA push object for this channel
    PMETHOD Method,               // Ptr to method structure
    U032    Offset,               // Method offset
    V032    Data                  // Method data
);

// Set the start offset for this DMA push operation
RM_STATUS mthdSetPushBufferStart
(
    POBJECT Object,               // Ptr to DMA push object for this channel
    PMETHOD Method,               // Ptr to method structure
    U032    Offset,               // Method offset
    V032    Data                  // Method data
);

// Set the length for this DMA push operation
RM_STATUS mthdSetPushBufferLength
(
    POBJECT Object,               // Ptr to DMA push object for this channel
    PMETHOD Method,               // Ptr to method structure
    U032    Offset,               // Method offset
    V032    Data                  // Method data
);

// Start the DMA push operation
RM_STATUS mthdSetPushBufferNotify
(
    POBJECT Object,               // Ptr to DMA push object for this channel
    PMETHOD Method,               // Ptr to method structure
    U032    Offset,               // Method offset
    V032    Data                  // Method data
);


#endif // _DMAPUSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\event.h ===
#ifndef _EVENT_H_
#define _EVENT_H_
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* DMA Manager *****************************\
*                                                                           *
* Module: EVENT.H                                                           *
*       Event object/engine management.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/


RM_STATUS eventSetObjectEventNotify(POBJECT, U032, U032, U032, U064);
RM_STATUS eventSetEventNotify(PHWINFO, U032, U032, U032, U032, U064);
RM_STATUS eventRemoveObjectEventNotify(POBJECT, U032);

#endif // _DMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\fifo.h ===
#ifndef _FIFO_H_
#define _FIFO_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** FIFO Manager *******************************\
*                                                                           *
* Module: FIFO.H                                                            *
*       FIFO assignment and hardware management.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

// Required include files
#include "dmapush.h"

//---------------------------------------------------------------------------
//
//  Macros.
//
//---------------------------------------------------------------------------

#define NUM_SUBCHANNELS     8
#define FIFO_STACK_DEPTH    16

//
// Hash table function.
//
//KJK #define FIFO_HASH(h,c)  ((((h)^((h)>>8)^((h)>>16)^((h)>>24))&0xFF)^((c)&0x7F))
#define FIFO_HASH(h,c)  (((h>>0)&0x7FF)^((h>>11)&0x7FF)^((h>>22)&0x7FF)^((c<<7)&0x7FF))
#define HASH_DEPTH      pDev->Pram.HalInfo.HashDepth
//KJK #define HASH_ENTRY(h,d) ((h)*HASH_DEPTH+(d))
#define HASH_ENTRY(h,d) ((h)+(d))
//
// Gray code translation macros.  Gray code is used by the FIFO runout
// GET and PUT pointers because of the asynchronous boundary.
//
extern U032 fifoGrayToBinTable[];
extern U032 fifoBinToGrayTable[];
#define BIN_TO_GRAY(bb)     fifoIntToGrayTable[(bb)>>2]
#define GRAY_TO_BIN(gg)     fifoGrayToIntTable[(gg)>>2]

//---------------------------------------------------------------------------
//
//  Chip Engines known to FIFO
//
//---------------------------------------------------------------------------

#define ENGINE_SW           0
#define ENGINE_GRAPHICS     1

//---------------------------------------------------------------------------
//
//  Structures and types.
//
//---------------------------------------------------------------------------

//
// FIFO structure.
//
typedef struct _def_fifo
{
    BOOL    InUse;
    U032    ChID;
    U032    CacheDepth;
//    U032    ObjectStackTop[NUM_SUBCHANNELS];
//    POBJECT ObjectStack[NUM_SUBCHANNELS][FIFO_STACK_DEPTH];
    POBJECT SubchannelContext[NUM_SUBCHANNELS];
    U032    ObjectCount;
    PNODE   ObjectTree;
    PDMAPUSHER DmaPushObject;  // Object representing the state of the dma
						       // pusher for this channel
    PDMAOBJECT StallNotifier;
    BOOL       IsStalledPendingVblank;
    U032       Put;
    POBJECT    LastIllegalMthdObject;
    U032       ClassAllocLocks;
    U032       Instance;       // Additional channel context instmem
    U032       InstanceSize;   // Amount of instmem
} FIFO, *PFIFO;


//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS initFifo(PHWINFO);
RM_STATUS fifoAlloc(PHWINFO, U032, U032 *);
RM_STATUS fifoAllocDma(PHWINFO, U032, U032 *, PDMAOBJECT);
RM_STATUS fifoFree(PHWINFO, U032);
RM_STATUS fifoResetChannelState(PHWINFO, U032);
RM_STATUS fifoSoftwareMethod(PHWINFO, PFIFOEXCEPTIONDATA);
RM_STATUS fifoHashEntry(PHWINFO, POBJECT, U032, U032 *);
RM_STATUS fifoAddHashEntry(PHWINFO, POBJECT, U032, U032);
RM_STATUS fifoDelHashEntry(PHWINFO, POBJECT, U032);
RM_STATUS fifoAddObject(PHWINFO, POBJECT);
RM_STATUS fifoDelObject(PHWINFO, POBJECT);
RM_STATUS fifoSearchObject(PHWINFO, U032, U032, POBJECT *);
RM_STATUS fifoUpdateContext(POBJECT, U032, U032);
RM_STATUS fifoUpdateObjectInstance(PHWINFO, POBJECT, U032, U032);
RM_STATUS fifoDeleteObjectInstance(PHWINFO, POBJECT, U032);
RM_STATUS fifoDeleteSubchannelContextEntry(PHWINFO, POBJECT);
V032      fifoService(PHWINFO);

#ifdef DEBUG
#define MAX_FIFOLOG_LENGTH	1024
extern U032 findex;
extern U032 fifolog[];

// fifolog format looks like:
//	31:28	= unique file number
//	27:4	= file line number
//	1:0	= fifo state bits (bit1 = puller, bit0 = reassign)
#define FIFOLOG(fn, fa, fb)					\
	fifolog[findex] = ((fn << 28) | (__LINE__ << 4) |	\
				((fa & 0x1) ? 1 : 0) << 1 |	\
				((fb & 0x1) ? 1 : 0));		\
	if (++findex == MAX_FIFOLOG_LENGTH)			\
		findex = 0
#else
#define FIFOLOG(fn, fa, fb)
#endif // DEBUG

#endif // _FIFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\class.h ===
#ifndef _CLASS_H_
#define _CLASS_H_
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/****************************** Object Manager *****************************\
*                                                                           *
* Module: CLASS.H                                                           *
*       User Object management.                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Includes.
//
//---------------------------------------------------------------------------

#ifndef _BTREE_H_
#include <btree.h>
#endif // _BTREE_H_

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define RESERVED_NAMES                  4096
#define MAX_OS_NAME_LENGTH              80

//---------------------------------------------------------------------------
//
//  Types and structures.
//
//---------------------------------------------------------------------------

//
// Forward declarations of structures.
//
typedef struct _def_method METHOD, *PMETHOD;
typedef struct _def_object OBJECT, *POBJECT;
typedef struct _def_class  CLASS,  *PCLASS;

//
// Methods.
//
typedef RM_STATUS (*METHODPROC)(PHWINFO, POBJECT, PMETHOD, U032, V032);
struct _def_method
{
    METHODPROC Proc;
    U032       Low;
    U032       High;
};

//
// Objects.
//
typedef struct _def_class_object        CLASSOBJECT, *PCLASSOBJECT;
typedef struct _def_dma_object          DMAOBJECT,   *PDMAOBJECT;
typedef struct _def_patch_object        PATCHOBJECT, *PPATCHOBJECT;
typedef struct _def_context_time_object TIMEOBJECT,  *PTIMEOBJECT;
typedef struct _def_event_notification  EVENTNOTIFICATION, *PEVENTNOTIFICATION;
typedef struct _def_engine_info         ENGINEINFO, *PENGINEINFO;
  
struct _def_object
{
    U032                Name;
    U032                ChID;
    PCLASS              Class;
    U032                Subchannel;
    NODE                Node;
    POBJECT             Next;
    PDMAOBJECT          NotifyXlate;
    U032                NotifyAction;
    U032                NotifyTrigger;
    PEVENTNOTIFICATION  NotifyEvent;
    PCLASS              ThisClass;   //KJK I don't like this!!
};
//
// Patch structure.
//
struct _def_patch_object
{
    OBJECT  Base;
    POBJECT Destination;
    POBJECT Source;
};
//
// NV_CLASS structure and create/destroy function prototypes.
//
typedef RM_STATUS (*CREATEOBJECTPROC)(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
typedef RM_STATUS (*DELETEOBJECTPROC)(PHWINFO, POBJECT);

struct _def_class_create
{
    U032                Class;
    CREATEOBJECTPROC    Function;
};

//
// Classes.
//
typedef struct _def_class_methods
{
    U032                Type;
    PMETHOD             Method;
    U032                MethodMax;
} CLASSMETHODS, *PCLASSMETHODS;

struct _def_class
{
    U032                Type;
    PMETHOD             Method;
    U032                MethodMax;
    //U032                StateSize;
    PCLASSDESCRIPTOR    ClassDecl;
    PCLASSDESCRIPTOR    ClassInstMalloc;
    PENGINEDESCRIPTOR   EngineDecl;
    PENGINEINFO         EngineInfo;
};

struct _def_class_object
{
    OBJECT     Base;
};

//===========================================================================
//
//                                Class Defines.
//
//===========================================================================

#define NV_CONTEXT_DMA_TO_MEM               3
#define NV_NULL_OBJECT                      0

//---------------------------------------------------------------------------
//
//  Method prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS mthdNoOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);

RM_STATUS mthdValidate(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdCreateLegacy(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdCreate(PHWINFO, POBJECT, PMETHOD, U032, V032, VOID*);
RM_STATUS mthdDestroy(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNameCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNameStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNameLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetEnumerateCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetEnumerateStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetEnumerateLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdEnumerate(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetDmaSpecifier(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAlarmTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAlarmTimeRelative(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAlarmNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAlarmNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdTmrStopTransfer(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdGetChipToken(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetOrdinal(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSwitchNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSwitchNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetGamePortOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetGamePortInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetGamePortFormat(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetStartTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetStartCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSampleRate(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetNumberChannels(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferNotifyCount(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferPosNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferPosNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferInCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferOutCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferInStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferOutStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferMemNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferMemLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferMemNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVideoInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVideoOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetCtxOrdinal(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetColormapCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetColormapFormat(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetColormapStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetColormapLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdColormapDirtyStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdColormapDirtyLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetImageOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetImageInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBetaInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBetaOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetRopInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetRopOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetColorFormat(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetMonochromeFormat(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetGraphicsCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAudioInput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAudioFormat(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSampleRateAdjust(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetStopLoopingCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetPortamento(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVibratoDepth(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVibratoFrequency(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVibratoAttackCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetVibratoAttack(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetDiscardPriority(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferLoopStart(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetBufferLoopLength(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAudioOutput(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetOutputGain(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetInputGain(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAttack(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetDecay(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSustain(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetRelease(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetAttackCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetReleaseCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetSustainLevel(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetTremoloDepth(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetTremoloAttackCtxTime(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetTremoloAttack(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdSetTremoloFrequency(PHWINFO, POBJECT, PMETHOD, U032, V032);

//
// Method aliases to common method procedure.
//
RM_STATUS mthdStaticImage(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdRender(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdRenderBeta(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdRender3d(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdImageToMem(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdDmaRender(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdImageBlit(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdGrSetNotify(PHWINFO, POBJECT, PMETHOD, U032, V032);
RM_STATUS mthdGrSetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, V032);
#define mthdSetBeta         mthdStaticImage
#define mthdSetRop          mthdStaticImage
#define mthdSetColor        mthdStaticImage
#define mthdSetPatternShape mthdStaticImage
#define mthdSetColor0       mthdStaticImage
#define mthdSetColor1       mthdStaticImage
#define mthdSetPattern      mthdStaticImage
#define mthdSetRectangle    mthdStaticImage
#define mthdColor           mthdRender
#define mthdPoint           mthdRender
#define mthdPoint32         mthdRender
#define mthdColorPoint      mthdRender
#define mthdLine            mthdRender
#define mthdLine32          mthdRender
#define mthdPolyLine        mthdRender
#define mthdPolyLine32      mthdRender
#define mthdColorPolyLine   mthdRender
#define mthdLin             mthdRender
#define mthdLin32           mthdRender
#define mthdPolyLin         mthdRender
#define mthdPolyLin32       mthdRender
#define mthdColorPolyLin    mthdRender
#define mthdTriangle        mthdRender
#define mthdTriangle32      mthdRender
#define mthdTrimesh         mthdRender
#define mthdTrimesh32       mthdRender
#define mthdColorTriangle   mthdRender
#define mthdColorTrimesh    mthdRender
#define mthdRectangle       mthdRender
#define mthdControlPointIn  mthdRender
#define mthdControlPointOut mthdRender
#define mthdControlPointOutFP mthdRender
#define mthdSize            mthdRender
#define mthdImagePitch      mthdRender
#define mthdImageStart      mthdRender
#define mthdSizeIn          mthdRender
#define mthdColor0          mthdRender
#define mthdColor1          mthdRender
#define mthdMonochrome      mthdRender
#define mthdSubdivideIn     mthdRender
#define mthdColorBeta       mthdRenderBeta
#define mthdControlBetaOut  mthdRenderBeta
#define mthdSubdivideInBeta mthdRenderBeta
#define mthdFilterBeta      mthdRenderBeta
#define mthdControlPointOutBeta mthdRenderBeta
#define mthdControlPointOutFPBeta mthdRenderBeta
#define mthdBlitPointIn     mthdImageBlit
#define mthdBlitPointOut    mthdImageBlit
#define mthdBlitSize        mthdImageBlit
#define mthdImageToMemPoint mthdImageToMem
#define mthdImageToMemSize  mthdImageToMem
#define mthdImageToMemPitch mthdImageToMem
#define mthdImageToMemStart mthdImageToMem
#define mthdGraphicsFromMemPoint mthdDmaRender
#define mthdGraphicsFromMemSize  mthdDmaRender
#define mthdGraphicsFromMemPitch mthdDmaRender
#define mthdGraphicsFromMemStart mthdDmaRender
#define mthdGraphicsFromMemSize  mthdDmaRender

//---------------------------------------------------------------------------
//
//  Class object prototypes.
//
//---------------------------------------------------------------------------
RM_STATUS classCreateWellKnownObjects(PHWINFO, U032);
RM_STATUS classDeleteWellKnownObjects(VOID*, POBJECT);
RM_STATUS classInitCommonObject(POBJECT, PCLASSOBJECT, U032);
RM_STATUS classCreate(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS classDestroy(VOID*, POBJECT);
RM_STATUS nopCreate(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS nopDestroy(VOID*, POBJECT);
RM_STATUS classSoftwareMethod(PHWINFO, POBJECT, U032, V032);
RM_STATUS classDirectSoftwareMethod(PHWINFO, POBJECT, U032, V032);

// JJV - Moved this structure from class66.c and class63.c
typedef struct _def_surface_attributes
{
  
  U032 StartAddress;
  U032 Type;		// tells you whether this is an interleaved surface or other
  U032 Pitch;
  U032 Length;
  U032 FittedSize;  // not used for overlay
  
} SURFACEATTRIBUTES, * PSURFACEATTRIBUTES ;

// JJV - Moved these defines from class66.c
// defined digitisers

#define PHILIPS_DEVICE_110 		0
#define PHILIPS_DEVICE_111A		1
#define ITT_VPX3225D_A1			0x20
#define ITT_VPX3225D_C3			0x23
#define SAMSUNG_DEVICE_127 		0xF0

#define ST_NTSC			0x0
#define ST_PAL			0x10
#define ST_UNDECODED	0xFFFFFFFF

#define IS_FLIP_FOR_OVERLAY_SURFACE_0 			0x10
#define IS_FLIP_FOR_OVERLAY_SURFACE_1 			0x20

#define NV_VCTM_IMAGE_FORMAT_NEXT_FIELD_EVEN	0x0
#define NV_VCTM_IMAGE_FORMAT_NEXT_FIELD_ODD		0x80000000
#define NV_VCTM_IMAGE_FORMAT_COLOR_LE_Y8V8Y8U8	0x00020001

#define NV_VCTM_VBI_FORMAT_NEXT_FIELD_EVEN		0x0
#define NV_VCTM_VBI_FORMAT_NEXT_FIELD_ODD		0x80000000
#define NV_VCTM_VBI_FORMAT_COLOR_LE_Y8_P4		0x01010000

//---------------------------------------------------------------------------
//
//  Engine structures and prototypes.
//
//---------------------------------------------------------------------------

//
// Engine info structure.
//
typedef RM_STATUS (*ENGINECREATEOBJECT)(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
typedef RM_STATUS (*ENGINEDELETEOBJECT)(VOID*, POBJECT);

struct _def_engine_info
{
    U032 Tag;                           // cross-ref with rom data tables
    PMETHOD Methods;                    // default methods
    U032 MethodMax;                     // default method max
    ENGINECREATEOBJECT CreateObject;
    ENGINEDELETEOBJECT DestroyObject;
};

typedef struct _def_engine_db
{
    PENGINEINFO         pEngineInfos;
    PENGINEDESCRIPTOR   pEngineDescriptors;
    U032                numEngineDescriptors;
} ENGINEDB, *PENGINEDB;

// kernel/hal/haleng.c
RM_STATUS engineGetInfo(PENGINEDB, U032, PENGINEINFO *, PENGINEDESCRIPTOR *);
U032 engineGetBufferSize(PENGINEDB, U032, U032);

//---------------------------------------------------------------------------
//
//  Class database structure.
//
//  This state is pulled from the HAL tables.
//
//---------------------------------------------------------------------------

typedef struct _def_class_db
{
    PCLASS              pClasses;
    U032                numClasses;
    PCLASSDESCRIPTOR    pClassDescriptors;
    U032                numClassDescriptors;
} CLASSDB, *PCLASSDB;

RM_STATUS classBuildDB(PENGINEDB, PCLASSDB);
RM_STATUS classDestroyDB(PCLASSDB);
RM_STATUS classGetClass(PCLASSDB, U032, PCLASS *);

#endif // _CLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\bios.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Header: bios.h
*
*   Description:
*       Definitions of BIOS structures.
*
*   Revision History:
*       Original -- 9/99 Jeff Westerinen
*
**************************************************************************************************************/

// We convert the bios data structures before they are used.  They are read from bios,
//   then each field is expanded into a 32 bit field into host byte order.
//   Each data structure has a format string below that describes its packed
//   layout in the rom.
//
// The format string looks like:
//
//    count defaults to 1
//    item is one of
//          b  (byte)
//          w  2 byte word
//          d  4 byte word
//
//  Eg: "1b3d"
//
//   means 1 byte field followed by 3 dword (32 bit) fields
//

#define bios_U008  U032
#define bios_U016  U032
#define bios_U032  U032
#define bios_S008  S032

// definition from nvidia.inc
#define EOL                     0xff    // end of list
#define INIT_PLL_REG            'p'     // Write a PLL value into the DAC (obsolete)
#define INIT_PLL                'y'     // Write an NV3 PLL value based on crystal
#define INIT_NV_REG             'n'     // Write an NV Register with mask
#define INIT_ZM_REG             'z'     // NV Register with 0 mask
#define INIT_ZM_WREG            'w'     // NV word Register with 0 mask
#define INIT_DAC_REG            'd'     // Write to a DAC register (obsolete)
#define INIT_TIME               't'     // Delay
#define INIT_IO                 'i'     // Write an IO value
#define INIT_INDEX_IO           'x'     // Write an indexed IO value
#define INIT_MEM_RESTRICT       'm'     // Memory restrict
#define INIT_STRAP_RESTRICT     's'     // Strap restrict
#define INIT_RESUME             'r'     // Resume operations
#define INIT_CONFIGURE_MEM      'f'     // Configure memory
#define INIT_CONFIGURE_CLK      'g'     // Configure clocks
#define INIT_CONFIGURE_PREINIT  'h'     // Configure RAM Type specifiers, etc
#define INIT_COMPUTE_MEM        'c'     // Compute memory size
#define INIT_RESET              'e'     // Reset chip
#define INIT_DONE               'q'     // Quit script

// new opocdes for BIP/3
#define INIT_ZM_IO              'a'     // Write an IO value with 0 mask
#define INIT_ZM_INDEX_IO        'b'     // Write an indexed IO value with 0 mask
#define INIT_EOS                'l'     // End of current script
#define INIT_SUB                'k'     // Execute another script as a subroutine
#define INIT_JUMP               'j'     // Jump to another script
#define INIT_MACRO              'o'     // Execute macro
#define INIT_CONDITION          'u'     // Restruct until INIT_RESUME based on condition
#define INIT_IO_CONDITION       'v'     // Restrict until INIT_RESUME based on I/O condition being true
#define INIT_IO_FLAG_CONDITION  '9'     // Restrict until INIT_RESUME based on I/O condition being true
#define INIT_RESTRICT_PROG      '1'     // Program a register from a value array based on another register
#define INIT_IO_RESTRICT_PROG   '2'     // Program a register from a value array based on an I/O port
#define INIT_REPEAT             '3'     // Repeat block N times up until INIT_END_REPEAT
#define INIT_END_REPEAT         '6'     // End repeat block
#define INIT_IO_RESTRICT_PLL    '4'     // Program a PLL clock from a value array based on an I/O port
#define INIT_COPY               '7'     // Copy a portion of a NV register to a IO register
#define INIT_NOT                '8'     // Invert the current condition status
#define INIT_FUNCTION           '5'     // Execute generic function !!!
#define INIT_INDEX_ADDRESS_LATCHED      'I' // Program a block of registers that are accessed via an index register
#define SCRIPT_TERMINATE        0x00    // End of sequential script indexes

// definitions from biosequ.inc
#define CRTC_INDEX_MONO             0x03B4
#define CRTC_INDEX_COLOR            0x03D4
#define ATC_INDEX                   0x03C0
#define SEQ_INDEX                   0x03C4
#define GDC_INDEX                   0x03CE

#define CRYSTAL_FREQ143KHZ          14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ          13500              // 13500 kHz

#define MAX_BIOS_SCAN               1024

// Hotkey bit definitions -- for test purposes.

// These bit definitions refer to CRTC register 4A, aka NV_CIO_CRE_SCRATCH5__INDEX.
#define NV_MOBILE_FLAG_DISPLAY_MASK     0x04    //SSF3
#define NV_MOBILE_FLAG_SCALE_MASK       0x10    //SSF5

// These bit definitions refer to CRTC register 4B, aka NV_CIO_CRE_SCRATCH6__INDEX.
#define NV_DRIVER_HANDLES_HOTKEYS       0x80    //SOS8
#define NV_IS_MOBILE_BIOS               0x40    //SOS7

// These bit definitions refer to CRTC register 4C, aka NV_CIO_CRE_SCRATCH7__INDEX.
#define NV_MOBILE_DISPLAY_LCD_MASK      0x01
#define NV_MOBILE_DISPLAY_CRT_MASK      0x02
#define NV_MOBILE_DISPLAY_TV_MASK       0x04
#define NV_MOBILE_DISPLAY_DFP_MASK      0x08

#define NV_MOBILE_DISPLAY_SCALE_MASK    0x80

#define NV_MOBILE_DISPLAY_EVENTS_MASK   (NV_MOBILE_DISPLAY_LCD_MASK | NV_MOBILE_DISPLAY_CRT_MASK \
                                        | NV_MOBILE_DISPLAY_TV_MASK | NV_MOBILE_DISPLAY_DFP_MASK \
                                        | NV_MOBILE_DISPLAY_SCALE_MASK)
///


#pragma pack(1)

// BMP information structure
#define CTRL_BLK_ID                 0x564e7fff
#define BIOS_ROM_CODE_SIZE          0x10000
#define BMP_INIT_CODE_SIZE_MAX      8192
#define BMP_INIT_TABLE_VER_0        0
#define BMP_INIT_TABLE_VER_1        1
#define BMP_INIT_TABLE_VER_2        2
#define BMP_INIT_TABLE_VER_3        3
#define BMP_INIT_TABLE_VER_4        4
#define BMP_INIT_TABLE_VER_5        5
#define BMP_INIT_TABLE_VER_6        6
#define BMP_INIT_TABLE_VER_UNDEF    0xffffffff
#define BMP_INIT_TABLE_SUBVER_0x10  0x10


#define BMP_CONTROL_BLOCK_FMT "w3b3b"

typedef struct
{
    bios_U016 CTL_ID;                    // ID Marker (0x7FFF)
    bios_U008 CTL_Header[3];             // ID Header ("NV\0")
    bios_U008 CTL_Version;               // Control Block Version
    bios_U008 CTL_Flags;                 // Control Block Subversion
    bios_U008 CTL_Checksum;              // Checksum byte for Control Block
} BMP_Control_Block, *PBMP_Control_Block;


#define BMP_INIT1_FMT BMP_CONTROL_BLOCK_FMT "2b1d" "3w" "2w" "5w" "5w"
typedef struct
{
    BMP_Control_Block bmpCtrlBlk;        // BMP control block

    bios_U008 BIOS_Checksum;             // Checksum byte for BIOS
    bios_U008 BIOS_Features;             // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;              // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;          // Pointer to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;        // Pointer to Extra Initialization Table
    bios_U016 BMP_SizeInitTable;         // Max size of Initialization Table.

    bios_U016 szSignonMsg;               // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;         // Current length of signon message
                           
    bios_U016 BMP_Fonts;                 // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;              // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;           // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;         // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;           // MNP parameters for clocks

    bios_U016 BMP_OEMString;             // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;         // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;        // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;         // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;             // Pointer to DAC/CRTC fifo settings table

} BMP_Struc_Rev1, *PBMP_Struc_Rev1;


#define BMP_INIT2_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "3w" "2w" "5w" "5w"
typedef struct
{
    BMP_Control_Block bmpCtrlBlk;        // BMP control block

    bios_U008 BIOS_Checksum;             // Checksum byte for BIOS
    bios_U008 BIOS_Features;             // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;              // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;           // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;          // Pointer to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;        // Pointer to Extra Initialization Table
    bios_U016 BMP_SizeInitTable;         // Max size of Initialization Table.

    bios_U016 szSignonMsg;               // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;         // Current length of signon message
                           
    bios_U016 BMP_Fonts;                 // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;              // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;           // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;         // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;           // MNP parameters for clocks

    bios_U016 BMP_OEMString;             // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;         // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;        // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;         // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;             // Pointer to DAC/CRTC fifo settings table

} BMP_Struc_Rev2, *PBMP_Struc_Rev2;



#define BMP_INIT3_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "6w" "2w" "5w" "5w"

typedef struct
{
    BMP_Control_Block bmpCtrlBlk;   // BMP control block

    bios_U008 BIOS_Checksum;             // Checksum byte for BIOS
    bios_U008 BIOS_Features;             // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;              // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;           // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;          // Offset to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;        // Offset to Extra Initialization Table.
    bios_U016 BMP_SizeInitTable;         // Max size of Initialization Table.
    bios_U016 BMP_MemInitTable;          // Offset to the Memory Initialization Table.
    bios_U016 BMP_SDRSequenceTable;      // Offset to the SDR Sequence Table.
    bios_U016 BMP_DDRSequenceTable;      // Offset to the DDR Sequence Table.

    bios_U016 szSignonMsg;               // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;         // Current length of signon message
                           
    bios_U016 BMP_Fonts;                 // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;              // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;           // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;         // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;           // MNP parameters for clocks

    bios_U016 BMP_OEMString;             // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;         // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;        // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;         // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;             // Pointer to DAC/CRTC fifo settings table

} BMP_Struc_Rev3, *PBMP_Struc_Rev3;


#define BMP_INIT4_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "6w" "2w" "5w" "5w" "4b2w"

typedef struct
{
    BMP_Control_Block bmpCtrlBlk;        // BMP control block

    bios_U008 BIOS_Checksum;             // Checksum byte for BIOS
    bios_U008 BIOS_Features;             // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;              // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;           // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;          // Offset to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;        // Offset to Extra Initialization Table.
    bios_U016 BMP_SizeInitTable;         // Max size of Initialization Table.
    bios_U016 BMP_MemInitTable;          // Offset to the Memory Initialization Table.
    bios_U016 BMP_SDRSequenceTable;      // Offset to the SDR Sequence Table.
    bios_U016 BMP_DDRSequenceTable;      // Offset to the DDR Sequence Table.

    bios_U016 szSignonMsg;               // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;         // Current length of signon message
                           
    bios_U016 BMP_Fonts;                 // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;              // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;           // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;         // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;           // MNP parameters for clocks

    bios_U016 BMP_OEMString;             // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;         // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;        // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;         // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;             // Pointer to DAC/CRTC fifo settings table

    bios_U008 BMP_CRTI2CPort;            // Default I2C port for CRT
    bios_U008 BMP_TVI2CPort;             // Default I2C port for TV
    bios_U008 BMP_DFPI2CPort;            // Default I2C port for DFP
    bios_U008 BMP_RsvdI2CPort;           // Reserved for future expansion
    bios_U016 BMP_I2CPort0IO;            // Read/Write reg for I2C Port 0
    bios_U016 BMP_I2CPort1IO;            // Read/Write reg for I2C Port 1

} BMP_Struc_Rev4, *PBMP_Struc_Rev4;


#define BMP_INIT5_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "6w" "2w" "5w" "5w" "4b2w" "1b2w"

typedef struct
{
    BMP_Control_Block bmpCtrlBlk;   // BMP control block

    bios_U008 BIOS_Checksum;             // Checksum byte for BIOS
    bios_U008 BIOS_Features;             // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;              // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;           // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;          // Offset to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;        // Offset to Extra Initialization Table.
    bios_U016 BMP_SizeInitTable;         // Max size of Initialization Table.
    bios_U016 BMP_MemInitTable;          // Offset to the Memory Initialization Table.
    bios_U016 BMP_SDRSequenceTable;      // Offset to the SDR Sequence Table.
    bios_U016 BMP_DDRSequenceTable;      // Offset to the DDR Sequence Table.

    bios_U016 szSignonMsg;               // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;         // Current length of signon message
                           
    bios_U016 BMP_Fonts;                 // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;              // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;           // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;         // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;           // MNP parameters for clocks

    bios_U016 BMP_OEMString;             // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;         // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;        // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;         // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;             // Pointer to DAC/CRTC fifo settings table

    bios_U008 BMP_CRTI2CPort;            // Default I2C port for CRT
    bios_U008 BMP_TVI2CPort;             // Default I2C port for TV
    bios_U008 BMP_DFPI2CPort;            // Default I2C port for DFP
    bios_U008 BMP_RsvdI2CPort;           // Reserved for future expansion
    bios_U016 BMP_I2CPort0IO;            // Read/Write reg for I2C Port 0
    bios_U016 BMP_I2CPort1IO;            // Read/Write reg for I2C Port 1

    bios_U008 BMP_OEMRevision;           // OEM Version Number (00 = Generic)
    bios_U016 BMP_LCDEDID;               // Pointer to LCD_EDID
    bios_U016 BMP_FPParams;              // Pointer to FP_Params
    
} BMP_Struc_Rev5, *PBMP_Struc_Rev5;

#define BMP_INIT5_0x10_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "6w" "2w" "5w" "5w" "4b2w" "1b2w" "2d" "7w"
typedef struct
{
    BMP_Control_Block bmpCtrlBlk;       // BMP control block

    bios_U008 BIOS_Checksum;            // Checksum byte for BIOS
    bios_U008 BIOS_Features;            // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;             // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;          // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;         // Offset to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;       // Offset to Extra Initialization Table.
    bios_U016 BMP_SizeInitTable;        // Max size of Initialization Table.
    bios_U016 BMP_MemInitTable;         // Offset to the Memory Initialization Table.
    bios_U016 BMP_SDRSequenceTable;     // Offset to the SDR Sequence Table.
    bios_U016 BMP_DDRSequenceTable;     // Offset to the DDR Sequence Table.

    bios_U016 szSignonMsg;              // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;        // Current length of signon message
                           
    bios_U016 BMP_Fonts;                // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;             // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;          // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;        // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;          // MNP parameters for clocks

    bios_U016 BMP_OEMString;            // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;        // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;       // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;        // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;            // Pointer to DAC/CRTC fifo settings table

    bios_U008 BMP_CRTI2CPort;           // Default I2C port for CRT
    bios_U008 BMP_TVI2CPort;            // Default I2C port for TV
    bios_U008 BMP_DFPI2CPort;           // Default I2C port for DFP
    bios_U008 BMP_RsvdI2CPort;          // Reserved for future expansion
    bios_U016 BMP_I2CPort0IO;           // Read/Write reg for I2C Port 0
    bios_U016 BMP_I2CPort1IO;           // Read/Write reg for I2C Port 1

    bios_U008 BMP_OEMRevision;          // OEM Version Number (00 = Generic)
    bios_U016 BMP_LCDEDID;              // Pointer to LCD_EDID
    bios_U016 BMP_FPParams;             // Pointer to FP_Params
    
    bios_U032 BMP_FmaxVco;              // Maximum internal PLL frequency
    bios_U032 BMP_FminVco;              // Minimum internal PLL frequency

    bios_U016 BMP_InitScriptTablePtr;       // Init script table pointer
    bios_U016 BMP_MacroIndexTablePtr;       // Macro index table pointer
    bios_U016 BMP_MacroTablePtr;            // Macro table pointer
    bios_U016 BMP_ConditionTablePtr;        // Condition table pointer
    bios_U016 BMP_IOConditionTablePtr;      // IO Condition table pointer
    bios_U016 BMP_IOFlagConditionTablePtr;  // IO Flag Condition table pointer
    bios_U016 BMP_InitFunctionTablePtr;     // Init function table pointer

} BMP_Struc_Rev5_0x10, *PBMP_Struc_Rev5_0x10;


#define BMP_INIT5_0x11_FMT BMP_CONTROL_BLOCK_FMT "2b2d" "6w" "2w" "5w" "5w" "4b2w" "1b2w" "2d" "7w" "8w" "1w"
typedef struct
{
    BMP_Control_Block bmpCtrlBlk;       // BMP control block

    bios_U008 BIOS_Checksum;            // Checksum byte for BIOS
    bios_U008 BIOS_Features;            // BIOS Feature Byte (bitfields)
    bios_U032 BIOS_Version;             // BIOS Version in BCD (Major/Minor/Sub)
    bios_U032 BIOS_DriverInfo;          // BIOS Version in BCD (Major/Minor/Sub)
                            
    bios_U016 BMP_GenInitTable;         // Offset to the General Initialization Table.
    bios_U016 BMP_ExtraInitTable;       // Offset to Extra Initialization Table.
    bios_U016 BMP_SizeInitTable;        // Max size of Initialization Table.
    bios_U016 BMP_MemInitTable;         // Offset to the Memory Initialization Table.
    bios_U016 BMP_SDRSequenceTable;     // Offset to the SDR Sequence Table.
    bios_U016 BMP_DDRSequenceTable;     // Offset to the DDR Sequence Table.

    bios_U016 szSignonMsg;              // Offset to signon string
    bios_U016 BMP_SizeSignonMsg;        // Current length of signon message
                           
    bios_U016 BMP_Fonts;                // Pointer to pointers to fonts
    bios_U016 BMP_FontSize;             // Size of memory available for all fonts
    bios_U016 BMP_InitSavePtr;          // Pointer to initial save pointer area
    bios_U016 BMP_Functionality;        // Pointer to functionality table for Function 1Bh
    bios_U016 BMP_TblClockMNP;          // MNP parameters for clocks

    bios_U016 BMP_OEMString;            // OEM String to identify grahpics controller chip or product family (20)
    bios_U016 BMP_OEMVendorName;        // Name of the vendor that produced the display controller board product (35)
    bios_U016 BMP_OEMProductName;       // Product name of the controller board (35)
    bios_U016 BMP_OEMProductRev;        // Revision of manufacturing level of the display controller board (30)
    bios_U016 BMP_FifoTable;            // Pointer to DAC/CRTC fifo settings table

    bios_U008 BMP_CRTI2CPort;           // Default I2C port for CRT
    bios_U008 BMP_TVI2CPort;            // Default I2C port for TV
    bios_U008 BMP_DFPI2CPort;           // Default I2C port for DFP
    bios_U008 BMP_RsvdI2CPort;          // Reserved for future expansion
    bios_U016 BMP_I2CPort0IO;           // Read/Write reg for I2C Port 0
    bios_U016 BMP_I2CPort1IO;           // Read/Write reg for I2C Port 1

    bios_U008 BMP_OEMRevision;          // OEM Version Number (00 = Generic)
    bios_U016 BMP_LCDEDID;              // Pointer to LCD_EDID
    bios_U016 BMP_FPParams;             // Pointer to FP_Params
    
    bios_U032 BMP_FmaxVco;              // Maximum internal PLL frequency
    bios_U032 BMP_FminVco;              // Minimum internal PLL frequency

    bios_U016 BMP_InitScriptTablePtr;       // Init script table pointer
    bios_U016 BMP_MacroIndexTablePtr;       // Macro index table pointer
    bios_U016 BMP_MacroTablePtr;            // Macro table pointer
    bios_U016 BMP_ConditionTablePtr;        // Condition table pointer
    bios_U016 BMP_IOConditionTablePtr;      // IO Condition table pointer
    bios_U016 BMP_IOFlagConditionTablePtr;  // IO Flag Condition table pointer
    bios_U016 BMP_InitFunctionTablePtr;     // Init function table pointer

    bios_U016 BMP_TMDSSingleAPtr;           // TMDS single link A table
    bios_U016 BMP_TMDSSingleBPtr;           // TMDS single link B table
    bios_U016 BMP_TMDSDualPtr;              // TMDS dual link table
    bios_U016 BMP_LVDSSingleAPtr;           // LVDS single link A table
    bios_U016 BMP_LVDSSingleBPtr;           // LVDS single link B table
    bios_U016 BMP_LVDSDualPtr;              // LVDS dual link table
    bios_U016 BMP_OffSingleAPtr;            // LVDS dual link table
    bios_U016 BMP_OffSingleBPtr;            // LVDS dual link table

    bios_U016 BMP_FPTablePtr;               // Pointer to internal LCD tables

} BMP_Struc_Rev5_0x11, *PBMP_Struc_Rev5_0x11;

// init code instruction formats

#define INIT_FMT1_FMT "1b3d"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_U032 operand2;
    bios_U032 operand3;

} BMP_FORMAT_1;


#define INIT_FMT2_FMT  "1b2d"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_U032 operand2;
} BMP_FORMAT_2;


#define INIT_FMT3_FMT "1b1d1w"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_U016 operand2;
} BMP_FORMAT_3;


#define INIT_FMT4_FMT "1b1w"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
} BMP_FORMAT_4;

#define INIT_FMT5_FMT "1b1w3b"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
    bios_U008 operand2;
    bios_U008 operand3;
    bios_U008 operand4;
} BMP_FORMAT_5;


#define INIT_FMT6_FMT "3b"
typedef struct
{
    bios_U008 opcode;
    bios_U008 operand1;
    bios_U008 operand2;
} BMP_FORMAT_6;


#define INIT_FMT7_FMT "1b"
typedef struct
{
    bios_U008 opcode;
} BMP_FORMAT_7;


#define INIT_FMT8_FMT "2b"
typedef struct
{
    bios_U008 opcode;
    bios_U008 operand1;
} BMP_FORMAT_8;


#define INIT_FMT9_FMT "1b1w2b"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
    bios_U008 operand2;
    bios_U008 operand3;
} BMP_FORMAT_9;

#define INIT_FMT10_FMT "1b1w1b"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
    bios_U008 operand2;
} BMP_FORMAT_10;

#define INIT_FMT11_FMT "1b1d2b1w2b"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_S008 operand2;
    bios_U008 operand3;
    bios_U016 operand4;
    bios_U008 operand5;
    bios_U008 operand6;
} BMP_FORMAT_11;

#define INIT_FMT12_FMT "1b2d2bd"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_U032 operand2;
    bios_U008 operand3;
    bios_U008 operand4;
    bios_U032 operand5;
    // instruction followed by a U032 array
} BMP_FORMAT_12;

#define INIT_FMT13_FMT "1b1w4bd"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
    bios_U008 operand2;
    bios_U008 operand3;
    bios_U008 operand4;
    bios_U008 operand5;
    bios_U032 operand6;
    // instruction followed by a U032 array
} BMP_FORMAT_13;

#define INIT_FMT14_FMT "1b1w5b1d"
typedef struct
{
    bios_U008 opcode;
    bios_U016 operand1;
    bios_U008 operand2;
    bios_U008 operand3;
    bios_U008 operand4;
    bios_U008 operand5;
    bios_U008 operand6;
    bios_U032 operand7;
    // instruction followed by a U016 array
} BMP_FORMAT_14;

#define INIT_FMT15_FMT "1b4d1b"
typedef struct
{
    bios_U008 opcode;
    bios_U032 operand1;
    bios_U032 operand2;
    bios_U032 operand3;
    bios_U032 operand4;
    bios_U008 operand5;
    // instruction followed by a U008 array
} BMP_FORMAT_15;


// biggest simple BMP item should be no bigger than this..
#define BMP_MAX_PADDED_SIZE 256


// memory initialization structs

#define MEM_INIT_STRAP_MAX          0xf        // the *max* value, so can have 16
#define MEM_INIT_SEQ_TABLE_MAX      32
#define SDR                         0
#define DDR                         1
#define MEM_INIT_END_OF_SEQUENCE    0xffffffff
#define SPECIAL_32                  0x00000001 // Mask for SPECIAL_32 bit 
#define SCRAMBLE_RAM                0x00000080 // Mask for scrambling the RAM
#define NV_PFB_CONFIG_0_SCRAMBLE    29:29 /* RWIVF */

/* SDR and DDR Sequence Table definitions */
#define MEM_SEQ_FMT "32d"


typedef struct
{
    bios_U032 PFB_BOOT_0_value;
    bios_U032 PFB_CONFIG_1_value;

} bmpMemInitData;

// NV10 memory init structure
/*
    _Flags          dw      ?               ; Bit0: 0 = SDR, 1 = DDR
    _MClk_PLL       dw      ?
    _NVClk_PLL      dw      ?
    _refctrl1       dd      NV_PFB_REFCTRL_VALID_0  ; NV_PFB_REFCTRL
    _cfg            dd      ?               ; NV_PFB_CFG
    _timing0        dd      ?               ; NV_PFB_TIMING0
    _timing1        dd      ?               ; NV_PFB_TIMING1
    _timing2        dd      ?               ; NV_PFB_TIMING2
    _ctrim4         dd      0
    _pin            dd      NV_PFB_PIN_CKE_NORMAL OR NV_PFB_PIN_DQM_NORMAL
    _emrs           dd      ?               ; NV_PFB_EMRS
    _mrs1           dd      ?               ; NV_PFB_MRS
    _mrs2           dd      ?               ; NV_PFB_MRS
    _refctrl2       dd      NV_PFB_REFCTRL_VALID_1  ; NV_PFB_REFCTRL
    _expand1        dd      0
    _expand2        dd      0
*/


#define MEM_INIT_VALS_NV10_FMT           "3w13d"
typedef struct
{
    bios_U016 Flags;         // Bit0: 0 = SDR, 1 = DDR
    bios_U016 MClk_PLL;
    bios_U016 NVClk_PLL;
    bios_U032 data[13];

} MEM_INIT_VALS_NV10;

// NV15 memory init structure
/*
    _Flags          dw      ?               ; Bit0: 0 = SDR, 1 = DDR
    _MClk_PLL       dw      ?
    _NVClk_PLL      dw      ?
    _pbus_debug_0   dd      ?
    _refctrl1       dd      NV_PFB_REFCTRL_VALID_0  ; NV_PFB_REFCTRL
    _cfg            dd      ?               ; NV_PFB_CFG
    _timing0        dd      ?               ; NV_PFB_TIMING0
    _timing1        dd      ?               ; NV_PFB_TIMING1
    _timing2        dd      ?               ; NV_PFB_TIMING2
    _ctrim4         dd      06530110h
    _ctrim5         dd      0777FFF0h
    _pin            dd      NV_PFB_PIN_CKE_NORMAL OR NV_PFB_PIN_DQM_NORMAL
    _emrs           dd      ?               ; NV_PFB_EMRS
    _mrs1           dd      ?               ; NV_PFB_MRS
    _mrs2           dd      ?               ; NV_PFB_MRS
    _refctrl2       dd      NV_PFB_REFCTRL_VALID_1  ; NV_PFB_REFCTRL
    _expand1        dd      0FFFFFFFFh
    _expand2        dd      0FFFFFFFFh
*/


#define MEM_INIT_VALS_NV15_FMT           "3w15d"
typedef struct
{
    bios_U016 Flags;         // Bit0: 0 = SDR, 1 = DDR
    bios_U016 MClk_PLL;
    bios_U016 NVClk_PLL;
    bios_U032 data[15];
} MEM_INIT_VALS_NV15;

// generic memory init types
typedef MEM_INIT_VALS_NV10 MEM_INIT_TABLE_NV10[MEM_INIT_STRAP_MAX + 1];
typedef MEM_INIT_VALS_NV15 MEM_INIT_TABLE_NV15[MEM_INIT_STRAP_MAX + 1];

#define MEM_INIT_VALS_MAX_BYTE_SIZE 80

#define BMP_I2C_FMT "2d" "4b" "2w"
typedef struct
{
    bios_U032 Reserved1;
    bios_U032 Reserved2;

    bios_U008 CRTI2CPort;
    bios_U008 TVI2CPort;
    bios_U008 DFPI2CPort;
    bios_U008 Reserved3;

    bios_U016 I2CPort0IO;
    bios_U016 I2CPort1IO;

} BIOSI2CTable, *PBIOSI2CTable;

// BMP script

// script table
typedef bios_U016 SCRIPT_TABLE_ENTRY;

// Macro Index Table Entry structure
#define MACRO_INDEX_ENTRY_FMT  "bb"
typedef struct
{
    bios_U008 macroIndex;
    bios_U008 macroCount;
} MACRO_INDEX_ENTRY;

// Macro Table Entry structure
#define MACRO_ENTRY_FMT  "dd"
typedef struct
{
    bios_U032 macroAddress;
    bios_U032 macroValue;
} MACRO_ENTRY;

// Condition Table Entry structure
#define CONDITION_ENTRY_FMT "3d"
typedef struct
{
    bios_U032 condAddress;
    bios_U032 condMask;
    bios_U032 condCompare;
} CONDITION_ENTRY;

// I/O Condition Table Entry structure
#define NO_CONDITION 0xff
#define IO_CONDITION_ENTRY_FMT "wbbb"
typedef struct
{
    bios_U016 iocondPort;
    bios_U008 iocondIndex;
    bios_U008 iocondMask;
    bios_U008 iocondCompare;
} IO_CONDITION_ENTRY;

// I/O Flag Condition Table Entry structure
#define IO_FLAG_CONDITION_ENTRY_FMT         "wbbbwbb"
typedef struct
{
    bios_U016 iofcondPort;
    bios_U008 iofcondIndex;
    bios_U008 iofcondMask;
    bios_U008 iofcondShift;
    bios_U016 iofcondFlagArray;
    bios_U008 iofcondFlagMask;
    bios_U008 iofcondFlagCompare;
} IO_FLAG_CONDITION_ENTRY;

// Function Table Entry structure
#define FUNCTION_ENTRY_FMT "w"
typedef bios_U016 FUNCTION_TABLE_ENTRY;

#define TMDS_MODE_FORMAT        "1w1b"
typedef struct
{
    bios_U016 tmdsmFreq;
    bios_U008 tmdsmScript;
} TMDS_MODE_ENTRY;


#define DEV_HEAD_FMT "1b1b1w"
typedef struct
{
    bios_U008 version;
    bios_U008 blocks;
    bios_U016 i2c_port_list;
} DEV_HEAD, *PDEV_HEAD;


#define DEV_REC_STRUC_FMT "1d1w1d"
typedef struct
{
    bios_U032 dev_type;
    bios_U016 data_ptr;
    bios_U032 data_rsvr;
} DEV_REC_STRUC, *PDEV_REC_STRUC;

#define DEV_REC_UNUSED_DEV      0xFFFFFFFF

/*
DEV_REC    RECORD  rec_rsvd:4=0, \
                   dbus:3=0, \
                   location:4=0, \
                   head:3=0, \
                   i2c:4=0, \
                   format:6=0, \
                   subtype:4=0, \
                   dtype:4=0
*/

// DEV_REC { X, X, DEV_REC_LOCATION_BOARD=1, Head, X, X, X, DEV_REC_TYPE_CRT=0}                            
// mask:  0000 000 1111 111 0000 000000 0000 1111
// value: 0000 000 0001 hhh 0000 000000 0000 0000

#define DEV_REC_CRT_DEV_MASK    0x01FC000F
#define DEV_REC_CRT_DEV_EXTERNAL_DAC 0x00200000
#define DEV_REC_HEAD_SHIFT      18

#pragma pack()

RM_STATUS BiosReadBytes            (PHWINFO, U008[], U032 offset, U032 size);
RM_STATUS BiosCalculateSizes       (const char *, U032 *, U032 *);
RM_STATUS BiosUnpackLittleEndianStructure(U008 *packedLEData, U032 *unpackedData, const char *format, U032 *numfields, U032 *unpacked_bytes);
RM_STATUS BiosReadStructure        (PHWINFO, void *, U032, U032*, const char *);
RM_STATUS BiosReadArray            (PHWINFO, void *, U032, U032, U032*, const char *);
U008 BiosRead8                     (PHWINFO, U032);
U016 BiosRead16                    (PHWINFO, U032);
U032 BiosRead32                    (PHWINFO, U032);
RM_STATUS BiosFindString           (PHWINFO, U008 string[], U032*, U032 string_size);
RM_STATUS BiosGetMaxExternalPCLKFreq(PHWINFO, U032 head, U032* freq);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\devinit.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************************************************************************************************
*
*   Header: devinit.h
*
*   Description:
*       Definitions for devinit.h.
*
*   Revision History:
*       Original -- 2/99 Jeff Westerinen
*
**************************************************************************************************************/

#include <bios.h>

// init table definitions
extern U032 Nv04_bmp_GenInitTbl[];
extern U032 Nv05_bmp_GenInitTbl[];
extern U032 Nv05Pro_bmp_GenInitTbl[];
extern bmpMemInitData Nv05_bmp_MemInitTbl[];

extern U032 Nv10_SDR_Sequence_Table[];
extern U032 Nv10_DDR_Sequence_Table[];
extern MEM_INIT_TABLE_NV10 Nv10_bmp_MemInitTbl;
extern U032 Nv10_bmp_GenInitTbl[];

// video RAM type enumerations
enum 
{
    DEVINIT_NORAM, 
    DEVINIT_SDRAM, 
    DEVINIT_SGRAM
};

// internal TMDS types
enum
{
    TMDSIT_TMDS_SINGLE_A,
    TMDSIT_TMDS_SINGLE_B,
    TMDSIT_TMDS_DUAL,
    TMDSIT_LVDS_SINGLE_A,
    TMDSIT_LVDS_SINGLE_B,
    TMDSIT_LVDS_DUAL,
    TMDSIT_OFF_SINGLE_A,
    TMDSIT_OFF_SINGLE_B
};

// table to hold copy of our devinit tables
typedef struct {
    U032 memInitTable[(MEM_INIT_STRAP_MAX+1) * (MEM_INIT_VALS_MAX_BYTE_SIZE / 4)];
    U032 SDRSeqTable[MEM_INIT_SEQ_TABLE_MAX];
    U032 DDRSeqTable[MEM_INIT_SEQ_TABLE_MAX];
    U032 *genInitCode;
    U008 *genInitData;
    U032 *extraInitCode;
    U008 *extraInitData;
 } devinit_tables_t;

#define DEVINIT_STACK_MAX 20
typedef struct
{
    U032 body[DEVINIT_STACK_MAX];
    U032 sp;
} DEVINIT_STACK, *PDEVINIT_STACK;

// tables from bios we extract (and convert) up front
typedef struct {
        MACRO_INDEX_ENTRY       macroIndexTable[256];
        MACRO_ENTRY             macroTable[256];
        CONDITION_ENTRY         conditionTable[256]; 
        IO_CONDITION_ENTRY      ioConditionTable[256];
        IO_FLAG_CONDITION_ENTRY ioFlagConditionTable[256];
        FUNCTION_TABLE_ENTRY    functionTable[256];
} BIOS_BIP3_TABLES;

typedef struct
{
    BOOL                    conditionFlag;
    DEVINIT_STACK           loopStack;
    BOOL                    doJump;
    U032                    jumpIndex;

    // offsets with the bios
    U032                    scriptTableOffset;
    U032                    macroIndexTableOffset;
    U032                    macroTableOffset;
    U032                    conditionTableOffset;
    U032                    ioConditionTableOffset;
    U032                    ioFlagConditionTableOffset;
    U032                    functionTableOffset;
    U032                    TMDSSingleAOffset;
    U032                    TMDSSingleBOffset;
    U032                    TMDSDualOffset;
    U032                    LVDSSingleAOffset;
    U032                    LVDSSingleBOffset;
    U032                    LVDSDualOffset;
    U032                    OffSingleAOffset;
    U032                    OffSingleBOffset;

    BIOS_BIP3_TABLES       *tables;

} EXECUTION_CONTEXT, *PEXECUTION_CONTEXT;


// prototypes
RM_STATUS   DevinitInitializeDevice     (PHWINFO, PHWREG, BOOL*);
RM_STATUS   DevinitProcessStaticTables  (PHWINFO);
RM_STATUS   DevinitProcessBip2          (PHWINFO, U032, BMP_Control_Block, BOOL*);
RM_STATUS   DevinitGetBMPControlBlock   (PHWINFO, BMP_Control_Block *, U032 *);
RM_STATUS   DevinitGetInitTableInfo     (PHWINFO, U032, PBMP_Control_Block, U032*, U032*, U032*, U032*, U032*, U032*);
RM_STATUS   DevinitInitDataToCode       (U032[], U008[]);
RM_STATUS   InitNV                      (PHWINFO, U032[], VOID*, U032[], U032[]);
U008        DevinitFetchByte            (U032[], U032*);
U016        DevinitFetchWord            (U032[], U032*);
U032        DevinitFetchDword           (U032[], U032*);
RM_STATUS   DevinitProcessBip3          (PHWINFO);
RM_STATUS   DevinitProcessBip3InternalTMDS (PHWINFO,U032,U032);
RM_STATUS   DevinitProcessBip3InternalTMDSTable (PHWINFO, PEXECUTION_CONTEXT, U032, U032);
RM_STATUS   DevinitGetBIP3TableOffsets  (PHWINFO, PEXECUTION_CONTEXT);
RM_STATUS   DevinitReadBIP3Tables       (PHWINFO, PEXECUTION_CONTEXT);
VOID        DevinitCleanupBIP3Tables    (PHWINFO, PEXECUTION_CONTEXT);
RM_STATUS   DevinitInterpretBIP3Script  (PHWINFO, PEXECUTION_CONTEXT, U032);
U008        DevinitFetchInstruction     (PHWINFO, U032, VOID*, U032*, U032*);
RM_STATUS   DevinitGetMinMaxVCOValues   (PHWINFO, U032*, U032*);
RM_STATUS   init_NV                     (PHWINFO, U032, U032, U032, BOOL);
RM_STATUS   init_PLL_Values             (PHWINFO, U032, U032, BOOL);
RM_STATUS   init_TIME_Delay             (PHWINFO, U032);
RM_STATUS   init_IO_Write               (PHWINFO, U016, U008, U008, BOOL);
RM_STATUS   init_INDEX_IO_Write         (PHWINFO, U032, U032, U032, U032, BOOL);
RM_STATUS   init_MEM_RESTRICT_SCRIPT    (PHWINFO, U032, U032, BOOL*);
RM_STATUS   init_STRAP_RESTRICT_SCRIPT  (PHWINFO, U032, U032, BOOL*);
RM_STATUS   init_CONFIGURE_Clocks       (PHWINFO, VOID*);
RM_STATUS   init_CONFIGURE_Memory       (PHWINFO, VOID*, U032[], U032[]);
RM_STATUS   init_CONFIGURE_PreInit      (PHWINFO);
RM_STATUS   init_COMPUTE_Memory         (PHWINFO);
RM_STATUS   init_Reset_Chip             (PHWINFO, U032, U032, U032);
RM_STATUS   init_IO                     (PHWINFO, U032, U032, U032, BOOL);
RM_STATUS   init_Condition              (PHWINFO, PEXECUTION_CONTEXT, U032, BOOL*);
RM_STATUS   init_IoCondition            (PHWINFO, PEXECUTION_CONTEXT, U032, BOOL*);
RM_STATUS   init_IoFlagCondition        (PHWINFO, PEXECUTION_CONTEXT, U032, BOOL*);
RM_STATUS   init_RestrictProg           (PHWINFO, PEXECUTION_CONTEXT, U032, U032, U032, U032, U032, U032, BOOL);
RM_STATUS   init_IoRestrictProg         (PHWINFO, PEXECUTION_CONTEXT, U032, U032, U032, U032, U032, U032, U032, BOOL);
RM_STATUS   init_IoRestrictPll          (PHWINFO, PEXECUTION_CONTEXT, U032, U032, U032, U032, U032, U032, U032, U032, BOOL);
RM_STATUS   init_IndexAddressLatched    (PHWINFO, U032, U032 ,U032, U032, U032, U032, BOOL);
RM_STATUS   init_Sub                    (PHWINFO, PEXECUTION_CONTEXT, U032, BOOL);
RM_STATUS   init_Macro                  (PHWINFO, PEXECUTION_CONTEXT, U032, BOOL);
RM_STATUS   init_ZM_IO                  (PHWINFO, U032, U032, BOOL);
RM_STATUS   init_Copy                   (PHWINFO, PEXECUTION_CONTEXT, U032, S008, U032, U032, U032, U032, BOOL);
RM_STATUS   init_Repeat                 (PHWINFO, PEXECUTION_CONTEXT, U032, U032);
RM_STATUS   init_EndRepeat              (PHWINFO, PEXECUTION_CONTEXT, U032*);
RM_STATUS   init_Function               (PHWINFO, PEXECUTION_CONTEXT, U032);
VOID        DevinitMeminitFormat        (PHWINFO, char **, int *);
RM_STATUS   DevinitReadPort             (PHWINFO, U032, U032, U008*);
RM_STATUS   DevinitWritePort            (PHWINFO, U032, U032, U032);
RM_STATUS   DevinitPortToPrivReg        (U032, U032*);
VOID        DevinitStackPush            (PDEVINIT_STACK,  U032);
U032        DevinitStackPop             (PDEVINIT_STACK);
U032        DevinitStackTop             (PDEVINIT_STACK);
RM_STATUS   DevinitShadowBios           (PHWINFO, PHWREG);
RM_STATUS   Nv04MemResizeMemory         (PHWINFO);
RM_STATUS   Nv04MemResizeSdram          (PHWINFO);
RM_STATUS   Nv04MemResizeSgram          (PHWINFO);
VOID        Nv04MemLatchMemConfig       (PHWINFO);
RM_STATUS   Nv05MemResizeMemory         (PHWINFO);
VOID        Nv05MemLatchMemConfig       (PHWINFO);
RM_STATUS   Nv10MemConfigureClocks      (PHWINFO, MEM_INIT_TABLE_NV10);
RM_STATUS   Nv10MemConfigureMemory      (PHWINFO, MEM_INIT_TABLE_NV10, U032[], U032[]);
RM_STATUS   Nv10MemChipPreInit          (PHWINFO);
RM_STATUS   Nv10MemComputeMemory        (PHWINFO);
RM_STATUS   Nv15MemConfigureClocks      (PHWINFO, MEM_INIT_TABLE_NV15);
RM_STATUS   Nv15MemConfigureMemory      (PHWINFO, MEM_INIT_TABLE_NV15, U032[], U032[]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\edid.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** EDID includes *******************************\
*                                                                           *
* Module: EDID.H                                                            *
*   This module contains structure and prototype definitions used in the    *
*   EDID utility functions.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _EDID_H_
#define _EDID_H_

RM_STATUS StopDDC1(PHWINFO, U032, U032);
RM_STATUS IsMonitorDDC(PHWINFO, U032, U032, U008 *);
RM_STATUS edidReadDevEDID(PHWINFO, U032, U008 *);
BOOL edidLogicalEDIDIsValid(U008 **, U032 *, U032 *);
RM_STATUS EDIDRead(PHWINFO, U032, U032);
RM_STATUS EDIDGetMaxRefreshRate(PHWINFO, U032, U032, U032 *);
RM_STATUS EDIDIsMonitorGTF (PHWINFO, BOOL *);
RM_STATUS ReadVDIF(PHWINFO, U032, U032, U008 *, U008, U008);
RM_STATUS EDIDCopy(PHWINFO, U008 *, U032 *, U032);
RM_STATUS ParseEDID2(PHWINFO, U032);
RM_STATUS ParseEDID12(PHWINFO, U032);
RM_STATUS ParseEDID11(PHWINFO, U032);
RM_STATUS fpParseEDID(PHWINFO, U032);
U032 edidParseDetailedTimingBlock(PHWINFO, U008, PDACFPTIMING, U032);
U032 edidParseDetailed1(PHWINFO, U008, PDACFPTIMING, U032);
U032 edidParseDetailed2(PHWINFO, U008, PDACFPTIMING, U032);
U032 edidGetVersion(PHWINFO, U032);
BOOL edidIsAnalogDisplay(PHWINFO, U032); 
BOOL edidIsDigitalDisplay(PHWINFO, U032); 
RM_STATUS EDIDDetect(PHWINFO, U032, U032);
RM_STATUS edidConstructMobileInfo(PHWINFO, U032, U008 *);
U032 getI2CPort(PHWINFO, U032, U032 );
U032 edidGetDDCCaps(PHWINFO);

#define DDC_RETRIES     3
#define NUM_DET_TIM		4

// DDC device address
#define DDC_CRT_ADR1 0x50
#define DDC_CRT_ADR2 0x51
#define DDC_CRT_ADR3 0x53

// EDID versions
#define EDID_VERSION_10	0x10
#define EDID_VERSION_11	0x11
#define EDID_VERSION_12	0x12
#define EDID_VERSION_13	0x13
#define EDID_VERSION_20	0x20
#define EDID_VERSION_14	0x14    // non-existant, but we should work if this gets added

// Flags byte, sync polarities (bits 2,1)
#define VSYNC_POS	1<<2
#define VSYNC_NEG	0
#define HSYNC_POS	1<<1
#define HSYNC_NEG	0

// EDID Version 1 header defines.
#define EDID_V1_SIZE 128
#define EDID_V1_VENDOR_ID_INDEX 0x08
#define EDID_V1_VERSION_NUMBER_INDEX  0x12
#define EDID_V1_REVISION_NUMBER_INDEX 0x13
#define EDID_V1_VIDEO_INPUT_DEF_INDEX 0x14
#define EDID_V1_FEATURE_SUPPORT_INDEX        0x18
#define EDID_V1_ESTABLISHED_TIMING_1_INDEX   0x23
#define EDID_V1_ESTABLISHED_TIMING_2_INDEX   0x24
#define EDID_V1_ESTABLISHED_TIMING_3_INDEX   0x25
#define EDID_V1_STANDARD_TIMING_1_INDEX      0x26
#define EDID_V1_NUM_STANDARD_TIMINGS        0x36-0x26
#define EDID_ESTABLISHED_TIMING_640x480_ANY 0x38
#define EDID_ESTABLISHED_TIMING_640x480_60  0x20
#define EDID_ESTABLISHED_TIMING_640x480_67  0x10
#define EDID_ESTABLISHED_TIMING_640x480_72  0x08
#define EDID_ESTABLISHED_TIMING_640x480_75  0x04
#define EDID_ESTABLISHED_TIMING_800x600_ANY 0xC0
#define EDID_ESTABLISHED_TIMING_800x600_56  0x02
#define EDID_ESTABLISHED_TIMING_800x600_60  0x01
#define EDID_ESTABLISHED_TIMING_800x600_72  0x80
#define EDID_ESTABLISHED_TIMING_800x600_75  0x40
#define EDID_ESTABLISHED_TIMING_1024x768_ANY 0x1E
#define EDID_ESTABLISHED_TIMING_1024x768_87  0x10
#define EDID_ESTABLISHED_TIMING_1024x768_60  0x08
#define EDID_ESTABLISHED_TIMING_1024x768_70  0x04
#define EDID_ESTABLISHED_TIMING_1024x768_75  0x02
#define EDID_ESTABLISHED_TIMING_1280x1024_75  0x01

// Standard timings start at bytes index 0x26. Each standard timing is 2 bytes.
// There are 8 standard timings entries.
#define EDID_V1_STANDARD_TIMINGS_START_INDEX 0x26

// Detailed timing section start at index 0x36. Each entry is 18 bytes.
// There are 4 detailed timing entries.
#define EDID_V1_DETAILED_TIMINGS_START_INDEX 0x36
#define EDID_V1_DETAILED_TIMINGS_SIZE 18


// EDID Version 2 header defines.
#define EDID_V2_SIZE 256
#define EDID_V2_VERSION_NUMBER_INDEX  0x0
#define EDID_V2_DISPLAY_TECHNOLOGY_INDEX 0x4f
#define DISPLAY_TECHNOLOGY_TYPE_MASK  0xf0
#define EDID_V2_GTF_SUPPORT_INDEX     0x7d
#define EDID_V2_TIMING_MAP1_INDEX     0x7e  // map of timing info
#define EDID_V2_TIMING_MAP2_INDEX     0x7f
#define EDID_V2_TIMING_SECTION_START_INDEX 0x80  // offset 80: start of timing info
#define EDID_V2_LUM_TABLE_EXIST		  0x20	// map bit 5
#define TRIPLE_LUM_ENTRIES			  0x80	// offset 80 bit 7: lum table white (x1) or RGB (x3)
#define NUM_LUM_ENTRIES				  0x1f	// size of lum table (x1 or x3)
#define	EDID_V2_FREQ_RANGES			  0x1c
#define EDID_V2_FREQ_RANGE_SHIFT	  0x02
#define EDID_V2_DETAILED_RANGE_LIMITS 0x03
#define EDID_V2_TIMING_CODES		  0xf8
#define EDID_V2_TIMING_CODES_SHIFT	  0x03
#define EDID_V2_DETAILED_TIMINGS	  0x07
#endif // _EDID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\dac.h ===
#ifndef _DAC_H_
#define _DAC_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/********************************* DAC Module ******************************\
*                                                                           *
* Module: DAC.H                                                             *
*       DAC support routines.                                               *
*                                                                           *
\***************************************************************************/

#include <nvmisc.h>                 // pick up I2C structures

#include <nvcm.h>                   // ick ick ick ick

//
// Microport access macros.
//
#ifdef SOLARIS

// 3-6-96 With updated model simulation requires DAC initialization, so
//        we place back the DAC macros.
/*
#define DAC_WR08(rr,dd) 
#define DAC_INDEX_WR08(ii,dd) 
#define DAC_RD08(rr) \
    (REG_RD32(rr)&0xFF)
#define DAC_INDEX_RD08(ii,dd) \
    DAC_WR08(SGS_DAC_UPORT_INDEX_LO,(ii));   \
    DAC_WR08(SGS_DAC_UPORT_INDEX_HI,(ii)>>8);\
    (dd)=DAC_RD08(SGS_DAC_UPORT_INDEX_DATA)
*/

// Origional DAC Macros for RM.
#define DAC_WR08(rr,dd) \
    REG_WR32((rr),(dd)&0xFF)
#define DAC_INDEX_WR08(ii,dd) \
    DAC_WR08(SGS_DAC_UPORT_INDEX_LO,(ii));   \
    DAC_WR08(SGS_DAC_UPORT_INDEX_HI,(ii)>>8);\
    DAC_WR08(SGS_DAC_UPORT_INDEX_DATA,(dd))
#define DAC_RD08(rr) \
    (REG_RD32(rr)&0xFF)
#define DAC_INDEX_RD08(ii,dd) \
    DAC_WR08(SGS_DAC_UPORT_INDEX_LO,(ii));   \
    DAC_WR08(SGS_DAC_UPORT_INDEX_HI,(ii)>>8);\
    (dd)=DAC_RD08(SGS_DAC_UPORT_INDEX_DATA)


#else   // ifdef SOLARIS
#if 0
#define DAC_WR08(rr,dd) \
    REG_WR32((rr),(dd)&0xFF)
#endif
#define DAC_INDEX_WR08(ii,dd) \
    DAC_WR08(SGS_DAC_UPORT_INDEX_LO,(ii));   \
    DAC_WR08(SGS_DAC_UPORT_INDEX_HI,(ii)>>8);\
    DAC_WR08(SGS_DAC_UPORT_INDEX_DATA,(dd))
#if 0
#define DAC_RD08(rr) \
    (REG_RD32(rr)&0xFF)
#endif
#define DAC_INDEX_RD08(ii,dd) \
    DAC_WR08(SGS_DAC_UPORT_INDEX_LO,(ii));   \
    DAC_WR08(SGS_DAC_UPORT_INDEX_HI,(ii)>>8);\
    (dd)=DAC_RD08(SGS_DAC_UPORT_INDEX_DATA)
#endif // ifdef SOLARIS


/* XXX temporary until they appear in nv_def.h */
#define NV_CIO_CRE_DDC0_STATUS__INDEX                     0x00000036
#define NV_CIO_CRE_DDC0_WR__INDEX                         0x00000037

#define CRTC2   1

// These macros access the DAC (including PCRTC) for either of two heads
#define DAC_REG_WR08(a,d,h)         \
        REG_WR08(a + CurDacAdr(h), d)

#define DAC_REG_WR32(a,d,h)         \
        REG_WR32(a + CurDacAdr(h), d) 

#define DAC_REG_RD08(a,h)           \
        REG_RD08(a + CurDacAdr(h)) 

#define DAC_REG_RD32(a,h)           \
        REG_RD32(a + CurDacAdr(h)) 

// We need special versions of these macros for HAL use...
#define HAL_DAC_REG_WR32(a,d,o)         \
        REG_WR32(a + o, d) 

#define HAL_DAC_REG_RD32(a,o)           \
        REG_RD32(a + o) 

#define DAC_FLD_WR_DRF_DEF(d,r,f,c,h) \
        REG_WR32(NV##d##r + CurDacAdr(h),(REG_RD32(NV##d##r + CurDacAdr(h))&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

// HAL Version
#define HAL_DAC_FLD_WR_DRF_DEF(d,r,f,c,o) \
        REG_WR32(NV##d##r + o,(REG_RD32(NV##d##r + o)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

#define DAC_FLD_WR_DRF_NUM(d,r,f,n,h) \
        REG_WR32(NV##d##r + CurDacAdr(h),(REG_RD32(NV##d##r + CurDacAdr(h))&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n)) 

#define DAC_REG_WR_DRF_DEF(d,r,f,c,h) \
        REG_WR32(NV ## d ## r + CurDacAdr(h), DRF_DEF(d,r,f,c))

#define DAC_REG_RD_DRF(d,r,f,h) \
    ((REG_RD32(NV##d##r + CurDacAdr(h))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

// HAL Version
#define HAL_DAC_REG_RD_DRF(d,r,f,o) \
    ((REG_RD32(NV##d##r + o)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//---------------------------------------------------------------------------
// Standard VGA Mode Table Structure
typedef struct _seq_ 
{   
    U008 ClockMode; 
    U008 MapMask; 
    U008 FontAddr; 
    U008 MemMode;
} SEQ;      
     
typedef struct  _crtc_
{
    U008   HTotal;
    U008   HDispEnd;
    U008   HBlankS;
    U008   HBlankE;
    U008   HSyncS;
    U008   HSyncE;
    U008   VTotal;
    U008   Overflow;
    U008   PresetRowScan;
    U008   CellHeight;
    U008   CursorS;
    U008   CursorE;
    U008   RegenSHigh;
    U008   RegenSLow;
    U008   CursorPosHigh;
    U008   CursorPosLow;
    U008   VSyncS;
    U008   VSyncE;
    U008   VDispE;
    U008   RowOffset;
    U008   ULineRow;
    U008   VBlankS;
    U008   VBlandE;
    U008   Mode;
    U008   LineCompare;
} CRTC;

typedef struct  _gr_
{
    U008   SetReset;
    U008   EnableSetReset;
    U008   ColorCmp;
    U008   ROP;
    U008   ReadMap;
    U008   Mode;
    U008   Misc;
    U008   CDC;
    U008   BitMask;
} GR;   
    
// Standard VGA Mode Table format.
typedef struct _vga_mode_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U016  RegenLenght;
    SEQ     seq_regs;              // SR1-4
    U008   PT_Misc;               // Misc Register
    CRTC    crtc_regs;             // CR0-18
    U008   PT_ATC[20];            // Attribute Controller
    GR      gr_regs;               // GR0-8
} VGATBL;                      

//  TVformat types
#define NTSC    0
#define PAL     1
//  TV encoders
#define NO_ENCODER 0
#define BROOKTREE  1
#define CHRONTEL   2
#define BROOKTREE_ID    0x8A
#define CHRONTEL_ID     0xEA

#define ERR_I2C_MODE    1
#define ERR_I2C_COMM    2
#define ERR_I2C_UNKNOWN 3
// Timing parameters, defined by CRTC containing low order bits
#define H_TOTAL         0
#define H_DISPLAY_END   1
#define H_BLANK_START   2
#define H_BLANK_END     3
#define H_RETRACE_START 4
#define H_RETRACE_END   5
#define V_TOTAL         6
#define V_DISPLAY_END   0x12
#define V_RETRACE_START 0x10
#define V_RETRACE_END   0x11
#define V_BLANK_START   0x15
#define V_BLANK_END     0x16

// Adjustments for TV
typedef struct
{
    U032    hRes;
    U032    vRes;
    U008    SR01;
    U008    CR00;
    U008    CR04;
    U008    CR06;
    U008    CR07;
    U008    CR08;
    U008    CR10;
    U008    CR12;
    U008    CR28;
    U008   *encoderString;
} TV_ADJUST;      

//typedef struct _I2C_string_struct_
typedef struct 
{
    U008    Dev;
    U008    reg0x00;
    U008    data0x00;
    U008    reg0x07;
    U008    data0x07;
    U008    reg0x0A;
    U008    data0x0A;
    U008    reg0x0B;
    U008    data0x0B;
    U008    reg0x13;
    U008    data0x13;
    U008    data0x14;
    U008    data0x15;
    U008    terminator;
} CH_string, *PCH_string;
    
    
//  Brooktree values -- 1 byte device ID, 6 bytes centering info, 33 bytes resolution info
typedef struct 
{
    U008    Dev;
    U008    btc1;
    U008    btc2;
    U008    btc3;
    U008    btc4;
    U008    btc5;
    U008    btc6;
    U008    bt1;
    U008    bt2;
    U008    bt3;
    U008    bt4;
    U008    bt5;
    U008    bt6;
    U008    bt7;
    U008    bt8;
    U008    bt9;
    U008    bt10;
    U008    bt11;
    U008    bt12;
    U008    bt13;
    U008    bt14;
    U008    bt15;
    U008    bt16;
    U008    bt17;
    U008    bt18;
    U008    bt19;
    U008    bt20;
    U008    bt21;
    U008    bt22;
    U008    bt23;
    U008    bt24;
    U008    bt25;
    U008    bt26;
    U008    bt27;
    U008    bt28;
    U008    bt29;
    U008    bt30;
    U008    bt31;
    U008    bt32;
    U008    bt33;
    U008    termination;
} BT_string, *PBT_string;

// DAC Flat Panel Timing struture
// Corresponds to HW regs which must be programmed for flat panel.
typedef struct DacFlatPanelTimings
{
    U032    PixClk;
    U032    HActive;
    U032    HDispEnd;
    U032    HValidStart;
    U032    HValidEnd;
    U032    HSyncStart;
    U032    HSyncEnd;
    U032    HTotal;
    U032    VActive;
    U032    VDispEnd;
    U032    VValidStart;
    U032    VValidEnd;
    U032    VSyncStart;
    U032    VSyncEnd;
    U032    VTotal;
    U032    Flags;
} DACFPTIMING, * PDACFPTIMING;

#define NV10_VSCALAR_TV_ADJUST  0x00010004  // adjustment for video overlay on TV

//
// Monitor position state.  Set during modeset and returned
// to clients via cfg get interfaces.
//
typedef struct _dac_monitor_position {
    U032 Hbs;
    U032 Hbe;
    U032 Vbs;
    U032 Vbe;
    U032 Hrs;
    U032 Hre;
    U032 Vrs;
    U032 Vre;
} DACMONITORPOSITION, *PDACMONITORPOSITION;

//
// Per-CRTC information.
// There is one of these structures for each possible CRTC in
// the system.
//
typedef struct _dac_crtc_info
{
    // Number of VIDEO_LUT_CURSOR_DAC objects allocated for this head
    U032 RefCount;

    VOID_PTR pVidLutCurDac; //Head-specific pointer, null if head is disabled.

#define DAC_CRTCINFO_VBLANK_ENABLED         0x0001
    U032 StateFlags;
    U032 UpdateFlags;

    // Panning/Buffer Flip data (used across LUT_CURSOR_DAC objects)
    U032 CurrentPanOffset;
    U032 CurrentImageOffset;

    // Display info
    U032 CurrentDisplay;
    U032 DisplayChanged;
    U032 CurrentVsyncState;
    U032 CurrentHsyncState;
    BOOL SyncStateIsSaved;
    U032 CurrentPowerState;

    // VBlank data
    BOOL IsVBlank;
    U032 VBlankToggle;
    U032 VBlankCounter;
    VOID_PTR VBlankCallbackList;

    // NvSysMoveCursor data
    S032 CursorPosX;
    S032 CursorPosY;

    // NvSysSetCursorImage data
    U032 CursorWidth;
    U032 CursorHeight;
    U032 CursorOffset;
    U032 CursorColorFormat;

    // NvSysSetCursor data
    U008 CursorImagePlane[2][32 * sizeof(U032)];
    U032 CursorType;

    // NvSysUpdateImageFormat data
    U032 ImageOffset;
    U032 ImageFormat;
    U032 ChID;
    U032 ObjectHandle;

    // Monitor position data
    DACMONITORPOSITION MonitorPosition;

    // EDID data
    U008 EdidVersion;
    U008 EdidDisplayType;
    U008 EDID[256];

} DACCRTCINFO, *PDACCRTCINFO;

// defines for the BIOS Display Config Block
#define DCB_PTR_OFFSET          0x0036      // from VGA BIOS base

// following offset are relative to the DCB base
#define DCB_REVISION_OFFSET     0x0000
#define DCB_SIZE_128B_OFFSET    0x0001      // size is in 128 bytes block
#define DCB_ICB_OFFSET          0x0002      // I2C ports configuration block
#define DCB_DEV_DESC_OFFSET     0x0004

#define DCB_FIRST_REVISION      0x13        // revision in BCD format
                                            // 1st revision that supports DCB
#define DCB_BLOCK_SIZE          128

// each device descriptor consists of 2 32-bit words and a short pointer,
// the first 32-bit word is the device type record, the second one is the data record.

// TYPE field definitions
#define DCB_DEV_REC_TYPE_CRT                    0x0
#define DCB_DEV_REC_TYPE_TV                     0x1
#define DCB_DEV_REC_TYPE_DD_SLINK               0x2
#define DCB_DEV_REC_TYPE_DD_DLINK               0x3
#define DCB_DEV_REC_TYPE_EOL                    0xf     // End of list
#define DCB_DEV_REC_TYPE_UNUSED                 0xf

// SUBTYPE field definitions
#define DCB_DEV_REC_SUBTYPE_UNUSED              0xf

// CRT subtypes
#define DCB_DEV_REC_SUBTYPE_CRT_DAC_INTERNAL    0x0
#define DCB_DEV_REC_SUBTYPE_CRT_DAC_FAIRCHILD   0x1
#define DCB_DEV_REC_SUBTYPE_CRT_UNUSED          DCB_DEV_REC_SUBTYPE_UNUSED

// TV subtypes
#define DCB_DEV_REC_SUBTYPE_TV_BROOKTREE        0x0
#define DCB_DEV_REC_SUBTYPE_TV_CHRONTEL         0x1
#define DCB_DEV_REC_SUBTYPE_TV_PHILIPS          0x2
#define DCB_DEV_REC_SUBTYPE_TV_UNUSED           DCB_DEV_REC_SUBTYPE_UNUSED

// digital display subtypes
#define DCB_DEV_REC_SUBTYPE_DD_TMDS             0x0
#define DCB_DEV_REC_SUBTYPE_DD_LVDS             0x1
#define DCB_DEV_REC_SUBTYPE_DD_UNUSED           DCB_DEV_REC_SUBTYPE_UNUSED

// FORMAT field definitions
#define DCB_DEV_REC_FMT_UNUSED                  0x3f

// CRT format definitions
#define DCB_DEV_REC_FMT_CRT_UNUSED              DCB_DEV_REC_FMT_UNUSED

// TV format definitions
#define DCB_DEV_REC_FMT_TV_NTSC_M               0x00
#define DCB_DEV_REC_FMT_TV_NTSC_J               0x01
#define DCB_DEV_REC_FMT_TV_PAL_M                0x02
#define DCB_DEV_REC_FMT_TV_PAL_BDGHI            0x03
#define DCB_DEV_REC_FMT_TV_PAL_N                0x04
#define DCB_DEV_REC_FMT_TV_PAL_NC               0x05
#define DCB_DEV_REC_FMT_TV_SECAM                0x06
#define DCB_DEV_REC_FMT_TV_STRAPS               0x0f
#define DCB_DEV_REC_FMT_TV_UNUSED               DCB_DEV_REC_FMT_UNUSED

// DFP format definitions
#define DCB_DEV_REC_FMT_DD_FIXED_00             0x00
#define DCB_DEV_REC_FMT_DD_FIXED_01             0x01
#define DCB_DEV_REC_FMT_DD_FIXED_02             0x02
#define DCB_DEV_REC_FMT_DD_FIXED_03             0x03
#define DCB_DEV_REC_FMT_DD_FIXED_04             0x04
#define DCB_DEV_REC_FMT_DD_FIXED_05             0x05
#define DCB_DEV_REC_FMT_DD_FIXED_06             0x06
#define DCB_DEV_REC_FMT_DD_FIXED_07             0x07
#define DCB_DEV_REC_FORMAT_DD_DDC               0x10
#define DCB_DEV_REC_FMT_DD_STRAPS               0x1f
#define DCB_DEV_REC_FMT_DD_UNUSED               DCB_DEV_REC_FMT_UNUSED

// I2C_PORT field definitions
#define DCB_DEV_REC_LOGICAL_PORT_0              0x0
#define DCB_DEV_REC_LOGICAL_PORT_1              0x1
#define DCB_DEV_REC_LOGICAL_PORT_2              0x2
#define DCB_DEV_REC_LOGICAL_PORT_UNUSED         0xf

// HEAD field definitions
#define DCB_DEV_REC_HEAD_A                      0x0
#define DCB_DEV_REC_HEAD_B                      0x1
#define DCB_DEV_REC_HEAD_UNUSED                 0x7

// LOCATION field definitions
#define DCB_DEV_REC_LOCATION_CHIP               0x0
#define DCB_DEV_REC_LOCATION_BOARD              0x1
#define DCB_DEV_REC_LOCATION_UNUSED             0xf

// BUS field definitions
#define DCB_DEV_REC_BUS_0                       0x0
#define DCB_DEV_REC_BUS_1                       0x1
#define DCB_DEV_REC_BUS_2                       0x2
#define DCB_DEV_REC_BUS_3                       0x3
#define DCB_DEV_REC_BUS_4                       0x4
#define DCB_DEV_REC_BUS_5                       0x5
#define DCB_DEV_REC_BUS_6                       0x6
#define DCB_DEV_REC_BUS_UNUSED                  0x7

// RSVD field definitions
#define DCB_DEV_REC_RSVD_UNUSED                 0xf

#define DCB_MAX_NUM_DEVDESCS    16      // max # of device descriptors and I2C
#define DCB_MAX_NUM_I2C_RECORDS 16      // records supported by current DCB

typedef struct {
    union {
        struct {
            U032    Type        :4;     // CRT, TV, DD
            U032    Subtype     :4;
            U032    Fmt         :6;
            U032    IdxToICB    :4;     // index into I2C Config Block
            U032    Head        :3;
            U032    Location    :4;     // chip, board
            U032    Bus         :3;
            U032    Rsvd        :4;
        } DevRec;

        U032 DevRec_U032;
    } DCBDevRec;

    U016    DataPtr;

    union {
        U032    DataReserved;
        U008    DataByte;
        U016    DataWord;
        U032    DataDword;
    } DCBDevData;

    // this var tells device type and unit by the lone set bit
    U032    DevTypeUnit;    // bits 0..7 map to CRT0..CRT7
                            // bits 8..15 map to TV0..TV7
                            // bits 16..23 map to DD0..DD7
} DACDCBDEVDESC, *PDACDCBDEVDESC;

// shortcuts for accessing DCB device descriptor field
#define DCBRecType        DCBDevRec.DevRec.Type
#define DCBRecSubtype     DCBDevRec.DevRec.Subtype
#define DCBRecFmt         DCBDevRec.DevRec.Fmt
#define DCBRecIdxToICB    DCBDevRec.DevRec.IdxToICB
#define DCBRecHead        DCBDevRec.DevRec.Head
#define DCBRecLocation    DCBDevRec.DevRec.Location
#define DCBRecBus         DCBDevRec.DevRec.Bus

#define I2C_PHYSICAL_PORT_A_STATUS         0x3E        // CR3E
#define I2C_PHYSICAL_PORT_A_DATA           0x3F        // CR3F
#define I2C_PHYSICAL_PORT_B_STATUS         0x36        // CR36
#define I2C_PHYSICAL_PORT_B_DATA           0x37        // CR37
#define I2C_PHYSICAL_PORT_C_STATUS         0x50        // CR50
#define I2C_PHYSICAL_PORT_C_DATA           0x51        // CR51
#define I2C_PHYSICAL_PORT_UNUSED           0xFF        // Unused I2C Port

#define I2C_PORT_UNUSED                    0xFF        // Port is not used

// i2c_access field - Access methods for I2C Port
#define I2C_PORT_ACCESS_UNUSED             0x03        // No access method defined
#define I2C_PORT_ACCESS_CRTC_INDEXED       0x00        // Indexed IO at 3x4/3x5
#define I2C_PORT_ACCESS_DIRECT_IO          0x01        // Direct IO (not indexed)

// i2c_rsvd field
#define I2C_PORT_RSVD_UNUSED               0x3F        // Unused
                                    
#define I2C_PORT_IOPORT_HI_UNUSED          0xFF        // Unused


typedef struct {
    U008    WritePort;
    U008    ReadPort;
    U016    IoPortHi    :8;
    U016    I2cAccess   :2;
    U016    Reserved    :6;

} DACDCBI2CRECORD, *pDACDCBI2CRECORD;

//
//  Function prototypes for Video DAC.
//
//---------------------------------------------------------------------------

RM_STATUS initDac(PHWINFO);
RM_STATUS dacCreateObj(VOID *, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS dacDestroyObj(VOID *, POBJECT);
RM_STATUS dacSetDpmLevel(PHWINFO);
RM_STATUS dacLoadReg(U032, U032, U032);
RM_STATUS dacLoadWidthDepth(PHWINFO, U032);
RM_STATUS dacCalcPLL(PHWINFO);
U032      dacCalcMNP(PHWINFO, U032, U032, U032 *, U032 *, U032 *);
RM_STATUS dacLoadPClkVClkRatio(VOID);
RM_STATUS dacCalcPClkVClkRatio(VOID);
RM_STATUS dacGetDisplayInfo(PHWINFO, U032, U032 *, U032 *, U032 *, U032 *);
RM_STATUS dacProgramPClk(PHWINFO, U032, U032);
RM_STATUS dacProgramMClk(PHWINFO);
RM_STATUS dacProgramNVClk(PHWINFO);
RM_STATUS dacVBlank(PHWINFO);
RM_STATUS dacUpdateEmulatedCursor(VOID);
RM_STATUS dacHideEmulatedCursor(VOID);
VOID      dacEnableCursor(PHWINFO, U032);
VOID      dacDisableCursor(PHWINFO, U032);
VOID      dacEnableDac(PHWINFO, U032);
VOID      dacDisableDac(PHWINFO, U032);
VOID      dacDisableImage(PHWINFO, U032);
VOID      dacEnableImage(PHWINFO, U032);
VOID      dacDisableTV(PHWINFO, U032);
VOID      dacEnableTV(PHWINFO, U032);
RM_STATUS dacProgramCursorImage(PHWINFO, U032, U032, U032, U032, U032);
RM_STATUS dacProgramCursorPosition(PHWINFO, U032, U032, U032);
RM_STATUS dacProgramVideoStart(PHWINFO, U032, U032, U032);
RM_STATUS dacProgramLUT(PHWINFO, U032, U032*, U032);
RM_STATUS dacProgramScanRegion(PHWINFO, U032, U032, U032, U032);
RM_STATUS dacSetMonitorPosition(PHWINFO, U032, U032, U032, U032, U032);
VOID      dacGetMonitorDefaultPosition(PHWINFO, U032, U032 *, U032 *, U032 *, 
                                       U032 *, U032 *, U032 *, U032 *, U032 *);
VOID      dacSaveMonitorDefaultPosition(PHWINFO, U032);
VOID      dacGetDefaultTVPosition(PHWINFO, U032, U032, U008, U032 *);
VOID      dacSetTVPosition(PHWINFO, U032, U032 *);
RM_STATUS dacWriteDesktopPositionToRegistry(PHWINFO, U032, BOOL, U008 *, U032);
RM_STATUS dacReadDesktopPositionFromRegistry(PHWINFO, U032, BOOL, U008 *, U032 *);
RM_STATUS dacReadTVDesktopPositionFromRegistry(PHWINFO, U032, U008 *, U032 *);
RM_STATUS dacReadTVOutFromRegistry(PHWINFO, U032, U032 *);
RM_STATUS dacWriteTVOutToRegistry(PHWINFO, U032, U032);
RM_STATUS dacGetBiosDefaultTVType(PHWINFO, U032 *);

BOOL       dacMonitorConnectStatus(PHWINFO, U032);
RM_STATUS  dacGetFlatPanelInfo(PHWINFO, U032, U032 *, U032 *, U032 *, BOOL *, BOOL *, BOOL);
RM_STATUS  dacSetFlatPanelMode(PHWINFO, U032, PVIDEO_LUT_CURSOR_DAC_OBJECT, U032, BOOL);
U032       dacGetFlatPanelConfig(PHWINFO, U032);
BOOL       dacFlatPanelConnectStatus(PHWINFO pDev, U032);
RM_STATUS  dacGetSyncState(PHWINFO, U032 Head, U032 *pHsync, U032 *pVsync);
RM_STATUS  dacSetSyncState(PHWINFO, U032 Head, U032 Hsync, U032 Vsync);
RM_STATUS  dacGetFlatPanelBrightness(PHWINFO, U032 Head, U032 * Brightness, BOOL * ControllerIsOn);
RM_STATUS  dacSetFlatPanelBrightness(PHWINFO, U032 Head, U032   Brightness, U032 Frequency, U032 MaxPercent, U032 MinPercent,BOOL ControllerIsOn);

//housekeeping PWM functions, reduces large spread of reg-rds to 3 closely spaced spots
void dacZeroPWMController(PHWINFO);
void dacSetPWMController(PHWINFO);
void dacGetPWMController(PHWINFO);

//an abstraction of flat panel operations
BOOL dacIsFlatPanelOn(PHWINFO pDev,U032 Head);

//some directly associated routines for adjusting brightness
U032 GetTicksForFrequency(U032 Frequency);
U032 GetAbsoluteDifference(U032 value_a,U032 value_b);
U032 GetRequiredTickCount(U032 Frequency,U032 MaxPercent,U032 MinPercent,U032 BaseMultiplier);
U032 GetPortionOfTotalSizeBasedOnPercentage(U032 TotalSize,U032 Percentage);
//U032 GetPercentageofTotalSize(U032 TotalSize,U032 Portion);
//U032 DetermineMultiplierForCurrentPeriod(PHWINFO pDev,U032 ClockTicksTotal,U032 DutyCycle);
U032 DetermineFrequencyFromTickCount(U032 NumTicks);

U032       dacGetCRTC(PHWINFO, U032, U032); 
VOID       dacSetCRTC(PHWINFO, U032, U032, U032);
RM_STATUS  dacGetCRTCTiming(PHWINFO, U032, NV_CFGEX_CRTC_TIMING_PARAMS *);
RM_STATUS  dacSetCRTCTiming(PHWINFO, U032, NV_CFGEX_CRTC_TIMING_PARAMS *);
RM_STATUS  dacSetMode(PHWINFO, U032);
RM_STATUS  dacSetModeMulti(PHWINFO, PVIDEO_LUT_CURSOR_DAC_OBJECT);
RM_STATUS  dacSetupTVEncoder(PHWINFO, U032);
RM_STATUS  dacAdjustCRTCForTV(PHWINFO, U032);
RM_STATUS  dacAdjustCRTCForFlatPanel(PHWINFO, U032, PVIDEO_LUT_CURSOR_DAC_OBJECT);

U032       dacGetBiosDisplayType(PHWINFO, U032);
BOOL       dacIsPAL(VOID);
U008       ReadCRTCLock(PHWINFO, U032);

RM_STATUS  dacGetMonitorInfo(PHWINFO, U032, U032*);
VOID       dacSetCursorBlink(PHWINFO, U032, U008);
VOID       dacSetFan(PHWINFO, U008);
RM_STATUS  dacGetColorSaturationBoost(PHWINFO, U032, U008*);
RM_STATUS  dacSetColorSaturationBoost(PHWINFO, U032, U008);
BOOL       dacTVConnectStatus(PHWINFO, U032);
U008       dacTVReadModifyWrite(PHWINFO, U032, U008, U008, U008);
//RM_STATUS  IsMonitorDDC(PHWINFO, U032, U032, U008 *);
RM_STATUS dacReadBIOSI2CSettings(PHWINFO pDev);
VOID dacDetectEncoder(PHWINFO, U032);
BOOL dacVGAConnectStatus(PHWINFO, U032);
RM_STATUS  dacPowerOnMobilePanel(PHWINFO, U032);
RM_STATUS  dacPowerOffMobilePanel(PHWINFO, U032);
// EXPER:
BOOL dacIsNV5orBetter(PHWINFO pDev);
RM_STATUS i2cAccess(PHWINFO, U032, NVRM_I2C_ACCESS_CONTROL *);
VOID RestoreLock(PHWINFO, U032, U008);
VOID SeqWr(PHWINFO, U032, U008, U008);
U008 SeqRd(PHWINFO, U032, U008);
VOID EnableSeq(PHWINFO, U032);
U008 UnlockCRTC();
VOID RestoreCRTC(U008);
VOID AssocDDC(PHWINFO, U032);
VOID AssocTV(PHWINFO, U032);
VOID AssocVideoScalar(PHWINFO, U032);
VOID EnableHead(PHWINFO, U032);
VOID EnableMobileHotkeyHandling(PHWINFO pDev);
VOID DisableMobileHotkeyHandling(PHWINFO pDev);
V032 dacService(PHWINFO);
RM_STATUS dacParseDCBFromBIOS(PHWINFO);
VOID dacDevicesConnectStatus(PHWINFO, U032 *);
RM_STATUS dacFindDevicesConfiguration(PHWINFO, U032, U032 *, U032, U032);
void RmProperClockPdivProgrammer(PHWINFO pDev,U032 ClockAddress,U032 NewValue);

#endif // _DAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\fb.h ===
#ifndef _FB_H_
#define _FB_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/**************************** Frambuffer Module ******** *******************\
*                                                                           *
* Module: FB.H                                                              *
*       Frambuffer routines for allocation and deallocation of off-screen   *
* memory.                                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    10/29/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//
// Amount of instance space to set aside for a BIOS image
//
#define BIOS_IMAGE_PAD  0x10000      // 64k

//---------------------------------------------------------------------------
//
//  Function prototypes for Frambuffer.
//
//---------------------------------------------------------------------------

RM_STATUS initFb(PHWINFO);
RM_STATUS fbInitializeInstMemBitMap(PHWINFO);
RM_STATUS fbAllocInstMem(PHWINFO, U032 *, U032);
RM_STATUS fbFreeInstMem(PHWINFO, U032, U032);
RM_STATUS fbAllocInstMemAlign(PHWINFO, U032 *, U032, U032);
RM_STATUS fbFreeInstMemAlign(U032, U032, U032);
V032      fbService(PHWINFO);

RM_STATUS fbUpdateStartAddress(PHWINFO, U032);
RM_STATUS fbGetScanline(U032 *);
RM_STATUS fbCheckConfig(PHWINFO);

#endif // _FB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\mp.h ===
#ifndef _MP_H_
#define _MP_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
//
/****************************** MediaPort Control ***************************\
*                                                                           *
* Module: MP.H                                                              *
*       Mediaport Includes.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Structures.
//
//---------------------------------------------------------------------------

//
// MediaPort context tree structure
//
typedef struct _def_mediaport_context
{ 
    U032                     Hwregs[50];
    PVIDEODECODEROBJECT      CurrentDecoder;
    PVIDEODECOMPRESSOROBJECT CurrentDecompressor;
} MEDIAPORTCONTEXT, * PMEDIAPORTCONTEXT;

//---------------------------------------------------------------------------
//
//  Macros.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------
RM_STATUS mpCreateObj(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS mpDestroyObj(VOID*, POBJECT);
RM_STATUS initMp(PHWINFO);
V032      mpService(PHWINFO);
RM_STATUS stateMp(PHWINFO, U032);

#endif // _MP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\dma.h ===
#ifndef _DMA_H_
#define _DMA_H_
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* DMA Manager *****************************\
*                                                                           *
* Module: DMA.H                                                             *
*       DMA object/engine management.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//
// Include graphics object defines.
//
#ifndef _GR_H_
#include <gr.h>
#endif // _GR_H_

//---------------------------------------------------------------------------
//
//  Memory page defines.
//
//  These correspond to the granularity understood by the hardware
//  for address mapping; the system page size can be larger.
// 
//---------------------------------------------------------------------------

#define RM_PAGE_SIZE    4096
#define RM_PAGE_MASK    0x0FFF
#define RM_PAGE_SHIFT   12

#define PTE_CACHE_SIZE  64

//---------------------------------------------------------------------------
//
//  DMA object states.
//
//---------------------------------------------------------------------------

#define DMA_SET_DESC_0  0x00000001
#define DMA_SET_DESC_1  0x00000002
#define DMA_SET_DESC_2  0x00000004
#define DMA_RELOAD      0x80000000

//---------------------------------------------------------------------------
//
//  Buffer states.
//
//---------------------------------------------------------------------------

#define BUFFER_IDLE     0
#define BUFFER_BUSY     1
#define BUFFER_NOTIFY_PENDING 2

//---------------------------------------------------------------------------
//
//  NV PTE state
//
//---------------------------------------------------------------------------
typedef U032       NV_PTE_STATE;
// Definition of state bit fields
#define PTE_STATE_PRESENT	0x00000001
                                 // Bit which indicates whether or not there
                                 // is a PTE currently allocated.

//---------------------------------------------------------------------------
//
//  DMA class defines.
//
//---------------------------------------------------------------------------

typedef struct _def_dma_user_object DMAUSEROBJECT, *PDMAUSEROBJECT;
/* typedef */ struct _def_dma_user_object
{
    PCOMMONOBJECT  UserObject;
    PDMAUSEROBJECT Next;
};
 
struct _def_dma_object
{
    OBJECT Base;
    U032   State;
    U032   Valid;
    U032   DescSelector;
    VOID*  DescAddr;
    VOID*  DescOffset;
    U032   DescLimit;
    U032   LockCount;
    VOID*  LockHandle;
    DMAHALOBJINFO HalInfo;
    U032   NotifyActionHandle;     // An OS specific handle to be used for
	                               // notification action if this DMA object
								   // is used for notification.

    U032   ClientHandle;           // The global DmaList keeps DMA objects
                                   // across clients, so save the client
                                   // handle to differentiate the same ID
                                   // used between multiple clients.
    struct _def_dma_object *Next;
};

//#define GETDMA_ADDRSPACE(dma)       (dma->HalInfo.AddressSpace)
//#define GETDMAHALINFO(dma,f)        (dma->HalInfo.f)

// _def_client_dma_info is a subset of the _def_dma_object structure.
// A list of this structure is used to iterate over all the context DMAs
// allocated in this client.
typedef struct _def_client_dma_info* PCLI_DMA_INFO;
typedef struct _def_client_dma_info
{
	U032   				Handle;
	U032				Client;
	U032				Class;
	U032				Flags;
	U032				Access;
	U032				Physicality;
	U032				Locked;
	U032				Coherency;
    //OBJECT 			Base;
    //U032   			State;
    U032   				Valid;
    //U032   			Instance;
    //U032   			UseCount;
    //U032   			XferCount;
    //PDMAUSEROBJECT 	Users;
    U032   				DescSelector;	// selector for hobbled OSs (always 0 for NT)
    VOID*   			DescOffset;		// buffer address from the client (flat address for NT)
    U032   				DescLimit;		// buffer length - 1
    VOID*  				DescAddr;		// actual DMA buffer address
    VOID*  				BufferBase;
    U032   				BufferSize;
    //U032   				LockCount;
    VOID*  				LockHandle;
    //NV_PTE_STATE   	PteState;
    U032   				PteCount;
    //U032   				PteOffset;
    U032   				PteAdjust;		// offset into the current DMA page
    U032   				PteLimit;		// buffer size rounded to DMA page
    U032*				PteArray;
	//U032*				CurPte;
    //U032   			PteCache[PTE_CACHE_SIZE];
    //U032   			NotifyActionHandle;
	NV_ADDRESS_SPACE	AddressSpace;
    struct _def_client_dma_info* Next;
    struct _def_client_dma_info* Prev;

} CLI_DMA_INFO;

//---------------------------------------------------------------------------
//
//  DMA instance structure.
//
//---------------------------------------------------------------------------

typedef struct _def_dma_instance
{
   U016 Adjust;
   U016 Present;
   U032 Limit;
   U032 AddressPresentAccess[1];
} DMAINSTANCE, *PDMAINSTANCE;

//---------------------------------------------------------------------------
//
//  Notification buffer structure.
//
//---------------------------------------------------------------------------

typedef struct _def_notification_buffer
{
    U032 TimeLo;
    U032 TimeHi;
    V032 OtherInfo32;
    V016 OtherInfo16;
    V016 Status;
} NOTIFICATION, *PNOTIFICATION;


//---------------------------------------------------------------------------
//
//  Event Notification structure.
//
//---------------------------------------------------------------------------

struct _def_event_notification
{
	U032                Handle;       // This handle is not currently used
    U032                NotifyIndex;
    U032                NotifyType;
    U064                Data;
    PEVENTNOTIFICATION  Next;   
};

//---------------------------------------------------------------------------
//
//  Dual buffer structure and object.
//
//---------------------------------------------------------------------------

//
// Buffer structure.
//
typedef struct _def_buffer
{
    PDMAOBJECT         Xlate;
    PDMAOBJECT         NotifyXlate;
    PDMAOBJECT         PosXlate;
	U032               NotifyMethod;      // The method to be used on notification
	                                      // of completion of this buffer.
    U032               NotifyAction;
    U032               NotifyCount;
    U032               NotifyCurrentCount;
    U032               Start;
    U032               Length;
    U032               State;
    U032               Pitch;
    U032               Width;
} BUFFER, *PBUFFER;
typedef struct _def_buffer_object BUFFEROBJECT, *PBUFFEROBJECT;
//
// Buffer specific routine to change sample rate.
//
typedef RM_STATUS (*SAMPLEPROC)(PBUFFEROBJECT);
//
// Time sampled information.
//
typedef struct _def_sample
{
    U032       NumChannels;
    U032       Format;
    U032       Size;
    U032       Rate;
    U032       RateAdjust;
    SAMPLEPROC RateUpdate;
} SAMPLEINFO, *PSAMPLEINFO;
//
// Buffer specific routine to start and complete transferring buffer data.
//
typedef RM_STATUS (*BUFFERSTARTPROC)(PHWINFO, PBUFFEROBJECT, U032);
typedef RM_STATUS (*BUFFERPOSPROC)(PHWINFO, PBUFFEROBJECT, U032, U032 *);
typedef RM_STATUS (*BUFFERENDPROC)(PHWINFO, PBUFFEROBJECT, U032, V032, RM_STATUS);
//
// Generic buffer object.
//
struct _def_buffer_object
{
    OBJECT          Base;
    U032            Valid;
    SAMPLEINFO      Sample;
    BUFFERSTARTPROC BufferXfer;
    BUFFERPOSPROC   BufferPos;
    BUFFERENDPROC   BufferComplete;
    BUFFER          Buffer[2];
};

// Definitions of generic buffer object substructures
#define BBase           BufferObj.Base
#define BValid          BufferObj.Valid
#define BSample         BufferObj.Sample
#define BBufferXfer     BufferObj.BufferXfer
#define BBufferPos      BufferObj.BufferPos
#define BBufferComplete BufferObj.BufferComplete
#define BBuffer         BufferObj.Buffer

// Memory to memory object definitions
// The memory to memory object is the same as the buffer object
typedef struct _def_buffer_object MEMTOMEMOBJECT, *PMEMTOMEMOBJECT;

// Buffer 0 in the memory to memory object is used for the from
// memory description.
#define MEM_TO_MEM_IN_BUFFER	0
// Buffer 1 in the memory to memory object is used for the to
// memory description.
#define MEM_TO_MEM_OUT_BUFFER	1

//---------------------------------------------------------------------------
//
//  NULL DMA Descriptor.
//
//---------------------------------------------------------------------------

extern U032 dmaNullInstance;

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------
RM_STATUS dmaCreateObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
RM_STATUS dmaDestroyObj(PHWINFO, POBJECT);
RM_STATUS dmaCreate(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS dmaDelete(VOID*, POBJECT);
RM_STATUS dmaContextInstanceToObject(PHWINFO, U032, U032, PDMAOBJECT *);
RM_STATUS dmaValidateObjectName(PHWINFO, U032, V032, PDMAOBJECT *);
RM_STATUS dmaFindContext(PHWINFO, U032, U032, PDMAOBJECT *);
RM_STATUS dmaValidateXlate(PDMAOBJECT, U032, U032);
RM_STATUS dmaGetMappedAddress(PHWINFO, PDMAOBJECT, U032, U032, VOID **);
RM_STATUS dmaAllocInstance(PHWINFO, PDMAOBJECT);
RM_STATUS dmaFreeInstance(PHWINFO, PDMAOBJECT);
RM_STATUS dmaAttach(PDMAOBJECT);
RM_STATUS dmaDetach(PDMAOBJECT);
RM_STATUS dmaBeginXfer(PDMAOBJECT, PCOMMONOBJECT);
RM_STATUS dmaEndXfer(PDMAOBJECT, PCOMMONOBJECT);
RM_STATUS dmaAllocate(PHWINFO, PDMAOBJECT);
RM_STATUS dmaDeallocate(PHWINFO, PDMAOBJECT);
RM_STATUS dmaSetBufferCtxDma(PHWINFO, PBUFFEROBJECT, PBUFFER, U032, V032);
RM_STATUS dmaSetBufferStart(PBUFFEROBJECT, PBUFFER, U032, V032);
RM_STATUS dmaSetBufferLength(PBUFFEROBJECT, PBUFFER, U032, V032);
RM_STATUS dmaSetBufferPitch(PBUFFEROBJECT, PBUFFER, U032, U032);
RM_STATUS notifySetBufferNotifyCtxDma(PHWINFO, PBUFFEROBJECT, PBUFFER, U032, V032);
RM_STATUS notifySetBufferNotify(PHWINFO, PBUFFEROBJECT, U032, U032, V032);
RM_STATUS notifyDefaultError(PHWINFO, POBJECT, U032, V032, U032, RM_STATUS);
RM_STATUS notifyMethodComplete(PHWINFO, POBJECT, U032, V032, RM_STATUS);
RM_STATUS notifyBufferHWComplete(PHWINFO, POBJECT, U032, V032, U032, RM_STATUS);
RM_STATUS notifyBufferComplete(PHWINFO, PBUFFEROBJECT, U032, V032, RM_STATUS);
RM_STATUS notifyFillNotifier(PHWINFO, PDMAOBJECT, V032, V016, RM_STATUS);
RM_STATUS notifyFillNotifierArray(PHWINFO, PDMAOBJECT, V032, V016, RM_STATUS, U032);
V032      dmaService(VOID);

RM_STATUS dmaRegisterToDevice(PHWINFO, PCLI_DMA_INFO, PDMAOBJECT *);
RM_STATUS dmaUnregisterFromDevice(PHWINFO, PDMAOBJECT);
RM_STATUS dmaBindToChannel(PHWINFO, PDMAOBJECT, U032);
RM_STATUS dmaUnbindFromChannel(PHWINFO, PDMAOBJECT, U032);

#endif // _DMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nvarm.h ===
#if !defined _NVARMH_
#define _NVARMH_

// define to make sure nvrm.h does not include all headers
#if !defined RM_HEADERS_MINIMAL
#define RM_HEADERS_MINIMAL
#endif

#include <nvrm.h>

#define MAX_AUDIO_INSTANCE          16

typedef struct _def_hw_audio_common_ *PHWINFO_COMMON_FIELDS;

typedef union _audioRef
{
    struct
    {
        U032    type    : 16;   // device type
        U032    revID   : 8;    // device instance
        U032    client  : 8;    // unique client ID
    } field;
    
    U032 uValue;
} AUDIO_REF, *PAUDIO_REF;


typedef struct _def_hw_audio_common_
{
    // this structure uniquely identifies a piece of hardware
    // successive calls to allocating the devref just increment
    // the instance counter
    
    U032            uDevType;           // type of device
    U008            uRevisionID;        // revision ID of the device
    U008            uInstanceCounter;   // num of clients using the device
    U032            pDeviceBase;        // PCI mem base
    
    union
    {
        // for NT and WDM
        struct
        {
            VOID    *pInterrupt;
            VOID    *pDeviceObject;     // PDO.. not FDO
        } OsNT;
        
        // for Win9X VxD
        struct
        {
            U032    irqNum;
            U032    irqHandle;
        }Os9X;
    }field;
    
    VOID    *pHalContext;
    
} HWINFO_COMMON_FIELDS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\heap.h ===
#ifndef _HEAP_H_
#define _HEAP_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
//
/*********************** Heap manager data structures **********************\
*                                                                           *
* Module: HEAP.H                                                            *
*   Heap manager for allocating memory based on usage and                   *
*   memory configuration.                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    05/19/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

typedef struct
{
    U032 offset;
    U032 size;
    U032 flags;
} MEMBANK, *PMEMBANK;

typedef struct def_block
{
    U032 owner;
    U032 mhandle;
    U032 begin;
    U032 align;
    U032 end;
    union
    {
        U032              type;
        struct def_block *prevFree;
    } u0;
    union
    {
        U032              hwres;
        struct def_block *nextFree;
    } u1;
    struct def_block *prev;
    struct def_block *next;
} MEMBLOCK, *PMEMBLOCK;

typedef struct
{
    U008     *base;
    U032      total;
    U032      free;
    MEMBLOCK *pBlockList;
    MEMBLOCK *pFreeBlockList;
    U032      numBanks;
    U032      memHandle;
    U032      memTypeFlags[11];
    MEMBANK   Bank[1];
} HEAP, *PHEAP;
//
// Handy heap macros.
//
//#define BLOCK_OFFSET(bp)        ((bp)->offset+(bp)->align)
//#define BLOCK_ADDRESS(hp,bp)    ((hp)->base+(bp)->offset+(bp)->align)
//
// Pre-defined no-owner ID - i.e. free.
//
#define FREE_BLOCK              0xFFFFFFFF
//
// Types of memory to allocate.
//
#ifndef BIT
#define BIT(b)                  (1<<(b))
#endif
#define MEM_GROW_UP             0x00000000
#define MEM_GROW_DOWN           0x80000000
#define MEM_GROW_MASK           0x80000000
#define MEM_TYPE_IMAGE          0
#define MEM_TYPE_DEPTH          1
#define MEM_TYPE_TEXTURE        2
#define MEM_TYPE_OVERLAY        3
#define MEM_TYPE_FONT           4
#define MEM_TYPE_CURSOR         5
#define MEM_TYPE_DMA            6
#define MEM_TYPE_INSTANCE       7
#define MEM_TYPE_PRIMARY        8
#define MEM_TYPE_IMAGE_TILED    9
#define MEM_TYPE_DEPTH_COMPR16  10
#define MEM_TYPE_DEPTH_COMPR32  11
#define MEM_TYPE_MAX            11
#define MEM_TYPE_MASK                       0x0000FFFF
#define MEM_TYPE_IGNORE_BANK_PLACEMENT_FLAG 0x00010000
#define MEM_TYPE_FORCE_MEM_GROWS_UP_FLAG    0x00020000
#define MEM_TYPE_FORCE_MEM_GROWS_DOWN_FLAG  0x00040000
#define MEM_FLAG_IMAGE          BIT(MEM_TYPE_IMAGE)
#define MEM_FLAG_DEPTH          BIT(MEM_TYPE_DEPTH)
#define MEM_FLAG_TEXTURE        BIT(MEM_TYPE_TEXTURE)
#define MEM_FLAG_OVERLAY        BIT(MEM_TYPE_OVERLAY)
#define MEM_FLAG_FONT           BIT(MEM_TYPE_FONT)
#define MEM_FLAG_CURSOR         BIT(MEM_TYPE_CURSOR)
#define MEM_FLAG_DMA            BIT(MEM_TYPE_DMA)
#define MEM_FLAG_INSTANCE       BIT(MEM_TYPE_INSTANCE)
#define MEM_FLAG_PRIMARY        BIT(MEM_TYPE_PRIMARY)
#define MEM_FLAG_IMAGE_TILED    BIT(MEM_TYPE_IMAGE_TILED)
#define MEM_FLAG_DEPTH_COMPR16  BIT(MEM_TYPE_DEPTH_COMPR16)
#define MEM_FLAG_DEPTH_COMPR32  BIT(MEM_TYPE_DEPTH_COMPR32)
#define MEM_TYPE_HEAD_MASK      0x80000000
#define MEM_TYPE_HEAD_SHIFT     31

// bits kept in MEMBLOCK->type indicating if/which HW tile range was allocated
#define MEM_TYPE_TILE_RANGE_SHIFT(i) (1 << (24+(i)))
#define MEM_TYPE_TILE_RANGE_MASK     0xFF000000

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS heapCreate(PHWINFO, U008 *, U032, U032, PHEAP *);
RM_STATUS heapDestroy(PHWINFO, PHEAP);
RM_STATUS heapAlloc(PHWINFO, PHEAP, U032, U032 *, U032, U032, U032 *, U032 *);
RM_STATUS heapFbSetAllocParameters(PHWINFO, PFBALLOCINFO);
RM_STATUS blockFree(PHWINFO, PHEAP, PMEMBLOCK);
RM_STATUS heapFree(PHWINFO, PHEAP, U032, U032, U032 *);
RM_STATUS heapPurge(PHWINFO, PHEAP, U032);
RM_STATUS heapInfo(PHEAP, U032 *, U032 *, VOID**, U032 *, U032 *);
RM_STATUS heapInfoFreeBlocks(PHEAP, U032 *, U032 *, U032, U032, U032 *);
RM_STATUS heapCompact(PHEAP);
RM_STATUS heapGetSize(PHEAP, U032 *);
RM_STATUS heapGetFree(PHEAP, U032 *);
RM_STATUS heapGetMaxFree(PHEAP, U032 *, U032 *);
RM_STATUS heapGetBase(PHEAP, U008 **);

#endif // _HEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\i2c.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** I2C includes ********************************\
*                                                                           *
* Module: I2C.H                                                             *
*   This module contains structure and prototype definitions used in the    *
*   I2C interface routines.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _I2C_H_
#define _I2C_H_

#define	NV_I2C_PORT_PRIMARY	    0
#define	NV_I2C_PORT_SECONDARY   1
#define	NV_I2C_PORT_TERTIARY    2

// This is the number of times we try sending out an I2C addresss byte without
// getting an acknowledge back before giving up.
#define I2C_ADDRESS_RETRIES     8

RM_STATUS i2cRead(PHWINFO, U032, U032, U008, U016, U008 *, U016, U008 *);
RM_STATUS i2cWrite(PHWINFO, U032, U032, U008, U016, U008 *, U016, U008 *);
RM_STATUS i2cSend(PHWINFO, U032, U032, U008, U016, U008 *, U016 , U008 *, U032);

RM_STATUS i2cRead_ALT(PHWINFO, U032, U032, U008, U016, U008 *, U016, U008 *);
RM_STATUS i2cWrite_ALT(PHWINFO, U032, U032, U008, U016, U008 *, U016, U008 *);

RM_STATUS i2cRead_ALT2(PHWINFO, U032, U032, U008, U016, U008 *, U016, U008 *);

//
// lower level routines
//
VOID i2cInit(PHWINFO, U032, U032 );
U008 i2cSendByte(PHWINFO, U032, U032, U008);
RM_STATUS i2cReceiveByte(PHWINFO, U032, U032, U008 *, U008);
VOID i2cStart(PHWINFO, U032, U032 );
VOID i2cStop(PHWINFO, U032, U032 );

U008 i2cHardwareInit(PHWINFO, U032, U032);
VOID ResetSCLLine(PHWINFO, U032, U032);
VOID SetSCLLine(PHWINFO, U032, U032);
VOID ResetSDALine(PHWINFO, U032, U032);
VOID SetSDALine(PHWINFO, U032, U032);
VOID ReadSDA(PHWINFO, U032, U032, U008 *);
VOID ReadSCL(PHWINFO, U032, U032, U008 *);
#endif // _I2C_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\gr.h ===
#ifndef _GR_H_
#define _GR_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/**************************** Graphics Manager *****************************\
*                                                                           *
* Module: GR.H                                                              *
*       Graphics engine management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
//
// Include balanced tree defines.
//
#ifndef _BTREE_H_
#include <btree.h>
#endif // _BTREE_H_
#ifndef _VBLANK_H_
#include <vblank.h>
#endif // _VBLANK_H_

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define INVALID_COLOR_FORMAT    0xFFFFFFFF
#define INVALID_MONO_FORMAT     0xFFFFFFFF
#define INVALID_CHID            0xFFFFFFFF
#define INVALID_BUFFER          0xFFFFFFFF
#define BOTH_BUFFERS            3
#define BUFFER(b)               BIT(b)
#define PACK_XY(x,y)            ((((y)&0xFFFF)<<16)|((x)&0xFFFF))
#define PACK_WH(x,y)            ((((h)&0xFFFF)<<16)|((w)&0xFFFF))
#define MAX_GRPATCH_FANOUT      56
#define MAX_GRPATCH_INPUT       56
// If we are using a window manager, then we will allow complex canvas shapes
// If we are not, we will just support the CLIP REGIONS allowed in hardware
#ifdef USE_GUI
#define MAX_CLIP_REGIONS        16
#else
#define MAX_CLIP_REGIONS        2
#endif

#define NUM_GRAPHICS_DEVICES    0x1C
#define FIRST_RENDERING_DEVICE  0x07
#define GR_RAM_SIZE             32
#define ZFOG_RAM_SIZE           16

#define GR_DEVICE_INDEX(d)      ((((d)>>16)&0x7F)-0x41)
#define GR_IDLE()               while ((volatile U032)REG_RD32(NV_PGRAPH_STATUS)) {         \
                                    V032 pmc;                                               \
                                    pmc = REG_RD32(NV_PMC_INTR_0);                          \
                                    if (pmc & DRF_DEF(_PMC, _INTR_0, _PGRAPH, _PENDING)) {  \
                                        grService(pDev);                                    \
                                    }                                                       \
                                    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)) {   \
                                        VBlank(pDev);                                       \
                                    }                                                       \
                                }
#define GR_DONE()				while ((volatile U032)REG_RD32(NV_PGRAPH_STATUS))   \
                                        ;
								   
#define GR_SAVE_STATE(misc)                                                         \
{                                                                                   \
        misc = REG_RD32(NV_PGRAPH_FIFO);                                            \
        REG_WR32(NV_PGRAPH_FIFO, DRF_DEF(_PGRAPH, _FIFO, _ACCESS, _DISABLED));      \
}

#define GR_RESTORE_STATE(misc)                                                      \
{                                                                                   \
        REG_WR32(NV_PGRAPH_FIFO, misc);                                             \
}

#define GR_ASSERT_CHID(chid)    (!(REG_RD32(NV_PGRAPH_INTR_0) & DRF_DEF(_PGRAPH, _INTR_0, _CONTEXT_SWITCH, _PENDING)) && (REG_RD_DRF(_PGRAPH, _CTX_USER, _CHID) == (chid)))

#define NV3_GR_OPERATIONS   3
#define NV4_GR_OPERATIONS   6

#define NV_SRCCOPY          NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY     
#define NV_SRCCOPY_AND      NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND
#define NV_ROP_AND          NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_ROP_AND    
#define NV_BLEND_AND        NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_AND  
#define NV_BLEND_PREMULT    NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_PRE  
#define NV_SRCCOPY_PREMULT  NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_PRE

//---------------------------------------------------------------------------
//
// Miscellaneous structure definitions.
//
//---------------------------------------------------------------------------

#define REGION_UPDATE_CANVAS    0x00000001
#define REGION_UPDATE_CLIP      0x00000002
#define REGION_UPDATE_DISABLE   0x00000003
typedef struct _def_canvas_region
{
    U032 hwnd;
    S032 CanvasLeft;
    S032 CanvasRight;
    S032 CanvasTop;
    S032 CanvasBottom;
    U032 ClipCount;
    S032 ClipLeft[MAX_CLIP_REGIONS];
    S032 ClipRight[MAX_CLIP_REGIONS];
    S032 ClipTop[MAX_CLIP_REGIONS];
    S032 ClipBottom[MAX_CLIP_REGIONS];
    U032 ClipInOut[MAX_CLIP_REGIONS];
    U032 UpdateFlags;
} CANVASREGION, * PCANVASREGION;

//---------------------------------------------------------------------------
//
//  Graphics class defines.
//
//---------------------------------------------------------------------------

typedef struct _def_ordinal_object   ORDINALOBJECT,  *PORDINALOBJECT;
typedef struct _def_video_patchcord  VIDEOPATCHCORD, *PVIDEOPATCHCORD;
typedef struct _def_image_patchcord  IMAGEPATCHCORD, *PIMAGEPATCHCORD;
typedef struct _def_beta_patchcord   BETAPATCHCORD,  *PBETAPATCHCORD;
typedef struct _def_rop_patchcord    ROPPATCHCORD,   *PROPPATCHCORD;
typedef struct _def_image_in_mem_object IMAGEINMEMOBJECT, *PIMAGEINMEMOBJECT;
typedef struct _def_canvas
{
    NODE Node;
    U032 CanvasID;
    U032 UsageCount;
    U032 BufferToggle;
    U032 xyMin;
    U032 xyMax;
    U032 ClipCount;
    U032 ClipMisc;
    U032 xyClipMin[MAX_CLIP_REGIONS];
    U032 xyClipMax[MAX_CLIP_REGIONS];
    U032 InOutClip[MAX_CLIP_REGIONS];
    U032 CplxClipCount;
    U032 xyCplxClipMin[2];
    U032 xyCplxClipMax[2];
} CANVAS, *PCANVAS;

// Common fields between most graphics object structures.
typedef struct _def_common_object COMMONOBJECT, *PCOMMONOBJECT;
struct _def_common_object
{
    OBJECT      Base;
    U032        Valid;
    U032        NotifyPending;
    U032        Instance;
    PDMAOBJECT  NotifyObject;
    PDMAOBJECT  Dma0Object;
    PDMAOBJECT  Dma1Object;
    PCOMMONOBJECT Next;
};

// Macros to get to the common fields
#define CBase            Common.Base
#define CValid           Common.Valid
#define CNotifyPending   Common.NotifyPending
#define CInstance        Common.Instance
#define CNext            Common.Next
typedef struct _def_video_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} VIDEOOBJECT, *PVIDEOOBJECT;
struct _def_video_patchcord
{
    COMMONOBJECT    Common;
    //OBJECT       Base;
    U032         FanOut;
    PVIDEOOBJECT Source;
    PVIDEOOBJECT Destination[MAX_GRPATCH_FANOUT];
};
typedef struct _def_video_switch_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[2];
    VBLANKNOTIFY    VBlankNotify[2];
    PORDINALOBJECT  Ordinal;
    PCANVAS         Canvas;
} VIDEOSWITCHOBJECT, *PVIDEOSWITCHOBJECT;
struct _def_ordinal_object
{
    OBJECT             Base;
    U032               Value;
    PVIDEOSWITCHOBJECT Switch[MAX_GRPATCH_FANOUT];
    U032               FanOut;
};
typedef struct _def_video_sink
{
    COMMONOBJECT    Common;
    //OBJECT          Base;
    PDMAOBJECT      NameXlate;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} VIDEOSINKOBJECT, *PVIDEOSINKOBJECT;
typedef struct _def_video_colormap_object
{
    COMMONOBJECT    Common;
    //OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput;
    U032            ColorFormat;
    PDMAOBJECT      Xlate;
    U032            Start;
    U032            Length;
    U032            DirtyStart;
    U032            DirtyLength;
    U032            ColorMap[256];
} VIDEOCOLORMAPOBJECT, *PVIDEOCOLORMAPOBJECT;
typedef struct _def_video_scaler_object
{
    COMMONOBJECT            Common;
    VIDEOSCALERHALOBJECT    HalObject;
} VIDEOSCALEROBJECT,     *PVIDEOSCALEROBJECT;
typedef struct _def_video_colorkey_object
{
    COMMONOBJECT            Common;
    VIDEOCOLORKEYHALOBJECT  HalObject;
#if 0
    U032                ColorFormat;
    U032                Color;      
    U032                xClipMin;   
    U032                xClipMax;   
    U032                yClipMin;   
    U032                yClipMax;   
#endif
} VIDEOCOLORKEYOBJECT,   *PVIDEOCOLORKEYOBJECT;
//
// Pixel source/destination objects.
//
typedef struct _def_render_common      RENDERCOMMON,     *PRENDERCOMMON;
typedef struct _def_render_common_object RENDERCOMMONOBJECT, *PRENDERCOMMONOBJECT;

//
// Graphics patch context representation
//
// This is a "snapshot" of the graphics context as it
// relates to a given patch.
//
typedef struct _def_patch_context
{
    U032                 VideoConfig;
    PVIDEOCOLORMAPOBJECT ColorMap0;
    PVIDEOCOLORMAPOBJECT ColorMap1;
    PVIDEOSCALEROBJECT   VideoScaler;		
    PVIDEOCOLORKEYOBJECT VideoColorKey;
    PCOMMONOBJECT        ColorKey;
    PCOMMONOBJECT        Pattern;
    PCOMMONOBJECT        Clip;
    PCOMMONOBJECT        Rop;
    PCOMMONOBJECT        Beta1;
    PCOMMONOBJECT        Beta4;
    PCOMMONOBJECT        Surface;
    PCOMMONOBJECT        SurfaceSource;
    PCOMMONOBJECT        SurfaceZeta;
    U032                 Operation;
} PATCHCONTEXT, *PPATCHCONTEXT;

// Common field within the various render objects
struct _def_render_common
{
    PATCHCONTEXT    PatchContext;
    PDMAOBJECT      Xlate;
};

// Macros to get to the common fields
//#define RCPatch            RenderCommon.Patch
#define RCPatchContext     RenderCommon.PatchContext
#define RCXlate            RenderCommon.Xlate

// Common structure to be used as template structure for various render objects
struct _def_render_common_object
{
	COMMONOBJECT    Common;
	RENDERCOMMON    RenderCommon;
};

/* typedef */ struct _def_image_in_mem_object
{
	COMMONOBJECT    Common;
	RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
    PDMAOBJECT      NameXlate;
    PCANVAS         Canvas;
    U032            Offset;
    U032            Pitch;
    U032            Buffer;
};

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------
RM_STATUS grCreateObj(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS grDestroyObj(VOID*, POBJECT);
VOID      grInitCommon(PCOMMONOBJECT, U032);
VOID      grInitRenderCommon(PRENDERCOMMON);
RM_STATUS grNotifyComplete(VOID);
RM_STATUS grValidateVideoPatchcord(PVIDEOPATCHCORD, PPATCHCONTEXT, U032);
RM_STATUS grInvalidateVideoPatchcord(PVIDEOPATCHCORD);
RM_STATUS grUnloadCurrentChannelContext(PHWINFO);
RM_STATUS grLoadChannelContext(PHWINFO, U032);
RM_STATUS grContextInstanceToObject(PHWINFO, U032, U032, POBJECT *);
RM_STATUS grWaitVBlank(PHWINFO, PVBLANKNOTIFY, U032);
RM_STATUS grCancelVBlank(PHWINFO, PVBLANKNOTIFY);
RM_STATUS grVBlank(PHWINFO);
V032      grService(PHWINFO);
V032      grDmaService(VOID);
RM_STATUS grVideoSwitchComplete(PHWINFO, POBJECT, U032, V032, RM_STATUS);
RM_STATUS grUpdateObjectInstance(PHWINFO, PCOMMONOBJECT);
RM_STATUS grDeleteObjectInstance(PHWINFO, PCOMMONOBJECT);
BOOL      grIsSetContextInHardware(PHWINFO);
#endif // _GR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\modular.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Modular includes *****************************\
*                                                                           *
* Module: MODULAR.H                                                         *
*   This module contains structure and prototype definitions used in the    *
*   modular class architechure.                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _MODULAR_H_
#define _MODULAR_H_

#include <gr.h>

//
// Define modular class structures.
//
typedef struct _def_video_from_mem_object    VIDEOFROMMEMOBJECT,    *PVIDEOFROMMEMOBJECT;
typedef struct _def_video_decoder_object     VIDEODECODEROBJECT,    *PVIDEODECODEROBJECT;
typedef struct _def_video_decompressor_object VIDEODECOMPRESSOROBJECT, *PVIDEODECOMPRESSOROBJECT;
typedef struct _def_parallel_bus_object      PARALLELBUSOBJECT,     *PPARALLELBUSOBJECT;
typedef struct _def_monitor_bus_object       MONITORBUSOBJECT,      *PMONITORBUSOBJECT;
typedef struct _def_serial_bus_object        SERIALBUSOBJECT,       *PSERIALBUSOBJECT;
typedef struct _def_video_overlay_object     VIDEO_OVERLAY_OBJECT,  *PVIDEO_OVERLAY_OBJECT;

// Define function pointers
typedef V032     (*POVERLAYSERVICEPROC)(PHWINFO, POBJECT);

//
// CLASS 63 NV_VIDEO_FROM_MEMORY
//
struct _def_video_from_mem_object
{
    BUFFEROBJECT            BufferObj;      // ALWAYS keep this first!!!!
    COMMONOBJECT            Common;
    //
    // State in this structure is shared between the HAL and RM.
    //
    VIDEOFROMMEMHALOBJECT   HalObject;
    VBLANKNOTIFY            VBlankNotify[2];
    U032                    BufferToggle;
    U032                    InitState;
};

//
// VIDEO_LUT_CURSOR_DAC class object.
//
typedef struct _def_video_lut_cursor_dac_object
{
    COMMONOBJECT                     Common;

    //
    // This state is shared between the RM and the HAL.
    //
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT  HalObject;

    //
    // This state is (currently) RM only.
    //
    struct {
        PDMAOBJECT  SemaphoreCtxDma;
        U032        Offset;
        U032        *ReleaseAddr;
        U032        ReleaseValue;
        U032        ReleaseTrigger;
        VBLANKCALLBACK ReleaseCallback;
    } Semaphore;

    struct {
        PDMAOBJECT   ImageCtxDma;
        U032         Offset;                       // Byte offset (from ImageContextDma) of top left pixel
        U032         Pitch;                        
        U032         NotifyAction;                   
        U032         NotifyTrigger;
        S016         DeltaX;
        S016         DeltaY;
        U032         MultiSync;
        VBLANKCALLBACK ImageCallback;
    }                                Image[2];
    struct {
        PDMAOBJECT     LUTCtxDma;
        U032           Offset;                       // Byte offset (from LUTContextDma)
        U032           NotifyAction;                   
        U032           NotifyTrigger;
        VBLANKCALLBACK LUTCallback;
    }                                LUT[2];
    struct {
        PDMAOBJECT     CursorCtxDma;
        U032           Offset;                       // Byte offset (from CursorContextDma) of top left pixel
        U032           Width;
        U032           Height;
        U032           ColorFormat;
        U032           NotifyAction;                   
        U032           NotifyTrigger;
        VBLANKCALLBACK CursorImageCallback;
    }                                CursorImage[2];
    U032                             CursorPoint;     // y_x
    U032                             ScanRegion;      // U015_U016 stop_start 
    U032                             Polarity;        // polarity bit (blit in/out of range)
    struct {
#if 0
        U032       VisibleImageWidth;    
        U032       VisibleImageHeight;   
        U032       HorizontalBlankStart;
        U032       HorizontalBlankWidth;
        U032       HorizontalSyncStart;
        U032       HorizontalSyncWidth;
        U032       VerticalBlankStart; 
        U032       VerticalBlankHeight; 
        U032       VerticalSyncStart; 
        U032       VerticalSyncHeight; 
        U032       TotalWidth; 
        U032       TotalHeight;     
        U032       PixelClock;
        U032       ColorFormat;                  
        U032       PixelDepth;
        struct {
            unsigned int DoubleScanMode         : 1;
            unsigned int InterlacedMode         : 1;
            unsigned int HorizontalSyncPolarity : 1;
            unsigned int VerticalSyncPolarity   : 1;
            unsigned int unusedBits1            : 12;
            unsigned int unusedBits2            : 16;
        }          Format;
#endif
        U032       NotifyAction;                   
        U032       NotifyTrigger;
    }                                Dac[2];
    U032    DisplayType;                                // may be CRT, TV, DFP
    U032    TVStandard;                                 // variations of NTSC and PAL
    U032    RefreshRate;
} VIDEO_LUT_CURSOR_DAC_OBJECT, *PVIDEO_LUT_CURSOR_DAC_OBJECT;

//
// CLASS 047 VIDEO_OVERLAY
//
/* typedef */ struct _def_video_overlay_object
{
    COMMONOBJECT                    Common;
    //
    // State in this structure is shared between the HAL and RM.
    //
    U032                            InitState;
    VIDEO_OVERLAY_HAL_OBJECT        HalObject;
    //
    // This per-buffer state is RM only.
    //
    struct {
        PDMAOBJECT                  OverlayCtxDma;
        U032                        NotifyAction;                   
        VBLANKCALLBACK              OverlayCallback;
    } Overlay[2];
};

//
// CLASS 04D NV_EXTERNAL_VIDEO_DECODER
//
struct _def_video_decoder_object
{
    COMMONOBJECT    Common;
    VIDEODECODERHALOBJECT   HalObject;
    PDMAOBJECT      ContextDmaImage[2];
    PDMAOBJECT      ContextDmaVbi[2];
    U032            LastEventProcessed;
    U032            LastVbiBufferProcessed;
    U032            LastImageBufferProcessed;
};

//
// CLASS 04E NV_EXTERNAL_VIDEO_DECOMPRESSOR
//
struct _def_video_decompressor_object
{
    COMMONOBJECT    Common;
    VIDEODECOMPRESSORHALOBJECT  HalObject;
    PDMAOBJECT      ContextDmaData[2];
    PDMAOBJECT      ContextDmaImage[2];
};

//
// CLASS 04F NV_EXTERNAL_PARALLEL_BUS
//
struct _def_parallel_bus_object
{
    COMMONOBJECT    Common;
    PARALLELBUSHALOBJECT    HalObject;
    U032            BusType;
    U032            InterruptNotifyPending;
};
//
// CLASS 050 NV_EXTERNAL_MONITOR_BUS
//
struct _def_monitor_bus_object
{
    COMMONOBJECT    Common;
    U032            BusType;
    struct {
        U016        DataSize;
        U016        AddressSize;
        U032        Address;
        U032        Data;
    } Write;
    struct {
        U016        DataSize;
        U016        AddressSize;
        U032        Address;
        U032        Notify;
    } Read;
    U032            InterruptNotifyPending;
};

//
// CLASS 051 NV_EXTERNAL_SERIAL_BUS
//
struct _def_serial_bus_object
{
    COMMONOBJECT    Common;
    U032            BusType;
    struct {
        U016        DataSize;
        U016        AddressSize;
        U032        Address;
        U032        Data;
    } Write;
    struct {
        U016        DataSize;
        U016        AddressSize;
        U032        Address;
        U032        Notify;
    } Read;
    U032            DefaultPortID;
    U032            InterruptNotifyPending;
};

//
// NVDE Object
//
#define NVDE_MAX_EVENTS                             32

#define NVDE_FLAG_PGRAPH_FIFO_ACCESS_ENABLED        4
#define NVDE_FLAG_CACHES_REASSIGN_ENABLED           2
#define NVDE_FLAG_CACHE1_PULL0_ACCESS_ENABLED       1

typedef struct _dev_nvde_event
{
    U032 code;
    U032 flags;
    U032 param[6];
} NVDEEVENT, *PNVDEEVENT;

typedef struct _def_nvde_object
{
    COMMONOBJECT Common;    // see gr.h
    U064 EventHandle;       // passed in as part of the alloc routine
    U032 EventClass;

    U032      EventBufferCount;
    NVDEEVENT EventBuffer[NVDE_MAX_EVENTS];
} NVDEOBJECT, *PNVDEOBJECT;

RM_STATUS NvdeAlloc(U032, VOID *);
RM_STATUS NvdeFree(U032, U032);
V032      NvdeAppendEventForDebugger (PNVDEOBJECT,U032,U032,U032,U032,U032,U032,U032,U032);

//
// Define modular class function prototypes.
//

//
// NV04_VIDEO_LUT_CURSOR_DAC
//
RM_STATUS class046SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046StopImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046StopLUT(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046StopCursorImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046StopDAC(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetLUTCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetCursorCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetPanOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046GetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetLUTValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetCursorImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetCursorPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class046SetDACValues(PHWINFO, POBJECT, PMETHOD, U032, U032);

//
// NV04_VIDEO_OVERLAY
//
RM_STATUS class047SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047StopOverlay(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047SetOverlayCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047GetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047SetOverlayValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047SetOverlayPointOutNow(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class047StopOverlayNow(PHWINFO, POBJECT, U032, V032, RM_STATUS);

//
// NV05_VIDEO_LUT_CURSOR_DAC
//
RM_STATUS class049SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049StopImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049StopLUT(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049StopCursorImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049StopDAC(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetLUTCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetCursorCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetPanOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049GetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetLUTValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetCursorImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetCursorPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class049SetDACValues(PHWINFO, POBJECT, PMETHOD, U032, U032);

//
// NV_VIDEO_FROM_MEMORY
//
RM_STATUS class63SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63StopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63SetVideoOutput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63SetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63ImageScan(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63GetOffsetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class63VBlank(PHWINFO);

//
// NV_VIDEO_SCALER
//
RM_STATUS class64SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetVideoOutput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetVideoInput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetDeltaDuDx(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetDeltaDvDy(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64SetPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class64LoadContext(PHWINFO, PVIDEOSCALEROBJECT);

//
// NV_VIDEO_COLOR_KEY
//
RM_STATUS class65SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetVideoOutput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetVideoInput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetColorFormat(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65SetSize(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class65LoadContext(PHWINFO, PVIDEOCOLORKEYOBJECT);
//
// NV_VIDEO_CAPTURE_TO_MEMORY
//
RM_STATUS class66SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66StopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetVideoInput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetImageNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66ImageCapture(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetVbiCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66SetVbiNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class66VbiCapture(PHWINFO, POBJECT, PMETHOD, U032, U032);

//
// NV10_VIDEO_LUT_CURSOR_DAC
//
RM_STATUS class067SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067StopImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067StopLUT(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067StopCursorImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067StopDAC(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetLUTCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetCursorCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetPanOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067GetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetLUTValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetCursorImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetCursorPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class067SetDACValues(PHWINFO, POBJECT, PMETHOD, U032, U032);

//
// NV15_VIDEO_LUT_CURSOR_DAC
//
RM_STATUS class07CSetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CStopImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CStopLUT(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CStopCursorImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CStopDAC(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetImageCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetLUTCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetCursorCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetSemaphoreCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetSemaphoreOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetSemaphoreRelease(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetPanOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetOffsetRange(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CGetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetLUTValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetCursorImageValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetCursorPoint(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07CSetDACValues(PHWINFO, POBJECT, PMETHOD, U032, U032);

//
// NV_VIDEO_SOURCE
//
RM_STATUS class74SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class74SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class74SetVideoOutput(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS osValidateVideoSource( char *, U032 , U032 );


//
// NV_CONTEXT_DMA_IN_MEMORY
//
RM_STATUS class61SetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class61SetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class61SetDmaSpecifier(PHWINFO, POBJECT, PMETHOD, U032, U032);


//////////////////////////////////////////////////////////////////////////////
// 
// CLASS012 - NV1_BETA_SOLID
//
// Method aliases
#define class012Notify              grHWMethod
#define class012SetContextDmaNotifies grHWMethod
#define class012SetBeta             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS017 - NV1_IMAGE_SOLID
//
// Method aliases
#define class017Notify              grHWMethod
#define class017SetContextDmaNotifies grHWMethod
#define class017SetColorFormat      grHWMethod
#define class017SetColor            grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS018 - NV1_IMAGE_PATTERN
//
// Method aliases
#define class018Notify              grHWMethod
#define class018SetContextDmaNotifies grHWMethod
#define class018SetColorFormat      grHWMethod
#define class018SetMonochromeFormat grHWMethod
#define class018SetPatternShape     grHWMethod
#define class018SetColor0           grHWMethod
#define class018SetColor1           grHWMethod
#define class018SetPattern          grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS019 - NV1_IMAGE_BLACK_RECTANGLE
//
// Method aliases
#define class019Notify              grHWMethod
#define class019SetContextDmaNotifies grHWMethod
#define class019SetRectangle        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS01C - NV1_RENDER_SOLID_LIN
//
RM_STATUS class01CSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01CSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01CSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01CSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01CSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01CSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class01CNotify              grHWMethod
#define class01CSetContextDmaNotifies grHWMethod
#define class01CSetColorFormat      grHWMethod
#define class01CColor               grHWMethod
#define class01CLin                 grHWMethod
#define class01CLin32               grHWMethod
#define class01CPolyLin             grHWMethod
#define class01CPolyLin32           grHWMethod
#define class01CColorPolyLin        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS01D - NV1_RENDER_SOLID_TRIANGLE
//
RM_STATUS class01DSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01DSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01DSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01DSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01DSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01DSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class01DNotify              grHWMethod
#define class01DSetContextDmaNotifies grHWMethod
#define class01DSetColorFormat      grHWMethod
#define class01DColor               grHWMethod
#define class01DTriangle            grHWMethod
#define class01DTriangle32          grHWMethod
#define class01DTrimesh             grHWMethod
#define class01DTrimesh32           grHWMethod
#define class01DColorTriangle       grHWMethod
#define class01DColorTrimesh        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS01E - NV1_RENDER_SOLID_RECTANGLE
//
RM_STATUS class01ESetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01ESetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01ESetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01ESetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01ESetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01ESetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class01ENotify              grHWMethod
#define class01ESetContextDmaNotifies grHWMethod
#define class01ESetColorFormat      grHWMethod
#define class01EColor               grHWMethod
#define class01ERectangle           grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS01F - NV1_IMAGE_BLIT
//
RM_STATUS class01FSetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextSurfaceSource(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class01FSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class01FNotify              grHWMethod
#define class01FSetContextDmaNotifies grHWMethod
#define class01FPointIn             grHWMethod
#define class01FPointOut            grHWMethod
#define class01FSize                grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS021 - NV1_IMAGE_FROM_CPU
//
RM_STATUS class021SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class021SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class021Notify              grHWMethod
#define class021SetContextDmaNotifies grHWMethod
#define class021SetColorFormat      grHWMethod
#define class021Point               grHWMethod
#define class021Size                grHWMethod
#define class021SizeIn              grHWMethod
#define class021Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS030 - NV1_NULL
//

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS036 - NV3_STRETCHED_IMAGE_FROM_CPU
//
RM_STATUS class036SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class036SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class036SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class036SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class036SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class036SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class036Notify              grHWMethod
#define class036SetContextDmaNotifies grHWMethod
#define class036SetColorFormat      grHWMethod
#define class036SizeIn              grHWMethod
#define class036DeltaDxDu           grHWMethod
#define class036DeltaDyDv           grHWMethod
#define class036Clip                grHWMethod
#define class036Point12d4           grHWMethod
#define class036Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS037 - NV3_SCALED_IMAGE_FROM_MEM
//
RM_STATUS class037SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class037SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class037SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class037SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class037SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class037Notify              grHWMethod
#define class037SetContextDmaNotifies grHWMethod
#define class037SetContextDmaImage  grHWMethod
#define class037SetColorFormat      grHWMethod
#define class037Clip                grHWMethod
#define class037RectangleOut        grHWMethod
#define class037DeltaDuDx           grHWMethod
#define class037DeltaDvDy           grHWMethod
#define class037ImageIn             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS039 - NV3_MEMORY_TO_MEMORY_FORMAT
//
// Method aliases
#define class039Notify              grHWMethod
#define class039SetContextDmaNotifies grHWMethod
#define class039SetContextDmaBufferIn grHWMethod
#define class039SetContextDmaBufferOut grHWMethod
#define class039BufferTransfer      grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS048 - NV3_DX3_TEXTURED_TRIANGLE
//
RM_STATUS class048SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class048SetContextSurfaceColor(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class048SetContextSurfaceZeta(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class048Notify              grHWMethod
#define class048SetContextDmaNotifies grHWMethod
#define class048SetTextureCtxDma    grHWMethod
#define class048TextureOffset       grHWMethod
#define class048TextureFormat       grHWMethod
#define class048Filter              grHWMethod
#define class048FogColor            grHWMethod
#define class048ControlOut0         grHWMethod
#define class048ControlOut1         grHWMethod
#define class048ControlPoint        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS04B - NV3_GDI_RECTANGLE_TEXT
//
RM_STATUS class04BSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04BSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04BSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04BSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04BSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class04BNotify              grHWMethod
#define class04BSetContextDmaNotifies grHWMethod
#define class04BSetColorFormat      grHWMethod
#define class04BSetMonochromeFormat grHWMethod
#define class04BColor1A             grHWMethod
#define class04BUnclippedRectangle  grHWMethod
#define class04BClipB               grHWMethod
#define class04BColor1B             grHWMethod
#define class04BClippedRectangle    grHWMethod
#define class04BClipC               grHWMethod
#define class04BColor1C             grHWMethod
#define class04BSizeC               grHWMethod
#define class04BPointC              grHWMethod
#define class04BMonochromeColor1C   grHWMethod
#define class04BClipD               grHWMethod
#define class04BColor1D             grHWMethod
#define class04BSizeInD             grHWMethod
#define class04BSizeOutD            grHWMethod
#define class04BPointD              grHWMethod
#define class04BMonochromeColor1D   grHWMethod
#define class04BClipE               grHWMethod
#define class04BColor0E             grHWMethod
#define class04BColor1E             grHWMethod
#define class04BSizeInE             grHWMethod
#define class04BSizeOutE            grHWMethod
#define class04BPointE              grHWMethod
#define class04BMonochromeColor01E  grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS04D - NV3_EXTERNAL_VIDEO_DECODER
//
RM_STATUS class04DNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DStopTransferVbi(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DStopTransferImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetContextDmaNotifies(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetContextDmaImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetContextDmaVbi(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetImageConfig(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetImageStartLine(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DGetImageOffsetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DSetVbi(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04DGetVbiOffsetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);

RM_STATUS class04DService(PHWINFO);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS04E - NV3_EXTERNAL_VIDEO_DECOMPRESSOR
//
RM_STATUS class04ENotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04EStopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ESetContextDmaNotifies(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ESetContextDmaData(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ESetContextDmaImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04EReadData(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04EWriteImage(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04EService(PHWINFO);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS04F - NV3_EXTERNAL_PARALLEL_BUS
//
RM_STATUS class04FNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FStopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FSetContextDmaNotifies(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FWrite(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FRead(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FSetInterruptNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04FService(PHWINFO);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS050 - NV3_EXTERNAL_MONITOR_BUS
//
RM_STATUS class050Create(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
RM_STATUS class050Destroy(PHWINFO, POBJECT);
RM_STATUS class050Notify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class050StopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class050SetContextDmaNotifies(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class050Write(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class050Read(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class050SetInterruptNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS051 - NV3_EXTERNAL_SERIAL_BUS
//
RM_STATUS class051Create(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
RM_STATUS class051Destroy(PHWINFO, POBJECT);
RM_STATUS class051Notify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class051StopTransfer(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class051SetContextDmaNotifies(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class051Write(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class051Read(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class051SetInterruptNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS058 - NV3_CONTEXT_SURFACE_0
//
// Method aliases
#define class058Notify              grHWMethod
#define class058SetContextDmaNotifies grHWMethod
#define class058SetContextDmaImage  grHWMethod
#define class058SetColorFormat      grHWMethod
#define class058SetImagePitch       grHWMethod
#define class058SetImageOffset      grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS059 - NV3_CONTEXT_SURFACE_1
//
// Method aliases
#define class059Notify              grHWMethod
#define class059SetContextDmaNotifies grHWMethod
#define class059SetContextDmaImage  grHWMethod
#define class059SetColorFormat      grHWMethod
#define class059SetImagePitch       grHWMethod
#define class059SetImageOffset      grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05A - NV3_CONTEXT_SURFACE_2
//
// Method aliases
#define class05ANotify              grHWMethod
#define class05ASetContextDmaNotifies grHWMethod
#define class05ASetContextDmaImage  grHWMethod
#define class05ASetColorFormat      grHWMethod
#define class05ASetImagePitch       grHWMethod
#define class05ASetImageOffset      grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05B - NV3_CONTEXT_SURFACE_3
//
// Method aliases
#define class05BNotify              grHWMethod
#define class05BSetContextDmaNotifies grHWMethod
#define class05BSetContextDmaImage  grHWMethod
#define class05BSetColorFormat      grHWMethod
#define class05BSetImagePitch       grHWMethod
#define class05BSetImageOffset      grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS043 - NV3_CONTEXT_ROP
//
// Method aliases
#define class043Notify              grHWMethod
#define class043SetContextDmaNotifies grHWMethod
#define class043SetRop5             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS038 - NV4_DVD_SUBPICTURE
//
// Method aliases
#define class038Notify              grHWMethod
#define class038SetContextDmaNotifies grHWMethod
#define class038SetContextDmaOverlay grHWMethod
#define class038SetContextDmaImageIn grHWMethod
#define class038SetContextDmaImageOut grHWMethod
#define class038ImageOutPoint       grHWMethod
#define class038ImageOutSize        grHWMethod
#define class038ImageOutFormat      grHWMethod
#define class038ImageOutOffset      grHWMethod
#define class038ImageInDeltaDuDx    grHWMethod
#define class038ImageInDeltaDvDy    grHWMethod
#define class038ImageInSize         grHWMethod
#define class038ImageInFormat       grHWMethod
#define class038ImageInOffset       grHWMethod
#define class038ImageInPoint        grHWMethod
#define class038OverlayDeltaDuDx    grHWMethod
#define class038OverlayDeltaDvDy    grHWMethod
#define class038OverlaySize         grHWMethod
#define class038OverlayFormat       grHWMethod
#define class038OverlayOffset       grHWMethod
#define class038OverlayPoint        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS042 - NV4_CONTEXT_SURFACES_2D
//
// Method aliases
#define class042Notify              grHWMethod
#define class042SetContextDmaNotifies grHWMethod
#define class042SetContextDmaSource grHWMethod
#define class042SetContextDmaDestin grHWMethod
#define class042SetColorFormat      grHWMethod
#define class042SetPitch            grHWMethod
#define class042SetOffsetSource     grHWMethod
#define class042SetOffsetDestin     grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS044 - NV4_CONTEXT_PATTERN_METHODS
//
// Method aliases
#define class044Notify              grHWMethod
#define class044SetContextDmaNotifies grHWMethod
#define class044SetColorFormat      grHWMethod
#define class044SetMonochromeFormat grHWMethod
#define class044SetMonochromeShape  grHWMethod
#define class044SetPatternSelect    grHWMethod
#define class044SetMonochromeColor  grHWMethod
#define class044SetMonochromePattern grHWMethod
#define class044SetPatternY8        grHWMethod
#define class044SetPatternR5G6B5    grHWMethod
#define class044SetPatternX8R8G8B8  grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS04A - NV4_GDI_RECTANGLE_TEXT
//
RM_STATUS class04ASetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ASetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ASetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ASetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ASetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class04ASetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class04ANotify              grHWMethod
#define class04ASetContextDmaNotifies grHWMethod
#define class04ASetContextFonts     grHWMethod
#define class04ASetColorFormat      grHWMethod    
#define class04ASetMonochromeFormat grHWMethod
#define class04AColor1A             grHWMethod
#define class04AUnclippedRectangle  grHWMethod
#define class04AClipB               grHWMethod
#define class04AColor1B             grHWMethod
#define class04AClippedRectangle    grHWMethod
#define class04AClipC               grHWMethod
#define class04AColor1C             grHWMethod
#define class04ASizeC               grHWMethod
#define class04APointC              grHWMethod
#define class04AMonochromeColor1C   grHWMethod
#define class04AClipE               grHWMethod
#define class04AColor0E             grHWMethod
#define class04AColor1E             grHWMethod
#define class04ASizeInE             grHWMethod
#define class04ASizeOutE            grHWMethod
#define class04APointE              grHWMethod
#define class04AMonochromeColor01E  grHWMethod
#define class04AFontF               grHWMethod
#define class04AClipF               grHWMethod
#define class04AColor1F             grHWMethod
#define class04ACharacterColor1F    grHWMethod
#define class04AFontG               grHWMethod
#define class04AClipG               grHWMethod
#define class04AColor1G             grHWMethod
#define class04ACharacterColor1G    grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS052 - NV4_CONTEXT_SURFACE_SWIZZLED
//
// Method aliases
#define class052Notify              grHWMethod
#define class052SetContextDmaNotifies grHWMethod
#define class052SetContextDmaImage  grHWMethod
#define class052SetFormat           grHWMethod
#define class052SetOffset           grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS053 - NV4_CONTEXT_SURFACES_ARGB_ZS
//
RM_STATUS class053SetClipHorizontal(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class053SetClipVertical(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class053Notify              grHWMethod
#define class053SetContextDmaNotifies grHWMethod
#define class053SetContextDmaColor  grHWMethod
#define class053SetContextDmaZeta   grHWMethod
#define class053SetFormat           grHWMethod
#define class053SetClipSize         grHWMethod
#define class053SetPitch            grHWMethod
#define class053SetOffsetColor      grHWMethod
#define class053SetOffsetZeta       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS054 - NV4_DX5_TEXTURED_TRIANGLE
//
// Method aliases
#define class054Notify              grHWMethod
#define class054SetContextDmaNotifies grHWMethod
#define class054SetContextDmaA      grHWMethod
#define class054SetContextDmaB      grHWMethod
#define class054SetContextSurface   grHWMethod
#define class054ColorKey            grHWMethod
#define class054Offset              grHWMethod
#define class054Format              grHWMethod
#define class054Filter              grHWMethod
#define class054Blend               grHWMethod
#define class054Control             grHWMethod
#define class054FogColor            grHWMethod
#define class054Tlvertex            grHWMethod
#define class054DrawPrimitive       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS055 - NV4_DX6_MULTI_TEXTURE_TRIANGLE
//
// Method aliases
#define class055Notify              grHWMethod
#define class055SetContextDmaNotifies grHWMethod
#define class055SetContextDmaA      grHWMethod
#define class055SetContextDmaB      grHWMethod
#define class055SetContextSurface   grHWMethod
#define class055Offset              grHWMethod
#define class055Format              grHWMethod
#define class055Filter              grHWMethod
#define class055Combine0Alpha       grHWMethod
#define class055Combine0Color       grHWMethod
#define class055Combine1Alpha       grHWMethod
#define class055Combine1Color       grHWMethod
#define class055CombineFactor       grHWMethod
#define class055Blend               grHWMethod
#define class055Control             grHWMethod
#define class055FogColor            grHWMethod
#define class055Tlmtvertex          grHWMethod
#define class055DrawPrimitive       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS056 - NV10_CELSIUS_PRIMITIVE
//
RM_STATUS class056GetState(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class056Notify              grHWMethod
#define class056SetWarningEnable    grHWMethod
#define class056WaitForIdle         grHWMethod
#define class056PMTrigger           grHWMethod
#define class056SetContextDmaNotifies grHWMethod
#define class056SetContextDmaA      grHWMethod
#define class056SetContextDmaB      grHWMethod
#define class056SetContextDmaVertex grHWMethod
#define class056SetContextDmaState  grHWMethod
#define class056SetContextDmaColor  grHWMethod
#define class056SetContextDmaZeta   grHWMethod
#define class056MethodCatcher       grHWMethod
#define class056InlineArray         grHWMethod
#define class056DebugInit           grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS057 - NV4_CONTEXT_COLOR_KEY
//
// Method aliases
#define class057Notify              grHWMethod
#define class057SetContextDmaNotifies grHWMethod
#define class057SetColorFormat      grHWMethod
#define class057SetColor            grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05C - NV4_RENDER_SOLID_LIN
//
RM_STATUS class05CSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05CSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class05CNotify              grHWMethod
#define class05CSetContextDmaNotifies grHWMethod
#define class05CSetColorFormat      grHWMethod
#define class05CColor               grHWMethod
#define class05CLin                 grHWMethod
#define class05CLin32               grHWMethod
#define class05CPolyLin             grHWMethod
#define class05CPolyLin32           grHWMethod
#define class05CColorPolyLin        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05D - NV4_RENDER_SOLID_TRIANGLE
//
RM_STATUS class05DSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05DSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class05DNotify              grHWMethod
#define class05DSetContextDmaNotifies grHWMethod
#define class05DSetColorFormat      grHWMethod
#define class05DColor               grHWMethod
#define class05DTriangle            grHWMethod
#define class05DTriangle32          grHWMethod
#define class05DTrimesh             grHWMethod
#define class05DTrimesh32           grHWMethod
#define class05DColorTriangle       grHWMethod
#define class05DColorTrimesh        grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05E - NV4_RENDER_SOLID_RECTANGLE
//
RM_STATUS class05ESetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05ESetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class05ENotify              grHWMethod
#define class05ESetContextDmaNotifies grHWMethod
#define class05ESetColorFormat      grHWMethod
#define class05EColor               grHWMethod
#define class05ERectangle           grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS05F - NV4_IMAGE_BLIT
//
RM_STATUS class05FSetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetContextSurfaces2d(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class05FSetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class05FNotify              grHWMethod
#define class05FSetContextDmaNotifies grHWMethod
#define class05FControlPointIn      grHWMethod
#define class05FControlPointOut     grHWMethod
#define class05FSize                grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS060 - NV4_INDEXED_IMAGE_FROM_CPU
//
RM_STATUS class060SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class060SetColorConversion(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class060Notify              grHWMethod
#define class060SetContextDmaNotifies grHWMethod
#define class060SetContextDmaLut    grHWMethod
#define class060SetColorFormat      grHWMethod
#define class060IndexFormat         grHWMethod
#define class060Point               grHWMethod
#define class060SizeOut             grHWMethod
#define class060SizeIn              grHWMethod
#define class060LutOffset           grHWMethod
#define class060Indices             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS061 - NV4_IMAGE_FROM_CPU
//
RM_STATUS class061SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class061SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class061Notify              grHWMethod
#define class061SetContextDmaNotifies grHWMethod
#define class061SetColorFormat      grHWMethod
#define class061Point               grHWMethod
#define class061SizeOut             grHWMethod
#define class061SizeIn              grHWMethod
#define class061Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS062 - NV10_CONTEXT_SURFACES_2D
//
// Method aliases
#define class062Notify              grHWMethod
#define class062SetContextDmaNotifies grHWMethod
#define class062SetContextDmaSource grHWMethod
#define class062SetContextDmaDestin grHWMethod
#define class062SetColorFormat      grHWMethod
#define class062SetPitch            grHWMethod
#define class062SetOffsetSource     grHWMethod
#define class062SetOffsetDestin     grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS063 - NV05_SCALED_IMAGE_FROM_MEMORY
//
RM_STATUS class063SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class063SetColorConversion(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class063Notify              grHWMethod
#define class063SetContextDmaNotifies grHWMethod
#define class063SetContextDmaImage  grHWMethod
#define class063SetColorFormat      grHWMethod
#define class063Clip                grHWMethod
#define class063RectangleOut        grHWMethod
#define class063DeltaDuDx           grHWMethod
#define class063DeltaDvDy           grHWMethod
#define class063ImageIn             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS064 - NV05_INDEXED_IMAGE_FROM_CPU
//
RM_STATUS class064SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class064SetColorConversion(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class064Notify              grHWMethod
#define class064SetContextDmaNotifies grHWMethod
#define class064SetContextDmaLut    grHWMethod
#define class064SetColorFormat      grHWMethod
#define class064IndexFormat         grHWMethod
#define class064Point               grHWMethod
#define class064SizeOut             grHWMethod
#define class064SizeIn              grHWMethod
#define class064LutOffset           grHWMethod
#define class064Indices             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS065 - NV5_IMAGE_FROM_CPU
//
RM_STATUS class065SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextClip(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class065SetColorConversion(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class065Notify              grHWMethod
#define class065SetContextDmaNotifies grHWMethod
#define class065SetColorFormat      grHWMethod
#define class065Point               grHWMethod
#define class065SizeOut             grHWMethod
#define class065SizeIn              grHWMethod
#define class065Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS066 - NV05_STRETCHED_IMAGE_FROM_CPU
//
RM_STATUS class066SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetColorConversion(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class066SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class066Notify              grHWMethod
#define class066SetContextDmaNotifies grHWMethod
#define class066SetColorFormat      grHWMethod
#define class066SizeIn              grHWMethod
#define class066DeltaDxDu           grHWMethod
#define class066DeltaDyDv           grHWMethod
#define class066Clip                grHWMethod
#define class066Point12d4           grHWMethod
#define class066Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS072 - NV4_CONTEXT_BETA
//
// Method aliases
#define class072Notify              grHWMethod
#define class072SetContextDmaNotifies grHWMethod
#define class072SetBetaFactor       grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS076 - NV4_STRETCHED_IMAGE_FROM_CPU
//
RM_STATUS class076SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class076SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class076Notify              grHWMethod
#define class076SetContextDmaNotifies grHWMethod
#define class076SetColorFormat      grHWMethod
#define class076SizeIn              grHWMethod
#define class076DeltaDxDu           grHWMethod
#define class076DeltaDyDv           grHWMethod
#define class076Clip                grHWMethod
#define class076Point12d4           grHWMethod
#define class076Color               grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS077 - NV4_SCALED_IMAGE_FROM_MEMORY
//
RM_STATUS class077SetContextColorKey(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetContextPattern(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetContextRop(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetContextBeta1(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetContextBeta4(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetContextSurface(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class077SetOperation(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class077Notify              grHWMethod
#define class077SetContextDmaNotifies grHWMethod
#define class077SetContextDmaImage  grHWMethod
#define class077SetColorFormat      grHWMethod
#define class077Clip                grHWMethod
#define class077RectangleOut        grHWMethod
#define class077DeltaDuDx           grHWMethod
#define class077DeltaDvDy           grHWMethod
#define class077ImageIn             grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS07A - NV10_VIDEO_OVERLAY
//
RM_STATUS class07ACreate(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
RM_STATUS class07ADestroy(PHWINFO, POBJECT);
RM_STATUS class07ASetNotify(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07AStopOverlay(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetNotifyCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetOverlayCtxDma(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07AGetOffset(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetOverlayValues(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetOverlayPointOutNow(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetOverlayLuminanceNow(PHWINFO, POBJECT, PMETHOD, U032, U032);
RM_STATUS class07ASetOverlayChrominanceNow(PHWINFO, POBJECT, PMETHOD, U032, U032);

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS07B - NV10_TEXTURE_FROM_CPU
//
// Method aliases
#define class07BNotify                grHWMethod
#define class07BSetContextDmaNotifies grHWMethod
#define class07BSetContextSurface     grHWMethod
#define class07BSetColorFormat        grHWMethod
#define class07BPoint                 grHWMethod
#define class07BSize                  grHWMethod
#define class07BClipHorizontal        grHWMethod
#define class07BClipVertical          grHWMethod
#define class07BColor                 grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS088 - NV10_DVD_SUBPICTURE
//
RM_STATUS grHWMethod(PHWINFO, POBJECT, PMETHOD, U032, U032);
// Method aliases
#define class088Notify              grHWMethod
#define class088SetContextDmaNotifies grHWMethod
#define class088SetContextDmaOverlay grHWMethod
#define class088SetContextDmaImageIn grHWMethod
#define class088SetContextDmaImageOut grHWMethod
#define class088ImageOutPoint       grHWMethod
#define class088ImageOutSize        grHWMethod
#define class088ImageOutFormat      grHWMethod
#define class088ImageOutOffset      grHWMethod
#define class088ImageInDeltaDuDx    grHWMethod
#define class088ImageInDeltaDvDy    grHWMethod
#define class088ImageInSize         grHWMethod
#define class088ImageInFormat       grHWMethod
#define class088ImageInOffset       grHWMethod
#define class088ImageInPoint        grHWMethod
#define class088OverlayDeltaDuDx    grHWMethod
#define class088OverlayDeltaDvDy    grHWMethod
#define class088OverlaySize         grHWMethod
#define class088OverlayFormat       grHWMethod
#define class088OverlayOffset       grHWMethod
#define class088OverlayPoint        grHWMethod

//////////////////////////////////////////////////////////////////////////////
//
// CLASS089 - NV10_SCALED_IMAGE_FROM_MEMORY
//
// Method aliases
#define class089Notify              grHWMethod
#define class089SetContextDmaNotifies grHWMethod
#define class089SetContextDmaImage  grHWMethod
#define class089SetContextPattern   grHWMethod
#define class089SetContextRop       grHWMethod
#define class089SetContextBeta1     grHWMethod
#define class089SetContextBeta4     grHWMethod
#define class089SetContextSurface   grHWMethod
#define class089SetColorConversion  grHWMethod
#define class089SetColorFormat      grHWMethod
#define class089SetOperation        grHWMethod
#define class089Clip                grHWMethod
#define class089RectangleOut        grHWMethod
#define class089DeltaDuDx           grHWMethod
#define class089DeltaDvDy           grHWMethod
#define class089ImageIn             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS08A - NV10_IMAGE_FROM_CPU
//

// Method aliases
#define class08ANotify              grHWMethod
#define class08ASetContextDmaNotifies grHWMethod
#define class08ASetContextColorKey  grHWMethod
#define class08ASetContextClip      grHWMethod
#define class08ASetContextPattern   grHWMethod
#define class08ASetContextRop       grHWMethod
#define class08ASetContextBeta1     grHWMethod
#define class08ASetContextBeta4     grHWMethod
#define class08ASetContextSurface   grHWMethod
#define class08ASetColorConversion  grHWMethod
#define class08ASetOperation        grHWMethod
#define class08ASetColorFormat      grHWMethod
#define class08ASetColorFormat      grHWMethod
#define class08APoint               grHWMethod
#define class08ASizeOut             grHWMethod
#define class08ASizeIn              grHWMethod
#define class08AColor               grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS093 - NV10_CONTEXT_SURFACES_3D
//
// Method aliases
#define class093Notify              grHWMethod
#define class093SetContextDmaNotifies grHWMethod
#define class093SetContextDmaColor  grHWMethod
#define class093SetContextDmaZeta   grHWMethod
#define class093SetFormat           grHWMethod
#define class093SetClipSize         grHWMethod
#define class093SetPitch            grHWMethod
#define class093SetClipHorizontal   grHWMethod
#define class093SetClipVertical     grHWMethod
#define class093SetOffsetColor      grHWMethod
#define class093SetOffsetZeta       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS094 - NV10_DX5_TEXTURED_TRIANGLE
//
// Method aliases
#define class094Notify              grHWMethod
#define class094SetContextDmaNotifies grHWMethod
#define class094SetContextDmaA      grHWMethod
#define class094SetContextDmaB      grHWMethod
#define class094SetContextSurface   grHWMethod
#define class094ColorKey            grHWMethod
#define class094Offset              grHWMethod
#define class094Format              grHWMethod
#define class094Filter              grHWMethod
#define class094Blend               grHWMethod
#define class094Control             grHWMethod
#define class094FogColor            grHWMethod
#define class094Tlvertex            grHWMethod
#define class094DrawPrimitive       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS095 - NV10_DX6_MULTI_TEXTURE_TRIANGLE
//
// Method aliases
#define class095Notify              grHWMethod
#define class095SetContextDmaNotifies grHWMethod
#define class095SetContextDmaA      grHWMethod
#define class095SetContextDmaB      grHWMethod
#define class095SetContextSurface   grHWMethod
#define class095Offset              grHWMethod
#define class095Format              grHWMethod
#define class095Filter              grHWMethod
#define class095Combine0Alpha       grHWMethod
#define class095Combine0Color       grHWMethod
#define class095Combine1Alpha       grHWMethod
#define class095Combine1Color       grHWMethod
#define class095CombineFactor       grHWMethod
#define class095Blend               grHWMethod
#define class095Control             grHWMethod
#define class095FogColor            grHWMethod
#define class095Tlmtvertex          grHWMethod
#define class095DrawPrimitive       grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS096 - NV15_CELSIUS_PRIMITIVE / NV11_CELSIUS_PRIMITIVE
//
RM_STATUS class096GetState(PHWINFO, POBJECT, PMETHOD, U032, U032);

// Method aliases
#define class096Notify                grHWMethod
#define class096SetWarningEnable      grHWMethod
#define class096WaitForIdle           grHWMethod
#define class096SyncSetRead           grHWMethod
#define class096SyncSetWrite          grHWMethod
#define class096SyncSetModulo         grHWMethod
#define class096SyncIncrementWrite    grHWMethod
#define class096SyncStall             grHWMethod
#define class096PMTrigger             grHWMethod
#define class096SetContextDmaNotifies grHWMethod
#define class096SetContextDmaA        grHWMethod
#define class096SetContextDmaB        grHWMethod
#define class096SetContextDmaVertex   grHWMethod
#define class096SetContextDmaState    grHWMethod
#define class096SetContextDmaColor    grHWMethod
#define class096SetContextDmaZeta     grHWMethod
#define class096MethodCatcher         grHWMethod
#define class096InlineArray           grHWMethod
#define class096DebugInit             grHWMethod

//////////////////////////////////////////////////////////////////////////////
// 
// CLASS09F - NV15_IMAGE_BLIT
//
// Method aliases
#define class09FNotify                  grHWMethod
#define class09FSyncSetRead             grHWMethod
#define class09FSyncSetWrite            grHWMethod
#define class09FSyncSetModulo           grHWMethod
#define class09FSyncIncrementWrite      grHWMethod
#define class09FSyncStall               grHWMethod
#define class09FSyncIncrementReadRange  grHWMethod
#define class09FSetContextDmaNotifies   grHWMethod
#define class09FSetContextColorKey      grHWMethod
#define class09FSetContextClip          grHWMethod
#define class09FSetContextPattern       grHWMethod
#define class09FSetContextRop           grHWMethod
#define class09FSetContextBeta1         grHWMethod
#define class09FSetContextBeta4         grHWMethod
#define class09FSetContextSurfaces2d    grHWMethod
#define class09FSetOperation            grHWMethod
#define class09FControlPointIn          grHWMethod
#define class09FControlPointOut         grHWMethod
#define class09FSize                    grHWMethod

#endif // _MODULAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\mvision.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Macrovision includes ********************************\
*                                                                           *
* Module: MVISION.H                                                             *
*   This module contains structure and prototype definitions used in the    *
*   Macrovision routines.                                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _MVISION_H_
#define _MVISION_H_

 
typedef struct
{
    U032    devAddr;        // device's I2C address
    U032    mode;           // Macrovision mode
    U032    port;           // I2C port (primary or secondary)
    U032    encoderType;    // Brooktree 868, Chrontel 7003, etc...
    U032    tvStandard;     // NTSC or PAL flavors
    U032    resx;
    U032    resy;
    U032    status;         // return status
} RM_MACROVISION_CONTROL;

 
RM_STATUS SetMacrovisionMode( PHWINFO, U032, RM_MACROVISION_CONTROL*);

#endif // _MVISION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\mc.h ===
#ifndef _MC_H_
#define _MC_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/****************************** Master Control *****************************\
*                                                                           *
* Module: MC.H                                                              *
*       Master Exception dispatcher.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Macros.
//
//---------------------------------------------------------------------------

//
// Since the hardware ref manuals don't give us macros to decode
// the PMC_BOOT_0 register, we provide a few here.
//
#define MC_GET_MASKREVISION(b0)         (b0 & 0x000000FF)
#define MC_GET_REVISION(b0)             ((b0 & 0x000F0000) >> 16)
#define MC_GET_IMPLEMENTATION(b0)       ((b0 & 0x00F00000) >> 20)
#define MC_GET_ARCHITECTURE(b0)         ((b0 & 0xFF000000) >> 20)

//
// Architecture constants.
//
#define MC_ARCHITECTURE_NV04            0x04
#define MC_ARCHITECTURE_NV10            0x10
#define MC_ARCHITECTURE_NV20            0x20

//
// Implementation constants.
// These must be unique within a single architecture.
//
#define MC_IMPLEMENTATION_NV04          0x00
#define MC_IMPLEMENTATION_NV05          0x01
#define MC_IMPLEMENTATION_NV0A          0x02
#define MC_IMPLEMENTATION_NV10          0x00
#define MC_IMPLEMENTATION_NV11          0x01
#define MC_IMPLEMENTATION_NV15          0x05
#define MC_IMPLEMENTATION_NV20          0x00

//
// MaskRevision constants.
//
#define MC_MASK_REVISION_A1             0xA1
#define MC_MASK_REVISION_A2             0xA2
#define MC_MASK_REVISION_A3             0xA3
#define MC_MASK_REVISION_A6             0xA6
#define MC_MASK_REVISION_B1             0xB1
#define MC_MASK_REVISION_B2             0xB2

//
// Revision constants.
// 
#define MC_REVISION_0                   0x00
#define MC_REVISION_1                   0x01
#define MC_REVISION_2                   0x02
#define MC_REVISION_3                   0x03

// Return from D3 ACPI state requires a delay before strap register is stable
#define D0_DELAY_RETRIES    10

//---------------------------------------------------------------------------
//
//  Chip ID objects.
//
//---------------------------------------------------------------------------

typedef struct _def_chip_id_object
{
    OBJECT     Base;
    PDMAOBJECT ChipTokenXlate;
} CHIPIDOBJECT, *PCHIPIDOBJECT;

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS initMc(PHWINFO);
VOID      mcService(PHWINFO);
RM_STATUS mcPowerStateTrigger(PHWINFO);
RM_STATUS chpCreateChipID(PCLASSOBJECT, U032, POBJECT *);
RM_STATUS chpDeleteChipID(POBJECT);
RM_STATUS mcPowerState(PHWINFO, U032);
BOOL IsNV4(PHWINFO);
BOOL IsNV5(PHWINFO);
BOOL IsNV0A(PHWINFO);
BOOL IsNV10(PHWINFO);
BOOL IsNV11(PHWINFO);
BOOL IsNV15(PHWINFO);
BOOL IsNV20(PHWINFO);

BOOL IsNV5orBetter(PHWINFO);
BOOL IsNV10orBetter(PHWINFO);
BOOL IsNV10MaskRevA03orBetter(PHWINFO);
BOOL IsNV15orBetter(PHWINFO);
BOOL IsNV15MaskRevA01(PHWINFO);
BOOL IsNV15MaskRevA02(PHWINFO);
BOOL IsNV15MaskRevA03(PHWINFO);
BOOL IsNV11orBetter(PHWINFO);
BOOL IsNV20orBetter(PHWINFO);

RM_STATUS mcSetBiosRevision(PHWINFO);

#endif // _MC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nvhalcpp.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** HAL/RM Interfaces ******************************\
*                                                                           *
* Module: nvhalcpp.h                                                        *
*   This include file contains any macro redefinitions required within the  *
*   HAL code to allow sharing of cpp directives between the RM and the HAL. *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#undef nvAddr
#undef ChipBugs
#define ChipBugs  pHalHwInfo->pMcHalInfo->ChipBugs

#ifdef DEBUG

#undef  DBG_PRINT_STRING
#define DBG_PRINT_STRING(d,s) (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmPrintString)((PHALHWINFO) pHalHwInfo->pDeviceId, d, s)  

#undef  DBG_PRINT_VALUE
#define DBG_PRINT_VALUE(d,v) (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmPrintValue)((PHALHWINFO) pHalHwInfo->pDeviceId, d, v) 

#undef  DBG_PRINT_STRING_VALUE
#define DBG_PRINT_STRING_VALUE(d,s,v) (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmPrintStringValue)((PHALHWINFO) pHalHwInfo->pDeviceId, d, s, v) 

#undef  DBG_PRINT_STRING_PTR
#define DBG_PRINT_STRING_PTR(d,s,v) (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmPrintStringPtr)((PHALHWINFO) pHalHwInfo->pDeviceId, d, s, (VOID*) v) 

#undef  DBG_PRINT_STRING_VAL64
#define DBG_PRINT_STRING_VAL64(d,s,v) (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmPrintStringVal64)((PHALHWINFO) pHalHwInfo->pDeviceId, d, s, v) 

#undef  DBG_BREAKPOINT
#define DBG_BREAKPOINT() (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmBreakPoint)((PHALHWINFO) pHalHwInfo->pDeviceId) 

#else // DEBUG

#undef  DBG_PRINT_STRING
#define DBG_PRINT_STRING(d,s) ((void)0)

#undef  DBG_PRINT_VALUE
#define DBG_PRINT_VALUE(d,v) ((void)0)

#undef  DBG_PRINT_STRING_VALUE
#define DBG_PRINT_STRING_VALUE(d,s,v) ((void)0)

#undef  DBG_PRINT_STRING_PTR
#define DBG_PRINT_STRING_PTR(d,s,v) ((void)0)

#undef  DBG_PRINT_STRING_VAL64
#define DBG_PRINT_STRING_VAL64(d,s,v) ((void)0)

#undef  DBG_BREAKPOINT
#define DBG_BREAKPOINT() ((void)0)

#endif // DEBUG

#undef REG_WR08
#undef REG_RD08
#define REG_WR08(o,v)   (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmRegWr08)((PHALHWINFO) pHalHwInfo->pDeviceId, o, (U008) v)
#define REG_RD08(o)		(*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmRegRd08)((PHALHWINFO) pHalHwInfo->pDeviceId, o)

#undef REG_WR32
#undef REG_RD32
#define REG_WR32(o,v)   (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmRegWr32)((PHALHWINFO) pHalHwInfo->pDeviceId, o, v)
#define REG_RD32(o)		(*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmRegRd32)((PHALHWINFO) pHalHwInfo->pDeviceId, o)

#undef osDelay
#define osDelay(m)      (*((PHALRMFUNCS_000)((PHALHWINFO) pHalHwInfo)->pHalRmFuncs)->_nvHalRmDelay)((PHALHWINFO) pHalHwInfo->pDeviceId, m)

#undef INST_RD32
#define INST_RD32(i,o)      REG_RD32((pHalHwInfo->pPramHalInfo->PraminOffset+((i)<<4)+(o)))

#undef INST_WR32
#define INST_WR32(i,o,d)    REG_WR32((pHalHwInfo->pPramHalInfo->PraminOffset+((i)<<4)+(o)),(d))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nvrm.h ===
#ifndef _NVRM_H_
#define _NVRM_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NVRM.H                                                            *
*       Resource Manager defines and structures used throughout the code.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Version number of files built using this header file.
//
//  The format of this is 0x00010206, where
//   - 0x0001 is the chip architecture
//   -   0x02 is the software release
//   -   0x06 is the minor revision
//
//---------------------------------------------------------------------------

#define NVRM_VERSION    0x00030200

//---------------------------------------------------------------------------
//  define some inline assembly instructions

#ifdef __WATCOMC__

void my_sti();
#pragma aux my_sti = \
    "pushf" \
    "sti";

void my_cli();
#pragma aux my_cli =  \
    "popf";

#else   // if not Watcom, its the Microsoft compiler

#define my_sti \
    _asm    pushf   \
    _asm    sti
#define my_cli \
    __asm   popf

#endif  // _WATCOMC_

//---------------------------------------------------------------------------
//
//  NVidia data types.
//
//---------------------------------------------------------------------------

#include <nvtypes.h>

//
// Fixed point math types and macros.
//
typedef signed long     S016d016;
typedef unsigned long   U016d016;
typedef signed long     S008d024;
typedef unsigned long   U008d024;
typedef signed long     S012d020;
typedef unsigned long   U012d020;

#define FIX16_POINT             16
#define FIX16_SCALE             ((U032)1<<FIX16_POINT)
#define FIX16_INT_MASK          ((U032)~0<<FIX16_POINT)
#define FIX16_FRAC_MASK         (~FIX16_INT_MASK)
#define FIX16_INT(f)            ((f)>>FIX16_POINT)
#define FIX16_FRAC(f)           ((f)&FIX16_FRAC_MASK)
#define INT_FIX16(f)            ((f)<<FIX16_POINT)
#define FIX16(i)                (S016d016)((i)*FIX16_SCALE))
#define FIX16_MUL(f1,f2)        ((FIX16_INT(f1)*FIX16_INT(f2)<<FIX16_POINT)     \
                                +(FIX16_INT(f1)*FIX16_FRAC(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_INT(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_FRAC(f2)>>FIX16_POINT))
#define FIX16_DIV(f1,f2)        (((f1)<<(FIX16_POINT/2))/((f2)>>(FIX16_POINT/2)))
#define FIX16_DIVI(f1,f2)       ((f1)/((f2)>>(FIX16_POINT)))
#define FIX16_IDIV(f1,f2)       (((f1)<<(FIX16_POINT))/(f2))
#define FIX24_POINT             24
#define FIX24_SCALE             ((U032)1<<FIX24_POINT)
#define FIX24_INT_MASK          ((U032)~0<<FIX24_POINT)
#define FIX24_FRAC_MASK         (~FIX24_INT_MASK)
#define FIX24_TO_INT(f)         ((f)>>FIX24_POINT)
#define FIX24(i)                ((S008d024)((i)*FIX24_SCALE))
#define FIX24_MUL(f1,f2)        (((f1)>>(FIX24_POINT/2))*((f2)>>(FIX24_POINT/2)))
#define FIX24_DIV(f1,f2)        (((f1)<<(FIX24_POINT/2))/((f2)>>(FIX24_POINT/2)))
#define FIX24_DIVI(f1,f2)       ((f1)/((f2)>>(FIX24_POINT)))
#define FIX24_IDIV(f1,f2)       (((f1)<<(FIX24_POINT))/(f2))

//---------------------------------------------------------------------------
//
//  Common types.
//
//---------------------------------------------------------------------------

#ifndef VOID
#define VOID            void
#endif
#ifndef BOOL
#define BOOL            S032
#endif
#ifndef TRUE
#define TRUE            !0L
#endif
#ifndef FALSE
#define FALSE           0L
#endif
#ifndef NULL
#define NULL            0L
#endif
    
//---------------------------------------------------------------------------
//
//  Error codes.
//
//---------------------------------------------------------------------------

//
// External codes.
//
#define NV_ERROR_1                      0x0100
#define NV_TYPE_CONFLICT                (0x01|NV_ERROR_1)
#define NV_OUT_OF_RANGE                 (0x02|NV_ERROR_1)
#define NV_NO_CONNECTION                (0x03|NV_ERROR_1)
#define NV_NO_SUCH_OBJECT               (0x04|NV_ERROR_1)
#define NV_NAME_IN_USE                  (0x05|NV_ERROR_1)
#define NV_OUT_OF_RESOURCES             (0x06|NV_ERROR_1)
#define NV_TRANSLATION_VIOLATION        (0x07|NV_ERROR_1)
#define NV_PROTECTION_VIOLATION         (0x08|NV_ERROR_1)
#define NV_BUFFER_BUSY                  (0x09|NV_ERROR_1)
#define NV_ILLEGAL_ACCESS               (0x0A|NV_ERROR_1)
#define NV_BAD_COLORMAP_FORMAT          (0x0B|NV_ERROR_1)
#define NV_BAD_COLOR_FORMAT             (0x0C|NV_ERROR_1)
#define NV_BAD_MONOCHROME_FORMAT        (0x0D|NV_ERROR_1)
#define NV_BAD_PATTERN_SHAPE            (0x0E|NV_ERROR_1)
#define NV_BAD_SUBDIVIDE                (0x0F|NV_ERROR_1)
#define NV_NO_CURRENT_POINT             (0x10|NV_ERROR_1)
#define NV_BAD_AUDIO_FORMAT             (0x11|NV_ERROR_1)
#define NV_NO_DMA_TRANSLATION           (0x12|NV_ERROR_1)
#define NV_INCOMPLETE_METHOD            (0x13|NV_ERROR_1)
#define NV_RESERVED_ADDRESS             (0x14|NV_ERROR_1)
#define NV_UNIMPLEMENTED_PATCH          (0x15|NV_ERROR_1)
#define NV_OS_NAME_ERROR                (0x16|NV_ERROR_1)
#define NV_INCOMPLETE_PATCH             (0x17|NV_ERROR_1)
#define NV_BUFFERGAP_ERROR              (0x18|NV_ERROR_1)
#define NV_FIFO_OVERFLOW                (0x19|NV_ERROR_1)
//
// Internal codes.
//
typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)

// Errors returned from the arch calls.
#define NV_ERROR_2                      0x0200
#define RM_ERR_OPERATING_SYSTEM         (0x00000001|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_PARENT        (0x00000002|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_HANDLE        (0x00000003|NV_ERROR_2)
#define RM_ERR_OBJECT_IN_USE            (0x00000004|NV_ERROR_2)
#define RM_ERR_OBJECT_HAS_CHILDERN      (0x00000005|NV_ERROR_2)
#define RM_ERR_BAD_CLASS                (0x00000006|NV_ERROR_2)
#define RM_ERR_INSUFFICIENT_RESOURCES   (0x00000007|NV_ERROR_2)
#define RM_ERR_BAD_FLAGS                (0x00000008|NV_ERROR_2)
#define RM_ERR_BAD_BASE                 (0x00000009|NV_ERROR_2)
#define RM_ERR_BAD_LIMIT                (0x0000000A|NV_ERROR_2)
#define RM_ERR_PROTECTION_FAULT         (0x0000000B|NV_ERROR_2)
#define RM_ERR_MULTIPLE_MEMORY_TYPES    (0x0000000C|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_ERROR         (0x0000000D|NV_ERROR_2)
#define RM_ERR_BAD_OBJECT_BUFFER        (0x0000000E|NV_ERROR_2)
#define RM_ERR_BAD_OFFSET               (0x0000000F|NV_ERROR_2)
#define RM_ERR_BAD_CLIENT               (0x00000010|NV_ERROR_2)

// Errors returned from HAL calls.
#define NV_ERROR_3                      (0x0400)
#define RM_ERR_VERSION_MISMATCH         (0x00000001|NV_ERROR_3)
#define RM_ERR_BAD_ARGUMENT             (0x00000002|NV_ERROR_3)
#define RM_ERR_INVALID_STATE            (0x00000003|NV_ERROR_3)

//
// RM_ASSERT macro
//
#ifdef DEBUG
#define RM_ASSERT(cond)                                                     \
    if ((cond) == 0x0)                                                      \
    {                                                                       \
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: assertion FAILED!\n");   \
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, __FILE__);                      \
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, ": line ");                     \
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)__LINE__);                  \
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");                          \
        DBG_BREAKPOINT();                                                   \
    }
#else
#define RM_ASSERT(cond)
#endif

//
// Power of 2 alignment.
//    (Will give unexpected results if 'a' is not a power of 2.)
//

#define NV_ALIGN_DOWN(v, gran) ((v) & ~((gran) - 1))
#define NV_ALIGN_UP(v, gran)   (((v) + ((gran) - 1)) & ~((gran)-1))

#define NV_ALIGN_PTR_DOWN(p, gran) ((void *) NV_ALIGN_DOWN(((NV_UINTPTR_T)p), (gran)))
#define NV_ALIGN_PTR_UP(p, gran)   ((void *) NV_ALIGN_UP(((NV_UINTPTR_T)p), (gran)))

#define NV_PAGE_ALIGN_DOWN(value) NV_ALIGN_DOWN((value), RM_PAGE_SIZE)
#define NV_PAGE_ALIGN_UP(value)   NV_ALIGN_UP((value), RM_PAGE_SIZE)

//
// NV Reference Manual register access definitions.
//
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
//
// NV Reference Manual instance memory structure access definitions.
//
#define INST_WR32(i,o,d)        REG_WR32((pDev->Pram.HalInfo.PraminOffset+((i)<<4)+(o)),(d))
#define INST_RD32(i,o)          REG_RD32((pDev->Pram.HalInfo.PraminOffset+((i)<<4)+(o)))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#undef  SF_MASK
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(i,s,f)       (((INST_RD32(i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
//
// EEPROM access macros.
//
#define EEPROM_INDEX_RD08(ii, dd)   \
    {REG_WR32(NV_PEEPROM_CONTROL,DRF_NUM(_PEEPROM,_CONTROL,_ADDRESS,(ii))|DRF_DEF(_PEEPROM,_CONTROL,_COMMAND,_READ));\
    osDelay(1);\
    (dd)=REG_RD32(NV_PEEPROM_CONTROL)&0xFF;}
//
// DevInfo update/finish flags.
//
#define UPDATE_HWINFO_AUDIO_VOLUME             BIT(0)
#define FINISH_HWINFO_AUDIO_VOLUME             BIT(0)
#define UPDATE_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define FINISH_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define UPDATE_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define FINISH_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define UPDATE_HWINFO_DAC_CURSOR_POS           BIT(0)
#define FINISH_HWINFO_DAC_CURSOR_POS           BIT(0)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define UPDATE_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define FINISH_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define UPDATE_HWINFO_DAC_COLORMAP             BIT(3)
#define FINISH_HWINFO_DAC_COLORMAP             BIT(3)
#define UPDATE_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define FINISH_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define UPDATE_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define FINISH_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define UPDATE_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define FINISH_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define UPDATE_HWINFO_DAC_DPML                 BIT(8)
#define FINISH_HWINFO_DAC_DPML                 BIT(8)
#define UPDATE_HWINFO_DAC_APLL                 BIT(9)
#define FINISH_HWINFO_DAC_APLL                 BIT(9)
#define UPDATE_HWINFO_DAC_VPLL                 BIT(10)
#define FINISH_HWINFO_DAC_VPLL                 BIT(10)
#define UPDATE_HWINFO_DAC_MPLL                 BIT(11)
#define FINISH_HWINFO_DAC_MPLL                 BIT(11)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW     BIT(12)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE_NEW     BIT(12)
#define UPDATE_HWINFO_DAC_NVPLL                BIT(13)
#define FINISH_HWINFO_DAC_NVPLL                BIT(13)
#define UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT  BIT(14)
#define FINISH_HWINFO_DAC_IMAGE_OFFSET_FORMAT  BIT(14)
#define UPDATE_HWINFO_CODEC_FREQUENCY          BIT(0)
#define FINISH_HWINFO_CODEC_FREQUENCY          BIT(0)
#define UPDATE_HWINFO_CODEC_SOURCE             BIT(1)
#define FINISH_HWINFO_CODEC_SOURCE             BIT(1)
#define UPDATE_HWINFO_CODEC_GAIN               BIT(2)
#define FINISH_HWINFO_CODEC_GAIN               BIT(2)
#define UPDATE_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define FINISH_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define UPDATE_HWINFO_BUFFER_FLIP              BIT(0)
#define FINISH_HWINFO_BUFFER_FLIP              BIT(0)
#define UPDATE_HWINFO_BUFFER_PARAMS            BIT(8)
#define FINISH_HWINFO_BUFFER_PARAMS            BIT(8)
#define UPDATE_HWINFO_DISPLAY_PARAMS           BIT(9)
#define FINISH_HWINFO_DISPLAY_PARAMS           BIT(9)
#define UPDATE_HWINFO_REFRESH_PARAMS           BIT(10)
#define FINISH_HWINFO_REFRESH_PARAMS           BIT(10)
#define UPDATE_HWINFO_GAMEPORT                 BIT(0)
#define FINISH_HWINFO_GAMEPORT                 BIT(0)
#define UPDATE_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define FINISH_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define UPDATE_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define FINISH_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define UPDATE_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_VGA_FIXUP                BIT(0)
#define UPDATE_HWINFO_DGP_3D_ENABLE            BIT(0)
#define FINISH_HWINFO_DGP_3D_ENABLE            BIT(0)
#define UPDATE_HWINFO_VIDEO_ENABLE             BIT(0)
#define FINISH_HWINFO_VIDEO_ENABLE             BIT(0)
#define UPDATE_HWINFO_VIDEO_START              BIT(1)
#define FINISH_HWINFO_VIDEO_START              BIT(1)
#define UPDATE_HWINFO_VIDEO_SIZE               BIT(2)
#define FINISH_HWINFO_VIDEO_SIZE               BIT(2)
#define UPDATE_HWINFO_VIDEO_SCALE              BIT(3)
#define FINISH_HWINFO_VIDEO_SCALE              BIT(3)
#define UPDATE_HWINFO_VIDEO_COLORKEY           BIT(4)
#define FINISH_HWINFO_VIDEO_COLORKEY           BIT(4)
//
// Notification otherInfo defines.
//
#define NOTIFY_INFO16_BUFFER_CHAIN_GAP  1
#define NOTIFY_INFO16_BUFFER_YANK       2
#define NOTIFY_INFO16_BUFFER_LOOP       3

//---------------------------------------------------------------------------
//
// 32 bit debug marker values.
//
//---------------------------------------------------------------------------

// Solaris machines are byte reversed from Intel machines
#ifdef SOLARIS
#define NV_MARKER1 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#define NV_MARKER2 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#else
#define NV_MARKER1 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#define NV_MARKER2 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#endif

//---------------------------------------------------------------------------
//
// DevInfo state values.
//
//---------------------------------------------------------------------------

//
// BUS type.
//
#define BUS_PCI                         1
#define BUS_VL                          2
#define BUS_NIRV                        3
#define BUS_AGP                         4
//
// AGP defines
//
#define AGP_APERTURE_SIZE               0x2000000       // 32 MB
#define MAP_WRITECOMBINE                0x2
//
// Define the various NV chip revision ID's
//
#define NV4_REV_A_00                    0x00
#define NV4_REV_B_00                    0x10
//
// Framebuffer values.
//
#define BUFFER_DRAM                     0
#define BUFFER_SGRAM                    1
#define BUFFER_SDRAM                    2
#define BUFFER_DDRAM                    3
#define BUFFER_CRUSH_UMA                4

#define BUFFER_DRAM_EDO                 0
#define BUFFER_DRAM_FPM                 1

#define BUFFER_HSYNC_NEGATIVE           1
#define BUFFER_HSYNC_POSITIVE           0
#define BUFFER_VSYNC_NEGATIVE           1
#define BUFFER_VSYNC_POSITIVE           0
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1
// Offscreen Instance Memory size.
//
#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB

//
// DAC values.
//
#define DAC_CURSOR_DISABLED             0
#define DAC_CURSOR_THREE_COLOR          1
#define DAC_CURSOR_TWO_COLOR_XOR        2
#define DAC_CURSOR_TWO_COLOR            3
#define DAC_CURSOR_FULL_COLOR_XOR       4
#define DAC_CURSOR_FULL_COLOR           5
#define DAC_CURSOR_TYPE_NEW             6

#define DAC_CURSOR_CACHE_ENTRY          0x80000000
#define DAC_CURSOR_CACHE_DISPLAY        0x40000000

#define MAX_CACHED_CURSORS              5


//
// Video modes.
//
// (keep these around until all rm's os sections are updated)
//
#define NUM_VIDEO_DEPTHS                3
#define VIDEO_DEPTH_8BPP                8
#define VIDEO_DEPTH_15BPP               15
#define VIDEO_DEPTH_30BPP               30
#define NUM_RESOLUTIONS                 16
#define RESOLUTION_576X432              0
#define RESOLUTION_640X400              1
#define RESOLUTION_640X480              2
#define RESOLUTION_800X600              3
#define RESOLUTION_1024X768             4
#define RESOLUTION_1152X864             5
#define RESOLUTION_1280X1024            6
#define RESOLUTION_1600X1200            7
#define RESOLUTION_320X200              8
#define RESOLUTION_320X240              9
#define RESOLUTION_512X384              10
#define RESOLUTION_640X240              11
#define RESOLUTION_400X300              12
#define RESOLUTION_480X360              13
#define RESOLUTION_960X720              14
#define RESOLUTION_320X400              15
//
// Monitor types
//
#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

//
// Display Types
//
#define MONITOR                         0
#define TV                              1
#define DUALSURFACE                     2
#define MONITOR_FLAT_PANEL              3

//Queue depth for mobile hotkey events. Should be comfortably more than needed.
#define NV_HOTKEY_EVENT_QUEUE_SIZE      16

// 
// Customer coding (bitmasks used to enable/disable functionality)
//
#define CUSTOMER_GENERIC                0x00000000
#define CUSTOMER_CANOPUS                0x00000001
#define CUSTOMER_CANOPUS_TOSHIBA        0x00000002
#define CUSTOMER_CREATIVE               0x00000004
#define CUSTOMER_ASUS                   0x00000008       

//
// Gamport Info Analog Data Array values.
//
#define NV_GPORT_X_AXIS                 0
#define NV_GPORT_Y_AXIS                 1
#define NV_GPORT_Z_AXIS                 2
#define NV_GPORT_PEDALS                 3
#define NV_GPORT_PEDALS_1               3
#define NV_GPORT_PEDALS_2               4
#define NV_GPORT_THROTTLE               5
#define NV_GPORT_THROTTLE_1             5
#define NV_GPORT_THROTTLE_2             6
//
// Gamport source values.
//
#define GPORT_INPUT_NULL                0x0000
#define GPORT_INPUT_POT                 0x0100
#define GPORT_INPUT_JOYSTICK            0x0200
#define GPORT_INPUT_PEDALS              0x0300
#define GPORT_INPUT_THROTTLE            0x0400
#define GPORT_INPUT_PAD                 0x0500
#define GPORT_INPUT_YOKE                0x0600
#define GPORT_INPUT_POTA                0x0700
#define GPORT_INPUT_GUN                 0x0800
#define GPORT_INPUT_INVALID             0xFF00
#define GPORT_INPUT_SOURCE_MASK         0xFF00
//
// Gamport source port values.
//
#define GPORT_INPUT_PORT_PLAYER1        0
#define GPORT_INPUT_PORT_PLAYER2        1
#define GPORT_INPUT_PORT_PLAYER3        2
#define GPORT_INPUT_PORT_PLAYER4        3
#define GPORT_INPUT_PORT_PLAYER5        4
#define GPORT_INPUT_PORT_PLAYER6        5
#define GPORT_INPUT_PORT_PLAYER7        6
#define GPORT_INPUT_PORT_PLAYER8        7
#define GPORT_INPUT_PORT_PLAYER9        8
#define GPORT_INPUT_PORT_PLAYER10       9
#define GPORT_INPUT_PORT_PLAYER11       10
#define GPORT_INPUT_PORT_PLAYER12       11
#define GPORT_INPUT_PORT_POT            12
#define GPORT_INPUT_PORT_MAX            12
#define GPORT_INPUT_PORT_MASK           0x00FF
//
// Gameport source channel values. 
//
#define GPORT_INPUT_BUTTONS             BIT(0)
#define GPORT_INPUT_X_AXIS              BIT(1)
#define GPORT_INPUT_Y_AXIS              BIT(2)
#define GPORT_INPUT_Z_AXIS              BIT(3)
#define GPORT_INPUT_X_POS               BIT(4)
#define GPORT_INPUT_Y_POS               BIT(5)

//---------------------------------------------------------------------------
//
//  Max number of FIFO channels used.
//
//---------------------------------------------------------------------------

// currently only initClientInfo() uses MAX_FIFOS instead of NUM_FIFOS, since
// NUM_FIFOS may be different per device (e.g. nv4 vs. nv10). Also, the client
// database alloc occurs before an nvInfo has been allocated.
#define MAX_FIFOS                       32

//---------------------------------------------------------------------------
//
//  Data structures.
//
//---------------------------------------------------------------------------
//
// Device register access array.
//
typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

//
// A hardware fifo hash table entry.
//
typedef struct _def_HashTableEntry
{
    V032 ht_ObjectHandle;
    V032 ht_Context;
} HASH_TABLE_ENTRY;
         
//
// Device state and configuration information.
//
typedef struct _def_hw_info *PHWINFO;

#ifndef RM_HEADERS_MINIMAL

//
// setting RM_HEADERS_MINIMAL causes rest of file to be excluded so that
//    we don't pull in all the other include files.   Used by
//    unix version for os-interface files (so we can minimize
//    shipped include files)
//

#include "all_incs.h"

#include <nvhal.h>
#include <nvromdat.h>
#include <nvRmStereo.h>


// A software hash table entry
typedef struct _def_sw_hashTableEntry
{
    POBJECT Object;
    U032    ChID;
} SW_HASH_TABLE_ENTRY, *PSW_HASH_TABLE_ENTRY;

// System info structure
typedef struct _def_rm_info
{
    struct _def_processor_info
    {
        U032 Size;
        char ID[32];
        U032 Type;
        U032 Clock;
        PROCESSORHALINFO HalInfo;
    } Processor;

	struct _def_agp_info
	{
        struct _def_agp_nb_addr {
            U008   bus;
            U008   device;
            U008   func;
            U008   valid;
        } NBAddr;                   // bus, device, func of the NB
		U032 AGPCapPtr;             // offset of the AGP capptr in the NB
		U032 AGPPhysStart;
		VOID_PTR AGPLinearStart;
		U032 AGPHeapFree;
		VOID_PTR AGPGartBase;
		VOID_PTR AGPGartBitmap;
		U032 AGPLimit;
		U032 AGPFWEnable;
		U032 AGPFullSpeedFW;
		U032 AGPChipset;			// AGP chipset enum (NT4 AGP support)
		VOID_PTR AGPChipsetMapping; // mapping to AGP registers (NT4 AGP support)
	} AGP;

    struct _def_debugger_info
    {
        U032 Handle;                // handle of currently registered DE client
        POBJECT object;             // object data structure
    } Debugger;

} RMINFO, *PRMINFO;

typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 IntrEn0;
        U032 Bus;
        U032 BiosRevision;
        U032 BiosOEMRevision;
        U032 BiosRMDword;
        U032 ReqAGPRate;
#ifdef RM_STATS
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
        U032 osStartInterrupt;
#endif
        MCHALINFO HalInfo;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 PhysFbAddr;
        U032 IntLine;
        U032 IntPin;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 nvPhys;						//***
        U032 fbPhys;						//***
        U032 nvIRQ;							//***
        // NOTE: fbLength is the size of the memory window.
        // IT DOES NOT REFLECT THE AMOUNT OF MEMORY ACTUALLY ON THE BOARD.
        // Use Framebuffer.RamSize for that.
        U032 fbLength;
        U032 nvBusDeviceFunc;
        U032 ChipID;						//***
		U032 hpicIRQ;						//***  WIN9X ONLY
        U032 hDev;							//***  WIN9X ONLY
		U032 doIOToFlushCache;				// A non zero in this field indicates that an IO needs to be done to 
											// ensure all the caches are flushed. This is currently set if we
											// detect an ALI1541 chipset or a RegistryEntry exists. This info
											// is returned in rmConfigGet.
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 PrivBase;						// throw this out!
        U032 UpdateFlags;
        U032 FinishFlags;
        PRAMHALINFO HalInfo;
    } Pram;        
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 UpdateFlags;
        U032 FinishFlags;
        FIFOHALINFO HalInfo;
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 Enable;
        U032 PciNv19;   // Not Master, but there is no Config
    } Master;
    struct _def_dma_info
    {
        U032 Size;
        char ID[32];
#ifdef LEGACY_ARCH    
        U032 DmaInMemEmptyInstance;
        U032 DmaToMemEmptyInstance;
        U032 DmaFromMemEmptyInstance;
#endif // LEGACY_ARCH
        DMAHALINFO HalInfo;
    } Dma;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        // I think these can go too
        U032 DpmLevel;
        U032 Resolution;
        U032 RefreshRateType;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 FilterEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;               
        U032 Scale_y;
        VOID_PTR HeapHandle;
        U032 CursorAdjust;
        U032 NoAdjustedPitch;
        U032 PrimarySurfaceAlloced;
        U032 ConfigPageHeight;  // for LEGACY_ARCH
        FBHALINFO HalInfo;
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 Debug4;
        U032 CurrentChID;
        U032 Enabled;
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 Capabilities;
        VOID_PTR ClassLocks;					// ptr to lock table
        GRHALINFO HalInfo;
    } Graphics;
    struct _def_video_info
    {
        U032 Size;
        char ID[32];
        U032 OverlayAllowed;
        U032 CurrentChID;
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 dwHasInited;   
        U032 class63VBlankCount[2];
        U032 FlipOnHsync;
        U032 ClassLocks;
        VIDEOHALINFO HalInfo;
    } Video;
    struct _def_mediaport_info
    {
        U032 Size;
        char ID[32];
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 ImageBufferNumber;
        VOID_PTR ImageCallback;
        VOID_PTR CurrentDecoder;
        VOID_PTR CurrentDecompressor;
        VOID_PTR CurrentParallelBusObj;
        U032 ClassLocks;
        MPHALINFO HalInfo;
    } MediaPort;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 DpmLevel;
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 DisplayChanged;
        U032 CurrentDisplay;
        U032 DisplayPitch;
        U032 EncoderType;
        U032 EncoderID;
        U032 TVCursorMin;
        U032 TVCursorMax;
#if 0
        U032 TVformat;					   // NTSC or Pal
#endif
        U032 TVStandard;                   // NTSC or PAL
        U032 TVoutput;                     // SVideo/Composite/Autoselect
        U032 DesktopState;                 // multimon/clone/single
#define NV_DAC_DESKTOP_STATE_DEFAULT       0x0
#define NV_DAC_DESKTOP_STATE_MULTI         0x1
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U016 CursorColorImage[32][32];
        U032 Palette[272];
        U032 Gamma[272];
        U032 UpdateFlags;
        U032 CursorImageInstance;
        U016 CursorImageCache[32][32][MAX_CACHED_CURSORS]; // 32x32 words
        U032 CursorImageCacheInstance[MAX_CACHED_CURSORS];
        U032 CursorAddress[MAX_CACHED_CURSORS];
        U032 CursorMaskCRC[MAX_CACHED_CURSORS];
        U008 SavedCursor[(32/8)*32 + 32*32];
        U032 CursorCached;
        U032 CursorCacheCount;
        U032 CursorCacheEntry;
        U008 flickertoggle;                //***
        U008 CursorBitDepth; 
        U008 I2cIniFlag;
        U008 dummy2;                       //Pads for the previous byte ***
        U032 filterCountdown;              //***
        U032 CursorCacheEnable;
        U032 CRTPortID;
        U032 CRT2PortID;
        U032 TVOutPortID;
        U032 DFPPortID;                    // I2C Port to use for digital flat panel as primary
        U032 DFP2PortID;                   // I2C Port to use for DFP 2 of 2
        U032 I2CPrimaryWriteIndex;         // CRTC Index of primary I2C write port
        U032 I2CPrimaryStatusIndex;        // CRTC Index of primary I2C status port
        U032 I2CSecondaryWriteIndex;       // CRTC Index of secondary I2C write port    
        U032 I2CSecondaryStatusIndex;      // CRTC Index of secondary I2C status port    
        U032 I2CTertiaryWriteIndex;        // CRTC Index of tertiary I2C write port    
        U032 I2CTertiaryStatusIndex;       // CRTC Index of tertiary I2C status port    
        U032 HorizontalVisible;
        U032 HorizontalBlankStart;
        U032 HorizontalRetraceStart;
        U032 HorizontalRetraceEnd;
        U032 HorizontalBlankEnd;
        U032 HorizontalTotal;
        U032 VerticalVisible;
        U032 VerticalBlankStart;
        U032 VerticalRetraceStart;
        U032 VerticalRetraceEnd;
        U032 VerticalBlankEnd;
        U032 VerticalTotal;
        U032 PixelDepth;
        U032 RefreshRate;
        U032 HorizontalSyncPolarity;
        U032 VerticalSyncPolarity;
        U032 DoubleScannedMode;
        U032 fpPixClk;
        U032 fpHActive;
        U032 fpHDispEnd;
        U032 fpHValidEnd;
        U032 fpHSyncStart;
        U032 fpHSyncEnd;
        U032 fpHValidStart;
        U032 fpHTotal;
        U032 fpVActive;
        U032 fpVDispEnd;
        U032 fpVValidEnd;
        U032 fpVSyncStart;
        U032 fpVSyncEnd;
        U032 fpVValidStart;
        U032 fpVTotal;
        U032 fpNative;
        U032 fpHMax;
        U032 fpVMax;
        U032 fpFlags;
        U032 fpRelativeBrightness;	//current setting of the FP brightness
        U032 fpPWMRegisterContents; //used by PM to shut off backlight and properly restore backlight
        U032 PClkVClkRatio; // for legacy
        U032 FminVco;
        U032 FmaxVco;
        U032 MultiSyncCounter;
        DACCRTCINFO CrtcInfo[MAX_CRTCS];
        DACHALINFO HalInfo;
        DACDCBDEVDESC DCBDesc[DCB_MAX_NUM_DEVDESCS];
        DACDCBI2CRECORD DCBI2c[DCB_MAX_NUM_I2C_RECORDS];
#define DAC_CRT_OFFSET_IN_MAP       0       // bits 0..7 map to CRT0..CRT7
#define DAC_TV_OFFSET_IN_MAP        8       // bits 8..15 map to TV0..TV7
#define DAC_DD_OFFSET_IN_MAP        16      // bits 16..23 map to DD0..DD7
        U032 DevicesBitMap;
        U032 BootDevicesBitMap;
        U032 DevicesNoCheck;
    } Dac;

#ifdef LEGACY_ARCH    
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Dgp;
#endif // LEGACY_ARCH

    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
#ifdef RM_STATS
        U032 ServiceCount;
#endif
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 tmrSave[2];          //***
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
        U032 DOSBox;
#ifdef NV_VGA
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
#endif // NV_VGA
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
#ifdef RM_STATS
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
#endif
    struct _def_power_info
    {
        U032 State;
        U032 strapInfo;
        U032 coeff_select;
        U032 nvpll;
        U032 mpll;
        U032 vpll;
        U032 PbusDebug1;
        U032 PbusDebug3;
        U032 MobileOperation;
        U032 PostNVCLK;
        U032 IdleNVCLK;
        U032 PostMCLK;
        U032 IdleMCLK;
        // Chip-dependent power data moved to MC section.
    } Power;
    struct _def_registry_info
    {
        U032 Size;
        char ID[32];
        char DBstrDevNodeDisplay[128];
        char DBstrDevNodeDisplayNumber[128];
    } Registry;

    struct _def_hotkey_info
    {
//        U032 reg4CShadow;
        BOOL enabled;
        U032 queueHead;
        U032 queueTail;
        struct _def_hotkey_queue
        {
            U032 event;
            U032 status;
        } Queue[NV_HOTKEY_EVENT_QUEUE_SIZE];
    } HotKeys;

    U016				  filler1;
    U008				  filler2;

    // NOTE: This filler above fixed a really strange problem. We don't know why it
    // fixed the problem. Without this filler, phantom drive letters would appear!
    // See bug # 19981209-132200. We also don't know how a misalignment here causes
    // the registry to go bad.

    U008                DeviceDisabled;
    PSW_HASH_TABLE_ENTRY DBhashTable;                 //***
    U008                *DBfbInstBitmap;              //***
    PHWREG              DBnvAddr;                     //***
    PHWREG              DBromAddr;                    //***
    PHWREG              DBbiosAddr;                   //***
    PHWREG              DBfbAddr;                     //***
    PHWREG              DBagpAddr;                    //***
    PHWREG              DBimAddr;                     //***                               
    PFIFO               DBfifoTable;                  //***
    PDMAOBJECT          DBDmaList;                    //***
    PDMAOBJECT          DBVidDmaObject;               //***
    PVBLANKNOTIFY       DBgrVBlankList[2];            //***
    PTIMERCALLBACK      DBtmrCallbackList;            //***
    PTIMERCALLBACK      DBtmrCallbackFreeList;        //***
    PTIMERCALLBACK      DBtmrCallbackTable;           //***
    PVBLANKNOTIFY       DBclass63VBlankList[2];
    POVERLAYSERVICEPROC pOverlayServiceHandler;
    POBJECT             DBpHardwareObject;
    U032                (*DBdisplayModeHook)(U032);
    SURFACEATTRIBUTES   DBOverlaySurfaceAttribs[20];
    SURFACEATTRIBUTES   DBImageSurfaceAttribs[20];
    U032                *fb_save;
    PVIDEOCOLORMAPOBJECT colormapObjectToNotify;

    ENGINEDB            engineDB;                   // HAL-derived engine info
    CLASSDB             classDB;                    // HAL-derived class info

#if 0
    PCLASS              pClasses;
    U032                numClasses;
    PENGINEINFO         pEngineInfos;

    PCLASSDESCRIPTOR    pClassDescriptors;
    U032                numClassDescriptors;
    PENGINEDESCRIPTOR   pEngineDescriptors;
    U032                numEngineDescriptors;
#endif

    HALHWINFO           halHwInfo;
    VOID_PTR            pHalEngineMem;
    PHALFUNCS           pHalFuncs;

    U008               *EDIDBuffer;
    U032                I2CAcquired;

    U032                DBdevInstance;
    U032                biosOffset;                   // has bios been relocated within rom?

    VOID_PTR			  pRmInfo;						// pointer to our system information (RMINFO NvRmInfo)
    VOID_PTR			  pOsHwInfo;					// pointer to our OS dependant information

    // Can't move this to WINNTHWINFO currently because of a hack in state.c
#ifdef NTRM
    VOID*				  DBmpDeviceExtension;			// miniport device extension
#endif

    // These will be moved to the MACOS9HWINFO
#ifdef MACOS
    BOOL                DBrmInitialized;              // per device init flag
    VOID*               DBmpDeviceExtension;          // os's device extension
#endif

#ifdef STEREO_SUPPORT
    //Stereo stuff
    LPNV_CFG_STEREO_PARAMS	pStereoParams;
#endif //STEREO_SUPPORT

} HWINFO;

// This macro will produce a divide by 0 error at compile time if the sizeof HWINFO
// struct is not a multiple of 4. However, it does not help if some sub struct of
// HWINFO is not aligned properly.
#define ASSERT_NVINFO_SIZE if (1/((sizeof(HWINFO) % 4) ? 0 : 1))

#ifndef JV
#ifndef LEGACY_ARCH
#define MAX_INSTANCE 8
#define TEST_DEVICE_NUM 0
#else
#define MAX_INSTANCE 1
#endif
extern  U032   ClientInstance;
extern  PHWINFO NvDBPtr_Table[MAX_INSTANCE];
extern	RMINFO	NvRmInfo;
#endif // JV

// nv10 needs 2 dwords, but nv4 only needs one, so we'll rename one of the
// fields to be the nv4 define
#define VideoScale                   VideoScaleX
#define Buff0VideoScale              Buff0VideoScaleX
#define Buff1VideoScale              Buff1VideoScaleX
#define nvAddr                       pDev->DBnvAddr 
#define romAddr                      pDev->DBromAddr
#define biosAddr                     pDev->DBbiosAddr
#define fbAddr                       pDev->DBfbAddr 
#define CurDacAdr(Head)              GETCRTCHALINFO(pDev,Head,RegOffset)
#define NUM_FIFOS                    pDev->Fifo.HalInfo.Count
#define devInstance                  pDev->DBdevInstance

// Things that were moved from nvarch.h
#define NV10_CHIP_ARCHITECTURE          0x10

// HW description
// TO DO: change this to DEVICE_EXTENT of instance memory so that we will ALWAYS map enuff memory
#define NV_DEVICE_SIZE                   0x740000		// 7M of regs + 256K of instance mem (first 64K is BIOS)
#define INSTANCE_MEMORY_BASE             (pDev->Mapping.PhysAddr + pDev->Pram.HalInfo.PraminOffset)
#define INSTANCE_MEMORY_PHYSICAL_BASE(d) ((d)->Mapping.PhysAddr + pDev->Pram.HalInfo.PraminOffset)
#define INSTANCE_MEMORY_LOGICAL_BASE(d)  ((U008*)(d)->DBnvAddr + pDev->Pram.HalInfo.PraminOffset)
#define INSTANCE_MEMORY_SIZE             0x40000        // 256K
#define ROM_SIZE                         0x8000
#define CHANNEL_LENGTH                   0x10000        // 64K
#define INT_A                            0x01
#define FIFO_USER_BASE(d)                (d->Fifo.HalInfo.UserBase)

#endif // RM_HEADERS_MINIMAL
#endif // _NVRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nvhal.h ===
#ifndef _NVHAL_H_
#define _NVHAL_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV HAL Defines and Structures ********************\
*                                                                           *
* Module: nvhal.h                                                           *
*       HAL interface defines and structures.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//
// HAL Interface Id:
//
//  31      27                              11                     0
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  | 4 bits| 16 bits                       | 12 bits               |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   Engine  Function number         Function revision
//
// Engine tag: unique engine tag
// Function number: unique interface number
// Function revision: specific revision of interface
//
typedef U032    NV_HAL_ID;

#define MKHALID(eng,func,rev)           (eng << 28 | func << 12 | rev)

//
// Engine tags to be used by both RM/HAL to reference specific engines.
//
// These values are used in the engine descriptor table (see nvromdat.h>
// as well as in the class descriptor table.
//
// WARNING: There are exactly 4 bits for the engine tags.
//
#define MC_ENGINE_TAG                   0x1
#define FB_ENGINE_TAG                   0x2
#define DAC_ENGINE_TAG                  0x3
#define TMR_ENGINE_TAG                  0x4
#define DMA_ENGINE_TAG                  0x5
#define GR_ENGINE_TAG                   0x6
#define FIFO_ENGINE_TAG                 0x7
#define MP_ENGINE_TAG                   0x8
#define VIDEO_ENGINE_TAG                0x9

//
// These are "special" tags for classes that don't need true
// engine handling.
//

// This tag is for the NV_CLASS "pseudo" class.
#define CLASS_PSEUDO_ENGINE_TAG         0xe
// This tag is for the memory classes etc.
#define NO_ENGINE                       0xf

//
// Forwards.
//
typedef struct _def_hal_hw_info HALHWINFO, *PHALHWINFO;
typedef struct _def_hal_rm_funcs_000 HALRMFUNCS_000, *PHALRMFUNCS_000;
typedef VOID *PHALRMFUNCS;

//--------------------------------------------------------------------
// Processor info
//--------------------------------------------------------------------
typedef struct _def_processor_hal_info
{
    U032 FrontSideBusFreq;
    U032 SystemMemoryFreq;
} PROCESSORHALINFO, *PPROCESSORHALINFO;

//--------------------------------------------------------------------
// Mc
//--------------------------------------------------------------------

// Current HAL mc interface revision ids.
#define MC_CONTROL_000                  MKHALID(MC_ENGINE_TAG,0x0001,0)
#define MC_POWER_000                    MKHALID(MC_ENGINE_TAG,0x0002,0)

typedef struct _def_mc_hal_info
{   
    U032 Implementation;
    U032 Revision;
    U032 Subrevision;
    U032 Architecture;
    U032 Manufacturer;
    U032 MaskRevision;
    U032 CrystalFreq;
    U032 PCIDeviceID;
    U032 PCISubDeviceID;
    U032 EndianControl;
	U032 ChipBugs;
} MCHALINFO, *PMCHALINFO;

#define MCHALINFO(nvinfo,a)             (nvinfo->Chip.HalInfo.a)

// Endian control records current endian-ness of the NV chip as
// well as how we were compiled (big or little endian).  We need
// to know this information early in the init process.

#define MC_ENDIAN_CONTROL_CHIP_BIG_ENDIAN         BIT(0)
#define MC_ENDIAN_CONTROL_CODE_BIG_ENDIAN         BIT(1)
#define MC_ENDIAN_CONTROL_ALL_BIG_ENDIAN          BIT(2)  // bit0 & bit1
#define MC_ENDIAN_CONTROL_SWAP_REQUIRED           BIT(3)  // bit0 ^ bit1

// Chip bugs that are tracked in MCHALINFO.ChipBugs
// If bit is set, that bug is an issue for this device

#define ChipBugs       MCHALINFO(pDev, ChipBugs)

#define MC_BUG_NV11_BIG_ENDIAN_PCI_CONFIG_READS   BIT(0)

//
// MC_CONTROL parameters.
//
typedef struct _def_mc_control_arg_000
{
    NV_HAL_ID id;                       // MC_CONTROL_000
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} MCCONTROLARG_000, *PMCCONTROLARG_000;

// MC_CONTROL commands.
#define MC_CONTROL_UPDATE               1
#define MC_CONTROL_LOAD                 2
#define MC_CONTROL_UNLOAD               3
#define MC_CONTROL_DESTROY              4
#define MC_CONTROL_INIT                 5
#define MC_CONTROL_SETREVISION          6

//
// MC_POWER parameters.
//
typedef struct _def_mc_power_arg_000
{
    NV_HAL_ID id;
    U032 newLevel;
    U032 oldLevel;
    PHALHWINFO pHalHwInfo;
} MCPOWERARG_000, *PMCPOWERARG_000;

// Power management states.
#define MC_POWER_LEVEL_0                0
#define MC_POWER_LEVEL_1                1
#define MC_POWER_LEVEL_2                2
#define MC_POWER_LEVEL_3                3
#define MC_POWER_LEVEL_4                4

//
// HAL wrappers.
//
RM_STATUS nvHalMcControl(PHWINFO, U032);
RM_STATUS nvHalMcPower(PHWINFO, U032, U032);

//--------------------------------------------------------------------
// Pram
//--------------------------------------------------------------------
typedef struct _def_pram_hal_info
{
    U032 InstPadSize;
    U032 TotalInstSize;
    U032 CurrentSize;
    U032 HashDepth;
    U032 HashSearch;
    U032 PraminOffset;
} PRAMHALINFO, *PPRAMHALINFO;

//--------------------------------------------------------------------
// Fifo
//--------------------------------------------------------------------

// Current HAL fifo interface revision ids.
#define FIFO_CONTROL_000                MKHALID(FIFO_ENGINE_TAG,0x0001,0x0)
#define FIFO_ALLOC_PIO_000              MKHALID(FIFO_ENGINE_TAG,0x0002,0x0)
#define FIFO_ALLOC_DMA_000              MKHALID(FIFO_ENGINE_TAG,0x0003,0x0)
#define FIFO_FREE_000                   MKHALID(FIFO_ENGINE_TAG,0x0004,0x0)
#define FIFO_GET_EXCEPTION_DATA_000     MKHALID(FIFO_ENGINE_TAG,0x0005,0x0)
#define FIFO_SERVICE_000                MKHALID(FIFO_ENGINE_TAG,0x0006,0x0)
#define FIFO_ACCESS_000                 MKHALID(FIFO_ENGINE_TAG,0x0007,0x0)
#define FIFO_HASH_ADD_000               MKHALID(FIFO_ENGINE_TAG,0x0008,0x0)
#define FIFO_HASH_DELETE_000            MKHALID(FIFO_ENGINE_TAG,0x0009,0x0)
#define FIFO_HASH_FUNC_000              MKHALID(FIFO_ENGINE_TAG,0x000a,0x0)
#define FIFO_HASH_SEARCH_000            MKHALID(FIFO_ENGINE_TAG,0x000b,0x0)

// Fifo HAL state info structure.
typedef struct _def_fifo_hal_info
{
    U032 IntrEn0;                       // interrupt enable mask
    U032 AllocateCount;
    U032 Count;                         // total available fifos
    U032 ContextSize;                   // per-fifo context size
    U032 RetryCount;
    U032 UserBase;                      // offset of user channel area
} FIFOHALINFO, *PFIFOHALINFO;

#define FIFOHALINFO(nvinfo,a)            (nvinfo->Fifo.StateInfo.a)

//
// FIFO_CONTROL_000 parameters.
//
typedef struct _def_fifo_control_arg_000
{
    NV_HAL_ID id;                       // FIFO_CONTROL_000
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} FIFOCONTROLARG_000, *PFIFOCONTROLARG_000;

// FIFO_CONTROL commands.
#define FIFO_CONTROL_UPDATE             1
#define FIFO_CONTROL_LOAD               2
#define FIFO_CONTROL_UNLOAD             3
#define FIFO_CONTROL_DESTROY            4
#define FIFO_CONTROL_INIT               5

//
// FIFO_ALLOC_PIO_000 parameters.
//
typedef struct _def_fifo_alloc_pio_arg_000 {
    NV_HAL_ID id;
    U032 chid;
    U032 instance;
    PHALHWINFO pHalHwInfo;
} FIFOALLOCPIOARG_000, *PFIFOALLOCPIOARG_000;

//
// FIFO_ALLOC_DMA_000 parameters.
//
typedef struct _def_fifo_alloc_dma_arg_000
{
    NV_HAL_ID id;
    U032 chid;
    U032 instance;
    U032 dmaInstance;
    U032 fetchTrigger;
    U032 fetchSize;
    U032 fetchRequests;
    PHALHWINFO pHalHwInfo;
} FIFOALLOCDMAARG_000, *PFIFOALLOCDMAARG_000;

//
// FIFO_FREE_000 parameters.
//
typedef struct _def_fifo_free_arg_000
{
    NV_HAL_ID id;
    U032 chid;
    U032 instance;
    PHALHWINFO pHalHwInfo;
} FIFOFREEARG_000, *PFIFOFREEARG_000;

//
// FIFO_ACCESS_000 parameters.
//

typedef struct _def_fifo_access_info
{
    U032 FifoReassign;
    U032 FifoPush;
    U032 FifoPull;
} FIFOACCESSINFO, *PFIFOACCESSINFO;

typedef struct _def_fifo_access_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PFIFOACCESSINFO pAccessInfo;
    PHALHWINFO pHalHwInfo;
} FIFOACCESSARG_000, *PFIFOACCESSARG_000;

// FIFO_ACCESS commands.
#define FIFO_ACCESS_DISABLE             0x0
#define FIFO_ACCESS_ENABLE              0x1

//
// FIFO_GET_EXCEPTION_DATA_000 parameters.
//
typedef struct _def_fifo_exception_data
{
    U032 Reason;
    U032 ChID;
    U032 GetPtr;
    U032 SubChannel;
    U032 Method;
    U032 Data;
} FIFOEXCEPTIONDATA, *PFIFOEXCEPTIONDATA;

typedef struct _def_fifo_get_exception_data_arg_000
{
    NV_HAL_ID id;
    PFIFOEXCEPTIONDATA pExceptionData;
    PHALHWINFO pHalHwInfo;
} FIFOGETEXCEPTIONDATAARG_000, *PFIFOGETEXCEPTIONDATAARG_000;

//
// FIFO_SERVICE_000 parameters.
//
typedef struct _def_fifo_service_arg_000
{
    NV_HAL_ID id;
    U032 intr;
    PFIFOEXCEPTIONDATA pExceptionData;
    PHALHWINFO pHalHwInfo;
} FIFOSERVICEARG_000, *PFIFOSERVICEARG_000;

//
// FIFO_HASH_ADD_000 parameters.
//
typedef struct _def_fifo_hash_add_arg_000
{
    NV_HAL_ID id;
    U032 entry;
    U032 handle;
    U032 chid;
    U032 instance;
    U032 engine;
    PHALHWINFO pHalHwInfo;
} FIFOHASHADDARG_000, *PFIFOHASHADDARG_000;

//
// FIFO_HASH_DELETE_000 parameters.
//
typedef struct _def_fifo_hash_delete_arg_000
{
    NV_HAL_ID id;
    U032 entry;
    PHALHWINFO pHalHwInfo;
} FIFOHASHDELETEARG_000, *PFIFOHASHDELETEARG_000;

//
// FIFO_HASH_FUNC_000 parameters.
//
typedef struct _def_fifo_hash_func_arg_000
{
    NV_HAL_ID id;
    U032 handle;
    U032 chid;
    U032 result;
    PHALHWINFO pHalHwInfo;
} FIFOHASHFUNCARG_000, *PFIFOHASHFUNCARG_000;

//
// FIFO_HASH_FUNC_000 parameters.
//
typedef struct _def_fifo_hash_search_arg_000
{
    NV_HAL_ID id;
    U032 handle;
    U032 chid;
    U032 result;
    PHALHWINFO pHalHwInfo;
} FIFOHASHSEARCHARG_000, *PFIFOHASHSEARCHARG_000;

// FIFO HAL wrappers.
RM_STATUS nvHalFifoControl(PHWINFO, U032);
RM_STATUS nvHalFifoAllocPio(PHWINFO, U032, U032);
RM_STATUS nvHalFifoAllocDma(PHWINFO, U032, U032, U032, U032, U032, U032);
RM_STATUS nvHalFifoFree(PHWINFO, U032, U032);
RM_STATUS nvHalFifoGetExceptionData(PHWINFO, PFIFOEXCEPTIONDATA);
RM_STATUS nvHalFifoService(PHWINFO, U032, PFIFOEXCEPTIONDATA);
RM_STATUS nvHalFifoAccess(PHWINFO, U032, PFIFOACCESSINFO);
RM_STATUS nvHalFifoHashAdd(PHWINFO, U032, U032, U032, U032, U032);
RM_STATUS nvHalFifoHashDelete(PHWINFO, U032);
RM_STATUS nvHalFifoHashFunc(PHWINFO, U032, U032, U032 *);
RM_STATUS nvHalFifoHashSearch(PHWINFO, U032, U032, U032 *);

//--------------------------------------------------------------------
// Framebuffer
//--------------------------------------------------------------------

// Current HAL gr interface revision ids.
#define FB_CONTROL_000                  MKHALID(FB_ENGINE_TAG,0x0001,0x0)
#define FB_SET_ALLOC_PARAMS_000         MKHALID(FB_ENGINE_TAG,0x0002,0x0)
#define FB_ALLOC_000                    MKHALID(FB_ENGINE_TAG,0x0003,0x0)
#define FB_FREE_000                     MKHALID(FB_ENGINE_TAG,0x0004,0x0)
#define FB_GET_SURFACE_PITCH_000        MKHALID(FB_ENGINE_TAG,0x0005,0x0)
#define FB_LOAD_OVERRIDE_000            MKHALID(FB_ENGINE_TAG,0x0006,0x0)
#define FB_GET_SURFACE_DIMENSIONS_000   MKHALID(FB_ENGINE_TAG,0x0007,0x0)

//
// Moving forward, nv chips will support fb sizes that are no longer
// powers of 2 (i.e. the external banks have different sizes).
//
#define MAX_EXTBANKS                    2

typedef struct _def_fb_extbank_hal_info
{
    U032 size;                          // size of bank
    U032 intBanks;                      // number of bank addressing bits
} FBEXTBANKHALINFO, *PFBEXTBANKHALINFO;

// FB allocation resources structure.
typedef struct _def_fb_alloc_info
{
    U032 type;
    U032 hwResId;
    U032 height;
    U032 pitch;    
    U032 size;
    U032 align;
    U032 offset;
    //U032 limit;
} FBALLOCINFO, *PFBALLOCINFO;

typedef struct _def_fb_hal_info
{   
    U032 RamSizeMb;                     // combined size of all extbanks (Mb)
    U032 RamSize;                       // combined size of all extbanks
    U032 RamType;                       // sdram vs ddr
    U032 ExtBankCount;                  // number of external banks
    U032 BankCount;                     // number of internal banks
    U032 Depth;
    U032 HorizDisplayWidth;
    U032 VertDisplayWidth;
    U032 RefreshRate;
    U032 Start[2];
    U032 Limit[2];
    FBEXTBANKHALINFO ExtBankInfo[MAX_EXTBANKS];
    FBALLOCINFO PrimaryFbAllocInfo[2];  // This should be MAX_CRTCS
} FBHALINFO, *PFBHALINFO;

//
// Use the following for display types.
//
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3
#define DISPLAY_TYPE_NONE             (~0)

//
// Use the following for monitor types.
//
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

#define FBHALINFO(nvinfo,a)              (nvinfo->Framebuffer.HalInfo.a)

//
// FB_CONTROL_000 parameters.
//
typedef struct _def_fb_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} FBCONTROLARG_000, *PFBCONTROLARG_000;

// FB_CONTROL commands.
#define FB_CONTROL_UPDATE               1
#define FB_CONTROL_LOAD                 2
#define FB_CONTROL_UNLOAD               3
#define FB_CONTROL_DESTROY              4
#define FB_CONTROL_INIT                 5
#define FB_CONTROL_INSTWR_DISABLE       6
#define FB_CONTROL_INSTWR_ENABLE        7
#define FB_CONTROL_TILING_DISABLE       8
#define FB_CONTROL_TILING_ENABLE        9
#define FB_CONTROL_TILING_CONFIGURE     10

//
// FB_SET_ALLOC_PARAMS_000 parameters.
//
typedef struct _def_fb_set_alloc_params_arg_000
{
    NV_HAL_ID id;
    PFBALLOCINFO pAllocInfo;
    PHALHWINFO pHalHwInfo;
} FBSETALLOCPARAMSARG_000, *PFBSETALLOCPARAMSARG_000;

//
// FB_ALLOC_000 parameters.
//
typedef struct _def_fb_alloc_arg_000
{
    NV_HAL_ID id;
    U032 flags;
    PFBALLOCINFO pAllocInfo;
    PHALHWINFO pHalHwInfo;
} FBALLOCARG_000, *PFBALLOCARG_000;

//
// Flags.
//
#define FB_ALLOC_NO_PITCH_ADJUST                0x01

//
// FB_FREE_000 parameters.
//
typedef struct _def_fb_free_arg_000
{
    NV_HAL_ID id;
    U032 hwResId;
    PHALHWINFO pHalHwInfo;
} FBFREEARG_000, *PFBFREEARG_000;

//
// FB_GET_SURFACE_PITCH_000 parameters.
//
typedef struct _def_fb_get_surface_pitch_arg_000
{
    NV_HAL_ID id;
    U032 flags;
    U032 width;
    U032 bpp;
    U032 pitch;
    PHALHWINFO pHalHwInfo;
} FBGETSURFACEPITCHARG_000, *PFBGETSURFACEPITCHARG_000;

//
// FB_GET_SURFACE_DIMENSIONS_000 parameters.
//
typedef struct _def_fb_get_surface_dimensions_arg_000
{
    NV_HAL_ID id;
    U032 flags;
    U032 width;
    U032 height;
    U032 bpp;
    U032 pitch;
    U032 size;
    PHALHWINFO pHalHwInfo;
} FBGETSURFACEDIMENSIONSARG_000, *PFBGETSURFACEDIMENSIONSARG_000;

//
// Flags.
//
#define FB_GET_SURFACE_PITCH_NO_ADJUST          0x01

//
// FB_LOAD_OVERRIDE_000 parameters.
//
typedef struct _def_fb_load_override_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    U032 value;
    PHALHWINFO pHalHwInfo;
} FBLOADOVERRIDEARG_000, *PFBLOADOVERRIDEARG_000;

// FB_LOAD_OVERRIDE commands.
#define FB_LOAD_OVERRIDE_MEMORY         1
#define FB_LOAD_OVERRIDE_RTL            2

// FB HAL wrappers.
RM_STATUS nvHalFbControl(PHWINFO, U032);
RM_STATUS nvHalFbAlloc(PHWINFO, PFBALLOCINFO);
RM_STATUS nvHalFbFree(PHWINFO, U032);
RM_STATUS nvHalFbSetAllocParameters(PHWINFO, PFBALLOCINFO);
RM_STATUS nvHalFbGetSurfacePitch(PHWINFO, U032, U032, U032 *);
RM_STATUS nvHalFbGetSurfaceDimensions(PHWINFO, U032, U032, U032, U032 *, U032 *);
RM_STATUS nvHalFbLoadOverride(PHWINFO, U032, U032);

//--------------------------------------------------------------------
// Graphics
//--------------------------------------------------------------------

// Graphics engine state info structure.
typedef struct _def_gr_hal_info
{
    U032 CurrentChID;
#if MAX_FIFOS <= 32
    U032 has3dObject;       // bitmask of chIDs containing 3d objs
#endif
} GRHALINFO, *PGRHALINFO;

#define GRHALINFO(nvinfo,a)             (nvinfo.Graphics.HalInfo.a)

// Current HAL gr interface revision ids.
#define GR_CONTROL_000                  MKHALID(GR_ENGINE_TAG,0x0001,0x0)
#define GR_ALLOC_000                    MKHALID(GR_ENGINE_TAG,0x0002,0x0)
#define GR_FREE_000                     MKHALID(GR_ENGINE_TAG,0x0003,0x0)
#define GR_GET_EXCEPTION_DATA_000       MKHALID(GR_ENGINE_TAG,0x0004,0x0)
#define GR_SERVICE_000                  MKHALID(GR_ENGINE_TAG,0x0005,0x0)
#define GR_GET_NOTIFY_DATA_000          MKHALID(GR_ENGINE_TAG,0x0006,0x0)
#define GR_SET_OBJECT_CONTEXT_000       MKHALID(GR_ENGINE_TAG,0x0007,0x0)
#define GR_LOAD_OVERRIDE_000            MKHALID(GR_ENGINE_TAG,0x0008,0x0)

//
// GR_CONTROL_000 parameters.
//
typedef struct _def_gr_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} GRCONTROLARG_000, *PGRCONTROLARG_000;

// GR_CONTROL commands.
#define GR_CONTROL_UPDATE               1
#define GR_CONTROL_LOAD                 2
#define GR_CONTROL_UNLOAD               3
#define GR_CONTROL_DESTROY              4
#define GR_CONTROL_INIT                 5

//
// GR_ALLOC_000 parameters.
//
typedef struct _def_gr_alloc_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    PHALHWINFO pHalHwInfo;
} GRALLOCARG_000, *PGRALLOCARG_000;

//
// GR_FREE_000 parameters.
//
typedef struct _def_gr_free_arg_000
{
    NV_HAL_ID id;
    U032 instance;
    U032 chid;
    PHALHWINFO pHalHwInfo;
} GRFREEARG_000, *PGRFREEARG_000;

//
// Graphics engine exception data.
//
typedef struct _def_gr_exception_data
{
    U032 classNum;
    U032 NotifyInstance;
    U032 Nsource;
    U032 Instance;
    U032 Offset;
    U032 Data;
    U032 ChID;
    U032 MethodStatus;
} GREXCEPTIONDATA, *PGREXCEPTIONDATA;

//
// GR_GET_EXCEPTION_DATA_000 parameters.
//
typedef struct _def_gr_get_exception_data_arg_000
{
    NV_HAL_ID id;
    PGREXCEPTIONDATA pExceptionData;
    PHALHWINFO pHalHwInfo;
} GRGETEXCEPTIONDATAARG_000, *PGRGETEXCEPTIONDATAARG_000;

//
// The following is used to setup object method handling in the
// HAL.
//
typedef RM_STATUS (*HALGRMETHODPROC)(PHALHWINFO, PGREXCEPTIONDATA);

typedef struct _def_hal_gr_method
{
    HALGRMETHODPROC Proc;
    U032 Low;
    U032 High;    
} HALGRMETHOD, *PHALGRMETHOD;

typedef struct _def_hal_gr_methods
{
    U032 classNum;
    PHALGRMETHOD pMethods;
    U032 methodMax;
} HALGRMETHODS, *PHALGRMETHODS;

//
// GR_SERVICE_000 parameters.
//
typedef struct _def_gr_service_arg_000
{
    NV_HAL_ID id;
    U032 intr;
    PGREXCEPTIONDATA pExceptionData;
    PHALHWINFO pHalHwInfo;
} GRSERVICEARG_000, *PGRSERVICEARG_000;

//
// GR_GET_NOTIFY_DATA_000 parameters.
//
typedef struct _def_gr_notify_data
{
    U032 trigger;
    U032 action;
} GRNOTIFYDATA, *PGRNOTIFYDATA;

typedef struct _def_gr_get_notify_data_arg_000
{
    NV_HAL_ID id;
    PGRNOTIFYDATA pGrNotifyData;
    PHALHWINFO pHalHwInfo;
} GRGETNOTIFYDATAARG_000, *PGRGETNOTIFYDATAARG_000;

//
// GR_SET_OBJECT_CONTEXT_000 parameters.
//
typedef struct _def_gr_set_object_context_arg_000
{
    NV_HAL_ID id;
    U032 andMask;
    U032 orMask;
    U032 instance;
    U032 chid;
    PHALHWINFO pHalHwInfo;
} GRSETOBJECTCONTEXTARG_000, *PGRSETOBJECTCONTEXTARG_000;

//
// GR_LOAD_OVERRIDE_000 parameters.
//
typedef struct _def_gr_load_override_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    U032 value;
    PHALHWINFO pHalHwInfo;
} GRLOADOVERRIDEARG_000, *PGRLOADOVERRIDEARG_000;

// GR_LOAD_OVERRIDE commands.
#define GR_LOAD_OVERRIDE_DEBUG0         1
#define GR_LOAD_OVERRIDE_DEBUG1         2
#define GR_LOAD_OVERRIDE_DEBUG2         3
#define GR_LOAD_OVERRIDE_DEBUG3         4
#define GR_LOAD_OVERRIDE_SWATHCTL       5

#define SWATH_CONTROL_VALID_BIT         (1 << 31)

// HAL wrappers.
RM_STATUS nvHalGrControl(PHWINFO, U032);
RM_STATUS nvHalGrAlloc(PHWINFO, U032, U032, U032);
RM_STATUS nvHalGrFree(PHWINFO, U032, U032);
RM_STATUS nvHalGrGetExceptionData(PHWINFO, PGREXCEPTIONDATA);
RM_STATUS nvHalGrService(PHWINFO, U032, PGREXCEPTIONDATA);
RM_STATUS nvHalGrGetNotifyData(PHWINFO, PGRNOTIFYDATA);
RM_STATUS nvHalGrSetObjectContext(PHWINFO, U032, U032, U032, U032);
RM_STATUS nvHalGrLoadOverride(PHWINFO, U032, U032);

//--------------------------------------------------------------------
// Dma
//--------------------------------------------------------------------

// Current HAL dma interface revision ids.
#define DMA_CONTROL_000                 MKHALID(DMA_ENGINE_TAG,0x0001,0x0)
#define DMA_ALLOC_000                   MKHALID(DMA_ENGINE_TAG,0x0002,0x0)
#define DMA_FREE_000                    MKHALID(DMA_ENGINE_TAG,0x0003,0x0)
#define DMA_GET_INSTSIZE_000            MKHALID(DMA_ENGINE_TAG,0x0004,0x0)

typedef struct _def_dma_hal_obj_info DMAHALOBJINFO, *PDMAHALOBJINFO;

//
// DMA engine state info.
//
// We need to use a U032 here to ensure pointer size argreement
// across 16 and 32 bit land.
// 
typedef struct _def_dma_hal_info
{
    VOID_PTR pDmaHalObjInfos;     // pointer to list of dma context objects
} DMAHALINFO, *PDMAHALINFO;

//
// DMA_CONTROL_000 parameters.
//
typedef struct _def_dma_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} DMACONTROLARG_000, *PDMACONTROLARG_000;

// DMA_CONTROL commands.
#define DMA_CONTROL_UPDATE              1
#define DMA_CONTROL_LOAD                2
#define DMA_CONTROL_UNLOAD              3
#define DMA_CONTROL_DESTROY             4
#define DMA_CONTROL_INIT                5

// Context dma address space identifiers.
typedef U032       NV_ADDRESS_SPACE;
#define ADDR_UNKNOWN 0              // Address space is unknown
#define ADDR_SYSMEM  1              // System memory (PCI)
#define ADDR_FBMEM   2              // Frame buffer memory space
#define ADDR_AGPMEM  3              // AGP memory space

struct _def_dma_hal_obj_info
{
    U032 classNum;                  // Class number
    U032 Flags;                     // API flags (coherency, access, etc)
    VOID_PTR BufferBase;            // Base address of client buffer
    U032 BufferSize;                // Size of client buffer
    U032 Instance;                  // Pointer to instance memory context
    U032 NumUnits;                  // Size of instance memory
    U032 PteCount;                  // Number of pages in dma context
    U032 PteAdjust;                 // Offset within first page
    U032 PteLimit;                  // Length of dma context
    U032 *PteArray;                 // Page data
    U032 MemoryClass;               // Class number of underlying memory
    NV_ADDRESS_SPACE AddressSpace;  // Address space of context
    PDMAHALOBJINFO Next;            // Next in list
};

//
// DMA_ALLOC_000 parameters.
//
typedef struct _def_dma_alloc_arg_000
{
    NV_HAL_ID id;
    PDMAHALOBJINFO pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DMAALLOCARG_000, *PDMAALLOCARG_000;

//
// DMA_FREE_000 parameters.
//
typedef struct _def_dma_free_arg_000
{
    NV_HAL_ID id;
    PDMAHALOBJINFO pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DMAFREEARG_000, *PDMAFREEARG_000;

//
// DMA_GETINSTSIZE_000 parameters.
//
typedef struct _def_dma_getinstsize_arg_000
{
    NV_HAL_ID id;
    PDMAHALOBJINFO pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DMAGETINSTSIZEARG_000, *PDMAGETINSTSIZEARG_000;

RM_STATUS nvHalDmaControl(PHWINFO, U032);
RM_STATUS nvHalDmaAlloc(PHWINFO, PDMAHALOBJINFO);
RM_STATUS nvHalDmaFree(PHWINFO, PDMAHALOBJINFO);
RM_STATUS nvHalDmaGetInstSize(PHWINFO, PDMAHALOBJINFO);

//--------------------------------------------------------------------
// Dac
//--------------------------------------------------------------------

// Current HAL dac interface revision ids.
#define DAC_CONTROL_000                 MKHALID(DAC_ENGINE_TAG,0x0001,0x0)
#define DAC_ALLOC_000                   MKHALID(DAC_ENGINE_TAG,0x0002,0x0)
#define DAC_FREE_000                    MKHALID(DAC_ENGINE_TAG,0x0003,0x0)
#define DAC_SET_START_ADDR_000          MKHALID(DAC_ENGINE_TAG,0x0004,0x0)
#define DAC_PROGRAMMCLK_000             MKHALID(DAC_ENGINE_TAG,0x0005,0x0)
#define DAC_PROGRAMNVCLK_000            MKHALID(DAC_ENGINE_TAG,0x0006,0x0)
#define DAC_PROGRAMPCLK_000             MKHALID(DAC_ENGINE_TAG,0x0007,0x0)
#define DAC_PROGRAMCURSOR_000           MKHALID(DAC_ENGINE_TAG,0x0008,0x0)
#define DAC_RASTERPOS_000               MKHALID(DAC_ENGINE_TAG,0x0009,0x0)
#define DAC_VALIDATEARBSETTINGS_000     MKHALID(DAC_ENGINE_TAG,0x000a,0x0)
#define DAC_UPDATEARBSETTINGS_000       MKHALID(DAC_ENGINE_TAG,0x000b,0x0)

//
// HAL VIDEO_LUT_CURSOR_DAC object.
//
typedef struct _def_video_lut_cursor_dac_hal_object
{
    U032 Head;

    struct {
        U032       VisibleImageWidth;    
        U032       VisibleImageHeight;   
        U032       HorizontalBlankStart;
        U032       HorizontalBlankWidth;
        U032       HorizontalSyncStart;
        U032       HorizontalSyncWidth;
        U032       VerticalBlankStart; 
        U032       VerticalBlankHeight; 
        U032       VerticalSyncStart; 
        U032       VerticalSyncHeight; 
        U032       TotalWidth; 
        U032       TotalHeight;     
        U032       PixelClock;
        U032       ColorFormat;                  
        U032       PixelDepth;
        struct {
            unsigned int DoubleScanMode         : 1;
            unsigned int InterlacedMode         : 1;
            unsigned int HorizontalSyncPolarity : 1;
            unsigned int VerticalSyncPolarity   : 1;
            unsigned int unusedBits1            : 12;
            unsigned int unusedBits2            : 16;
        } Format;
    }  Dac[2];

} VIDEO_LUT_CURSOR_DAC_HAL_OBJECT, *PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT;

// This constant defines the maximum number of crtcs on any
// chip supported by this HAL revision.  An increase in this
// value means a new revision of the DAC section of the HAL.
//
#define MAX_CRTCS                       2

//
// There are MAX_CRTCS of these structures.
//
typedef struct _def_dac_crtc_hal_info
{
    #define DISPLAYTYPEBIT(d)   (1 << d)

    U032 DisplayType;
    U032 MonitorType;
    U032 DisplayTypesAllowed;
    U032 PCLKLimit8bpp;
    U032 PCLKLimit16bpp;
    U032 PCLKLimit32bpp;
    U032 RegOffset;
 
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pVidLutCurDac;

} DACCRTCHALINFO, *PDACCRTCHALINFO;

typedef struct _def_dac_hal_info
{
    U032 InputWidth;
    U032 Depth;
    U032 MClk;
    U032 VClk;
    U032 NVClk;
    U032 MPllM;
    U032 MPllN;
    U032 MPllO;
    U032 MPllP;
    U032 VPllM;
    U032 VPllN;
    U032 VPllO;
    U032 VPllP;
    U032 NVPllM;
    U032 NVPllN;
    U032 NVPllO;
    U032 NVPllP;
    U032 NumCrtcs;
    U032 Head2RegOwner;                 // cr44 shadow; toggled for CXXXXX IOs
    U032 InitialBootHead;
    U032 Enable256Burst;
    U032 PixelClock;
    DACCRTCHALINFO CrtcInfo[MAX_CRTCS];
} DACHALINFO, *PDACHALINFO;

// Until an EnableHead is called, the Head2RegOwner is unknown
#define HEAD2_OWNER_UNKNOWN    0xFFFFFFFF

//
// Use these for convenient access to HAL data from within RM (i.e.
// these require a pDev).
//
#define DACHALINFO(nvinfo,a)            (nvinfo->Dac.HalInfo.a)
#define GETCRTCHALINFO(nvinfo,c,a)      (nvinfo->Dac.HalInfo.CrtcInfo[c].a)

#define GETDISPLAYTYPE(nvinfo, c)		(nvinfo->Dac.HalInfo.CrtcInfo[c].DisplayType)
#define SETDISPLAYTYPE(nvinfo, c, v)	(nvinfo->Dac.HalInfo.CrtcInfo[c].DisplayType = v)

#define GETMONITORTYPE(nvinfo, c)		(nvinfo->Dac.HalInfo.CrtcInfo[c].MonitorType)
#define SETMONITORTYPE(nvinfo, c, v)	(nvinfo->Dac.HalInfo.CrtcInfo[c].MonitorType = v)

// HAL versions
#define HAL_GETDISPLAYTYPE(c)		    (pDacHalInfo->CrtcInfo[c].DisplayType)

//
// DAC_CONTROL_000 parameters.
//
typedef struct _def_dac_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} DACCONTROLARG_000, *PDACCONTROLARG_000;

// DAC_CONTROL commands.
#define DAC_CONTROL_UPDATE              1
#define DAC_CONTROL_LOAD                2
#define DAC_CONTROL_UNLOAD              3
#define DAC_CONTROL_DESTROY             4
#define DAC_CONTROL_INIT                5

//
// Get head assignment for VIDEO_LUT_CURSOR_DAC_OBJECT.
//
#define DACGETHEAD(p)                   (p->HalObject.Head)

//
// DAC_ALLOC_000 parameters.
//
typedef struct _def_dac_alloc_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DACALLOCARG_000, *PDACALLOCARG_000;

//
// DAC_FREE_000 parameters.
//
typedef struct _def_dac_free_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DACFREEARG_000, *PDACFREEARG_000;

//
// DAC_SET_START_ADDR_000 parameters.
//
typedef struct _def_dac_set_start_addr_arg_000
{
    NV_HAL_ID id;
    U032 startAddr;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} DACSETSTARTADDRARG_000, *PDACSETSTARTADDRARG_000;

//
// DAC_PROGRAMMCLK_000
//
typedef struct _def_dac_program_mclk_000
{
    NV_HAL_ID id;
    PHALHWINFO pHalHwInfo;
} DACPROGRAMMCLKARG_000, *PDACPROGRAMMCLKARG_000;

//
// DAC_PROGRAMNVCLK_000
//
typedef struct _def_dac_program_nvclk_000
{
    NV_HAL_ID id;
    PHALHWINFO pHalHwInfo;
} DACPROGRAMNVCLKARG_000, *PDACPROGRAMNVCLKARG_000;

//
// DAC_PROGRAMPCLK_000
//
typedef struct _def_dac_program_pclk_000
{
    NV_HAL_ID id;
    PHALHWINFO pHalHwInfo;
    VOID    *pHalObjInfo;
    U032 PixelClock;
} DACPROGRAMPCLKARG_000, *PDACPROGRAMPCLKARG_000;

//
// DAC_PROGRAMCURSOR_000
//
typedef struct _def_dac_program_curosor_arg_000
{
    NV_HAL_ID id;
    PHALHWINFO pHalHwInfo;
    VOID    *pHalObjInfo;
    U032    startAddr; 
    U032    asi;          // Address space indicator: 0=Instance Mem, 1=Frame buffer
    U032    width; 
    U032    height; 
    U032    colorFormat;
} DACPROGRAMCURSORARG_000, *PDACPROGRAMCURSORARG_000;

#define DAC_ASI_INSTMEM 0
#define DAC_ASI_FRAMEBUFFER 1

//
// DAC_RASTERPOS_000
//
typedef struct _def_dac_raster_pos_arg_000
{
    NV_HAL_ID   id;
    PHALHWINFO  pHalHwInfo;
    VOID        *pHalObjInfo;
    U016        result;
} DACRASTERPOSARG_000, *PDACRASTERPOSARG_000;


//
// DAC_VALIDATEARBSETTINGS_000
//
typedef struct _def_dac_validate_arb_settings_arg_000
{
    NV_HAL_ID   id;
    PHALHWINFO  pHalHwInfo;
    U032        result;
    U032        bpp;
    U032        video_enabled;
    U032        mport_enabled;
    U032        vclk;
} DACVALIDATEARBSETTINGSARG_000, *PDACVALIDATEARBSETTINGSARG_000;

//
// DAC_UPDATEARBSETTINGS_000
//
typedef struct _def_dac_update_arb_settings_000
{
    NV_HAL_ID   id;
    PHALHWINFO  pHalHwInfo;
    VOID        *pHalObjInfo;
} DACUPDATEARBSETTINGSARG_000, *PDACUPDATEARBSETTINGSARG_000;


RM_STATUS nvHalDacControl(PHWINFO, U032);
RM_STATUS nvHalDacAlloc(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalDacFree(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalDacSetStartAddr(PHWINFO, U032, VOID *);
RM_STATUS nvHalDacProgramMClk(PHWINFO);
RM_STATUS nvHalDacProgramNVClk(PHWINFO);
RM_STATUS nvHalDacProgramPClk(PHWINFO, U032, VOID *);
RM_STATUS nvHalDacProgramCursorImage(PHWINFO, U032, U032, U032, U032, U032, VOID *);
RM_STATUS nvHalDacGetRasterPosition(PHWINFO, U016 *, VOID *);
RM_STATUS nvHalDacValidateArbSettings(PHWINFO, U032, U032, U032, U032, U032*);
RM_STATUS nvHalDacUpdateArbSettings(PHWINFO, VOID *);


//--------------------------------------------------------------------
// Mediaport
//--------------------------------------------------------------------

// Current HAL mediaport interface revision ids.
#define MP_CONTROL_000                  MKHALID(MP_ENGINE_TAG,0x0001,0x0)
#define MP_ALLOC_000                    MKHALID(MP_ENGINE_TAG,0x0002,0x0)
#define MP_FREE_000                     MKHALID(MP_ENGINE_TAG,0x0003,0x0)
#define MP_METHOD_000                   MKHALID(MP_ENGINE_TAG,0x0004,0x0)
#define MP_GET_EVENT_STATUS_000         MKHALID(MP_ENGINE_TAG,0x0005,0x0)
#define MP_SERVICE_EVENT_000            MKHALID(MP_ENGINE_TAG,0x0006,0x0)

//
// The data in this structure is shared by both the RM and HAL.
//
typedef struct _def_mp_hal_info
{
    U032 Enabled;
    U032 DetectEnable;
    U032 ImageBufferNumber;
    U032 MPCPresent;
    U032 MPCDeviceAddr;
} MPHALINFO, *PMPHALINFO;

//
// MP_CONTROL_000 parameters.
//
typedef struct _def_mp_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} MPCONTROLARG_000, *PMPCONTROLARG_000;

// MP_CONTROL commands.
#define MP_CONTROL_UPDATE               1
#define MP_CONTROL_LOAD                 2
#define MP_CONTROL_UNLOAD               3
#define MP_CONTROL_DESTROY              4
#define MP_CONTROL_INIT                 5

//
// HAL NV_EXTERNAL_VIDEO_DECODER object.
//
typedef struct _def_video_decoder_hal_object
{
    U032    ImageDataWidth;
    U032    Task;
    U032    NullData;
    U032    NullValue;
    U032    ImageStartLine;
    struct {
        U032    FirstLine;         
        U032    Height;           
        U032    Offset;
        U032    Pitch;
        U032    Field;
        U032    Notify;
        U032    GetOffsetData;
        PDMAHALOBJINFO   CtxDma; 
    } SetVbi[2];
    struct {
        U032    WidthIn;         
        U032    HeightIn;
        U032    WidthOut;
        U032    HeightOut;
        U032    Offset;           
        U032    Pitch;
        U032    Field;
        U032    Notify;
        U032    GetOffsetData;
        U032    Info32;
        PDMAHALOBJINFO   CtxDma;
    } SetImage[2];
    U032    lastWidthIn;
    U032    lastWidthOut;
    U032    lastHeightIn;
    U032    lastHeightOut;
    U032    lastImageStartLine;  
    U032    lastImageConfig;
} VIDEODECODERHALOBJECT, *PVIDEODECODERHALOBJECT;

#define EVENT_PROCESSED_VBI 0
#define EVENT_PROCESSED_IMAGE 1

//
// HAL NV_EXTERNAL_VIDEO_DECOMPRESSOR object.
//
typedef struct _def_video_decompressor_hal_object
{
    struct {
        U032    Offset;         
        U032    Size;           
        U032    Notify;
        PDMAHALOBJINFO   CtxDma;
    } ReadData[2];
    struct {
        U032    Offset;         
        U032    Size;           
        U032    FormatIn;
        U032    FormatOut;
        U032    Notify;
        PDMAHALOBJINFO   CtxDma;
    } WriteImage[2];
} VIDEODECOMPRESSORHALOBJECT, *PVIDEODECOMPRESSORHALOBJECT;

//
// HAL NV_EXTERNAL_PARALLEL_BUS object.
//
typedef struct _def_parallel_bus_hal_object
{
    U032    BusType;
    struct {
        U016    DataSize;
        U016    AddressSize;
        U032    Address;
        U032    Data;
    } Write;
    struct {
        U016    DataSize;
        U016    AddressSize;
        U032    Address;
        U032    Notify;
        U032    ReadData;
    } Read;
} PARALLELBUSHALOBJECT, *PPARALLELBUSHALOBJECT;

//
// MP_ALLOC_000 parameters.
//
typedef struct _def_mp_alloc_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} MPALLOCARG_000, *PMPALLOCARG_000;

//
// MP_FREE_000 parameters.
//
typedef struct _def_mp_free_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} MPFREEARG_000, *PMPFREEARG_000;

//
// MP_METHOD_000 parameters.
//
typedef struct _def_mp_method_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 offset;
    U032 data;
    U032 mthdStatus;
    PHALHWINFO pHalHwInfo;
} MPMETHODARG_000, *PMPMETHODARG_000;

//
// MP_GET_EVENT_STATUS_000 parameters.
//
typedef struct _def_mp_get_event_status_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 events;
    V032 intrStatus;
    PHALHWINFO pHalHwInfo;
} MPGETEVENTSTATUSARG_000, *PMPGETEVENTSTATUSARG_000;

//
// The events field holds a class-dependent bit mask
// specifying which "event" is to be processed.  For the decoder
// class, an event is a vbi or image buffer completion.  For the
// parallel bus class, it's an interrupt notify completion.

//
// The class04d decoder class uses 4 bits (1:0 for vbi, 3:2 for image).
//
#define CLASS04D_VBI_EVENTS_BASE            0
#define CLASS04D_IMAGE_EVENTS_BASE          2
#define CLASS04D_VBI_EVENT(n)               (1 << (CLASS04D_VBI_EVENTS_BASE+n))
#define CLASS04D_IMAGE_EVENT(n)             (1 << (CLASS04D_IMAGE_EVENTS_BASE+n))

//
// The class04e decompressor class uses 6 bits.
//
#define CLASS04E_VIDEO_EVENTS_BASE          0
#define CLASS04E_AUDIO_EVENTS_BASE          2
#define CLASS04E_IMAGE_EVENTS_BASE          4
#define CLASS04E_VIDEO_EVENT(n)             (1 << (CLASS04E_VIDEO_EVENTS_BASE+n))
#define CLASS04E_AUDIO_EVENT(n)             (1 << (CLASS04E_AUDIO_EVENTS_BASE+n))
#define CLASS04E_IMAGE_EVENT(n)             (1 << (CLASS04E_IMAGE_EVENTS_BASE+n))

//
// The parallel bus class uses a single event constant.
//
#define CLASS04F_PBUS_EVENT                 1

//
// MP_SERVICE_EVENT_000 parameters.
//
typedef struct _def_mp_service_event_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 event;
    V032 intrStatus;
    PHALHWINFO pHalHwInfo;
} MPSERVICEEVENTARG_000, *PMPSERVICEEVENTARG_000;

RM_STATUS nvHalMpControl(PHWINFO, U032);
RM_STATUS nvHalMpAlloc(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalMpFree(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalMpMethod(PHWINFO, U032, VOID *, U032, U032, U032 *);
RM_STATUS nvHalMpGetEventStatus(PHWINFO, U032, VOID *, U032 *, V032 *);
RM_STATUS nvHalMpServiceEvent(PHWINFO, U032, VOID *, U032, V032 *);

//--------------------------------------------------------------------
// Video
//--------------------------------------------------------------------

// Current HAL video interface revision ids.
#define VIDEO_CONTROL_000               MKHALID(VIDEO_ENGINE_TAG,0x0001,0x0)
#define VIDEO_ALLOC_000                 MKHALID(VIDEO_ENGINE_TAG,0x0002,0x0)
#define VIDEO_FREE_000                  MKHALID(VIDEO_ENGINE_TAG,0x0003,0x0)
#define VIDEO_METHOD_000                MKHALID(VIDEO_ENGINE_TAG,0x0004,0x0)
#define VIDEO_GET_EVENT_STATUS_000      MKHALID(VIDEO_ENGINE_TAG,0x0005,0x0)
#define VIDEO_SERVICE_EVENT_000         MKHALID(VIDEO_ENGINE_TAG,0x0006,0x0)

//
// The data in this structure is shared by both the RM and HAL.
//
typedef struct _def_video_hal_info
{
    U032 Head;
    U032 UpdateFlags;
    U032 FinishFlags;
    U032 Enabled;
    U032 ColorKeyEnabled;
    U032 ScaleFactor;       // 12.20
    U032 VideoStart;
    U032 VideoSize;
    U032 VideoScaleX;       // nv10's scale factors are 20/21 bits long
    U032 VideoScaleY;       // and need to be kept in separate dwords
    U032 VideoColorFormat;
    U032 VideoColor;
    U032 OverlayMaxDownscale_768;
    U032 OverlayMaxDownscale_1280;
    U032 OverlayMaxDownscale_1920;
    U032 CustomizationCode;
    VOID_PTR ActiveVideoOverlayObject;
} VIDEOHALINFO, *PVIDEOHALINFO;

//
// VIDEO_CONTROL_000 parameters.
//
typedef struct _def_video_control_arg_000
{
    NV_HAL_ID id;
    U032 cmd;
    PHALHWINFO pHalHwInfo;
} VIDEOCONTROLARG_000, *PVIDEOCONTROLARG_000;

// VIDEO_CONTROL commands.
#define VIDEO_CONTROL_UPDATE            1
#define VIDEO_CONTROL_LOAD              2
#define VIDEO_CONTROL_UNLOAD            3
#define VIDEO_CONTROL_DESTROY           4
#define VIDEO_CONTROL_INIT              5
#define VIDEO_CONTROL_ENABLE            6
#define VIDEO_CONTROL_DISABLE           7

//
// Video buffer kick off interface.
//
typedef RM_STATUS (*PVIDEOKICKOFFPROC)(PHALHWINFO, VOID *, U032);

//
// Video engine defines.
//
#define MAX_OVERLAY_BUFFERS             2

#define OVERLAY_BUFFER_IDLE             0
#define OVERLAY_BUFFER_BUSY             1
#define OVERLAY_BUFFER_NOTIFY_PENDING   2
#define OVERLAY_BUFFER_STOP_PENDING     3

//
// HAL NV_VIDEO_FROM_MEMORY object.
//
typedef struct _def_video_from_mem_hal_object
{
    PVIDEOKICKOFFPROC KickOffProc;
    U032 InitState;
    U032 Format;
    struct {
        U032 State;
        U032 Start;
        U032 Pitch;
        U032 Length;
        U032 Width;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScaleX;
        U032 VideoScaleY;
        U032 VideoColorFormat;
        U032 VideoColor;
        PDMAHALOBJINFO bufferCtxDma;
    } Buffer[MAX_OVERLAY_BUFFERS];
} VIDEOFROMMEMHALOBJECT, *PVIDEOFROMMEMHALOBJECT;

//
// HAL NV_VIDEO_SCALER object.
//
typedef struct _def_video_scaler_hal_object
{
    V032 DeltaDuDx;
    V032 DeltaDvDy;
    V032 xStart;   
    V032 yStart;   
} VIDEOSCALERHALOBJECT, *PVIDEOSCALERHALOBJECT;

//
// HAL NV_VIDEO_COLOR_KEY object.
//
typedef struct _def_video_colorkey_hal_object
{
    U032 ColorFormat;
    U032 Color;
    U032 xClipMin;
    U032 xClipMax;
    U032 yClipMin;
    U032 yClipMax; 
} VIDEOCOLORKEYHALOBJECT, *PVIDEOCOLORKEYHALOBJECT;

//
// HAL video overlay object for use by classes:
//   NV04_VIDEO_OVERLAY
//   NV10_VIDEO_OVERLAY
//

typedef struct _def_video_overlay_hal_object
{
    PVIDEOKICKOFFPROC KickOffProc;
	U032 PvideoBufferCopy;
	U032 PvideoStopActive;
    struct {
        PDMAHALOBJINFO OverlayCtxDma;
		U032 ColorKey;
		U032 Luminance;
		U032 Chrominance;
        U032 Offset;                       
        U016 SizeIn_width;
        U016 SizeIn_height;
        U016 SizeOut_width;
        U016 SizeOut_height;
        U016 PointIn_s;
        U016 PointIn_t;
        U016 PointOut_x;
        U016 PointOut_y;
        U032 OverlayStart;
        U032 DsDx;
        U032 DtDy;
        U032 ScaleFactor;
        U032 WindowStart; 
        U032 WindowSize;
        U032 Pitch;                        
        U032 OverlayFormat;
        U032 DisplayWhen;
        U032 State;
		U016 FormatPitch;
		U016 FormatColor;
		U016 FormatDisplay;
		U016 FormatMatrix;
    } Overlay[MAX_OVERLAY_BUFFERS];
} VIDEO_OVERLAY_HAL_OBJECT, *PVIDEO_OVERLAY_HAL_OBJECT;

#define OVERLAY_BUFFER_IS_IDLE(obj,buffer) (obj->Overlay[buffer].State == OVERLAY_BUFFER_IDLE)

//
// VIDEO_ALLOC_000 parameters.
//
typedef struct _def_video_alloc_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} VIDEOALLOCARG_000, *PVIDEOALLOCARG_000;

//
// VIDEO_FREE_000 parameters.
//
typedef struct _def_video_free_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    U032 instance;
    U032 chid;
    VOID *pHalObjInfo;
    PHALHWINFO pHalHwInfo;
} VIDEOFREEARG_000, *PVIDEOFREEARG_000;

//
// VIDEO_METHOD_000 parameters.
//
typedef struct _def_video_method_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 offset;
    U032 data;
    U032 mthdStatus;
    PHALHWINFO pHalHwInfo;
} VIDEOMETHODARG_000, *PVIDEOMETHODARG_000;

//
// VIDEO_GET_EVENT_STATUS_000 parameters.
//
typedef struct _def_video_get_event_status_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 events;
    V032 intrStatus;
    PHALHWINFO pHalHwInfo;
} VIDEOGETEVENTSTATUSARG_000, *PVIDEOGETEVENTSTATUSARG_000;

//
// VIDEO_SERVICE_EVENT_000 parameters.
//
typedef struct _def_video_service_event_arg_000
{
    NV_HAL_ID id;
    U032 classNum;
    VOID *pHalObjInfo;
    U032 events;
    V032 intrStatus;
    PHALHWINFO pHalHwInfo;
} VIDEOSERVICEEVENTARG_000, *PVIDEOSERVICEEVENTARG_000;

RM_STATUS nvHalVideoControl(PHWINFO, U032);
RM_STATUS nvHalVideoAlloc(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalVideoFree(PHWINFO, U032, U032, U032, VOID *);
RM_STATUS nvHalVideoMethod(PHWINFO, U032, VOID *, U032, U032, U032 *);
RM_STATUS nvHalVideoGetEventStatus(PHWINFO, U032, VOID *, U032 *, V032 *);
RM_STATUS nvHalVideoServiceEvent(PHWINFO, U032, VOID *, U032, V032 *);

//--------------------------------------------------------------------
// HAL device data.
//--------------------------------------------------------------------

//
// Each engine in the chip has the following state (setup by the RM):
//
//  - HalInfo       = Pointer to state held in pDev (shared between RM and HAL)
//  - HalPvtInfo    = Pointer to malloc'd system memory for engine state that
//                    is "private" to the HAL
//  - MallocBuffer  = Pointer to temporary malloced buffer for engine state
//                    transitions (e.g. save areas for STATE_LOAD calls)
//  - InstMem       = Offset into instance memory for engine state needed
//                    by hardware
//
// The amount of space (if any) to setup for these fields is determined
// by the contents of the chip-specific engine descriptor table (see
// kernel/inc/nvromdat.h).
//
struct _def_hal_hw_info
{
    PHWREG nvBaseAddr;                  // pointer to mapped registers
    PHWREG fbBaseAddr;                  // pointer to mapped framebuffer

    PHALRMFUNCS pHalRmFuncs;            // pointer to rm services table
    VOID_PTR pDeviceId;                 // pDev reference handle

    PPROCESSORHALINFO pProcessorHalInfo;
    PPRAMHALINFO pPramHalInfo;

    PMCHALINFO pMcHalInfo;
    VOID_PTR pMcHalPvtInfo;
    VOID_PTR pMcMallocBuffer;
    U032 mcInstMem;

    PFIFOHALINFO pFifoHalInfo;
    VOID_PTR pFifoHalPvtInfo;
    VOID_PTR pFifoMallocBuffer;
    U032 fifoInstMem;

    PFBHALINFO pFbHalInfo;
    VOID_PTR pFbHalPvtInfo;
    VOID_PTR pFbMallocBuffer;
    U032 fbInstMem;

    PGRHALINFO pGrHalInfo;
    VOID_PTR pGrHalPvtInfo;
    VOID_PTR pGrMallocBuffer;
    U032 grInstMem;

    PDMAHALINFO pDmaHalInfo;
    VOID_PTR pDmaHalPvtInfo;
    VOID_PTR pDmaMallocBuffer;
    U032 dmaInstMem;

    PDACHALINFO pDacHalInfo; 
    VOID_PTR pDacHalPvtInfo;
    VOID_PTR pDacMallocBuffer;
    U032 dacInstMem;

    PMPHALINFO pMpHalInfo;
    VOID_PTR pMpHalPvtInfo;
    VOID_PTR pMpMallocBuffer;
    U032 mpInstMem;

    PVIDEOHALINFO pVideoHalInfo;
    VOID_PTR pVideoHalPvtInfo;
    VOID_PTR pVideoMallocBuffer;
    U032 videoInstMem;
};

//--------------------------------------------------------------------
// HAL function table.
// The format of this table is ROM revision dependent.
//--------------------------------------------------------------------
typedef struct _def_halfuncs_000
{
    // mc interfaces
    RM_STATUS (*_nvHalMcControl)(VOID *);
    RM_STATUS (*_nvHalMcPower)(VOID *);

    // fifo interfaces
    RM_STATUS (*_nvHalFifoControl)(VOID *);
    RM_STATUS (*_nvHalFifoAllocPio)(VOID *);
    RM_STATUS (*_nvHalFifoAllocDma)(VOID *);
    RM_STATUS (*_nvHalFifoFree)(VOID *);
    RM_STATUS (*_nvHalFifoGetExceptionData)(VOID *);
    RM_STATUS (*_nvHalFifoService)(VOID *);
    RM_STATUS (*_nvHalFifoAccess)(VOID *);
    RM_STATUS (*_nvHalFifoHashAdd)(VOID *);
    RM_STATUS (*_nvHalFifoHashDelete)(VOID *);
    RM_STATUS (*_nvHalFifoHashFunc)(VOID *);
    RM_STATUS (*_nvHalFifoHashSearch)(VOID *);

    // framebuffer interfaces
    RM_STATUS (*_nvHalFbControl)(VOID *);
    RM_STATUS (*_nvHalFbAlloc)(VOID *);
    RM_STATUS (*_nvHalFbFree)(VOID *);
    RM_STATUS (*_nvHalFbSetAllocParameters)(VOID *);
    RM_STATUS (*_nvHalFbGetSurfacePitch)(VOID *);
    RM_STATUS (*_nvHalFbGetSurfaceDimensions)(VOID *);
    RM_STATUS (*_nvHalFbLoadOverride)(VOID *);

    // graphics interfaces
    RM_STATUS (*_nvHalGrControl)(VOID *);
    RM_STATUS (*_nvHalGrAlloc)(VOID *);
    RM_STATUS (*_nvHalGrFree)(VOID *);
    RM_STATUS (*_nvHalGrGetExceptionData)(VOID *);
    RM_STATUS (*_nvHalGrService)(VOID *);
    RM_STATUS (*_nvHalGrGetNotifyData)(VOID *);
    RM_STATUS (*_nvHalGrSetObjectContext)(VOID *);
    RM_STATUS (*_nvHalGrLoadOverride)(VOID *);

    // dma interfaces
    RM_STATUS (*_nvHalDmaControl)(VOID *);
    RM_STATUS (*_nvHalDmaAlloc)(VOID *);
    RM_STATUS (*_nvHalDmaFree)(VOID *);
    RM_STATUS (*_nvHalDmaGetInstSize)(VOID *);

    // dac interfaces
    RM_STATUS (*_nvHalDacControl)(VOID *);
    RM_STATUS (*_nvHalDacAlloc)(VOID *);
    RM_STATUS (*_nvHalDacFree)(VOID *);
    RM_STATUS (*_nvHalDacSetStartAddr)(VOID *);
    RM_STATUS (*_nvHalDacProgramMClk)(VOID *);
    RM_STATUS (*_nvHalDacProgramNVClk)(VOID *);
    RM_STATUS (*_nvHalDacProgramPClk)(VOID *);
    RM_STATUS (*_nvHalDacProgramCursorImage)(VOID *);
    RM_STATUS (*_nvHalDacGetRasterPosition)(VOID *);
    RM_STATUS (*_nvHalDacValidateArbSettings)(VOID *);
    RM_STATUS (*_nvHalDacUpdateArbSettings)(VOID *);

    // media port interfaces
    RM_STATUS (*_nvHalMpControl)(VOID *);
    RM_STATUS (*_nvHalMpAlloc)(VOID *);
    RM_STATUS (*_nvHalMpFree)(VOID *);
    RM_STATUS (*_nvHalMpMethod)(VOID *);
    RM_STATUS (*_nvHalMpGetEventStatus)(VOID *);
    RM_STATUS (*_nvHalMpServiceEvent)(VOID *);

    // video interfaces
    RM_STATUS (*_nvHalVideoControl)(VOID *);
    RM_STATUS (*_nvHalVideoAlloc)(VOID *);
    RM_STATUS (*_nvHalVideoFree)(VOID *);
    RM_STATUS (*_nvHalVideoMethod)(VOID *);
    RM_STATUS (*_nvHalVideoGetEventStatus)(VOID *);
    RM_STATUS (*_nvHalVideoServiceEvent)(VOID *);
} HALFUNCS_000, *PHALFUNCS_000;

typedef VOID *PHALFUNCS;

#define HALFUNC_000(i)                  (*((PHALFUNCS_000)pDev->pHalFuncs)->i)

extern HALFUNCS_000 NV04_HalFuncs_000;
extern HALFUNCS_000 NV10_HalFuncs_000;
extern HALFUNCS_000 NV20_HalFuncs_000;

//--------------------------------------------------------------------
// RM entry points for use by HAL.
//--------------------------------------------------------------------

struct _def_hal_rm_funcs_000
{
    // interrupt service request interface
    //   engine, phalhwinfo
    RM_STATUS (*_nvHalRmServiceIntr)(VOID *, U032);

    // debug print routines
    VOID (*_nvHalRmPrintString) (VOID *, U032, char*);
    VOID (*_nvHalRmPrintValue) (VOID *, U032, U032);
    VOID (*_nvHalRmPrintStringValue) (VOID *, U032, char*, U032);
    VOID (*_nvHalRmPrintStringPtr) (VOID *, U032, char*, VOID*);
    VOID (*_nvHalRmPrintStringVal64) (VOID *, U032, char*, U064);

    // register i/o interfaces
    VOID (*_nvHalRmRegWr08) (VOID *, U032, U008);
    U008 (*_nvHalRmRegRd08) (VOID *, U032);

    //   *address = value
    VOID (*_nvHalRmRegWr32) (VOID *, U032, U032);
    //   value = *address
    U032 (*_nvHalRmRegRd32) (VOID *, U032);

    VOID (*_nvHalRmBreakPoint) (VOID *);
    RM_STATUS (*_nvHalRmDelay) (VOID *, U032);

    // i2c read/write interfaces
    RM_STATUS (*_nvHalRmI2cRead) (VOID *, U032, U008, U016, U008 *, U016, U008 *);
    RM_STATUS (*_nvHalRmI2cWrite) (VOID *, U032, U008, U016, U008 *, U016, U008 *);
};

// from kernel/hal/halrm.c
extern HALRMFUNCS_000 HalRmFuncs_000;

// 
// RM service macros.
// 

#define HALRMSERVICEINTR(p,e)   (*((PHALRMFUNCS_000)((PHALHWINFO)p)->pHalRmFuncs)->_nvHalRmServiceIntr)((PHALHWINFO)p->pDeviceId,e)

#define HAL_GR_IDLE(p) \
    while ((volatile U032)REG_RD32(NV_PGRAPH_STATUS))  {         \
        V032 pmc;                                                \
        pmc = REG_RD32(NV_PMC_INTR_0);                           \
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PGRAPH, _PENDING)) {   \
            (void)HALRMSERVICEINTR((PHALHWINFO)p,GR_ENGINE_TAG); \
        }                                                        \
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)) {    \
            (void)HALRMSERVICEINTR((PHALHWINFO)p,DAC_ENGINE_TAG);\
        }                                                        \
    }

//
// RM ic2 read/write macros.
//
#define HALRMI2CREAD(p,id,chipadr,adrlen,addr,datalen,data) \
    (*((PHALRMFUNCS_000)((PHALHWINFO)p)->pHalRmFuncs)->_nvHalRmI2cRead)((PHALHWINFO)p->pDeviceId,id,chipadr,adrlen,addr,datalen,data)
#define HALRMI2CWRITE(p,id,chipadr,adrlen,addr,datalen,data) \
    (*((PHALRMFUNCS_000)((PHALHWINFO)p)->pHalRmFuncs)->_nvHalRmI2cWrite)((PHALHWINFO)p->pDeviceId,id,chipadr,adrlen,addr,datalen,data)

//--------------------------------------------------------------------
// RM routines.
//--------------------------------------------------------------------

// kernel/hal/halinit.c
RM_STATUS initHal(PHWINFO);
RM_STATUS initHalMappings(PHWINFO);
RM_STATUS destroyHal(PHWINFO);
RM_STATUS allocHalEngineInstMem(PHWINFO);
RM_STATUS freeHalEngineInstMem(PHWINFO);

#endif // _NVHAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\state.h ===
#ifndef _STATE_H_
#define _STATE_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
//
/***************************** HW State Routines ***************************\
*                                                                           *
* Module: STATE.H                                                           *
*       Hardware State is managed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)     1/06/95 - wrote it.                    *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  State transition message defines.
//
//---------------------------------------------------------------------------

#define STATE_UPDATE        1
#define STATE_LOAD          2
#define STATE_UNLOAD        3
#define STATE_DESTROY       4
#define STATE_INIT          5

//---------------------------------------------------------------------------
//
//  Real mode state transitions.
//
//---------------------------------------------------------------------------

RM_STATUS stateRModeInit(U032);
RM_STATUS stateRModeSave(U032);
RM_STATUS stateRModeRestore(U032);

//---------------------------------------------------------------------------
//
//  Nv device state transitions.
//
//---------------------------------------------------------------------------

RM_STATUS stateNv(PHWINFO, U032);
RM_STATUS stateAu(PHWINFO, U032);
RM_STATUS stateCodec(PHWINFO, U032);
RM_STATUS stateDac(PHWINFO, U032);
RM_STATUS stateDma(PHWINFO, U032);
RM_STATUS stateFb(PHWINFO, U032);
RM_STATUS stateFifo(PHWINFO, U032);
RM_STATUS stateGr(PHWINFO, U032);
RM_STATUS stateGp(PHWINFO, U032);
RM_STATUS stateMc(PHWINFO, U032);
RM_STATUS stateRMode(U032);
RM_STATUS stateTmr(PHWINFO, U032);
RM_STATUS stateVideo(PHWINFO, U032);
RM_STATUS stateSetMode(PHWINFO);
RM_STATUS stateSetMode_DacClassStyle(PHWINFO);
RM_STATUS stateSetModeMultiHead(PHWINFO, PVIDEO_LUT_CURSOR_DAC_OBJECT);

//---------------------------------------------------------------------------
//
//  Nv device state information.
//
//---------------------------------------------------------------------------

RM_STATUS stateConfigGet(PHWINFO, U032, U032*);
RM_STATUS stateConfigSet(PHWINFO, U032, U032, U032*);

#define CONFIG_GETEX_OK        0
#define CONFIG_GETEX_BAD_READ  1 // matches NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM
#define CONFIG_GETEX_BAD_INDEX 4 // matches NVOS_CGE_STATUS_ERROR_BAD_INDEX
#define CONFIG_GETEX_BAD_PARAM 6 // matches NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT
#define CONFIG_SETEX_OK        0
#define CONFIG_SETEX_BAD_WRITE 1 // matches NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM
#define CONFIG_SETEX_BAD_INDEX 4 // matches NVOS_CSE_STATUS_ERROR_BAD_INDEX
#define CONFIG_SETEX_BAD_PARAM 6 // matches NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT

RM_STATUS stateConfigGetEx(PHWINFO, U032, VOID *, U032);
RM_STATUS stateConfigSetEx(PHWINFO, U032, VOID *, U032);

//
// Global extern.
//
//extern HWINFO nvInfo;

#if (_WIN32_WINNT >= 0x0500)
extern U032 GetCurrentDPMSState(VOID *);
#endif


#endif // _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\tmr.h ===
#ifndef _TMR_H_
#define _TMR_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
//
/****************************** Timer Module *******************************\
*                                                                           *
* Module: TMR.H                                                             *
*       Timer functions.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    01/24/95 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define NUM_TIMERCALLBACKS              32
typedef RM_STATUS (*TIMEPROC)(PHWINFO, POBJECT);

//---------------------------------------------------------------------------
//
//  Time objects.
//
//---------------------------------------------------------------------------

struct _def_context_time_object
{
    OBJECT   Base;
    U032     TimeLo;
    U032     TimeHi;
    TIMEPROC TimeProc;
    POBJECT  TimeChange;
};
typedef struct _def_timer_object
{
    COMMONOBJECT    Common;
//    PDMAOBJECT NotifyXlate;
//    U032       NotifyAction;
    U032            State;
    U032            AlarmLo;
    U032            AlarmHi;
} TIMEROBJECT, *PTIMEROBJECT;

//---------------------------------------------------------------------------
//
//  Timer callbacks.
//
//---------------------------------------------------------------------------

typedef struct _def_timer_callback
{
    TIMEPROC Callback;
    POBJECT  Object;
    U032     TimeLo;
    U032     TimeHi;
    struct   _def_timer_callback *Next;
} TIMERCALLBACK, *PTIMERCALLBACK;

//---------------------------------------------------------------------------
//
//  Function prototypes.
//
//---------------------------------------------------------------------------

RM_STATUS initTmr(PHWINFO);
RM_STATUS tmrCreateTimer(VOID*, PCLASSOBJECT, U032, POBJECT *, VOID*);
RM_STATUS tmrDeleteTimer(VOID*, POBJECT);
RM_STATUS tmrAlarmNotify(PHWINFO, POBJECT);
RM_STATUS tmrStatTimer(PHWINFO, POBJECT);
RM_STATUS tmrGetCurrentTime(PHWINFO, U032 *, U032 *);
RM_STATUS tmrDelay(PHWINFO, U032);
RM_STATUS tmrScheduleCallbackAbs(PHWINFO, TIMEPROC, POBJECT, U032, U032);
RM_STATUS tmrScheduleCallbackRel(PHWINFO, TIMEPROC, POBJECT, U032, U032);
RM_STATUS tmrCancelCallback(PHWINFO, POBJECT);
RM_STATUS tmrStopTransfer(PHWINFO, POBJECT, PMETHOD, U032, V032);
V032      tmrService(PHWINFO);
#endif // _TMR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nvromdat.h ===
#ifndef _NVROMDAT_H_
#define _NVROMDAT_H_

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV ROM Defines and Structures ********************\
*                                                                           *
* Module: nvromdat.h                                                        *
*       NV RM/HAL ROM data table formats.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

//
// Describes format of data tables found in ROM.
//
// Currently two such tables:  engine descriptors and class descriptors.
//

#include <nvhal.h>

//
// Engine descriptor instruction opcodes (4 bits wide).
//
#define ENGDECL_INSTR                   0x0
#define ENGMALLOC_INSTR                 0x1
#define ENGINSTMALLOC_INSTR             0x2

//
// Engine declaration instruction
//
// There is one engine descriptor instruction for each engine in the
// chip:
//
//  31      27      25      21                                       0 
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  | 4 bits| 4 bits| 4 bits| 20 bits                                 |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   Opcode  Tag     Hash     Obj inst size
//
// Opcode: ENGDECL_INSTR
// Tag:
//   Unique engine tag.  Used by class headers.
// Hash:
//   NV_RAMHT_ENGINE bits (if any) for objects managed by engine.
// Object instance size:
//   Default instmem size (in paragraphs) to alloc for objects managed
//   by engine.  This value can be increased for a given class using the
//   CLASSINSTMALLOC_INSTR (see below).
//

typedef U032 ENGINEDESCRIPTOR, *PENGINEDESCRIPTOR;

#define ENGDECL_OBJINSTSZ               19:0
#define ENGDECL_OBJRAMHT                23:20
#define ENGDECL_TAG                     27:24
#define ENGDECL_OPCODE                  31:28

#define MKENGDECL(tag,ht,osz) \
    (ENGDECL_INSTR << SF_SHIFT(ENGDECL_OPCODE) | \
     tag << SF_SHIFT(ENGDECL_TAG) | \
     ht << SF_SHIFT(ENGDECL_OBJRAMHT) | \
     osz << SF_SHIFT(ENGDECL_OBJINSTSZ))

// WARNING: these macros depend on <nvrm.h>
#define ENGDECL_FIELD(desc,field)       (((U032)desc >> SF_SHIFT(ENGDECL ## field)) & SF_MASK(ENGDECL ## field))

//
// Engine malloc instruction
//
// The engine malloc instruction is used to describe system memory
// requirements for the engine.
//
//  31      27      23      21      17                               0 
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  | 4 bits| 4 bits| 4 bits| 20 bits                                 |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   Opcode  Tag     Type    Size
//
// Opcode: ENGMALLOC_OPCODE
// Tag: 
//   Unique engine tag.
// Type:
//   Describes purpose of memory, indicating when
//   memory should be allocated/freed.
// Size:
//   Amount of memory (in dwords).
//

#define ENGMALLOC_SIZE                  19:0
#define ENGMALLOC_TYPE                  23:20
#define ENGMALLOC_TAG                   27:24
#define ENGMALLOC_OPCODE                31:28

#define MKENGMALLOC(tag,type,sz) \
    (ENGMALLOC_INSTR << SF_SHIFT(ENGMALLOC_OPCODE) | \
     tag << SF_SHIFT(ENGMALLOC_TAG) | \
     type << SF_SHIFT(ENGMALLOC_TYPE) | \
     sz << SF_SHIFT(ENGMALLOC_SIZE))

// WARNING: these macros depend on <nvrm.h>
#define ENGMALLOC_FIELD(desc,field)    (((U032)desc >> SF_SHIFT(ENGMALLOC ## field)) & SF_MASK(ENGMALLOC ## field))

//
// Engine malloc types:
//   TYPE_PRIVATE
//     Buffer should be allocated/freed when resman starts up
//     and shuts down.  Used for chip-dependent private state.
//   TYPE_INIT
//     Buffer should be allocated/freed across call to INIT
//     engine.
//   TYPE_DESTROY
//     Buffer should be allocated/freed across call to DESTROY
//     engine.
//
#define ENGMALLOC_TYPE_PRIVATE          0x0
#define ENGMALLOC_TYPE_INIT             0x1
#define ENGMALLOC_TYPE_DESTROY          0x2

//
// Engine instmem alloc instruction
//
// The engine instmem alloc instruction is used to describe instance
// memory requirements for the engine.  Up to one megabyte of instance
// memory can be requested with this instruction (supporting up to a
// 4K alignment).
//
//  31      27      23              15                               0 
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  | 4 bits| 4 bits| 8 bits        | 16 bits                         |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//    Opcode  Tag     Align            Size
//
// Opcode: ENGINSTMALLOC_OPCODE
// Tag: 
//   Unique engine tag.
// Align:
//   Alignment requirements of allocation (in paragraphs).
//   A value of 0 indicates the default alignment (1 paragraph).
// Size:
//   Amount of memory (in paragraphs).
//
#define ENGINSTMALLOC_SIZE              15:0
#define ENGINSTMALLOC_ALIGN             23:16
#define ENGINSTMALLOC_TAG               27:24
#define ENGINSTMALLOC_OPCODE            31:28

#define MKENGINSTMALLOC(tag,align,sz) \
    (ENGINSTMALLOC_INSTR << SF_SHIFT(ENGINSTMALLOC_OPCODE) | \
     tag << SF_SHIFT(ENGINSTMALLOC_TAG) | \
     align << SF_SHIFT(ENGINSTMALLOC_ALIGN) | \
     sz << SF_SHIFT(ENGINSTMALLOC_SIZE))

// WARNING: these macros depend on <nvrm.h>
#define ENGINSTMALLOC_FIELD(desc,field)    (((U032)desc >> SF_SHIFT(ENGINSTMALLOC ## field)) & SF_MASK(ENGINSTMALLOC ## field))

//
// Class descriptor instruction opcodes (4 bits wide).
//
#define CLASSDECL_INSTR                 0x0
#define CLASSINSTMALLOC_INSTR           0x1

//
// Class declaration instruction
//
//  31      27      21   21          15                               0 
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  |4 bits |4 bits | 8 bits        | 16 bits                         |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   Opcode  Tag     Lock            Class number
// 
// Opcode: CLASSDECL_INSTR
// Tag: engine tag
// Lock: allocation restriction
// Class number: class number
//

typedef U032 CLASSDESCRIPTOR, *PCLASSDESCRIPTOR;

#define CLASSDECL_CLASS                 15:0
#define CLASSDECL_LOCK                  23:16
#define CLASSDECL_TAG                   27:24
#define CLASSDECL_OPCODE                31:28

#define MKCLASSDECL(tag,lock,class) \
    (CLASSDECL_INSTR << SF_SHIFT(CLASSDECL_OPCODE) | \
     tag << SF_SHIFT(CLASSDECL_TAG) | \
     lock << SF_SHIFT(CLASSDECL_LOCK) | \
     class << SF_SHIFT(CLASSDECL_CLASS))

// WARNING: these macros depend on <nvrm.h>
#define CLASSDECL_FIELD(desc,field)     (((U032)desc >> SF_SHIFT(CLASSDECL ## field)) & SF_MASK(CLASSDECL ## field))

//
// No allocation restrictions for the class.
//
#define NO_LOCK                         0xff

//
// Class instance memory alloc instruction
//
//  31      27              19                                       0 
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  | 4 bits| 8 bits        | 20 bits                                 |
//  .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   Opcode  Alignment       Size
//
// Opcode: CLASSINSTMALLOC_INSTR
// Alignment:
//   Instance memory alignment (in paragraphs).  A value of 0 indicates
//   the default alignment (1 paragraph).
// Size:
//   Additional instance space (in paragraphs) for objects of this class
//   to the amount specified in ENGDESC_OBJINSTSZ field.
//

#define CLASSINSTMALLOC_SIZE            19:0
#define CLASSINSTMALLOC_ALIGN           27:20
#define CLASSINSTMALLOC_OPCODE          31:28

#define MKCLASSINSTMALLOC(align,size) \
    (CLASSINSTMALLOC_INSTR << SF_SHIFT(CLASSINSTMALLOC_OPCODE) | \
     align << SF_SHIFT(CLASSINSTMALLOC_ALIGN) | \
     size << SF_SHIFT(CLASSINSTMALLOC_SIZE))

// WARNING: these macros depend on <nvrm.h>
#define CLASSINSTMALLOC_FIELD(desc,field)  (((U032)desc >> SF_SHIFT(CLASSINSTMALLOC ## field)) & SF_MASK(CLASSINSTMALLOC ## field))

//
// Graphics engine (per channel) allocation locks.
//
#define GR_LOCK_CONTEXT_BETA_SOLID          0x00
#define GR_LOCK_CONTEXT_BETA                0x01
#define GR_LOCK_CONTEXT_COLOR_KEY           0x02
#define GR_LOCK_CONTEXT_PATTERN             0x03
#define GR_LOCK_CONTEXT_CLIP                0x04
#define GR_LOCK_CONTEXT_ROP                 0x05
#define GR_LOCK_DVD                         0x06
#define GR_LOCK_CONTEXT_SURFACES_2D         0x07
#define GR_LOCK_CONTEXT_SURFACES_3D         0x08
#define GR_LOCK_CONTEXT_SURFACES_SWIZZLED   0x09
#define GR_LOCK_3D                          0x0a

//
// MediaPort engine (per device) allocation locks.
//
#define MP_LOCK_DECODER                     0x00    
#define MP_LOCK_DECOMPRESSOR                0x01

//
// Video engine (per device) allocation locks.
//

//
// HAL initialization data.
//
extern CLASSDESCRIPTOR NV04_ClassDescriptors[];
extern U032 NV04_NumClassDescs;
extern CLASSDESCRIPTOR NV05_ClassDescriptors[];
extern U032 NV05_NumClassDescs;
extern ENGINEDESCRIPTOR NV04_EngineDescriptors[];
extern U032 NV04_NumEngineDescs;

extern CLASSDESCRIPTOR NV10_ClassDescriptors[];
extern U032 NV10_NumClassDescs;
extern CLASSDESCRIPTOR NV15_ClassDescriptors[];
extern U032 NV15_NumClassDescs;
extern CLASSDESCRIPTOR NV11_ClassDescriptors[];
extern U032 NV11_NumClassDescs;
extern ENGINEDESCRIPTOR NV10_EngineDescriptors[];
extern U032 NV10_NumEngineDescs;

extern CLASSDESCRIPTOR NV20_ClassDescriptors[];
extern U032 NV20_NumClassDescs;
extern ENGINEDESCRIPTOR NV20_EngineDescriptors[];
extern U032 NV20_NumEngineDescs;

#endif // _NVROMDAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nv_uep.h ===
#ifndef __NV_EAP_H__
#define __NV_EAP_H__

// software methods for the EP...
#define NV1BAE_PIO_SET_OUTBUF_BA(i)                             (0x00000000+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_BA__SIZE_1                        4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_BA_ADDRESS                        23:0 /* -W-UF */
#define NV1BAE_PIO_SET_OUTBUF_LEN(i)                            (0x00000004+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_LEN__SIZE_1                       4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_LEN_VALUE                         23:0 /* -W-UF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE                       0x00000800 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_HANDLE                31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA           0x00000804 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA_HANDLE    31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET                0x00000808 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET_PARAMETER      31:12 /* -W-VF */
#define NV1BAE_PIO_SET_STATE                                    0x0000080C
#define NV1BAE_PIO_SET_STATE_VALUE                              0:0
#define NV1BAE_PIO_SET_STATE_OFF                                0x00
#define NV1BAE_PIO_SET_STATE_ON                                 0x01
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nv_ref.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
*               Hardware Reference Manual extracted defines.                *
*                                                                           *
\***************************************************************************/
#ifndef _NV_REF_H_
#define _NV_REF_H_

//
// VGA hardware is supported on NV3/NV4/NV10
//
#define NV_VGA  1

#ifdef NV3_HW
//
// VGA hardware is supported on NV3
//
#include <nv3_ref.h>
#define NV_PFIFO_CACHE1_SIZE                                  32
#define BUG_BM_OFF()
#define BUG_BM_ON()

#else
//
// These registers can be accessed by chip-independent code as
// well as chip-dependent code.
//

/* NVidia Corporation */ 
/* basis: nv4 manuals 
built on Tue Nov 17 04:01:20 PST 1998*/

#ifndef _NV_REG_H_
#define _NV_REG_H_

#ifdef DEBUG
/*
 * These macros are here strictly for debugging purposes.
 * For the real definitions to be used in the code, refer to
 * the chip-specific headers.
 */
#define NV_PGRAPH_DMA_A_XLATE_INST                       0x00401040 /* RW-4R */
#define NV_PGRAPH_DMA_A_CONTROL                          0x00401044 /* RW-4R */
#define NV_PGRAPH_DMA_A_LIMIT                            0x00401048 /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_PTE                          0x0040104C /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_TAG                          0x00401050 /* RW-4R */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET                       0x00401054 /* RW-4R */
#define NV_PGRAPH_DMA_A_OFFSET                           0x00401058 /* RW-4R */
#define NV_PGRAPH_DMA_A_SIZE                             0x0040105C /* RW-4R */
#define NV_PGRAPH_DMA_A_Y_SIZE                           0x00401060 /* RW-4R */

#define NV_PGRAPH_DMA_B_XLATE_INST                       0x00401080 /* RW-4R */
#define NV_PGRAPH_DMA_B_CONTROL                          0x00401084 /* RW-4R */
#define NV_PGRAPH_DMA_B_LIMIT                            0x00401088 /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_PTE                          0x0040108C /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_TAG                          0x00401090 /* RW-4R */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET                       0x00401094 /* RW-4R */
#define NV_PGRAPH_DMA_B_OFFSET                           0x00401098 /* RW-4R */
#define NV_PGRAPH_DMA_B_SIZE                             0x0040109C /* RW-4R */
#define NV_PGRAPH_DMA_B_Y_SIZE                           0x004010A0 /* RW-4R */
#endif

/* dev_bus.ref */
/*
 * This macro is used in the NvDeviceBaseGet 16bit call.
 */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID                          31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV01_A              0x00000009 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV01_B_B02_B03_C01  0x00000008 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV02_A01            0x00000010 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV03_NOACPI         0x00000018 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV03_ACPI           0x00000019 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04                0x00000020 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0         0x00000028 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1         0x00000029 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2         0x0000002A /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3         0x0000002B /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0         0x0000002C /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1         0x0000002D /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2         0x0000002E /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3         0x0000002F /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0         0x000000A0 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1         0x000000A1 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2         0x000000A2 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3         0x000000A3 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0         0x00000100 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1         0x00000101 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2         0x00000102 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3         0x00000103 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0         0x00000110 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1         0x00000111 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2         0x00000112 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3         0x00000113 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0         0x00000150 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1         0x00000151 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2         0x00000152 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3         0x00000153 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0         0x00000200 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1         0x00000201 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2         0x00000202 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3         0x00000203 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#de