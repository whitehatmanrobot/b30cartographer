 AddUserAsync(ulong xboxId, ulong userId, uint userFlags, object userState)
        {
            if ((this.AddUserOperationCompleted == null))
            {
                this.AddUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddUserOperationCompleted);
            }
            this.InvokeAsync("AddUser", new object[] {
                        xboxId,
                        userId,
                        userFlags}, this.AddUserOperationCompleted, userState);
        }

        private void OnAddUserOperationCompleted(object arg)
        {
            if ((this.AddUserCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddUserCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/RemoveUser", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveUser(ulong xboxId, ulong userId)
        {
            this.Invoke("RemoveUser", new object[] {
                        xboxId,
                        userId});
        }

        /// <remarks/>
        public void RemoveUserAsync(ulong xboxId, ulong userId)
        {
            this.RemoveUserAsync(xboxId, userId, null);
        }

        /// <remarks/>
        public void RemoveUserAsync(ulong xboxId, ulong userId, object userState)
        {
            if ((this.RemoveUserOperationCompleted == null))
            {
                this.RemoveUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveUserOperationCompleted);
            }
            this.InvokeAsync("RemoveUser", new object[] {
                        xboxId,
                        userId}, this.RemoveUserOperationCompleted, userState);
        }

        private void OnRemoveUserOperationCompleted(object arg)
        {
            if ((this.RemoveUserCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveUserCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/GetUserCount", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public byte GetUserCount(ulong xboxId)
        {
            object[] results = this.Invoke("GetUserCount", new object[] {
                        xboxId});
            return ((byte)(results[0]));
        }

        /// <remarks/>
        public void GetUserCountAsync(ulong xboxId)
        {
            this.GetUserCountAsync(xboxId, null);
        }

        /// <remarks/>
        public void GetUserCountAsync(ulong xboxId, object userState)
        {
            if ((this.GetUserCountOperationCompleted == null))
            {
                this.GetUserCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserCountOperationCompleted);
            }
            this.InvokeAsync("GetUserCount", new object[] {
                        xboxId}, this.GetUserCountOperationCompleted, userState);
        }

        private void OnGetUserCountOperationCompleted(object arg)
        {
            if ((this.GetUserCountCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserCountCompleted(this, new GetUserCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/ReadUserQValPacket", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool ReadUserQValPacket(ulong xboxId, ulong userId, out QValPacket packet)
        {
            object[] results = this.Invoke("ReadUserQValPacket", new object[] {
                        xboxId,
                        userId});
            packet = ((QValPacket)(results[1]));
            return ((bool)(results[0]));
        }

        /// <remarks/>
        public void ReadUserQValPacketAsync(ulong xboxId, ulong userId)
        {
            this.ReadUserQValPacketAsync(xboxId, userId, null);
        }

        /// <remarks/>
        public void ReadUserQValPacketAsync(ulong xboxId, ulong userId, object userState)
        {
            if ((this.ReadUserQValPacketOperationCompleted == null))
            {
                this.ReadUserQValPacketOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadUserQValPacketOperationCompleted);
            }
            this.InvokeAsync("ReadUserQValPacket", new object[] {
                        xboxId,
                        userId}, this.ReadUserQValPacketOperationCompleted, userState);
        }

        private void OnReadUserQValPacketOperationCompleted(object arg)
        {
            if ((this.ReadUserQValPacketCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadUserQValPacketCompleted(this, new ReadUserQValPacketCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/GetInaSG", RequestNamespace = "http://test.xbox.com/", ResponseNamespace = "http://test.xbox.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint GetInaSG()
        {
            object[] results = this.Invoke("GetInaSG", new object[0]);
            return ((uint)(results[0]));
        }

        /// <remarks/>
        public void GetInaSGAsync()
        {
            this.GetInaSGAsync(null);
        }

        /// <remarks/>
        public void GetInaSGAsync(object userState)
        {
            if ((this.GetInaSGOperationCompleted == null))
            {
                this.GetInaSGOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetInaSGOperationCompleted);
            }
            this.InvokeAsync("GetInaSG", new object[0], this.GetInaSGOperationCompleted, userState);
        }

        private void OnGetInaSGOperationCompleted(object arg)
        {
            if ((this.GetInaSGCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetInaSGCompleted(this, new GetInaSGCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }

        private bool IsLocalFileSystemWebService(string url)
        {
            if (((url == null)
                        || (url == string.Empty)))
            {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024)
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0)))
            {
                return true;
            }
            return false;
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://test.xbox.com/")]
    public partial class QValPacket
    {

        private System.DateTime deliveryTimeField;

        private bool pushField;

        private uint[] dataField;

        /// <remarks/>
        public System.DateTime DeliveryTime
        {
            get
            {
                return this.deliveryTimeField;
            }
            set
            {
                this.deliveryTimeField = value;
            }
        }

        /// <remarks/>
        public bool Push
        {
            get
            {
                return this.pushField;
            }
            set
            {
                this.pushField = value;
            }
        }

        /// <remarks/>
        public uint[] Data
        {
            get
            {
                return this.dataField;
            }
            set
            {
                this.dataField = value;
            }
        }
    }
/*
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://test.xbox.com/")]
    public enum ClientType
    {
        Xbox,
        Xenon,
        XenonBackCompat,
        Panorama,
        Zune,
        XboxCom,
        WebBrowser
    }
*/
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void LoadSlotCompletedEventHandler(object sender, LoadSlotCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LoadSlotCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal LoadSlotCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public CSGInfo sgInfo
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((CSGInfo)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void AddXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void RemoveXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void DeadXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void ClearXboxesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetTitleCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetAltTitlesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetKeyCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetUserStateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetEnableStateBatchingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetStateEndpointCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void AddUserCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void RemoveUserCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void GetUserCountCompletedEventHandler(object sender, GetUserCountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetUserCountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public byte Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((byte)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void ReadUserQValPacketCompletedEventHandler(object sender, ReadUserQValPacketCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadUserQValPacketCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReadUserQValPacketCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public bool Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }

        /// <remarks/>
        public QValPacket packet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((QValPacket)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void GetInaSGCompletedEventHandler(object sender, GetInaSGCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetInaSGCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetInaSGCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public uint Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Arbitration.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using System.IO;
using live.protocol.Presence;
using live.protocol;

namespace live.server
{

    //TODO: This class is a work in progress
    public class Arbitration
    {
        public static byte[] RegisterArbitrationSession(IClient client, XblUser user, ulong teamId, float trust, ulong sessionId, ulong sessionNonce)
        {
            METHOD.ENTER();


            XUIDAndTrust[] users = new XUIDAndTrust[1];
            users[0] = new XUIDAndTrust(user.Puid, ArbitrationFlags.flagMask, trust);

            byte[] request = GetRegisterPostData(client, users, teamId, 0x000b, sessionId, sessionNonce);
            byte[] response;

            uint hr = client.SendRequest(user, XOService.Arbitration, "/xarb/Register.ashx", "POST", null, request, out response);
            Throw.IfXErrFailed(hr);


            ushort flags = ArbitrationFlags.TimeExtendable;
            XRLRegisterRequest req = new XRLRegisterRequest();
            req.flags = flags;
            req.sessionId = sessionId;
            req.sessionNonce = sessionNonce;
            req.teamId = (uint)0;
            req.users = users;
            req.xboxId = client.MachinePuid;
            req.titleId = client.TitleId;
            req.usersLen = 1;

            XRLRegisterResponse resp = new XRLRegisterResponse();
            hr = client.SendRequest(user, req.GetServiceId(), req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);



            ArbitrationDebugResultRequest reqObj = new ArbitrationDebugResultRequest();
            reqObj.sessionID = sessionId;
            reqObj.sessionNonce = sessionNonce;
            reqObj.titleID = client.TitleId;
            reqObj.flags = ArbitrationFlags.flagMask;
            reqObj.version = 1;

            ArbitrationDebugResultResponse respObj = new ArbitrationDebugResultResponse();
            hr = client.SendRequest(user, XOService.Arbitration, "/xarb/DebugResult.ashx", "POST", null, reqObj, respObj);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return response;
        }

        //public static uint Register(ulong xboxId, ulong userId, float trust, ulong teamId, ulong sessionId, ulong sessionNonce)
        //{
        //    XUIDAndTrust[] users = new XUIDAndTrust[1];
        //    users[0] = new XUIDAndTrust(userId, 0, trust);
        //    uint hr;

        //    byte[] postData = GetRegisterPostData(xboxId, users, teamId, 0x000b, sessionId, sessionNonce);


        //    hr = FrontDoorRequest(Config.GetVirtualInterface(VirtualInterface.xarb_int).Url, "/xarb/Register.ashx", xboxId, users, postData, out respData);

        //    Console.WriteLine("Register took {0}ms and returned {1}", timeElapsed.MillisecondsElapsed, hr.ToString("x"));
        //    Console.WriteLine("Register input: " + ByteConvert.ToString(postData));
        //    Console.WriteLine("Register output: " + ByteConvert.ToString(respData));
        //    Console.WriteLine("");

        //    return hr;
        //}

        //public static uint FrontDoorRequest(Uri url, String path, ulong xboxID, XUIDAndTrust[] users, byte[] postData, out byte[] respData)
        //{
        //    CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
        //    slot.AddService(ServerTestFramework.LiveService.XOService.Arbitration);
        //    slot.titleId = TITLE_ID;
        //    slot.machinePuid = xboxID;
        //    slot.userPuid0 = users.Length <= 0 ? 0 : users[0].qwUserID;
        //    slot.userPuid1 = users.Length <= 1 ? 0 : users[1].qwUserID;
        //    slot.userPuid2 = users.Length <= 2 ? 0 : users[2].qwUserID;
        //    slot.userPuid3 = users.Length <= 3 ? 0 : users[3].qwUserID;




        //    uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Arbitration, false, path, postData, out respData);
        //    return hr;
        //}
   


        private static byte[] GetRegisterPostData(IClient client, XUIDAndTrust[] users, ulong teamId, ushort flags, ulong sessionId, ulong sessionNonce)
        {
            MemoryStream postStream = new MemoryStream(200);
            BinaryWriter writer = new BinaryWriter(postStream);

            writer.Write((ushort)1);
            writer.Write(flags);
            writer.Write(client.TitleId);
            writer.Write(sessionId);
            writer.Write(sessionNonce);
            writer.Write((ushort)400);

            //if (teamId != 0)
            //{
            //    TeamTicket[] teamTicket = new TeamTicket[1];
            //    teamTicket[0] = new TeamTicket(users[0].qwUserID, teamId);
            //    teamTicket[0].SignTicket(new HTTPAuthData((ushort)3, (uint)0x44444444, (ulong)0x5555555555555555, client.MachinePuid, users, client.TitleId, (uint)XOService.Arbitration, 0));
            //    TeamTickets teamTickets = new TeamTickets(teamTicket);
            //    teamTickets.WriteStream(writer);
            //}

            return postStream.ToArray();
        }





        public static byte[] TimeExtend(IClient client, XblUser user, float trust, ulong sessionId, ulong sessionNonce)
        {
            METHOD.ENTER();
            byte[] request = GetTimeExtendPostData(client.TitleId, sessionId, sessionNonce);
            byte[] response;

            XUIDAndTrust[] users = new XUIDAndTrust[1];
            users[0] = new XUIDAndTrust(user.Puid, 0, trust);

            uint hr = client.SendRequest(user, XOService.Arbitration, "/xarb/TimeExtend.ashx", "POST", null, request, out response);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return response;

        }

        private static byte[] GetTimeExtendPostData(ulong titleId, ulong sessionId, ulong sessionNonce)
        {
            MemoryStream postStream = new MemoryStream(200);
            BinaryWriter writer = new BinaryWriter(postStream);

            writer.Write((ushort)1);
            writer.Write((ushort)0x0000);
            writer.Write(titleId);
            writer.Write(sessionId);
            writer.Write(sessionNonce);
            writer.Write((ushort)800);

            return postStream.ToArray();
        }


        public static ArbitrationDebugResultResponse ReportArbitrationResults(IClient client, XblUser user, float trust, ulong sessionId, ulong sessionNonce)
        {
            METHOD.ENTER();

            XUIDAndTrust[] users = new XUIDAndTrust[1];
            users[0] = new XUIDAndTrust(user.Puid, 0, trust);

            ArbitrationReportResultRequest request = new ArbitrationReportResultRequest();
            request.flags = 0x0F80;
            request.titleId = client.TitleId;
            request.sessionId = sessionId;
            request.sessionNonce = sessionNonce;

            //ASCIIEncoding ascii = new ASCIIEncoding();

            //request.type1SuspiciousInfo = new SuspiciousInfo();
            //request.type1SuspiciousInfo.message = ascii.GetBytes("Test1");

            //request.type2SuspiciousInfo = new SuspiciousInfo();
            //request.type2SuspiciousInfo.message = ascii.GetBytes("Test2");
            //request.type2SuspiciousInfo.relatedXbox = new ulong[] { xboxID1, xboxID2 };

            //request.type3SuspiciousInfo = new SuspiciousInfo();
            //request.type3SuspiciousInfo.message = ascii.GetBytes("Test3");
            //request.type3SuspiciousInfo.relatedXbox = new ulong[] { xboxID2 };
            //request.type3SuspiciousInfo.relatedUser = new ulong[] { userID1, userID2 };

            // For Test
            Random rand = new Random();
            byte[] bundle1 = new byte[16];
            byte[] bundle2 = new byte[16];
            rand.NextBytes(bundle1);
            rand.NextBytes(bundle2);

            request.statsBundle = new live.protocol.StatsBundle();
            request.statsBundle.bundle = bundle1;

            request.tournamentBundle = new TournamentBundle();
            request.tournamentBundle.bundle = bundle2;

            ArbitrationDebugResultResponse response = new ArbitrationDebugResultResponse();

            uint hr = client.SendRequest(user, XOService.Arbitration, "/xarb/ReportResult.ashx", "POST", null, request, response);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return response;
        }


      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Cust.cs ===
using System;
using System.Collections.Generic;

using live.common;
using live.protocol;

namespace live.server
{

    public static class Cust
    {

        private static void ThrowOnError(uint hr, string message)
        {
            if (hr != 0)
            {
                throw new HResultException(hr, message);
            }
        }

        public static uint SendRequest(
            IClient client,
            HttpRequestObject2 reqOb,
            XRLObject2 respOb)
        {
            uint hr = client.SendRequest(null, XOService.Cust,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), null, reqOb, respOb);
            return hr;
        }

        public static uint SendRequest(IClient client, CustPayloadRequest reqOb, PayloadResponse respOb)
        {
            reqOb.SetPayloadTypeFor(client, respOb);

            uint hr = client.SendRequest(null, XOService.Cust,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), null, reqOb, respOb);
            return hr;
        }

        public static ulong GetPuidFromXName(IClient client, string gamertag)
        {
            METHOD.ENTER();
            getPuidFromXName req = new getPuidFromXName();
            getPuidFromXNameResponse resp = new getPuidFromXNameResponse();

            req.XName = gamertag;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            METHOD.EXIT();
            return resp.Puid;
        }

        public static AccountInfo GetAccount(IClient client, ulong puid)
        {
            METHOD.ENTER();
            getAccount req = new getAccount();
            getAccountResponse resp = new getAccountResponse();

            req.puid = puid;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getAccountResult, resp.errorString);
            AccountInfo info = new AccountInfo();
            info.IsActive = resp.isActive;
            info.IsGeofenceExempt = resp.isGeofenceExempt;
            info.IsLockedOut = resp.isLockedOut;
            info.IsNicknameBanned = resp.isNicknameBanned;
            info.IsOwner = resp.isAccountOwner;
            info.IsVoiceBanned = resp.isVoiceBanned;
            info.MustChangeXName = resp.mustChangeXName;
            METHOD.EXIT();
            return info;
        }

        public static AccountInfoEx GetAccountEx(IClient client, ulong puid)
        {
            AccountInfoEx info = null;

            METHOD.ENTER();
            CustGetAccountExRequest req = new CustGetAccountExRequest();
            CustGetAccountExResponse resp = new CustGetAccountExResponse();

            req.puid = puid;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getAccountExResult, resp.errorString);
            info = new AccountInfoEx();
            info.AcceptedTOS = resp.dtAcceptedTOS;
            info.CountryId = (CountryId)resp.tiCountryID;
            info.ErrorString = resp.errorString;
            info.isGeofenceExempt = resp.isGeoFenceExempt;
            info.MustChangeXName = resp.bMustChangeXName;
            info.OwnerPuid = resp.biOwnerPuid;
            info.Puid = puid;
            info.ResumeDate = resp.dtAccountResumeDate;
            info.SuspensionLength = resp.iSuspensionLength;
            info.VoiceBanLength = resp.iVoiceBanLength;
            info.VoiceResumeDate = resp.dtVoiceResumeDate;
            METHOD.EXIT();
            return info;

        }


        public static MachineAccountInfo GetMachineAccountByConsoleId(IClient client, ulong puid, string consoleId)
        {
            METHOD.ENTER();
            CustGetMachineAccountByConsoleIdRequest req = new CustGetMachineAccountByConsoleIdRequest();
            CustGetMachineAccountByConsoleIdResponse resp = new CustGetMachineAccountByConsoleIdResponse();
            req.puid = puid;
            req.consoleId = consoleId;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getMachineAccountByConsoleIdResult, resp.errorString);

            MachineAccountInfo info = new MachineAccountInfo();
            info.isLockedOut = resp.isLockedOut;
            info.ErrorString = resp.errorString;
            METHOD.EXIT();
            return info;
        }

        public static string GetPassportMemberName(IClient client, ulong puid, out string parentPmn)
        {
            METHOD.ENTER();
            CustGetPassportMemberNameReuest req = new CustGetPassportMemberNameReuest();
            CustGetPassportMemberNameResponse resp = new CustGetPassportMemberNameResponse();

            req.puid = puid;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getPassportMemberNameResult, resp.errorString);
            parentPmn = resp.parentPmn;
            METHOD.EXIT();
            return resp.userPmn;

        }


        public static void ModifyAccount(IClient client, ulong puid, AccountInfo info)
        {
            METHOD.ENTER();
            CustModifyAccountRequest req = new CustModifyAccountRequest();
            CustModifyAccountResponse resp = new CustModifyAccountResponse();
 
            req.puid = puid;
            req.isGeoFenceExempt = info.IsGeofenceExempt;
            req.isLockedOut = info.IsLockedOut;
            req.isNicknameBanned = info.IsNicknameBanned;
            req.isVoiceBanned = info.IsVoiceBanned;
            req.mustChangeXName = info.MustChangeXName;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.modifyAccountResult, resp.errorString);
            
            METHOD.EXIT();

        }


        public static void BanAccount(IClient client, ulong puid, bool banAccount)
        {
            METHOD.ENTER();
            CustBanAccountRequest req = new CustBanAccountRequest();
            CustBanAccountResponse resp = new CustBanAccountResponse();

            req.puid = puid;
            req.isLockedOut = banAccount;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.banAccountResult, resp.errorString);

            METHOD.EXIT();

        }

        public static void SetUserMotto(IClient client, ulong puid, string newMotto)
        {
            METHOD.ENTER();
            CustSetUserMottoRequest req = new CustSetUserMottoRequest();
            CustSetUserMottoResponse resp = new CustSetUserMottoResponse();

            req.puid = puid;
            req.newMotto = newMotto;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.SetUserMottoResult, resp.errorString);

            METHOD.EXIT();

        }

        public static void SetUserProfileItems(IClient client, ulong puid, ProfileItem[] items)
        {
            METHOD.ENTER();
            CustSetUserProfileItemsRequest req = new CustSetUserProfileItemsRequest();
            CustSetUserProfileItemsResponse resp = new CustSetUserProfileItemsResponse();

            req.puid = puid;
            req.profileItems = items;
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.SetUserProfileItemsResult, resp.errorString);

            METHOD.EXIT();

        }

        public static void RemoveGamerPicture(IClient client, ulong puid)
        {
            METHOD.ENTER();
            CustRemoveGamerPictureRequest req = new CustRemoveGamerPictureRequest();
            CustRemoveGamerPictureResponse resp = new CustRemoveGamerPictureResponse();

            req.puid = puid;
            
            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.RemoveGamerPictureResult, resp.errorString);

            METHOD.EXIT();

        }


        public static ulong[] GetRelatedAccounts(IClient client, ulong puid, out string[] gamertags)
        {
            METHOD.ENTER();
            CustGetRelatedAccountsRequest req = new CustGetRelatedAccountsRequest();
            CustGetRelatedAccountsResponse resp = new CustGetRelatedAccountsResponse();
            req.puid = puid;

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getRelatedAccountsResult, resp.errorString);
            gamertags = resp.relatedAccountNames;

            METHOD.EXIT();
            return resp.relatedAccounts;

        }


        public static SubscriptionCodeStatus GetSubscriptionCodeStatus(IClient client, string code)
        {
            METHOD.ENTER();
            CustGetSubscriptionCodeStatusRequest req = new CustGetSubscriptionCodeStatusRequest();
            CustGetSubscriptionCodeStatusResponse resp = new CustGetSubscriptionCodeStatusResponse();
            req.SubscriptionCode = code;

            uint hr = SendRequest(client, req, resp);
            Throw.IfHRFailed(hr);
            ThrowOnError(resp.getSubscriptionCodeStatusResult, resp.errorString);
            SubscriptionCodeStatus status = new SubscriptionCodeStatus();
            status.LastUsage = resp.ftLastUsage;
            status.LastUserGamertag = resp.szLastUser;
            status.LastUserPuid = resp.ulLastUser;
            status.Offer = resp.szOffer;
            status.OfferID = resp.ulOfferID;
            status.Used = resp.bUsed;
            status.UsedMaxTimes = resp.bUsedMaxTimes;
            status.ValidSubscriptionCode = resp.bValidSubscriptionCode;

            METHOD.EXIT();
            return status;

        }


        /*

 
        public static uint GetSubscriptionCodeStatus(
            string Code,
            out bool IsValid,
            out bool IsUsed,
            out bool UsedMaxTimes,
            out ulong LastUser,
            out string LastUserName,
            out DateTime LastUsage,
            out ulong OfferID,
            out string InstanceID)
        {
            ulong ReturnCode = Prov.getSubscriptionCodeStatus(
                            Code,
                            out IsValid,
                            out IsUsed,
                            out UsedMaxTimes,
                            out LastUser,
                            out LastUserName,
                            out LastUsage,
                            out OfferID,
                            out InstanceID,
                            out ErrorString);
            return (uint)ReturnCode;
        }
 */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Crypto.cs ===
using System;
using System.Net;
using System.IO;

using live.common;
using live.protocol;
using System.Security.Cryptography;

namespace live.server
{
    public static class xCrypto
    {
        public static uint SendRequest (IClient client,
                                           XblUser user,
                                           XRLRequestObject2 reqOb,
                                           XRLObject2 respOb )
        {
            uint hr = client.SendRequest(user, XOService.Crypto,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), null, reqOb, respOb);
            return hr;
        }

        public static XCryptoVerifyConsolePakResponse XCryptoVerifyConsolePAK(IClient _client, UInt64 _consoleId, byte[] _clearHash, byte[] _consoleEncryptedHash)
        {
            XCryptoVerifyConsolePakRequest request = new XCryptoVerifyConsolePakRequest();
            XCryptoVerifyConsolePakResponse response = new XCryptoVerifyConsolePakResponse();
            XCryptoData clearHash = new XCryptoData(_clearHash, XCryptoVerifyConsolePakRequest.DATA_SIZE);
            XCryptoData consoleEncryptesHash = new XCryptoData(_consoleEncryptedHash, XCryptoVerifyConsolePakRequest.DATA_SIZE);

            //
            // Setup the request
            //
            request.consoleId = _consoleId;
            request.clear = clearHash;
            request.pakEncrypted = consoleEncryptesHash;

            //
            // Send the request
            //
            uint hr = SendRequest(_client, _client.LoggedOnUsers[0], request, response);
            Throw.IfXErrFailed(hr);
            
            return response;
        }

    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\KDC.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.client;
using live.common.kdc;

namespace live.server
{
    public class KDCNotRespondingException : Exception
    {
        public KDCNotRespondingException(string messageFormat, params object[] objs)
            : base(string.Format(messageFormat, objs))
        {
        }
    }

    public static class KDC
    {

        internal static uint SendRequest(IClient client, XOService service, byte[] request, out byte[] response)
        {
            return client.SendRequest(null, service, null, null, null, request, out response);
        }


        public static ulong CreateMachineAccount(Xbox360Client client)
        {
            return CreateMachineAccount(client, false);
        }

        public static ulong CreateMachineAccount(Xbox360Client client, bool newAccount)
        {
            METHOD.ENTER();
            if (newAccount)
            {
                    client.Principal = live.common.kdc.XmacsClient.GenerateXenonPrincipal();
                    client.AuthContext = new live.common.kdc.AuthContext();
             
            }
            XmacsClient xmacs = new XmacsClient(client.AuthContext, null, null, true);
            XmacsClient.SetDefaultsForClient(client);
            byte[] req = xmacs.BuildRequest();
            byte[] resp;
            uint hr = client.SendKDCRequest(XOService.KDCSvc, req, out resp);
            if (hr != HResult.S_OK)
            {
                throw new KDCNotRespondingException("No XMACS response to create machine account for {0} to {1}", client.Principal, Config.Current.GetIPEndPoint(XOService.KDCSvc));
            }

            xmacs.VerifyResponse(resp);
            System.Threading.Thread.Sleep(1000);
            METHOD.EXIT();
            return xmacs.MachinePuid;

        }

        public static TgtContext SignInASKdc(Xbox360Client client, XblUser user, int slot, int retries)
        {
            return SignInASKdc(client, user, slot, retries, null);
        }

        public static TgtContext SignInASKdc(Xbox360Client client, XblUser user, int slot, int retries, byte[] echoData)
        {
            METHOD.ENTER();

            AskdcClient askdc = new AskdcClient(client.AuthContext, null, true);
            AskdcClient.SetDefaults(client.AuthContext);
            byte[] req = askdc.BuildUserRequest(client, user, slot, echoData);
            byte[] resp = new byte[] { };
            uint hr = 2;
            int attempt = 0;

            //an account may only call ASKDC once a second. So we should check to see if its a machine and if so delay the calls
            if (user == null)
            {
                Logging.WriteLine("DEBUG", "Machine Puid: 0x{0:X}", client.MachinePuid);
                long ticks = DateTime.Now.Ticks - client.AuthContext.LastMachineASRequestTime.Ticks;
                ticks = 1020 - (long)TimeSpan.FromTicks(ticks).TotalMilliseconds;
                if (ticks > 0)
                {
                    Logging.WriteLine("DEBUG", "Time since last machine call too short, sleeping {0} ms", ticks);
                    System.Threading.Thread.Sleep((int)(ticks));
                }
            }
            else
            {
                Logging.WriteLine("DEBUG", "User: {0}", user);
            }
            while (hr != HResult.S_OK && attempt <= retries)
            {
                attempt++;
                try
                {
                    hr = client.SendKDCRequest(XOService.KDCSvc, req, out resp);
                }
                catch
                {
                    if (attempt > retries)
                    {
                        throw;
                    }
                }
                finally
                {
                    if (user == null)
                    {
                        client.AuthContext.LastMachineASRequestTime = DateTime.Now;
                    }
                }
            }
            Logging.WriteLine("DEBUG", "Made {0} requests", attempt);

            if (hr != HResult.S_OK)
            {
                if (user != null)
                {
                    throw new KDCNotRespondingException("No ASKDC response at {0} for User: {1} on Xbox360: {2} 0x{3:X} \tAttempts: {4}", Config.Current.GetIPEndPoint(XOService.KDCSvc), user, client.Principal, client.MachinePuid, attempt);
                }
                else
                {
                    throw new KDCNotRespondingException("No ASKDC reponse at {0} for Xbox360: {1} 0x{2:X} \tAttempts{3}", Config.Current.GetIPEndPoint(XOService.KDCSvc), client.Principal, client.MachinePuid, attempt);
                }
            }

            TgtContext ticket;

            try
            {
                ticket = askdc.VerifyResponse(resp);
            }
            catch (KerbErrException kee)
            {
                //preauth with echo retry may be needed
                if (echoData == null && kee.KerbErr == KerbErrCode.KDC_ERR_PREAUTH_REQUIRED && askdc.CurrentTicket != null)
                {
                    byte[] echoBytes = new byte[0];
                    uint echoByteCount = AuthClientBase.kcl_GetTGTEchoBytes(askdc.CurrentTicket.tgtToken, echoBytes, 0);
                    if (echoByteCount != 0)
                    {
                        Logging.WriteLine("DEBUG", "ASKKDC requesting Echo preauth of length: {0}", echoByteCount);
                        echoBytes = new byte[echoByteCount];
                        AuthClientBase.kcl_GetTGTEchoBytes(askdc.CurrentTicket.tgtToken, echoBytes, echoByteCount);
                        ticket = SignInASKdc(client, user, slot, retries, echoBytes);
                    }
                    else
                    {
                        throw;
                    }

                }
                else
                {
                    throw;
                }
            }

            if (user == null)
            {
                client.AuthContext.CombinedTgt = ticket;
                if (client.LoggedOnUsers.Count > 0)
                {
                    askdc.InitializePUIDS();
                }
            }

            METHOD.EXIT();
            return ticket;
        }

        public static TgtContext SignInASKdc(Xbox360Client client)
        {
            METHOD.ENTER();

            client.AuthContext.ClearAskdc();
            if (client.AuthContext.CombinedTgt != null)
            {
                client.AuthContext.CombinedTgt.Dispose();
                client.AuthContext.CombinedTgt = null;
            }
            for (int i = 0; i < client.LoggedOnUsers.Count; i++)
            {
                TgtContext curr = SignInASKdc(client, client.LoggedOnUsers[i], i, 5);
                if (client.AuthContext.CombinedTgt != null)
                {
                    client.AuthContext.CombinedTgt.Dispose();
                }
                client.AuthContext.CombinedTgt = curr;
            }
            client.AuthContext.CombinedTgt = SignInASKdc(client, null, -1, 5);

            METHOD.EXIT();
            return client.AuthContext.CombinedTgt;
        }

        public static CSGInfo SignInXKdc(Xbox360Client client, TgtContext tgt)
        {
            METHOD.ENTER();
            client.AuthContext.ClearXkdc();
            XkdcClient xkdc = new XkdcClient(client.AuthContext, null, true);


            byte[] req = xkdc.BuildRequest(client);
            byte[] resp;
            uint hr = client.SendKDCRequest(XOService.KDCSvc, req, out resp);
            if (hr != HResult.S_OK)
            {
                throw new KDCNotRespondingException("No XKDC response for {0} to {1}", client.Principal, Config.Current.GetIPEndPoint(XOService.KDCSvc));
            }
            xkdc.Verify(resp);
            CSGInfo result = client.AuthContext.ToCSGInfo();
            METHOD.EXIT();
            return result;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Billing.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;
using Global = ServerTestFramework.Global;

using live.common;
using live.protocol;
using live.client;


namespace live.server
{
    public static class Billing
    {
        public static uint SendRequest(
            IClient client,
            XblUser user,
            XOService service,
            HttpRequestObject2 reqOb,
            XRLObject2 respOb)
        {

            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, service,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            return hr;
        }

        //
        // XBOX 1
        //

        public static void OfferingPurchase(IClient client, XblUser user, ulong offerId)
        {
            METHOD.ENTER();
            OfferingPurchaseRequest req = new OfferingPurchaseRequest();
            XRLObject2 resp = null;

            req.userPuid = user.Puid;
            req.machinePuid = client.MachinePuid;
            req.titleId = client.TitleId;
            req.offerId = offerId;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }

        public static void OfferingCancel(IClient client, XblUser user, ulong offerId) 
        {
            METHOD.ENTER();
            OfferingCancelRequest req = new OfferingCancelRequest();
            XRLObject2 resp = null;

            req.userPuid = user.Puid;
            req.offerId = offerId;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }


        public static void OfferingDetails(IClient client, XblUser user) { }
        public static void OfferingEnumerate(IClient client, XblUser user) { }
        public static void ContentReferral(IClient client, XblUser user) { }
        public static void AutoupdReferral(IClient client, XblUser user) { }
        public static void VerifyNickname(IClient client, XblUser user) { }
        public static void ContentAvailable(IClient client, XblUser user) { }
        public static void OfferingDetailsNoUser(IClient client, XblUser user) { }
        public static void health(IClient client, XblUser user) { }

        //
        // XENON
        //

        public static void XeContentUpdateAccessTimes(IClient client, XblUser user, uint titleID,
            uint titleCategories)
        {
            METHOD.ENTER();
            ContentUpdateAccessTimesRequest req = new ContentUpdateAccessTimesRequest();
            req.titleCategories = titleCategories;
            req.titleID = titleID;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, null);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
        }

        public static EnumeratedContentItems XeContentEnumerate2(IClient client, XblUser user,
            ContentEnumerateFilter filter)
        {
            METHOD.ENTER();
            ContentEnumerateRequest req = filter.ToContentEnumerateRequest(user);
            ContentEnumerateResponse resp = new ContentEnumerateResponse();
            resp.SchemaVersion = req.SchemaVersion;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new EnumeratedContentItems(resp);
        }

        public static EnumeratedContentHistoryItems XeContentHistoryEnumerate(IClient client, XblUser user,
            ContentHistoryEnumerateFilter filter)
        {
            METHOD.ENTER();
            ContentHistoryEnumerateRequest req = filter.ToContentHistoryEnumerateRequest(client, user);
            ContentHistoryEnumerateResponse resp = new ContentHistoryEnumerateResponse();
            resp.SchemaVersion = req.SchemaVersion;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new EnumeratedContentHistoryItems(resp);
        }

        public static EnumeratedContentItems XeContentDetails(IClient client, XblUser user, ulong offerId,
            PaymentTypeEnum paymentType, byte ratingSystem)
        {
            METHOD.ENTER();
            ContentDetailsRequest req = new ContentDetailsRequest();
            ContentDetailsResponse resp = new ContentDetailsResponse();

            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageID = user.Settings.PersonalInfo.LanguageId;
            req.offerID = 0;
            req.offerIDs = new ulong[1] { offerId };
            req.offers = (ushort)req.offerIDs.Length;
            req.paymentType = (uint)paymentType;
            req.ratingSystem = ratingSystem;
            req.tierRequired = (byte)user.Settings.UserType;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new EnumeratedContentItems(resp);
        }

        public static void XeContentAvailable(IClient client, XblUser user) { }

        public static ContentReferral XeContentReferral(IClient client, XblUser user, ContentItem contentItem)
        {
            return XeContentReferral(client, user, contentItem.contentId);
        }

        public static ContentReferral XeContentReferral(IClient client, XblUser user, byte[] contentId)
        {
            METHOD.ENTER();
            XeContentReferralRequest req = new XeContentReferralRequest();
            XeContentReferralResponse resp = new XeContentReferralResponse();
            resp.SchemaVersion = req.SchemaVersion;
            req.contentId = contentId;
            req.userId = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new ContentReferral(resp);
        }

        public static byte[] XeContentRefreshLicense(IClient client, XblUser user, ContentItem contentItem)
        {
            METHOD.ENTER();
            XeContentRefreshLicenseRequest req = new XeContentRefreshLicenseRequest();
            XeContentRefreshLicenseResponse resp = new XeContentRefreshLicenseResponse();

            //TODO: I believe we need to switch byte orders to PPC big-endian
            // I also made up everything this is doing and someone from billing should
            // review and correct it

            ContentLicense license = new ContentLicense();
            license.body = new ContentLicenseBody();
            license.body.ContentId = contentItem.contentId;
            license.body.licensees = ContentLicensee.CreateEmptyLicenseeArray();
            license.body.SizeOfHeaders = 0;
            license.signature = new ContentLicenseSignature();
            license.signature.signature = new byte[ContentLicense.LiveSignatureLen];
            license.signature.signatureType = ContentLicense.LicenseTypeLive;

            req.license = license.ToArray();
            req.licenseLength = (ushort)req.license.Length;
            req.machineId = client.MachinePuid;
            req.userId = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return resp.license;
        }

        public static EnumeratedSubscriptions XeSubscriptionEnumerate(IClient client, XblUser user,
            SubscriptionEnumerateFilter filter)
        {
            METHOD.ENTER();
            SubscriptionEnumerateRequest req = filter.ToSubscriptionEnumerateRequest(client, user);
            SubscriptionEnumerateResponse resp = new SubscriptionEnumerateResponse();
            resp.SchemaVersion = req.SchemaVersion;

            uint hr = SendRequest(client, user, XOService.Base_Subscription, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return new EnumeratedSubscriptions(resp);
        }

        public static SubscriptionItem XeSubscriptionDetails(IClient client, XblUser user, ulong offerID)
        {
            METHOD.ENTER();

            SubscriptionDetailsRequest req = new SubscriptionDetailsRequest();
            SubscriptionDetailsResponse resp = new SubscriptionDetailsResponse();
            resp.SchemaVersion = req.SchemaVersion;
            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageID = user.Settings.PersonalInfo.LanguageId;
            req.machinePuid = client.MachinePuid;
            req.offerID = offerID;
            req.paymentType = (uint)PaymentTypeEnum.Any;
            req.ratingSystem = 0;
            req.tierRequired = (byte)user.Settings.UserType;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);


            METHOD.EXIT();
            return new SubscriptionItem(resp.basicInfo);

        }

        public static void XeOfferPurchase(IClient client, XblUser user, ulong offerId)
        {
            PaymentInstrumentBase pi = user.Settings.BillingInfo.GetActivePaymentInstrument();
            if (pi == null)
            {
                throw new Exception("User has no active payment instrument.");
            }

            if (pi is WholesaleInfo)
            {
                XeOfferPurchase(client, user, offerId, PaymentTypeEnum.Wholesale, pi.PaymentInstrumentId);
            }
            else
            {
                XeOfferPurchase(client, user, offerId, PaymentTypeEnum.CreditCard, pi.PaymentInstrumentId);
            }
        }

        public static void XeOfferPurchase(IClient client, XblUser user, ulong offerId,
            PaymentTypeEnum paymentType, string paymentIdOrToken)
        {
            XeOfferPurchase(client, user, new ulong[] { offerId }, paymentType, paymentIdOrToken);
        }

        public static void XeOfferPurchase(IClient client, XblUser user, ulong[] offerIds,
           PaymentTypeEnum paymentType, string paymentIdOrToken)
        {
            XeOfferPurchase(client, user, offerIds, paymentType, paymentIdOrToken, string.Empty);
        }
        public static void XeOfferPurchase(IClient client, XblUser user, ulong[] offerIds,
            PaymentTypeEnum paymentType, string paymentIdOrToken,string npdbInjectionHeader)
        {
            Global.RO.Info(string.Format("XeOfferPurchase user({0:x}, offer[0]:{1:x})", user.Puid, offerIds[0]));
            METHOD.ENTER();
            XeOfferPurchaseRequest req = new XeOfferPurchaseRequest();

            if (paymentIdOrToken == null)
            {
                paymentIdOrToken = "";
            }

            client.Timeout = 65000 * 2;
            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageID = user.Settings.PersonalInfo.LanguageId;
            req.machinePuid = client.MachinePuid;
            req.offerID = 0;
            req.offerIDs = offerIds;  // info.offerID
            req.offerIDLength = (uint)req.offerIDs.Length;
            req.paymentType = (uint)paymentType;
            req.tier = (byte)user.Settings.UserType; // info.tierRequired;
            req.userPuid = user.Puid;

            req.billingToken = "";
            req.paymentInstrumentID = "";
            if (paymentType == PaymentTypeEnum.Token)
            {
                req.billingToken = paymentIdOrToken;
            }
            else if (paymentType == PaymentTypeEnum.CreditCard || paymentType == PaymentTypeEnum.Wholesale )
            {
                req.paymentInstrumentID = paymentIdOrToken;
            }
            req.billingTokenLength = (ushort)req.billingToken.Length;
            req.paymentInstrumentIDLength = (ushort)req.paymentInstrumentID.Length;
            if (Config.Current.GetDefaultSchemaVersion() >= WireData.MakeSchemaVersion(4, 0))
            {
                if (paymentType == PaymentTypeEnum.Wholesale)
                {
                    if (user.Settings.BillingInfo.WholesaleInfo == null)
                    {
                        throw new NullReferenceException("user.Settings.BillingInfo.WholeSaleInfo is set to null on a Wholesale Purchase call");
                    }
                    req.EncryptedPassword = user.Settings.BillingInfo.WholesaleInfo.EncryptedPassword;
                }
                else
                {
                    req.EncryptedPassword = "";
                }
                req.EncryptedPasswordLength = (ushort)req.EncryptedPassword.Length;
            }

            if (!string.IsNullOrEmpty(npdbInjectionHeader))
            {
                string[] nameValuePair = npdbInjectionHeader.Split(':');
                if (nameValuePair.Length != 2)
                    throw new Exception("The npdbOverrideSetting has to provide both name and value!");
                req.BehaviorInjection.AddNpdbOverride(nameValuePair[0], nameValuePair[1], true);
            }

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, null);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
        }

        public static void XeOfferPurchaseGamertag(IClient client, XblUser user, ulong offerId,
            PaymentTypeEnum paymentType, string paymentIdOrToken, string newGamertag)
        {
            METHOD.ENTER();
            XeOfferPurchaseGamertagRequest req = new XeOfferPurchaseGamertagRequest();

            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageID = user.Settings.PersonalInfo.LanguageId;
            req.machinePuid = client.MachinePuid;
            req.offerID = offerId;
            req.paymentType = (uint)paymentType;
            req.tier = (byte)user.Settings.UserType; // info.tierRequired;
            req.userPuid = user.Puid;
            req.gamertag = newGamertag;
            if (paymentType == PaymentTypeEnum.Token)
            {
                req.billingToken = paymentIdOrToken;
            }
            else
            {
                req.billingToken = "";
            }
            req.billingTokenLength = (ushort)req.billingToken.Length;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, null);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
        }

        public static void XeOfferPurchaseMusic(IClient client, XblUser user, MusicItem[] items, string externalOrderID,
            PaymentTypeEnum paymentType, string paymentIdOrToken)
        {
            METHOD.ENTER();
            XeOfferPurchaseMusicRequest req = new XeOfferPurchaseMusicRequest();
            SetMaxSchemaVersion(req, 3, 0);
            uint oldSchema = client.SchemaVersion;
            client.SchemaVersion = req.SchemaVersion;
            req.billingToken = req.paymentInstrumentID = string.Empty;

            if (paymentType == PaymentTypeEnum.Token)
            {
                req.billingToken = paymentIdOrToken;
            }
            else if (paymentType == PaymentTypeEnum.CreditCard)
            {
                req.paymentInstrumentID = paymentIdOrToken;
            }
            req.paymentInstrumentIDLength = (ushort)req.paymentInstrumentID.Length;
            req.billingTokenLength = (ushort)req.billingToken.Length;
            req.externalOrderID = externalOrderID;
            req.externalOrderIDLength = (ushort)externalOrderID.Length;
            System.Net.IPHostEntry iphe = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            req.ipAddress = iphe.AddressList[0].ToString();
            req.ipAddressLength = (ushort)req.ipAddress.Length;
            req.itemCount = (ushort)items.GetLength(0);
            req.items = items;
            req.paymentType = (uint)paymentType;
            req.userPuid = user.Puid;


            try
            {
                uint hr = SendRequest(client, user, XOService.Billing_Offering, req, null);
                Throw.IfXErrFailed(hr);
            }
            finally
            {
                client.SchemaVersion = oldSchema;
            }

            METHOD.EXIT();
        }

        public static live.protocol.WMID[] XeOfferPurchaseVideo(IClient client, XblUser user, live.protocol.WMID wmid, uint expectedPrice, PaymentTypeEnum paymentType, string paymentIdOrToken)
        {
            METHOD.ENTER();
            XeOfferPurchaseVideoRequest req = new XeOfferPurchaseVideoRequest();
            XeOfferPurchaseVideoResponse resp = new XeOfferPurchaseVideoResponse();
            SetMaxSchemaVersion(req, 3, 0);
            uint oldSchema = client.SchemaVersion;
            client.SchemaVersion = req.SchemaVersion;
            req.billingToken = req.paymentInstrumentID = string.Empty;

            if (paymentType == PaymentTypeEnum.Token)
            {
                req.billingToken = paymentIdOrToken;
            }
            else if (paymentType == PaymentTypeEnum.CreditCard)
            {
                req.paymentInstrumentID = paymentIdOrToken;
            }
            req.paymentInstrumentIDLength = (ushort)req.paymentInstrumentID.Length;
            req.billingTokenLength = (ushort)req.billingToken.Length;
            req.machinePuid = client.MachinePuid;
            req.paymentType = (uint)paymentType;
            req.userPuid = user.Puid;
            wmid.wmidLength = (ushort)wmid.wmid.Length;
            req.wmid = wmid;
            req.expectedPrice = expectedPrice;

            try
            {
                uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
                Throw.IfXErrFailed(hr);
            }
            finally
            {
                client.SchemaVersion = oldSchema;
            }

            METHOD.EXIT();
            return resp.wmids;
        }

        private static void SetMaxSchemaVersion(WireData xrl, ushort major, ushort minor)
        {
            uint schema = WireData.MakeSchemaVersion(major, minor);
            if (schema < xrl.SchemaVersion)
            {
                xrl.SchemaVersion = schema;
            }
        }

        public static TitleDetails XeGetTitleDetails(IClient client, XblUser user, uint titleId)
        {
            METHOD.ENTER();
            XeGetTitleDetailsRequest req = new XeGetTitleDetailsRequest();
            XeGetTitleDetailsResponse resp = new XeGetTitleDetailsResponse();

            req.countryId = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageId = user.Settings.PersonalInfo.LanguageId;
            req.tierRequired = (byte)user.Settings.UserType;
            req.titleId = titleId;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return new TitleDetails(resp);
        }

        public static EnumeratedTitles XeEnumerateTitlesByFilter(IClient client, XblUser user,
            TitleEnumerateFilter filter)
        {
            METHOD.ENTER();
            XeEnumerateTitlesByFilterRequest req = filter.ToXeEnumerateTitlesByFilterRequest();
            XeEnumerateTitlesByFilterResponse resp = new XeEnumerateTitlesByFilterResponse();

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return new EnumeratedTitles(resp);
        }

        public static EnumeratedGenres XeEnumerateGenres(IClient client, XblUser user, GenreEnumerateFilter filter)
        {
            METHOD.ENTER();
            XeEnumerateGenresRequest req = filter.ToXeEnumerateGenresRequest();
            XeEnumerateGenresResponse resp = new XeEnumerateGenresResponse();

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return new EnumeratedGenres(resp);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="client"></param>
        /// <param name="user"></param>
        /// <param name="voucher"></param>
        /// <param name="offeringType"></param>
        /// <returns>Offer ID</returns>
        public static ulong XeOfferingVerifyToken(IClient client, XblUser user, string voucher, out OfferingTypeEnum offerType)
        {
            METHOD.ENTER();
            XeOfferingVerifyTokenRequest req = new XeOfferingVerifyTokenRequest();
            XeOfferingVerifyTokenResponse resp = new XeOfferingVerifyTokenResponse();
            req.countryId = (byte)user.Settings.PersonalInfo.CountryId;
            req.voucher = voucher;
            req.voucherLength = (ushort)req.voucher.Length;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfHRFailed(hr);
            offerType = (OfferingTypeEnum)resp.offerTypeId;
            METHOD.EXIT();
            return resp.offerId;
        }

        public static void GetRevocationList(IClient client, XblUser user)
        {
            XeGetRevocationListRequest req = new XeGetRevocationListRequest();
            XRLObject2 resp = new XeGetRevocationListReply();

            uint hr = SendRequest(client, user, XOService.DRM, req, resp);
            Throw.IfXErrFailed(hr);
        }

        public static void XeBannerGetList(IClient client, XblUser user) { }
        public static void AssetEnumerate(IClient client, XblUser user) { }
        public static void AssetConsume(IClient client, XblUser user) { }
        public static void SignAssets(IClient client, XblUser user) { }
        public static void XeWmdrmCreateCertificate(IClient client, XblUser user) { }
        public static void XeAcknowledgeLicenseDelivery(IClient client, XblUser user) { }
        public static void XeAcquireVideoLicense(IClient client, XblUser user) { }
        public static void XeAcquireVideoContentURL(IClient client, XblUser user) { }
        public static void XeGetPointsPurchaseStatus(IClient client, XblUser user) { }
        public static void TransferMachineLicenses(IClient client, XblUser user) { }

        public static GetTitleActivationListResponse GetTitleActivationList(IClient _client, UInt32 _nonce)
        {
            return GetTitleActivationList(_client, _client.MachinePuid, _nonce, TitleActivationInfo.SIGNATUREFORMAT_LITTLE_ENDIAN);
        }

        public static GetTitleActivationListResponse GetTitleActivationList(IClient _client, UInt64 _puid, UInt32 _nonce)
        {
            return GetTitleActivationList(_client, _puid, _nonce, TitleActivationInfo.SIGNATUREFORMAT_LITTLE_ENDIAN);
        }

        public static GetTitleActivationListResponse GetTitleActivationList(IClient _client, UInt64 _Puid, UInt32 _nonce, UInt32 _signatureFormat)
        {
            GetTitleActivationListRequest req = new GetTitleActivationListRequest();
            XRLObject2 resp = new GetTitleActivationListResponse();

            req.machineId = _Puid;
            req.nonce = _nonce;
            req.requestedTitleId = _client.TitleId;
            req.signatureFormat = _signatureFormat;

            for (int i = 0; i < _client.LoggedOnUsers.Count; i++)
            {
                req.userIds[i] = _client.LoggedOnUsers[i].Puid;
            }

            uint hr = SendRequest(_client, null, XOService.DRM, req, resp);
            Throw.IfXErrFailed(hr);

            return (GetTitleActivationListResponse)resp;
        }

        // for 360 client
        public static MediaInstanceUrl[] FindMediaInstanceUrls(Xbox360Client client, Guid[] mediaInstanceIds)
        {
            return FindMediaInstanceUrls((IClient)client, null, mediaInstanceIds);
        }

        // for zune client
        public static MediaInstanceUrl[] FindMediaInstanceUrls(ZuneClient client, Guid[] mediaInstanceIds)
        {
            return FindMediaInstanceUrls((IClient)client, null, mediaInstanceIds);
        }

#if INTERNALTEST
        public
#endif
        static MediaInstanceUrl[] FindMediaInstanceUrls(IClient client, XblUser user, Guid[] mediaInstanceIds)
        {
            METHOD.ENTER();
            FindMediaInstanceUrlsRequest req = new FindMediaInstanceUrlsRequest();
            FindMediaInstanceUrlsResponse resp = new FindMediaInstanceUrlsResponse();
            req.mediaInstanceIds = mediaInstanceIds;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp.mediaInstanceUrls;

        }

        public static void PurchaseOffers(IClient client, XblUser user, OfferPriceInfo[] offers, PaymentTypeEnum paymentType, string billingTokenOrPaymentId)
        {
            PurchaseOffersRequest req = new PurchaseOffersRequest();
            METHOD.ENTER();
            if (billingTokenOrPaymentId == null)
            {
                billingTokenOrPaymentId = "";
            }

            req.MachinePuid = client.MachinePuid;
            req.UserPuid = user.Puid;
            req.Offers = OfferPriceInfo.ConvertToXrlArray(offers);
            req.OffersLength = (uint)req.Offers.Length;
            req.PaymentType = (uint)paymentType;
            req.PaymentInstrumentID = "";
            req.BillingToken = "";
            switch (paymentType)
            {
                case PaymentTypeEnum.CreditCard:
                    req.PaymentInstrumentID = billingTokenOrPaymentId;
                    break;
                case PaymentTypeEnum.Token:
                    req.BillingToken = billingTokenOrPaymentId;
                    break;
                case PaymentTypeEnum.Points:
                default:
                    break;
            }
            req.BillingToken = billingTokenOrPaymentId;
            req.BillingTokenLength = (ushort)req.BillingToken.Length;
            req.PaymentInstrumentIDLength = (ushort)req.PaymentInstrumentID.Length;
            if (client is ZuneClient)
            {
                req.StoreId = 2;
            }
            else
            {
                req.StoreId = 1;
            }

            uint hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, null);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();

        }


        public static XeVerifyTokenResponse XeVerifyToken(IClient client, XblUser user, string billingToken, uint storeId)
        {
            XeVerifyTokenRequest req = new XeVerifyTokenRequest();
            XeVerifyTokenResponse resp = new XeVerifyTokenResponse();

            METHOD.ENTER();

            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            req.billingToken = billingToken;
            req.storeId = storeId;

            uint hr = SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();

            return resp;
        }

        public static VerifyTokenResults WSVerifyToken(IClient client, XblUser user, string billingToken, int storeId)
        {
            VerifyTokenRequest req = new VerifyTokenRequest();
            VerifyTokenResults resp = new VerifyTokenResults();

            METHOD.ENTER();

            req.MachinePuid = client.MachinePuid;
            req.UserPuid = user.Puid;
            req.BillingToken = billingToken;
            req.StoreId = storeId;

            uint hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();

            return resp;
        }


        public static WSSubscriptionEnumerateResponse WSSubscriptionEnumerate(IClient client, XblUser user, uint offerType, uint paymentType, uint titleId, 
                                                                                                                                                    bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended)
        {
            uint hr;
            
            //WSSubscriptionEnumerateRequest req = filter.ToWSSubscriptionEnumerateRequest(client, user);
            WSSubscriptionEnumerateRequest req = new WSSubscriptionEnumerateRequest();
            WSSubscriptionEnumerateResponse resp = new WSSubscriptionEnumerateResponse();

            METHOD.ENTER();

            req.userPuid = user.Puid;
            req.machinePuid = client.MachinePuid;
            req.offerType = offerType;
            req.paymentType = paymentType;
            req.titleId = titleId;
            req.queryForNew = queryForNew;
            req.queryForRenewals = queryForRenewals;
            req.queryForCurrent = queryForCurrent;
            req.queryForCancelled = queryForCancelled;
            req.queryForSuspended = queryForSuspended;

            // Remove 2nd time call after bug # fixed
            try
            {
                Global.RO.Info(string.Format("Calling WSSubscriptionEnumerate 1st time"));
                hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, resp);
            }
            catch(XrlRequestException e)
            {
                Global.RO.Info(string.Format("Calling WSSubscriptionEnumerate 1st time failed : {0}", e.Message));

                Global.RO.Info(string.Format("Calling WSSubscriptionEnumerate 2nd time"));
                hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, resp);
            }

            Throw.IfXErrFailed(hr);
            METHOD.EXIT();

            return resp;
        }

        public delegate void DelegateRequest(HttpRequestObject2 request);

        public static uint PurchaseBillingOffer(IClient client, XblUser user, ulong offerID, PaymentTypeEnum paymentType, string paymentInstrumentID, string billingToken)
        {
            return PurchaseBillingOffer(client, user, offerID, paymentType, paymentInstrumentID, billingToken, null);
        }

        public static uint PurchaseBillingOffer(IClient client, XblUser user, ulong offerID, PaymentTypeEnum paymentType, string paymentInstrumentID, 
            string billingToken, DelegateRequest updateRequest)
        {
            PurchaseBillingOfferRequest req = new PurchaseBillingOfferRequest();
            METHOD.ENTER();


            req.MachinePuid = client.MachinePuid;
            req.UserPuid = user.Puid;
            req.OfferId = offerID;

            req.PaymentType = (uint)paymentType;

            req.PaymentInstrumentID = paymentInstrumentID;
            req.BillingToken = billingToken;

            if (updateRequest != null)
                updateRequest(req);

            uint hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();

            return hr;
        }

        public static uint PreviewPurchaseMediaOffersXrl(IClient client, XblUser user, Guid[] offerIds,
            int[] mediaTypeIds, live.common.PaymentTypeEnum paymentType, string paymentInstrumentId, uint expectedResult, uint storeId, XOService service, string billingToken, uint schemaversion, out live.protocol.next.XePreviewProductPurchaseResponse resp)
        {
            METHOD.ENTER();

            resp = null;

            if (paymentInstrumentId == null)
            {
                paymentInstrumentId = "";
            }

            if (paymentInstrumentId == "" && paymentType == live.common.PaymentTypeEnum.CreditCard)
                paymentInstrumentId = user.Settings.BillingInfo.ActivePaymentInstrumentId;

            live.protocol.next.XePreviewProductPurchaseRequest req = new live.protocol.next.XePreviewProductPurchaseRequest();
            resp = new live.protocol.next.XePreviewProductPurchaseResponse();
            resp.SchemaVersion = schemaversion;


            req.SchemaVersion = schemaversion;
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;

            live.protocol.next.OfferProductInfo[] offers = new live.protocol.next.OfferProductInfo[offerIds.Length];
            for (int ii = 0; ii < offerIds.Length; ii++)
            {
                offers[ii] = new live.protocol.next.OfferProductInfo();
                offers[ii].productTypeId = mediaTypeIds[ii];
                offers[ii].offerId = offerIds[ii];
            }

            req.offers = offers;
            req.paymentType = (uint)paymentType;
            req.paymentInstrumentID = paymentInstrumentId;
            req.storeId = storeId;
            req.billingToken = billingToken;
            req.billingTokenLength = (ushort)billingToken.Length;

            uint actualResult = HResult.E_FAIL;
            try
            {
                actualResult = live.server.Billing.SendRequest(client, user, service, req, resp);
            }
            catch (live.common.XrlRequestException ex)
            {
                if (expectedResult == 0x0)
                {
                    Global.RO.Error(string.Format("PreviewPurchase of offer failed with: {0}, \n Exception: {1} \n {2}", ex.Message, ex.RespData, ex.InnerException));
                }
                else
                {
                    Global.RO.Info(string.Format("PreviewPurchase of offer failed with: {0}, Exception: {1}", ex.Message, ex.RespData));
                    System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
                    try
                    {
                        doc.LoadXml(ex.RespData);
                        System.Xml.XmlNode hrNode = doc.SelectSingleNode("//HResult");
                        if (hrNode != null)
                        {
                            actualResult = Convert.ToUInt32(hrNode.InnerText, 16);
                        }
                    }
                    catch (Exception ex2)
                    {
                        Global.RO.Info(ex2.Message);
                    }
                }
            }
            catch (live.common.XErrFailedException xerr)
            {
                if (expectedResult == 0x0)
                {
                    Global.RO.Error(string.Format("PreviewPurchase of offer failed with: {0}, \n Exception: {1} ", xerr.Message, xerr.InnerException));
                }
                else
                {
                    actualResult = xerr.HResult;
                }
            }

            catch (Exception ex1)
            {
                if (expectedResult == 0x0)
                {
                    Global.RO.Error(string.Format("PreviewPurchase of offer failed with: {0}, Exception: {1} ", ex1.Message, ex1.InnerException));
                }
                else
                {
                    Global.RO.Info(string.Format("PreviewPurchase of offer failed with: {0}, Exception: {1}", ex1.Message, ex1.InnerException));
                }
                throw; 
            }
            finally
            {
            }

            METHOD.EXIT();

            return actualResult;
        }


        public static uint PurchaseMediaOffers(IClient client, XblUser user, XOService service, XePurchaseMediaOffersRequest req)
        {
            uint hr = SendRequest(client, user, service, req, null);
            return hr;
        }

        public static void XePurchaseMediaOffers(IClient client, XblUser user, OfferMediaTypeExpectedPrice [] offers, uint paymentType, string paymentInstrumentID, string billingToken, uint storeId)
        {
            XePurchaseMediaOffersRequest req = new XePurchaseMediaOffersRequest();
            //XePurchaseMediaOffersResponse resp = new XeVerifyTokenResponse();

            METHOD.ENTER();

            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            req.offers = offers;
            req.paymentType = paymentType;
            req.paymentInstrumentID = paymentInstrumentID;
            req.billingToken = billingToken;
            req.storeId = storeId;

            uint hr = PurchaseMediaOffers(client, user, XOService.Billing_Offering, req);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }

        public static uint PurchaseMediaOffers(
                    IClient client
                   , XblUser user
                   , Guid offerId 
                   , uint priceWhole
                   , uint priceFractional
                   , int mediaTypeId
                   , PaymentTypeEnum paymentType
                   , string billingToken
                   , string paymentInstrumentId                 
                   , uint storeId
                   , uint? timeExtendedinMonths
            )
        {
            uint overriddenSchemaVersion = Config.Current.GetDefaultSchemaVersion();
            if(timeExtendedinMonths != null) {
                overriddenSchemaVersion  = WireData.MakeSchemaVersion(6, 4);
            }

            OfferMediaTypeExpectedPrice [] offerPrices = new OfferMediaTypeExpectedPrice[1];

            offerPrices[0] = new OfferMediaTypeExpectedPrice();

            offerPrices[0].expectedPriceFractional = priceFractional;

            offerPrices[0].expectedPriceWhole = priceWhole;

            offerPrices[0].offerId = offerId;

            offerPrices[0].mediaTypeId = mediaTypeId;


            XePurchaseMediaOffersRequest req = CreatePurchaseMediaOffersRequest(client, user, offerPrices, paymentType, billingToken, paymentInstrumentId, 
                                  storeId, timeExtendedinMonths, timeExtendedinMonths != null, overriddenSchemaVersion);

            uint ret = PurchaseMediaOffers(client, user, XOService.Billing_Offering, req);
            if (ret != HResult.S_OK)
            {
                throw new XErrFailedException(ret);
            }
            return ret;
        }

        private static XePurchaseMediaOffersRequest CreatePurchaseMediaOffersRequest
                (
                     IClient client
                   , XblUser user
                   , OfferMediaTypeExpectedPrice[] offers
                   , PaymentTypeEnum paymentType
                   , string billingToken
                   , string paymentInstrumentId
                   , uint storeId
                   , uint? timeExtendedinMonths
                   , bool overrideDefaultSchema
                   , uint overriddenSchemaVersion
               )
        {
            if (billingToken == null)
            {
                billingToken = "";
            }

            if (paymentInstrumentId == null)
            {
                paymentInstrumentId = "";
            }

            if (paymentInstrumentId == "" && paymentType == live.common.PaymentTypeEnum.CreditCard)
                paymentInstrumentId = user.Settings.BillingInfo.ActivePaymentInstrumentId;

            XePurchaseMediaOffersRequest req = new XePurchaseMediaOffersRequest();

            if (overrideDefaultSchema)
            {
                req.SchemaVersion = overriddenSchemaVersion;
            }

            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            req.offers = offers;
            req.paymentType = (uint)paymentType;
            req.paymentInstrumentID = paymentInstrumentId;
            req.billingToken = billingToken;
            req.storeId = storeId;

            //If the time extended has no null value then set the subscriptionPurchaseInfo as null
            if (!timeExtendedinMonths.HasValue)
            {
                req.subscriptionPurchaseInfo = null;
            }
            else
            {
                req.subscriptionPurchaseInfo = new live.protocol.SubscriptionPurchaseInfo();
                req.subscriptionPurchaseInfo.subscriptionTimeExtendedInMonths = timeExtendedinMonths.Value;
            }

            return req;
        }

    }


}

namespace live.server.next
{
    using live.client;
    using live.protocol.next;

    public static class Billing
    {
        //
        // Billing Web Methods
        //

        public static uint PurchaseOffersXrl(Xbox360Client client, XblUser user, Guid[] offerIds,
            uint[] expectedPrices, PaymentTypeEnum paymentType, string billingToken)
        {
            return PurchaseOffersXrlWithMachinePuid(client, client.MachinePuid, user, offerIds, expectedPrices, paymentType, billingToken);
        }

        public static uint PurchaseOffersXrlWithMachinePuid(Xbox360Client client, ulong machinePuid, XblUser user, Guid[] offerIds,
            uint[] expectedPrices, PaymentTypeEnum paymentType, string billingToken)
        {
            METHOD.ENTER();
            if (billingToken == null)
            {
                billingToken = "";
            }

            OfferExpectedPrice[] offers = new OfferExpectedPrice[offerIds.Length];
            for (int i = 0; i < offerIds.Length; i++)
            {
                offers[i] = new OfferExpectedPrice();
                offers[i].offerId = offerIds[i];
                offers[i].expectedPrice = expectedPrices[i];
            }

            XRLPurchaseOffersRequest req = new XRLPurchaseOffersRequest();
            XRLObject2 resp = null;
            req.MachinePuid = machinePuid;
            req.UserPuid = user.Puid;
            req.Offers = offers;
            req.OffersLength = (uint)offers.Length;
            req.PaymentType = (uint)paymentType;
            req.BillingToken = billingToken;
            req.PaymentInstrumentIDLength = 0;
            req.PaymentInstrumentID = "";
            req.BillingTokenLength = (ushort)req.BillingToken.Length;

            uint hr = live.server.Billing.SendRequest(client, user, XOService.Billing_Offering, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();

            return hr;
        }


    }

    public static class WebBilling
    {
        public static PurchaseOffersWebResponse PurchaseOffers(IClient client, XblUser user, Guid[] offerIds,
            uint[] expectedPrices, PaymentTypeEnum paymentType, string billingToken)
        {
            METHOD.ENTER();
            if (billingToken == null)
            {
                billingToken = "";
            }

            PurchaseOffersWebRequest req = new PurchaseOffersWebRequest();
            PurchaseOffersWebResponse resp = new PurchaseOffersWebResponse();

            req.MachinePuid = client.MachinePuid;
            req.UserPuid = user.Puid;
            System.Net.IPHostEntry iphe = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            req.IPAddress = iphe.AddressList[0].ToString();
            req.OfferIds = offerIds;
            req.ExpectedPrices = expectedPrices;
            req.PaymentType = paymentType;
            req.PaymentInstrumentId = "";   // Only points and tokens are currently supported
            req.BillingToken = billingToken;

            //req.SetWebRequestType(WebRequestBase.WebRequestType.Get);

            uint hr = live.server.Billing.SendRequest(client, user, XOService.WebBilling, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public delegate void DelegateReqResp(PurchaseHistoryWebRequest req, PurchaseHistoryWebResponse resp);

        public static PurchaseHistoryWebResponse GetPurchaseHistory(IClient client, XblUser user, List<StringPair> filterList, DelegateReqResp updateReqResp)
        {
            METHOD.ENTER();
            PurchaseHistoryWebRequest req = new PurchaseHistoryWebRequest(user.Puid, client.MachinePuid, filterList);
            PurchaseHistoryWebResponse resp = new PurchaseHistoryWebResponse();

            if (updateReqResp != null)
                updateReqResp(req, resp);

            uint hr = live.server.Billing.SendRequest(client, user, XOService.WebBilling, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public static PurchaseHistoryWebResponse GetPurchaseHistoryV2(IClient client, XblUser user, List<StringPair> filterList, DelegateReqResp updateReqResp)
        {
            METHOD.ENTER();
            PurchaseHistoryWebRequest req = new PurchaseHistoryWebRequest(user.Puid, client.MachinePuid, filterList,"PurchaseHistoryV2");
            PurchaseHistoryWebResponse resp = new PurchaseHistoryWebResponse();

            if (updateReqResp != null)
                updateReqResp(req, resp);

            uint hr = live.server.Billing.SendRequest(client, user, XOService.WebBilling, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }


        public static PurchaseHistoryWebResponse GetPurchaseHistory(IClient client, XblUser user, List<StringPair> filterList)
        {
            return GetPurchaseHistory(client, user, filterList, null);
        }

        public static DownloadHistoryWebResponse DownloadHistory(IClient client, XblUser user, List<StringPair> filterList)
        {
            METHOD.ENTER();
            DownloadHistoryWebRequest req = new DownloadHistoryWebRequest(user.Puid, client.MachinePuid, filterList);
            DownloadHistoryWebResponse resp = new DownloadHistoryWebResponse();

            uint hr = live.server.Billing.SendRequest(client, user, XOService.WebBilling, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public delegate void DelegateSubOfferEnumerateReq(SubscriptionOfferEnumerateWebRequest req);
        public static SubscriptionOfferEnumerateWebResponse GetSubscriptionOffers(IClient client, XblUser user, ulong queryModifier, List<StringPair> filterList, DelegateSubOfferEnumerateReq updateReqResp)
        {
            METHOD.ENTER();
            SubscriptionOfferEnumerateWebRequest req = new SubscriptionOfferEnumerateWebRequest(user.Puid, client.MachinePuid, queryModifier,filterList);
            SubscriptionOfferEnumerateWebResponse resp = new SubscriptionOfferEnumerateWebResponse();

            if (updateReqResp != null)
                updateReqResp(req);

            uint hr = live.server.Billing.SendRequest(client, user, XOService.WebBilling, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\feedback.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.protocol;
using System.Diagnostics;


namespace live.server
{
    public static class Feedback
    {
        public static void SendComplaint(IClient client, XblUser user, ulong targetPUID, uint titleID, live.protocol.FeedbackDefs.ComplaintType type, ulong context)
        {
            METHOD.ENTER();
            SubmitComplaintRequest req = new SubmitComplaintRequest();
            req.context = context;
            req.senderPUID = user.Puid;
            req.targetPUID = targetPUID;
            req.titleID = titleID;
            req.type = (uint)type;

            XRLObject2 resp = null;
            uint hr = client.SendRequest(user, XOService.Feedback, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
        }



        public static void SendReview(IClient client, XblUser user, ulong targetPUID, uint titleID, live.protocol.FeedbackDefs.PlayerReview type, ulong context)
        {
            METHOD.ENTER();
            SubmitReviewRequest req = new SubmitReviewRequest();
            req.context = context;
            req.senderPUID = user.Puid;
            req.targetPUID = targetPUID;
            req.titleID = titleID;
            req.type = (uint)type;
            
            XRLObject2 resp = null;
            uint hr = client.SendRequest(user, XOService.Feedback, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
        }




    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\DownloadQueue.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

using live.common;
using live.common.next;
using live.protocol;

namespace live.server
{
    public static class DownloadQueue
    {
        public const int DOWNLOAD_QUEUE_TYPE = 55129;


        private static uint SendRequest(IClient client,
                                        XblUser user,
                                        PayloadRequest req,
                                        PayloadResponse resp)
        {
            return SendRequest(client, user, XOService.Lists, req, resp);
        }


        private static uint SendRequest(IClient client,
                                        XblUser user,
                                        XOService service,
                                        PayloadRequest req,
                                        PayloadResponse resp)
        {
            req.SetPayloadTypeFor(client, resp);

            uint hr = client.SendRequest(user, service, 
                                         req.GetRelativeUrl(),
                                         req.GetHttpMethod(),
                                         null,
                                         req,
                                         resp);

            return hr;
        }

        // Async Helpers
        private static IAsyncResult BeginSendRequest(IClient client,
                                                     XblUser user,
                                                     PayloadRequest req,
                                                     AsyncCallback callback,
                                                     Object state)
        {
            return BeginSendRequest(client, user, XOService.Lists,
                                    req, callback, state);
        }

        private static IAsyncResult BeginSendRequest(IClient client,
                                                     XblUser user,
                                                     XOService service,
                                                     PayloadRequest req,
                                                     AsyncCallback callback,
                                                     Object state)
        {
            req.SetPayloadTypeFor(client, null);

            // Wrap the base AsyncResult with ClientAsyncContext
            // which maintains extra data about the call
            // like the Client object and Request object that initiated 
            // the call            
            ClientAsyncContext context = 
                new ClientAsyncContext(callback,
                                       state,
                                       client,
                                       req);

            IAsyncResult baseResult = 
                client.BeginSendRequest(
                    client,
                    user,
                    service,
                    req.GetRelativeUrl(),
                    req.GetHttpMethod(),
                    null,
                    req,
                    new AsyncCallback(context.HandleCallback),
                    null);

            context.BaseResult = baseResult;
            return context;
        }

        private static uint EndSendRequest(IAsyncResult asyncResult,
                                           PayloadResponse resp)
        {
            ClientAsyncContext context = (ClientAsyncContext)asyncResult;
            
            // Get the Client and the Request object for this call from the
            // context
            IClient client = context.Client;

            PayloadRequest req = (PayloadRequest)context.Request;
            req.SetPayloadTypeFor(client, resp);            
            
            return client.EndSendRequest(context.BaseResult,
                                         resp);
        }


        // ---  Public APIs ---

        // CreateDownloadQueue methods  

        // Synchronous version
        public static uint CreateDownloadQueue(IClient client, 
                                               XblUser user, 
                                               String name, 
                                               String xmlProperties, 
                                               out int listId,
                                               out DateTime timestamp)
        {
            METHOD.ENTER();
            CreateDownloadQueueRequest req = new CreateDownloadQueueRequest();
            CreateDownloadQueueResponse resp = 
                new CreateDownloadQueueResponse();

            listId = Int32.MinValue;
            timestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            
            req.nameLength = (byte)name.Length;
            req.name = name;

            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                listId = resp.listId;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult 
        BeginCreateDownloadQueue(IClient client, 
                                 XblUser user, 
                                 String name, 
                                 String xmlProperties,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();
            CreateDownloadQueueRequest req = new CreateDownloadQueueRequest();

            req.userPuid = user.Puid;
            
            req.nameLength = (byte)name.Length;
            req.name = name;

            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req, 
                                                                 callback,
                                                                 state); 

            METHOD.EXIT();
            return result;
        }


        public static uint
        EndCreateDownloadQueue(IAsyncResult asyncResult,
                               out int listId,
                               out DateTime timestamp)
        {
            METHOD.ENTER();
            uint hr;

            listId = Int32.MinValue;
            timestamp = DateTime.MinValue;

            CreateDownloadQueueResponse resp = 
                new CreateDownloadQueueResponse();

            hr = DownloadQueue.EndSendRequest(asyncResult,
                                              resp);
            if (hr == 0)
            {
                listId = resp.listId;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;            
        }                                 


        // ModifyDownloadQueue methods

        // Synchronous version
        public static uint ModifyDownloadQueue(IClient client,
                                               XblUser user, 
                                               int listId,
                                               DateTime currentTimestamp,
                                               String xmlProperties,
                                               out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            ModifyDownloadQueueRequest req = 
                new ModifyDownloadQueueRequest();
            
            ModifyDownloadQueueResponse resp = 
                new ModifyDownloadQueueResponse();
            
            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;
            
            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp);

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }
        
        // Asynchronous methods
        public static IAsyncResult 
        BeginModifyDownloadQueue(
            IClient client,
            XblUser user, 
            int listId,
            DateTime currentTimestamp,
            String xmlProperties,
            AsyncCallback callback,
            Object state)
        {
            METHOD.ENTER();
            
            ModifyDownloadQueueRequest req = 
                new ModifyDownloadQueueRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;
            
            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;
            
            IAsyncResult result = DownloadQueue.BeginSendRequest(client,
                                                                 user,
                                                                 req,
                                                                 callback,
                                                                 state);

            METHOD.EXIT();
            return result;
        }

        public static uint EndModifyDownloadQueue(IAsyncResult asyncResult,
                                                  out DateTime newTimestamp)
        {
            METHOD.ENTER();
            uint hr;

            newTimestamp = DateTime.MinValue;

            ModifyDownloadQueueResponse resp = 
                new ModifyDownloadQueueResponse();

            hr = DownloadQueue.EndSendRequest(asyncResult,
                                              resp);
            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;                    
        }
                                                  
        
        // QueryDownloadQueue methods

        // Synchronous version
        public static uint QueryDownloadQueues(IClient client, 
                                               XblUser user, 
                                               int listId,
                                               DateTime lastModified,
                                               int pageSize,
                                               int pageNum,
                                               int orderDir,
                                               out ListInfo[] results,
                                               out ushort totalLists)
        {
            METHOD.ENTER();
            
            QueryDownloadQueuesRequest req = 
                new QueryDownloadQueuesRequest();
            
            QueryDownloadQueuesResponse resp = 
                new QueryDownloadQueuesResponse();

            results = null;
            totalLists = 0;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = lastModified;
            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                results = resp.resultDownloadQueues;
                totalLists = resp.totalDownloadQueues;
            }
            
            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult 
        BeginQueryDownloadQueues(IClient client, 
                                 XblUser user, 
                                 int listId,
                                 DateTime lastModified,
                                 int pageSize,
                                 int pageNum,
                                 int orderDir,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();
            
            QueryDownloadQueuesRequest req = 
                new QueryDownloadQueuesRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = lastModified;
            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state); 
            METHOD.EXIT();
            return result;
        }

        public static uint 
        EndQueryDownloadQueues(IAsyncResult asyncResult,
                               out ListInfo[] results,
                               out ushort totalLists)
        {
            METHOD.ENTER();
            
            QueryDownloadQueuesResponse resp = 
                new QueryDownloadQueuesResponse();
            
            results = null;
            totalLists = 0;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp);

            if (hr == 0)
            {
                results = resp.resultDownloadQueues;
                totalLists = resp.totalDownloadQueues;
            }
            
            METHOD.EXIT();
            return hr;
        }

        // DeleteDownloadQueue methods  

        // Synchronous version
        public static uint DeleteDownloadQueue(IClient client, 
                                               XblUser user, 
                                               int listId)
        {
            METHOD.ENTER();

            DeleteListRequest req = new DeleteListRequest();
            DeleteListResponse resp = new DeleteListResponse();

            req.userPuid = user.Puid;
            req.listType = DOWNLOAD_QUEUE_TYPE;
            req.listId = listId;
            
            uint hr = DownloadQueue.SendRequest(client, user, 
                                                XOService.Lists_Internal,
                                                req, resp); 
            
            METHOD.EXIT();
            return hr;
        }
        

        // Asynchronous methods
        public static IAsyncResult 
        BeginDeleteDownloadQueue(IClient client, 
                                 XblUser user, 
                                 int listId,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();
            
            DeleteListRequest req = new DeleteListRequest();
            
            req.userPuid = user.Puid;
            req.listType = DOWNLOAD_QUEUE_TYPE;
            req.listId = listId;
            
            IAsyncResult result = 
                DownloadQueue.BeginSendRequest(client, 
                                               user,
                                               XOService.Lists_Internal,
                                               req, 
                                               callback,
                                               state); 
            
            METHOD.EXIT();
            return result;
        }

        public static uint
        EndDeleteDownloadQueue(IAsyncResult asyncResult)
        {
            METHOD.ENTER();
            uint hr;

            DeleteListResponse resp = 
                new DeleteListResponse();

            hr = DownloadQueue.EndSendRequest(asyncResult,
                                              resp);
            METHOD.EXIT();
            return hr;            
        }


        // Grant access to a machine to a user's list

        // Synchronous version
        public static uint GrantDownloadQueueAccess(IClient client,
                                                    XblUser user,
                                                    int listId,
                                                    ulong machinePuid)
        {
            METHOD.ENTER();

            GrantDownloadQueueAccessRequest req = 
                new GrantDownloadQueueAccessRequest();
            GrantDownloadQueueAccessResponse resp = 
                new GrantDownloadQueueAccessResponse();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.machinePuid = machinePuid;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            METHOD.EXIT();
            return hr;
        }

        // Asyncronous methods 
        public static IAsyncResult
        BeginGrantDownloadQueueAccess(IClient client,
                                      XblUser user,
                                      int listId,
                                      ulong machinePuid,
                                      AsyncCallback callback,
                                      Object state)
        {
            METHOD.ENTER();

            GrantDownloadQueueAccessRequest req = 
                new GrantDownloadQueueAccessRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.machinePuid = machinePuid;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state); 

            METHOD.EXIT();
            return result;
        }

        public static uint 
        EndGrantDownloadQueueAccess(IAsyncResult asyncResult)
        {
            METHOD.ENTER();

            GrantDownloadQueueAccessResponse resp = 
                new GrantDownloadQueueAccessResponse();

            uint hr = DownloadQueue.EndSendRequest(asyncResult, resp); 

            METHOD.EXIT();
            return hr;
        }


        // Revoke access to all machines to a user's list

        // Synchronous version
        public static uint RevokeDownloadQueueAccess(IClient client,
                                                     XblUser user,
                                                     int listId,
                                                     ulong machinePuid)
        {
            METHOD.ENTER();

            RevokeDownloadQueueAccessRequest req = 
                new RevokeDownloadQueueAccessRequest();
            RevokeDownloadQueueAccessResponse resp = 
                new RevokeDownloadQueueAccessResponse();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.machinePuid = machinePuid;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult
        BeginRevokeDownloadQueueAccess(IClient client,
                                       XblUser user,
                                       int listId,
                                       ulong machinePuid,
                                       AsyncCallback callback,
                                       Object state)
        {
            METHOD.ENTER();

            RevokeDownloadQueueAccessRequest req = 
                new RevokeDownloadQueueAccessRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.machinePuid = machinePuid;

            IAsyncResult result = 
                DownloadQueue.BeginSendRequest(client, 
                                               user, 
                                               req, 
                                               callback,
                                               state);
            
            METHOD.EXIT();
            return result;
        }
        
        public static uint 
        EndRevokeDownloadQueueAccess(IAsyncResult asyncResult)
        {
            METHOD.ENTER();

            RevokeDownloadQueueAccessResponse resp = 
                new RevokeDownloadQueueAccessResponse();

            uint hr = DownloadQueue.EndSendRequest(asyncResult, resp);

            METHOD.EXIT();
            return hr;
        }

        // Insert a list of items into a list

        // Synchronous version
        public static uint InsertDownloadItems(IClient client,
                                               XblUser user,
                                               int listId,
                                               DateTime currentTimestamp,
                                               ListItem[] items,
                                               out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            InsertDownloadItemsRequest req = 
                new InsertDownloadItemsRequest();
            InsertDownloadItemsResponse resp = 
                new InsertDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numDownloadItems = (ushort)items.Length;
            req.items = items;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }
        
        // Asynchronous methods
        public static IAsyncResult
        BeginInsertDownloadItems(IClient client,
                                 XblUser user,
                                 int listId,
                                 DateTime currentTimestamp,
                                 ListItem[] items,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();
            
            InsertDownloadItemsRequest req = 
                new InsertDownloadItemsRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numDownloadItems = (ushort)items.Length;
            req.items = items;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state);

            METHOD.EXIT();
            return result;
        }

        public static uint 
        EndInsertDownloadItems(IAsyncResult asyncResult,
                               out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            InsertDownloadItemsResponse resp = 
                new InsertDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp);

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Delete items in a list

        // Synchronous version
        public static uint DeleteDownloadItems(IClient client,
                                               XblUser user,
                                               int listId,
                                               DateTime currentTimestamp,
                                               Guid[] itemIds,
                                               out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            DeleteDownloadItemsRequest req = 
                new DeleteDownloadItemsRequest();
            DeleteDownloadItemsResponse resp = 
                new DeleteDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult
        BeginDeleteDownloadItems(IClient client,
                                 XblUser user,
                                 int listId,
                                 DateTime currentTimestamp,
                                 Guid[] itemIds,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();
            
            DeleteDownloadItemsRequest req = 
                new DeleteDownloadItemsRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state);

            METHOD.EXIT();
            return result;
        }


        public static uint 
        EndDeleteDownloadItems(IAsyncResult asyncResult,
                               out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            DeleteDownloadItemsResponse resp = 
                new DeleteDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp); 

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Modify items in a list

        // Synchronous version
        public static uint ModifyDownloadItems(IClient client,
                                               XblUser user,
                                               int listId,
                                               DateTime currentTimestamp,
                                               ListItemMod[] items,
                                               out DateTime newTimestamp)
        {
            METHOD.ENTER();

            ModifyDownloadItemsRequest req = 
                new ModifyDownloadItemsRequest();
            ModifyDownloadItemsResponse resp = 
                new ModifyDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numDownloadItems = (ushort)items.Length;
            req.items = items;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }
            
            METHOD.EXIT();
            return hr;
        }
        
        // Asynchronous methods
        public static IAsyncResult
        BeginModifyDownloadItems(IClient client,
                                 XblUser user,
                                 int listId,
                                 DateTime currentTimestamp,
                                 ListItemMod[] items,
                                 AsyncCallback callback,
                                 Object state)
        {
            METHOD.ENTER();

            ModifyDownloadItemsRequest req = 
                new ModifyDownloadItemsRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numDownloadItems = (ushort)items.Length;
            req.items = items;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state);
            
            METHOD.EXIT();
            return result;
        }

        public static uint 
        EndModifyDownloadItems(IAsyncResult asyncResult,
                               out DateTime newTimestamp)
        {
            METHOD.ENTER();

            ModifyDownloadItemsResponse resp = 
                new ModifyDownloadItemsResponse();

            newTimestamp = DateTime.MinValue;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp);

            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }
            
            METHOD.EXIT();
            return hr;
        }


        // Query list items from a list

        // Synchronous version
        public static uint QueryDownloadItems(IClient client, 
                                              XblUser user, 
                                              int listId,
                                              int pageSize,
                                              int pageNum,
                                              int orderDir,
                                              Guid[] itemIds,
                                              out ListItem[] results,
                                              out ushort totalItems,
                                              out DateTime timestamp)
        {
            METHOD.ENTER();
            QueryDownloadItemsRequest req = new QueryDownloadItemsRequest();
            QueryDownloadItemsResponse resp = new QueryDownloadItemsResponse();

            results = null;
            totalItems = 0;
            timestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;

            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            uint hr = DownloadQueue.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                results = resp.resultDownloadItems;
                totalItems = resp.totalDownloadItems;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult
        BeginQueryDownloadItems(IClient client, 
                                XblUser user, 
                                int listId,
                                int pageSize,
                                int pageNum,
                                int orderDir,
                                Guid[] itemIds,
                                AsyncCallback callback,
                                Object state)
        {
            METHOD.ENTER();
            QueryDownloadItemsRequest req = new QueryDownloadItemsRequest();

            req.userPuid = user.Puid;
            req.listId = listId;

            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client, 
                                                                 user, 
                                                                 req,
                                                                 callback,
                                                                 state);
            METHOD.EXIT();
            return result;
        }

        public static uint 
        EndQueryDownloadItems(IAsyncResult asyncResult,
                              out ListItem[] results,
                              out ushort totalItems,
                              out DateTime timestamp)
        {
            METHOD.ENTER();
            QueryDownloadItemsResponse resp = new QueryDownloadItemsResponse();

            results = null;
            totalItems = 0;
            timestamp = DateTime.MinValue;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp);

            if (hr == 0)
            {
                results = resp.resultDownloadItems;
                totalItems = resp.totalDownloadItems;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Move items in a list

        // Synchronous version
        public static uint MoveDownloadItems(IClient client,
                                             XblUser user,
                                             int listId,
                                             DateTime currentTimestamp,
                                             ListItemIndex[] moves,
                                             out DateTime newTimestamp)
        {
            METHOD.ENTER();
            MoveDownloadItemsRequest req = new MoveDownloadItemsRequest();
            MoveDownloadItemsResponse resp = new MoveDownloadItemsResponse();
            
            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numIndices = (ushort)moves.Length;
            req.itemIndices = moves;

            uint hr = DownloadQueue.SendRequest(client,
                                                user,
                                                req,
                                                resp);

            
            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Asynchronous methods
        public static IAsyncResult
        BeginMoveDownloadItems(IClient client,
                               XblUser user,
                               int listId,
                               DateTime currentTimestamp,
                               ListItemIndex[] moves,
                               AsyncCallback callback,
                               Object state)
        {
            METHOD.ENTER();
            MoveDownloadItemsRequest req = new MoveDownloadItemsRequest();

            req.userPuid = user.Puid;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numIndices = (ushort)moves.Length;
            req.itemIndices = moves;

            IAsyncResult result = DownloadQueue.BeginSendRequest(client,
                                                                 user,
                                                                 req,
                                                                 callback,
                                                                 state);

            METHOD.EXIT();
            return result;
        }
        
        public static uint 
        EndMoveDownloadItems(IAsyncResult asyncResult,
                             out DateTime newTimestamp)
        {
            METHOD.ENTER();
            MoveDownloadItemsResponse resp = new MoveDownloadItemsResponse();
            
            newTimestamp = DateTime.MinValue;

            uint hr = DownloadQueue.EndSendRequest(asyncResult,
                                                   resp);
            
            if (hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Lists.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

using live.common;
using live.common.next;
using live.protocol;

namespace live.server
{
    public static class Lists
    {
        private static uint SendRequest(IClient client,
                                        XblUser user,
                                        XOService service,
                                        PayloadRequest req,
                                        PayloadResponse resp)
        {
            req.SetPayloadTypeFor(client, resp);

            uint hr = client.SendRequest(user, service, 
                                         req.GetRelativeUrl(),
                                         req.GetHttpMethod(),
                                         null,
                                         req,
                                         resp);

            return hr;
        }

        private static uint SendRequest(IClient client,
                                        XblUser user,
                                        PayloadRequest req,
                                        PayloadResponse resp)
        {
            return SendRequest(client, user, XOService.Lists, req, resp);
        }

        // Create a List instance
        public static uint CreateList(IClient client, 
                                      XblUser user, 
                                      int listType, 
                                      String name, 
                                      String xmlProperties, 
                                      out int listId,
                                      out DateTime timestamp)
        {
            METHOD.ENTER();
            CreateListRequest req = new CreateListRequest();
            CreateListResponse resp = new CreateListResponse();

            listId = Int32.MinValue;
            timestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            
            req.nameLength = (byte)name.Length;
            req.name = name;

            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if (hr == 0)
            {
                listId = resp.listId;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Delete a list by it's id
        public static uint DeleteList(IClient client,
                                      XblUser user,
                                      int listType,
                                      int listId)
        {
            METHOD.ENTER();

            DeleteListRequest req = new DeleteListRequest();
            DeleteListResponse resp = new DeleteListResponse();

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;

            uint hr = Lists.SendRequest(client, 
                                        user, 
                                        XOService.Lists_Internal,
                                        req, 
                                        resp);

            METHOD.EXIT();
            return hr;
        }
           
        // Modify Properties of an existing list
        public static uint ModifyList(IClient client,
                                      XblUser user, 
                                      int listType,
                                      int listId,
                                      DateTime currentTimestamp,
                                      String xmlProperties,
                                      out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            ModifyListRequest req = new ModifyListRequest();
            ModifyListResponse resp = new ModifyListResponse();
            
            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = currentTimestamp;
            
            req.xmlLength = (ushort)xmlProperties.Length;
            req.xmlProperties = xmlProperties;

            uint hr = Lists.SendRequest(client, user, req, resp);

            if(hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        
        // Query existing lists
        public static uint QueryLists(IClient client, 
                                      XblUser user, 
                                      int listType,
                                      int listId,
                                      DateTime lastModified,
                                      int pageSize,
                                      int pageNum,
                                      int orderDir,
                                      out ListInfo[] results,
                                      out ushort totalLists)
        {
            METHOD.ENTER();
            QueryListsRequest req = new QueryListsRequest();
            QueryListsResponse resp = new QueryListsResponse();

            results = null;
            totalLists = 0;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = lastModified;
            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if(hr == 0)
            {
                results = resp.resultLists;
                totalLists = resp.totalLists;
            }
            
            METHOD.EXIT();
            return hr;
        }

        // Grant access to client to a user's list
        public static uint GrantListAccess(IClient client,
                                           XblUser user,
                                           int listType,
                                           int listId,
                                           ulong machinePuid)
        {
            METHOD.ENTER();

            GrantListAccessRequest req = new GrantListAccessRequest();
            GrantListAccessResponse resp = new GrantListAccessResponse();

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.machinePuid = machinePuid;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            METHOD.EXIT();
            return hr;
        }

        // Revoke access to all machines to a user's list
        public static uint RevokeListAccess(IClient client,
                                            XblUser user,
                                            int listType,
                                            int listId,
                                            ulong machinePuid)
        {
            METHOD.ENTER();

            RevokeListAccessRequest req = new RevokeListAccessRequest();
            RevokeListAccessResponse resp = new RevokeListAccessResponse();

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.machinePuid = machinePuid;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            METHOD.EXIT();
            return hr;            
        }
                                           

        // Insert a list of items into a list
        public static uint InsertItems(IClient client,
                                       XblUser user,
                                       int listType,
                                       int listId,
                                       DateTime currentTimestamp,
                                       ListItem[] items,
                                       out DateTime newTimestamp)
        {
            METHOD.ENTER();
            InsertItemsRequest req = new InsertItemsRequest();
            InsertItemsResponse resp = new InsertItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numItems = (ushort)items.Length;
            req.items = items;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if(hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;            
        }

        // Delete items in a list
        public static uint DeleteItems(IClient client,
                                       XblUser user,
                                       int listType,
                                       int listId,
                                       DateTime currentTimestamp,
                                       Guid[] itemIds,
                                       out DateTime newTimestamp)
        {
            METHOD.ENTER();
            
            DeleteItemsRequest req = new DeleteItemsRequest();
            DeleteItemsResponse resp = new DeleteItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = currentTimestamp;
            
            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if(hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;            
        }

        // Modify items in a list
        public static uint ModifyItems(IClient client,
                                       XblUser user,
                                       int listType,
                                       int listId,
                                       DateTime currentTimestamp,
                                       ListItemMod[] items,
                                       out DateTime newTimestamp)
        {
            METHOD.ENTER();

            ModifyItemsRequest req = new ModifyItemsRequest();
            ModifyItemsResponse resp = new ModifyItemsResponse();

            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numItems = (ushort)items.Length;
            req.items = items;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if(hr == 0)
            {
                newTimestamp = resp.lastModified;
            }
            
            METHOD.EXIT();
            return hr;            
        }

        // Query list items from a list
        public static uint QueryItems(IClient client, 
                                      XblUser user, 
                                      int listType,
                                      int listId,
                                      int pageSize,
                                      int pageNum,
                                      int orderDir,
                                      Guid[] itemIds,
                                      out ListItem[] results,
                                      out ushort totalItems,
                                      out DateTime timestamp)
        {
            METHOD.ENTER();
            QueryItemsRequest req = new QueryItemsRequest();
            QueryItemsResponse resp = new QueryItemsResponse();

            results = null;
            totalItems = 0;
            timestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;

            req.pageSize = pageSize;
            req.pageNum = pageNum;
            req.orderDir = orderDir;

            req.numIds = (ushort)itemIds.Length;
            req.itemIds = itemIds;

            uint hr = Lists.SendRequest(client, user, req, resp); 

            if(hr == 0)
            {
                results = resp.resultItems;
                totalItems = resp.totalItems;
                timestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

        // Move items in a list
        public static uint MoveItems(IClient client,
                                     XblUser user,
                                     int listType,
                                     int listId,
                                     DateTime currentTimestamp,
                                     ListItemIndex[] moves,
                                     out DateTime newTimestamp)
        {
            METHOD.ENTER();
            MoveItemsRequest req = new MoveItemsRequest();
            MoveItemsResponse resp = new MoveItemsResponse();
            
            newTimestamp = DateTime.MinValue;

            req.userPuid = user.Puid;
            req.listType = listType;
            req.listId = listId;
            req.lastModified = currentTimestamp;

            req.numIndices = (ushort)moves.Length;
            req.itemIndices = moves;

            uint hr = Lists.SendRequest(client,
                                        user,
                                        req,
                                        resp);

            
            if(hr == 0)
            {
                newTimestamp = resp.lastModified;
            }

            METHOD.EXIT();
            return hr;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Messaging.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using HttpStatusCode = System.Net.HttpStatusCode;

using live.common;
using live.protocol;
using live.protocol.Presence;

namespace live.server
{
    public static class Messaging
    {
        public static void SendTextMessage(IClient client, XblUser user, XblUser target, string text, byte messageType)
        {
            METHOD.ENTER();
            PNState state = Presence.GetPresenceForRequest(client, user);
            PNState targetState = Presence.GetPresence(target);

            MsgDetails details = MsgDetails.CreateBlank();
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT, text);
            details.AddProperty(XonPresNoti.MSG_PROP_TEXT_LANGUAGE, (uint)1);

            UserMessage msg = UserMessage.Create(
                state,
                messageType,
                0,
                XonPresNoti.MSG_FLAG_HAS_TEXT,
                0,
                details);
            msg.Send(state, targetState);
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\LiveInfo.cs ===
using System;
using System.Net;
using System.IO;

using live.common;
using live.protocol;

namespace live.server
{
    public static class LiveInfo
    {
        public static uint SendRequest(IClient client,
                                        XblUser user,
                                        XRLRequestObject2 reqOb,
                                        XRLObject2 respOb)
        {
            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, XOService.liveinfo,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            return hr;
        }

        public static GetLiveConfigResponse GetLiveConfig(IClient _client, XblUser _user, string _configType)
        {
            GetLiveConfigRequest request = new GetLiveConfigRequest();
            GetLiveConfigResponse response = new GetLiveConfigResponse();

            request.BehaviorInjection.AddNpdbOverride("fakeSetting", "10", true);

            request.configname = _configType;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }

        /// <summary>
        /// Takes in a set of generic blocks and deserializes it into the config string
        /// </summary>
        /// <param name="_blocks">The block[] returned by GetLiveConfig</param>
        /// <returns></returns>
        public static string DeserializeConfigBlocks(XeGenericBlock[] _blocks)
        {
            BlockDeserializer deserializer = new BlockDeserializer(_blocks);
            byte[] clear = deserializer.Deserialize();
            return System.Text.UTF8Encoding.UTF8.GetString(clear);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Matchmaking.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.protocol;

namespace live.server
{
    public static class Matchmaking
    {

        public static XNADDR CreateRandomXNADDR()
        {
            Random randomGenerator = new Random();
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina = (uint)randomGenerator.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.inaOnline = (uint)randomGenerator.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.abEnet = new byte[6];

            xnaddr.wPortOnline = (ushort)randomGenerator.Next(Int32.MinValue, Int32.MaxValue);
            randomGenerator.NextBytes(xnaddr.abEnet);

            SGADDR sgAddr = new SGADDR();

            sgAddr.inaSg = (uint)randomGenerator.Next(Int32.MinValue, Int32.MaxValue);
            sgAddr.dwSpiSg = (uint)randomGenerator.Next(Int32.MinValue, Int32.MaxValue);
            sgAddr.qwXboxId = 0;

            xnaddr.sgaddr = sgAddr;

            return xnaddr;
        }

        public static MatchSessionReply CreateSession(IClient client, XblUser user, uint publicSlots, uint privateSlots)
        {
            METHOD.ENTER();
            MatchSessionMsg request = new MatchSessionMsg();
            MatchSessionReply response = new MatchSessionReply();

            string gamerTag = " ";

            if (null != user.Gamertag)
            {
                gamerTag = user.Gamertag;
            }


            // later on, these values will be parameterized

            request.qwSessionId = MatchDefs.XNET_XNKID_ONLINE_PEER | MatchDefs.XONLINE_NAT_OPEN << 4;

            request.dwTitleId = client.TitleId;

            // figure out which slot to give the host
//             if (publicSlots > 1)
//             {
//                 request.dwPublicOpen = publicSlots - 1;
//                 request.dwPublicFilled = 1;
//                 request.dwPrivateOpen = privateSlots;
//                 request.dwPrivateFilled = 0;
//             }
//             else
//             {
//                 request.dwPrivateOpen = privateSlots - 1;
//                 request.dwPrivateFilled = 1;
//                 request.dwPublicOpen = publicSlots;
//                 request.dwPublicFilled = 0;
//             }

            request.dwPrivateOpen = privateSlots;
            request.dwPrivateFilled = 0;
            request.dwPublicOpen = publicSlots;
            request.dwPublicFilled = 0;

            request.HostAddress = CreateRandomXNADDR();

            // Overwrite the random Puid with the machine Id
            request.HostAddress.sgaddr.qwXboxId = client.MachinePuid;

            // Do I need to parameterize Attributes?
            // Yes... but later. 
            uint dwCurAttribute = 0;
            request.rgAttributes = new MatchAttribute[5];

            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, 1);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_PUID, user.Puid);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute((MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME | MatchDefs.X_ATTRIBUTE_DATATYPE_STRING), gamerTag);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, 1);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, 0);
            //request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED, 1);

            uint dwTotalSize = request.GetBaseSize() + (4 * (uint)request.rgAttributes.Length);

            request.rgdwAttrOffsets = new uint[request.rgAttributes.Length];

            for (int iAttrib = 0; iAttrib < request.rgAttributes.Length; iAttrib++)
            {
                request.rgdwAttrOffsets[iAttrib] = dwTotalSize;
                dwTotalSize += request.rgAttributes[iAttrib].GetSize();
            }

            request.dwMessageLength = dwTotalSize;

            uint hr = client.SendRequest(user, XOService.Matchmaking, "/xmatch/xmatchhost2.ashx", "POST", null, request, response);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return response;

        }


        public static MatchSearchReply SearchSession(IClient client, XblUser user)
        {
            METHOD.ENTER();
            MatchSearchMsg request = new MatchSearchMsg();
            MatchSearchReply response = new MatchSearchReply();

            request.dwTitleId = client.TitleId;
            
            // Is the procedure index important?
            request.dwProcedureIndex = 0;
            request.wNumUsers = 1; // we'll add more users per client later
            request.wFlags = 0; // what search flags can we add?

            request.ClientAddress = CreateRandomXNADDR();

            uint dwCurAttribute = 0;
            request.rgParameters = new MatchAttribute[3];
            request.rgParameters[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, 1);
            request.rgParameters[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, 1);
            request.rgParameters[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, 0);

            // Set up the parameter offsets
            uint dwTotalSize = request.GetBaseSize() + (4 * (uint)request.rgParameters.Length);
            request.rgdwParamOffsets = new uint[request.rgParameters.Length];
            for (int iParam = 0; iParam < request.rgParameters.Length; iParam++)
            {
                request.rgdwParamOffsets[iParam] = dwTotalSize;
                dwTotalSize += request.rgParameters[iParam].GetSize();
            }

            //Initialize the required dwNumWeightedParameters, and add it to the message total.
            request.dwNumWeightedParameters = 0;
            dwTotalSize += 4;

            request.dwMessageLength = dwTotalSize;

            uint hr = client.SendRequest(user, XOService.Matchmaking, "/xmatch/xmatchclient2.ashx", "POST", null, request, response);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return response;
        }


        public static uint UpdateSession(
        IClient client,
        XblUser user,
        ulong qwSessionId,
        uint dwPublicOpen,
        uint dwPublicFilled)
        {
            METHOD.ENTER();
            MatchSessionMsg request = new MatchSessionMsg();
            MatchSessionReply response = new MatchSessionReply();

            // Build the request
            request.qwSessionId = qwSessionId;
            request.dwTitleId = client.TitleId;
            request.dwPublicOpen = dwPublicOpen;
            request.dwPublicFilled = dwPublicFilled;


            request.HostAddress = CreateRandomXNADDR();


            // Do I need to parameterize Attributes?
            // Yes... but later. 
            uint dwCurAttribute = 0;
            request.rgAttributes = new MatchAttribute[5];

            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, 1);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_PUID, user.Puid);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute((MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME | MatchDefs.X_ATTRIBUTE_DATATYPE_STRING), user.Gamertag);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, 1);
            request.rgAttributes[dwCurAttribute++] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, 0);

            uint dwTotalSize = request.GetBaseSize() + (4 * (uint)request.rgAttributes.Length);

            request.rgdwAttrOffsets = new uint[request.rgAttributes.Length];

            for (int iAttrib = 0; iAttrib < request.rgAttributes.Length; iAttrib++)
            {
                request.rgdwAttrOffsets[iAttrib] = dwTotalSize;
                dwTotalSize += request.rgAttributes[iAttrib].GetSize();
            }

            request.dwMessageLength = dwTotalSize;

            // Send the request
            uint hr = client.SendRequest(user, XOService.Matchmaking, "/xmatch/xmatchhost2.ashx", "POST", null, request, response);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return hr;
        }

        public static uint DeleteSession(
                IClient client,
                XblUser user,
                ulong qwSessionId)
        {
            METHOD.ENTER();
            MatchDeleteMsg request = new MatchDeleteMsg();

            // Build the request
            request.qwSessionId = qwSessionId;
            request.dwTitleId = client.TitleId;
            request.dwMessageLength = request.GetBaseSize();

            // Send the request
            uint hr = client.SendRequest(user, XOService.Matchmaking, "/xmatch/xmatchhostdelete2.ashx", "POST", null, request, null);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return hr;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Notification.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using HttpStatusCode = System.Net.HttpStatusCode;

using live.common;
using live.protocol;
using live.protocol.Presence;

namespace live.server
{
    public static class Notification
    {
        public static void WaitForBuddyStatusOK(IClient client, XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            PNState state = Presence.GetPresenceForRequest(client, user);
            PNState friendState = Presence.GetPresence(friend);
            state.WaitForBuddyStatusOK(friendState);
            METHOD.EXIT();
        }

        public static void WaitForBuddyStatusPending(IClient client, XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            PNState state = Presence.GetPresenceForRequest(client, user);
            PNState friendState = Presence.GetPresence(friend);
            state.WaitForBuddyStatusPending(friendState);
            METHOD.EXIT();
        }

        public static void WaitForBuddyStatusRequested(IClient client, XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            PNState state = Presence.GetPresenceForRequest(client, user);
            PNState friendState = Presence.GetPresence(friend);
            state.WaitForBuddyStatusRequested(friendState);
            METHOD.EXIT();
        }

        public static void WaitForPeerPresence(IClient client, XblUser user, XblUser[] peers)
        {
            METHOD.ENTER();
            PNState state = Presence.GetPresence(user);
            PNState[] peerStates = new PNState[peers.Length];
            for (int i = 0; i < peerStates.Length; i++)
            {
                peerStates[i] = Presence.GetPresence(peers[i]);
            }
   
            // Build conditions
            PNConditionalWaitState wait = new PNConditionalWaitState(240);
            foreach (PNState User in peerStates)
            {
                if (User.LoggedOn)
                {
                    // TODO: this needs to be updated to handle xbox 1 machines
                    // TODO: they wait on PEER_PRESENCE, not PRESENCE_2
                    wait.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_PRESENCE_2, User, state);
                }
            }

            // Wait for Presence2 items from all xenon peers
            wait.WaitOnConditions();
            state.ProcessQVals();

            METHOD.EXIT();


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Presence.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using HttpStatusCode = System.Net.HttpStatusCode;

using live.common;
using live.protocol;
using live.protocol.Presence;

namespace live.server
{
    public static class Presence
    {
        // Unique ascending message sequnece number
        public static uint PresSeqNum
        {
            get { return (uint)System.Threading.Interlocked.Increment(ref _SeqNum); }
        }
        private static int _SeqNum = 0;


        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, not expecting a reply.
        /// </summary>
        /// <param name="request">Request being sent</param>
        public static void TransactFD(PNState requestor, PNRequestMsg request)
        {
            PNMsg Reply;
            uint xDelay;
            TransactFD(requestor, request, out Reply, out xDelay);
            if (Reply.Hdr != null)
            {
                throw new Exception("Transact FD got reply contents when none was expected");
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, not expecting a reply.
        /// </summary>
        /// <param name="request">Request being sent</param>
        /// <param name="xDelay">XDelay in response Hdr</param>
        public static void TransactFD(PNState requestor, PNRequestMsg request, out uint xDelay)
        {
            PNMsg Reply;
            TransactFD(requestor, request, out Reply, out xDelay);
            if (Reply.Hdr != null)
            {
                throw new Exception("Transact FD got reply contents when none was expected");
            }
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="request">Request being sent</param>
        /// <param name="reply">Response contents as PNMsg</param>
        public static void TransactFD(PNState requestor, PNRequestMsg request, out PNMsg reply)
        {
            uint xDelay;
            TransactFD(requestor, request, out reply, out xDelay);
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="request">Request being sent</param>
        /// <param name="reply">Response contents as PNMsg</param>
        /// <param name="xDelay">XDelay in response Hdr</param>
        public static void TransactFD(PNState requestor, PNRequestMsg request, out PNMsg reply, out uint xDelay)
        {
            // Setup SG Auth if needed
            CSGInfo slot = new CSGInfo();

            // If we have some mappable SGAUTH and we are requesting a valid auth
            // method load the slot from the FakeSG
            if (request.AuthMethod != PNRequestMsg.FDAuth.None
                    && 0 != request.Msg.Hdr.Sgaddr.qwXboxId)
            {
                if (requestor.Xbox != null)
                {
                    slot = requestor.Xbox.SecurityInfo;
                }
            }

            TransactFD(requestor, request, ref slot, out reply, out xDelay);
        }

        //////////////////////////////////////
        /// <summary>
        /// Send request to PN front door, with a reply expected.
        /// </summary>
        /// <param name="request">Request being sent</param>
        /// <param name="slot">Customized SGInfo</param>
        /// <param name="reply">Response contents as PNMsg</param>
        /// <param name="xDelay">XDelay in response Hdr</param>
        public static void TransactFD(PNState requestor, PNRequestMsg request, ref CSGInfo slot, out PNMsg reply, out uint xDelay)
        {
            xDelay = 0;
            reply = null;

            // Web messages should have sgignore set on the message so they 
            // don't fail the CheckSgAddr() on INH
            if (PNRequestMsg.FDAuth.HttpHdr == request.AuthMethod)
            {
                request.Msg.Hdr.Sgaddr.inaSg = 0;
                request.Msg.Hdr.Sgaddr.dwSpiSg = 0;
                request.Msg.Hdr.Sgaddr.qwXboxId = 0;
                request.Msg.Hdr.Sgaddr.abReserved = 0;
            }

            // Write request message to memory stream
            MemoryStream stream = new MemoryStream();
            request.Msg.WriteStream(stream);

            // Build Http Header
            WebHeaderCollection httpHdr = request.GetFDHttpHdr(ref slot, stream.Length);
            byte[] responseData;
            uint xErr = requestor.Client.SendRequest(requestor.User, request.ServiceId,  request.ServiceUrl, "POST", httpHdr, stream.ToArray(), out responseData);

            if(xErr != 0)
            {
                throw new XErrFailedException(xErr);
            }

            // Check results and reply
            reply = new PNMsg();
            if (responseData != null)
            {
                MemoryStream inStream = new MemoryStream(responseData);
                reply.ReadStream(inStream);
            }
        }

        public static uint SendRequest(
            IClient client,
            XblUser user,
            XOService service,
            string url,
            XRLObject2 reqOb,
            XRLObject2 respOb)
        {
            METHOD.ENTER();
            uint hr = client.SendRequest(user, XOService.PresNotification,
                url, "POST", null, reqOb, respOb);
            Logging.WriteHResult(hr);
            METHOD.EXIT();
            return hr;
        }

        public static PNState GetPresence(XblUser user)
        {
            PNState state = PNState.FindOrCreate(null, user, null);
            return state;
        }

        public static PNState GetPresenceForRequest(IClient client, XblUser user)
        {
            PNState state = PNState.Find(user.Puid);

            if (state != null && state.Connected)
            {
                if (state.Client == client)
                {
                    state.ProcessQVals();
                    return state;
                }
                else
                {
                    state.Disconnect();
                }
            }

            ITransaction transObj = client.GetTransactionObject(XOService.PresNotification);

            if (state == null)
            {
                state = PNState.FindOrCreate(client, user, transObj.SecurityProvider);
            }
            else
            {
                state.Client = client;
                state.Connect(transObj.SecurityProvider);
            }

            return state;
        }

        public static XblUser FindUser(IClient client, XblUser user, string targetName)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);

            PMsgFindUser req = new PMsgFindUser(state, 0, targetName);
            PNMsg rep = null;
            TransactFD(state, req, out rep);
            PFindUserReplyMsgData data = (PFindUserReplyMsgData)rep.Data;

            XblUser found = new XblUser(data.FoundID, data.GamerTag);
            METHOD.EXIT();
            return found;
        }

        public static void LogOut(IClient client, XblUser user)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.Disconnect();
            METHOD.EXIT();
        }

        public static void Alive2(IClient client, XblUser user)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.Alive2();
            METHOD.EXIT();
        }

        public static void AddFriend(IClient client, XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState buddyState = GetPresence(friend);
            state.AddBuddy(buddyState);
            METHOD.EXIT();
        }

        public static void AcceptFriend(IClient client, XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState buddyState = GetPresence(friend);
            state.AcceptBuddy(buddyState);
            METHOD.EXIT();
        }

        public static void ChangeTitle(IClient client, XblUser user)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.SetTitleData();
            METHOD.EXIT();
        }

        public static uint GetState(IClient client, XblUser user)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            METHOD.EXIT();
            return state.State;
        }

        public static void SetState(IClient client, XblUser user, uint State)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.State = State;
            state.SetTitleData();
            METHOD.EXIT();
        }

        public static void SetTitleData(IClient client, XblUser user, byte[] titleData)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.SetTitleData(titleData);
            METHOD.EXIT();
        }

        public static AffiliateState QueryAffiliates(IClient client, XblUser user)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            state.LoadAffiliates();
            AffiliateState affiliates = state.LoadedAffiliates;
            METHOD.EXIT();
            return affiliates;
        }

        public static void AddAffiliate(IClient client, XblUser user, XblUser recentPlayer, AffiliateFlags flags)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState affiliateState = GetPresence(recentPlayer);
            AffiliateState affiliates = new AffiliateState(state);
            state.AddAffiliate(affiliateState, (uint)flags);
            METHOD.EXIT();
        }

        private static PresenceInfo GetPresenceInfo(IClient client, XblUser user, XblUser target)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState targetState = GetPresence(target);
            PresenceInfo info = state.GetPresenceInfo(targetState);
            METHOD.EXIT();
            return info;
        }

        public static void PeerSubscribeEx(IClient client, XblUser user, XblUser[] target)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState[] targetStates = new PNState[target.Length];
            for (int i = 0; i < targetStates.Length; i++)
            {
                targetStates[i] = GetPresence(target[i]);
            }
            state.PeerSubscribeEx(targetStates);
            METHOD.EXIT();
        }

        public static live.protocol.Presence.GetFriendsListData[] GetFriendsList(IClient client, XblUser user, XblUser target)
        {
            METHOD.ENTER();
            PNState state = GetPresenceForRequest(client, user);
            PNState targetState = GetPresence(target);
            PGetFriendsListReplyMsgData friendsData = state.GetFriendsList(targetState);
            live.protocol.Presence.GetFriendsListData[] friends = new live.protocol.Presence.GetFriendsListData[0]; 
            if(friendsData != null)
            {
                friends = friendsData.rgFriends;
            }
            METHOD.EXIT();
            return friends;
        }

        //public static void (IClient client, XblUser user)
        //{
        //    METHOD.ENTER();
        //    PNState state = GetPresenceForRequest(client, user);
        //    state.
        //    METHOD.EXIT();
        //}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Stats.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

using live.common;
using live.protocol;

namespace live.server
{
    public static class Stats
    {
        private const int PAGE_SIZE = 100;

        public static void PostStatsBundle(IClient client, XblUser user, live.common.StatsBundle bundle)
        {
            METHOD.ENTER();
            ReqStatPost postRequest = new ReqStatPost();

            MemoryStream ms = new MemoryStream();

            // Let the protocol's version of the bundle rebuild the bundle data.
            postRequest.ReadFrom(bundle.GenerateReader());

            postRequest.WriteTo(new BinaryWriter(ms));

            byte [] binRequest = ms.ToArray();
            byte[] binReply = null;

            uint hr = client.SendRequest(user, XOService.Stats, postRequest.GetXRL(), "POST", null, binRequest, out binReply);
            
            // For now, we will discard the binary response (I don't think we use it on the 360).

            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
        }

        public static StatsReadResponse ReadStats(IClient client, XblUser readerUser, uint titleId, ulong[] targetUsers, StatsSpec[] messages)
        {
            METHOD.ENTER();
            StatsReadRequest readRequest = new StatsReadRequest();
            StatsReadResponse readResponse = new StatsReadResponse();

            readRequest.Specs = messages;
            readRequest.SpecCount = (uint) messages.Length;
            readRequest.TitleId = titleId;
            readRequest.Users = targetUsers;
            readRequest.UserCount = (uint) targetUsers.Length;
           
            uint hr = client.SendRequest(readerUser, XOService.Stats, readRequest.GetXRL(), "POST", null, readRequest, readResponse);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return readResponse;

        }


        public static StatsEnumResponse StatsEnumByUser(IClient client, XblUser readerUser, ulong userId, StatsSpec[] messages)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = new StatsEnumResponse();
            StatsEnumByUserRequest req = new StatsEnumByUserRequest();

            req.UserId = userId;
            req.TitleId = client.TitleId;
            req.Specs = messages;
            req.SpecsLen = (uint)messages.Length;
            req.PageSize = PAGE_SIZE;

            uint hr = client.SendRequest(readerUser, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public static StatsEnumResponse StatsEnumByRank(IClient client, XblUser readerUser, ulong rank, StatsSpec[] messages)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = new StatsEnumResponse();
            StatsEnumByRankRequest req = new StatsEnumByRankRequest();

            req.Rank = rank;
            req.TitleId = client.TitleId;
            req.Specs = messages;
            req.SpecsLen = (uint)messages.Length;
            req.PageSize = PAGE_SIZE;
            
            uint hr = client.SendRequest(readerUser, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public static StatsEnumResponse StatsEnumByRating(IClient client, XblUser readerUser, ulong rating, StatsSpec[] messages)
        {
            METHOD.ENTER();
            StatsEnumResponse resp = new StatsEnumResponse();
            StatsEnumByRatingRequest req = new StatsEnumByRatingRequest();

            req.Rating = rating;
            req.Specs = messages;
            req.SpecsLen = (uint)messages.Length;
            req.TitleId = client.TitleId;
            req.PageSize = PAGE_SIZE;

            uint hr = client.SendRequest(readerUser, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Storage.cs ===
﻿using System;
using System.Net;
using System.IO;

using live.client;
using live.common;
using live.protocol;

namespace live.server
{
    public static class Storage
    {
        public static uint SendRequest(IClient client, 
                                        XblUser user, 
                                        XRLRequestObject2 reqOb, 
                                        XRLObject2 respOb)
        {
            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, XOService.Storage,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), null, reqOb, respOb);
            return hr;
        }

        public static EnumFilesResponse EnumFile(IClient client, XblUser user, EnumFileRequest enumFileRequest)
        {
            METHOD.ENTER();
            ReqEnumerateFiles req = enumFileRequest.ToXrl();
            RepEnumerateFilesResponse resp = new RepEnumerateFilesResponse();
            uint hr = SendRequest(client, user, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new EnumFilesResponse(resp);
        }

        public static ReadFileResponse ReadFile(IClient client, XblUser user, ReadFileRequest readFileReq)
        {
            METHOD.ENTER();
            ReqReadFile req = readFileReq.ToXrl();
            RepHdrReadFile resp = new RepHdrReadFile();
            uint hr = SendRequest(client, user, req, resp);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
            return new ReadFileResponse(resp);
        }

        public static void WriteFile(IClient client, XblUser user, WriteFileRequest writeFileReq)
        {
            METHOD.ENTER();
            ReqHdrWriteFile req = writeFileReq.ToXrl();
            uint hr = SendRequest(client, user, req, null);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
        }

        public static void RemoveFile(IClient client, XblUser user, RemoveFileRequest removeFileReq)
        {
            METHOD.ENTER();
            ReqRemoveFile req = removeFileReq.ToXrl();
            uint hr = SendRequest(client, user, req, null);
            Throw.IfHRFailed(hr);

            METHOD.EXIT();
        }

        //EnumeratedReadFile
        //readfilehash
        //getquota
        //resolvename
        //reportbrokenlink
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\UserSettings.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.protocol;


namespace live.server
{
    public static class UserSettings
    {
        public enum SettingSource
        {
            XSOURCE_NO_VALUE = 0,
            XSOURCE_DEFAULT = 1,
            XSOURCE_TITLE = 2,
            XSOURCE_PERMISSION_DENIED = 3
        }

        public static SyncTitlesResponse SyncTitles(IClient client, XblUser user, DateTime version, UserTitle[] titles)
        {
            METHOD.ENTER();
            SyncTitlesRequest req = new SyncTitlesRequest();
            req.UserId = user.Puid; 
            req.Version = version;
            req.Titles = titles;

            SyncTitlesResponse resp = new SyncTitlesResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static EnumTitlesResponse EnumTitles(IClient client, XblUser user, ulong forUserId, ushort startingIndex, ushort maxTitles)
        {
            METHOD.ENTER();
            EnumTitlesRequest req = new EnumTitlesRequest(user.Puid, forUserId, startingIndex, maxTitles);
            EnumTitlesResponse resp = new EnumTitlesResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static ReadSettingsResponse ReadSettings(IClient client, XblUser user, uint titleId, ulong[] friends, uint[] settingIds)
        {
            METHOD.ENTER();
            ReadSettingsRequest req = new ReadSettingsRequest();
            req.TitleId = titleId;
            req.UserId = user.Puid;
            req.ForUserIds = friends;
            req.SettingIds = settingIds;
            
            ReadSettingsResponse resp = new ReadSettingsResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }

        public static SyncSettingsResponse SyncSettings(IClient client, XblUser user, uint titleId, UserSetting[] userSettings, DateTime version)
        {
            METHOD.ENTER();
            SyncSettingsRequest req = new SyncSettingsRequest();
            req.TitleId = titleId;
            req.UserId = user.Puid;
            req.Settings = userSettings;
            req.Version = version;

            SyncSettingsResponse resp = new SyncSettingsResponse();
            uint hr = client.SendRequest(user, XOService.Stats, req.GetXRL(), "POST", null, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();
            return resp;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\util\BillingUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.server;

namespace live.common
{
    public static partial class Util
    {
        public static class Billing
        {
            public static void PurchaseOffer(XblUser user, uint titleId, ulong offerId,
                PaymentTypeEnum paymentType, string paymentIdOrToken)
            {
                Xbox360Client client = new Xbox360Client(user.Settings.CreatedOn);
                client.TitleId = titleId;
                client.UserLoggingOn(user);

                live.server.Billing.XeOfferPurchase(client, user, offerId,
                    paymentType, paymentIdOrToken);

                client.Shutdown();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\Signature.cs ===
using System;
using System.Net;
using System.IO;

using live.common;
using live.protocol;
 
namespace live.server
{
    public static class Signature
    {
        public static string clientInfoZune = "";
        public static XeGenericBlock[] clientBlocks = null;

        public static uint SendRequest (
                   IClient client,
                   XblUser user,
                   XRLRequestObject2 reqOb,
                   XRLObject2 respOb )
        {

            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, XOService.Signature_Server,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            return hr;
        }

        public static uint SendRequestInternal(
                   IClient client,
                   XblUser user,
                   XRLRequestObject2 reqOb,
                   XRLObject2 respOb)
        {
            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, XOService.Signature_Internal,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            return hr;
        }

        //
        // CheckLicensesAvailability
        //
        public static CheckLicensesAvailabilityResponse CheckLicenseAvailability(IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid)
        {
            return CheckLicenseAvailability(_client, _user, _miid, _user.Puid);
        }

        public static CheckLicensesAvailabilityResponse CheckLicenseAvailability(IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid, ulong _puid)
        {
            CheckLicensesAvailabilityRequest request = new CheckLicensesAvailabilityRequest();
            CheckLicensesAvailabilityResponse response = new CheckLicensesAvailabilityResponse();

            // Build the web request
            request.miids = new String[_miid.Length];
            request.oids = new String[_miid.Length];
            for (int i = 0; i < _miid.Length; i++)
            {
                request.miids[i] = _miid[i].miid.ToString();
                request.oids[i] = _miid[i].oid.ToString();
            }
            request.userPuid = _puid;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }
        //
        //  END CheckLicensesAvailability
        //

        //
        // AcquireMediaLicenses
        //
        public static AcquireMediaLicensesResponse AcquireMediaLicenses(IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid)
        {
            return AcquireMediaLicenses(_client, _user, _miid, _user.Puid);
        }

        public static AcquireMediaLicensesResponse AcquireMediaLicenses ( IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid, ulong _puid )
        {
            AcquireMediaLicensesRequest request = new AcquireMediaLicensesRequest();
            AcquireMediaLicensesResponse response = new AcquireMediaLicensesResponse();

            XeGenericBlock[] clientBlocks = GetClientBlocks();
            string clientInfo = GetClientInfo();

            if (clientBlocks == null)
            {
                throw new Exception("ClientBlocks was null. Verify that the clientinfo.bin file is correct.");
            }

            // Build the xrl request
            request.userPuid = _puid;
            request.idPairs = _miid;
            request.idPairsLength = (ushort)_miid.Length;
            request.clientInfoBlocks = clientBlocks;
            request.clientInfoBlockCount = (ushort)clientBlocks.Length;

            // Build the web request
            request.miids = new String[_miid.Length];
            request.oids = new String[_miid.Length];
            for (int i = 0; i < _miid.Length; i++)
            {
                request.miids[i] = _miid[i].miid.ToString();
                request.oids[i] = _miid[i].oid.ToString();
            }
            request.userPuid = _puid;

            request.clientInfo = clientInfoZune;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }

        public static AcquireMediaLicensesResponse AcquireMediaLicensesStress(IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid, ulong _puid, XeGenericBlock[] clientBlocks)
        {
            AcquireMediaLicensesRequest request = new AcquireMediaLicensesRequest();
            AcquireMediaLicensesResponse response = new AcquireMediaLicensesResponse();

            if (clientBlocks == null)
            {
                throw new Exception("ClientBlocks was null. Verify that the clientinfo.bin file is correct.");
            }

            // Build the request
            request.userPuid = _puid;
            request.idPairs = _miid;
            request.idPairsLength = (ushort)_miid.Length;
            request.clientInfoBlocks = clientBlocks;
            request.clientInfoBlockCount = (ushort)clientBlocks.Length;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }
        //
        // END AcquireMediaLicenses
        //

        //
        // AcknowledgeLicensesDelivery
        //
        public static AcknowledgeLicensesDeliveryResponse AcknowledgeLicensesDelivery(IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid)
        {
            return AcknowledgeLicensesDelivery(_client, _user, _miid, _user.Puid);
        }

        public static AcknowledgeLicensesDeliveryResponse AcknowledgeLicensesDelivery ( IClient _client, XblUser _user, MediaInstanceIdOfferIdPair[] _miid, ulong _puid)
        {
            AcknowledgeLicensesDeliveryRequest request = new AcknowledgeLicensesDeliveryRequest();
            AcknowledgeLicensesDeliveryResponse response = new AcknowledgeLicensesDeliveryResponse();

            // Build the request
            request.userPuid = _puid;
            request.idPairs = _miid;
            request.idPairsLength = (ushort)_miid.Length;

            //required for POST requests (Zune)
            request.miids = new String[_miid.Length];
            request.oids = new String[_miid.Length];
            for (int i = 0; i < _miid.Length; i++)
            {
                request.miids[i] = _miid[i].miid.ToString();
                request.oids[i] = _miid[i].oid.ToString();
            }
            
            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }
        //
        // END AcknowledgeLicensesDelivery
        //

        //
        // RefreshGameLicense
        //
        public static RefreshGameLicenseResponse RefreshGameLicense(IClient _client, XblUser _user, byte[] _license)
        {
            return RefreshGameLicense(_client, _user, _license, (UInt16)_license.Length, _user.Puid, _client.MachinePuid);
        }
        public static RefreshGameLicenseResponse RefreshGameLicenseUser(IClient _client, XblUser _user, byte[] _license, UInt64 _userPuid)
        {
            return RefreshGameLicense(_client, _user, _license, (UInt16)_license.Length, _userPuid, _client.MachinePuid);
        }
        public static RefreshGameLicenseResponse RefreshGameLicenseMachine(IClient _client, XblUser _user, byte[] _license, UInt64 _machinePuid)
        {
            return RefreshGameLicense(_client, _user, _license, (UInt16)_license.Length, _user.Puid, _machinePuid);
        }
        public static RefreshGameLicenseResponse RefreshGameLicenseLicenseLength(IClient _client, XblUser _user, byte[] _license, UInt16 _licenseLength)
        {
            return RefreshGameLicense(_client, _user, _license, _licenseLength, _user.Puid, _client.MachinePuid);
        }
        public static RefreshGameLicenseResponse RefreshGameLicense(IClient _client, XblUser _user, byte[] _license, UInt16 _licenseLength, UInt64 _userPuid, UInt64 _machinePuid)
        {
            RefreshGameLicenseRequest request = new RefreshGameLicenseRequest();
            RefreshGameLicenseResponse response = new RefreshGameLicenseResponse();

            // Build the request
            request.userId = _userPuid;
            request.machineId = _machinePuid;
            request.licenseLength = _licenseLength;
            request.license = _license;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }
        //
        // END RefreshGameLicense
        //

        //
        // START XSigner
        //
        public static GetSignedHeaderResponse GetSignedHeader(IClient _client, XblUser _user, UInt32 _fileSize, UInt32 _fileType, byte[] _fileHash)
        {
            GetSignedHeaderRequest request = new GetSignedHeaderRequest();
            GetSignedHeaderResponse response = new GetSignedHeaderResponse();

            // Build the request
            request.fileSize = _fileSize;
            request.fileType = _fileType;
            request.fileHash = _fileHash;

            // XSigner is an internal only API so it sends the request internally
            uint hr = SendRequestInternal(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return response;
        }
        //
        // END XSigner
        //

        //
        // START License Migration
        //
        //Execute xrl start migration api
         public static GetLicenseTransferStateResponse LicenseMigrationStart(IClient _client, XblUser _user)
        {
            UpdateLicenseTransferStateRequest request = new UpdateLicenseTransferStateRequest();
            GetLicenseTransferStateResponse response = new GetLicenseTransferStateResponse();

            request.command = UpdateTransferStateEnum.Start;
            request.userPuid = _user.Puid;

            Signature.SendRequest(_client, _user, request, response);

            if (response.currentStatus != LicenseTransferStatusEnum.PendingConsoleSignIn)
            {
                throw new Exception("State was not correctly set.");
            }
            return response;
        }

         public static GetLicenseTransferStateResponse LicenseMigrationComplete(IClient _client, XblUser _user)
        {
            UpdateLicenseTransferStateRequest request = new UpdateLicenseTransferStateRequest();
            GetLicenseTransferStateResponse response = new GetLicenseTransferStateResponse();

            request.command = UpdateTransferStateEnum.Complete;
            request.userPuid = _user.Puid;
            
            if (response.currentStatus != LicenseTransferStatusEnum.Completed)
            {
                throw new Exception("State was not correctly set.");
            }

            return response;
        }
        //
        // END License Migration
        //

        //
        // Utility functions
        //
        public static String GetClientInfo()
        {
            if (clientInfoZune == "")
            {
                clientInfoZune = System.Web.HttpUtility.UrlEncode("<CLIENTINFO><CLIENTID>AgAAAIcU7SQ1dNzrRF9TC6TJ1Gu!TTckCs2c33A0ChkLQBNGQD9O3R!yQBPkBMvmGA56AJNOFNDx0cHLcLFlWEFprZDaAaE7nIzZLuJBzPofxDcLekEbQZ7eWzU5ALozHAi1I76vXgL!M09dAYOsC!OKp6xZ7aVEfqlihiV!T7783MQuPLGGENP33grnzfLKvrSB3LIWETRSfrDWxlZKEcq0FzjeFS3X</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My4wLjAuMDwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!NmNkdjVSMXExT0lpWS9MRE5nMmh1ZlZ2WXB0RzhvMXVEcitJajhSdm1zZlhsKzlTQ2JoN25wU1RtYWpRR3hUQ3FPUjByRklKT05kSlVWU0hneEFXUFgzcG1BdmZIYWV3NG5DUnBvS01Va1R5RHhZUkhuanlBQkJEazVvZmJCZ1JPckRWdFo4RzV1Mi9YdkJaZTg3OEtkSllxMlVETlNQd3M4YWlrNGhVeVJFPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PjFITzBQdmVLbXpYckdIM1hET0VLUDlVaTlrNU5iWTJSMUFJcTVJUEFxekxlQkFPOXJHVjJOd0lGQUFBYzVuWXhHT0lkaENXb0JueWRvZzNCckRhSVJMR1l6K0dPWVM0d0lUMHRYSHVkZjNFaEVqUXA8L2M6UEtDZXJ0PjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOkhhcmR3YXJlSUQ!ckF6aFExK2s3S3FiKy9ZMWVKUklBWGNleWtJPTwvYzpIYXJkd2FyZUlEPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPk4ycnh4djA1a2xJak9keTgyc3FQVVdNejJvcz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!UnptOVM3QUwwV0oyL2N0WWo3MzhnbkhWME84V2lQTDU1MWpmVjhwV1ZEMkRBc0RQbmtaa1VXQW9rMGtKUEhiVXpVb2lWaWYyWmJ0MDBSVlVPSFU0VEJBK3hITGprb1huNVQvR0ZHOCt5SEtaTmZaLzBxNkVuS2JYbytIZ0pBWEdPNEE5a0g2Z0FuekkrVlNmbE5vV3A5YmpUK1ozMktENFc0Y3JzemN2ckJrPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wME9WaVdYbDl4a1pJR2VPeTdNdnAzOGJIK3RkZDlhOVNpb0xGVG12aytCSWRhUkp2c3l4bVZQK210WXRCVWJjN2ptUWdNczFQS3d3UzJkKzZGejE4OGEra3p6ODZReXM3bUxvQ2IvL3FpVTgxaFUyR1owTkxoK1cwZ253R1UzZk1YbnBvUFRHUlNrMGVWVkpDeVRSM0FMMUFkT2d0ditoR1JoT2dUZjdtUHM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My4wLjAuMDwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!cDBPVmlXWGw5eGtaSUdlT3k3TXZwMzhiSCt0ZGQ5YTlTaW9MRlRtdmsrQklkYVJKdnN5eG1WUCttdFl0QlViYzdqbVFnTXMxUEt3d1MyZCs2RnoxODhhK2t6ejg2UXlzN21Mb0NiLy9xaVU4MWhVMkdaME5MaCtXMGdud0dVM2ZNWG5wb1BUR1JTazBlVlZKQ3lUUjNBTDFBZE9ndHYraEdSaE9nVGY3bVBzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6U2VjdXJpdHlMZXZlbD4yMDAwPC9jOlNlY3VyaXR5TGV2ZWw!PGM6S2V5VXNhZ2U!PGM6U2lnbkNlcnRpZmljYXRlPjE8L2M6U2lnbkNlcnRpZmljYXRlPjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48bTpXTURSTVRyYW5zbWl0dGVyPjE8L206V01EUk1UcmFuc21pdHRlcj48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPk1pY3Jvc29mdDwvYzpNYW51ZmFjdHVyZXJOYW1lPjwvYzpNYW51ZmFjdHVyZXJEYXRhPjwvYzpEYXRhPjxTaWduYXR1cmUgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyMiPjxTaWduZWRJbmZvPjxDYW5vbmljYWxpemF0aW9uTWV0aG9kIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMS9SRUMteG1sLWMxNG4tMjAwMTAzMTUiPjwvQ2Fub25pY2FsaXphdGlvbk1ldGhvZD48U2lnbmF0dXJlTWV0aG9kIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL1JzYS1zaGExIj48L1NpZ25hdHVyZU1ldGhvZD48UmVmZXJlbmNlPjxUcmFuc2Zvcm1zPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL0NFUlQvRGF0YSI!PC9UcmFuc2Zvcm0!PFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L1RyYW5zZm9ybT48L1RyYW5zZm9ybXM!PERpZ2VzdE1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyNzaGExIj48L0RpZ2VzdE1ldGhvZD48RGlnZXN0VmFsdWU!cHR3S1F3Q3VLY2JzZU1ZSUFDeCswVkljNDdFPTwvRGlnZXN0VmFsdWU!PC9SZWZlcmVuY2U!PC9TaWduZWRJbmZvPjxTaWduYXR1cmVWYWx1ZT5qKzVmT3A5U0o1dFh5dW1jSVdIU0wySnQwdEdZaUtQbGJLdGZZY3ptT3J4TGp3aS9iQ21PRW5lQ1JmRkxydnVBTUsxQ3pWcHh5MGd3MzZTZ3NRYmliam94TEFIOTd4b2Z5TzAwVXVNQ29GRjB5NlZNN3BMY1RzaDNESkV2a3ZDTWRnMlUrbXQ0N1FCaHM3aWZoc0k0a2xjbStCOTVUci95WXBhdXNMcGRuakk9PC9TaWduYXR1cmVWYWx1ZT48S2V5SW5mbz48S2V5VmFsdWU!PFJTQUtleVZhbHVlPjxNb2R1bHVzPnM2bGZIM3paK205bzducFNWanFWSVZ5N2l1YVhjNWtLbncwL2xZSFZ1bHpBaTZTeDRYZkFUQm1tSGFjUzdCT004dDNRTFBvWFAyVUV1VS85QzB1b3BaajdPajQ0clZFWlFmbHMxTk9IQ0FuT3B1cHFXOVBYU2VRc1VUTnpoRy9BRVJ3Q1dQYTJxYjVORGl0UTlIckR4L2k3UitFUEMrcDlxa09md3B3RGdkRT08L01vZHVsdXM!PEV4cG9uZW50PkFRQUI8L0V4cG9uZW50PjwvUlNBS2V5VmFsdWU!PC9LZXlWYWx1ZT48L0tleUluZm8!PC9TaWduYXR1cmU!PC9jOkNlcnRpZmljYXRlPjxjOkNlcnRpZmljYXRlIGM6VmVyc2lvbj0iMi4wIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiPjxjOkRhdGEgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvY2VydCIgeG1sbnM6bT0iaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzExL21zbHAiPjxjOlB1YmxpY0tleT48S2V5VmFsdWU!PFJTQUtleVZhbHVlPjxNb2R1bHVzPnM2bGZIM3paK205bzducFNWanFWSVZ5N2l1YVhjNWtLbncwL2xZSFZ1bHpBaTZTeDRYZkFUQm1tSGFjUzdCT004dDNRTFBvWFAyVUV1VS85QzB1b3BaajdPajQ0clZFWlFmbHMxTk9IQ0FuT3B1cHFXOVBYU2VRc1VUTnpoRy9BRVJ3Q1dQYTJxYjVORGl0UTlIckR4L2k3UitFUEMrcDlxa09md3B3RGdkRT08L01vZHVsdXM!PEV4cG9uZW50PkFRQUI8L0V4cG9uZW50PjwvUlNBS2V5VmFsdWU!PC9LZXlWYWx1ZT48L2M6UHVibGljS2V5PjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjBaOGI5YWN5Mnh1VFoyUzc5OERkSE1CMDR3UT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!ZU5VOEpMNkxBNnBLcXIwM1VCOWxlNTJ2NHZNMVF1dnE4WS9KeTR6SURQQ3p4a3gzM3NFMUZ3N1d2MHltZ1M1UVZJaEd2dVJNQll4c00yanVKaldlSHErUGRaUVVoRi9TbVlUamlOZ1I4Q3plWTV1Mjk0Q1R5ZTBrZzBmdlRIM09WczFwNzl3WHQ3aURlKzh5RGxkRUN5RnJ6cHlvZTZlelQxUGh4Qzh6R0ZnPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.6000.6324</CLIENTVERSION><SECURITYVERSION>2.5.0.0</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>");
            }

            return clientInfoZune;
        }

        public static XeGenericBlock[] GetClientBlocks ()
        {
            if (clientBlocks == null)
            {
                FileStream fs = new FileStream("Suites\\clientinfo.bin", FileMode.Open);
                BinaryReader br = new BinaryReader(fs);

                Byte[] fileData = new Byte[fs.Length];
                if (br.Read(fileData, 0, (int)fs.Length) != (int)fs.Length)
                {
                    throw new Exception("Did not read correct number of bytes from clientinfo.bin");
                }

                // Use the block utils, to chop the client info blob into smaller bite size pieces.
                BlockSerializer bs = new BlockSerializer(fileData, 1, AcquireMediaLicensesRequest.CLIENT_INFO_BLOCK_MAX_COUNT);
                clientBlocks = bs.Serialize();

                fs.Close();
            }
            return clientBlocks;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\server\UACS.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;
using live.common;
using live.protocol;
using live.client;


namespace live.server
{
    [Flags]
    public enum PointsBalanceStatus
    {
        Active = 0x1,
        Disabled = 0x2,
        Closed = 0x4,
        AboveLowBalance = 0x10000,
        None = 0,
    }

    public static class UACS
    {
        public static uint SendRequest(
            IClient client,
            XblUser user,
            XOService service,
            HttpRequestObject2 reqOb,
            XRLObject2 respOb)
        {

            if (reqOb is PayloadRequest)
            {
                ((PayloadRequest)reqOb).SetPayloadTypeFor(client, respOb as PayloadResponse);
            }

            uint hr = client.SendRequest(user, service,
                reqOb.GetRelativeUrl(), reqOb.GetHttpMethod(), reqOb.BehaviorInjection.headers, reqOb, respOb);
            return hr;
        }

        public static uint SendRequest(
            IClient client,
            XblUser user,
            XRLRequestObject2 reqOb,
            XRLObject2 respOb)
        {
            return SendRequest(client, user, XOService.User_Account,
                               reqOb, respOb);                               
        }


        //
        //  ARGO
        //

        public static void ArgoAuthenticateAccount()
        { 
        }

        public static ArgoGetAccountStatusResponse ArgoGetAccountStatus(IClient client, XblUser user)
        {
            METHOD.ENTER();
            ArgoGetAccountStatusRequest req = new ArgoGetAccountStatusRequest();
            ArgoGetAccountStatusResponse resp = new ArgoGetAccountStatusResponse();

            req.userPuid = user.Puid;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp;
        }

        public static void ArgoTestCreateAccount()
        {
        }

        public static ArgoAccountInfo ArgoSignIn(Xbox360Client client, XblUser user)
        {
            return ArgoSignIn((IClient)client, user);
        }

        public static ArgoAccountInfo ArgoSignIn(ZuneClient client, XblUser user)
        {
            return ArgoSignIn((IClient)client, user);
        }

#if INTERNALTEST
        public
#endif
        static ArgoAccountInfo ArgoSignIn(IClient client, XblUser user)
        {
            METHOD.ENTER();
            ArgoSignInRequest req = new ArgoSignInRequest();
            ArgoSignInResponse resp = new ArgoSignInResponse();

            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);
            //Throw.IfXErrFailed(resp.hr);

            METHOD.EXIT();
            return new ArgoAccountInfo(resp);

        }


        public static SigninInfo GetUserAuthorization(IClient client, XblUser user, uint titleId, ServiceTypeEnum service)
        {
            METHOD.ENTER();
            GetUserAuthorizationRequest req = new GetUserAuthorizationRequest();
            GetUserAuthorizationResponse resp = new GetUserAuthorizationResponse();

            req.serviceType = service;
            req.titleId = titleId;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return new SigninInfo(resp);

        }



        //
        //  XBOX 360
        //

        public delegate void DelegateRequest(HttpRequestObject2 request);
        
        public static uint XeCreateLiveAccount(IClient client, XblUserSettings settings, out XblUser user)
        {
            return XeCreateLiveAccount(client, settings, out user, null);
        }

        public static uint XeCreateLiveAccount(IClient client, XblUserSettings settings, out XblUser user, DelegateRequest updateRequest)
        {
            METHOD.ENTER();
            int retryCount = 0;
            settings.CreatedOn.MachinePuid = client.MachinePuid;
            settings.CreatedOn.OfflineXuid = 0; //BUGBUG: client.OfflineXuid;
            settings.CreatedOn.TitleId = client.TitleId;
            settings.CreatedOn.Key = ArrayEx.DeepClone(client.Key);

            CreateLiveAccountRequest req = settings.ToCreateLiveAccountRequest(client);
            CreateLiveAccountResponse resp = new CreateLiveAccountResponse();

            // update the request by calling the delegate
            if (updateRequest != null)
            {
                updateRequest(req);
            }

            uint hr = HResult.S_OK;

            do
            {
                hr = SendRequest(client, null, req, resp);

                if (hr != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN)
                {
                    // Error is not NAME_TAKEN so we don't know what to do.
                    break;
                }
                else
                {
                    settings.PersonalInfo.Gamertag = new RandomEx().GenerateRandomName().TrimEnd(' ');
                    Logging.WriteLine("XblUser.XeCreateLiveAccount() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");

                    // Must create new user (and owner if this is a child account) passport because the 1st one will be linked to the failed gamertag
                    PassportInfo ppUserInfo = new PassportInfo();
                    PassportInfo ppOwnerInfo = new PassportInfo();
                    byte[] signedUserPuid;
                    byte[] signedOwnerPuid;
                    if (settings.UserPassportInfo.PassportType == PassportType.Fake) //If this is a fake passport, create a fake passport to replace it.
                    {
                        PassportUtils.CreateFakePassportAccount(client, ppUserInfo);
                    }
                    else
                    {
                        signedUserPuid = XePassportCreate(client, ppUserInfo);
                    }
                    
                    
                    if( settings.OwnerPassportInfo != settings.UserPassportInfo )
                    {
                        if (settings.OwnerPassportInfo.PassportType == PassportType.Fake)
                        {
                            PassportUtils.CreateFakePassportAccount(client, ppOwnerInfo);
                        }
                        else
                        {
                            signedOwnerPuid = XePassportCreate(client, ppOwnerInfo);
                        }

                        settings.UserPassportInfo = ppUserInfo;
                        settings.OwnerPassportInfo = ppOwnerInfo;
                    }
                    else
                        settings.OwnerPassportInfo = settings.UserPassportInfo = ppUserInfo; //If this is not a child account, set owner and user = new user passport                    
                    
                    req = settings.ToCreateLiveAccountRequest(client); // Fill in the request object with the new gamertag and passport info
                }

            } while (retryCount++ < 3); // Loop while NAME_TAKEN error is returned

            Throw.IfXErrFailed(hr);

            user = new XblUser(((CreateLiveAccountResponse)resp).userPuid,
                settings.PersonalInfo.Gamertag);
            user.Settings = settings;
            user.Settings.XenonKey = resp.xenonKey;
            Logging.WriteLine("user = " + user.ToString(), "SERVER");

            METHOD.EXIT();
            return hr;
        }

        public static void XeCreateWholesaleAccount(IClient client, XblUserSettings settings, out XblUser user) 
        {
            METHOD.ENTER();
            CreateWholesaleAccountRequest req = settings.ToCreateWholesaleAccountRequest(client);
            CreateWholesaleAccountResponse resp = new CreateWholesaleAccountResponse();

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            user = new XblUser(resp.userPuid,
                settings.PersonalInfo.Gamertag);
            user.Settings = settings;
            Logging.WriteLine("user = " + user.ToString(), "SERVER");

            METHOD.EXIT();
            
        }

        public static void XeCreateXboxComAccount()
        {
        }

        /// <summary>
        /// Adds a credit or debit card to an account.
        /// </summary>
        /// <param name="client">Client</param>
        /// <param name="user">User</param>
        /// <param name="payment">Payment: CreditCardInfo or DirectDebitInfo</param>
        /// <returns></returns>
        private static void XeAddPaymentInstrument(IClient client, XblUser user,
            PaymentInstrumentBase payment)
        {
            METHOD.ENTER();
            AddPaymentInstrumentRequest req = new AddPaymentInstrumentRequest();
            AddPaymentInstrumentResponse resp = new AddPaymentInstrumentResponse();

            req.addressInfo = payment.AddressInfo.ToAddressInfoData();

            if (payment is CreditCardInfo)
            {
                req.creditCardInfo = ((CreditCardInfo)payment).ToCreditCardInfoData();
                req.directDebitInfo = new DirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.CreditCard;
            }
            else if (payment is DirectDebitInfo)
            {
                req.creditCardInfo = new CreditCardInfoData();
                req.directDebitInfo = ((DirectDebitInfo)payment).ToDirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.DirectDebit;
            }
            else
            {
                req.creditCardInfo = new CreditCardInfoData();
                req.directDebitInfo = new DirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
            }
            req.machinePuid = client.MachinePuid;
            req.phoneInfo = payment.PhoneInfo.ToPhoneInfoData();
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            payment.PaymentInstrumentId = resp.paymentInstrumentId;
            METHOD.EXIT();
        }

        /// <summary>
        /// Adds a credit card to an account. Now support both XRL and web services
        /// </summary>
        /// <param name="client">Client</param>
        /// <param name="user">User</param>
        /// <param name="payment">Credit Card</param>
        /// <returns></returns>
#if INTERNALTEST
        public
#endif
        static void XeAddPaymentInstrument(IClient client, XblUser user, CreditCardInfo creditCard)
        {
            XeAddPaymentInstrument(client, user, (PaymentInstrumentBase)creditCard);
            user.Settings.BillingInfo.AddCreditCard(creditCard);
        }

        /// <summary>
        /// Adds a direct debit payment instrument to an account. Now support both XRL and web services
        /// </summary>
        /// <param name="client">Client</param>
        /// <param name="user">User</param>
        /// <param name="payment">Direct Debit</param>
        /// <returns></returns>
#if INTERNALTEST
        public
#endif
        static void XeAddPaymentInstrument(IClient client, XblUser user, DirectDebitInfo directDebit)
        {
            XeAddPaymentInstrument(client, user, (PaymentInstrumentBase)directDebit);
            user.Settings.BillingInfo.AddDirectDebit(directDebit);
        }

        // client specific method
        public static void XeAddPaymentInstrument(Xbox360Client client, XblUser user, CreditCardInfo creditCard)
        {
            XeAddPaymentInstrument((IClient)client, user, creditCard);
        }

        // client specific method
        public static void XeAddPaymentInstrument(ZuneClient client, XblUser user, CreditCardInfo creditCard)
        {
            XeAddPaymentInstrument((IClient)client, user, creditCard);
        }

        // client specific method
        public static void XeAddPaymentInstrument(Xbox360Client client, XblUser user, DirectDebitInfo directDebit)
        {
            XeAddPaymentInstrument((IClient)client, user, directDebit);
        }

        // client specific method
        public static void XeAddPaymentInstrument(ZuneClient client, XblUser user, DirectDebitInfo directDebit)
        {
            XeAddPaymentInstrument((IClient)client, user, directDebit);
        }

#if INTERNALTEST
        public
#endif
        static AddCreditCardRequest BuildAddCreditCardRequest(IClient client, XblUser user, CreditCardInfo creditCard)
        {
            AddCreditCardRequest req = new AddCreditCardRequest();
            req.userPuid = user.Puid;
            req.machinePuid = client.MachinePuid;

            req.addressStreet1 = creditCard.AddressInfo.Street1;
            req.addressStreet2 = creditCard.AddressInfo.Street2;
            req.addressCity = creditCard.AddressInfo.City;
            req.addressDistrict = creditCard.AddressInfo.District;
            req.addressState = creditCard.AddressInfo.State;
            req.addressPostalCode = creditCard.AddressInfo.PostalCode;

            req.phonePrefix = creditCard.PhoneInfo.PhonePrefix;
            req.phoneNumber = creditCard.PhoneInfo.PhoneNumber;
            req.phoneExtension = creditCard.PhoneInfo.PhoneExtension;

            req.cardType = (byte)creditCard.CardType;
            req.accountHolderName = creditCard.AccountHolderName;
            req.accountNumber = creditCard.AccountNumber;
            req.cardVerificationNumber = creditCard.CcvNumber;
            req.expirationDate = creditCard.ExpirationDate.Month.ToString("D2") + '/' + creditCard.ExpirationDate.Year.ToString();

            return req;
        }

#if INTERNALTEST
        public
#endif
        static string AddCreditCard(IClient client, XblUser user, CreditCardInfo creditCard)
        {
            METHOD.ENTER();
            AddCreditCardResponse resp = new AddCreditCardResponse();
            AddCreditCardRequest req = BuildAddCreditCardRequest(client, user, creditCard);
            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();

            return resp.PaymentInstrumentId;
        }

        // client specific method
        public static string AddCreditCard(ZuneClient client, XblUser user, CreditCardInfo creditCard)
        {
            return AddCreditCard((IClient)client, user, creditCard);
        }

        /// <summary>
        /// This returns the first "maxResults" pyament instruments of the user
        /// </summary>
        /// <param name="client">Client</param>
        /// <param name="user">User</param>
        /// <param name="maxResults">Maximum number of instruments returned</param>
        /// <returns>array of PaymentInstrumentInfoEx</returns>
        public static PaymentInstrumentInfoEx[] XeGetPaymentInstruments2(IClient client, XblUser user, ushort maxResults)
        {
            METHOD.ENTER();
            GetPaymentInstrumentsRequest req = new GetPaymentInstrumentsRequest();
            GetPaymentInstrumentsResponse response = new GetPaymentInstrumentsResponse();
            req.maxResults = maxResults;
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, response);
            Throw.IfXErrFailed(hr);
           
            METHOD.EXIT();
            return response.paymentInstrumentInfo;
        }

        /// <summary>
        /// This returns the first "maxResults" pyament instruments of the user. The user's billinginfo will be updated with the paymentinstruments
        /// </summary>
        /// <param name="client">Client</param>
        /// <param name="user">User</param>
        /// <param name="maxResults">Maximum number of instruments returned</param>
        /// <returns>array of PaymentInstrumentId</returns>
        public static string[] XeGetPaymentInstruments(IClient client, XblUser user, ushort maxResults)
        {
            METHOD.ENTER();
            GetPaymentInstrumentsRequest req = new GetPaymentInstrumentsRequest();
            GetPaymentInstrumentsResponse response = new GetPaymentInstrumentsResponse();

            req.maxResults = maxResults;
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, response);
            Throw.IfXErrFailed(hr);

            List<string> billingIds = new List<string>(response.count);

            foreach (PaymentInstrumentInfoEx pi in response.paymentInstrumentInfo)
            {
                billingIds.Add(pi.paymentInstrumentId);
                switch ((PaymentInstrumentTypeEnum)pi.paymentInstrumentType)
                {
                    case PaymentInstrumentTypeEnum.None:
                        break;
                    case PaymentInstrumentTypeEnum.CreditCard:
                        user.Settings.BillingInfo.AddCreditCard(new CreditCardInfo(pi));
                        break;
                    case PaymentInstrumentTypeEnum.DirectDebit:
                        user.Settings.BillingInfo.AddDirectDebit(new DirectDebitInfo(pi));
                        break;
                    default:
                        break;
                }
            }

            METHOD.EXIT();
            return billingIds.ToArray();
        }

        public static void XeRemovePaymentInstrument(IClient client, XblUser user, string paymentInstrumentID)
        {
            METHOD.ENTER();
            RemovePaymentInstrumentRequest req = new RemovePaymentInstrumentRequest();

            req.machinePuid = client.MachinePuid;
            req.paymentInstrumentId = paymentInstrumentID;
            req.paymentInstrumentIdLength = (ushort)paymentInstrumentID.Length;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, null, req, null);
            Throw.IfXErrFailed(hr);

            user.Settings.BillingInfo.RemovePaymentInstrument(paymentInstrumentID);
            METHOD.EXIT();
        }

        public static void XeUpdatePaymentInstrument(IClient client, XblUser user, PaymentInstrumentBase payment)
        {
            METHOD.ENTER();

            UpdatePaymentInstrumentRequest req = new UpdatePaymentInstrumentRequest();

            req.addressInfo = payment.AddressInfo.ToAddressInfoData();
            if (payment is CreditCardInfo)
            {
                req.creditCardInfo = ((CreditCardInfo)payment).ToCreditCardInfoData();
                req.directDebitInfo = new DirectDebitInfoData();
            }
            else if (payment is DirectDebitInfo)
            {
                req.creditCardInfo = new CreditCardInfoData();
                req.directDebitInfo = ((DirectDebitInfo)payment).ToDirectDebitInfoData();
            }
            req.machinePuid = client.MachinePuid;
            req.paymentInstrumentId = payment.PaymentInstrumentId;
            req.paymentInstrumentIdLength = (ushort)payment.PaymentInstrumentId.Length;
            req.phoneInfo = payment.PhoneInfo.ToPhoneInfoData();
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, null, req, null);
            Throw.IfXErrFailed(hr);
            user.Settings.BillingInfo.UpdatePaymentInstrument((CreditCardInfo)payment);
            

            METHOD.EXIT();
        }

        public static void XeChangeSubscriptionPaymentInstrument()
        {
        }


        public static PersonalInfo XeGetUserInfo(IClient client, ulong userPuid, out int age)
        {
            METHOD.ENTER();
            GetUserInfoRequest req = new GetUserInfoRequest();
            GetUserInfoResponse resp = new GetUserInfoResponse();

            req.machinePuid = client.MachinePuid;
            req.userPuid = userPuid;
            req.titleId = client.TitleId;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            PersonalInfo pi = new PersonalInfo(resp);
            age = resp.age;

            METHOD.EXIT();
            return pi;
        }

        public static void XeLinkXbox1Account(IClient client, XblUser user)
        {
            METHOD.ENTER();

            PaymentInstrumentBase pib = user.Settings.BillingInfo.GetActivePaymentInstrument();

            LinkXbox1AccountRequest req = new LinkXbox1AccountRequest();
            req.cardHolder = pib.AccountHolderName;
            req.cardNumber = pib.AccountNumber;
            req.gamertag = user.Gamertag;
            req.phoneInfo = user.Settings.PersonalInfo.PhoneInfo.ToPhoneInfoData();
            req.postalCode = user.Settings.PersonalInfo.AddressInfo.PostalCode;
            req.machinePuid = client.MachinePuid;
            req.signedUserPassportPuid = PassportUtils.GenerateSignedPuid(user.Settings.UserPassportInfo.PassportPuid, client.Key);
            req.signedOwnerPassportPuid = PassportUtils.GenerateSignedPuid(user.Settings.OwnerPassportInfo.PassportPuid, client.Key);
            req.titleId = client.TitleId;

            uint hr = SendRequest(client, null, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }

        public static PassportPersonalInfo XePassportGetUserData(IClient client, byte[] sessionToken)
        {
            METHOD.ENTER();
            PassportGetUserDataRequest req = new PassportGetUserDataRequest();
            PassportGetUserDataResponse resp = new PassportGetUserDataResponse();

            req.sessionToken = sessionToken;


            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            PassportPersonalInfo pi = new PassportPersonalInfo(resp);
            METHOD.EXIT();
            return pi;

        }

        public static void XePassportGetEncryptedProxyParameters(IClient client,
            out uint publicKeyPublicExponent, out byte[] publicKeyModulus,
            out byte[] publicKeyDigest, out string loginTokenRequest)
        {
            METHOD.ENTER();
            XePassportGetEncryptedProxyParametersRequest req =
                new XePassportGetEncryptedProxyParametersRequest();
            XePassportGetEncryptedProxyParametersResponse resp =
                new XePassportGetEncryptedProxyParametersResponse();

            req.serviceId = 0;
            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            XePassportGetEncryptedProxyParametersResponse ppParams =
                (XePassportGetEncryptedProxyParametersResponse)resp;
            loginTokenRequest = ppParams.loginTokenRequest;
            publicKeyDigest = ppParams.publicKeyDigest;
            publicKeyModulus = ppParams.publicKeyModulus;
            publicKeyPublicExponent = ppParams.publicKeyPublicExponent;
            METHOD.EXIT();
        }

        public static byte[] XePassportCreate(IClient client, PassportInfo ppInfo)
        {
            METHOD.ENTER();
            XePassportCreateRequest req = ppInfo.ToXePassportCreateRequest(client);
            XePassportCreateResponse resp = new XePassportCreateResponse();

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            ppInfo.SessionToken = resp.sessionToken;
            ppInfo.PassportPuid = PassportUtils.GetPuidFromSessionToken(ppInfo.SessionToken);

            METHOD.EXIT();
            return resp.sessionToken;
        }

        public class LLPassportLoginResponse : XePassportLoginResponse
        {
            private int _serviceId = XOn.XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID;
            public int ServiceId
            {
                get
                {
                    return _serviceId;
                }
            }

            public LLPassportLoginResponse(int serviceId)
            {
                _serviceId = serviceId;
            }

            public override void ReadFromRequest(System.IO.BinaryReader reader, UTF8Encoding enc, long len, System.Collections.Specialized.NameValueCollection queryString)
            {
                // Special case for Spring07
                if (_serviceId == XOn.XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID &&
                    this.SchemaVersion > WireData.MakeSchemaVersion(2, 0))
                {
                    this.SchemaVersion = WireData.MakeSchemaVersion(2, 0);
                }
                base.ReadFromRequest(reader, enc, len, queryString);
            }
        }

        /// <summary>
        /// Passport login
        /// </summary>
        /// <returns>The passport session token for the logged in Passport user</returns>
        public static byte[] XePassportLogin(IClient client, PassportInfo ppInfo)
        {
            METHOD.ENTER();
            XePassportLoginRequest req = new XePassportLoginRequest();
            LLPassportLoginResponse resp = new LLPassportLoginResponse(req.serviceId);

            byte[] encSessionKey, encPassword, encLoginTokenRequest;
            PassportUtils.GenerateEncryptedLoginParts(client, ppInfo,
                out encSessionKey, out encPassword, out encLoginTokenRequest);

            req.encryptedPassword = encPassword;
            req.encryptedPasswordLength = (ushort)req.encryptedPassword.Length;
            req.encryptedSessionKey = encSessionKey;
            req.encryptedSessionKeyLength = (ushort)req.encryptedSessionKey.Length;
            req.encryptedTokenRequest = encLoginTokenRequest;
            req.encryptedTokenRequestLength = (ushort)req.encryptedTokenRequest.Length;
            req.passportMemberName = ppInfo.MemberName;
            req.passportMemberNameLength = (ushort)req.passportMemberName.Length;
            req.serviceId = 0;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp.sessionToken;
        }

        public static void XePassportChangePassword()
        {
        }

        public static void XePassportGetSecretQuestions()
        {
        }

        public static string XePassportGetMemberName(IClient client, ulong userPuid)
        {
            METHOD.ENTER();
            XePassportGetMemberNameRequest req = new XePassportGetMemberNameRequest();
            XePassportGetMemberNameResponse resp = new XePassportGetMemberNameResponse();

            req.userPuid = userPuid;
           

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp.userPmn;

        }


        public static void XePassportGetMemberName(IClient client, XblUser user, out string userPassportName, out string parentPassportName)
        {
            METHOD.ENTER();
            XePassportGetMemberNameRequest req = new XePassportGetMemberNameRequest();
            XePassportGetMemberNameResponse resp = new XePassportGetMemberNameResponse();
            
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            userPassportName = resp.userPmn;
            parentPassportName = resp.parentPmn;

            METHOD.EXIT();
        }


        public static void XePassportGetFriendMemberName()
        {
        }

        public static void XePassportGetBuddyGamertag()
        {
        }

        public static void XeABCHGetContactlistGamertags()
        {
        }

        public static void XeUpsGetProfile()
        {
        }

        public static void XeUpsUpdateProfile()
        {
        }

        public static uint XeGetPointsBalance(IClient client, XblUser user, out PointsBalanceStatus status)
        {
            METHOD.ENTER();
            XeGetPointsBalanceRequest req = new XeGetPointsBalanceRequest();
            XeGetPointsBalanceResponse resp = new XeGetPointsBalanceResponse();
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            status = PointsBalanceStatus.None;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            switch (resp.dmpAccountStatus)
            {
                case 0:
                    status |= PointsBalanceStatus.Active;
                    break;
                case 1:
                    status |= PointsBalanceStatus.Disabled;
                    break;
                case 2:
                    status |= PointsBalanceStatus.Closed;
                    break;
                default:
                    break;
            }

            if (resp.aboveLowBalance)
            {
                status |= PointsBalanceStatus.AboveLowBalance;
            }


            METHOD.EXIT();
            return resp.pointsBalance;
        }

        public static uint XeGetPointsBalance(IClient client, XblUser user)
        {
            PointsBalanceStatus ignored;
            return XeGetPointsBalance(client, user, out ignored);
        }

        public static void XeUpdateParentalControls(IClient client, XblUser user, Privileges grant, Privileges restrict, string source)
        {
            XeUpdateParentalControls( client,  user,  grant,  restrict,  source, 0, 0);
        }
        
        public static void XeUpdateParentalControls(IClient client, XblUser user, Privileges grant, Privileges restrict, string source, uint setProfilePermissionEntries, uint clearProfilePermissionEntries)
        {
            METHOD.ENTER();
            UpdateParentalControlsRequest req = new UpdateParentalControlsRequest();
            req.userPuid = user.Puid;
            req.userGrantPrivileges = grant.ToByteData();
            req.userRestrictPrivileges = restrict.ToByteData();
            if (client.SchemaVersion >= live.protocol.WireData.MakeSchemaVersion(6, 3))
            {
                if (user.Settings.OwnerPassportInfo.SessionToken != null)
                {
                    PassportSessionToken_WD pst = new PassportSessionToken_WD();
                    pst.signedUserPassportPuid = user.Settings.OwnerPassportInfo.SessionToken;
                    req.tokens = new PassportSessionToken_WD[] { pst };
                    req.tokenLength = 1;
                }
            }
            if (client.SchemaVersion >= live.protocol.WireData.MakeSchemaVersion(6, 5))
            {
                req.setProfilePermissionEntries = setProfilePermissionEntries;
                req.clearProfilePermissionEntries = clearProfilePermissionEntries;
            }

            if (source == null)
            {
                req.source = string.Empty;
            }
            else
            {
                req.source = source;
            }
            uint hr = client.SendRequest(user, XOService.User_Account, req.Xrl,
                HttpMethod.Post, null, req, null);
            Throw.IfXErrFailed(hr);
            METHOD.EXIT();

        }

        public static Recovered XeRecoverAccount(IClient client, byte[] passportToken)
        {
            METHOD.ENTER();

            XeRecoverAccountRequest req = new XeRecoverAccountRequest();
            XeRecoverAccountResponse resp = new XeRecoverAccountResponse();

            req.machinePuid = client.MachinePuid;
            req.signedPuid = passportToken;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            Recovered rec = new Recovered(resp);

            METHOD.EXIT();

            return rec;
        }

        public static void XeSetAccountInfo(IClient client, XblUser user, PersonalInfo personalInfo)
        {
            METHOD.ENTER();
            XeSetAccountInfoRequest req = new XeSetAccountInfoRequest();
            req.addressInfo = personalInfo.AddressInfo.ToAddressInfoData();
            req.birthdate = personalInfo.BirthDate;
            req.email = personalInfo.Email;
            req.firstName = personalInfo.FirstName;
            req.languageId = personalInfo.LanguageId;
            req.lastName = personalInfo.LastName;
            req.msftOptIn = personalInfo.MsftOptIn;
            req.partnerOptIn = personalInfo.PartnerOptIn;
            req.phoneInfo = personalInfo.PhoneInfo.ToPhoneInfoData();
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            uint hr = SendRequest(client, null, req, null);
            Throw.IfXErrFailed(hr);



            METHOD.EXIT();
        }

        public static string XeGetLinkedGamertag(IClient client, PassportInfo ppInfo, out ulong userPuid)
        {
            METHOD.ENTER();
            GetLinkedGamertagRequest req = new GetLinkedGamertagRequest();
            GetLinkedGamertagResponse resp = new GetLinkedGamertagResponse();
            req.signedPassportPuid = ppInfo.SessionToken;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);
            userPuid = resp.userPuid;

            METHOD.EXIT();
            return resp.gamertag;
        }

        public static void XeMigrateXbox1User(live.client.Xbox360Client client, XblUser user, 
            PassportInfo userPassport, PassportInfo ownerPassport)
        {
            METHOD.ENTER();
            MigrateXbox1UserRequest req = new MigrateXbox1UserRequest();
            MigrateXbox1UserResponse resp = new MigrateXbox1UserResponse();
            req.languageId = user.Settings.PersonalInfo.LanguageId;
            req.machinePuid = client.MachinePuid;
            req.offlineXuid = client.OfflineXuid;
            req.reservedBytes = new byte[0];
            req.reservedBytesLength = (ushort)req.reservedBytes.Length;
            req.signedParentPassportPuid = ownerPassport.SessionToken;
            req.signedUserPassportPuid = userPassport.SessionToken;
            req.titleId = client.TitleId;
            req.userPassportMemberName = userPassport.MemberName;
            req.userPassportMemberNameLength = (ushort)req.userPassportMemberName.Length;

            uint hr = SendRequest(client, user, req, resp);
            Throw.IfHRFailed(hr);

            //resp.cultureId;
            //resp.userPuid;
            //client.Key = resp.xenonKey;
            user.Settings.UserPassportInfo = userPassport;
            user.Settings.OwnerPassportInfo = ownerPassport;

            METHOD.EXIT();
        }

        public static PersonalInfo XeGetAccountInfo(IClient client, ulong userPuid)
        {
            XeGetAccountInfoRequest req = new XeGetAccountInfoRequest();
            XeGetAccountInfoResponse resp = new XeGetAccountInfoResponse();

            req.machinePuid = client.MachinePuid;
            req.userPuid = userPuid;

            uint hr = SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            return new PersonalInfo(resp);
        }

        public static void XeGetAccountInfoFromPassport()
        {
        }

        public static UserSubscriptionDetails XeGetUserSubscriptionDetails(IClient client, XblUser user, ulong offerId)
        {
            METHOD.ENTER();
            XeGetUserSubscriptionDetailsRequest req = new XeGetUserSubscriptionDetailsRequest();
            XeGetUserSubscriptionDetailsResponse resp = new XeGetUserSubscriptionDetailsResponse();
            req.offerId = offerId;
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            req.instanceId = "";
            req.instanceIdLength = 0;

            uint hr = client.SendRequest(user, XOService.User_Account, req.Xrl,
                HttpMethod.Post, new WebHeaderCollection(), req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return new UserSubscriptionDetails(resp);
        }

        /// <summary>
        /// Gets the user type (as opposed to account tier) for the supplied user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="user"></param>
        /// <param name="hasGamerProfile">This is set to true if the user has a gamer profile</param>
        /// <returns></returns>
        public static XboxUserType XeGetUserType(IClient client, XblUser user, out bool hasGamerProfile)
        {
            METHOD.ENTER();
            XeGetUserTypeRequest req = new XeGetUserTypeRequest();
            XeGetUserTypeResponse resp = new XeGetUserTypeResponse();
            req.machinePuid = client.MachinePuid;
            req.gamertag = user.Gamertag;


            uint hr = SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            hasGamerProfile = resp.HasGamerProfile;
            METHOD.EXIT();
            return (XboxUserType)resp.UserType;
        }

        /// <summary>
        /// Gets the user type (As opposed to Account Tier) for the supplied user
        /// </summary>
        /// <param name="client"></param>
        /// <param name="user"></param>
        /// <returns></returns>
        public static XboxUserType XeGetUserType(IClient client, XblUser user)
        {
            bool ignored;
            return XeGetUserType(client, user, out ignored);
        }


        public static void XeMigrateXboxComUser()
        {
        }

        /// <summary>
        /// Gets the UserWebInfo for the user. Note: the Client must have its title id set to XOn.WEB_TITLE_ID
        /// </summary>
        /// <param name="client">The client</param>
        /// <param name="user">The User</param>
        /// <returns></returns>
        public static UserWebInfo XeGetUserWebInfo(IClient client, XblUser user)
        {
            METHOD.ENTER();
            XeGetUserWebInfoRequest req = new XeGetUserWebInfoRequest();
            XeGetUserWebInfoResponse resp = new XeGetUserWebInfoResponse();
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, 
                                  XOService.User_Account_Internal,
                                  req, resp); // Send request to internal interface
            Throw.IfXErrFailed(hr);

            UserWebInfo info = new UserWebInfo(resp);
            METHOD.EXIT();
            return info;

        }

        public static void XeUpdateXboxComActivity(IClient client, XblUser user)
        {
            METHOD.ENTER();

            XeUpdateXboxComActivityRequest req = new XeUpdateXboxComActivityRequest();
            req.userPuid = user.Puid;

            uint hr = client.SendRequest(user, XOService.User_Account, req.Xrl,
                HttpMethod.Post, null, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }

        public static void XeReserveGamertag()
        {
        }

        public static void XeVerifyParentCreditCard()
        {
        }

        public static AccountIssues XeTroubleshootAccount(IClient client, XblUser user)
        {
            METHOD.ENTER();
            XeTroubleshootAccountRequest req = new XeTroubleshootAccountRequest();
            XeTroubleshootAccountResponse resp = new XeTroubleshootAccountResponse();
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;

            uint hr = UACS.SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            AccountIssues issues = new AccountIssues(resp);

            METHOD.EXIT();
            return issues;
        }

        public static void XeAcknowledgeDowngrade()
        {
        }

        public static void XeVerifyBillingInfo()
        {
        }

        public static WSGetPaymentInstrumentResponse WSGetPaymentInstruments(IClient client, XblUser user)
        {
            WSGetPaymentInstrumentsRequest req = new WSGetPaymentInstrumentsRequest();
            WSGetPaymentInstrumentResponse resp = new WSGetPaymentInstrumentResponse();

            METHOD.ENTER();

            req.MachinePuid = client.MachinePuid;
            req.UserPuid = user.Puid;

            uint hr = UACS.SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();

            return resp;
        }

        //
        //  XBOX 1
        //

        public static void reservename()
        {
        }

        public static XblUser createowneracct(XboxClient client, XblUserSettings settings)
        {
            METHOD.ENTER();

            CreateAccountRequest req = settings.ToCreateAccountRequest(client);
            CreateAccountResponse resp = new CreateAccountResponse();

            uint hr = UACS.SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            settings.Xbox1Key = resp.key;

            METHOD.EXIT();
            return new XblUser(resp.puid, req.gamertag, settings);
        }

        public static void getpaymentinfo()
        {
        }

        public static void setpaymentinfo()
        {
        }

        public static void setusersettings()
        {
        }

        public static void setusersettings2()
        {
        }

        public static void setuserpin()
        {
        }

        public static void verifybillingpin()
        {
        }

        public static void verifyvoucher()
        {
        }

        public static void restoreaccount()
        {
        }

        public static void changegamertag()
        {
        }

        public static void setuseraccountstatus()
        {
        }

        public static void accepttou()
        {
        }

        public static void AcceptTermsOfService(Xbox360Client client, XblUser user)
        {
            METHOD.ENTER();
            AcceptTermsOfServiceRequest req = new AcceptTermsOfServiceRequest();
            req.titleId = client.TitleId;
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;

            uint hr = SendRequest(client, user, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
        }

        public static void troubleshootaccount()
        {
        }

        public static void clearsubscriptions()
        {
        }

        public static void DisableSubscription(Xbox360Client client, XblUser user, string serviceInstanceId, SubscriptionStatus status, bool addViolation)
        {
            METHOD.ENTER();
            DisableSubscriptionRequest req = new DisableSubscriptionRequest();
            req.userPuid = user.Puid;
            req.addViolation = addViolation;
            req.serviceInstanceId = serviceInstanceId;
            req.serviceInstanceIdLength = (ushort)serviceInstanceId.Length;
            req.subscriptionStatusId = (int)status;

            uint hr = SendRequest(client, user, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();

        }

        public static void getpostalcode()
        {
        }

        public static void linkwebaccount()
        {
        }

        public static void webgetusersettings()
        {
        }

        public static void enumerateeligible()
        {
        }

        public static void getsubscriptionstatus()
        {
        }

        public static void renewsubscription()
        {
        }

        public static void verifyvouchergetoffer()
        {
        }

        /// <summary>
        /// Gets an anonymous ID associated with the PUID passed. This ID cannot be traced back to the user
        /// </summary>
        /// <param name="_client">The xbox 360 client</param>
        /// <param name="_user">The user that is requesting the ANID</param>
        /// <param name="_puid">The PUID to request the ANID for. This is passed for testing purposes to allow mismatches</param>
        /// <returns></returns>
        public static XeGetANIDResponse GetANID(IClient _client, XblUser _user, ulong _puid)
        {
            XeGetANID request = new XeGetANID();
            XRLObject2 response = new XeGetANIDResponse();

            request.UserXuid = _puid;

            uint hr = SendRequest(_client, _user, request, response);
            Throw.IfXErrFailed(hr);

            return (XeGetANIDResponse)response;
        }

        //
        // HEALTHCHECK
        //

        public static void HealthCheck()
        {
        }
        
        public static uint TransferPoints(IClient client, XblUser primary, XblUser secondary, int pointsQuantity)
        {
            METHOD.ENTER();
            WSTransferPointsBalance req = new WSTransferPointsBalance();
            req.dependentUserPuid = secondary.Puid;
            req.primaryUserPuid = primary.Puid;
            req.pointstoTransfer = pointsQuantity;

            uint hr = SendRequest(client, primary, XOService.WebAccounts, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return hr;
        }
                
        
    }
}
namespace live.server.next
{
    using live.protocol.next;
    using System.Xml;
    using System.IO;

    public static class UACS
    {
        public static PersonalInfo XeGetUserInfo(IClient client, ulong userPuid, out int age)
        {
            METHOD.ENTER();
            GetUserInfoRequest req = new GetUserInfoRequest();
            GetUserInfoResponse resp = new GetUserInfoResponse();

            req.machinePuid = client.MachinePuid;
            req.userPuid = userPuid;
            req.titleId = client.TitleId;

            uint hr = live.server.UACS.SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            PersonalInfo pi = new PersonalInfo(resp);
            age = resp.age;

            METHOD.EXIT();
            return pi;
        }

        public static uint XeSwitchUserPassport(IClient client, XblUser user, PassportInfo newPpInfo, bool transferBalance)
        {
            METHOD.ENTER();

            SwitchUserPassportRequest req = new SwitchUserPassportRequest();

            req.machinePuid = client.MachinePuid;
            req.titleId = client.TitleId;
            req.userPuid = user.Puid;

            req.signedOldUserPassportPuid = user.Settings.UserPassportInfo.SessionToken;
            req.oldUserPassportMemberName = user.Settings.UserPassportInfo.MemberName;

            req.signedNewUserPassportPuid = newPpInfo.SessionToken;
            req.newUserPassportMemberName = newPpInfo.MemberName;

            req.transferBalance = transferBalance;

            uint hr = live.server.UACS.SendRequest(client, user, req, null);
            Throw.IfXErrFailed(hr);

            if (hr == HResult.S_OK)
            {
                // If the switch is successful update the passport settings with the new passport info
                // For a parent account update both user and owner passport info
                // For a child account update only user passport info

                if (user.Settings.UserPassportInfo.PassportPuid == user.Settings.OwnerPassportInfo.PassportPuid)
                {  // Parent
                    user.Settings.OwnerPassportInfo = newPpInfo.DeepClone();
                }

                user.Settings.UserPassportInfo = newPpInfo.DeepClone();
            }

            METHOD.EXIT();
            return hr;
        }


        public static uint XeSwitchUserPassportNpdbOverride(IClient client, XblUser user, PassportInfo newPpInfo, bool transferBalance)
        {
            METHOD.ENTER();        

            SwitchUserPassportRequest req = new SwitchUserPassportRequest();

            req.machinePuid = client.MachinePuid;
            req.titleId = client.TitleId;
            req.userPuid = user.Puid;

            req.signedOldUserPassportPuid = user.Settings.UserPassportInfo.SessionToken;
            req.oldUserPassportMemberName = user.Settings.UserPassportInfo.MemberName;

            req.signedNewUserPassportPuid = newPpInfo.SessionToken;
            req.newUserPassportMemberName = newPpInfo.MemberName;

            req.transferBalance = transferBalance;
            req.BehaviorInjection.AddNpdbOverride("xuacs_switchUserPassportDaysBetween", "0", false);
            
            uint hr =  live.server.UACS.SendRequest(client, user, req, null);
            Throw.IfXErrFailed(hr);

            if (hr == HResult.S_OK)
            {
                // If the switch is successful update the passport settings with the new passport info
                // For a parent account update both user and owner passport info
                // For a child account update only user passport info
                
                if (user.Settings.UserPassportInfo.PassportPuid == user.Settings.OwnerPassportInfo.PassportPuid)
                {  // Parent
                    user.Settings.OwnerPassportInfo = newPpInfo.DeepClone();          
                }
                
                user.Settings.UserPassportInfo = newPpInfo.DeepClone();
            }

            METHOD.EXIT();
            return hr;
        }

        /// <summary>
        /// This is the ActiveAuth version of XeGetPointsBalance.
        /// </summary>
        /// <param name="client"></param>
        /// <param name="user"></param>
        /// <param name="status"></param>
        /// <returns>Points Balance of user</returns>
        public static uint GetPointsBalance(IClient client, XblUser user, out PointsBalanceStatus status)
        {
            METHOD.ENTER();
            GetPointsBalanceWebRequest req = new GetPointsBalanceWebRequest();
            GetPointsBalanceWebResponse res = new GetPointsBalanceWebResponse();

            status = PointsBalanceStatus.None;
            uint balance = uint.MaxValue;

            req.UserPuid = user.Puid;

            live.server.Billing.SendRequest(client, user, XOService.WebAccounts, req, res);


            StringReader sreader = new StringReader(res.Response);
            XmlReader reader = XmlReader.Create(sreader);
            XmlDocument doc = new XmlDocument();
            doc.Load(reader);
            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                if (node.Name == "PointsBalance")
                {
                    balance = uint.Parse(node.FirstChild.Value);
                }
                else if (node.Name == "AboveLowBalance" && bool.Parse(node.FirstChild.Value))
                {
                    status |= PointsBalanceStatus.AboveLowBalance;
                }
                else if (node.Name == "DmpAccountStatus")
                {
                    byte dmp = byte.Parse(node.FirstChild.Value);
                    switch (dmp)
                    {
                        case 0:
                            status |= PointsBalanceStatus.Active;
                            break;
                        case 1:
                            status |= PointsBalanceStatus.Disabled;
                            break;
                        case 2:
                            status |= PointsBalanceStatus.Closed;
                            break;
                        default:
                            break;

                    }

                }
            }
            METHOD.EXIT();
            return balance;

        }

        public static uint GetDependentPointsBalance(IClient client, XblUser primary, XblUser secondary)
        {
            METHOD.ENTER();
            WSGetDependentPointsBalanceRequest req = new WSGetDependentPointsBalanceRequest();
            req.dependentUserPuid = secondary.Puid;
            req.primaryUserPuid = primary.Puid;

            WSGetDependentPointsBalanceResponse resp = new WSGetDependentPointsBalanceResponse();
            uint hr = live.server.Billing.SendRequest(client, primary, XOService.WebAccounts, req, resp);
            Throw.IfXErrFailed(hr);

            StringReader sreader = new StringReader(resp.Response);
            XmlReader reader = XmlReader.Create(sreader);
            XmlDocument doc = new XmlDocument();
            doc.Load(reader);

            uint balance = uint.MaxValue;
            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                if (node.Name == "pointbalance")
                {
                    balance = uint.Parse(node.FirstChild.Value);
                }
            }

            METHOD.EXIT();

            return balance;//resp.pointsBalance;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="user"></param>
        /// <returns>Points Balance of user</returns>
        public static uint GetPointsBalance(IClient client, XblUser user)
        {
            PointsBalanceStatus ignored;
            return GetPointsBalance(client, user, out ignored);
        }

        public static void ParseGetPointsBalanceWebResponse(GetPointsBalanceWebResponse res)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(res.Response);
            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                if (node.Name == "PointsBalance")
                {
                    res.PointsBalance = int.Parse(node.FirstChild.Value);
                }
                else if (node.Name == "AboveLowBalance")
                {
                    res.AboveLowBalance = bool.Parse(node.FirstChild.Value);
                }
                else if (node.Name == "DmpAccountStatus")
                {
                    res.DmpAccountStatus = byte.Parse(node.FirstChild.Value);
                }
            }
        }

        public static GetPointsBalanceWebResponse WebGetPointsBalance(IClient client, XblUser user)
        {
            METHOD.ENTER();
            GetPointsBalanceWebRequest req = new GetPointsBalanceWebRequest();
            GetPointsBalanceWebResponse res = new GetPointsBalanceWebResponse();
            req.UserPuid = user.Puid;

            live.server.Billing.SendRequest(client, user, XOService.WebAccounts, req, res);
            ParseGetPointsBalanceWebResponse(res);
            METHOD.EXIT();
            return res;
        }

        public static SignInWebResponse ZuneSignIn(IClient client, XblUser user)
        {
            METHOD.ENTER();
            SignInWebRequest req = new SignInWebRequest();
            SignInWebResponse res = new SignInWebResponse();

            live.server.Billing.SendRequest(client, user, XOService.WebAccounts, req, res);

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(res.Response);
            res.AccountInfo = new AccountInfo();
            res.ErrorInfo = new ErrorInfo();
            foreach (XmlNode node in doc.DocumentElement.ChildNodes)
            {
                if (node.Name == "ErrorInfo")
                {
                    foreach (XmlNode subNode in node)
                    {
                        switch (subNode.Name)
                        {
                            case "HResult":
                                res.ErrorInfo.HResult = uint.Parse(subNode.FirstChild.Value);
                                break;
                            case "TagChangeRequired":
                                res.ErrorInfo.TagChangeRequired = bool.Parse(subNode.FirstChild.Value);
                                break;
                        }
                    }
                }
                else if (node.Name == "AccountInfo")
                {
                    foreach (XmlNode subNode in node)
                    {
                        switch (subNode.Name)
                        {
                            case "XboxPuid":
                                res.AccountInfo.XboxPuid = ulong.Parse(subNode.FirstChild.Value);
                                break;
                            case "LivePuid":
                                res.AccountInfo.LivePuid = ulong.Parse(subNode.FirstChild.Value);
                                break;
                            case "IsLightweight":
                                res.AccountInfo.IsLightweight = bool.Parse(subNode.FirstChild.Value);
                                break;

                        }
                    }
                }
            }

            Throw.IfXErrFailed(res.ErrorInfo.HResult);
            METHOD.EXIT();
            return res;
        }

        public static PersonalInfo XeGetAccountInfo(IClient client, ulong userPuid)
        {
            XeGetAccountInfoRequest req = new XeGetAccountInfoRequest();
            XeGetAccountInfoResponse resp = new XeGetAccountInfoResponse();

            req.machinePuid = client.MachinePuid;
            req.userPuid = userPuid;

            uint hr = live.server.UACS.SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);

            return new PersonalInfo(resp);
        }

        /// <summary>
        /// Gets the UserWebInfo for the user. Note: the Client must have its title id set to XOn.WEB_TITLE_ID
        /// </summary>
        /// <param name="client">The client</param>
        /// <param name="user">The User</param>
        /// <returns></returns>
        public static UserWebInfo XeGetUserWebInfo(IClient client, XblUser user)
        {
            METHOD.ENTER();
            XeGetUserWebInfoRequest req = new XeGetUserWebInfoRequest();
            XeGetUserWebInfoResponse resp = new XeGetUserWebInfoResponse();
            req.userPuid = user.Puid;

            uint hr = live.server.UACS.SendRequest(client, user, req, resp);
            Throw.IfXErrFailed(hr);

            UserWebInfo info = new UserWebInfo(resp);
            METHOD.EXIT();
            return info;

        }

        public static ulong XePassportGetPuidFromMemberName(IClient client, string memberName)
        {
            METHOD.ENTER();
            XePassportGetPuidFromMemberNameRequest req = new XePassportGetPuidFromMemberNameRequest();
            XePassportGetPuidFromMemberNameResponse resp = new XePassportGetPuidFromMemberNameResponse();
            req.memberName = memberName;
            req.memberNameLength = (ushort)memberName.Length;

            uint hr = client.SendRequest(null, XOService.User_Account, req.Xrl, HttpMethod.Post, null, req, resp);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return resp.passportPuid;


        }

        public static void XeGraduateUser(IClient client, XblUser user, CreditCardInfo creditCard)
        {
            XeGraduateUser(client, user, (PaymentInstrumentBase)creditCard);
        }

        public static void XeGraduateUser(IClient client, XblUser user, DirectDebitInfo directDebit)
        {
            XeGraduateUser(client, user, (PaymentInstrumentBase)directDebit);
        }

        public static void XeGraduateUser(IClient client, XblUser user)
        {
            XeGraduateUser(client, user, (PaymentInstrumentBase) null);
        }

        static void XeGraduateUser(IClient client, XblUser user, PaymentInstrumentBase payment)
        {
            METHOD.ENTER();
            GraduateUserRequest req = new GraduateUserRequest();
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;


            if (payment == null)
            {
                req.creditCardInfo = new CreditCardInfoData();
                req.directDebitInfo = new DirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
                req.addressInfo = new AddressInfoData();
                req.phoneInfo = new PhoneInfoData();

            }
            else if (payment is CreditCardInfo)
            {
                req.creditCardInfo = ((CreditCardInfo)payment).ToCreditCardInfoData();
                req.directDebitInfo = new DirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.CreditCard;
                req.addressInfo = payment.AddressInfo.ToAddressInfoData();
                req.phoneInfo = payment.PhoneInfo.ToPhoneInfoData();

            }
            else if (payment is DirectDebitInfo)
            {
                req.creditCardInfo = new CreditCardInfoData();
                req.directDebitInfo = ((DirectDebitInfo)payment).ToDirectDebitInfoData();
                req.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.DirectDebit;
                req.addressInfo = payment.AddressInfo.ToAddressInfoData();
                req.phoneInfo = payment.PhoneInfo.ToPhoneInfoData();
            }


            uint hr = client.SendRequest(null, XOService.User_Account, req.Xrl, HttpMethod.Post, null, req, null);
            Throw.IfXErrFailed(hr);

            METHOD.EXIT();
            return;


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\minrunner\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\util\AccountsUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.lfm;
using live.server;

namespace live.common
{
    public static partial class Util
    {
        public static class Accounts
        {
            /// <summary>
            /// Creates a Live service account.
            /// </summary>
            /// <param name="settings">The settings to create the user with.</param>
            /// <returns>The created user</returns>
            public static XblUser CreateLiveAccount(XblUserSettings settings)
            {
                Xbox360 xbox360 = new Xbox360();
                XblUser user = xbox360.SignUp.CreateUser(settings);
                xbox360.ShutdownConsole();
                return user;
            }

            /// <summary>
            /// Creates a Live service account. For example:  CreateLiveAccount(XblUserTier.Silver, 
            /// PassportType.Real, false) creates a real Passport and a free Live account and returns 
            /// a representative XblUser instance.
            /// </summary>
            /// <param name="userTier">The user's type (ex: XblUserTier.Silver).</param>
            /// <param name="passportType">The user's passport type (ex: PassportType.Real).</param>
            /// <param name="createZuneProfile">Specifies whether or not to creates a Zune profile.</param>
            /// <returns>The created user.</returns>
            public static XblUser CreateLiveAccount(XblUserTier userTier, PassportType passportType, 
                bool createZuneProfile)
            {
                if (passportType == PassportType.Existing)
                {
                    throw new ArgumentException("This method cannot be called with PassportType.Existing", 
                        "passportType");
                }

                XblUserSettings settings = new XblUserSettings(userTier, passportType);
                settings.CreateZuneProfile = createZuneProfile;
                return CreateLiveAccount(settings);
            }

            /// <summary>
            /// Creates a Live service account with a Zune profile and subscription.
            /// </summary>
            /// <param name="userTier">The user's type (ex: XblUserTier.Silver).</param>
            /// <param name="passportType">The user's passport type (ex: PassportType.Real).</param>
            /// <param name="musicNetOffer">The Zune subscription offer ID. (ex: Offers.MusicNetOffers.MonthlyPP).</param>
            /// <returns>The created user.</returns>
            public static XblUser CreateZuneAccount(XblUserTier userTier, PassportType passportType,
                Offers.MusicNetOffers musicNetOffer)
            {
                if (userTier == XblUserTier.Xbox1)
                {
                    throw new ArgumentException("Cannot create Zune users with Xbox 1 accounts", "userTier");
                }
                if (passportType == PassportType.Fake && Offers.IsCreditCardRequired(musicNetOffer))
                {
                    throw new ArgumentException("Fake passports cannot be used with credit card offers", 
                        "passportType");
                }

                PaymentTypeEnum paymentType;
                string paymentIdOrToken;

                // Create an acct with Argo profile
                XblUser user = CreateLiveAccount(userTier, passportType, true);

                // Select the appropriate payment instrument, creating one if none exists
                if (Offers.IsCreditCardRequired(musicNetOffer))
                {
                    paymentType = PaymentTypeEnum.CreditCard;
                    PaymentInstrumentBase pib = user.Settings.BillingInfo.GetActivePaymentInstrument();
                    if (pib != null)
                    {
                        paymentIdOrToken = pib.PaymentInstrumentId;
                    }
                    else
                    {
                        paymentIdOrToken = Accounts.AddVisaPaymentInstrument(user);
                    }
                }
                else
                {
                    paymentType = PaymentTypeEnum.Token;
                    paymentIdOrToken = Offers.GetPrepaidVoucherCode(musicNetOffer);
                }

                // Purchase a MusicNet subscription
                Util.Billing.PurchaseOffer(user, XOn.CRUX_TITLE_ID, Offers.GetOfferId(musicNetOffer),
                    paymentType, paymentIdOrToken);

                return user;
            }

            /// <summary>
            /// Creates a Live service account with a Zune profile and subscription.
            /// </summary>
            /// <param name="userTier">The user's account type. (ex: XblUserTier.Silver).</param>
            /// <param name="passportType">The user's passport type. (ex: PassportType.Real).</param>
            /// <param name="musicNetOfferId">The Zune subscription offer ID. (ex: 0xFFFE077788000010).</param>
            /// <param name="paymentType">The type of payment being made (ex: PaymentTypeEnum.Token).</param>
            /// <param name="paymentIdOrToken">The payment instrument ID or prepaid voucher code
            /// used to pay for the MusicNet subscription. (ex: "D6B9M-TQVGM-HP892-WR382-626G8").</param>
            /// <returns>The created user</returns>
            public static XblUser CreateZuneAccount(XblUserTier userTier, PassportType passportType,
                ulong musicNetOfferId, PaymentTypeEnum paymentType, string paymentIdOrToken)
            {
                if (userTier == XblUserTier.Xbox1)
                {
                    throw new ArgumentException("Cannot create Zune users with Xbox 1 accounts", "userTier");
                }
                if (musicNetOfferId == 0)
                {
                    throw new ArgumentException("The MusicNet offer ID cannot be 0.", "musicNetOfferId");
                }
                if (paymentType != PaymentTypeEnum.CreditCard && paymentType != PaymentTypeEnum.Token)
                {
                    throw new ArgumentException("Cannot purchase MusicNet subscriptions with payment type " + 
                        paymentType, "paymentType");
                }
                if (paymentIdOrToken == null || paymentIdOrToken == "")
                {
                    throw new ArgumentException("Payment ID cannot be null or empty", "paymentIdOrToken");
                }

                // Create an acct with Argo profile
                XblUser user = CreateLiveAccount(userTier, passportType, true);

                // Purchase a MusicNet subscription
                Util.Billing.PurchaseOffer(user, XOn.CRUX_TITLE_ID, musicNetOfferId,
                    paymentType, paymentIdOrToken);

                return user;
            }

            /// <summary>
            /// Generates and adds a Visa to the user's account.
            /// </summary>
            /// <param name="user">The user whose account will have a Visa added.</param>
            public static string AddVisaPaymentInstrument(XblUser user)
            {
                Xbox360Client client = new Xbox360Client(user.Settings.CreatedOn);
                client.UserLoggingOn(user);

                // Generate a Visa credit card and add it to the user's account
                CreditCardInfo creditCard =
                    Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                UACS.XeAddPaymentInstrument(client, user, creditCard);

                client.Shutdown();
                return creditCard.PaymentInstrumentId;
            }

            public static XblUser LoadXblUserFromPassportLogin(string memberName, string password)
            {
                METHOD.ENTER();
                PassportInfo ppi = new PassportInfo();
                ppi.MemberName = memberName;
                ppi.Password = password;
                Xbox360Client client = new Xbox360Client();

                using (client)
                {
                    PassportUtils.LoadExistingPassportAccount(client, ppi);
                    ulong xuid;
                    string gamertag = UACS.XeGetLinkedGamertag(client, ppi, out xuid);
                    XblUser user = new XblUser(xuid, gamertag);
                    XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Existing);
                    user.Settings = settings;
                    settings.PersonalInfo.CountryId = ppi.CountryId;
                    settings.PersonalInfo.LanguageId = 1;
                    client.UserLoggingOn(user);

                    //Needed to get Parentcontrol group and actual User Tier
                    WebClient webClient = new WebClient();
                    webClient.TitleId = XOn.WEB_TITLE_ID;
                    webClient.AddUser(user);
                    UserWebInfo uwi = UACS.XeGetUserWebInfo(webClient, user);
                    settings.UserType = uwi.Tier;

                    PersonalInfo pi = UACS.XeGetAccountInfo(client, user.Puid);
                    settings.PersonalInfo = pi;
                    pi.Gamertag = user.Gamertag;
                    settings.UserPassportInfo = ppi;
                    settings.PersonalInfo.ParentalControlGroupId = uwi.ParentalControlGroupId;
                    if (uwi.ParentalControlGroupId == 0)
                    {
                        settings.OwnerPassportInfo = ppi.DeepClone();
                    }

                    METHOD.EXIT();
                    return user;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\minrunner\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\minrunner\UnitTestsProxy.cs ===
using System;

using live.client;
using live.common;
using live.server;
using live.unittests.samples;

namespace live.minrunner
{
    public static class UnitTestsProxy
    {
        public static void GetAccountEx()
        {
            Xbox360Client client = new Xbox360Client();
            XblUser user;
            using (client)
            {
                user = SamplesTests.CreateLiveAccounts.CreateLiveAccount(client, XblUserTier.Gold, PassportType.Real);
            }

            WebClient webClient = new WebClient();

            AccountInfoEx info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be owner");
            }

            Cust.BanAccount(webClient, user.Puid, true);

            info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be owner");
            }
        }

        public static void BanAccount()
        {
            Xbox360Client client = new Xbox360Client();
            XblUser user;
            using (client)
            {
                user = SamplesTests.CreateLiveAccounts.CreateLiveAccount(client, XblUserTier.Gold, PassportType.Real);
            }

            WebClient webClient = new WebClient();

            AccountInfoEx info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be owner");
            }
            DateTime oldResumeDate = info.ResumeDate;

            Cust.BanAccount(webClient, user.Puid, true);

            info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be owner");
            }
            if (info.ResumeDate == oldResumeDate)
            {
                throw new Exception("Expected different resume date");
            }
        }

        public static void VoiceBanAccount()
        {
            Xbox360Client client = new Xbox360Client();
            XblUser user;
            using (client)
            {
                user = SamplesTests.CreateLiveAccounts.CreateLiveAccount(client, XblUserTier.Gold, PassportType.Real);
            }

            WebClient webClient = new WebClient();

            AccountInfoEx info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be user");
            }
            int oldVoiceBanLength = info.VoiceBanLength;

            //Cust.BanAccount(webClient, user.Puid, true);
            AccountInfo newInfo = new AccountInfo();
            newInfo.IsVoiceBanned = true;
            Cust.ModifyAccount(webClient, user.Puid, newInfo);

            newInfo = Cust.GetAccount(webClient, user.Puid);

            info = Cust.GetAccountEx(webClient, user.Puid);
            if (info.Puid != user.Puid)
            {
                throw new Exception("Expected to be user");
            }
            if (info.VoiceBanLength == oldVoiceBanLength)
            {
                throw new Exception("Expected greater voice ban length");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\Web References\WebClientProxyWebReference\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.1434.
// 
#pragma warning disable 1591

namespace live.WebClientProxyWebReference {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebClientProxySoap", Namespace="http://test.xbox.com/")]
    public partial class WebClientProxy : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback SendRequestOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebClientProxy() {
            this.Url = global::live.Properties.Settings.Default.LiveLib_WebReference_WebClientProxy;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event SendRequestCompletedEventHandler SendRequestCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SendRequest", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint SendRequest(TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] request, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] out byte[] response) {
            object[] results = this.Invoke("SendRequest", new object[] {
                        secProv,
                        service,
                        relativeUrl,
                        httpMethod,
                        webHeaders,
                        request});
            response = ((byte[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SendRequestAsync(TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, byte[] request) {
            this.SendRequestAsync(secProv, service, relativeUrl, httpMethod, webHeaders, request, null);
        }
        
        /// <remarks/>
        public void SendRequestAsync(TG2SecurityProvider secProv, XOService service, string relativeUrl, string httpMethod, string[] webHeaders, byte[] request, object userState) {
            if ((this.SendRequestOperationCompleted == null)) {
                this.SendRequestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendRequestOperationCompleted);
            }
            this.InvokeAsync("SendRequest", new object[] {
                        secProv,
                        service,
                        relativeUrl,
                        httpMethod,
                        webHeaders,
                        request}, this.SendRequestOperationCompleted, userState);
        }
        
        private void OnSendRequestOperationCompleted(object arg) {
            if ((this.SendRequestCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendRequestCompleted(this, new SendRequestCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public partial class TG2SecurityProvider {
        
        private uint titleIdField;
        
        private CSGInfo securityInfoField;
        
        /// <remarks/>
        public uint TitleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
        
        /// <remarks/>
        public CSGInfo SecurityInfo {
            get {
                return this.securityInfoField;
            }
            set {
                this.securityInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public partial class CSGInfo {
        
        private uint inaSgField;
        
        private uint spiSgField;
        
        private uint ipaIField;
        
        private ushort ipportIField;
        
        private long liNonceField;
        
        private ulong machinePuidField;
        
        private uint titleIdField;
        
        private uint titleVersionField;
        
        private uint titleRegionField;
        
        private uint consoleRegionField;
        
        private uint mediaIDField;
        
        private ushort languageIDField;
        
        private uint authDataFlagsField;
        
        private ushort wMajorVersionField;
        
        private ushort wMinorVersionField;
        
        private ushort wBuildNumberField;
        
        private ushort wQFENumberField;
        
        private ulong userPuid0Field;
        
        private ulong userPuid1Field;
        
        private ulong userPuid2Field;
        
        private ulong userPuid3Field;
        
        private uint userFlag0Field;
        
        private uint userFlag1Field;
        
        private uint userFlag2Field;
        
        private uint userFlag3Field;
        
        private ushort wNumPrivilegesField;
        
        private uint dwPrivileges4Field;
        
        private uint dwPrivileges5Field;
        
        private uint dwPrivileges6Field;
        
        private uint dwPrivileges7Field;
        
        public uint dwPrivileges5User0;
        public uint dwPrivileges6User0;
        public uint dwPrivileges7User0;
        public uint dwPrivileges5User1;
        public uint dwPrivileges6User1;
        public uint dwPrivileges7User1;
        public uint dwPrivileges5User2;
        public uint dwPrivileges6User2;
        public uint dwPrivileges7User2;
        public uint dwPrivileges5User3;
        public uint dwPrivileges6User3;
        public uint dwPrivileges7User3;
        
        private uint dwPrivileges0Field;
        
        private uint dwPrivileges1Field;
        
        private uint dwPrivileges2Field;
        
        private uint dwPrivileges3Field;

        private ushort wNumDwordServicesField;
        
        private uint dwServiceID0Field;
        
        private uint dwServiceID1Field;
        
        private uint dwServiceID2Field;
        
        private uint dwServiceID3Field;
        
        private float userTrust0Field;
        
        private float userTrust1Field;
        
        private float userTrust2Field;
        
        private float userTrust3Field;
        
        private uint altTitleId0Field;
        
        private uint altTitleId1Field;
        
        private uint altTitleId2Field;
        
        private uint altTitleId3Field;
        
        private byte key00Field;
        
        private byte key01Field;
        
        private byte key02Field;
        
        private byte key03Field;
        
        private byte key04Field;
        
        private byte key05Field;
        
        private byte key06Field;
        
        private byte key07Field;
        
        private byte key08Field;
        
        private byte key09Field;
        
        private byte key10Field;
        
        private byte key11Field;
        
        private byte key12Field;
        
        private byte key13Field;
        
        private byte key14Field;
        
        private byte key15Field;
        
        private byte userExistsField;
        
        private ushort portField;
        
        private ulong clientVersionField;
        
        /// <remarks/>
        public uint inaSg {
            get {
                return this.inaSgField;
            }
            set {
                this.inaSgField = value;
            }
        }
        
        /// <remarks/>
        public uint SpiSg {
            get {
                return this.spiSgField;
            }
            set {
                this.spiSgField = value;
            }
        }
        
        /// <remarks/>
        public uint ipaI {
            get {
                return this.ipaIField;
            }
            set {
                this.ipaIField = value;
            }
        }
        
        /// <remarks/>
        public ushort ipportI {
            get {
                return this.ipportIField;
            }
            set {
                this.ipportIField = value;
            }
        }
        
        /// <remarks/>
        public long liNonce {
            get {
                return this.liNonceField;
            }
            set {
                this.liNonceField = value;
            }
        }
        
        /// <remarks/>
        public ulong machinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public uint titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint titleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public uint titleRegion {
            get {
                return this.titleRegionField;
            }
            set {
                this.titleRegionField = value;
            }
        }
        
        /// <remarks/>
        public uint consoleRegion {
            get {
                return this.consoleRegionField;
            }
            set {
                this.consoleRegionField = value;
            }
        }
        
        /// <remarks/>
        public uint mediaID {
            get {
                return this.mediaIDField;
            }
            set {
                this.mediaIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort languageID {
            get {
                return this.languageIDField;
            }
            set {
                this.languageIDField = value;
            }
        }
        
        /// <remarks/>
        public uint authDataFlags {
            get {
                return this.authDataFlagsField;
            }
            set {
                this.authDataFlagsField = value;
            }
        }
        
        /// <remarks/>
        public ushort wMajorVersion {
            get {
                return this.wMajorVersionField;
            }
            set {
                this.wMajorVersionField = value;
            }
        }
        
        /// <remarks/>
        public ushort wMinorVersion {
            get {
                return this.wMinorVersionField;
            }
            set {
                this.wMinorVersionField = value;
            }
        }
        
        /// <remarks/>
        public ushort wBuildNumber {
            get {
                return this.wBuildNumberField;
            }
            set {
                this.wBuildNumberField = value;
            }
        }
        
        /// <remarks/>
        public ushort wQFENumber {
            get {
                return this.wQFENumberField;
            }
            set {
                this.wQFENumberField = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid0 {
            get {
                return this.userPuid0Field;
            }
            set {
                this.userPuid0Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid1 {
            get {
                return this.userPuid1Field;
            }
            set {
                this.userPuid1Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid2 {
            get {
                return this.userPuid2Field;
            }
            set {
                this.userPuid2Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid3 {
            get {
                return this.userPuid3Field;
            }
            set {
                this.userPuid3Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag0 {
            get {
                return this.userFlag0Field;
            }
            set {
                this.userFlag0Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag1 {
            get {
                return this.userFlag1Field;
            }
            set {
                this.userFlag1Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag2 {
            get {
                return this.userFlag2Field;
            }
            set {
                this.userFlag2Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag3 {
            get {
                return this.userFlag3Field;
            }
            set {
                this.userFlag3Field = value;
            }
        }
        
        /// <remarks/>
        public ushort wNumPrivileges {
            get {
                return this.wNumPrivilegesField;
            }
            set {
                this.wNumPrivilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges0 {
            get {
                return this.dwPrivileges0Field;
            }
            set {
                this.dwPrivileges0Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges1 {
            get {
                return this.dwPrivileges1Field;
            }
            set {
                this.dwPrivileges1Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges2 {
            get {
                return this.dwPrivileges2Field;
            }
            set {
                this.dwPrivileges2Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges3 {
            get {
                return this.dwPrivileges3Field;
            }
            set {
                this.dwPrivileges3Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges4 {
            get {
                return this.dwPrivileges4Field;
            }
            set {
                this.dwPrivileges4Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges5 {
            get {
                return this.dwPrivileges5Field;
            }
            set {
                this.dwPrivileges5Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges6 {
            get {
                return this.dwPrivileges6Field;
            }
            set {
                this.dwPrivileges6Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges7 {
            get {
                return this.dwPrivileges7Field;
            }
            set {
                this.dwPrivileges7Field = value;
            }
        }
        
        /// <remarks/>
        public ushort wNumDwordServices {
            get {
                return this.wNumDwordServicesField;
            }
            set {
                this.wNumDwordServicesField = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID0 {
            get {
                return this.dwServiceID0Field;
            }
            set {
                this.dwServiceID0Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID1 {
            get {
                return this.dwServiceID1Field;
            }
            set {
                this.dwServiceID1Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID2 {
            get {
                return this.dwServiceID2Field;
            }
            set {
                this.dwServiceID2Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID3 {
            get {
                return this.dwServiceID3Field;
            }
            set {
                this.dwServiceID3Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust0 {
            get {
                return this.userTrust0Field;
            }
            set {
                this.userTrust0Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust1 {
            get {
                return this.userTrust1Field;
            }
            set {
                this.userTrust1Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust2 {
            get {
                return this.userTrust2Field;
            }
            set {
                this.userTrust2Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust3 {
            get {
                return this.userTrust3Field;
            }
            set {
                this.userTrust3Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId0 {
            get {
                return this.altTitleId0Field;
            }
            set {
                this.altTitleId0Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId1 {
            get {
                return this.altTitleId1Field;
            }
            set {
                this.altTitleId1Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId2 {
            get {
                return this.altTitleId2Field;
            }
            set {
                this.altTitleId2Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId3 {
            get {
                return this.altTitleId3Field;
            }
            set {
                this.altTitleId3Field = value;
            }
        }
        
        /// <remarks/>
        public byte key00 {
            get {
                return this.key00Field;
            }
            set {
                this.key00Field = value;
            }
        }
        
        /// <remarks/>
        public byte key01 {
            get {
                return this.key01Field;
            }
            set {
                this.key01Field = value;
            }
        }
        
        /// <remarks/>
        public byte key02 {
            get {
                return this.key02Field;
            }
            set {
                this.key02Field = value;
            }
        }
        
        /// <remarks/>
        public byte key03 {
            get {
                return this.key03Field;
            }
            set {
                this.key03Field = value;
            }
        }
        
        /// <remarks/>
        public byte key04 {
            get {
                return this.key04Field;
            }
            set {
                this.key04Field = value;
            }
        }
        
        /// <remarks/>
        public byte key05 {
            get {
                return this.key05Field;
            }
            set {
                this.key05Field = value;
            }
        }
        
        /// <remarks/>
        public byte key06 {
            get {
                return this.key06Field;
            }
            set {
                this.key06Field = value;
            }
        }
        
        /// <remarks/>
        public byte key07 {
            get {
                return this.key07Field;
            }
            set {
                this.key07Field = value;
            }
        }
        
        /// <remarks/>
        public byte key08 {
            get {
                return this.key08Field;
            }
            set {
                this.key08Field = value;
            }
        }
        
        /// <remarks/>
        public byte key09 {
            get {
                return this.key09Field;
            }
            set {
                this.key09Field = value;
            }
        }
        
        /// <remarks/>
        public byte key10 {
            get {
                return this.key10Field;
            }
            set {
                this.key10Field = value;
            }
        }
        
        /// <remarks/>
        public byte key11 {
            get {
                return this.key11Field;
            }
            set {
                this.key11Field = value;
            }
        }
        
        /// <remarks/>
        public byte key12 {
            get {
                return this.key12Field;
            }
            set {
                this.key12Field = value;
            }
        }
        
        /// <remarks/>
        public byte key13 {
            get {
                return this.key13Field;
            }
            set {
                this.key13Field = value;
            }
        }
        
        /// <remarks/>
        public byte key14 {
            get {
                return this.key14Field;
            }
            set {
                this.key14Field = value;
            }
        }
        
        /// <remarks/>
        public byte key15 {
            get {
                return this.key15Field;
            }
            set {
                this.key15Field = value;
            }
        }
        
        /// <remarks/>
        public byte UserExists {
            get {
                return this.userExistsField;
            }
            set {
                this.userExistsField = value;
            }
        }
        
        /// <remarks/>
        public ushort port {
            get {
                return this.portField;
            }
            set {
                this.portField = value;
            }
        }
        
        /// <remarks/>
        public ulong clientVersion {
            get {
                return this.clientVersionField;
            }
            set {
                this.clientVersionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public enum XOService {
        
        /// <remarks/>
        InvalidService,
        
        /// <remarks/>
        PresNotification,
        
        /// <remarks/>
        StringService,
        
        /// <remarks/>
        Auto_Update,
        
        /// <remarks/>
        Base_Subscription,
        
        /// <remarks/>
        User_Account,
        
        /// <remarks/>
        Matchmaking,
        
        /// <remarks/>
        Stats,
        
        /// <remarks/>
        Feedback,
        
        /// <remarks/>
        Billing_Offering,
        
        /// <remarks/>
        Lists,
        
        /// <remarks/>
        Tous,
        
        /// <remarks/>
        Signature_Server,
        
        /// <remarks/>
        Query,
        
        /// <remarks/>
        Name_Resolution,
        
        /// <remarks/>
        Storage,
        
        /// <remarks/>
        Arbitration,
        
        /// <remarks/>
        Cron,
        
        /// <remarks/>
        MessagingService,
        
        /// <remarks/>
        Teams,
        
        /// <remarks/>
        NatDetection,
        
        /// <remarks/>
        DRM,
        
        /// <remarks/>
        Massive,
        
        /// <remarks/>
        PCLocator,
        
        /// <remarks/>
        Crypto,
        
        /// <remarks/>
        liveinfo,
        
        /// <remarks/>
        MaxService,
        
        /// <remarks/>
        Catalog,
        
        /// <remarks/>
        WebBilling,
        
        /// <remarks/>
        WebAccounts,
        
        /// <remarks/>
        Cust,
        
        /// <remarks/>
        KDCSvc,
        
        /// <remarks/>
        ActiveAuthSg,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SendRequestCompletedEventHandler(object sender, SendRequestCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendRequestCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendRequestCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public byte[] response {
            get {
                this.RaiseExceptionIfNecessary();
                return ((byte[])(this.results[1]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\util\PresenceUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.lfm;
using live.protocol.Presence;
using live.server;

using UserMessage = live.protocol.Presence.UserMessage;

namespace live.common
{
    public static partial class Util
    {
        public static class Presence
        {
            private static Xbox360 GetLoggedOnClient(XblUser user)
            {
                Xbox360Client client = new Xbox360Client(user.Settings.CreatedOn);
                Xbox360 xbox360 = new Xbox360(client);
                xbox360.Live.Logon(user);
                return xbox360;
            }

            private static void CleanUpClient(Xbox360 xbox360)
            {
                while (xbox360.Client.LoggedOnUsers.Count > 0)
                {
                    xbox360.Live.Logout(xbox360.Client.LoggedOnUsers[0]);
                }
                xbox360.ShutdownConsole();
            }

            /// <summary>
            /// Makes 2 users friends.
            /// </summary>
            /// <param name="inviter">The user sending the Friends Invite.</param>
            /// <param name="invitee">The user accepting the Friends Invite.</param>
            public static void MakeFriends(XblUser inviter, XblUser invitee)
            {
                // Create the inviter and log it in
                Xbox360 inviterXbox360 = GetLoggedOnClient(inviter);

                // Create the invitee and log it in
                Xbox360 inviteeXbox360 = GetLoggedOnClient(invitee);

                // Send the invite
                inviterXbox360.Live.Friends.AddFriend(inviter, invitee);

                // Wait for it and accept it
                inviteeXbox360.Live.Friends.WaitForFriendStatusRequested(invitee, inviter);
                inviteeXbox360.Live.Friends.AcceptFriendRequest(invitee, inviter);

                // Log all out and shutdown the consoles
                CleanUpClient(inviterXbox360);
                CleanUpClient(inviteeXbox360);
            }

            /// <summary>
            /// Adds a recent player to a user's recent players list.
            /// </summary>
            /// <param name="user">The user who's recent players list will be updated.</param>
            /// <param name="recentPlayer">The user who will be added to the recent players list.</param>
            public static void AddRecentPlayer(XblUser user, XblUser recentPlayer)
            {
                Xbox360 xbox360 = GetLoggedOnClient(user);
                live.server.Presence.AddAffiliate(xbox360.Client, user, recentPlayer,
                    live.protocol.Presence.AffiliateFlags.CompletedGame);
                CleanUpClient(xbox360);
            }

            /// <summary>
            /// Sends a text message from one user to another.  Only the recipient's gamertag is required.
            /// This is ideal for sending messages to users who were not created with LiveLib (ex: sending
            /// a message to a user created via the dash).
            /// </summary>
            /// <param name="sender">The user sending the message.</param>
            /// <param name="recipientGamertag">The gamertag of the user receiving the message.</param>
            /// <param name="message">The text to be sent.</param>
            public static void SendMessage(XblUser sender, string recipientGamertag, string message)
            {
                Xbox360 xbox360 = GetLoggedOnClient(sender);
                XblUser recipient = live.server.Presence.FindUser(xbox360.Client, sender, recipientGamertag);
                SendMessageInternal(xbox360, sender, recipient, message);
            }

            /// <summary>
            /// Sends a text message from one user to another.
            /// </summary>
            /// <param name="sender">The user sending the message.</param>
            /// <param name="recipient">The gamertag of the user receiving the message.</param>
            /// <param name="message">The text to be sent.</param>
            public static void SendMessage(XblUser sender, XblUser recipient, string message)
            {
                Xbox360 xbox360 = GetLoggedOnClient(sender);
                SendMessageInternal(xbox360, sender, recipient, message);
            }

            private static void SendMessageInternal(Xbox360 xbox360, XblUser sender, XblUser recipient, 
                string message)
            {
                xbox360.Live.Messages.SendPersonalMessage(sender, recipient, message);
                CleanUpClient(xbox360);
            }

            /// <summary>
            /// Retrieves the messages that have been sent to a user.
            /// </summary>
            /// <param name="user">The user who's inbox will be checked.</param>
            /// <returns>The user's messages.</returns>
            public static List<UserMessage> ViewMessages(XblUser user)
            {
                Xbox360 xbox360 = GetLoggedOnClient(user);
                PNState pn = live.server.Presence.GetPresenceForRequest(xbox360.Client, user);
                UserMsgFolder msgFolder = new UserMsgFolder(pn);
                ushort numberOfMessages = msgFolder.Load2();

                List<UserMessage> messages = new List<UserMessage>();

                foreach (UserMessage msg in msgFolder.Inbox)
                {
                    if (msg.Type == XonPresNoti.MSG_TYPE_FRIEND_REQUEST)
                        continue;
                    uint hr = msg.GetDetails(pn);
                    if (!HResult.Succeeded(hr))
                        throw new Exception("Failed to load message details with HR=0x" + hr.ToString("x"));
                    messages.Add(msg);
                }
                CleanUpClient(xbox360);
                return messages;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\Web References\FakeSGProxyWebReference\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.1434.
// 
#pragma warning disable 1591

using live.common;

namespace live.FakeSGProxyWebReference {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="FakeSGProxySoap", Namespace="http://test.xbox.com/")]
    public partial class FakeSGProxy : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback LoadSlotOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddXboxOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveXboxOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeadXboxOperationCompleted;
        
        private System.Threading.SendOrPostCallback ClearXboxesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetTitleOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetAltTitlesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetKeyOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetEnableStateBatchingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetStateEndpointOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserCountOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadUserQValPacketOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetInaSGOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public FakeSGProxy() {
            this.Url = global::live.Properties.Settings.Default.LiveLib_FakeSGProxyWebReference1_FakeSGProxy;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event LoadSlotCompletedEventHandler LoadSlotCompleted;
        
        /// <remarks/>
        public event AddXboxCompletedEventHandler AddXboxCompleted;
        
        /// <remarks/>
        public event RemoveXboxCompletedEventHandler RemoveXboxCompleted;
        
        /// <remarks/>
        public event DeadXboxCompletedEventHandler DeadXboxCompleted;
        
        /// <remarks/>
        public event ClearXboxesCompletedEventHandler ClearXboxesCompleted;
        
        /// <remarks/>
        public event SetTitleCompletedEventHandler SetTitleCompleted;
        
        /// <remarks/>
        public event SetAltTitlesCompletedEventHandler SetAltTitlesCompleted;
        
        /// <remarks/>
        public event SetKeyCompletedEventHandler SetKeyCompleted;
        
        /// <remarks/>
        public event SetUserStateCompletedEventHandler SetUserStateCompleted;
        
        /// <remarks/>
        public event SetEnableStateBatchingCompletedEventHandler SetEnableStateBatchingCompleted;
        
        /// <remarks/>
        public event SetStateEndpointCompletedEventHandler SetStateEndpointCompleted;
        
        /// <remarks/>
        public event AddUserCompletedEventHandler AddUserCompleted;
        
        /// <remarks/>
        public event RemoveUserCompletedEventHandler RemoveUserCompleted;
        
        /// <remarks/>
        public event GetUserCountCompletedEventHandler GetUserCountCompleted;
        
        /// <remarks/>
        public event ReadUserQValPacketCompletedEventHandler ReadUserQValPacketCompleted;
        
        /// <remarks/>
        public event GetInaSGCompletedEventHandler GetInaSGCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/LoadSlot", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LoadSlot(ref CSGInfo sgInfo, ulong xboxId) {
            object[] results = this.Invoke("LoadSlot", new object[] {
                        sgInfo,
                        xboxId});
            sgInfo = ((CSGInfo)(results[0]));
        }
        
        /// <remarks/>
        public void LoadSlotAsync(CSGInfo sgInfo, ulong xboxId) {
            this.LoadSlotAsync(sgInfo, xboxId, null);
        }
        
        /// <remarks/>
        public void LoadSlotAsync(CSGInfo sgInfo, ulong xboxId, object userState) {
            if ((this.LoadSlotOperationCompleted == null)) {
                this.LoadSlotOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLoadSlotOperationCompleted);
            }
            this.InvokeAsync("LoadSlot", new object[] {
                        sgInfo,
                        xboxId}, this.LoadSlotOperationCompleted, userState);
        }
        
        private void OnLoadSlotOperationCompleted(object arg) {
            if ((this.LoadSlotCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.LoadSlotCompleted(this, new LoadSlotCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/AddXbox", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddXbox(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] key, ulong clientVersion, ClientType clientType, uint languageId) {
            this.Invoke("AddXbox", new object[] {
                        sgIp,
                        spi,
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion,
                        key,
                        clientVersion,
                        clientType,
                        languageId});
        }
        
        /// <remarks/>
        public void AddXboxAsync(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, ClientType clientType, uint languageId) {
            this.AddXboxAsync(sgIp, spi, xboxId, titleId, titleVer, titleRegion, key, clientVersion, clientType, languageId, null);
        }
        
        /// <remarks/>
        public void AddXboxAsync(uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, ClientType clientType, uint languageId, object userState) {
            if ((this.AddXboxOperationCompleted == null)) {
                this.AddXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddXboxOperationCompleted);
            }
            this.InvokeAsync("AddXbox", new object[] {
                        sgIp,
                        spi,
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion,
                        key,
                        clientVersion,
                        clientType,
                        languageId}, this.AddXboxOperationCompleted, userState);
        }
        
        private void OnAddXboxOperationCompleted(object arg) {
            if ((this.AddXboxCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/RemoveXbox", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveXbox(ulong xboxId) {
            this.Invoke("RemoveXbox", new object[] {
                        xboxId});
        }
        
        /// <remarks/>
        public void RemoveXboxAsync(ulong xboxId) {
            this.RemoveXboxAsync(xboxId, null);
        }
        
        /// <remarks/>
        public void RemoveXboxAsync(ulong xboxId, object userState) {
            if ((this.RemoveXboxOperationCompleted == null)) {
                this.RemoveXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveXboxOperationCompleted);
            }
            this.InvokeAsync("RemoveXbox", new object[] {
                        xboxId}, this.RemoveXboxOperationCompleted, userState);
        }
        
        private void OnRemoveXboxOperationCompleted(object arg) {
            if ((this.RemoveXboxCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/DeadXbox", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeadXbox(ulong xboxId) {
            this.Invoke("DeadXbox", new object[] {
                        xboxId});
        }
        
        /// <remarks/>
        public void DeadXboxAsync(ulong xboxId) {
            this.DeadXboxAsync(xboxId, null);
        }
        
        /// <remarks/>
        public void DeadXboxAsync(ulong xboxId, object userState) {
            if ((this.DeadXboxOperationCompleted == null)) {
                this.DeadXboxOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeadXboxOperationCompleted);
            }
            this.InvokeAsync("DeadXbox", new object[] {
                        xboxId}, this.DeadXboxOperationCompleted, userState);
        }
        
        private void OnDeadXboxOperationCompleted(object arg) {
            if ((this.DeadXboxCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeadXboxCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/ClearXboxes", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ClearXboxes() {
            this.Invoke("ClearXboxes", new object[0]);
        }
        
        /// <remarks/>
        public void ClearXboxesAsync() {
            this.ClearXboxesAsync(null);
        }
        
        /// <remarks/>
        public void ClearXboxesAsync(object userState) {
            if ((this.ClearXboxesOperationCompleted == null)) {
                this.ClearXboxesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnClearXboxesOperationCompleted);
            }
            this.InvokeAsync("ClearXboxes", new object[0], this.ClearXboxesOperationCompleted, userState);
        }
        
        private void OnClearXboxesOperationCompleted(object arg) {
            if ((this.ClearXboxesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ClearXboxesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetTitle", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetTitle(ulong xboxId, uint titleId, uint titleVer, uint titleRegion) {
            this.Invoke("SetTitle", new object[] {
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion});
        }
        
        /// <remarks/>
        public void SetTitleAsync(ulong xboxId, uint titleId, uint titleVer, uint titleRegion) {
            this.SetTitleAsync(xboxId, titleId, titleVer, titleRegion, null);
        }
        
        /// <remarks/>
        public void SetTitleAsync(ulong xboxId, uint titleId, uint titleVer, uint titleRegion, object userState) {
            if ((this.SetTitleOperationCompleted == null)) {
                this.SetTitleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetTitleOperationCompleted);
            }
            this.InvokeAsync("SetTitle", new object[] {
                        xboxId,
                        titleId,
                        titleVer,
                        titleRegion}, this.SetTitleOperationCompleted, userState);
        }
        
        private void OnSetTitleOperationCompleted(object arg) {
            if ((this.SetTitleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetTitleCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetAltTitles", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetAltTitles(ulong xboxId, uint[] altTitleIds) {
            this.Invoke("SetAltTitles", new object[] {
                        xboxId,
                        altTitleIds});
        }
        
        /// <remarks/>
        public void SetAltTitlesAsync(ulong xboxId, uint[] altTitleIds) {
            this.SetAltTitlesAsync(xboxId, altTitleIds, null);
        }
        
        /// <remarks/>
        public void SetAltTitlesAsync(ulong xboxId, uint[] altTitleIds, object userState) {
            if ((this.SetAltTitlesOperationCompleted == null)) {
                this.SetAltTitlesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetAltTitlesOperationCompleted);
            }
            this.InvokeAsync("SetAltTitles", new object[] {
                        xboxId,
                        altTitleIds}, this.SetAltTitlesOperationCompleted, userState);
        }
        
        private void OnSetAltTitlesOperationCompleted(object arg) {
            if ((this.SetAltTitlesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetAltTitlesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetKey", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetKey(ulong xboxId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] key) {
            this.Invoke("SetKey", new object[] {
                        xboxId,
                        key});
        }
        
        /// <remarks/>
        public void SetKeyAsync(ulong xboxId, byte[] key) {
            this.SetKeyAsync(xboxId, key, null);
        }
        
        /// <remarks/>
        public void SetKeyAsync(ulong xboxId, byte[] key, object userState) {
            if ((this.SetKeyOperationCompleted == null)) {
                this.SetKeyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetKeyOperationCompleted);
            }
            this.InvokeAsync("SetKey", new object[] {
                        xboxId,
                        key}, this.SetKeyOperationCompleted, userState);
        }
        
        private void OnSetKeyOperationCompleted(object arg) {
            if ((this.SetKeyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetKeyCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetUserState", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] titleData, ushort titleDataLen) {
            this.Invoke("SetUserState", new object[] {
                        xboxId,
                        userId,
                        matchSessionId,
                        state,
                        titleData,
                        titleDataLen});
        }
        
        /// <remarks/>
        public void SetUserStateAsync(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen) {
            this.SetUserStateAsync(xboxId, userId, matchSessionId, state, titleData, titleDataLen, null);
        }
        
        /// <remarks/>
        public void SetUserStateAsync(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen, object userState) {
            if ((this.SetUserStateOperationCompleted == null)) {
                this.SetUserStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserStateOperationCompleted);
            }
            this.InvokeAsync("SetUserState", new object[] {
                        xboxId,
                        userId,
                        matchSessionId,
                        state,
                        titleData,
                        titleDataLen}, this.SetUserStateOperationCompleted, userState);
        }
        
        private void OnSetUserStateOperationCompleted(object arg) {
            if ((this.SetUserStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserStateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetEnableStateBatching", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetEnableStateBatching(bool enable, uint intervalSeconds) {
            this.Invoke("SetEnableStateBatching", new object[] {
                        enable,
                        intervalSeconds});
        }
        
        /// <remarks/>
        public void SetEnableStateBatchingAsync(bool enable, uint intervalSeconds) {
            this.SetEnableStateBatchingAsync(enable, intervalSeconds, null);
        }
        
        /// <remarks/>
        public void SetEnableStateBatchingAsync(bool enable, uint intervalSeconds, object userState) {
            if ((this.SetEnableStateBatchingOperationCompleted == null)) {
                this.SetEnableStateBatchingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetEnableStateBatchingOperationCompleted);
            }
            this.InvokeAsync("SetEnableStateBatching", new object[] {
                        enable,
                        intervalSeconds}, this.SetEnableStateBatchingOperationCompleted, userState);
        }
        
        private void OnSetEnableStateBatchingOperationCompleted(object arg) {
            if ((this.SetEnableStateBatchingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetEnableStateBatchingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/SetStateEndpoint", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetStateEndpoint(string endpoint) {
            this.Invoke("SetStateEndpoint", new object[] {
                        endpoint});
        }
        
        /// <remarks/>
        public void SetStateEndpointAsync(string endpoint) {
            this.SetStateEndpointAsync(endpoint, null);
        }
        
        /// <remarks/>
        public void SetStateEndpointAsync(string endpoint, object userState) {
            if ((this.SetStateEndpointOperationCompleted == null)) {
                this.SetStateEndpointOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetStateEndpointOperationCompleted);
            }
            this.InvokeAsync("SetStateEndpoint", new object[] {
                        endpoint}, this.SetStateEndpointOperationCompleted, userState);
        }
        
        private void OnSetStateEndpointOperationCompleted(object arg) {
            if ((this.SetStateEndpointCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetStateEndpointCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/AddUser", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddUser(ulong xboxId, ulong userId, uint userFlags) {
            this.Invoke("AddUser", new object[] {
                        xboxId,
                        userId,
                        userFlags});
        }
        
        /// <remarks/>
        public void AddUserAsync(ulong xboxId, ulong userId, uint userFlags) {
            this.AddUserAsync(xboxId, userId, userFlags, null);
        }
        
        /// <remarks/>
        public void AddUserAsync(ulong xboxId, ulong userId, uint userFlags, object userState) {
            if ((this.AddUserOperationCompleted == null)) {
                this.AddUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddUserOperationCompleted);
            }
            this.InvokeAsync("AddUser", new object[] {
                        xboxId,
                        userId,
                        userFlags}, this.AddUserOperationCompleted, userState);
        }
        
        private void OnAddUserOperationCompleted(object arg) {
            if ((this.AddUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddUserCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/RemoveUser", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveUser(ulong xboxId, ulong userId) {
            this.Invoke("RemoveUser", new object[] {
                        xboxId,
                        userId});
        }
        
        /// <remarks/>
        public void RemoveUserAsync(ulong xboxId, ulong userId) {
            this.RemoveUserAsync(xboxId, userId, null);
        }
        
        /// <remarks/>
        public void RemoveUserAsync(ulong xboxId, ulong userId, object userState) {
            if ((this.RemoveUserOperationCompleted == null)) {
                this.RemoveUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveUserOperationCompleted);
            }
            this.InvokeAsync("RemoveUser", new object[] {
                        xboxId,
                        userId}, this.RemoveUserOperationCompleted, userState);
        }
        
        private void OnRemoveUserOperationCompleted(object arg) {
            if ((this.RemoveUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveUserCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/GetUserCount", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public byte GetUserCount(ulong xboxId) {
            object[] results = this.Invoke("GetUserCount", new object[] {
                        xboxId});
            return ((byte)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserCountAsync(ulong xboxId) {
            this.GetUserCountAsync(xboxId, null);
        }
        
        /// <remarks/>
        public void GetUserCountAsync(ulong xboxId, object userState) {
            if ((this.GetUserCountOperationCompleted == null)) {
                this.GetUserCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserCountOperationCompleted);
            }
            this.InvokeAsync("GetUserCount", new object[] {
                        xboxId}, this.GetUserCountOperationCompleted, userState);
        }
        
        private void OnGetUserCountOperationCompleted(object arg) {
            if ((this.GetUserCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserCountCompleted(this, new GetUserCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/ReadUserQValPacket", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool ReadUserQValPacket(ulong xboxId, ulong userId, out QValPacket packet) {
            object[] results = this.Invoke("ReadUserQValPacket", new object[] {
                        xboxId,
                        userId});
            packet = ((QValPacket)(results[1]));
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void ReadUserQValPacketAsync(ulong xboxId, ulong userId) {
            this.ReadUserQValPacketAsync(xboxId, userId, null);
        }
        
        /// <remarks/>
        public void ReadUserQValPacketAsync(ulong xboxId, ulong userId, object userState) {
            if ((this.ReadUserQValPacketOperationCompleted == null)) {
                this.ReadUserQValPacketOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadUserQValPacketOperationCompleted);
            }
            this.InvokeAsync("ReadUserQValPacket", new object[] {
                        xboxId,
                        userId}, this.ReadUserQValPacketOperationCompleted, userState);
        }
        
        private void OnReadUserQValPacketOperationCompleted(object arg) {
            if ((this.ReadUserQValPacketCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadUserQValPacketCompleted(this, new ReadUserQValPacketCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://test.xbox.com/GetInaSG", RequestNamespace="http://test.xbox.com/", ResponseNamespace="http://test.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint GetInaSG() {
            object[] results = this.Invoke("GetInaSG", new object[0]);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetInaSGAsync() {
            this.GetInaSGAsync(null);
        }
        
        /// <remarks/>
        public void GetInaSGAsync(object userState) {
            if ((this.GetInaSGOperationCompleted == null)) {
                this.GetInaSGOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetInaSGOperationCompleted);
            }
            this.InvokeAsync("GetInaSG", new object[0], this.GetInaSGOperationCompleted, userState);
        }
        
        private void OnGetInaSGOperationCompleted(object arg) {
            if ((this.GetInaSGCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetInaSGCompleted(this, new GetInaSGCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public partial class CSGInfo {
        
        private uint inaSgField;
        
        private uint spiSgField;
        
        private uint ipaIField;
        
        private ushort ipportIField;
        
        private long liNonceField;
        
        private ulong machinePuidField;
        
        private uint titleIdField;
        
        private uint titleVersionField;
        
        private uint titleRegionField;
        
        private uint consoleRegionField;
        
        private uint mediaIDField;
        
        private ushort languageIDField;
        
        private uint authDataFlagsField;
        
        private ushort wMajorVersionField;
        
        private ushort wMinorVersionField;
        
        private ushort wBuildNumberField;
        
        private ushort wQFENumberField;
        
        private ulong userPuid0Field;
        
        private ulong userPuid1Field;
        
        private ulong userPuid2Field;
        
        private ulong userPuid3Field;
        
        private uint userFlag0Field;
        
        private uint userFlag1Field;
        
        private uint userFlag2Field;
        
        private uint userFlag3Field;
        
        private ushort wNumPrivilegesField;
        
        private uint dwPrivileges4Field;
        
        private uint dwPrivileges5Field;
        
        private uint dwPrivileges6Field;
        
        private uint dwPrivileges7Field;
        
        public uint dwPrivileges5User0;
        public uint dwPrivileges6User0;
        public uint dwPrivileges7User0;
        public uint dwPrivileges5User1;
        public uint dwPrivileges6User1;
        public uint dwPrivileges7User1;
        public uint dwPrivileges5User2;
        public uint dwPrivileges6User2;
        public uint dwPrivileges7User2;
        public uint dwPrivileges5User3;
        public uint dwPrivileges6User3;
        public uint dwPrivileges7User3;
        
        private uint dwPrivileges0Field;
        
        private uint dwPrivileges1Field;
        
        private uint dwPrivileges2Field;
        
        private uint dwPrivileges3Field;

        private ushort wNumDwordServicesField;
        
        private uint dwServiceID0Field;
        
        private uint dwServiceID1Field;
        
        private uint dwServiceID2Field;
        
        private uint dwServiceID3Field;
        
        private float userTrust0Field;
        
        private float userTrust1Field;
        
        private float userTrust2Field;
        
        private float userTrust3Field;
        
        private uint altTitleId0Field;
        
        private uint altTitleId1Field;
        
        private uint altTitleId2Field;
        
        private uint altTitleId3Field;
        
        private byte key00Field;
        
        private byte key01Field;
        
        private byte key02Field;
        
        private byte key03Field;
        
        private byte key04Field;
        
        private byte key05Field;
        
        private byte key06Field;
        
        private byte key07Field;
        
        private byte key08Field;
        
        private byte key09Field;
        
        private byte key10Field;
        
        private byte key11Field;
        
        private byte key12Field;
        
        private byte key13Field;
        
        private byte key14Field;
        
        private byte key15Field;
        
        private byte userExistsField;
        
        private ushort portField;
        
        private ulong clientVersionField;
        
        /// <remarks/>
        public uint inaSg {
            get {
                return this.inaSgField;
            }
            set {
                this.inaSgField = value;
            }
        }
        
        /// <remarks/>
        public uint SpiSg {
            get {
                return this.spiSgField;
            }
            set {
                this.spiSgField = value;
            }
        }
        
        /// <remarks/>
        public uint ipaI {
            get {
                return this.ipaIField;
            }
            set {
                this.ipaIField = value;
            }
        }
        
        /// <remarks/>
        public ushort ipportI {
            get {
                return this.ipportIField;
            }
            set {
                this.ipportIField = value;
            }
        }
        
        /// <remarks/>
        public long liNonce {
            get {
                return this.liNonceField;
            }
            set {
                this.liNonceField = value;
            }
        }
        
        /// <remarks/>
        public ulong machinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public uint titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint titleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public uint titleRegion {
            get {
                return this.titleRegionField;
            }
            set {
                this.titleRegionField = value;
            }
        }
        
        /// <remarks/>
        public uint consoleRegion {
            get {
                return this.consoleRegionField;
            }
            set {
                this.consoleRegionField = value;
            }
        }
        
        /// <remarks/>
        public uint mediaID {
            get {
                return this.mediaIDField;
            }
            set {
                this.mediaIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort languageID {
            get {
                return this.languageIDField;
            }
            set {
                this.languageIDField = value;
            }
        }
        
        /// <remarks/>
        public uint authDataFlags {
            get {
                return this.authDataFlagsField;
            }
            set {
                this.authDataFlagsField = value;
            }
        }
        
        /// <remarks/>
        public ushort wMajorVersion {
            get {
                return this.wMajorVersionField;
            }
            set {
                this.wMajorVersionField = value;
            }
        }
        
        /// <remarks/>
        public ushort wMinorVersion {
            get {
                return this.wMinorVersionField;
            }
            set {
                this.wMinorVersionField = value;
            }
        }
        
        /// <remarks/>
        public ushort wBuildNumber {
            get {
                return this.wBuildNumberField;
            }
            set {
                this.wBuildNumberField = value;
            }
        }
        
        /// <remarks/>
        public ushort wQFENumber {
            get {
                return this.wQFENumberField;
            }
            set {
                this.wQFENumberField = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid0 {
            get {
                return this.userPuid0Field;
            }
            set {
                this.userPuid0Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid1 {
            get {
                return this.userPuid1Field;
            }
            set {
                this.userPuid1Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid2 {
            get {
                return this.userPuid2Field;
            }
            set {
                this.userPuid2Field = value;
            }
        }
        
        /// <remarks/>
        public ulong userPuid3 {
            get {
                return this.userPuid3Field;
            }
            set {
                this.userPuid3Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag0 {
            get {
                return this.userFlag0Field;
            }
            set {
                this.userFlag0Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag1 {
            get {
                return this.userFlag1Field;
            }
            set {
                this.userFlag1Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag2 {
            get {
                return this.userFlag2Field;
            }
            set {
                this.userFlag2Field = value;
            }
        }
        
        /// <remarks/>
        public uint userFlag3 {
            get {
                return this.userFlag3Field;
            }
            set {
                this.userFlag3Field = value;
            }
        }
        
        /// <remarks/>
        public ushort wNumPrivileges {
            get {
                return this.wNumPrivilegesField;
            }
            set {
                this.wNumPrivilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges0 {
            get {
                return this.dwPrivileges0Field;
            }
            set {
                this.dwPrivileges0Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges1 {
            get {
                return this.dwPrivileges1Field;
            }
            set {
                this.dwPrivileges1Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges2 {
            get {
                return this.dwPrivileges2Field;
            }
            set {
                this.dwPrivileges2Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges3 {
            get {
                return this.dwPrivileges3Field;
            }
            set {
                this.dwPrivileges3Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges4 {
            get {
                return this.dwPrivileges4Field;
            }
            set {
                this.dwPrivileges4Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges5 {
            get {
                return this.dwPrivileges5Field;
            }
            set {
                this.dwPrivileges5Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges6 {
            get {
                return this.dwPrivileges6Field;
            }
            set {
                this.dwPrivileges6Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwPrivileges7 {
            get {
                return this.dwPrivileges7Field;
            }
            set {
                this.dwPrivileges7Field = value;
            }
        }
        
        /// <remarks/>
        public ushort wNumDwordServices {
            get {
                return this.wNumDwordServicesField;
            }
            set {
                this.wNumDwordServicesField = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID0 {
            get {
                return this.dwServiceID0Field;
            }
            set {
                this.dwServiceID0Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID1 {
            get {
                return this.dwServiceID1Field;
            }
            set {
                this.dwServiceID1Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID2 {
            get {
                return this.dwServiceID2Field;
            }
            set {
                this.dwServiceID2Field = value;
            }
        }
        
        /// <remarks/>
        public uint dwServiceID3 {
            get {
                return this.dwServiceID3Field;
            }
            set {
                this.dwServiceID3Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust0 {
            get {
                return this.userTrust0Field;
            }
            set {
                this.userTrust0Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust1 {
            get {
                return this.userTrust1Field;
            }
            set {
                this.userTrust1Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust2 {
            get {
                return this.userTrust2Field;
            }
            set {
                this.userTrust2Field = value;
            }
        }
        
        /// <remarks/>
        public float userTrust3 {
            get {
                return this.userTrust3Field;
            }
            set {
                this.userTrust3Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId0 {
            get {
                return this.altTitleId0Field;
            }
            set {
                this.altTitleId0Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId1 {
            get {
                return this.altTitleId1Field;
            }
            set {
                this.altTitleId1Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId2 {
            get {
                return this.altTitleId2Field;
            }
            set {
                this.altTitleId2Field = value;
            }
        }
        
        /// <remarks/>
        public uint altTitleId3 {
            get {
                return this.altTitleId3Field;
            }
            set {
                this.altTitleId3Field = value;
            }
        }
        
        /// <remarks/>
        public byte key00 {
            get {
                return this.key00Field;
            }
            set {
                this.key00Field = value;
            }
        }
        
        /// <remarks/>
        public byte key01 {
            get {
                return this.key01Field;
            }
            set {
                this.key01Field = value;
            }
        }
        
        /// <remarks/>
        public byte key02 {
            get {
                return this.key02Field;
            }
            set {
                this.key02Field = value;
            }
        }
        
        /// <remarks/>
        public byte key03 {
            get {
                return this.key03Field;
            }
            set {
                this.key03Field = value;
            }
        }
        
        /// <remarks/>
        public byte key04 {
            get {
                return this.key04Field;
            }
            set {
                this.key04Field = value;
            }
        }
        
        /// <remarks/>
        public byte key05 {
            get {
                return this.key05Field;
            }
            set {
                this.key05Field = value;
            }
        }
        
        /// <remarks/>
        public byte key06 {
            get {
                return this.key06Field;
            }
            set {
                this.key06Field = value;
            }
        }
        
        /// <remarks/>
        public byte key07 {
            get {
                return this.key07Field;
            }
            set {
                this.key07Field = value;
            }
        }
        
        /// <remarks/>
        public byte key08 {
            get {
                return this.key08Field;
            }
            set {
                this.key08Field = value;
            }
        }
        
        /// <remarks/>
        public byte key09 {
            get {
                return this.key09Field;
            }
            set {
                this.key09Field = value;
            }
        }
        
        /// <remarks/>
        public byte key10 {
            get {
                return this.key10Field;
            }
            set {
                this.key10Field = value;
            }
        }
        
        /// <remarks/>
        public byte key11 {
            get {
                return this.key11Field;
            }
            set {
                this.key11Field = value;
            }
        }
        
        /// <remarks/>
        public byte key12 {
            get {
                return this.key12Field;
            }
            set {
                this.key12Field = value;
            }
        }
        
        /// <remarks/>
        public byte key13 {
            get {
                return this.key13Field;
            }
            set {
                this.key13Field = value;
            }
        }
        
        /// <remarks/>
        public byte key14 {
            get {
                return this.key14Field;
            }
            set {
                this.key14Field = value;
            }
        }
        
        /// <remarks/>
        public byte key15 {
            get {
                return this.key15Field;
            }
            set {
                this.key15Field = value;
            }
        }
        
        /// <remarks/>
        public byte UserExists {
            get {
                return this.userExistsField;
            }
            set {
                this.userExistsField = value;
            }
        }
        
        /// <remarks/>
        public ushort port {
            get {
                return this.portField;
            }
            set {
                this.portField = value;
            }
        }
        
        /// <remarks/>
        public ulong clientVersion {
            get {
                return this.clientVersionField;
            }
            set {
                this.clientVersionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public partial class QValPacket {
        
        private System.DateTime deliveryTimeField;
        
        private bool pushField;
        
        private uint[] dataField;
        
        /// <remarks/>
        public System.DateTime DeliveryTime {
            get {
                return this.deliveryTimeField;
            }
            set {
                this.deliveryTimeField = value;
            }
        }
        
        /// <remarks/>
        public bool Push {
            get {
                return this.pushField;
            }
            set {
                this.pushField = value;
            }
        }
        
        /// <remarks/>
        public uint[] Data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
    }
/*
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.1434")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://test.xbox.com/")]
    public enum ClientType {
        
        /// <remarks/>
        Xbox,
        
        /// <remarks/>
        Xenon,
        
        /// <remarks/>
        XenonBackCompat,
        
        /// <remarks/>
        PC,
    }
*/
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void LoadSlotCompletedEventHandler(object sender, LoadSlotCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LoadSlotCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal LoadSlotCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CSGInfo sgInfo {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CSGInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void AddXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void RemoveXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void DeadXboxCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void ClearXboxesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetTitleCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetAltTitlesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetKeyCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetUserStateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetEnableStateBatchingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void SetStateEndpointCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void AddUserCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void RemoveUserCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void GetUserCountCompletedEventHandler(object sender, GetUserCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserCountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public byte Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((byte)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void ReadUserQValPacketCompletedEventHandler(object sender, ReadUserQValPacketCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadUserQValPacketCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadUserQValPacketCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public QValPacket packet {
            get {
                this.RaiseExceptionIfNecessary();
                return ((QValPacket)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    public delegate void GetInaSGCompletedEventHandler(object sender, GetInaSGCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.1434")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetInaSGCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetInaSGCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\minrunner\MinRunner.cs ===
using System;

using live.client;
using live.common;
using live.server;
using live.unittests;
using live.unittests.samples;

namespace live.minrunner
{
    class MinRunner
    {
        public static XblUser LoadXblUserFromPassportLogin(string memberName, string password)
        {
            METHOD.ENTER();
            PassportInfo ppi = new PassportInfo();
            ppi.MemberName = memberName;
            ppi.Password = password;

            using (Xbox360Client client = new Xbox360Client())
            {
                PassportUtils.LoadExistingPassportAccount(client, ppi);
                ulong xuid;
                string gamertag = UACS.XeGetLinkedGamertag(client, ppi, out xuid);
                XblUser user = new XblUser(xuid, gamertag);
                XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Existing);
                user.Settings = settings;
                settings.PersonalInfo.CountryId = ppi.CountryId;
                settings.PersonalInfo.LanguageId = 1;
                client.UserLoggingOn(user);

                //Needed to get Parentcontrol group and actual User Tier
                WebClient webClient = new WebClient();
                webClient.TitleId = XOn.WEB_TITLE_ID;
                webClient.AddUser(user);
                UserWebInfo uwi = UACS.XeGetUserWebInfo(webClient, user);
                settings.UserType = uwi.Tier;

                PersonalInfo pi = UACS.XeGetAccountInfo(client, user.Puid);
                settings.PersonalInfo = pi;
                pi.Gamertag = user.Gamertag;
                settings.UserPassportInfo = ppi;
                settings.PersonalInfo.ParentalControlGroupId = uwi.ParentalControlGroupId;
                if (uwi.ParentalControlGroupId == 0)
                {
                    settings.OwnerPassportInfo = ppi.DeepClone();
                }

                METHOD.EXIT();
                return user;
            }
        }

        static void TestLoadXblUserFromPassportLogin()
        {
            XblUser user = SamplesTests.CreateLiveAccounts.CreateGamesForWindowsLiveAccount();

            XblUser userToo = Util.Accounts.LoadXblUserFromPassportLogin(user.Settings.UserPassportInfo.MemberName, user.Settings.UserPassportInfo.Password);

            if (user.Gamertag == userToo.Gamertag && user.Puid == userToo.Puid)
            {
                Console.WriteLine("TestLoadXblUserFromPassportLogin passed.");
            }
            else
            {
                Console.WriteLine("TestLoadXblUserFromPassportLogin failed.");
            }
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Executing: WGX_LoadXblUserFromPassportLogin");
            live.unittests.BugRegressionTests.WGX_LoadXblUserFromPassportLogin();

            //Console.WriteLine("Executing: RunBillingTests");
            //RunBillingTests();

            //Console.WriteLine("Executing: TestLoadXblUserFromPassportLogin");
            //TestLoadXblUserFromPassportLogin();

            //Console.WriteLine("Executing: SamplesTests.Parties.Create8UserPartyDemo");
            //SamplesTests.Parties.Create8UserPartyDemo();

            //Console.WriteLine("Executing: CreateLiveAccounts.CreateGamesForWindowsLiveAccount");
            //SamplesTests.CreateLiveAccounts.CreateGamesForWindowsLiveAccount();

/*
            Console.WriteLine("Executing: Avatars.RunSamples");
            Avatars.RunSamples();

            Console.WriteLine("Executing: CreateLiveAccounts.RunSamples");
            CreateLiveAccounts.RunSamples();

            Console.WriteLine("Executing: CreateRealUsers.RunSamples");
            CreateRealUsers.RunSamples();

            Console.WriteLine("Executing: Parties.RunSamples");
            Parties.RunSamples();
*/

/*
            Console.WriteLine("Executing: UtilTests.PresenceUtilTests.AddRecentPlayer");
            UtilTests.PresenceUtilTests.AddRecentPlayer();

            Console.WriteLine("Executing: UnitTestsProxy.GetAccountEx");
            UnitTestsProxy.GetAccountEx();
            Console.WriteLine("Executing: UnitTestsProxy.BanAccount");
            UnitTestsProxy.BanAccount();
            Console.WriteLine("Executing: UnitTestsProxy.VoiceBanAccount");
            UnitTestsProxy.VoiceBanAccount();

            Console.WriteLine("Executing: CreateLiveGoldAccountExample");
            live.unittests.AccountSamples.CreateLiveGoldAccountExample();
            Console.WriteLine("Executing: CreateZuneAccountExample");
            live.unittests.AccountSamples.CreateZuneAccountExample();
            Console.WriteLine("Executing: AddVisaExample");
            live.unittests.AccountSamples.AddVisaExample();
 */
            Console.WriteLine("Press any key to continue . . . ");
            Console.Read();
        }

        public static void RunBillingTests()
        {
            //ServerTests.DefaultClientType = live.common.ClientType.Panorama;

            Console.WriteLine("Executing: BillingTests.XeEnumerateGenres");
            ServerTests.BillingTests.XeEnumerateGenres();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveLib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("XBoxOnline")]
[assembly: AssemblyProduct("LiveLib")]
[assembly: AssemblyCopyright("Copyright © XBoxOnline 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9d2d7113-8b5d-40e7-b5e7-3530f5114935")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\BugRegressionTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.lfm;

using ServerTestFramework;

namespace live.unittests
{
    [TestGroup]
    public class BugRegressionTests : UnitTests
    {
        private const int MaxPlayers = 4;

        private static void AddFakePlayers(XblUser user, int numberPlayers)
        {
            METHOD.ENTER();
            if (numberPlayers > MaxPlayers)
            {
                throw new ArgumentOutOfRangeException(String.Format(System.Globalization.CultureInfo.CurrentCulture,
                    "Cannot have > {0} players", MaxPlayers.ToString(System.Globalization.CultureInfo.CurrentCulture)));
            }
            for (int i = 0; i < numberPlayers; i++)
            {
                XblUser player = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                Util.Presence.AddRecentPlayer(user, player);
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// WGX experienced a bug when attempting to create recent players using the (above) AddFakePlayers code.
        /// For n recent players, the # actually seen was consistently n-1 using TG2 (and not via TG1).
        /// </summary>
        [TestCase]
        public static void WGX_MissingFriend()
        {
            METHOD.ENTER();
            XblUser user = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Real, false);
            AddFakePlayers(user, MaxPlayers);
            Xbox360 xbox = new Xbox360(new Xbox360Client(user.Settings.CreatedOn));
            xbox.Live.Logon(user);
            live.protocol.Presence.AffiliateState affState = live.server.Presence.QueryAffiliates(xbox.Client, user);
            if (affState._CompletedGame.Count != MaxPlayers)
            {
                throw new Exception("WGX_MissingFriend: repro'd a 'fixed' bug");
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// WGX experienced a bug when attempting to create recent players using the (above) AddFakePlayers code.
        /// For n recent players, the # actually seen was consistently n-1 using TG2 (and not via TG1).
        /// </summary>
        [TestCase]
        public static void WGX_LoadXblUserFromPassportLogin()
        {
            METHOD.ENTER();

            Logging.WriteLine("Creating user");
            XblUser user1 = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Real, false);
            Logging.WriteLine("Loading user from Passport login");
            XblUser user2 = Util.Accounts.LoadXblUserFromPassportLogin(user1.Settings.UserPassportInfo.MemberName,
                user1.Settings.UserPassportInfo.Password);
            Logging.WriteLine("Comparing user instances");
            if (user1.Gamertag != user2.Gamertag || user1.Puid != user2.Puid)
            {
                throw new Exception("WGX_LoadXblUserFromPassportLogin: XblUserBases did not match");
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\FDTransactionTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.unittests
{
    internal class FDTransactionTests
    {
        public void Run()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\LFMTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.lfm;
using live.lfm.xbox360Internal;
using live.lfm.xbox360Internal.HUD;

using ServerTestFramework;

namespace live.unittests
{
    [TestGroup]
    internal class LFMTests : UnitTests
    {
        [TestCase]
        public static void MarketplaceScenario()
        {
            Xbox360 xbox360 = new Xbox360();
            using (xbox360)
            {
                //xbox360.CreateMachineAccount();
                XblUser user = xbox360.SignUp.CreateUser(new XblUserSettings(XblUserTier.Silver, PassportType.Real));
                UnitTests.WriteLine(user.ToString());
                xbox360.Live.Logon(user);

                xbox360.Marketplace.RedeemMSPointsCode(Offers.PointsOffers.PP4000,
                    Offers.GetPrepaidVoucherCode(Offers.PointsOffers.PP4000)).RedeemNow();

                // Browse some content
                xbox360.Marketplace.Browse();

                foreach (Genre genre in xbox360.Marketplace.Games.Genres.AvailableGenres)
                {
                    Logging.WriteLine("Genre == " + genre.GenreName);
                }

                Logging.WriteLine("Genre == " +
                    xbox360.Marketplace.Games.Genres.Genre[Genres.GENRE_ACTION].Details.GenreName);
                //xbox360.Marketplace.Games.Genres[Genres.GENRE_ACTION].Downloads

                GenresScene myGenres = xbox360.Marketplace.Games.Genres;
                GenreScene myGenre = myGenres.Genre[Genres.GENRE_ACTION];

                //live.lfm.xbox360Internal.TitleContentsScene myTitleContents = myGenre.Titles[0];
                TitleInfo titleInfo = myGenre.AvailableTitles[0];

                TitleContentsScene titleContentsScene = myGenre.SelectTitle(titleInfo);

                ContentItemPurchaseScene itemPurchaseScene =
                    titleContentsScene.SelectContentItem(titleContentsScene.AvailableContent[0]);

                itemPurchaseScene.ConfirmDownload();

                xbox360.Marketplace.AccountMgmt.DownloadHistory.SelectRandomItem().DownloadAgain();

                // In toto:
                xbox360.Marketplace.Games.Genres.RandomGenre.SelectRandomTitle().SelectRandomContentItem().ConfirmDownload();
                xbox360.Marketplace.AccountMgmt.DownloadHistory.SelectRandomItem().DownloadAgain();

                //xbox360.Marketplace.Games.Genres.Genre[Genres.GENRE_ACTION].SelectRandomTitle().

                //titleInfo = xbox360.Marketplace.Games.Genres.Genre[Genres.GENRE_ACTION].Titles[0];

                // xbox360.Marketplace.Games.Genres();
                // /xbos/XeEnumerateGenres.ashx

                // xbox360.Marketplace.Games.Genres().Action();
                // /xbos/XeEnumerateTitlesByFilter.ashx
                // For each item (and cache):
                //      /stfd/resolvename.ashx
                //      /stfd/readfile.ashx
                //  and:
                //      /xbos/XeGetTitleDetails.ashx

                // xbox360.Marketplace.Games.Genres().Action().ArcadeSessions;
                // Sometimes: /xbos/XeContentHistoryEnumerate.ashx
                // /xbos/XeContentEnumerate2.ashx
                // /xbos/XeContentUpdateAccessTimes.ashx
                // /stfd/resolvename.ashx
                // /stfd/readfile.ashx

                // xbox360.Marketplace.Games.Genres().Action().ArcadeSessions.ContentPackage1_50pts();
                // /xbos/XeGetTitleDetails.ashx
                // /xbos/XeContentDetails.ashx
                // /stfd/resolvename.ashx
                // /stfd/readfile.ashx

                // xbox360.Marketplace.Games.Genres().Action().ArcadeSessions.ContentPackage1_50pts().ConfirmDownload;
                // /xbos/XeOfferPurchase.ashx
                // /xbos/XeContentHistoryEnumerate.ashx
                // /xuacs/XeGetPointsBalance.ashx
                // /xbos/XeContentReferral.ashx
                // /where/out/there/GameContent
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\UnitTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;

using ServerTestFramework;

namespace live.unittests
{
    internal class ConsoleDestination : ServerTestFramework.Report.Destination
    {
        public void Log(uint level, string path, string message, string testName, DateTime date)
        {
            Console.WriteLine("STF: " + message);
        }
    }

    internal class TraceDestination : ServerTestFramework.Report.Destination
    {
        public virtual void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            Logging.WriteLine(message, "STF");
        }
    }

    [TestGroup]
    public class UnitTests : TestNode
    {
        static class UnitTestConfig
        {
            public static bool UseStfConfig = false;
        }

        public static void WriteLine(string message)
        {
            Logging.WriteLine(message, "UNITTEST");
        }

        public static void WriteLine(string format, params object[] args)
        {
            Logging.WriteLine(String.Format(format, args));
        }

        public override void OneTimeSetup()
        {
            // Setup output to Console
            //System.Diagnostics.Trace.Listeners.Add(new System.Diagnostics.TextWriterTraceListener(Console.Out));
            if (UnitTestConfig.UseStfConfig)
            {
                // Setup xonline.common
                System.Environment.SetEnvironmentVariable("XBL_CONFIG_SERVER",
                    ServerTestFramework.Global.CurrentEnvironment.NpdbIp);
                Global.RO.Debug("xonline.common.config.Config.SiteId = " + xonline.common.config.Config.SiteId);
                //ServerTestFramework.Global.RO.AddReportDestination(new ConsoleDestination());

                // Configure LiveLib to use STF
                live.common.Config.SetConfig(new STFConfig());

                Global.RO.Info("LiveLib Unit Tests configured by STF to use environment: " +
                    ServerTestFramework.Global.CurrentEnvironment.Environment);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\DataTests\DataTests.cs ===
using System;

using ServerTestFramework;

namespace live.unittests
{
    [TestGroup]
    internal partial class DataTests : UnitTests
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\DataTests\DataObjectTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.protocol;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    internal partial class DataTests
    {
        public static void Assert(bool condition, string format, params object[] list)
        {
            if (!condition)
            {
                throw new Exception(string.Format(format, list));
            }
        }

        [TestGroup]
        public class BillingInfoTests
        {
            [TestCase]
            public static void AddCreditCard()
            {
                string accountnum = "1234567890123456";
                string id = "Someid";
                BillingInfo bi = new BillingInfo();
                CreditCardInfo ci1 = new CreditCardInfo();
                CreditCardInfo ci2 = new CreditCardInfo();
                ci1.AccountNumber = accountnum;
                ci2.AccountNumber = accountnum.Substring(accountnum.Length - 4, 4);
                ci2.PaymentInstrumentId = id;
                bi.AddCreditCard(ci1.DeepClone());
                Assert(bi.CreditCards.Count == 1, "Expected CreditCards Count to be 1, is {0}", bi.CreditCards.Count);
                bi.AddCreditCard(ci2.DeepClone());
                Assert(bi.CreditCards.Count == 1, "Expected CreditCards Count after second add to be 1, is {0}", bi.CreditCards.Count);
                Assert(bi.CreditCards[0].AccountNumber == accountnum, "Expected the account numbers to be the same: [{0}] != e[{1}]", bi.CreditCards[0].AccountNumber, accountnum);
                Assert(bi.CreditCards[0].AccountNumber.Length > 4, " Expected Accountnumber to be longer then 4 digits");
                Assert(bi.CreditCards[0].PaymentInstrumentId == id, "Expected the Ids to be the same: [{0}] != e[{1}]", bi.CreditCards[0].PaymentInstrumentId, id);
                CreditCardInfo ci3 = new CreditCardInfo(ci1);
                ci3.AccountNumber = "someotheraccount";
                bi.AddCreditCard(ci3.DeepClone());
                Assert(bi.CreditCards.Count == 2, "Expected CreditCards Count to be 2, is {0}", bi.CreditCards.Count);
                bi.CreditCards.Clear();
                ci1.PaymentInstrumentId = id;
                ci2.PaymentInstrumentId = string.Empty;
                bi.AddCreditCard(ci1.DeepClone());
                bi.AddCreditCard(ci2.DeepClone());
                Assert(bi.CreditCards.Count == 1, "Expected CreditCards Count be 1, is {0}", bi.CreditCards.Count);
                Assert(bi.CreditCards[0].AccountNumber == accountnum, "Expected the account numbers to be the same: [{0}] != e[{1}]", bi.CreditCards[0].AccountNumber, accountnum);
                Assert(bi.CreditCards[0].AccountNumber.Length > 4, " Expected Accountnumber to be longer then 4 digits");
                Assert(bi.CreditCards[0].PaymentInstrumentId == id, "Expected the Ids to be the same: [{0}] != e[{1}]", bi.CreditCards[0].PaymentInstrumentId, id);
                ci2.AccountHolderName = "john";
                bi.AddCreditCard(ci2.DeepClone());
                Assert(bi.CreditCards.Count == 2, "Expected CreditCards Count to be 2, is {0}", bi.CreditCards.Count);
                ci1.PaymentInstrumentId = "Someotherid";
                bi.AddCreditCard(ci1.DeepClone());
                Assert(bi.CreditCards.Count == 3, "Expected CreditCards Count to be 3, is {0}", bi.CreditCards.Count);
                //CCV Equivlence and Sync test
                ci1 = new CreditCardInfo();
                ci1.AccountNumber = accountnum;
                ci2 = ci1.DeepClone();
                ci2.CcvNumber = "123";
                bi.CreditCards.Clear();
                bi.AddCreditCard(ci1.DeepClone());
                bi.AddCreditCard(ci2.DeepClone());
                Assert(bi.CreditCards.Count == 1, "CCV: Expected CreditCards Count be 1, is {0}", bi.CreditCards.Count);
                Assert(bi.CreditCards[0].CcvNumber == ci2.CcvNumber, "CCV: Expected the ccv numbers to be the same: [{0}] != e[{1}]", bi.CreditCards[0].CcvNumber == ci2.CcvNumber);
            }

            [TestCase]
            public static void AddDirectDebit()
            {
                string accountnum = "1234567890123456";
                string id = "Someid";
                BillingInfo bi = new BillingInfo();
                DirectDebitInfo ci1 = new DirectDebitInfo();
                DirectDebitInfo ci2 = new DirectDebitInfo();
                ci1.AccountNumber = accountnum;
                ci2.AccountNumber = accountnum.Substring(accountnum.Length - 4, 4);
                ci2.PaymentInstrumentId = id;
                bi.AddDirectDebit(ci1.DeepClone());
                Assert(bi.DirectDebits.Count == 1, "Expected DirectDebits Count to be 1, is {0}", bi.DirectDebits.Count);
                bi.AddDirectDebit(ci2.DeepClone());
                Assert(bi.DirectDebits.Count == 1, "Expected DirectDebits Count after second add to be 1, is {0}", bi.DirectDebits.Count);
                Assert(bi.DirectDebits[0].AccountNumber == accountnum, "Expected the account numbers to be the same: [{0}] != e[{1}]", bi.DirectDebits[0].AccountNumber, accountnum);
                Assert(bi.DirectDebits[0].AccountNumber.Length > 4, " Expected Accountnumber to be longer then 4 digits");
                Assert(bi.DirectDebits[0].PaymentInstrumentId == id, "Expected the Ids to be the same: [{0}] != e[{1}]", bi.DirectDebits[0].PaymentInstrumentId, id);
                DirectDebitInfo ci3 = new DirectDebitInfo(ci1);
                ci3.AccountNumber = "someotheraccount";
                bi.AddDirectDebit(ci3.DeepClone());
                Assert(bi.DirectDebits.Count == 2, "Expected DirectDebits Count to be 2, is {0}", bi.DirectDebits.Count);
                bi.DirectDebits.Clear();
                ci1.PaymentInstrumentId = id;
                ci2.PaymentInstrumentId = string.Empty;
                bi.AddDirectDebit(ci1.DeepClone());
                bi.AddDirectDebit(ci2.DeepClone());
                Assert(bi.DirectDebits.Count == 1, "Expected DirectDebits Count be 1, is {0}", bi.DirectDebits.Count);
                Assert(bi.DirectDebits[0].AccountNumber == accountnum, "Expected the account numbers to be the same: [{0}] != e[{1}]", bi.DirectDebits[0].AccountNumber, accountnum);
                Assert(bi.DirectDebits[0].AccountNumber.Length > 4, " Expected Accountnumber to be longer then 4 digits");
                Assert(bi.DirectDebits[0].PaymentInstrumentId == id, "Expected the Ids to be the same: [{0}] != e[{1}]", bi.DirectDebits[0].PaymentInstrumentId, id);
                ci2.AccountHolderName = "john";
                bi.AddDirectDebit(ci2.DeepClone());
                Assert(bi.DirectDebits.Count == 2, "Expected DirectDebits Count to be 2, is {0}", bi.DirectDebits.Count);
                ci1.PaymentInstrumentId = "Someotherid";
                bi.AddDirectDebit(ci1.DeepClone());
                Assert(bi.DirectDebits.Count == 3, "Expected DirectDebits Count to be 3, is {0}", bi.DirectDebits.Count);


            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("unittests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("XBoxOnline")]
[assembly: AssemblyProduct("unittests")]
[assembly: AssemblyCopyright("Copyright © XBoxOnline 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d31ed09d-18fb-4414-9692-906c5d26066c")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\CreateRealUsers.cs ===
using System;

using ServerTestFramework;

using live.lfm;
using live.common;

namespace live.unittests.samples
{
    public partial class SamplesTests
    {
        /// <summary>
        /// This is the closest thing we have to a "real" users since these all use a simulation of the Xbox 360's calls
        /// into Live to create the user.  I believe a few steps are missing (ex: Storage enums), but you at least
        /// get a synced settings and logged into Presence before you're logged back out.
        /// </summary>
        [TestGroup]
        public class CreateRealUsers
        {
            public static void RunSamples()
            {
                Logging.WriteLine("Running CreateXbox360GoldUserWithUtil", "SAMPLES");
                CreateXbox360GoldUserWithUtil();
                Logging.WriteLine("Running CreateXbox360GoldUserWithLFM", "SAMPLES");
                CreateXbox360GoldUserWithLFM();
                Logging.WriteLine("Running CreateXbox360SilverFakeUser", "SAMPLES");
                CreateXbox360SilverFakeUser();
            }

            /// <summary>
            /// The Util layer is a set of helper classes designed to simplify housekeeping.  In this case, Util.Accounts
            /// is used to obviate the need to deal with any client objects.
            /// </summary>
            /// <returns>An Xbox Live real Gold user with working Passport</returns>
            public static XblUser CreateXbox360GoldUserWithUtil()
            {
                XblUser user = Util.Accounts.CreateLiveAccount(new XblUserSettings(XblUserTier.Gold, PassportType.Real));
                DbgDumpUserDetails(user);
                return user;
            }

            [TestCase]
            public static void CreateXbox360GoldUserWithUtilTest()
            {
                CreateXbox360GoldUserWithUtil();
            }

            /// <summary>
            /// The LFM is an abstraction of the Xbox 360 based on a particular version of the Dash for ease of navigation.
            /// Using the LFM implies you'd like to do more with a user than just "get a user".  The LFM makes it easier to
            /// sync additional profile settings, join a Matchmaking session, etc.
            /// </summary>
            /// <returns>An Xbox Live real Gold user with working Passport</returns>
            public static XblUser CreateXbox360GoldUserWithLFM()
            {
                Xbox360 xbox360 = new Xbox360();
                using (xbox360)
                {
                    // CreateUser() defaults to Gold subscription and a real Passport
                    XblUser user = xbox360.SignUp.CreateUser();
                    DbgDumpUserDetails(user);
                    xbox360.ShutdownConsole();
                    return user;
                }
            }

            [TestCase]
            public static void CreateXbox360GoldUserWithLFMTest()
            {
                CreateXbox360GoldUserWithLFM();
            }

            /// <summary>
            /// This sample demonstrates creating a Silver user with a fake Passport.  Silver entails reduced privileges
            /// (i.e. multiplayer matchmaking and Marketplace content).  A fake Passport is convenient for speedier
            /// user creation, however this user will not be able to purchase in the Marketplace, cannot be used with
            /// any UACS or Cust API calls requiring a passport, and is not recoverable to a console.
            /// </summary>
            /// <returns>An Xbox Live fake Silver user with a fake Passport</returns>
            public static XblUser CreateXbox360SilverFakeUser()
            {
                Xbox360 xbox360 = new Xbox360();
                using (xbox360)
                {
                    XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);
                    XblUser user = xbox360.SignUp.CreateUser(settings);
                    DbgDumpUserDetails(user);
                    xbox360.ShutdownConsole();
                    return user;
                }
            }

            [TestCase]
            public static void CreateXbox360SilverFakeUserTest()
            {
                CreateXbox360SilverFakeUser();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\CreateLiveAccounts.cs ===
using System;

using ServerTestFramework;

using live.client;
using live.common;
using live.lfm;
using live.server;

namespace live.unittests.samples
{
    public partial class SamplesTests
    {
        /// <summary>
        /// These samples do nothing more than create a Live account.  No login, profile sync, etc. are performed.
        /// </summary>
        [TestGroup]
        public class CreateLiveAccounts
        {
            public static void RunSamples()
            {
                Logging.WriteLine("Running CreateCustom360LiveAccount", "SAMPLES");
                CreateCustom360LiveAccount();
                Logging.WriteLine("Running CreateXbox360SilverLiveAccount", "SAMPLES");
                CreateXbox360SilverLiveAccount();
                Logging.WriteLine("Running CreateGamesForWindowsLiveAccount", "SAMPLES");
                CreateGamesForWindowsLiveAccount();
                Logging.WriteLine("Running CreateXbox1LiveAccount", "SAMPLES");
                CreateXbox1LiveAccount();
            }

            /// <summary>
            /// Generic create live account.  Works for Xbox 1 and 360.
            /// </summary>
            public static XblUser CreateLiveAccount(IClient client, XblUserTier userType, PassportType passportType)
            {
                XblUserSettings settings = new XblUserSettings(userType, passportType);
                XblUser user;

                PassportUtils.CreatePassportAccounts(client, settings, true);

                if (userType == XblUserTier.Xbox1)
                {
                    settings.BillingInfo.AddCreditCard(
                        Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo));
                    user = UACS.createowneracct((XboxClient)client, settings);
                }
                else
                {
                    // Xbox360 or Games for Windows Live client
                    uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
                    if (hr != 0)
                    {
                        throw new Exception("Failed to create user; hr = " + hr);
                    }
                    if (client is Xbox360Client)
                    {
                        ((Xbox360Client)client).UserLoggingOn(user);
                    }
                }

                DbgDumpUserDetails(user);
                return user;
            }

            public static XblUser CreateCustom360LiveAccount()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
                    PassportUtils.CreatePassportAccounts(client, settings, true);

                    XblUser user;
                    uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
                    if (hr != 0)
                    {
                        throw new Exception("Failed to create user; hr = " + hr);
                    }
                    DbgDumpUserDetails(user);
                    client.Shutdown();
                    return user;
                }
            }

            [TestCase]
            public static void CreateCustom360LiveAccountTest()
            {
                CreateCustom360LiveAccount();
            }

            /// <summary>
            /// This sample demonstrates creating a Silver user with a fake Passport.  Silver entails reduced privileges
            /// (i.e. multiplayer matchmaking and Marketplace content).  A fake Passport is convenient for speedier
            /// user creation, however this user will not be able to purchase in the Marketplace, cannot be used with
            /// any UACS or Cust API calls requiring a passport, and is not recoverable to a console.
            /// </summary>
            /// <returns>An Xbox Live Silver user with a fake Passport</returns>
            public static XblUser CreateXbox360SilverLiveAccount()
            {
                Xbox360 xbox360 = new Xbox360();
                using (xbox360)
                {
                    XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);
                    XblUser user = xbox360.SignUp.CreateUser(settings);
                    DbgDumpUserDetails(user);
                    xbox360.ShutdownConsole();
                    return user;
                }
            }

            [TestCase]
            public static void CreateXbox360SilverLiveAccountTest()
            {
                CreateXbox360SilverLiveAccount();
            }

            public static XblUser CreateGamesForWindowsLiveAccount()
            {
                GfWLClient client = new GfWLClient();
                return CreateLiveAccount(client, XblUserTier.Gold, PassportType.Real);
            }

            [TestCase]
            public static void CreateGamesForWindowsLiveAccountTest()
            {
                CreateGamesForWindowsLiveAccount();
            }

            public static XblUser CreateXbox1LiveAccount()
            {
                XboxClient client = new XboxClient();
                XblUserSettings settings = new XblUserSettings(XblUserTier.Xbox1, PassportType.Real);
                settings.BillingInfo.AddCreditCard(
                    Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo));
                settings.BillingInfo.BillingToken = "1111111111111111111111111";
                //client.ClientType = ClientType.Xbox;
                XblUser user = UACS.createowneracct(client, settings);
                DbgDumpUserDetails(user);
                return user;
            }

            [TestCase]
            public static void CreateXbox1LiveAccountTest()
            {
                CreateXbox1LiveAccount();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\AccountsUtil.cs ===
using System;

using live.common;

using ServerTestFramework;

namespace live.unittests.samples
{
    public partial class SamplesTests
    {
        [TestGroup]
        public class AccountsUtil
        {
            public static void RunSamples()
            {
                CreateLiveGoldAccountExample();
                CreateZuneAccountExample();
                AddVisaExample();
            }

            [TestCase]
            public static void CreateLiveGoldAccountExample()
            {
                XblUser user = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Real, false);
                Global.RO.Info("Created user: " + user.Gamertag + " (0x" + user.Puid.ToString("X") + ")");
            }

            [TestCase]
            public static void CreateZuneAccountExample()
            {
                XblUser user = Util.Accounts.CreateZuneAccount(XblUserTier.Silver, PassportType.Real,
                    Offers.MusicNetOffers.MonthlyPP);
                Global.RO.Info("Created user: " + user.Gamertag + " (0x" + user.Puid.ToString("X") + ")");
            }

            [TestCase]
            public static void AddVisaExample()
            {
                XblUser user = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                Util.Accounts.AddVisaPaymentInstrument(user);
                Global.RO.Info("Created user: " + user.Gamertag + " (0x" + user.Puid.ToString("X") + ")");
            }

            [TestCase]
            public static void LoadExistingUser()
            {
                // Create a user to work with
                XblUser user = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);

                XblUser reuser = Util.Accounts.LoadXblUserFromPassportLogin(user.Settings.OwnerPassportInfo.MemberName,
                    user.Settings.OwnerPassportInfo.Password);

                if (user.Puid != user.Puid)
                {
                    throw new Exception("user.Puid != user.Puid");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\Avatars.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using ServerTestFramework;

using live.common;
using live.lfm;
using live.protocol;

namespace live.unittests.samples
{
    public partial class SamplesTests
    {
        [TestGroup]
        public class Avatars
        {
            public static void RunSamples()
            {
                CreateAvatar();
            }

            /// <summary>
            /// You can use this value to blank out a gamer pic during testing
            /// </summary>
            private const string NoPicture = "000000000000000000000000";

            private static string GetNormalPersonPicStoragePath(XblUser user)
            {
                return "//pics/u:" + user.Puid.ToString("X8") + "/FFFE0700/gamerpic.a";
            }

            private static string GetAvatarPersonPicStoragePath(XblUser user)
            {
                //BUGBUG:  Need to update this once I know the correct path format
                return "//pics/u:" + user.Puid.ToString("X8") + "/FFFE0700/gamerpic.a";
            }

            public static void SyncAvatarToProfile(Xbox360 xbox360, byte[] guids1, byte[] guids2, string bigHeadshotPath)
            {
                if (xbox360 == null)
                {
                    throw new ArgumentNullException("client");
                }
                if (guids1 == null)
                {
                    throw new ArgumentNullException("guids1");
                }
                List<UserSetting> userSettings = new List<UserSetting>(3);
                userSettings.Add(new UserSetting(xbox360.ActiveUser.Puid, XOn.XSOURCE_DEFAULT,
                    ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, guids1));

                if (guids2 != null)
                {
                    userSettings.Add(new UserSetting(xbox360.ActiveUser.Puid, XOn.XSOURCE_DEFAULT,
                        ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_2, guids2));
                }

                if (bigHeadshotPath != null)
                {
                    userSettings.Add(new UserSetting(xbox360.ActiveUser.Puid, XOn.XSOURCE_NO_VALUE,
                        ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,
                        UnicodeEncoding.Unicode.GetBytes(bigHeadshotPath)));
                }

                xbox360.Live.Profile.SyncSettings(userSettings.ToArray(), XOn.XENON_DASH_TITLE_ID, DateTime.UtcNow);
            }

            private static byte[] GetBytesFromFile(string filename)
            {
                FileStream file = new FileStream(filename, FileMode.Open);
                BinaryReader br = new BinaryReader(file);
                byte[] bytes = br.ReadBytes((int)file.Length);
                br.Close();
                return bytes;
            }

            public static void AddDefaultAvatar(Xbox360 xbox360)
            {
                byte[] avatarPicData = GetBytesFromFile("avatardata.ava");
                SyncAvatarToProfile(xbox360, avatarPicData, null, null);

                byte[] body = GetBytesFromFile("avatar-body.png");
                byte[] pic_l = GetBytesFromFile("avatarpic-l.png");
                byte[] pic_s = GetBytesFromFile("avatarpic-s.png");
                //UploadAvatarDataToStorage(xbox360, body, pic_l, pic_s);
            }

            public static void DbgCaptureAvatarProfileData(Xbox360 xbox360, string filename)
            {
                Xbox360 watcher = new Xbox360();
                using (watcher)
                {
                    watcher.SignUp.CreateUser();

                    ulong[] friends = new ulong[] { xbox360.ActiveUser.Puid };
                    uint[] settingsIds = new uint[] { ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1 };

                    ReadSettingsResponse resp = watcher.Live.Profile.ReadSettings(friends, XOn.XENON_DASH_TITLE_ID, settingsIds);
                    if (resp.SettingsLen != 0)
                    {
                        foreach (UserSetting setting in resp.Settings)
                        {
                            if (setting.SettingId == ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1)
                            {
                                FileStream file = new FileStream(filename, FileMode.OpenOrCreate);
                                BinaryWriter writer = new BinaryWriter(file);
                                writer.Write(setting.Value);
                                writer.Close();
                            }
                        }
                    }
                }
            }

            public static void StorageTest(Xbox360 xbox360)
            {
                ReqEnumerateFiles enumReq = new ReqEnumerateFiles();
                enumReq._accessToken = new ReadFileToken();
                enumReq._accessToken._flags = 0;
                enumReq._accessToken._operation = (ushort)Operation.FileEnumerate;
                enumReq._accessToken._pathName = "//avatar/u:" + xbox360.ActiveUser.Puid.ToString("X") + "/avatar-body.png";
                enumReq._accessToken._pathNameSize = (ushort)enumReq._accessToken._pathName.Length;
                enumReq._accessToken._serviceId = (uint)XOService.Storage;
                enumReq._accessToken._signature = null;
                enumReq._accessToken._signatureSize = 0;
                enumReq._accessToken._tokenExpirationDate = (long)System.DateTime.UtcNow.AddYears(1).ToFileTimeUtc();
                enumReq._accessToken._userPuid = xbox360.ActiveUser.Puid;
                enumReq._accessToken._version = AccessToken.accessTokenVersion;
                enumReq._accessToken._xboxPuid = xbox360.Client.MachinePuid;
                enumReq._ifModifiedSinceDate = 0;
                enumReq._resultsEnd = 100;
                enumReq._resultsStart = 0;
                enumReq._teamTickets = null;
                //enumReq._titleId = xbox360.Client.TitleId;
                enumReq._titleId = 0x584D07D1;
                enumReq._titleVersion = 0;
                //enumReq._titleVersion = 0x201CAB00;
                enumReq._userCountryId = (byte)xbox360.ActiveUser.Settings.PersonalInfo.CountryId;

                //enumReq.SchemaVersion = live.protocol.WireData.MakeSchemaVersion(4, 0);

                xbox360.Client.TitleId = 0x584D07D1;    // Avatar Creater title ID
                RepEnumerateFilesResponse enumResp = new RepEnumerateFilesResponse();
                xbox360.Client.SendRequest(xbox360.ActiveUser, XOService.Storage, enumReq.GetXRL(), HttpMethod.Post, null, enumReq, enumResp);
                Logging.WriteLine("count == " + enumResp.resultsLen);

                EnumFileRequest commonReq = new EnumFileRequest(
                    xbox360.Client, xbox360.ActiveUser, "//avatar/u:" + xbox360.ActiveUser.Puid.ToString("X") + "/avatar-body.png");
                live.server.Storage.EnumFile(xbox360.Client, xbox360.ActiveUser, commonReq);

                xbox360.Client.TitleId = XOn.XENON_DASH_TITLE_ID;
                commonReq = new EnumFileRequest(
                    xbox360.Client, xbox360.ActiveUser, "//title/t:FFFE07D1/*");
                live.server.Storage.EnumFile(xbox360.Client, xbox360.ActiveUser, commonReq);
            }

            [TestCase]
            public static void CreateAvatar()
            {
                Xbox360 xbox360;
                LoadUserLoggedIn("chromedheat11@xboxtest.com", "supersecret", out xbox360);
                //CaptureAvatarProfileData(xbox360, "chromedheat11-avatardata.ava");

                StorageTest(xbox360);

                // Prepare the Avatar data to upload to profile
                string avatarPicNum = RandomEx.GlobalRandGen.Next(9999).ToString("X4");
                string avatarPicData = "FFFE0854" + "0001" + avatarPicNum + "0001" + avatarPicNum + "\0";

                // Avatar Info 1 (default boy)
                // 0x63E80044	0xFFFE07D1	0x00000000BF000000BF80000000100000031D0003C1C8F109A19CB2E00008000003310003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026E0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF1F120BFFE58995FF92B2CAFF1F120BFF000000FF1F120BFFBCAE89FFBCAE890000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401DA0003C1C8F109A19CB2E0000400000000000000000000000000000000000800600001C1C8F109A19CB2E0000800000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000800600001C1C8F109A19CB2E0000800000000000000000000000000000000000401DA0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
                // Avatar Info 1 (default girl)
                // 0x63E80044	0xFFFE07D1	0x00000000BF0000003F0000000010000003210003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E0000000000000000000000000000000000000200002C60003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF0D0D0DFF5C3B2CFF82501DFF0D0D0DFFFFFFFFFF0D0D0DFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000000401EA0003C1C8F109A19CB2E0000400000000000000000000000000000000000800600001C1C8F109A19CB2E0000800000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000800600001C1C8F109A19CB2E0000800000000000000000000000000000000000401EA0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
                // Avatar Info 1 (balding guy, default clothes)
                // 0x63E80044	0xFFFE07D1	0x000000003F8000003F80000000100000031D0003C1C8F109A19CB2E000080000032E0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BE0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE6BC8EFF906636FFCF8562FFCECECCFF906636FFC08950FF906636FFECB6BEFFECB6BE0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004025B0003C1C8F109A19CB2E0000400000000000000000000000000000000000800600001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E00010000000000000000000000000000000000020002C0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800600001C1C8F109A19CB2E00008000000000000000000000000000000000004025B0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

                // Sync guids and profile pic to Profile
                SyncAvatarToProfile(xbox360, UnicodeEncoding.Unicode.GetBytes(avatarPicData), null, null);

                // Sync big and small headshot pics and bodyshit pic to Storage
                //TODO:  Need 3 PNGs and storage paths
            }
        }
    }
}

// Picture Key
// 0x4064000F	0xFFFE07D1	0x6600660066006500300037006400310030003000300032003000300030003800300030003000310030003000300038000000

// Personal Picture
// 0x40640010	0xFFFE07D1	0x6600660066006500300037006400310030003000300032003000300030003900300030003000310030003000300039000000

// User Name ("Michael")
// 0x41040040	0xFFFE07D1	0x4D00690063006800610065006C000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\Parties.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;

using live.common;
using live.client;
using live.lfm;
using live.protocol;
using live.protocol.Presence;

using ArrayEx = live.common.ArrayEx;
using XNADDR = live.protocol.Presence.XNADDR;
using WireInfoAttribute = live.protocol.WireInfoAttribute;

namespace live.unittests.samples
{
    public partial class SamplesTests
    {
        [TestGroup]
        public class Parties
        {
            public static void RunSamples()
            {
                Create4UserPartyDemo();
                Create8UserPartyDemo();
                Create8UserParty();
            }

            //public const int MAX_USERS_IN_A_PARTY = 8;

            private static void DbgCustomDemo()
            {
                Xbox360 jh7340Xbox;
                LoadUserLoggedIn("jh7340@xboxtest.com", "supersecret", out jh7340Xbox);

                Xbox360 ChromedHeat12Xbox;
                LoadUserLoggedIn("ChromedHeat12@xboxtest.com", "supersecret", out ChromedHeat12Xbox);

                Party party = new Party(jh7340Xbox.Client, jh7340Xbox.ActiveUser, PartyFlags.XPARTY_PROFILE_FLAG_NAT_OPEN);

                party.AddGuest(ChromedHeat12Xbox.Client, ChromedHeat12Xbox.ActiveUser, PartyFlags.XPARTY_PROFILE_FLAG_NAT_OPEN);

                party.SyncAllPartyMembersSettings();

                ChromedHeat12Xbox.ShutdownConsole();
                jh7340Xbox.ShutdownConsole();
            }

            private static void DbgInspectProfile(Xbox360 xbox360)
            {
                Xbox360 watcher = new Xbox360();
                using (watcher)
                {
                    watcher.SignUp.CreateUser();

                    ulong[] friends = new ulong[] { xbox360.ActiveUser.Puid };
                    uint[] settingsIds = new uint[] {
                        ProfileDefs.XPROFILE_GAMERCARD_MOTTO,
                        ProfileDefs.XPROFILE_GAMERCARD_ZONE,
                        ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY,
                        ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,
                        ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1,
                        ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_2 };
                    ReadSettingsResponse resp = watcher.Live.Profile.ReadSettings(friends, XOn.XENON_DASH_TITLE_ID, settingsIds);
                    if (resp.SettingsLen != 0)
                    {
                        foreach (UserSetting setting in resp.Settings)
                        {
                            WriteLine("setting.SettingId: {0}", setting.SettingId);
                        }
                    }
                }
            }

            /// <summary>
            /// Creates a party.
            /// </summary>
            /// <param name="host">Host of the party</param>
            /// <param name="guests">Guests of the party</param>
            /// <returns>Party instance representing the whole party</returns>
            public static Party CreateParty(Xbox360 host, params Xbox360[] guests)
            {
                // HOST
                // 1. Create a party by syncing Profile: DONE
                Party party = new Party(host.Client, host.ActiveUser, PartyFlags.XPARTY_PROFILE_FLAG_NAT_OPEN);

                // Everyone joins the party
                for (int i = 0; i < guests.Length; i++)
                {
                    // CLIENT
                    // 2. Wait for party invite:  SKIPPED

                    // HOST
                    // 3. Send party invite (XONLINE_MSG_TYPE_PARTY_CHAT_INVITE):  SKIPPED
                    // 4. Wait for client peer-to-peer connection: SKIPPED

                    // CLIENT
                    // 5. Receive party invite: SKIPPED
                    // 6. Initiate peer-to-peer connection: SKIPPED
                    // 7. Sync profile to reflect joining the party: DEFERRED
                    party.AddGuest(guests[i].Client, guests[i].ActiveUser, PartyFlags.XPARTY_PROFILE_FLAG_NAT_OPEN);

                    // HOST
                    // 8. Update profile to include joining user's info: DEFERRED
                }
                // 7 & 8. (cont) Sync all the settings (including the host's latest) in one fell swoop
                party.SyncAllPartyMembersSettings();

                return party;
            }

            /// <summary>
            /// Creates a party with the provided user info as host.  Also creates the necessary number of users to
            /// fill out the party to the user provided limit.
            /// </summary>
            /// <param name="ppMemberName">Host's Passport Member Name</param>
            /// <param name="ppPassword">Host's Passport Password</param>
            /// <param name="numMembers">Total number of users in the party</param>
            /// <param name="host">Host's Xbox360</param>
            /// <param name="guests">Guests' Xbox360s</param>
            /// <returns>Party instance representing the whole party</returns>
            public static Party AutoCreatePartyWithExistingUser(string ppMemberName, string ppPassword, uint numMembers, 
                out Xbox360 host, out List<Xbox360> guests)
            {
                // Load the host
                LoadUserLoggedIn(ppMemberName, ppPassword, out host);
                return AutoCreatePartyWithExistingUser(host, numMembers, out guests);
            }

            /// <summary>
            /// Creates a party with the provided Xbox360's active user as host.  Also creates the necessary number of
            /// users to fill out the party to the user provided limit.
            /// </summary>
            /// <param name="host">Host's Xbox360</param>
            /// <param name="numMembers">Total number of users in the party</param>
            /// <param name="guests">Guests' Xbox360s</param>
            /// <returns>Party instance representing the whole party</returns>
            public static Party AutoCreatePartyWithExistingUser(Xbox360 host, uint numMembers, out List<Xbox360> guests)
            {
                if (numMembers < 1)
                {
                    throw new ArgumentOutOfRangeException("numMembers", numMembers, "Cannot have less than 1 member (the host)");
                }
                if (numMembers > Party.MaxUsers)
                {
                    throw new ArgumentOutOfRangeException("numMembers", numMembers, "Cannot have more guests than " + Party.MaxGuests);
                }

                // Create users and sign them in
                guests = new List<Xbox360>((int)numMembers - 1);
                for (int i = 0; i < numMembers - 1; i++)
                {
                    Xbox360 xbox = new Xbox360();
                    xbox.SignUp.CreateUser();
                    Avatars.AddDefaultAvatar(xbox);
                    guests.Add(xbox);
                }

                return CreateParty(host, guests.ToArray());
            }

            /// <summary>
            /// 
            /// </summary>
            /// <param name="numMembers">Total number of users in the party</param>
            /// <param name="host">Host's Xbox360</param>
            /// <param name="guests">Guests' Xbox360s</param>
            /// <returns></returns>
            public static Party AutoCreateParty(uint numMembers, out Xbox360 host, out List<Xbox360> guests)
            {
                host = new Xbox360();
                host.SignUp.CreateUser();
                Avatars.AddDefaultAvatar(host);

                return AutoCreatePartyWithExistingUser(host, numMembers, out guests);
            }

            public static void Create4UserPartyDemo()
            {
                Xbox360 host;
                List<Xbox360> guests;
                AutoCreatePartyWithExistingUser("ChromedHeat12@xboxtest.com", "supersecret", 4, out host, out guests);

                // Shutdown Xboxes
                host.Dispose();
                guests.ForEach(delegate(Xbox360 xbox360) { xbox360.Dispose(); });
            }

            public static void Create8UserPartyDemo()
            {
                Xbox360 host;
                List<Xbox360> guests;
                AutoCreatePartyWithExistingUser("ChromedHeat12@xboxtest.com", "supersecret", 8, out host, out guests);

                // Shutdown Xboxes
                host.Dispose();
                guests.ForEach(delegate(Xbox360 xbox360) { xbox360.Dispose(); });
            }

            /// <summary>
            /// Creates an 8 user party.  Users are not friends and are on their own individual Xboxes.
            /// </summary>
            [TestCase]
            public static void Create8UserParty()
            {
                Xbox360 host;
                List<Xbox360> guests;
                AutoCreateParty(8, out host, out guests);

                // Do crazy stuff

                // Leave party
                //???  Unsure if we're supposed to clear out the Party user setting for each user

                // Shutdown Xboxes
                host.Dispose();
                guests.ForEach(delegate(Xbox360 xbox360) { xbox360.Dispose(); });
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\Samples\SamplesBase.cs ===
using System;
using System.Diagnostics;

using ServerTestFramework;

using live.common;
using live.lfm;
using ArrayEx = live.common.ArrayEx;

namespace live.unittests.samples
{
    [TestGroup]
    public partial class SamplesTests : UnitTests
    {
        public static void RunSamples()
        {
            WriteLine("Executing CreateLiveAccounts.RunSamples");
            CreateLiveAccounts.RunSamples();
            WriteLine("Executing CreateRealUsers.RunSamples");
            CreateRealUsers.RunSamples();
            WriteLine("Executing AccountsUtil.RunSamples");
            AccountsUtil.RunSamples();
            WriteLine("Executing Avatars.RunSamples");
            Avatars.RunSamples();
            WriteLine("Executing Parties.RunSamples");
            Parties.RunSamples();
        }

        public static void DbgDumpUserDetails(XblUser user)
        {
            Debug.WriteLine("Puid: 0x" + user.Puid.ToString("X"));
            Debug.WriteLine("GamerTag: " + user.Gamertag);
            Debug.WriteLine("Key: " + ArrayEx.ToString(user.Settings.CreatedOn.Key));
            Debug.WriteLine("Passport Member Name: " + user.Settings.UserPassportInfo.MemberName);
            Debug.WriteLine("Passport Password: " + user.Settings.UserPassportInfo.Password);
        }

        public static void LoadUserLoggedIn(string ppmn, string pppw, out Xbox360 xbox360)
        {
            // Load the host
            XblUser user = Util.Accounts.LoadXblUserFromPassportLogin(ppmn, pppw);
            user.Settings.UserPassportInfo.PassportType = PassportType.Existing;
            user.Settings.OwnerPassportInfo.PassportType = PassportType.Existing;
            // recovered accounts don't have any 'CreatedOn' information, so we need to fake this
            xbox360 = new Xbox360();
            ClientSettings clientSettings = new ClientSettings();
            clientSettings.Key = xbox360.Client.Key;
            clientSettings.MachinePuid = xbox360.Client.MachinePuid;
            clientSettings.OfflineXuid = xbox360.Client.OfflineXuid;
            clientSettings.Principal = xbox360.Client.Principal;
            clientSettings.TitleId = xbox360.Client.TitleId;
            user.Settings.CreatedOn = clientSettings;
            xbox360.Live.Logon(user);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\UACSTests.cs ===
using System;

using live.client;
using live.common;
using live.protocol;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    public partial class ServerTests
    {
        [TestGroup]
        public class UacsTests
        {
            public static void HealthCheck()
            {
            }

            //
            //  ARGO
            //

            public static void ArgoAuthenticateAccount()
            {
            }

            public static void ArgoGetAccountStatus()
            {
            }

            public static void ArgoTestCreateAccount()
            {
            }

            public static void ArgoSignInpublic()
            {
            }

            //
            //  XBOX 360
            //

            private static UInt32 PublicExponent;
            private static byte[] Modulus;
            private static byte[] Digest;
            private static string LoginTokenRequest;
            private static PassportInfo ppInfo = null;

            [TestCase]
            public static void XeCreateLiveAccount()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                }
            }

            [TestCase]
            public static void XeCreateWholesaleAccount()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    Randomizer.SetCountry(CountryId.CN);
                    PassportInfo ppi = new PassportInfo();
                    ppi.PassportType = PassportType.Real;
                    ppi.CountryId = CountryId.CN;
                    PassportUtils.CreateRealPassportAccount(client, ppi);

                    XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
                    settings.PersonalInfo = Randomizer.Persons.RegularUserInfo;
                    settings.PersonalInfo.Gamertag = "CT " + RandomEx.GlobalRandGen.GenerateRandomString(13).Substring(3).Trim();
                    settings.BillingInfo.OfferId = ServerTestFramework.LiveService.Billing.Offers.GetBaseOfferId(ServerTestFramework.LiveService.Billing.Offers.BaseOffers.GoldBobo);
                    settings.BillingInfo.WholesaleInfo = new WholesaleInfo();
                    settings.BillingInfo.WholesaleInfo.AccountHolderName = settings.PersonalInfo.FirstName + " " + settings.PersonalInfo.LastName;
                    settings.BillingInfo.WholesaleInfo.EncryptedPassword = string.Empty;
                    settings.BillingInfo.WholesaleInfo.ExternalReferenceId = Randomizer.CreditCards.CardNumber(CreditCardType.Visa);
                    settings.BillingInfo.WholesaleInfo.Partner = "CHINATELCOM Wireline";
                    settings.BillingInfo.WholesaleInfo.PartnerId = 54;
                    settings.UserPassportInfo = ppi;
                    settings.OwnerPassportInfo = ppi.DeepClone();
                    XblUser user;
                    UACS.XeCreateWholesaleAccount(client, settings, out user);

                }

            }

            public static void XeCreateXboxComAccount()
            {
            }

            [TestCase]
            public static void XeAddPaymentInstrument()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    CreditCardInfo visa = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa,
                        user.Settings.PersonalInfo);

                    UACS.XeAddPaymentInstrument(client, user, visa);
                    //TODO: Additional verification
                }
            }

            [TestCase]
            public static void XeGetPaymentInstruments()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    string[] billings;

                    CreditCardInfo visa1 = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa,
                        user.Settings.PersonalInfo);
                    CreditCardInfo cca1 = visa1.DeepClone();
                    UACS.XeAddPaymentInstrument(client, user, cca1);

                    CreditCardInfo visa2 = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa,
                        user.Settings.PersonalInfo);
                    CreditCardInfo cca2 = visa2.DeepClone();
                    UACS.XeAddPaymentInstrument(client, user, cca2);

                    billings = UACS.XeGetPaymentInstruments(client, user, 2);
                    if (!visa1.AccountNumber.EndsWith(user.Settings.BillingInfo.CreditCards[0].AccountNumber))
                    {
                        throw new Exception("Origional Account number does not end with what was returned");
                    }
                    if (!visa2.AccountNumber.EndsWith(user.Settings.BillingInfo.CreditCards[1].AccountNumber))
                    {
                        throw new Exception("Origional Account number does not end with what was returned");
                    }
                }
            }

            [TestCase]
            public static void XeRemovePaymentInstrument()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {

                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    // Generate a Visa credit card and add it to the user's account
                    CreditCardInfo creditCard = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa,
                        user.Settings.PersonalInfo);
                    UACS.XeAddPaymentInstrument(client, user, creditCard);

                    UACS.XeRemovePaymentInstrument(client, user, creditCard.PaymentInstrumentId);
                    string[] ids = UACS.XeGetPaymentInstruments(client, user, 1);
                    if (ids.GetLength(0) != 0)
                    {
                        throw new Exception("ids.GetLength(0) != 0");
                    }
                }
            }

            [TestCase]
            public static void XeUpdatePaymentInstrument()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    // Generate a Visa credit card and add it to the user's account
                    CreditCardInfo creditCard = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa,
                        user.Settings.PersonalInfo);
                    UACS.XeAddPaymentInstrument(client, user, creditCard);
                    creditCard.ExpirationDate = DateTime.UtcNow.AddYears(4);
                    UACS.XeUpdatePaymentInstrument(client, user, creditCard);
                    //TODO: Additional verification
                }
           }

            public static void XeChangeSubscriptionPaymentInstrument()
            {
            }

            [TestCase]
            public static void XeGetUserInfo()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    int age;
                    PersonalInfo info = UACS.XeGetUserInfo(client, user.Puid, out age);
                    // These 5 values are not returned by XeGetAccountInfo
                    info.Gamertag = user.Settings.PersonalInfo.Gamertag;
                    info.ParentalControlGroupId = user.Settings.PersonalInfo.ParentalControlGroupId;
                    info.OwnerPuid = user.Settings.PersonalInfo.OwnerPuid;
                    info.PhoneInfo = user.Settings.PersonalInfo.PhoneInfo;
                    info.BirthDate = user.Settings.PersonalInfo.BirthDate;
                    if (info != user.Settings.PersonalInfo)
                    {
                        throw new Exception("info != user.Settings.PersonalInfo");
                    }
                }
            }

            [TestCase]
            public static void NextXeGetUserInfo()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    int age;

                    PersonalInfo info = live.server.next.UACS.XeGetUserInfo(client, user.Puid, out age);
                    // These 5 values are not returned by XeGetAccountInfo
                    info.Gamertag = user.Settings.PersonalInfo.Gamertag;
                    info.ParentalControlGroupId = user.Settings.PersonalInfo.ParentalControlGroupId;
                    info.OwnerPuid = user.Settings.PersonalInfo.OwnerPuid;
                    info.PhoneInfo = user.Settings.PersonalInfo.PhoneInfo;
                    info.BirthDate = user.Settings.PersonalInfo.BirthDate;
                    if (info != user.Settings.PersonalInfo)
                    {
                        throw new Exception("info != user.Settings.PersonalInfo");
                    }
                }
            }

            [TestCase]
            public static void XeLinkXbox1Account()
            {
                XboxClient client = new XboxClient();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Xbox1, PassportType.Real);
                UACS.XeLinkXbox1Account(client, user);
            }

            [TestCase]
            public static void XePassportGetUserData()
            {
                live.common.PassportInfo pi = new live.common.PassportInfo();
                using (Xbox360Client client = new Xbox360Client())
                {
                    pi.PassportType = PassportType.Real;
                    pi.CountryId = live.common.CountryId.JP;
                    pi.BirthDate = new DateTime(1974, 6, 9).Date;
                    
                    pi.SessionToken = UACS.XePassportCreate(client, pi);

                    PassportPersonalInfo ppi = UACS.XePassportGetUserData(client, pi.SessionToken);
                    if (pi.BirthDate != ppi.Birthdate)
                    {
                        throw new Exception(String.Format("Birthdate Mismatch. Sent: {0}   Recieved: {1}", pi.BirthDate, ppi.Birthdate));
                    }
                    if (pi.CountryId != ppi.CountryId) 
                    {
                        throw new Exception(String.Format("CountryId Mismatch. Sent: {0}   Recieved: {1}", pi.CountryId, ppi.CountryId));
                    }
                    
                }

            }

            [TestCase]
            public static void XePassportGetEncryptedProxyParameters()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {

                    UACS.XePassportGetEncryptedProxyParameters(client, out PublicExponent,
                        out Modulus, out Digest, out LoginTokenRequest);
                }
            }

            [TestCase]
            public static void XePassportCreate()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {

                    ppInfo = new PassportInfo();
                    PassportUtils.CreateRealPassportAccount(client, ppInfo);
                }
            }

            [TestCase]
            public static void XePassportLogin()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {

                    if (ppInfo == null)
                    {
                        // Create a global Passport to work with
                        XePassportCreate();
                    }

                    // Attempt to login with it
                    UACS.XePassportLogin(client, ppInfo);
                }
            }

            public static void XePassportChangePassword()
            {
            }

            public static void XePassportGetSecretQuestions()
            {
            }

            public static void XePassportGetMemberName()
            {
            }

            public static void XePassportGetFriendMemberName()
            {
            }

            public static void XePassportGetBuddyGamertag()
            {
            }

            public static void XeABCHGetContactlistGamertags()
            {
            }

            public static void XeUpsGetProfile()
            {
            }

            public static void XeUpsUpdateProfile()
            {
            }

            [TestCase]
            public static void XeGetPointsBalance()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    uint points = UACS.XeGetPointsBalance(client, user);
                    if (points != 0)
                    {
                        throw new Exception("points != 0");
                    }
                }
            }

            [TestCase]
            public static void XeUpdateParentalControls()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    Privileges grant = new Privileges(true);
                    grant[Privilege.PurchaseContent] = false;
                    Privileges restrict = Privileges.Invert(grant);
                    UACS.XeUpdateParentalControls(client, user, grant, restrict, "stftest");
                }
            }

            [TestCase]
            public static void XeRecoverAccount()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    Recovered rec = UACS.XeRecoverAccount(client, user.Settings.UserPassportInfo.SessionToken);
                    if (rec.UserPuid != user.Puid)
                    {
                        throw new Exception("rec.UserPuid != user.Puid");
                    }
                }
            }

            [TestCase]
            public static void XeSetAccountInfo()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    PersonalInfo pi = new PersonalInfo();
                    pi.FirstName = "Matthew";
                    UACS.XeSetAccountInfo(client, user, pi);
                    //TODO: Additional verification
                }
            }

            [TestCase]
            public static void XeGetLinkedGamertag()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    ulong uid;
                    string gamertag;
                    gamertag = UACS.XeGetLinkedGamertag(client, user.Settings.UserPassportInfo, out uid);
                    if (uid != user.Puid)
                    {
                        throw new Exception("uid != user.Puid");
                    }
                    if (gamertag != user.Gamertag)
                    {
                        throw new Exception("gamertag != user.Gamertag");
                    }
                }
            }

            public static void XeMigrateXbox1User()
            {
            }

            [TestCase]
            public static void XeGetAccountInfo()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    PersonalInfo info = UACS.XeGetAccountInfo(client, user.Puid);
                    // These 3 values are not returned by XeGetAccountInfo
                    info.Gamertag = user.Settings.PersonalInfo.Gamertag;
                    info.ParentalControlGroupId = user.Settings.PersonalInfo.ParentalControlGroupId;
                    info.OwnerPuid = user.Settings.PersonalInfo.OwnerPuid;
                    if (info != user.Settings.PersonalInfo)
                    {
                        throw new Exception("info != user.Settings.PersonalInfo");
                    }
                }
            }

            public static void XeGetAccountInfoFromPassport()
            {
            }

            [TestCase]
            public static void XeGetUserSubscriptionDetails()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    /*
                    SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
                    filter.QueryForCurrent = true;

                    EnumeratedSubscriptions response = Billing.XeSubscriptionEnumerate(client, user, filter);
                    if (response.Infos.Count == 0)
                    {
                        throw new Exception("SubscriptionEnumerate returned 0 subscriptions");
                    }
                    */

                    UserSubscriptionDetails info = UACS.XeGetUserSubscriptionDetails(client, user, 0xfffe07d180000011);

                    if (info == null)
                    {
                        throw new Exception("Info is null!");
                    }
                }
            }

            [TestCase]
            public static void XeGetUserType()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    XboxUserType type = UACS.XeGetUserType(client, user);
                    if (type != XboxUserType.XenonUser)
                    {
                        throw new Exception(string.Format("type != XboxUserType.XenonUser it is {0}", type.ToString()));
                    }
                }
            }

            public static void XeMigrateXboxComUser()
            {
            }

            [TestCase]
            public static void XeGetUserWebInfo()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    client.TitleId = XOn.WEB_TITLE_ID;

                    UserWebInfo info = UACS.XeGetUserWebInfo(client, user);
                    if (info.Tier != XblUserTier.Silver)
                    {
                        throw new Exception(string.Format("tier != XblUserTier.Silver, it is {0}", info.Tier.ToString()));
                    }
                }
            }

            [TestCase]
            public static void XeUpdateXboxComActivity()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    client.TitleId = XOn.WEB_TITLE_ID;

                    UACS.XeUpdateXboxComActivity(client, user);
                }
            }

            public static void XeReserveGamertag()
            {
            }

            public static void XeVerifyParentCreditCard()
            {
            }

            [TestCase]
            public static void XeTroubleshootAccount()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    AccountIssues issues = UACS.XeTroubleshootAccount(client, user);
                    if (issues.Violations != AccountViolations.None)
                    {
                        throw new Exception(string.Format("Violations found! {0}", issues.Violations.ToString()));
                    }
                }
            }

            public static void XeAcknowledgeDowngrade()
            {
            }

            public static void XeVerifyBillingInfo()
            {
            }


            //
            //  XBOX 1
            //

            public static void reservename()
            {
            }

            [TestCase]
            public static void createowneracct()
            {
                XboxClient client = new XboxClient();
                XblUserSettings settings = new XblUserSettings(XblUserTier.Xbox1, PassportType.Existing);
                settings.BillingInfo.AddCreditCard(
                    Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo));
                XblUser xbox1User = UACS.createowneracct(client, settings);
                Global.RO.Info("createowneracct(): xbox 1 user created;  gamertag: " + xbox1User.Gamertag +
                    "; puid: 0x" + xbox1User.Puid.ToString("X"));
            }

            public static void getpaymentinfo()
            {
            }

            public static void setpaymentinfo()
            {
            }

            public static void setusersettings()
            {
            }

            public static void setusersettings2()
            {
            }

            public static void setuserpin()
            {
            }

            public static void verifybillingpin()
            {
            }

            public static void verifyvoucher()
            {
            }

            public static void restoreaccount()
            {
            }

            public static void changegamertag()
            {
            }

            public static void setuseraccountstatus()
            {
            }

            public static void accepttou()
            {
            }

            public static void AcceptTermsOfService()
            {
            }

            public static void troubleshootaccount()
            {
            }

            public static void clearsubscriptions()
            {
            }

            public static void DisableSubscription()
            {
            }

            public static void getpostalcode()
            {
            }

            public static void linkwebaccount()
            {
            }

            public static void webgetusersettings()
            {
            }

            public static void enumerateeligible()
            {
            }

            public static void getsubscriptionstatus()
            {
            }

            public static void renewsubscription()
            {
            }

            public static void verifyvouchergetoffer()
            {
            }

            [TestCase]
            public static void GetPointsBalance()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                    ZuneClient zune = new ZuneClient();
                    PointsBalanceStatus status;
                    uint points = live.server.next.UACS.GetPointsBalance(zune, user, out status);
                    if (points != 0)
                    {
                        throw new Exception("points != 0");
                    }
                    if (status != PointsBalanceStatus.Active)
                    {
                        throw new Exception("status != PointsBalanceStatus.Active");

                    }
                }
            }

            [TestCase]
            public static void XePassportGetPuidFromMemberName() 
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    client.UserLoggingOff(user);
                    ulong puid = live.server.next.UACS.XePassportGetPuidFromMemberName(client, user.Settings.UserPassportInfo.MemberName);
                    client.Shutdown();
                    if (puid != user.Settings.UserPassportInfo.PassportPuid)
                    {
                        throw new Exception("puid != user.Settings.UserPassportInfo.PassportPuid");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\ServerTests.cs ===
using System;
using System.IO;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

using live.client;
using live.common;
using live.protocol;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    [TestGroup]
    public partial class ServerTests : UnitTests
    {
        public static ClientType DefaultClientType = ClientType.Xenon;

        private static IClient GetDefaultClient()
        {
            switch (DefaultClientType)
            {
                case ClientType.Xenon:
                    return new Xbox360Client();
                case ClientType.Panorama:
                    return new GfWLClient();
                default:
                    throw new Exception("Unsupported client type: " + DefaultClientType);
            }
        }

        private static Xbox360Client GetXbox360Client()
        {
            return new Xbox360Client();
        }

        private static WebClient GetWebClient()
        {
            return new WebClient();
        }

        private static XblUser CreateUser(IClient client, XblUserTier userType, PassportType passportType)
        {
            XblUserSettings settings = new XblUserSettings(userType, passportType);
            XblUser user;

            PassportUtils.CreatePassportAccounts(client, settings, true);

            if (userType == XblUserTier.Xbox1)
            {
                settings.BillingInfo.AddCreditCard(
                    Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo));
                user = UACS.createowneracct((XboxClient)client, settings);
                Global.RO.Info("createowneracct(): xbox 1 user created;  gamertag: " + user.Gamertag +
                    "; puid: 0x" + user.Puid.ToString("X"));
            }
            else
            {
                uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
                if (hr != 0)
                {
                    throw new Exception("Failed to create user; hr = " + hr);
                }
                ((Xbox360Client)client).UserLoggingOn(user);
            }

            return user;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\StorageTests.cs ===
using System;

using live.client;
using live.common;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    public partial class ServerTests
    {
        [TestGroup]
        public partial class StorageTests
        {
            public static void LogTestRunning(string testName)
            {
                Logging.WriteLine("Running: " + testName, "UNITTEST");
                Logging.IncIndent();
                WriteFile();
                Logging.DecIndent();
            }

            public static void RunAllTests()
            {
                LogTestRunning("WriteFile");
                WriteFile();
                LogTestRunning("EnumFile");
                EnumFile();
                LogTestRunning("ReadFile");
                ReadFile();
                LogTestRunning("RemoveFile");
                RemoveFile();
            }

            [TestCase]
            public static void WriteFile()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                byte[] data = new byte[128];
                RandomEx.GlobalRandGen.NextBytes(data);

                WriteFileRequest writeReq = new WriteFileRequest(client, user, data);
                Storage.WriteFile(client, user, writeReq);
            }

            public static void DbgEnumFile_Avatar()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                client.TitleId = 0x584D07D1;    // Avatar Creator
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                EnumFileRequest enumReq = new EnumFileRequest(client, user,
                    "//avatar/u:" + user.Puid.ToString("X") + "/avatar-body.png");
                Storage.EnumFile(client, user, enumReq);
            }

            [TestCase]
            public static void EnumFile()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                EnumFileRequest enumReq = new EnumFileRequest(client, user, "//title/t:FFFE07D1/*");
                EnumFilesResponse enumResp = Storage.EnumFile(client, user, enumReq);
                Throw.IfEqual(enumResp.Results.Count, 0, "EnumFile returned 0 results.  Need at least 1 result to proceed.");
            }

            [TestCase]
            public static void ReadFile()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                // Grab the latest LivePack filename
                EnumFileRequest enumReq = new EnumFileRequest(
                    client, user, "//title/t:" + XOn.XENON_DASH_TITLE_ID.ToString("x") + "/livepack*");
                EnumFilesResponse enumResp = Storage.EnumFile(client, user, enumReq);
                Throw.IfEqual(enumResp.Results.Count, 0, "EnumFile returned 0 results.  Need at least 1 result to proceed.");

                ReadFileRequest readReq = new ReadFileRequest(client, user, enumResp.Results[0]._pathName);
                ReadFileResponse readResp = Storage.ReadFile(client, user, readReq);
            }

            [TestCase]
            public static void RemoveFile()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                byte[] data = new byte[128];
                RandomEx.GlobalRandGen.NextBytes(data);

                WriteFileRequest writeReq = new WriteFileRequest(client, user, data);
                Storage.WriteFile(client, user, writeReq);

                RemoveFileRequest removeReq = new RemoveFileRequest(client, user, writeReq.AccessToken._pathName);
                Storage.RemoveFile(client, user, removeReq);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\CatalogTests.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.common;
using live.common.next;
using live.protocol.next;
using live.server.next;

using ServerTestFramework;

namespace live.unittests
{
    public partial class ServerTests
    {
        [TestGroup]
        public class CatalogTests
        {
            [TestCase]
            public static void TestConnection()
            {
                WebClient client = ServerTests.GetWebClient();
                TestConnectionFilter filter = new TestConnectionFilter("ASingleString");

                CatalogResponse resp = Catalog.TestConnection(client, filter);

                UnitTests.WriteLine("response:\r\n" + resp.Response);
            }
/*
            public static void HelloWorld()
            {
                WebClient client = ServerTests.GetWebClient();
                HelloWorldFilter filter = new HelloWorldFilter(
                    "ASingleString",
                    new string[] { "StringArrayVal1", "StringArrayVal2" }
                    );

                //filter.DisableField("inputString");

                CatalogResponse resp = Catalog.HelloWorld(client, filter);

                UnitTests.WriteLine("response:\r\n" + resp.ResponseXml);
            }
*/
            [TestCase]
            public static void CustomQuery()
            {
                WebClient client = ServerTests.GetWebClient();
                //string query = "/Catalog/catalog.asmx/Query?clientType=fakeClientType&clientVersion=unrealClientVersion&localeId=noPlaceSpecial&methodName=FindGameOffers&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=10000&Names=PageSize&Values=10&Names=PageNum&Values=1&Names=DetailView&Values=1&Names=MediaTypes&Values=2";
                string query = "clientType=fakeClientType&clientVersion=unrealClientVersion&localeId=noPlaceSpecial&methodName=FindGameOffers&Names=Locale&Values=en-US&Names=LegalLocale&Values=en-US&Names=Store&Values=10000&Names=PageSize&Values=10&Names=PageNum&Values=1&Names=DetailView&Values=1&Names=MediaTypes&Values=2";
                GenericQueryRequest req = new GenericQueryRequest(query);
                CatalogResponse resp = Catalog.SendRequest(client, req);
                UnitTests.WriteLine("CustomQuery response: \r\n" + resp.Response);
            }

            [TestCase]
            public static void FindGameOffers()
            {
                WebClient client = ServerTests.GetWebClient();

                FindGameOffersFilter filter = new FindGameOffersFilter();
                filter.Locale = "en-US";
                filter.LegalLocale = "en-US";
                filter.Store = (int)Store.Xbox360;
                filter.PageSize = 10;
                filter.PageNum = 1;
                filter.DetailView = (int)DetailView.IdOnly;
                filter.MediaTypes = ListEx.NewList(2);

                CatalogResponse resp = Catalog.FindGameOffers(client, filter);
                UnitTests.WriteLine("FindMediaOffer response: \r\n" + resp.Response);
            }

            [TestCase]
            public static void FindMedia()
            {
                WebClient client = ServerTests.GetWebClient();
                FindMediaFilter filter = new FindMediaFilter();
                filter.Locale = "en-US";
                filter.LegalLocale = "en-US";
                filter.Store = (int)Store.Xbox360;
                filter.PageSize = 10;
                filter.PageNum = 1;
                filter.DetailView = (int)DetailView.Full;
                filter.OfferFilterLevel = (int)OfferFilterLevel.All;
                filter.MediaTypes = ListEx.NewList((int)MediaTypeEnum.Game360, (int)MediaTypeEnum.GameDemo,
                    (int)MediaTypeEnum.GameVideo);
                filter.CategoryIds = ListEx.NewList(2001, 2005);
                filter.OrderBy = 1;
                filter.OrderDirection = (int)OrderDirection.Ascending;

                CatalogResponse resp = Catalog.FindMedia(client, filter);
                UnitTests.WriteLine("FindMedia response: \r\n" + resp.Response);
            }

            [TestCase]
            public static void FindMediaOffers()
            {
                WebClient client = ServerTests.GetWebClient();

                FindMediaOffersFilter filter = new FindMediaOffersFilter();
                filter.Locale = "en-US";
                filter.LegalLocale = "en-US";
                filter.Store = (int)Store.Xbox360;
                filter.PageSize = 10;
                filter.PageNum = 1;
                filter.DetailView = (int)DetailView.Full;
                //filter.OfferFilterLevel = "1";

                filter.MediaIds = ListEx.NewList(
                    //- <!--  C1T0R1 
                    new Guid("BFD67B9A-7666-45F3-9381-D5BCC99D24FE"),
                    //- <!--  C1T3R1 
                    new Guid("B4B1294F-1C2D-4411-8C9F-73282F3C89A5"),
                    //- <!--  C12T1R12 
                    new Guid("2809DD66-3004-4152-BE8D-901DC14E4D74"),
                    //- <!--  C1T1R3 
                    new Guid("36CF4AE8-E4C5-4533-B4FA-D842207A9FFC"),
                    //- <!--  C3R12T1 
                    new Guid("6ED7D887-D1ED-4DA7-A6A7-B5F9B2085AA7"),
                    //- <!--  C3R12T2 
                    new Guid("F943760D-2DB9-4206-A293-64D824F47EA7"),
                    //- <!--  Expired Offer 
                    new Guid("305A2AD5-D668-4181-8E54-CB656381F81F"),
                    //- <!--  Hidden Offer 
                    new Guid("3F8C3D42-E621-4320-918A-B5771336F26A"),
                    //- <!--  Without Offer 
                    new Guid("AB14D645-5762-4AB4-8E50-8FCA5ECFECB9"),
                    //- <!--  C1R1U12 
                    new Guid("BD3DA9B5-944E-431D-9378-422A2F9D6661"),
                    new Guid("AE81B70A-638F-4F41-89F4-79290E69CA9D"),
                    //- <!--  T2 
                    new Guid("D9A0D038-6EC8-4177-A18A-910674E767F5")
                );

                filter.MediaTypes = ListEx.NewList(18, 19, 1);
                filter.CategoryIds = ListEx.NewList(10101, 10102);
                filter.OrderBy = 1;
                filter.OrderDirection = (int)OrderDirection.Ascending;

                CatalogResponse resp = Catalog.FindMediaOffers(client, filter);
                UnitTests.WriteLine("FindMediaOffer response: \r\n" + resp.Response);
            }

            [TestCase]
            public static void FindVideoOffers()
            {
                WebClient client = ServerTests.GetWebClient();

                FindVideoOffersFilter filter = new FindVideoOffersFilter();
                filter.Locale = "en-US";
                filter.LegalLocale = "en-US";
                filter.Store = (int)Store.Xbox360;
                filter.PageSize = 10;
                filter.PageNum = 1;
                filter.DetailView = (int)DetailView.IdOnly;
                filter.MediaTypes = ListEx.NewList(2);

                CatalogResponse resp = Catalog.FindVideoOffers(client, filter);
                UnitTests.WriteLine("FindMediaOffer response: \r\n" + resp.Response);
            }

            [TestCase]
            public static void PurchaseHistory()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                //client.MachinePuid = 0xFA00000000F76ACE;
                //XblUser user = new XblUser(2600292642020233, "Xefa5357b6YCALT");
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);

                PurchaseHistoryFilter filter = new PurchaseHistoryFilter();
                filter.Locale = "en-US";
                filter.LegalLocale = "en-US";
                filter.Store = (int)Store.Xbox360;
                filter.DetailView = (int)DetailView.IdOnly;
                filter.MediaTypes = ListEx.NewList(2, 3, 4, 7, 8, 9, 10, 40, 39, 5, 18, 19, 20, 21, 22, 23, 30, 34, 37);
                filter.PageSize = 10;
                filter.PageNum = 1;

                PurchaseHistoryWebResponse resp = WebBilling.GetPurchaseHistory(client, user, filter.ToList());
                UnitTests.WriteLine("PurchaseHistory response: \r\n" + resp.Response);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\UtilTests\AccountsUtilTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    public partial class UtilTests
    {
        [TestGroup]
        internal class AccountsUtilTests
        {
/*
            /// <remarks>
            /// This unit test should be expanded/broken out to cover many more of the XblUserSetting options
            /// </remarks>
            [TestCase]
            public static void CreateLiveAccountMatrix_OLD()
            {
                XblUserTier[] supportedUserTiers = new XblUserTier[] { XblUserTier.Silver, XblUserTier.Gold };

                Exception lastException = null;
                foreach (XblUserTier userTier in supportedUserTiers)
                {
                    foreach (PassportType passportType in Enum.GetValues(typeof(PassportType)))
                    {
                        try
                        {
                            Logging.WriteLine("CreateLiveAccountMatrix:  Testing " + userTier +
                                " user with a " + passportType + " passport");
                            XblUserSettings settings = new XblUserSettings(userTier, passportType);
                            if (passportType == PassportType.Existing)
                            {
                                Xbox360Client client = new Xbox360Client();
                                PassportUtils.CreatePassportAccounts(client, settings, true);
                            }
                            XblUser user = Util.Accounts.CreateLiveAccount(settings);
                            if (user.Puid == 0)
                            {
                                throw new Exception("user.Puid == 0");
                            }
                        }
                        catch (Exception e)
                        {
                            Logging.WriteLine("FAILED: " + e);
                            Logging.ResetIndent();
                            lastException = e;
                        }
                    }
                }
                if (lastException != null)
                {
                    throw lastException;
                }
            }
*/
            [TestCase]
            public class CreateLiveAccount_SimpleMatrix : TestNode
            {
                XblUserTier[] supportedUserTiers = new XblUserTier[] { XblUserTier.Silver, XblUserTier.Gold };
                PassportType[] supportedPassportTypes = new PassportType[] { PassportType.Fake, PassportType.Real };

                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (XblUserTier userTier in supportedUserTiers)
                    {
                        foreach (PassportType passportType in supportedPassportTypes)
                        {
                            for (int i = 0; i < 2; i++)
                            {
                                bool withArgoProfile = (i == 1);
                                string argoDisplay = "without_Argo";
                                if (withArgoProfile)
                                {
                                    argoDisplay = "with_Argo";
                                }

                                string testName = "P_" + userTier + "_" + passportType + "Passport_" + argoDisplay;

                                Global.RO.Info("CreateLiveAccount_SimpleMatrix:  Created test " + testName);
                                instances.Add(new CompoundCaseAttribute(testName, userTier, passportType, withArgoProfile));
                            }
                        }
                    }
                }

                public override void Run()
                {
                    XblUserTier userTier = (XblUserTier)this.MyValues[0];
                    PassportType passportType = (PassportType)this.MyValues[1];
                    bool withArgoProfile = (bool)this.MyValues[2];

                    XblUser user = Util.Accounts.CreateLiveAccount(userTier, passportType, withArgoProfile);
                    if (user.Puid == 0)
                    {
                        throw new Exception("user.Puid == 0");
                    }
                }
            }

            /// <remarks>
            /// This unit test should be expanded/broken out to cover many more of the XblUserSetting options
            /// </remarks>
            [TestCase]
            public class CreateLiveAccount_XblUserSettingsMatrix : TestNode
            {
                XblUserTier[] supportedUserTiers = new XblUserTier[] { XblUserTier.Silver, XblUserTier.Gold };

                protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
                {
                    foreach (XblUserTier userTier in supportedUserTiers)
                    {
                        foreach (PassportType passportType in Enum.GetValues(typeof(PassportType)))
                        {
                            for (int i = 0; i < 2; i++)
                            {
                                bool withArgoProfile = (i == 1);
                                string argoDisplay = "without_Argo";
                                if (withArgoProfile)
                                {
                                    argoDisplay = "with_Argo";
                                }
                                string testName = "P_" + userTier + "_" + passportType + "Passport_" + argoDisplay;

                                Global.RO.Info("CreateLiveAccount_XblUserSettingsMatrix:  Created test " + testName);
                                instances.Add(new CompoundCaseAttribute(testName, userTier, passportType, withArgoProfile));
                            }
                        }
                    }
                }

                public override void Run()
                {
                    XblUserTier userTier = (XblUserTier)this.MyValues[0];
                    PassportType passportType = (PassportType)this.MyValues[1];
                    bool withArgoProfile = (bool)this.MyValues[2];

                    if (passportType == PassportType.Existing)
                    {
                        // Create the "already existing" Passport account
                        Xbox360Client client = new Xbox360Client();
                        using (client)
                        {
                            XblUserSettings ppsettings = new XblUserSettings(userTier, PassportType.Real);
                            PassportUtils.CreatePassportAccounts(client, ppsettings, true);
                        }
                    }

                    XblUserSettings settings = new XblUserSettings(userTier, passportType);
                    settings.CreateZuneProfile = withArgoProfile;

                    XblUser user = Util.Accounts.CreateLiveAccount(settings);
                    if (user.Puid == 0)
                    {
                        throw new Exception("user.Puid == 0");
                    }
                }
            }

            [TestCase]
            public static void CreateLiveAccount_ExistingPassport()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUserSettings createPPSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
                    PassportUtils.CreatePassportAccounts(client, createPPSettings, true);

                    XblUserSettings createUserSettings = new XblUserSettings(XblUserTier.Gold, PassportType.Existing);
                    createUserSettings.UserPassportInfo = createPPSettings.UserPassportInfo;
                    createUserSettings.UserPassportInfo.PassportType = PassportType.Existing;
                    createUserSettings.OwnerPassportInfo = createUserSettings.UserPassportInfo;

                    XblUser user = Util.Accounts.CreateLiveAccount(createUserSettings);
                    if (user.Puid == 0)
                    {
                        throw new Exception("user.Puid == 0");
                    }
                    //UACS.XePassportGetUserData();
                }
            }

            private static void CreateZuneAccount(XblUserTier userTier, PassportType passportType,
                Offers.MusicNetOffers offer)
            {
                Logging.WriteLine("CreateZuneAccount: " + userTier + "; " + passportType + "; " + offer);

                XblUser user = Util.Accounts.CreateZuneAccount(userTier, passportType, offer);

                // Verify the MusicNet account was created
                Xbox360Client client = new Xbox360Client(user.Settings.CreatedOn);
                using (client)
                {
                    client.TitleId = XOn.CRUX_TITLE_ID;
                    live.protocol.ArgoGetAccountStatusResponse resp = UACS.ArgoGetAccountStatus(client, user);

                    ulong offerId = Offers.GetOfferId(offer);
                    if (resp.offerId != offerId)
                    {
                        throw new Exception("resp.offerId(0x" + resp.offerId.ToString("X") +
                            ") != MusicNetOffers.MonthlyCC(0x" + offerId.ToString("X") + ")");
                    }
                }
            }

            [TestCase]
            public static void CreateZuneAccount_Matrix()
            {
                XblUserTier[] supportedUserTiers = new XblUserTier[] { XblUserTier.Silver, XblUserTier.Gold };

                Exception lastException = null;
                foreach (XblUserTier userTier in supportedUserTiers)
                {
                    foreach (Offers.MusicNetOffers offer in Enum.GetValues(typeof(Offers.MusicNetOffers)))
                    {
                        try
                        {
                            CreateZuneAccount(userTier, PassportType.Real, offer);
                        }
                        catch (Exception e)
                        {
                            Logging.WriteLine("FAILED: " + e);
                            Logging.ResetIndent();
                            lastException = e;
                        }
                        Logging.WriteLine("");
                    }
                }
                if (lastException != null)
                {
                    throw lastException;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\BillingTests.cs ===
using System;
using System.Collections.Generic;
using System.IO;

using live.client;
using live.common;
using live.protocol;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    public partial class ServerTests
    {
        [TestGroup]
        public partial class BillingTests
        {
            [TestCase]
            public static void XeContentUpdateAccessTimes()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                // Get a title to work with
                TitleEnumerateFilter filter = new TitleEnumerateFilter(user);
                EnumeratedTitles titles = live.server.Billing.XeEnumerateTitlesByFilter(client, user, filter);

                Billing.XeContentUpdateAccessTimes(client, user, titles.Titles[0].titleId, 0xffffffff);
            }

            [TestCase]
            public static void XeContentEnumerate2()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                ContentEnumerateFilter filter = new ContentEnumerateFilter();

                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);
                if (response.Infos.Count != 30)
                {
                    throw new Exception("Warning: less than 30 offers returned.  Total # returned: " +
                        response.Infos.Count);
                }
            }

            [TestCase]
            public static void XeContentHistoryEnumerate()
            {
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);

                ContentEnumerateFilter filter = new ContentEnumerateFilter();
                filter.OfferType = OfferingTypeEnum.AllContent;
                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);

                //TODO: This only works in StressNet.  Make it universal.
                //ContentItem info = FindOffer.ByOfferId(response.Infos, PaymentTypeEnum.Points, 3268063190341369100);
                ContentItem info = FindOffer.Xbox360Content(response.Infos, PaymentTypeEnum.Points);

                Billing.XeOfferPurchase(client, user, info.offerID, PaymentTypeEnum.Points, null);

                ContentHistoryEnumerateFilter historyFilter = new ContentHistoryEnumerateFilter();
                EnumeratedContentHistoryItems response2 = Billing.XeContentHistoryEnumerate(client, user, historyFilter);
                if (response2.ContentHistoryItems.Count == 0)
                {
                    throw new Exception("No content history items were found.");
                }
            }

            [TestCase]
            public static void XeContentDetails()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                ContentEnumerateFilter filter = new ContentEnumerateFilter();

                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);
                if (response.Infos.Count != 30)
                {
                    throw new Exception("Warning: less than 30 offers returned.  Total # returned: " +
                        response.Infos.Count);
                }

                ContentItem contentItem = response.Infos[0];

                EnumeratedContentItems contentItems = Billing.XeContentDetails(client, user, contentItem.offerID,
                    contentItem.prices[0].paymentType, 63);

                if (contentItems.TotalOffers == 0)
                {
                    throw new Exception("XeContentDetails returned no details for offer ID " + contentItem.offerID);
                }
            }

            [TestCase]
            public static void XeContentReferral()
            {
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);

                ContentEnumerateFilter filter = new ContentEnumerateFilter();
                filter.OfferType = OfferingTypeEnum.AllContent;
                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);

                ////TODO: This only works in StressNet.  Make it universal.
                //ContentItem info = FindOffer.ByOfferId(response.Infos, PaymentTypeEnum.Points, 3268063190341369100);
                ContentItem info = FindOffer.Xbox360Content(response.Infos, PaymentTypeEnum.Points);

                Billing.XeOfferPurchase(client, user, info.offerID, PaymentTypeEnum.Points, null);

                ContentReferral referral = Billing.XeContentReferral(client, user, info);
                if (referral.LocationsCount == 0)
                {
                    throw new Exception("XeContentReferral returned 0 locations");
                }
            }

            [TestCase]
            public static void XeContentRefreshLicense()
            {
                throw new Exception("Cannot test XeContentRefreshLicense until machine accounts can be created.");
            }

            [TestCase]
            public static void XeSubscriptionEnumerate()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
                filter.QueryForCurrent = true;

                EnumeratedSubscriptions response = Billing.XeSubscriptionEnumerate(client, user, filter);
                if (response.ReturnedCount == 0)
                {
                    throw new Exception("0 subscriptions were returned");
                }
            }

            [TestCase]
            public static void XeSubscriptionDetails()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
                filter.QueryForCurrent = true;

                EnumeratedSubscriptions response = Billing.XeSubscriptionEnumerate(client, user, filter);
                if (response.ReturnedCount == 0)
                {
                    throw new Exception("SubscriptionEnumerate returned 0 subscriptions");
                }

                SubscriptionItem item = Billing.XeSubscriptionDetails(client, user, response.Subscriptions[0].offerID);

                if (item == null)
                {
                    throw new Exception("Subscription is null");
                }

                if (!item.UserIsSubscribed)
                {
                    throw new Exception("User is not subscribed");
                }
            }

            private static class FindOffer
            {
                private static bool HasNonZeroContentId(ContentItem item)
                {
                    foreach (byte elem in item.contentId)
                    {
                        if (elem != 0)
                        {
                            return true;
                        }
                    }
                    return false;
                }

                public static ContentItem Xbox360Content(List<ContentItem> infos,
                    PaymentTypeEnum paymentType)
                {
                    foreach (ContentItem info in infos)
                    {
                        if (info.offerType == OfferingTypeEnum.Content)
                        {
                            if (HasNonZeroContentId(info))
                            {
                                foreach (live.common.OfferPrice price in info.prices)
                                {
                                    if (price.paymentType == paymentType)
                                    {
                                        return info;
                                    }
                                }
                            }
                        }
                    }
                    throw new Exception("FindOffer.Xbox360Content: no content found");
                }

                public static ContentItem ByOfferId(List<ContentItem> infos, PaymentTypeEnum paymentType,
                    ulong targetOfferId)
                {
                    foreach (ContentItem info in infos)
                    {
                        if (info.offerID == targetOfferId)
                        {
                            foreach (live.common.OfferPrice price in info.prices)
                            {
                                if (price.paymentType == paymentType)
                                {
                                    return info;
                                }
                            }
                        }
                    }
                    throw new Exception("FindOffer.ByOfferId: no content found");
                }

                public static ContentItem PointsBundle(List<ContentItem> infos,
                    PaymentTypeEnum paymentType)
                {
                    foreach (ContentItem info in infos)
                    {
                        if (info.offerType == OfferingTypeEnum.PointsBundle)
                        {
                            foreach (live.common.OfferPrice price in info.prices)
                            {
                                if (price.paymentType == paymentType)
                                {
                                    return info;
                                }
                            }
                        }
                    }
                    throw new Exception("FindOffer.PointsBundle: no content found");
                }

                public static ContentItem PointsBundle(List<ContentItem> infos,
                    Offers.PointsOffers pointsOffer)
                {
                    ulong targetOfferId = Offers.GetOfferId(pointsOffer);

                    foreach (ContentItem info in infos)
                    {
                        if (info.offerID == targetOfferId)
                        {
                            return info;
                        }
                    }
                    throw new Exception("FindOffer.PointsBundle: Points offer " + targetOfferId + " not found");
                }

                public static ContentItem GamertagChange(List<ContentItem> infos,
                    Offers.PointsOffers pointsOffer)
                {
                    ulong targetOfferId = Offers.GetOfferId(pointsOffer);

                    foreach (ContentItem info in infos)
                    {
                        if (info.offerType == OfferingTypeEnum.GamertagChange)
                        {
                            return info;
                        }
                    }
                    throw new Exception("FindOffer.GamertagChange: Points offer " + targetOfferId + " not found");
                }

                public static ContentItem Music(List<ContentItem> infos,
                    PaymentTypeEnum paymentType)
                {
                    foreach (ContentItem info in infos)
                    {
                        if (info.offerType == OfferingTypeEnum.SyncCastWMIS)
                        {
                            foreach (live.common.OfferPrice price in info.prices)
                            {
                                if (price.paymentType == paymentType)
                                {
                                    return info;
                                }
                            }
                        }
                    }
                    throw new Exception("FindOffer.Music: no content found");
                }
            }

            private static void SetupForPurchase(out Xbox360Client client, out XblUser user,
                Offers.PointsOffers pointsOffer, out uint pointsBalance,
                out PointsBalanceStatus pointsBalanceStatus)
            {
                client = ServerTests.GetXbox360Client();
                user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                UACS.XeAddPaymentInstrument(client, user,
                    Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo));

                // Work-around for server bug that returns DMP_E_STATUS_UNREGISTERED if you attempt to purchase
                // a points (and any others?) offering prior to getting points balance
                pointsBalance = UACS.XeGetPointsBalance(client, user, out pointsBalanceStatus);

                ContentEnumerateFilter filter = new ContentEnumerateFilter();
                filter.OfferType = OfferingTypeEnum.PointsBundle;
                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);
                ContentItem info = FindOffer.PointsBundle(response.Infos, pointsOffer);

                Billing.XeOfferPurchase(client, user, info.offerID, PaymentTypeEnum.CreditCard,
                    user.Settings.BillingInfo.GetActivePaymentInstrument().PaymentInstrumentId);

                PointsBalanceStatus ptsBalStatus;
                uint ptsBal = UACS.XeGetPointsBalance(client, user, out ptsBalStatus);

                UnitTests.WriteLine("Points Balance: {0} ({1})", ptsBal, ptsBalStatus);
            }

            /// <summary>
            /// Purchases points, a behavior the XeOfferPurchaseXxx tests rely on
            /// </summary>
            [TestCase]
            public static void XeOfferPurchase()
            {
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);

                PointsBalanceStatus newStatus;
                uint newPointsBalance = UACS.XeGetPointsBalance(client, user, out newStatus);

                UnitTests.WriteLine("Old Points Balance: {0} ({1})\tNew Points Balance: {2} ({3})",
                    oldPointsBalance, oldStatus, newPointsBalance, newStatus);
                if (newPointsBalance <= oldPointsBalance)
                {
                    throw new Exception("newPointsBalance <= oldPointsBalance");
                }
            }

            [TestCase]
            public static void XeOfferPurchaseGamertag()
            {
                // Setup
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);

                // Find offer
                ContentEnumerateFilter filter = new ContentEnumerateFilter();
                filter.OfferType = OfferingTypeEnum.GamertagChange;
                EnumeratedContentItems response = Billing.XeContentEnumerate2(client, user, filter);
                ContentItem info = FindOffer.GamertagChange(response.Infos, Offers.PointsOffers.CC5000US);

                // Server call
                string oldGamertag = user.Gamertag;
                string newGamertag = new RandomEx().GenerateRandomName();
                Billing.XeOfferPurchaseGamertag(client, user, info.offerID, PaymentTypeEnum.Points,
                    null, newGamertag);

                // Verification
                ulong userPuid;
                string currentGamertag = UACS.XeGetLinkedGamertag(client, user.Settings.UserPassportInfo, out userPuid);
                UnitTests.WriteLine("Old Gamertag: {0}\tNew: {1}\tCurrent:{2}",
                    oldGamertag, newGamertag, currentGamertag);
                if (currentGamertag != newGamertag)
                {
                    throw new Exception("Current gamertag is not equal to new gamertag");
                }
            }

            public static MusicItem[] CreateRealMusicItems(byte[] comTypes, string[] comIds)
            {
                if (comTypes.GetLength(0) != comIds.GetLength(0))
                {
                    throw new Exception(string.Format("Types and Ids are not the same size. Types: {0}, Ids: {1}", comTypes.GetLength(0), comIds.GetLength(0)));
                }

                MusicItem[] items = new MusicItem[comTypes.GetLength(0)];
                MusicItem item;

                for (int i = 0; i < comTypes.GetLength(0); i++)
                {
                    item = new MusicItem();
                    item.componentType = comTypes[i];
                    item.mnetID = comIds[i];
                    item.artistName = "MN artist " + item.mnetID;
                    item.titleField = "MN title " + item.mnetID;
                    if (item.componentType == 0)    // 0 - track, 1 - album
                    {
                        item.retailPriceInPoints = 80;
                        item.retailPriceInCurrency = 0.9900m;
                        item.wholesalePriceInCurrency = 0.7000m;
                    }
                    else
                    {
                        item.retailPriceInPoints = 160;
                        item.retailPriceInCurrency = 9.9000m;
                        item.wholesalePriceInCurrency = 7.0000m;
                    }

                    items[i] = item;
                }
                return items;
            }

            public static MusicItem[] CreateRealMusicItems()
            {
                return CreateRealMusicItems(new byte[] { 0, 1 }, new string[] { "7378269", "5337487" });
            }

            public static MusicItem[] CreateOneMusicItem()
            {
                return CreateRealMusicItems(new byte[] { 0 }, new string[] { "7378269" });
            }

            [TestCase]
            public static void XeOfferPurchaseMusic()
            {
                // Setup
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);


                Billing.XeOfferPurchaseMusic(client, user, CreateRealMusicItems(), (new Guid()).ToString(), PaymentTypeEnum.Points, "");
            }

            //[INF] [7/26/2007 4:57:26 PM] [Log] HDMovie::	 id: 3d9a8c23-ad02-46c6-aa1a-706be5c24068	 videoType: 1	 price: 360	 offerType: 2
            //[INF] [7/26/2007 4:57:26 PM] [Log] SDMovie::	 id: 477100bb-3229-4697-9bc0-3a78827b0c48	 videoType: 1	 price: 240	 offerType: 2

            [TestCase]
            public static void XeOfferPurchaseVideo()
            {
                // Setup
                Xbox360Client client;
                XblUser user;
                PointsBalanceStatus oldStatus;
                uint oldPointsBalance;
                SetupForPurchase(out client, out user, Offers.PointsOffers.CC5000US,
                    out oldPointsBalance, out oldStatus);
                live.protocol.WMID wmid = new live.protocol.WMID();
                wmid.videoType = 1;
                wmid.wmid = "477100bb-3229-4697-9bc0-3a78827b0c48";
                wmid.wmidLength = (ushort)wmid.wmid.Length;

                live.protocol.WMID[] wmids = Billing.XeOfferPurchaseVideo(client, user, wmid, 240, PaymentTypeEnum.Points, "");
                if (wmids.GetLength(0) != 1)
                {
                    throw new Exception("wmids.GetLength(0) != 1");
                }
            }

            [TestCase]
            public static void XeGetTitleDetails()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                // Get a title to work with
                TitleEnumerateFilter filter = new TitleEnumerateFilter(user);
                EnumeratedTitles resp = Billing.XeEnumerateTitlesByFilter(client, user, filter);

                // Grab the title's details
                TitleDetails details = Billing.XeGetTitleDetails(client, user, resp.Titles[0].titleId);
            }

            [TestCase]
            public static void XeEnumerateTitlesByFilter()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                TitleEnumerateFilter filter = new TitleEnumerateFilter(user);
                EnumeratedTitles resp = Billing.XeEnumerateTitlesByFilter(client, user, filter);
                if (resp.ReturnedCount == 0)
                {
                    throw new Exception("0 titles were returned");
                }
            }

            [TestCase]
            public static void XeEnumerateGenres()
            {
                IClient client = ServerTests.GetDefaultClient();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                GenreEnumerateFilter filter = new GenreEnumerateFilter();

                EnumeratedGenres response = Billing.XeEnumerateGenres(client, user, filter);
                if (response.Genres.Count == 0)
                {
                    throw new Exception("0 genres were returned");
                }
            }

            [TestCase]
            public static void XeOfferingVerifyToken()
            {
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);

                Offers.BaseOffers offer = Offers.BaseOffers.GoldPP1Year;
                OfferingTypeEnum expectedOfferType = OfferingTypeEnum.Subscription;
                ulong expectedOfferId = Offers.GetOfferId(offer);

                OfferingTypeEnum actualOfferType;
                ulong actualOfferId = Billing.XeOfferingVerifyToken(client, user,
                    Offers.GetPrepaidVoucherCode(offer), out actualOfferType);
                if (actualOfferType != expectedOfferType)
                {
                    throw new Exception("Actual offer type " + actualOfferType +
                        " is not the expected offer type " + expectedOfferType);
                }
                if (actualOfferId != expectedOfferId)
                {
                    throw new Exception("Actual offer ID " + actualOfferId +
                        " is not the expected offer ID " + expectedOfferId);
                }
            }

            //
            // Title Activation Tests
            //

            // Verification test. Just to see if the calls succeed.
            [TestCase]
            public static void GetTitleActivationList()
            {
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                client.TitleId = 0;
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);
            }

            [TestCase]
            public static void GetTitleActivationList_PMainline()
            {
                for (int i = 0; i < 4; i++)
                {
                    // Setup the User, Nonce, and Machine
                    Random rand = new Random();
                    UInt32 Nonce = (UInt32)rand.Next();
                    Xbox360Client client = ServerTests.GetXbox360Client();
                    client.TitleId = 0xFFFF0096;

                    // This allows us to use 1 user, then 2 users, then 3 Etc.
                    for (int j = 0; j < i + 1; j++)
                    {
                        XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                    }

                    // Send the request
                    GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                    VerifyTitleActivationResponse(response, client, "GetTitleActivationList_PMainline");

                    // Manually verify the privileges
                    switch (i)
                    {
                        case 0: // One User Slot 1
                            if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                            {

                                Global.RO.Error("Title Privilege 0: " + "GetTitleActivationList_PMainline");
                            }
                            break;
                        case 1: // Two users Slot 1+2
                            if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                            {
                                Global.RO.Error("Title Privilege 0+1: " + "GetTitleActivationList_PMainline");
                            }
                            break;
                        case 2: // Three users Slot 1+2+3
                            if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                            {
                                Global.RO.Error("Title Privilege 0+1+2: " + "GetTitleActivationList_PMainline");
                            }
                            break;
                        case 3: // Four users Slot 1+2+3+4
                            if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                            {
                                Global.RO.Error("Title Privilege: 0+1+2+3" + "GetTitleActivationList_PMainline");
                            }
                            break;
                    }
                }
            }

            [TestCase]
            public static void GetTitleActivationList_PActivated()
            {
                // Setup the User, Nonce, and Machine
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = ServerTests.GetXbox360Client();

                for (int i = 0; i < 4; i++)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                }

                // Setting the requested title ID to 0, we should get a list of all
                // activated titles for all users.
                client.TitleId = 0;

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                VerifyTitleActivationResponse(response, client, "GetTitleActivationList_NMainline");

                // Manually verify the privileges only for users 1 + 3
                if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                {
                    Global.RO.Error("Title Privilege 1: " + "GetTitleActivationList_NMainline");
                }
                if (response.titles[1].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                {
                    Global.RO.Error("Title Privilege 1+2: " + "GetTitleActivationList_NMainline");
                }
                if (response.titles[2].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                {
                    Global.RO.Error("Title Privilege 1+2+3: " + "GetTitleActivationList_NMainline");
                }
                if (response.titles[3].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                        TitleActivationInfo.LicenseFlags_GrantedUser2 |
                                                        TitleActivationInfo.LicenseFlags_GrantedUser3 |
                                                        TitleActivationInfo.LicenseFlags_GrantedUser4))
                {
                    Global.RO.Error("Title Privilege 1+2+3+4: " + "GetTitleActivationList_NMainline");
                }
            }

            [TestCase]
            public static void GetTitleActivationList_NMainline()
            {
                // Setup the User, Nonce, and Machine
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = ServerTests.GetXbox360Client();

                for (int i = 0; i < 4; i++)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Silver, PassportType.Real);
                }

                client.TitleId = 0xFFFF0096;

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                VerifyTitleActivationResponse(response, client, "GetTitleActivationList_NMainline");

                // Manually verify the privileges only for users 1 + 3
                if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 | TitleActivationInfo.LicenseFlags_GrantedUser3))
                {
                    Global.RO.Error("Title Privilege: " + "GetTitleActivationList_NMainline");
                }
            }

            [TestCase]
            public static void GetTitleActivationList_N_No_Users()
            {
                // Setup the User, Nonce, and Machine
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = ServerTests.GetXbox360Client();

                client.TitleId = 0xFFFF0096;

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                VerifyTitleActivationResponse(response, client, "GetTitleActivationList_NMainline");
            }

            //public static void XeGetTitleActivationList_N_No_MachinePUID ()
            //{
            //    // Setup the User, Nonce, and Machine
            //    Random rand = new Random();
            //    UInt32 Nonce = (UInt32)rand.Next();
            //    Xbox360Client client = ServerTests.GetXbox360Client();

            //    client.TitleId = 0xFFFF0096;
            //    XblUser user = ServerTests.CreateUser(client, UserType.Silver, PassportType.Real);
            //    client.SecurityProvider.MachinePuid = 0;

            //    // Send the request
            //    XeGetTitleActivationListResponse response = Billing.XeGetTitleActivationList(client, Nonce);

            //    VerifyTitleActivationResponse(response, client, "XeGetTitleActivationList_NMainline");
            //}

            public static void VerifyTitleActivationResponse(GetTitleActivationListResponse _response, Xbox360Client client, string test)
            {
                // If a title ID was passed, then we should only have one in the 
                // response
                if (client.TitleId != 0)
                {
                    if (_response.titlesLength != 1)
                    {
                        if (client.LoggedOnUsers.Count != 0)
                        {
                            Global.RO.Error("Verify titlesLength: " + test);
                        }
                    }
                    else
                    {
                        // Verify that the title ID recieved matches the requested one.
                        if (_response.titles[0].titleId != client.TitleId)
                        {
                            Global.RO.Error("Verify titlesID: " + test);
                        }
                    }
                }

                // Verify that the MachinePUID is correct
                if (_response.machineId != client.MachinePuid)
                {
                    Global.RO.Error("Verify MachinePUID: " + test);
                }

                //// Make sure the user list is the same as what we requested
                for (int i = 0; i < client.LoggedOnUsers.Count; i++)
                {
                    if (_response.userIds[i] != client.LoggedOnUsers[i])
                    {
                        Global.RO.Error("Verify UserID: " + test);
                    }
                }

                MemoryStream ms = new MemoryStream();
                BinaryWriter bw = new BinaryWriter(ms);
                bw.Write(_response.machineId);
                for (int i = 0; i < TitleActivationInfo.MaxUserLogin; i++)
                {
                    bw.Write(_response.userIds[i]);
                }
                bw.Write(_response.nonce);
                bw.Write(_response.titlesLength);
                for (int i = 0; i < _response.titlesLength; i++)
                {
                    bw.Write(_response.titles[i].titleId);
                    bw.Write(_response.titles[i].licenseFlags);
                }

                if (ServerTestFramework.Utilities.SignatureUtil.VerifySignature(ms.ToArray(), _response.signature) == false)
                {
                    Global.RO.Error("Verify Signature: " + test);
                }
            }
        }
    }
}

namespace live.unittests
{
    using live.common.next;
    using live.protocol.next;
    using live.server.next;

    public partial class ServerTests
    {
        public partial class BillingTests
        {
            //
            // Web Billing Tests
            //

            [TestCase]
            public static void PurchaseOffers_360()
            {
                Xbox360Client client360 = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client360, XblUserTier.Gold, PassportType.Real);


                //Add Payment Instrument
                live.common.CreditCardInfo cc = live.common.Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                live.server.UACS.XeAddPaymentInstrument(client360, user, cc);

                //Call Get Points balance before purchasing points
                uint pBalance = 0;
                pBalance = live.server.UACS.XeGetPointsBalance(client360, user);

                //Purchase Points
                live.server.Billing.XeOfferPurchase(client360, user,
                    live.common.Offers.GetOfferId(live.common.Offers.PointsOffers.CC5000US),
                    live.common.PaymentTypeEnum.CreditCard, user.Settings.BillingInfo.ActivePaymentInstrumentId);
                // 0FF39000-0000-0000-0000-000000000101, exp price 200
                // 0FF39000-0000-0000-0000-000000000404, exp price 200

                Guid[] offerIds = new Guid[] { new Guid("0FF39000-0000-0000-0000-000000000101") };
                uint[] expectedPrices = new uint[] { 200 };
                PaymentTypeEnum paymentType = PaymentTypeEnum.Points;
                //string billingToken;
                uint hr = live.server.next.Billing.PurchaseOffersXrl(client360, user, offerIds, expectedPrices, paymentType, null);
                Throw.IfXErrFailed(hr);
            }

            [TestCase]
            public static void PurchaseOffers_Web()
            {
                // Create a user to work with
                Xbox360Client client360 = ServerTests.GetXbox360Client();
                XblUser user = ServerTests.CreateUser(client360, XblUserTier.Gold, PassportType.Real);
                //UACS.XeAddPaymentInstrument(client, user, live.common.CreditCardRandomizer.GenerateVisaCard());


                //Add Payment Instrument
                live.common.CreditCardInfo cc = live.common.Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, user.Settings.PersonalInfo);
                live.server.UACS.XeAddPaymentInstrument(client360, user, cc);

                //Call Get Points balance before purchasing points
                uint pBalance = 0;
                pBalance = live.server.UACS.XeGetPointsBalance(client360, user);

                //Purchase Points
                live.server.Billing.XeOfferPurchase(client360, user,
                    live.common.Offers.GetOfferId(live.common.Offers.PointsOffers.CC5000US),
                    live.common.PaymentTypeEnum.CreditCard, user.Settings.BillingInfo.ActivePaymentInstrumentId);

                ZuneClient webClient = new ZuneClient();
                //WebClient webClient = ServerTests.GetWebClient();
                Guid[] offerIds = new Guid[] { new Guid("166CDE1E-9840-DC11-A90D-0019B9B20623") };
                uint[] expectedPrices = new uint[] { 99 };
                PaymentTypeEnum paymentType = PaymentTypeEnum.Points;
                //string billingToken;
                //WebRequestBase.RequestType = WebRequestBase.WebRequestType.Get;
                PurchaseOffersWebResponse resp = live.server.next.WebBilling.PurchaseOffers(webClient, user,
                    offerIds, expectedPrices, paymentType, null);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\ServerTests\CustTests.cs ===
using System;

using live.client;
using live.common;
using live.protocol;
using live.server;

using ServerTestFramework;

namespace live.unittests
{
    public partial class ServerTests
    {
        [TestGroup]
        public class CustTests
        {
            //private static string userGamertag = "LLi778i140u79";
            //private static ulong userPuid = 2536626028980653;
            //private static ulong userPassportPuid = 844427111823456;

            [TestCase]
            public static void GetPuidFromXName()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    //userGamertag = user.Gamertag;
                    //userPassportPuid = user.Settings.UserPassportInfo.PassportPuid;

                    ulong foundPuid = Cust.GetPuidFromXName(client, user.Gamertag);
                    if (foundPuid != user.Settings.OwnerPassportInfo.PassportPuid)
                    {
                        throw new Exception("foundPuid 0x" + foundPuid.ToString("X") +
                            " not equal to actual puid 0x" + user.Settings.OwnerPassportInfo.PassportPuid.ToString("X"));
                    }
                }
            }

            [TestCase]
            public static void GetAccount()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    AccountInfo info = Cust.GetAccount(client, user.Puid);

                    if (!info.IsOwner)
                    {
                        throw new Exception("Expected to be owner");
                    }
                }
            }

            [TestCase]
            public static void GetAccountEx()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    AccountInfoEx info = Cust.GetAccountEx(client, user.Puid);

                    if (info.OwnerPuid != user.Puid)
                    {
                        throw new Exception("Expected to be owner");
                    }
                }
            }

            [TestCase]
            public static void GetPassportMemberName()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    string ignored;
                    string pmn = Cust.GetPassportMemberName(client, user.Puid, out ignored);

                    if (pmn != user.Settings.UserPassportInfo.MemberName)
                    {
                        throw new Exception("Expected to Membernames to match");
                    }
                }
            }

            [TestCase]
            public static void ModifyAccount()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    AccountInfo info = new AccountInfo();
                    info.IsGeofenceExempt = true;

                    Cust.ModifyAccount(client, user.Puid, info);

                    AccountInfo info2 = Cust.GetAccount(client, user.Puid);
                    if (!info2.IsGeofenceExempt)
                    {
                        throw new Exception("Expected to be geofenced exempt");
                    }
                }
            }


            [TestCase]
            public static void BanAccount()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Real);
                    Cust.BanAccount(client, user.Puid, true);

                    AccountInfo info = Cust.GetAccount(client, user.Puid);
                    if (!info.IsLockedOut)
                    {
                        throw new Exception("Expected to be lockedout");
                    }


                }
            }

            [TestCase]
            public static void SetUserMotto()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Fake);
                    Cust.SetUserMotto(client, user.Puid, "My Motto");

                }
            }

            [TestCase]
            public static void SetUserProfileItems()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Fake);
                    ProfileItem item = new ProfileItem();
                    item.Item = 2;
                    item.ProfileItemValue = "blah";
                    item.TitleId = XOn.CRUX_TITLE_ID;

                    Cust.SetUserProfileItems(client, user.Puid, new ProfileItem[] { item });

                }
            }

            [TestCase]
            public static void RemoveGamerPicture()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Fake);
                    Cust.RemoveGamerPicture(client, user.Puid);

                }
            }

            [TestCase]
            public static void GetSubscriptionCodeStatus()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    SubscriptionCodeStatus status = Cust.GetSubscriptionCodeStatus(client, Offers.GetPrepaidVoucherCode(Offers.BaseOffers.GoldPP1Month));
                    if (!status.ValidSubscriptionCode)
                    {
                        throw new Exception("Expected a valid SubscriptionCode");
                    }


                }
            }

            [TestCase]
            public static void GetRelatedAccounts()
            {
                Xbox360Client client = new Xbox360Client();
                using (client)
                {
                    XblUser user = ServerTests.CreateUser(client, XblUserTier.Gold, PassportType.Fake);
                    string[] tags;
                    ulong[] puids = Cust.GetRelatedAccounts(client, user.Puid, out tags);

                    if (puids == null)
                    {
                        throw new Exception("Expected a non-null response");
                    }
                    if (puids[0] != user.Puid)
                    {
                        throw new Exception("Expected puids to be same");
                    }
                    if (tags[0] != user.Gamertag)
                    {
                        throw new Exception("Expected gamertags to be same");
                    }

                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\UtilTests\UtilTests.cs ===
using System;

using ServerTestFramework;

namespace live.unittests
{
    [TestGroup]
    public partial class UtilTests : UnitTests
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\AddressInforProviderTest.cs ===
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    [TestClass]
    public class AddressInforProviderTest
    {
        [TestMethod]
        public void TestOneAddressExists()
        {
            DataManager dm = new DataManager(CountryId.JP);
            AddressInfoProvider prov = dm.Get<AddressInfoProvider>();
            AddressInfo ai = prov.AddressInfo;
            Assert.AreEqual("Shibuya-ku", ai.City);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\CreditCardProviderTest.cs ===
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    [TestClass]
    public class CreditCardProviderTest
    {
        [TestMethod]
        public void TestApiDesign()
        {
            DataManager dm = new DataManager(CountryId.US);
            CreditCardProvider prov = dm.Get<CreditCardProvider>();
            CreditCardInfo visaForPerson = prov.CardInfoForPerson(CreditCardType.Visa, new PersonalInfo());
            string visaNumber = prov.CardNumber(CreditCardType.Visa);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\AccountsUtilTest.cs ===
using live.client;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using live.common;


namespace live.unittests
{
    [TestClass]
    public class AccountsUtilTest
    {

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod] public void TestAddVisaCard()
        {
            XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
            settings.PersonalInfo = Randomizer.Persons.RegularUserInfo;
            XblUser user = Util.Accounts.CreateLiveAccount(settings);
            string paymentInstrument = Util.Accounts.AddVisaPaymentInstrument(user);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\EnumProviderTest.cs ===
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class EnumProviderTest
    {

        [TestMethod]
        public void TestCreation()
        {
            DataManager dm = new DataManager(CountryId.US);
            EnumDataProvider<TestEnum> prov = dm.Get<EnumDataProvider<TestEnum>>();
            System.Diagnostics.Trace.WriteLine(prov.GenerateValue());
        }

        enum TestEnum
        {
            First,
            Second
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\unittests\UtilTests\PresenceUtilTests.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;

using live.client;
using live.common;
using live.lfm;
using live.server;

using UserMessage = live.protocol.Presence.UserMessage;

namespace live.unittests
{
    public partial class UtilTests
    {
        [TestGroup]
        public class PresenceUtilTests
        {
            /// <summary>
            /// Creates a user with the specified settings.  WARNING: it is the callers responsibility to call
            /// Xbox360.ShutdownConsole() on the returned Xbox360 object prior to disposal
            /// </summary>
            /// <param name="userTier"></param>
            /// <param name="passportType"></param>
            /// <param name="createZuneProfile"></param>
            /// <returns></returns>
            private static Xbox360 CreateUserLoggedOnXbox360(XblUserTier userTier, PassportType passportType, bool createZuneProfile)
            {
                if (passportType == PassportType.Existing)
                {
                    throw new ArgumentException("This method cannot be called with PassportType.Existing", 
                        "passportType");
                }

                // Create the correct default settings
                XblUserSettings settings = new XblUserSettings(userTier, passportType);
                settings.CreateZuneProfile = createZuneProfile;

                // Sign the user up
                Xbox360 xbox360 = new Xbox360();
                XblUser user = xbox360.SignUp.CreateUser(settings);
                xbox360.Live.Logon(user);
                //xbox360.ShutdownConsole();
                return xbox360;
            }

            [TestCase, StressTest]
            public static void MakeFriends()
            {
                XblUser inviter = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                Global.RO.Debug("inviter.Settings.CreatedOn.MachinePuid: 0x{0}; inviter.Puid: 0x{1}",
                    inviter.Settings.CreatedOn.MachinePuid.ToString("X"), inviter.Puid.ToString("X"));
                XblUser invitee = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                Global.RO.Debug("invitee.Settings.CreatedOn.MachinePuid: 0x{0}; invitee.Puid: 0x{1}",
                    invitee.Settings.CreatedOn.MachinePuid.ToString("X"), invitee.Puid.ToString("X"));
                Util.Presence.MakeFriends(inviter, invitee);
            }

            [TestCase, StressTest]
            public static void AddRecentPlayer()
            {
                XblUser user = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                XblUser recentPlayer = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                Util.Presence.AddRecentPlayer(user, recentPlayer);

                /*
                Xbox360 userXbox360 = CreateUserLoggedOnXbox360(XblUserTier.Silver, PassportType.Real, false);
                using (userXbox360)
                {
                    Xbox360 recentPlayerXbox = CreateUserLoggedOnXbox360(XblUserTier.Silver, PassportType.Real, false);
                    using (recentPlayerXbox)
                    {
                        live.server.Presence.AddAffiliate(userXbox360.Client, userXbox360.ActiveUser, recentPlayerXbox.ActiveUser, live.protocol.Presence.AffiliateFlags.CompletedGame);
                        recentPlayerXbox.ShutdownConsole();
                    }
                    userXbox360.ShutdownConsole();
                }
                */
            }

            public static void SendMessage()
            {
                XblUser sender = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                Util.Presence.SendMessage(sender, "Russ123", "Yo mama!");
            }

            [TestCase, StressTest]
            public static void ViewMessage()
            {
                // Create sender and recipient
                XblUser sender = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);
                XblUser recipient = Util.Accounts.CreateLiveAccount(XblUserTier.Silver, PassportType.Real, false);

                // Send message
                Util.Presence.SendMessage(sender, recipient, "Yo mama!");
                System.Threading.Thread.Sleep(2000);
                List<UserMessage> msgs = Util.Presence.ViewMessages(recipient);
                if (msgs.Count == 0)
                {
                    throw new Exception("msgs.Count == 0");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\DateProviderTest.cs ===
using System;
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.common
{
}

namespace live.unittests
{
    [TestClass]
    public class DateProviderTest
    {
        DataManager dm;
        DateProvider prov;

        [TestInitialize]
        public void SetUp()
        {
            dm = new DataManager(CountryId.US);
            prov = dm.Get<DateProvider>();
        }

        [TestMethod]
        public void TestRegularUserBD()
        {
            DateTime dob = prov.UserDateOfBirth;
            DateTime eligible = DateTime.Now.AddYears(-18);
            Assert.IsTrue(dob <= eligible);
        }

        [TestMethod]
        public void TestRestrictedUserBD()
        {
            DateTime dob = prov.RestrictedDateOfBirth;
            DateTime upper = DateTime.Now.AddYears(-13);
            Assert.IsTrue(dob > upper);
        }

        [TestMethod]
        public void TestMinorUserBD()
        {
            DateTime dob = prov.MinorDateOfBirth;
            DateTime upper = DateTime.Now.AddYears(-18);
            DateTime lower = DateTime.Now.AddYears(-13);
            Assert.IsTrue(dob > upper);
            Assert.IsTrue(dob < lower);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\DataManagerTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    [TestClass]
    public class DataManagerTest
    {

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TestCreation()
        {
            IRandom rand = new RealRandom();
            DataManager dm = new DataManager(CountryId.US, rand);
            Assert.AreEqual(CountryId.US, dm.CountryId);
            Assert.AreSame(rand, dm.Random);
        }

        [TestMethod]
        public void TestProviderCreation()
        {
            IRandom r = new RealRandom();
            DataManager dm = new DataManager(CountryId.US, r);
            DummyProvider dummy = dm.Get<DummyProvider>();
            Assert.AreSame(dm, dummy.dataManager);
        }

        [TestMethod]
        public void TestProviderCaching()
        {
            DataManager dm = new DataManager(CountryId.US, new RealRandom());
            Assert.AreSame(dm.Get<DummyProvider>(), dm.Get<DummyProvider>());
        }

        [TestMethod]
        public void TestCreation2()
        {
            DataManager dm = new DataManager(CountryId.US);
            Assert.IsNotNull(dm.Random);
            Assert.IsInstanceOfType(dm.Random, typeof(RealRandom));
        }

        public class DummyProvider : IDataProvider
        {
            public DataManager dataManager;
            public void AttachTo(DataManager dm)
            {
                dataManager = dm;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\LanguageProviderTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    [TestClass]
    public class LanguageProviderTest
    {
        [TestMethod]
        public void Test1()
        {
            DataManager dm = new DataManager(CountryId.US); 
            Assert.AreEqual(LanguageId.en, dm.Get<LanguageProvider>().LiveLanguage);
            dm.CountryId = CountryId.FR;
            Assert.AreEqual(LanguageId.fr, dm.Get<LanguageProvider>().LiveLanguage);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\NameProviderTest.cs ===
using System;
using System.Diagnostics;
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    [TestClass]
    public class NameProviderTest
    {
        private NameProvider provider;
        private DataManager manager = new DataManager(CountryId.US, new RealRandom());

        [TestInitialize]
        public void SetUp()
        {
            manager.CountryId = CountryId.US;
            provider = manager.Get<NameProvider>();
        }

        [TestMethod]
        public void TestGamerTag()
        {
            for (int i = 0; i < 10; i++ )
                Trace.WriteLine("Gamertag <"+provider.Gamertag+">" );
        }

        [TestMethod]
        public void TestName()
        {
            Trace.WriteLine("Name: "+ provider.FirstName + " " + provider.LastName);
            manager.CountryId = CountryId.JP;
            Trace.WriteLine(provider.FirstName + " " +provider.LastName);
        }

        [TestMethod]
        public void TestGenerateDifferentNames()
        {
            Assert.AreNotEqual(provider.FirstName, provider.FirstName);
        }

        [TestMethod]
        public void TestEmail()
        {
            Trace.WriteLine("Email:"+provider.Email);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\PersonalInfoProviderTest.cs ===
using Microsoft.VisualStudio.TestTools.UnitTesting;
using live.common;

namespace live.unittests
{
    [TestClass]
    public class PersonalInfoProviderTest
    {
        [TestMethod]
        public void TestMethod1()
        {
            DataManager dm = new DataManager(CountryId.JP);
            PersonalInfoProvider prov = dm.Get<PersonalInfoProvider>();
            PersonalInfo person = prov.RegularUserInfo;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\VSCodeGenAccessors.cs ===
﻿// ------------------------------------------------------------------------------
//<autogenerated>
//        This code was generated by Microsoft Visual Studio Team System 2005.
//
//        Changes to this file may cause incorrect behavior and will be lost if
//        the code is regenerated.
//</autogenerated>
//------------------------------------------------------------------------------
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
[System.Diagnostics.DebuggerStepThrough()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TestTools.UnitTestGeneration", "1.0.0.0")]
internal class BaseAccessor {
    
    protected Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject m_privateObject;
    
    protected BaseAccessor(object target, Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType type) {
        m_privateObject = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject(target, type);
    }
    
    protected BaseAccessor(Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType type) : 
            this(null, type) {
    }
    
    internal virtual object Target {
        get {
            return m_privateObject.Target;
        }
    }
    
    public override string ToString() {
        return this.Target.ToString();
    }
    
    public override bool Equals(object obj) {
        if (typeof(BaseAccessor).IsInstanceOfType(obj)) {
            obj = ((BaseAccessor)(obj)).Target;
        }
        return this.Target.Equals(obj);
    }
    
    public override int GetHashCode() {
        return this.Target.GetHashCode();
    }
}


[System.Diagnostics.DebuggerStepThrough()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TestTools.UnitTestGeneration", "1.0.0.0")]
internal class live_common_CountriesAccessor : BaseAccessor {
    
    protected static Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType m_privateType = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateType("LiveLib", "live.common.Countries");
    
    internal live_common_CountriesAccessor() : 
            base(m_privateType) {
    }
    
    internal static global::live.common.CountryInfoContainer countriesFile {
        get {
            global::live.common.CountryInfoContainer ret = ((global::live.common.CountryInfoContainer)(m_privateType.GetStaticField("countriesFile")));
            return ret;
        }
        set {
            m_privateType.SetStaticField("countriesFile", value);
        }
    }
    
    internal static object CreatePrivate() {
        object[] args = new object[0];
        Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject priv_obj = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject("LiveLib", "live.common.Countries", new System.Type[0], args);
        return priv_obj.Target;
    }
    
    internal static global::live.common.CountryInfo CountryInfo(byte countryId) {
        object[] args = new object[] {
                countryId};
        global::live.common.CountryInfo ret = ((global::live.common.CountryInfo)(m_privateType.InvokeStatic("CountryInfo", new System.Type[] {
                    typeof(byte)}, args)));
        return ret;
    }
    
    internal static global::live.common.CountryInfo CountryInfo(global::live.common.CountryId countryId) {
        object[] args = new object[] {
                countryId};
        global::live.common.CountryInfo ret = ((global::live.common.CountryInfo)(m_privateType.InvokeStatic("CountryInfo", new System.Type[] {
                    typeof(global::live.common.CountryId)}, args)));
        return ret;
    }
    
    internal static global::live.common.CountryInfo CountryInfo(string countryCode) {
        object[] args = new object[] {
                countryCode};
        global::live.common.CountryInfo ret = ((global::live.common.CountryInfo)(m_privateType.InvokeStatic("CountryInfo", new System.Type[] {
                    typeof(string)}, args)));
        return ret;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\Common\SimpleLog.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.IO;
using System.Text;

namespace TestGateway20.Common
{
    public class SimpleLog
    {
        public enum Rotation
        {
            Daily,
            Hourly,
        }

        private Rotation _frequency;

        public Rotation Frequency
        {
            get { return _frequency; }
        }

        private string _logBase;

        public string LogBase
        {
            get { return _logBase; }
            set { _logBase = value; }
        }

        private FileStream _fileStream;
        private TextWriter _logStream;
        private DateTime _nextRollover;
        private object _lock = new object();
        private TimeSpan _rolloverSpan;

        public SimpleLog(string logBase, Rotation frequency)
        {
            _logBase = logBase;
            _frequency = frequency;

            switch (_frequency)
            {
                case Rotation.Daily:
                    _rolloverSpan = TimeSpan.FromDays(1.0);
                    break;
                case Rotation.Hourly:
                default:
                    _rolloverSpan = TimeSpan.FromHours(1.0);
                    break;
            }

            CalculateNextRollover();
        }

        private void CalculateNextRollover()
        {
            _nextRollover = new DateTime((DateTime.Now.Ticks + _rolloverSpan.Ticks) % _rolloverSpan.Ticks);
        }

        public void Log(string format, params object[] objects)
        {
            string message = string.Format(format, objects);

            lock (_lock)
            {
                DateTime now = DateTime.Now;
                if (now >= _nextRollover)
                {
                    if (_logStream != null)
                    {
                        _logStream.Close();
                        _logStream = null;
                    }
                    if (_fileStream != null && _fileStream.CanWrite)
                    {
                        _fileStream.Close();
                    }
                    CalculateNextRollover();
                }
                if (_fileStream == null || !_fileStream.CanWrite)
                {
                    OpenFile(now);
                }
                _logStream.WriteLine("{0} {1}", now, message);
                _logStream.Flush();
                _fileStream.Flush();
            }
        }

        private void OpenFile(DateTime now)
        {
            string filename = _logBase + "-" + new DateTime(now.Ticks - now.Ticks % _rolloverSpan.Ticks).ToString("yyyymmdd-HH") + ".log";
            _fileStream = File.Open(filename, FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read);
            _fileStream.Seek(0, SeekOrigin.End);
            _logStream = new StreamWriter(_fileStream, Encoding.UTF8);
        }

        

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\XmlSerializationTests.cs ===
using System.Diagnostics;
using System.IO;
using System.Xml.Serialization;
using live.common;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace live.unittests
{
    /// <summary>
    /// Summary description for XmlSerializationTests
    /// </summary>
    [TestClass]
    public class XmlSerializationTests
    {
        [TestMethod]
        public void TestMethod1()
        {
            XmlSerializer sr = new XmlSerializer(typeof(StringArrays));
            TextWriter str = new StringWriter();
            StringArrays sample = new StringArrays();
            sr.Serialize(str, sample);
            Trace.WriteLine(str.ToString());
        }

        [TestMethod]
        public void TestMethodBytes()
        {
            PrintSerialization<Bytes>();
        }

        private static void PrintSerialization<T>() where T : new()
        {
            XmlSerializer sr = new XmlSerializer(typeof(T));
            TextWriter str = new StringWriter();
            T sample = new T();
            sr.Serialize(str, sample);
            Trace.WriteLine(str.ToString());
        }

        [TestMethod]
        public void TestCountries()
        {
            CountryInfo germany = live_common_CountriesAccessor.CountryInfo(CountryId.DE);
            Assert.IsTrue(germany.AllowDirectDebit);
        }

        [TestMethod]
        public void TestAddressInfo()
        {
            PrintSerialization<AddressContainer>();
        }
    }

    public class StringArrays
    {
        public string[] Names = new string[] {"John", "Mary", "Titus", "Carol", "Becky" };
    }

    public class Bytes
    {
        [XmlArray]
        [XmlArrayItem("byte")]
        public byte[] LiveLanguages = new byte[] { 0, 1, 2, 3, 4 };
    }

    public class AddressContainer
    {
        public AddressInfo[] addresses;
        public AddressContainer()
        {
            addresses = new AddressInfo[1];
            addresses[0] = new AddressInfo();
            addresses[0].Street1 = "bla";
            addresses[0].Street2 = "bla bla";
            addresses[0].City = "Redmond";
            addresses[0].PostalCode = "98007";
            addresses[0].State = "WA";
        }
    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\Global.asax.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Net;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;

using StfGlobal = ServerTestFramework.Global;

namespace TestGateway20
{
    public class Global : System.Web.HttpApplication
    {
        static private bool _doWriteEvent = true;

        static public void WriteEvent(string msg)
        {
            if (_doWriteEvent)
            {
                try
                {
                    System.Diagnostics.EventLog appLog = new System.Diagnostics.EventLog();
                    appLog.Source = "TestGateway20";
                    string fullMsg = msg;
                    fullMsg += System.Environment.NewLine;
                    fullMsg += System.Environment.NewLine;
                    fullMsg += "Stack trace:" + System.Environment.NewLine;
                    fullMsg += new System.Diagnostics.StackTrace().ToString();
                    appLog.WriteEntry(fullMsg);
                }
                catch
                {
                    _doWriteEvent = false;
                }
            }
        }

        protected void Application_Start(object sender, EventArgs e)
        {
            live.common.Config.SetFilename(Server.MapPath("livelib.xml"));

            // Setup ServerTestFramework
            ServerTestFramework.Global.Initialize(Server.MapPath("stf.xml"));

            // Direct FakeSG state updates (DeadXbox, etc.) to the real Presence servers
            StfGlobal.FakeSG.SetStateEndpoint(ServerTestFramework.Global.XEnv.GetVirtualInterface("xpnfd_presence").ToString());

            SetBestInternalIP();

            WriteEvent("Global.Application_Start(): Successfully initialized (BestInternalIP: 0x" + BestInternalIP.ToString("X") + ")");
        }

        protected void Application_End(object sender, EventArgs e)
        {
        }


        private static uint _bestInternalIP = 0;
        public static uint BestInternalIP
        {
            get
            {
                return _bestInternalIP;
            }
        }

        private void SetBestInternalIP()
        {
            IPEndPoint presIpEndpoint = live.common.Config.Current.GetIPEndPoint(live.common.XOService.PresNotification);
            IPAddress localIP;
            ServerTestFramework.Utilities.LocalInterface.GetBestMatchByConnecting(presIpEndpoint, out localIP);

            byte[] ipBytes = localIP.GetAddressBytes();
            if (ipBytes.Length == 4)
            {
                uint IP =
                    ((uint)ipBytes[3] << 24) |
                    ((uint)ipBytes[2] << 16) |
                    ((uint)ipBytes[1] << 8) |
                    ((uint)ipBytes[0] << 0);

                _bestInternalIP = IP;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\Unittests2\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UnitTests2")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("UnitTests2")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7c21b087-8983-4219-88b3-76e1d4e62256")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\Common\Global.asax.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Net;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;

using StfGlobal = ServerTestFramework.Global;

namespace TestGateway20
{
    public class Global : System.Web.HttpApplication
    {
        static private bool _doWriteEvent = true;

        static public void WriteEvent(string msg)
        {
            if (_doWriteEvent)
            {
                try
                {
                    System.Diagnostics.EventLog appLog = new System.Diagnostics.EventLog();
                    appLog.Source = "TestGateway20";
                    string fullMsg = msg;
                    fullMsg += System.Environment.NewLine;
                    fullMsg += System.Environment.NewLine;
                    fullMsg += "Stack trace:" + System.Environment.NewLine;
                    fullMsg += new System.Diagnostics.StackTrace().ToString();
                    appLog.WriteEntry(fullMsg);
                }
                catch
                {
                    _doWriteEvent = false;
                }
            }
        }

        protected void Application_Start(object sender, EventArgs e)
        {
            live.common.Config.SetFilename(Server.MapPath("livelib.xml"));

            // Setup ServerTestFramework
            ServerTestFramework.Global.Initialize(Server.MapPath("stf.xml"));

            // Direct FakeSG state updates (DeadXbox, etc.) to the real Presence servers
            StfGlobal.FakeSG.SetStateEndpoint(ServerTestFramework.Global.XEnv.GetVirtualInterface("xpnfd_presence").ToString());

            SetBestInternalIP();

            WriteEvent("Global.Application_Start(): Successfully initialized (BestInternalIP: 0x" + BestInternalIP.ToString("X") + ")");
        }

        protected void Application_End(object sender, EventArgs e)
        {
        }


        private static uint _bestInternalIP = 0;
        public static uint BestInternalIP
        {
            get
            {
                return _bestInternalIP;
            }
        }

        private void SetBestInternalIP()
        {
            IPEndPoint presIpEndpoint = live.common.Config.Current.GetIPEndPoint(live.common.XOService.PresNotification);
            IPAddress localIP;
            ServerTestFramework.Utilities.LocalInterface.GetBestMatchByConnecting(presIpEndpoint, out localIP);

            byte[] ipBytes = localIP.GetAddressBytes();
            if (ipBytes.Length == 4)
            {
                uint IP =
                    ((uint)ipBytes[3] << 24) |
                    ((uint)ipBytes[2] << 16) |
                    ((uint)ipBytes[1] << 8) |
                    ((uint)ipBytes[0] << 0);

                _bestInternalIP = IP;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\FakeSGProxy.asmx.cs ===
using System;
using System.Data;
using System.Web;
using System.Collections;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Configuration;

using TestGateway20.Common;

using ServerTestFramework.LiveService.FakeSG;
using StfGlobal = ServerTestFramework.Global;

namespace TestGateway20.FakeSGProxy
{
    [WebService(Namespace = "http://test.xbox.com/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [ToolboxItem(false)]
    public class FakeSGProxy : System.Web.Services.WebService
    {
        private static SimpleLog _log = new SimpleLog((string)ConfigurationManager.AppSettings["SimpleLogDir"] + @"\FakeSGProxy", SimpleLog.Rotation.Hourly);

        private CSGInfo.ClientType Convert(live.common.ClientType clientType)
        {
            switch (clientType)
            {
                case live.common.ClientType.Xbox:
                    return CSGInfo.ClientType.Xbox;
                case live.common.ClientType.Xenon:
                    return CSGInfo.ClientType.Xenon;
                case live.common.ClientType.XenonBackCompat:
                    return CSGInfo.ClientType.XenonBackCompat;
                case live.common.ClientType.Panorama:
                    return CSGInfo.ClientType.PC;
                default:
                    throw new Exception("Unable to convert " + clientType + " into a valid CSGInfo.ClientType");
            }
        }

        [WebMethod]
        public void LoadSlot(ref CSGInfo sgInfo, ulong xboxId)
        {
            _log.Log("FakeSGProxy.LoadSlot(): xboxId: 0x" + xboxId.ToString("X"));
            StfGlobal.FakeSG.LoadSlot(ref sgInfo, xboxId);
        }

        [WebMethod]
        public void AddXbox(uint sgIp,
                            uint spi,
                            ulong xboxId,
                            uint titleId,
                            uint titleVer,
                            uint titleRegion,
                            byte[] key,
                            ulong clientVersion,
                            live.common.ClientType clientType,
                            uint languageId)
        {
            _log.Log("FakeSGProxy.AddXbox(): sgIp: {0}, spi: {1}, xboxId: 0x{2}, titleId: 0x{3}, titleVer: {4}, titleRegion: {5}, key != null: {6}, clientVersion: {7}, clientType: {8}, languageId: {9}",
                sgIp, spi, xboxId.ToString("X"), titleId.ToString("X"), titleVer, titleRegion, (key != null ? "true" : "false"), clientVersion, clientType, languageId);
            StfGlobal.FakeSG.AddXbox(sgIp, spi, xboxId, titleId, titleVer, titleRegion, key, clientVersion, Convert(clientType), languageId);
        }

        [WebMethod]
        public void RemoveXbox(ulong xboxId)
        {
            _log.Log("FakeSGProxy.RemoveXbox(): xboxId: 0x" + xboxId.ToString("X"));
            StfGlobal.FakeSG.RemoveXbox(xboxId);
        }

        [WebMethod]
        public void DeadXbox(ulong xboxId)
        {
            _log.Log("FakeSGProxy.DeadXbox(): xboxId: 0x" + xboxId.ToString("X"));
            StfGlobal.FakeSG.DeadXbox(xboxId);
        }

        [WebMethod]
        public void ClearXboxes()
        {
            _log.Log("FakeSGProxy.ClearXboxes(): called");
            StfGlobal.FakeSG.ClearXboxes();
        }

        /*
        public void SendNotifyDelete(SGXboxInfo xboxInfo)
        {
            StfGlobal.FakeSG.SendNotifyDelete(xboxInfo);
        }
        */

        [WebMethod]
        public void SetTitle(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            _log.Log("FakeSGProxy.SetTitle(): xboxId: 0x{0}, titleId: 0x{1}, titleVer: {2}, titleRegion: {3}",
                xboxId.ToString("X"), titleId.ToString("X"), titleVer, titleRegion);
            StfGlobal.FakeSG.SetTitle(xboxId, titleId, titleVer, titleRegion);
        }

        [WebMethod]
        public void SetAltTitles(ulong xboxId, uint[] altTitleIds)
        {
            StfGlobal.FakeSG.SetAltTitles(xboxId, altTitleIds);
        }

        [WebMethod]
        public void SetKey(ulong xboxId, byte[] key)
        {
            StfGlobal.FakeSG.SetKey(xboxId, key);
        }

        [WebMethod]
        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            _log.Log("FakeSGProxy.SetUserState(): xboxId: " + xboxId.ToString("X") + "; userId: " + userId.ToString("X") +
                "; state: " + state);
            StfGlobal.FakeSG.SetUserState(xboxId, userId, matchSessionId, state, titleData, titleDataLen);
        }

        [WebMethod]
        public void SetEnableStateBatching(bool enable, uint intervalSeconds)
        {
            StfGlobal.FakeSG.SetEnableStateBatching(enable, intervalSeconds);
        }

        [WebMethod]
        public void SetStateEndpoint(string endpoint)
        {
            _log.Log("FakeSGProxy.SetStateEndpoint(): endpoint: " + endpoint);
            StfGlobal.FakeSG.SetStateEndpoint(endpoint);
        }

        [WebMethod]
        public void AddUser(ulong xboxId, ulong userId, uint userFlags)
        {
            _log.Log("FakeSGProxy.AddUser(): xboxId: 0x{0}, userId: 0x{1}, userFlags: {2}",
                xboxId.ToString("X"), userId.ToString("X"), userFlags);
            StfGlobal.FakeSG.AddUser(xboxId, userId, userFlags);
        }

        [WebMethod]
        public void RemoveUser(ulong xboxId, ulong userId)
        {
            _log.Log("FakeSGProxy.RemoveUser(): xboxId: 0x{0}, userId: 0x{1}",
                xboxId.ToString("X"), userId.ToString("X"));
            StfGlobal.FakeSG.RemoveUser(xboxId, userId);
        }

        [WebMethod]
        public byte GetUserCount(ulong xboxId)
        {
            return StfGlobal.FakeSG.GetUserCount(xboxId);
        }

        [WebMethod]
        public bool ReadUserQValPacket(ulong xboxId, ulong userId, out QValPacket packet)
        {
            _log.Log("FakeSGProxy.ReadUserQValPacket(): xboxId: 0x{0}, userId: 0x{1}",
                xboxId.ToString("X"), userId.ToString("X"));
            return StfGlobal.FakeSG.ReadUserQValPacket(xboxId, userId, out packet);
        }

        [WebMethod]
        public uint GetInaSG()
        {
            return Global.BestInternalIP;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\PerfCounters.cs ===
using System;
using System.Collections;
using System.Diagnostics;

namespace TestGateway20.FakeSGProxy
{
    public class PerfCounters
    {
        public static readonly string CATEGORY_NAME = "TestGateway 2";

        public static void Install()
        {
            ArrayList samplesList = new ArrayList();

            // If the category does not exist, create the category and exit.
            // Performance counters should not be created and immediately used.
            // There is a latency time to enable the counters, they should be created
            // prior to executing the application that uses the counters.
            // Execute this sample a second time to use the category.
            if (SetupCategory())
                return;
            //CreateCounters();
            //CollectSamples(samplesList);
            //CalculateResults(samplesList);
        }

        public static bool SetupCategory()
        {
            if (!PerformanceCounterCategory.Exists(CATEGORY_NAME))
            {
                CounterCreationDataCollection CCDC = new CounterCreationDataCollection();

                // Add the counter.
                CounterCreationData averageCount64 = new CounterCreationData();
                averageCount64.CounterType = PerformanceCounterType.AverageCount64;
                averageCount64.CounterName = "AverageCounter64Sample";
                CCDC.Add(averageCount64);

                // Add the base counter.
                CounterCreationData averageCount64Base = new CounterCreationData();
                averageCount64Base.CounterType = PerformanceCounterType.AverageBase;
                averageCount64Base.CounterName = "AverageCounter64SampleBase";
                CCDC.Add(averageCount64Base);

                // Create the category.
                PerformanceCounterCategory.Create("AverageCounter64SampleCategory",
                    "Demonstrates usage of the AverageCounter64 performance counter type.",
                    PerformanceCounterCategoryType.SingleInstance, CCDC);

                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\SGUserInfo.cs ===
using System;
using System.IO;
using System.Collections;
using System.Diagnostics;

using ServerTestFramework.LiveService.FakeSG;

namespace TestGateway20.FakeSGProxy
{
	public class SGUserInfo
	{
		public const uint MAX_QVAL_QUEUE_SIZE = 1000;

		public ulong  UserId         = 0;
		public uint   UserFlags      = 0;
		public uint   QFlags         = 0;
		public uint   QFlagSeqNum    = 0;
		public ushort Invites        = 0;  
		public uint   InviteSeqNum   = 0;
		public ulong  MatchSessionId = 0;
		public uint   State          = 0;
		public ushort TitleDataLen   = 0; 
		public byte   []TitleData    = new byte[256];
		public Queue  QValPacketQueue = new Queue();


		public SGUserInfo(ulong userId, uint userFlags)
		{
			UserId = userId;
			UserFlags = userFlags;
		}

		/// <summary>
		/// This method is called by the UDP handler to accumulate 
		/// SG qval data on the user object. This will be 'delivered'
		/// via a pull from a STF hosted PNUser object. 
		///
		/// Technically the real SG would accumulate these changes for the
		/// user this method will packetize it so that this process is not lossy.
		/// </summary>
		public bool EnqueueQVals(bool bIsPush, uint [] qvalData)
		{
			if(QValPacketQueue.Count > MAX_QVAL_QUEUE_SIZE)
			{
				return false;
			}

			QValPacket packet = new QValPacket();
			packet.Push = bIsPush;
			packet.Data = qvalData;
			packet.DeliveryTime = DateTime.Now;
			QValPacketQueue.Enqueue(packet);
		
			return true;
		}

		/// <summary>
		/// Read queued qval packets until false is returned.
		/// </summary>
		public bool DequeueQVals(out QValPacket packet)
		{
			if(QValPacketQueue.Count > 0)
			{
				packet = QValPacketQueue.Dequeue() as QValPacket;
				return true;
			}
			else
			{
				packet = null;
				return false;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\SGXBoxInfo.cs ===
using System;
using System.Collections;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace TestGateway20.FakeSGProxy
{
    public class SGXboxInfo
    {
        public uint  SgIp;
        public uint  Spi;
        public ulong XboxId;

        public ulong ClientVersion;
        public CSGInfo.ClientType ClientType = CSGInfo.ClientType.Xbox;

        public SGXboxInfo( uint sgIp, uint spi, ulong xboxId, uint languageId )
        {
            SgIp   = sgIp;
            Spi    = spi;
            XboxId = xboxId;
			LanguageId = languageId;
        }

        public uint  TitleId;
        public uint  TitleVer;
        public uint  TitleRegion;
        public uint  LanguageId;

        public byte[] Key = DefaultKey;
        public static byte[] DefaultKey = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        public static byte[] AnotherKey = {1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4};
		
        public uint[] AltTitles = new uint[4];
        public byte   NumAltTitles = 0;
        public Hashtable users = new Hashtable( 4 );

        public void AddAltTitle( uint id )
        {
            if( NumAltTitles == 4 )
            {
                throw new Exception( "No more alt titles allowed in SGXboxInfo" );
            }
            AltTitles[ NumAltTitles++ ] = id;
        }

        public void ClearAltTitles()
        {
            AltTitles = new uint[4];
            NumAltTitles = 0;
        }

		public SGUserInfo GetUser(ulong userId)
		{
			return GetUser(userId, false);
		}

        public SGUserInfo GetUser(ulong userId, bool mustExist)
        {
            SGUserInfo userInfo = users[userId] as SGUserInfo;
			if(null == userInfo && mustExist)
			{
				throw new Exception("UserId: " + userId.ToString("x") + " was not found for XboxId: " + XboxId.ToString("x"));
			}

			return userInfo;
        }

        public void AddUser( ulong userId, uint userFlags )
        {
			SGUserInfo userInfo = users[userId] as SGUserInfo;
			if(null == userInfo)
			{
            	if( users.Count >= 4 ) 
            	{
                	throw new Exception( "Too many Users in SGXboxInfo" );
            	}
 				userInfo = new SGUserInfo(userId, userFlags);
            	users[ userId ] = userInfo;
			}
			else
			{
				userInfo.UserFlags = userFlags;
			}
        }

        // Title data can represent XBOX 1 title data or Xenon GI data, it is opaque to the SG
        // titleData is a static size array (xenon specifies 256 bytes)
        public void SetUserState(ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            SGUserInfo user = GetUser(userId, true);
            
            // update user state
            user.MatchSessionId   = matchSessionId;
            user.State            = state;
            user.TitleDataLen     = titleDataLen;
            user.TitleData        = titleData;
        }

        public void RemoveUser( ulong userId )
        {
            if(users.Contains(userId))
            {
            	users.Remove( userId );
            }
        }

        public void ResetUser( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);
            
            user.QFlags       = 0; 
            user.QFlagSeqNum  = 0;
            user.Invites      = 0;
            user.InviteSeqNum = 0;
        }

        public uint GetUserQFlag( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);
            
            return user.QFlags;
        }

        public ushort GetUserInvites( ulong userId )
        {
            SGUserInfo user = GetUser(userId, true);

            return user.Invites;
        }

        public void LoadSGInfo( ref CSGInfo sgInfo )
        {
            sgInfo.inaSg = SgIp;
            sgInfo.SpiSg = Spi;

            sgInfo.machinePuid = XboxId;

            sgInfo.titleId      = TitleId;
            sgInfo.titleVersion = TitleVer;
            sgInfo.titleRegion  = TitleRegion;

            sgInfo.clientVersion = ClientVersion;
           	sgInfo.SetClientType(ClientType);

            int i = 0;
            foreach( SGUserInfo userInfo in users.Values )
            {
                switch( i )
                {
                    case 0: 
						sgInfo.userPuid0 = userInfo.UserId; 
						sgInfo.userFlag0 = userInfo.UserFlags;
						break;
                    case 1: 
						sgInfo.userPuid1 = userInfo.UserId; 
						sgInfo.userFlag1 = userInfo.UserFlags;
						break;
                    case 2: 
						sgInfo.userPuid2 = userInfo.UserId; 
						sgInfo.userFlag2 = userInfo.UserFlags;
						break;
                    case 3: 
						sgInfo.userPuid3 = userInfo.UserId; 
						sgInfo.userFlag3 = userInfo.UserFlags; 
						break;
                }
                ++i;
            }
            for( ;i < 4; ++i )
            {
                switch( i )
                {
                    case 0: 
						sgInfo.userPuid0 = 0; 
						sgInfo.userFlag0 = 0; 
						break;
                    case 1: 
						sgInfo.userPuid1 = 0; 
						sgInfo.userFlag1 = 0; 
						break;
                    case 2: 
						sgInfo.userPuid2 = 0; 
						sgInfo.userFlag2 = 0; 
						break;
                    case 3: 
						sgInfo.userPuid3 = 0; 
						sgInfo.userFlag3 = 0; 
						break;
                }
            }
			
            sgInfo.altTitleId0 = AltTitles[0];
            sgInfo.altTitleId1 = AltTitles[1];
            sgInfo.altTitleId2 = AltTitles[2];
            sgInfo.altTitleId3 = AltTitles[3];
			
            sgInfo.SetKey( Key );

            sgInfo.UserExists = 1;
			sgInfo.languageID = (ushort)LanguageId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\FakeSGService.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime.Remoting.Services;

//using ServerTestFramework;
//using ServerTestFramework.Utilities;
//using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.FakeSG;
//using ServerTestFramework.LiveService.PresNotiCommon;

namespace TestGateway20
{
    public unsafe class FakeSGService //: FakeSGBase, IFakeSGRemoteControl
    {
        //private static FakeSGService Singleton;

        // IPs and Port to listen on
        private ArrayList IpList = null;   
        private ushort    Port   = 0xffff; 

        // local interface IP to mmf port tabke mapping
        private Hashtable mmfPortTableOffset = null;

        // Table of Connected Xboxes for QVal processing
        private Hashtable SGXboxInfoSlots = Hashtable.Synchronized(new Hashtable()); 

        // Control Variables    
        private Thread SGThread  = null;  // Message handler thread
        private bool   terminate = false; // Signal for handler thread to terminate

        // Event logging object
        private EventLog Log; 

        // Batched state updates
        private ArrayList  StateUpdateQueue = new ArrayList();
        private IPEndPoint StateEndpoint = null;
		private bool       EnableStateBatching = false;
		private Timer      StateUpdateTimer;

        class StateUpdateItem
        {
            public ulong   XboxId;
            public ulong   UserId;
			public uint    State;
			public ulong   MatchSessionId;
			public byte[]  TitleData;
			public ushort  TitleDataCount;


            public StateUpdateItem(
					ulong   xboxId, 
					ulong   userId, 
					uint    state, 
					ulong   matchSessionId, 
					byte[]  titleData, 
					ushort  titleDataCount)
            {
				TitleData      = new byte[XonPresNoti.MAX_TITLE_DATA_BYTES];
                XboxId         = xboxId;
                UserId         = userId;
				State          = state;
				MatchSessionId = matchSessionId;
				
				uint length = (uint)titleData.Length;
				if(length > XonPresNoti.MAX_TITLE_DATA_BYTES)
				{
                	((FakeSGService) Singleton).Log.WriteEntry("StateUpdateItem: title data truncated to " + XonPresNoti.MAX_TITLE_DATA_BYTES, EventLogEntryType.Error);
                
					length = XonPresNoti.MAX_TITLE_DATA_BYTES;
				}

				// For testing purposes we allow the actual data passed in to exceed count. The packet
				// sent to presence uses a fixed length buffer of MAX_TITLE_DATA_BYTES + PacketMetaData
				Array.Copy(titleData, TitleData, length);
				TitleDataCount = titleDataCount;
            }
        }

        class AsyncHttpRequest
        {
			public String       Resource; 
            public IPEndPoint   Endpoint;
            public MemoryStream Request; // Hdr + Payload
            public MemoryStream Payload;
            public Socket       Socket;
            public int          TotalSent;
            public int          TotalRecv;
            public byte         []RecvBuffer;
            public MemoryStream Response;
            public EventLog     Log; 

            public AsyncHttpRequest()
            {
            }

            public void OnConnect(IAsyncResult result)
            {
                if(!Socket.Connected)
                {
                    Log.WriteEntry("AsyncHttpRequest: Could not connect to: " + Endpoint.ToString(), EventLogEntryType.Error);
                    return;
                }

                StringBuilder hdr = new StringBuilder(128);
                hdr.Append("POST ");
				hdr.Append(Resource);
				hdr.Append(" HTTP/1.0\r\n");

                hdr.Append("Host: ");
                hdr.Append(Endpoint.ToString());
                hdr.Append("\r\n");

                hdr.Append("Content-Length: ");
                hdr.Append(Payload.Length.ToString());
                hdr.Append("\r\n");

                hdr.Append("Connection: close\r\n");
                hdr.Append("Content-Type: xon/1\r\n");
                hdr.Append("User-Agent: 1/0.10.4715\r\n");
                hdr.Append("\r\n");

                byte[] hdrBytes = new ASCIIEncoding().GetBytes(hdr.ToString());

                Request = new MemoryStream();
                Request.Write(hdrBytes, 0, hdrBytes.Length);
                Payload.WriteTo(Request);

                TotalSent = 0;
                Socket.BeginSend(Request.ToArray(), 0, (int)Request.Length, SocketFlags.None, new AsyncCallback(OnSend), this);
            }

            public void OnSend(IAsyncResult result)
            {
                int nbytes = Socket.EndSend(result);
                if(nbytes < 0)
                {
                    Log.WriteEntry("Send Failed to: " + Endpoint.ToString() + ", Total sent: " + TotalSent, EventLogEntryType.Error);
                    return;
                } 

                TotalSent += nbytes;

                if(TotalSent < Request.Length)
                {
                    // Continue sending
                    Socket.BeginSend(Request.ToArray(), (int)TotalSent, (int)(Request.Length - TotalSent), SocketFlags.None,  new AsyncCallback(OnSend), this);
                }
                else
                {
                    // All data sent, recv response
                    Response = new MemoryStream();
                    RecvBuffer = new byte[512];
                    TotalRecv = 0;
                    Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                }
            } 

            public void OnRecv(IAsyncResult result)
            {
                int nbytes = Socket.EndReceive(result);
                if(nbytes == 0)
                {
                    //Log.WriteEntry("Recv remote end closed connection: " + Endpoint.ToString() + "Response:\n" + 
                     //   new ASCIIEncoding().GetString(Response.ToArray()));

					// Close the socket and dicard any time_wait or close_wait data
					LingerOption linger = new LingerOption(false, 0);
					Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, linger);
					Socket.Close();
                }
                else if(nbytes < 0)
                {
                    Log.WriteEntry("Recv failed from " + Endpoint.ToString() + ", Total Bytes: " +  TotalRecv, EventLogEntryType.Error);
                }
                else
                {
                    TotalRecv += nbytes;
                    Response.Write(RecvBuffer, 0, nbytes);
                    Socket.BeginReceive(RecvBuffer, 0, (int)RecvBuffer.Length, SocketFlags.None, new AsyncCallback(OnRecv), this);
                }
            }
        }
        //////////////(uint)/////////////////////////////////////
        /// <summary>
        /// Message Handler Status
        /// </summary>
        public FakeSGState State
        {
            get{ return state; }
        }
        public enum FakeSGState
        {
            NotRunning,
            Starting,
            PortListening,
            ShuttingDown,
            ShutDown,
        }
        private FakeSGState state = FakeSGState.NotRunning;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Numver of messages processed
        /// </summary>
        public int  Connections
        {
            get{ return connections; }
        }
        private int connections = 0;

        ///////////////////////////////////////////////////
        /// <summary>
        /// Exception occured in message handler
        /// </summary>
        public bool ExceptionOcurred
        {
            get{ return exceptionOcurred; }
        }
        private bool exceptionOcurred = false;
        
        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap creation to manage singleton 
        /// </summary>
        public static void Create()
        {
            if( Singleton != null )
            {
                ((FakeSGService) Singleton).Log.WriteEntry( "Attempted Start Abotred.\nService should already be started.", EventLogEntryType.Warning );
            }
            else
            {
                Singleton = new FakeSGService();
                ((FakeSGService) Singleton).Start();
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Wrap destruction to manage singleton 
        /// </summary>
        public static void Destroy()
        {
            if( Singleton == null )
            {
                EventLog log = new EventLog();
                log.Source = "FakeSG";
                log.WriteEntry( "Attempted Stop Abotred.\nService should already be stopped.", EventLogEntryType.Warning );
            }
            else
            {
                ((FakeSGService) Singleton).End();
                Singleton = null;
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Constructor
        /// </summary>
        private FakeSGService()
        {
            // Setup for event logging
            Log = new EventLog();
            Log.Source = "FakeSG";
            Log.WriteEntry( "Beginning Service Initialization..." );

            // Get local interface list
            IpList = FakeSGSocket.FindIPAddresses();
            StringBuilder sb = new StringBuilder( "Local Interfaces detected.  Service will be monitoring:\n" );
            sb.AppendFormat( "Port:  {0:G} (0x{0:X})\nIP Addresses:\n", Port );
            foreach( IPAddress ip in IpList )
            {
                sb.AppendFormat( "   {0}\n", ip );
            }
            Log.WriteEntry( sb.ToString() );
/*            
            // Create new MMF and store the version the service was built with
            SetUpMMF( (int)IpList.Count );
            header->Version = CurrentVersion;
            sb = new StringBuilder( "MMF Created with version "+header->Version );

            // Set up mapping of local interface IP to offset of port table in mmf
            mmfPortTableOffset = new Hashtable( (int)IpList.Count );
            sb.AppendFormat( "\nMapping of IP to offset of first MMF Slot:\n" );
            for( int i = 0; i < (int)IpList.Count; ++i )
            {
                int offset = i * tableSize;
                mmfPortTableOffset[ IpList[i] ] = offset; 
                sb.AppendFormat( "{0} <-- {1}\n", offset, IpList[i] );
            }
            Log.WriteEntry( sb.ToString() );
*/
            // Set up remote controller 
            TcpChannel channel = new TcpChannel( 9900 );
            ChannelServices.RegisterChannel( channel, false );
            
            WellKnownServiceTypeEntry wste = new WellKnownServiceTypeEntry(
                typeof( FakeSGRemoteController ),
                "RemoteFakeSGService", 
                WellKnownObjectMode.Singleton );
            
            RemotingConfiguration.RegisterWellKnownServiceType( wste );

            Log.WriteEntry( "Remoting Configuration Registered" );
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Begin message processing
        /// </summary>
        private void Start()
        {
            if( SGThread != null )
            {
                Log.WriteEntry( "Aborting. Message Handler Already started", EventLogEntryType.Error );
                return;
            }

            Log.WriteEntry( "Starting Message Handler" );
            terminate = false;
            state     = FakeSGState.NotRunning;

            // Start the thread
            SGThread = new Thread( new ThreadStart( FastHandler ) );
            SGThread.Priority = ThreadPriority.Highest;
            SGThread.Start();
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// End message processing 
        /// </summary>
        private void End()
        {
            Log.WriteEntry( "Beginning Service Shutdown..." );
            
            if( SGThread == null )
            {
                Log.WriteEntry( "Aborting. Message Handler Already stopped", EventLogEntryType.Error );
                return;
            }

            Log.WriteEntry( "Stopping Message Handler" );
            state     = FakeSGState.ShuttingDown;
            terminate = true;
                    
            // Wait for Thread to get the message and quit
            int SleepCount = 10;
            while( --SleepCount >= 0 )
            {
                if( SGThread.IsAlive )
                {
                    Thread.Sleep( 200 );
                }
                else
                {
                    break;
                }
            }
            if( SleepCount == -1 )
            {
                Log.WriteEntry( "Message Handler didn't stop when signalled.", EventLogEntryType.Warning );
            }

            SGThread.Abort();
            SGThread = null;

            // Clear out QVal proccesing table
            SGXboxInfoSlots.Clear();
                
            state = FakeSGState.ShutDown;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Message handler thread
        /// </summary>
        void FastHandler()
        {
            Log.WriteEntry( "FastHandler: Starting" );
            try
            {
                state = FakeSGState.Starting;

                FakeSGSocket.Initialize( IpList, Port );

                state = FakeSGState.PortListening;
                IPEndPoint RemoteIpEndPoint = new IPEndPoint( IPAddress.Any, 0 );
                EndPoint remote = RemoteIpEndPoint;

				uint[] qvals = new uint[15];
                byte[] receiveBytes = new byte[ 1000 ];
                while( !terminate )
                {
                    try
                    {
                        ArrayList sockList = FakeSGSocket.CheckReceive( 500000 );

                        if( sockList.Count < 1 )
                            continue;
                        
                        foreach( Socket sock in sockList )
                        {
                            byte[] outArray = new byte[ 1492 ];
        
                            try
                            {
                                FakeSGSocket.Receive( sock, receiveBytes, ref remote );
                            }
                            catch( Exception )
                            {
                                continue;
                            }

                            RemoteIpEndPoint = remote as IPEndPoint;
    
                            Interlocked.Increment( ref connections );
                        
                            IPAddress localIp = ((IPEndPoint)sock.LocalEndPoint).Address;

                            fixed( Byte* b = receiveBytes )
                            {
                                SSgMsgHdr* regHdr = (SSgMsgHdr*) b;
#if THISISOBSOLETE
                                if( regHdr->_wType == (ushort) SGMSG.AUTHDATA_REQ )
                                {
                                    StringBuilder sb = new StringBuilder( "Obsolete AUTHDATA_REQ recieved on local Socket:" );
                                    sb.AppendFormat( " {0}\n", localIp );
                                    Log.WriteEntry( sb.ToString() );
                                }
                                else if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ )
                                {
                                    StringBuilder sb = new StringBuilder( "Obsolete SPIDATA_REQ recieved on local Socket:" );
                                    sb.AppendFormat( " {0}\n", localIp );
                                    Log.WriteEntry( sb.ToString() );
                                } 
                                else if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ2 )
                                {
                                #region Process Spi Data2 Request
                                    
                                    SgMsgSpiReq* req = (SgMsgSpiReq*) b;
                                    
                                    ushort RealPort = (ushort) ((req->_ipportZ>>8) | (req->_ipportZ<<8));
                                    CSGInfo SGInfo = FindSlotByPort( RealPort, localIp );

                                    fixed( byte* outBytes = outArray )
                                    {
                                        SgMsgSpiRep*    SpiRep   = (SgMsgSpiRep*)    outBytes;
                                        SSgMsgSpiData2* SpiData2 = (SSgMsgSpiData2*) (outBytes+sizeof(SgMsgSpiRep));
                                        SAuthData2*     AuthData = (SAuthData2*)     (outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2));
                                        
                                        // Fill Spi Rep data
                                        SpiRep->Header._wType = (ushort)SGMSG.SPIDATA_REP2;
                                        SpiRep->Header._cbEnt = (ushort) sizeof(SgMsgSpiRep);                   // must be real size
                                        SpiRep->_dwReqNum     = req->_dwReqNum;
                                        SpiRep->_ipaZ         = req->_ipaZ;
                                        SpiRep->_ipportZ      = req->_ipportZ;
                                        SpiRep->_fNotFound    = SGInfo.UserNotFound;

                                        // fill AuthDAta2
                                        AuthData->Header._wType    = (ushort)SGMSG.AUTHDATA2;
                                        AuthData->Header._cbEnt    = 184;
                                        AuthData->wAuthDataVersion = 2;
                                        AuthData->wAuthDataSize    = 180;
                                        AuthData->clientVersion    = SGInfo.clientVersion;
                                        AuthData->dwTitleID        = SGInfo.titleId;
                                        AuthData->dwTitleVersion   = SGInfo.titleVersion;
                                        AuthData->dwTitleRegion    = SGInfo.titleRegion;
                                        AuthData->qwXboxID         = SGInfo.machinePuid;

                                        AuthData->user0.flags=SGInfo.userFlag0;
                                        AuthData->user1.flags=SGInfo.userFlag1;
                                        AuthData->user2.flags=SGInfo.userFlag2;
                                        AuthData->user3.flags=SGInfo.userFlag3;

                                        AuthData->user0.puid = SGInfo.userPuid0;
                                        AuthData->user1.puid = SGInfo.userPuid1;
                                        AuthData->user2.puid = SGInfo.userPuid2;
                                        AuthData->user3.puid = SGInfo.userPuid3;
                                        AuthData->dwNumServices= 12;
                                        uint *Services = (uint*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2));
                                        Services[0] = (uint) SGInfo.service0;
                                        Services[1] = (uint) SGInfo.service1;
                                        Services[2] = (uint) SGInfo.service2;
                                        Services[3] = (uint) SGInfo.service3;
                                        Services[4] = (uint) SGInfo.service4;
                                        Services[5] = (uint) SGInfo.service5;
                                        Services[6] = (uint) SGInfo.service6;
                                        Services[7] = (uint) SGInfo.service7;
                                        Services[8] = (uint) SGInfo.service8;
                                        Services[9] = (uint) SGInfo.service9;
                                        Services[10] = (uint) SGInfo.service10;
                                        Services[11] = (uint) SGInfo.service11;
                                                                            
                                        // Trust factores  are set to Zero ;
                                        float *afltTrustFactor = (float*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint)));
                                        afltTrustFactor[0] = SGInfo.userTrust0;
                                        afltTrustFactor[1] = SGInfo.userTrust1;
                                        afltTrustFactor[2] = SGInfo.userTrust2;
                                        afltTrustFactor[3] = SGInfo.userTrust3;

                                        uint *altTitleID = (uint*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint))+(4*sizeof(float)));
                                        altTitleID[0] = SGInfo.altTitleId0;
                                        altTitleID[1] = SGInfo.altTitleId1;
                                        altTitleID[2] = SGInfo.altTitleId2;
                                        altTitleID[3] = SGInfo.altTitleId3;

                                        byte *key = (byte*)(outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2)+sizeof(SAuthData2)+(12*sizeof(uint))+(4*sizeof(float))+(4*sizeof(uint)));
                                        key[0] = SGInfo.key00;
                                        key[1] = SGInfo.key01;
                                        key[2] = SGInfo.key02;
                                        key[3] = SGInfo.key03;
                                        key[4] = SGInfo.key04;
                                        key[5] = SGInfo.key05;
                                        key[6] = SGInfo.key06;
                                        key[7] = SGInfo.key07;
                                        key[8] = SGInfo.key08;
                                        key[9] = SGInfo.key09;
                                        key[10] = SGInfo.key10;
                                        key[11] = SGInfo.key11;
                                        key[12] = SGInfo.key12;
                                        key[13] = SGInfo.key13;
                                        key[14] = SGInfo.key14;
                                        key[15] = SGInfo.key15;

                                        // The commented out SpiData lines below are AuthData elements that so far are not 
                                        // nescessary.  If they become nescessary we will fill them in.
                                        SpiData2->Header._wType=(ushort)SGMSG.SPIDATA2;
                                        SpiData2->Header._cbEnt=(ushort) sizeof(SSgMsgSpiData2);
                                        SpiData2->_fCs             = (byte)1;
                                        
                                        byte[] thisIp = ((IPEndPoint)sock.LocalEndPoint).Address.GetAddressBytes();
                                        uint listenIP = 
                                            ((uint) thisIp[3]<<24) |
                                            ((uint) thisIp[2]<<16) |
                                            ((uint) thisIp[1]<< 8) |
                                            ((uint) thisIp[0]<< 0);
                                        SpiData2->_ipaI            = listenIP;
                                        SpiData2->_ipportI         = Port;

                                        //SpiData2->_liNonce       =
                                        DateTime today             = DateTime.Now;
                                        SpiData2->_liTimeInit      = today.ToFileTime();
                                        //SpiData2->_wFlagsKeyEx   =
                                        //SpiData2->_wVersionKeyEx =
                                        SpiData2->sgaddr.abReserved = 0;
                                        SpiData2->sgaddr.dwSpiSg    = SGInfo.SpiSg;
                                        SpiData2->sgaddr.inaSg      = SGInfo.inaSg;
                                        SpiData2->sgaddr.qwXboxID   = SGInfo.machinePuid;
                                    }
                                    FakeSGSocket.Send( sock, outArray, 262, RemoteIpEndPoint );
                                #endregion
                                }
#endif
                                if( regHdr->_wType == (ushort) SGMSG.SPIDATA_REQ )
                                {
                                    #region Process SpiData Request
                                    // The reply is actually of the form:
                                    // {
                                    //   CSgMsgSpiRep
                                    //   CSgMsgSpiData2
                                    //   CSgMsgHdr+CAuthData[2,3]
                                    // }
                                    SgMsgSpiReq* req = (SgMsgSpiReq*) b;
                                    
                                    ushort RealPort = (ushort) ((req->_ipportZ>>8) | (req->_ipportZ<<8));
                                    CSGInfo SGInfo = FindSlotByPort( RealPort, localIp );

                                    int packetSize = 0;
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SgMsgSpiRep*    SpiRep   = (SgMsgSpiRep*)       outBytes;
                                        SSgMsgSpiData2* SpiData2 = (SSgMsgSpiData2*)    (outBytes+sizeof(SgMsgSpiRep));
                                        SAuthData3*     AuthData = (SAuthData3*)        (outBytes+sizeof(SgMsgSpiRep)+sizeof(SSgMsgSpiData2));
                                                                                
                                        // Fill Spi Rep data
                                        //
                                        SpiRep->Header._wType = (ushort)SGMSG.SPIDATA_REP;
                                        SpiRep->Header._cbEnt = (ushort) sizeof(SgMsgSpiRep);                   // must be real size
                                        SpiRep->_dwReqNum     = req->_dwReqNum;
                                        SpiRep->_ipaZ         = req->_ipaZ;
                                        SpiRep->_ipportZ      = req->_ipportZ;
                                        SpiRep->_fNotFound    = (byte)(SGInfo.UserExists == 0 ? 1 : 0);

                                        // If user doesn't exist, we only send the SgMsgSpiRep back.  I think.
                                        packetSize = sizeof(SgMsgSpiRep);

                                        if (SGInfo.UserExists > 0)
                                        {
                                            // Fill SpiData2 data
                                            //
                                            // The commented out SpiData lines below are AuthData elements that so far are not 
                                            // nescessary.  If they become nescessary we will fill them in.
                                            SpiData2->Header._wType=(ushort)SGMSG.SPIDATA;
                                            SpiData2->Header._cbEnt=(ushort) sizeof(SSgMsgSpiData2);
                                            SpiData2->_fCs             = (byte)1;

                                            if(0 == SGInfo.ipaI)
                                            {
                                                byte[] thisIp = ((IPEndPoint)sock.LocalEndPoint).Address.GetAddressBytes();
                                                uint listenIP = 
                                                    ((uint) thisIp[3]<<24) |
                                                    ((uint) thisIp[2]<<16) |
                                                    ((uint) thisIp[1]<< 8) |
                                                    ((uint) thisIp[0]<< 0);
                                                SpiData2->_ipaI             = listenIP;
                                                SpiData2->_ipportI          = Port;
                                            }
                                            else
                                            {
                                                SpiData2->_ipaI             = SGInfo.ipaI;
                                                SpiData2->_ipportI          = SGInfo.ipportI;
                                            }

                                            SpiData2->_liNonce          = SGInfo.liNonce;
                                            DateTime today              = DateTime.Now;
                                            SpiData2->_liTimeInit       = today.ToFileTime();
                                            //SpiData2->_wFlagsKeyEx    =
                                            //SpiData2->_wVersionKeyEx  =
                                            SpiData2->sgaddr.abReserved = 0;
                                            SpiData2->sgaddr.dwSpiSg    = SGInfo.SpiSg;
                                            SpiData2->sgaddr.inaSg      = SGInfo.inaSg;
                                            SpiData2->sgaddr.qwXboxID   = SGInfo.machinePuid;

                                            // Fill AuthDataHdr data
                                            //
                                            AuthData->Header._wType             = (ushort)SGMSG.AUTHDATA;
                                            AuthData->Header._cbEnt             = (ushort)sizeof(SAuthData3);  // was 184

                                            // Fill AuthData3 data
                                            //
                                            AuthData->wAuthDataVersion = (ushort)3;  // XONLINE_XENON_AUTHDATA_VERSION
                                            AuthData->wAuthDataSize    = (ushort)(sizeof(SAuthData3)-sizeof(SSgMsgHdr));  // was 180
                                            AuthData->clientVersion.wMajorVersion = SGInfo.wMajorVersion;
                                            AuthData->clientVersion.wMinorVersion = SGInfo.wMinorVersion;
                                            AuthData->clientVersion.wBuildNumber = SGInfo.wBuildNumber;
                                            AuthData->clientVersion.wQFENumber = SGInfo.wQFENumber;
                                            AuthData->dwTitleID         = SGInfo.titleId;
                                            AuthData->dwTitleVersion    = SGInfo.titleVersion;
                                            AuthData->dwTitleRegion     = SGInfo.titleRegion;
                                            AuthData->dwConsoleRegion   = SGInfo.consoleRegion;
                                            AuthData->dwMediaID         = SGInfo.mediaID;
                                            AuthData->wLanguageID       = SGInfo.languageID;
                                            AuthData->dwAuthDataFlags   = SGInfo.authDataFlags;

                                            AuthData->wNumPrivileges = SGInfo.wNumPrivileges;
                                            AuthData->dwPrivileges0 = SGInfo.dwPrivileges0;
                                            AuthData->dwPrivileges1 = SGInfo.dwPrivileges1;
                                            AuthData->dwPrivileges2 = SGInfo.dwPrivileges2;
                                            AuthData->dwPrivileges3 = SGInfo.dwPrivileges3;
                                            AuthData->dwPrivileges4 = SGInfo.dwPrivileges4;
                                            AuthData->dwPrivileges5 = SGInfo.dwPrivileges5;
                                            AuthData->dwPrivileges6 = SGInfo.dwPrivileges6;
                                            AuthData->dwPrivileges7 = SGInfo.dwPrivileges7;
                                            
                                            AuthData->qwXboxID          = SGInfo.machinePuid;
                                            AuthData->user0.flags= SGInfo.userFlag0;
                                            AuthData->user1.flags= SGInfo.userFlag1;
                                            AuthData->user2.flags= SGInfo.userFlag2;
                                            AuthData->user3.flags= SGInfo.userFlag3;
                                            AuthData->user0.puid = SGInfo.userPuid0;
                                            AuthData->user1.puid = SGInfo.userPuid1;
                                            AuthData->user2.puid = SGInfo.userPuid2;
                                            AuthData->user3.puid = SGInfo.userPuid3;
                                            
                                            AuthData->afltTrustFactor0 = SGInfo.userTrust0;
                                            AuthData->afltTrustFactor1 = SGInfo.userTrust1;
                                            AuthData->afltTrustFactor2 = SGInfo.userTrust2;
                                            AuthData->afltTrustFactor3 = SGInfo.userTrust3;

                                            AuthData->wNumDwordServices = SGInfo.wNumDwordServices;
                                            AuthData->dwServiceID0 = SGInfo.dwServiceID0;
                                            AuthData->dwServiceID1 = SGInfo.dwServiceID1;
                                            AuthData->dwServiceID2 = SGInfo.dwServiceID2;
                                            AuthData->dwServiceID3 = SGInfo.dwServiceID3;

                                            AuthData->dwAltTitleID0 = SGInfo.altTitleId0;
                                            AuthData->dwAltTitleID1 = SGInfo.altTitleId1;
                                            AuthData->dwAltTitleID2 = SGInfo.altTitleId2;
                                            AuthData->dwAltTitleID3 = SGInfo.altTitleId3;

                                            AuthData->abKey00 = SGInfo.key00;
                                            AuthData->abKey01 = SGInfo.key01;
                                            AuthData->abKey02 = SGInfo.key02;
                                            AuthData->abKey03 = SGInfo.key03;
                                            AuthData->abKey04 = SGInfo.key04;
                                            AuthData->abKey05 = SGInfo.key05;
                                            AuthData->abKey06 = SGInfo.key06;
                                            AuthData->abKey07 = SGInfo.key07;
                                            AuthData->abKey08 = SGInfo.key08;
                                            AuthData->abKey09 = SGInfo.key09;
                                            AuthData->abKey10 = SGInfo.key10;
                                            AuthData->abKey11 = SGInfo.key11;
                                            AuthData->abKey12 = SGInfo.key12;
                                            AuthData->abKey13 = SGInfo.key13;
                                            AuthData->abKey14 = SGInfo.key14;
                                            AuthData->abKey15 = SGInfo.key15;

                                            packetSize = sizeof(SgMsgSpiRep) + sizeof(SSgMsgSpiData2) + sizeof(SAuthData3);
                                        }

                                    }
                                    FakeSGSocket.Send( sock, outArray, packetSize, RemoteIpEndPoint );
                                    #endregion
                                }
                                else if( (regHdr->_wType==(ushort)SGMSG.SET_QVALS_LAZY) || 
                                    (regHdr->_wType==(ushort)SGMSG.SET_QVALS_PUSH) )
                                {
                                    #region Process QVal Request

									bool bIsPushRequest = regHdr->_wType == (ushort)SGMSG.SET_QVALS_PUSH;

                                    SSgMsgSetQValsReq* pRequest = (SSgMsgSetQValsReq*) b;
        
                                    fixed( byte* outBytes = outArray )
                                    {
                                        SSgMsgSetQValsRep* pReply = (SSgMsgSetQValsRep*) outBytes;
                                        pReply->Hdr._wType = (ushort)SGMSG.SET_QVALS_REP;
                                        pReply->Hdr._cbEnt = (ushort)sizeof( SSgMsgSetQValsRep );

                                        pReply->sgaddr  = pRequest->sgaddr;
                                        pReply->UserId  = pRequest->UserId;
                                        pReply->Context = pRequest->Context;

                                        SGXboxInfo xboxInfo = (SGXboxInfo) SGXboxInfoSlots[ pRequest->sgaddr.qwXboxID ];
                                        if( xboxInfo == null )
                                        {
                                            pReply->NotFound = 1;
                                            pReply->NoSuchUser = 1;
                                        }
                                        else
                                        {
                                            pReply->NotFound = 0;
                                            SGUserInfo userInfo = (SGUserInfo) xboxInfo.users[ pRequest->UserId ];
                                            if( userInfo == null )
                                            {
                                                pReply->NoSuchUser = 1;
                                            }
                                            else
                                            {
                                                pReply->NoSuchUser = 0;

												// TODO-jacobr: this is not too desirable but 
												// it will do 
												qvals[0]  = pRequest->QVals.QFlagQVal; 
												qvals[1]  = pRequest->QVals.QFlags;
												qvals[2]  = pRequest->QVals.InviteQVal; 
												qvals[3]  = pRequest->QVals.NewMsgIdsQVal; 
												qvals[4]  = pRequest->QVals.NewMsgId_1;
												qvals[5]  = pRequest->QVals.NewMsgId_2;
												qvals[6]  = pRequest->QVals.NewMsgId_3;

												qvals[7]  = pRequest->QVals.NewMsgDataQVal;
												qvals[8]  = pRequest->QVals.NewMsgData_1;
												qvals[9]  = pRequest->QVals.NewMsgData_2;
												qvals[10] = pRequest->QVals.NewMsgData_3;

												qvals[11] = pRequest->QVals.DelMsgQVal; 
												qvals[12] = pRequest->QVals.DelMsg_1;
												qvals[13] = pRequest->QVals.DelMsg_2;
												qvals[14] = pRequest->QVals.DelMsg_3;
												if(!userInfo.EnqueueQVals(bIsPushRequest, qvals))
												{
                        							Log.WriteEntry("QVal packet queue exceeded for user: " + userInfo.UserId.ToString("x"), EventLogEntryType.Error);
												}

											}
										}
                                    }
                                    FakeSGSocket.Send( sock, outArray, sizeof(SSgMsgSetQValsRep), RemoteIpEndPoint );
                                    #endregion                                                                              
                                }
                            }
                        }
                    }       
                    catch( SocketException ex)
                    {
                        Log.WriteEntry( "FakeSG socket exception.\nNativeErrorCode: 0x"+ex.NativeErrorCode.ToString("X") + "\nMessage: " + ex.Message + "\nStackTrace: " + ex.StackTrace, EventLogEntryType.Error);
                        exceptionOcurred = true;
                    }
                    catch( Exception ex)
                    {
                        Log.WriteEntry("NONFATAL ERROR: FakeSG should never throw an exception:\n" + ex.ToString(), EventLogEntryType.Error);
                        exceptionOcurred = true;
                    }
                }
            }
            finally
            {
                FakeSGSocket.Terminate();
                Log.WriteEntry( "FastHandler: Finished" );
            }
        }

		private void StateUpdateTimerCallback(object state)
		{
			SendUpdateState(true);
		}

		// Called by either the timer drive batch state update 
		// or 
        private void SendUpdateState(bool batching)
        {
			// Provide a lock at the top level of this function to protect config
			// change race conditions and update queue modifications. This function
			// may be called from a system thread driven from the timer
			lock(StateUpdateQueue)
			{

				if(null == StateEndpoint)
				{
					Log.WriteEntry("InternalSendUpdateState: cannot send state update, the state update endpoint has not be specified", EventLogEntryType.Error);
					goto lbDone;
				}

				// This method was called from the wrong place, this isn't a bad thing but
				// indicates either:
				//
				//	- Stale timer which is should expire
				//	- Call from SetUserState() which can be ignored as the timer will kick off
				//		the appropriate call.
				if(EnableStateBatching != batching)
				{
					goto lbDone;
				}

				try
				{
					MemoryStream stream = new MemoryStream();
					CSgMsgNotifyCliUpdate msg = new CSgMsgNotifyCliUpdate();

					// Batch all of the updates into a single stream
					foreach(StateUpdateItem updateItem in StateUpdateQueue)
					{
						// Get the xbox slot information
						SGXboxInfo xbox = SGXboxInfoSlots[updateItem.XboxId] as SGXboxInfo;
						if(xbox == null) 
						{
							Log.WriteEntry("Attempted to write state update for xbox ID: " + 
									updateItem.XboxId.ToString("x") + 
									" which was not found in the slot hash", EventLogEntryType.Error);
							continue;
						}

						// Build the msg
						msg.wType       = (ushort)SGMSG.NOTIFY_CLI_UPD;
						msg.cbEnt       = 310;
						msg.inaSg       = xbox.SgIp;
						msg.dwSpiSg     = xbox.Spi;
						msg.qwXboxID    = xbox.XboxId;
						msg.abReserved  = 0;
						msg.qwUserId    = updateItem.UserId;
						msg.qwMatchSessionId = updateItem.MatchSessionId;
                        if (xbox.ClientType == CSGInfo.ClientType.Xenon)
                        {
                            msg.dwAuthFlags = (uint)CSGInfo.AUTHDATA_FLAGS_ISXENON;
                        }
                        else if (xbox.ClientType == CSGInfo.ClientType.XenonBackCompat)
                        {
                            msg.dwAuthFlags = (uint)CSGInfo.AUTHDATA_FLAGS_ISXENONBACKCOMPAT;
                        }
                        else
                        {
                            msg.dwAuthFlags = 0;
                        }
						msg.dwState 	= updateItem.State;
						msg.dwTitleId 	= xbox.TitleId;
						msg.cbTitleData = updateItem.TitleDataCount;

						// This will never be more than MAX_TITLE_DATA_BYTES
						Array.Copy(updateItem.TitleData, msg.rgbTitleData, updateItem.TitleData.Length);

						// Serialize the header and data 
						msg.WriteStream(stream);

					} // end build up batch state

					// All done with the items in the queue
					StateUpdateQueue.Clear();

					// Send the update to the presence FD state XRL
					AsyncHttpRequest request = new AsyncHttpRequest();
					request.Resource = "/xpnfront/state.ashx";
					request.Log = Log;
					request.Endpoint = StateEndpoint;
					request.Payload = stream;
					request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
					request.Socket.Blocking = false;
					request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
				}
				catch(Exception ex)
				{
					Log.WriteEntry("Error in batch state update: " + ex.ToString(), EventLogEntryType.Error);
				}
			} // end lock(StateUpdateQueue)

lbDone:
			return;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Retries data from shared MMF
        /// </summary>
        /// <param name="port">Port for which data is requested</param>
        /// <param name="localIp">IP of interface requtest came in on</param>
        /// <returns>SPI Auth data</returns>
        private CSGInfo FindSlotByPort( ushort port, IPAddress localIp )
        {
            CSGInfo* pMirror = (CSGInfo*)( slotPtrs + (int)mmfPortTableOffset[ localIp ] );
            return pMirror[ port ];
        }
        
        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get service version
        /// </summary>
        /// <returns>Version number compiled into service</returns>
        public int GetServiceVersion()
        {
            return GetCompiledVersion();
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get number of serviced interfaces
        /// </summary>
        /// <returns>Number of interfaces service is listening on</returns>
        public int GetInterfaceCount()
        {
            return mmfPortTableOffset.Count;
        }
    
        ///////////////////////////////////////////////////
        /// <summary>
        /// Remote Controler to get the interface at a particular offset.  This makes sure the hash
        /// table the client uses to map local IP addresses to mmf slot data is the same as the 
        /// one used by the service.
        /// </summary>
        /// <param name="index">Interface index</param>
        /// <returns></returns>
        public IPAddress GetInterfaceAddress( int offset )
        {
            foreach( IPAddress ip in mmfPortTableOffset.Keys )
            {
                if( (int)mmfPortTableOffset[ ip ] == offset )
                    return ip;
            }
            return IPAddress.None;
        }


        public void LoadSlot( ref CSGInfo sgInfo, ulong xboxId )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox: " + xboxId.ToString("x") + " not found in FakeSG" );
            }
            xbox.LoadSGInfo( ref sgInfo );
        }

        public void AddXbox( 	uint sgIp, 
								uint spi, 
								ulong xboxId, 
								uint titleId, 
								uint titleVer, 
								uint titleRegion, 
								byte[] key, 
								ulong clientVersion,
                                CSGInfo.ClientType clientType, 
								uint languageId )
        {
			SGXboxInfo xbox = SGXboxInfoSlots[xboxId] as SGXboxInfo;

			if(null == xbox)
			{
				xbox = new SGXboxInfo(sgIp, spi, xboxId, languageId);
				SGXboxInfoSlots[xboxId] = xbox;
			}
			else
			{
				// Make sure we update spi
				xbox.SgIp = sgIp;
				xbox.Spi = spi;
				xbox.LanguageId = languageId;
			}

            xbox.TitleId = titleId;
            xbox.TitleVer = titleVer;
            xbox.TitleRegion = titleRegion;
            xbox.Key = key;
            xbox.ClientVersion = clientVersion;
            xbox.ClientType = clientType;
        }

        public void RemoveXbox( ulong xboxId )
        {
			SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
            	SGXboxInfoSlots.Remove(xboxId);
            }
        }

		public void DeadXbox( ulong xboxId )
		{
			SGXboxInfo xboxInfo = SGXboxInfoSlots[xboxId] as SGXboxInfo;

            if(null != xboxInfo)
            {
				SendNotifyDelete(xboxInfo);
				SGXboxInfoSlots.Remove(xboxId);
			}
		}

		public void ClearXboxes()
		{
			try 
			{
				foreach(SGXboxInfo xboxInfo in SGXboxInfoSlots.Values)
				{
					if(xboxInfo == null)
						continue;
					
					SendNotifyDelete(xboxInfo);
					
				}
			}
            catch(Exception ex)
            {
                Log.WriteEntry("Error in ClearXboxes() update: " + ex.ToString(), EventLogEntryType.Error);
            }

			// Clear all slots
			SGXboxInfoSlots.Clear();
		}

		public void SendNotifyDelete(SGXboxInfo xboxInfo)
		{
			MemoryStream stream = new MemoryStream();
			CSgMsgNotifyCliDelete msg = new CSgMsgNotifyCliDelete();

			// Build the msg
			msg.wType           = (ushort)SGMSG.NOTIFY_CLI_DEL;
			msg.cbEnt           = 28; 
			msg.inaSg           = xboxInfo.SgIp;
			msg.dwSpiSg         = xboxInfo.Spi;
			msg.qwXboxId        = xboxInfo.XboxId;
			msg.abReserved      = 0;
			msg.dwTitleId       = xboxInfo.TitleId;

			// Serialize the header and data 
			msg.WriteStream(stream);

			// Send the dead xbox info to the presence FD state XRL
			AsyncHttpRequest request = new AsyncHttpRequest();
			request.Resource = "/xpnfront/deadxbox.ashx";
			request.Log = Log;
			request.Endpoint = StateEndpoint;
			request.Payload = stream;
			request.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			request.Socket.Blocking = false;
			request.Socket.BeginConnect(request.Endpoint, new AsyncCallback(request.OnConnect), request);
		}

        public void SetTitle( ulong xboxId, uint titleId, uint titleVer, uint titleRegion )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in FakeSG" );
            }
            xbox.TitleId     = titleId;
            xbox.TitleVer    = titleVer;
            xbox.TitleRegion = titleRegion;
        }

        public void SetAltTitles( ulong xboxId, uint[] altTitleIds )
        {
            SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
            if( xbox == null ) 
            {
                throw new Exception( "Xbox not found in FakeSG" );
            }
            
            xbox.ClearAltTitles();
            foreach( uint id in altTitleIds )
            {
                xbox.AddAltTitle( id );
            }
        }

        public void SetKey( ulong xboxId, byte[] key )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.Key = key;
        }

        public void SetUserState(ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte []titleData, ushort titleDataLen)
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.SetUserState(userId, matchSessionId, state, titleData, titleDataLen);
            lock (StateUpdateQueue)
            {
                StateUpdateQueue.Add(new StateUpdateItem(xboxId, userId, state, matchSessionId, titleData, titleDataLen));
            }
			SendUpdateState(false);
        }

		public void SetEnableStateBatching(bool enable, uint intervalSeconds)
		{
			if(intervalSeconds > 3600)
			{
				Log.WriteEntry("SetEnableStateBatching: interval times of over an hour not supported");
				goto lbDone;
			}
			
			lock(StateUpdateQueue)
			{
				EnableStateBatching = enable;
			
				if(null != StateUpdateTimer)
				{
					StateUpdateTimer.Dispose();
				}

				if(EnableStateBatching)
				{
					// State updates will now be driven off of a timer which will drain
					// the StateUpdateQueue
					StateUpdateTimer = new Timer(
							new TimerCallback(this.StateUpdateTimerCallback),
							this,
							0,                // start right away
							(int)(intervalSeconds * 1000)); // repeat interval in millis
				}
			}

lbDone:
			return;
		}

        public void SetStateEndpoint(string endpoint)
        {
			lock(StateUpdateQueue)
			{
            	int mark = endpoint.IndexOf(':');
            	if(mark > 0) 
            	{
                	string address = endpoint.Substring(0, mark);
                	string port = endpoint.Substring(mark+1);
                	StateEndpoint = new IPEndPoint(IPAddress.Parse(address), Int16.Parse(port));
            	}
			}
        }

        public void AddUser( ulong xboxId, ulong userId, uint userFlags )
        {
			// This will only add a new user if their UserId does not yet exist on this Xbox
			// else it will just update their flags
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.AddUser( userId, userFlags );
        }

        public void RemoveUser( ulong xboxId, ulong userId )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            xbox.RemoveUser( userId );
        }

        public byte GetUserCount( ulong xboxId )
        {
            SGXboxInfo xbox = LookupXbox(xboxId);
            return (byte) xbox.users.Count;
        }

		public bool ReadUserQValPacket( ulong xboxId, ulong userId, out QValPacket packet )
		{
			SGXboxInfo xbox = LookupXbox(xboxId);
			SGUserInfo user = xbox.GetUser(userId);
			if(user == null)
			{
				packet = null;
				return false;
			}
			else
			{
				return user.DequeueQVals(out packet);
			}
		}

		private SGXboxInfo LookupXbox( ulong xboxId)
		{ 
			SGXboxInfo xbox = (SGXboxInfo)SGXboxInfoSlots[ xboxId ];
			if( xbox == null)
			{
				throw new Exception( "Xbox: " + xboxId.ToString("x") + " not found in FakeSG" );
			}

			return xbox;
		}

        #region SG Message Protocol constants and structures
        private enum SGMSG : ushort
        {
            AUTHDATA_REQ   = 0x4700, // CSgMsgAuthReq
            AUTHDATA_REP   = 0x4701, // CSgMsgAuthRep
            KICK_REQ       = 0x4705, // CSgMsgKickReq
            KICK_REP       = 0x4706, // CSgMsgKickRep
            CLIENT_ADD     = 0x4707, // CSgMsgClient
            CLIENT_DEL     = 0x4708, // CSgMsgClient
            CLIENT_UPD     = 0x4709, // CSgMsgClient
            XBTOXB_FORWARD = 0x470A, // CSgMsgXbToXbForward
            SET_QVALS_LAZY = 0x470B, // CSgMsgSetQValsReq
            SET_QVALS_PUSH = 0x470C, // CSgMsgSetQValsReq
            SET_QVALS_REP  = 0x470D, // CSgMsgSetQValsRep
            //SPIDATA_REQ    = 0x470E, // CSgMsgSpiReq
            //SPIDATA_REP    = 0x470F, // CSgMsgSpiRep
            //AUTHDATA       = 0x4780, // CAuthData in the payload
            //SPIDATA        = 0x4781, // CSgMsgSpiData in the payload
            SPIDATA_REQ    = 0x4710, // CSgMsgSpiReq
            SPIDATA_REP    = 0x4711, // CSgMsgSpiRep2
            NOTIFY_CLI_DEL = 0x4712,  // CSgMsgNotifyCliDelete
            NOTIFY_CLI_UPD = 0x4713,  // CSgMsgNotifyCliUpdate
            NOTIFY_CLI_TCHG= 0x4714,  // CSgMsgNotifyCliTitleChange
            SPIDATA        = 0x4782, // CSgMsgSpiData2 in the payload
            AUTHDATA       = 0x4783  // CAuthData3 in the payload
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgHdr 
        {
            public ushort _wType; // One of SGMSG enumeration
            public ushort _cbEnt; // Size of this entry (including header)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSGAddr
        {
            public uint  inaSg;      // IP address of the SG for the client
            public uint  dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong qwXboxID;   // Unique identifier of client machine account
            public uint  abReserved; // Reserved (must be zero)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthReq
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiReq
        {
            public SSgMsgHdr Header;    
            public uint      _dwReqNum; // Request number from requester
            public uint      _ipaZ;     // IP address of the client on the DMZ
            public ushort    _ipportZ;  // IP port of the client on the DMZ
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiRep
        {
            public SSgMsgHdr Header;
            // Data ------------------------------------------------------------------------------
            public uint   _dwReqNum;  // Copy of _dwReqNum from request
            public uint   _ipaZ;      // IP address of the client on the DMZ
            public ushort _ipportZ;   // IP port of the client on the DMZ
            public byte   _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SgMsgSpiData
        {
            public ushort  _ipportI;      // IP port of the client on the Internet
            public uint    _ipaI;         // IP address of the client on the Internet
            public SSGAddr sgaddr;
            public ushort _wVersionKeyEx; // KeyEx version of the client
            public ushort _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long   _liNonce;       // A random nonce associated with this session
            public long   _liTimeInit;    // FILETIME marking session initiation
            public int    _fCs;           // TRUE if SG is providing connection service
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSpiData2 
        {
            public SSgMsgHdr Header;
            public ushort    _ipportI;       // IP port of the client on the Internet
            public uint      _ipaI;          // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public ushort    _wVersionKeyEx; // KeyEx version of the client
            public ushort    _wFlagsKeyEx;   // Flags sent in KeyEx initiator
            public long      _liNonce;       // A random nonce associated with this session
            public long      _liTimeInit;    // FILETIME marking session initiation
            public int       _fCs;           // TRUE if SG is providing connection services
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData1
        {
            public SSgMsgHdr      Header;
            public ushort         wAuthDataVersion; 
            public ushort         wAuthDataSize; 
            public ulong          clientVersion;
            public uint           dwTitleID;
            public uint           dwTitleVersion;
            public uint           dwTitleRegion;
            public ulong          qwXboxID;
            public SAuthData2User user0;
            public SAuthData2User user1;
            public SAuthData2User user2;
            public SAuthData2User user3;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public ulong            clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public ulong            qwXboxID;
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            public uint             dwNumServices;

            // Arrays are difficult to specify in C#, easier to do this in the fixed{} block above
            //public ushort         dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];  // 12
            //public float          afltTrustFactor[4];
            //public uint           dwAltTitleID[4];
            //public byte           abKey[16];
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData2User
        {
            // The high 16 bits of dwUserFlags should come from the UODB User Table.
            public ulong puid; 
            public uint  flags; 
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SXboxLibraryVersion
        {
            public ushort           wMajorVersion;
            public ushort           wMinorVersion;
            public ushort           wBuildNumber;
            public ushort           wQFENumber;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SAuthData3
        {
            public SSgMsgHdr        Header;
            public ushort           wAuthDataVersion; 
            public ushort           wAuthDataSize; 
            public SXboxLibraryVersion  clientVersion;
            public uint             dwTitleID;
            public uint             dwTitleVersion;
            public uint             dwTitleRegion;
            public uint             dwConsoleRegion;
            public uint             dwMediaID;
            public ushort           wLanguageID;
            public uint             dwAuthDataFlags;
            public ushort           wNumPrivileges;
            //public uint           dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];  // 8
            public uint             dwPrivileges0;
            public uint             dwPrivileges1;
            public uint             dwPrivileges2;
            public uint             dwPrivileges3;
            public uint             dwPrivileges4;
            public uint             dwPrivileges5;
            public uint             dwPrivileges6;
            public uint             dwPrivileges7;
            public ulong            qwXboxID;
            //public XUID           users[XONLINE_MAX_LOGON_USERS];  // 4
            public SAuthData2User   user0;
            public SAuthData2User   user1;
            public SAuthData2User   user2;
            public SAuthData2User   user3;
            //public float          afltTrustFactor[XONLINE_MAX_LOGON_USERS];  // 4
            public float            afltTrustFactor0;
            public float            afltTrustFactor1;
            public float            afltTrustFactor2;
            public float            afltTrustFactor3;
            public ushort           wNumDwordServices;
            //public uint           dwServiceID[XONLINE_MAX_DWORD_SERVICEIDS];  // 4
            public uint             dwServiceID0;
            public uint             dwServiceID1;
            public uint             dwServiceID2;
            public uint             dwServiceID3;
            //public uint           dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID];  // 4
            public uint             dwAltTitleID0;
            public uint             dwAltTitleID1;
            public uint             dwAltTitleID2;
            public uint             dwAltTitleID3;
            //public byte           abKey[XONLINE_KEY_LENGTH];  // 16
            public byte             abKey00;
            public byte             abKey01;
            public byte             abKey02;
            public byte             abKey03;
            public byte             abKey04;
            public byte             abKey05;
            public byte             abKey06;
            public byte             abKey07;
            public byte             abKey08;
            public byte             abKey09;
            public byte             abKey10;
            public byte             abKey11;
            public byte             abKey12;
            public byte             abKey13;
            public byte             abKey14;
            public byte             abKey15;
        };

        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgAuthRep
        {
            public SSgMsgHdr Header;
            public uint      _dwReqNum;  // Copy of _dwReqNum from request
            public uint      _ipaZ;      // IP address of the client on the DMZ
            public ushort    _ipportZ;   // IP port of the client on the DMZ
            public ushort    _ipportI;   // IP port of the client on the Internet
            public uint      _ipaI;      // IP address of the client on the Internet
            public SSGAddr   sgaddr;
            public byte      _fNotFound; // TRUE if client not found (no auth-data enclosed)
        };

        // QVals - Xonline.x over engineers the crap out of these.
        //         In practice they always look like this
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SQVals
        {
            public uint QFlagQVal; // Notification Queue Flags
            public uint QFlags;
            
            public uint InviteQVal; // Boolean (no extra data)

            public uint NewMsgIdsQVal; // The last 3 message IDs that arrived
            public uint NewMsgId_1;
            public uint NewMsgId_2;
            public uint NewMsgId_3;

            public uint NewMsgDataQVal; // Data for the last 3 messages that arrived
            public uint NewMsgData_1;
            public uint NewMsgData_2;
            public uint NewMsgData_3;

            public uint DelMsgQVal; // the last 3 messages deleted
            public uint DelMsg_1;
            public uint DelMsg_2;
            public uint DelMsg_3;
        };

        // QVal Request (From NotiInh)
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;  // SGADDR of the client
            public ulong     UserId;  // User id of the user
            public uint      Context; // Sender's context to be returned in reply
            public SQVals    QVals;   // Turns out this blob at the end always looks the same
        };

        // QVal Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct SSgMsgSetQValsRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;     // SGADDR of the client
            public ulong     UserId;     // User id of the user
            public uint      Context;    // Sender's context from corresponding request
            public byte      NotFound;   // TRUE if client not found
            public byte      NoSuchUser; // TRUE if SG doesn't know about qwUserId
        };

        // Kick Request
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickReq
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr; // SGADDR of the client to kick
        };
        
        // Kick Reply
        [StructLayout(LayoutKind.Sequential, Pack=1)]
            private struct CSgMsgKickRep
        {
            public SSgMsgHdr Hdr;
            public SSGAddr   sgaddr;    // SGADDR of the client that was kicked
            public byte      fNotFound; // TRUE if client not found
        };

        // State update
        private class CSgMsgNotifyCliUpdate  //: WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public ulong     qwUserId;
            public ulong     qwMatchSessionId;
            public uint      dwAuthFlags;  // <- New member
            public uint      dwState;
            public uint      dwTitleId;
            public ushort    cbTitleData;
            //[WireInfo(ArraySize=256)]
            public byte      []rgbTitleData = new byte[256];
        }; 

	 	private class CSgMsgNotifyCliDelete //: WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxId;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwTitleId;
        };
	
		/*TODO-jacobr: stubbed in here in anticipation of m4 integration
		private class CSgMsgNotifyCliTitleChange : WireData
        {
            public ushort    wType;
            public ushort    cbEnt;
            public uint      inaSg;      // IP address of the SG for the client
            public uint      dwSpiSg;    // Pseudo-random identifier assigned by the SG
            public ulong     qwXboxID;   // Unique identifier of client machine account
            public uint      abReserved; // Reserved (must be zero)
            public uint      dwOldTitleId;
            public uint      dwNewTitleId;
        }
		*/
        #endregion 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\UnitTest\UnitTest.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.common;
using live.client;
using live.server;

namespace UnitTest
{
    class UnitTest
    {
        static void Main(string[] args)
        {
            new App().Run();
            Console.Write("Press any key to continue . . . ");
            //Console.Read();
        }
    }

    class App
    {
        private static Xbox360Client GetXbox360Client()
        {
            return new Xbox360Client();
        }

        private static XblUser CreateUser(Xbox360Client client, XblUserTier userType, PassportType passportType)
        {
            XblUserSettings settings = new XblUserSettings(userType, passportType);

            PassportUtils.CreatePassportAccounts(client, settings, true);

            XblUser user;
            uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }

            client.UserLoggingOn(user);
            return user;
        }

        public void Run()
        {
            Xbox360Client client = GetXbox360Client();
            using (client)
            {
                client.BypassKDC = true;
                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\FakeSGProxy\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FakeSG")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("FakeSG")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\WebClientProxy\WebClientProxy.asmx.cs ===
using System;
using System.ComponentModel;
using System.Configuration;
using System.Net;
using System.Web;
using System.Web.Services;

using TestGateway20.Common;

using live.client;
using live.common;

namespace TestGateway20.WebClientProxy
{
    /// <summary>
    /// WebClientProxy provides a remote-accessible interface for programs to access a custom partial implementation of WebClient on the hosting server.
    /// Shorter: it's a proxy service.  Insecurity note: you'd better lock this down in IIS because WebClientProxy will talk to anyone.
    /// </summary>
    [WebService(Namespace = "http://test.xbox.com/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [ToolboxItem(false)]
    public class WebClientProxy : System.Web.Services.WebService
    {
        private static SimpleLog _log = new SimpleLog((string )ConfigurationManager.AppSettings["SimpleLogDir"] + @"\WebProxy", SimpleLog.Rotation.Hourly);

        [WebMethod]
        public uint SendRequest(
            ClientSettings clientSettings,
            TG2SecurityProvider secProv,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            UriBuilder uri = new UriBuilder(relativeUrl);

            string ipAddress = "UNKNOWN";
            DateTime start = DateTime.Now;
            string status = "SUCCESS";
            if (HttpContext.Current != null)
            {
                ipAddress = HttpContext.Current.Request.UserHostAddress;
                start = HttpContext.Current.Timestamp;
            }

            // Reconstruct an appropriate client
            ClientBase client = ClientBase.CreateClient(clientSettings);
            if (client is Xbox360Client)
            {
                ((Xbox360Client)client).BypassKDC = true;
                ((Xbox360Client)client).SupressDispose();
            }
            live.protocol.FDTransaction trans = new live.protocol.FDTransaction();
            trans.SecurityProvider.SecurityInfo = secProv.SecurityInfo;

            uint hr;
            try
            {
                _log.Log("SendRequest: Calling service {0} with client type {1} and secProv type {2} at uri.Path {3}", 
                    (int)service, client.ClientType, trans.SecurityProvider.GetType().Name, uri.Path);
                //hr = client.SendRequest(null, service, uri.Path, httpMethod, webHeaders, request, out response);
                // Use the transaction object we've already prepared
                hr = trans.SendRequest(client, null, service, uri.Path, httpMethod, webHeaders, request, out response);
                status = HResult.XErrToString(hr);
            }
            catch (XrlRequestException xre)
            {
                status = "XrlRequestException: " + xre.Message + " " + xre.StatusCode;
                throw new XrlRequestException(xre.Url, string.Format("Binary Data of length: {0}", xre.PostData.Length), xre.StatusCode,
                    new byte[0], xre.InnerException);
            }
            catch (Exception e)
            {
                status = e.GetType().Name + ": " + e.Message;
                throw;
            }
            finally
            {
                _log.Log("SendRequest: {0} called {1} Elapsed: {2} Status: {3}", ipAddress, uri.Path, new TimeSpan(DateTime.Now.Ticks - start.Ticks), status);
            }
            return hr;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\UnitTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UnitTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("UnitTest")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ff06d132-9760-4cca-862c-34c5396b5862")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Actor.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace ZeroDownTime.Framework
{
    public class Actor
    {
        private Script script;
        private ITransitionSelectionPolicy selectionPolicy;
        
        private Random random;
        
        private State currentState;
        private object globals;

        private volatile Timer delayTimer;

        private volatile Mode mode;

        internal enum Mode
        {
            Run, Stop
        }

        public Actor(Script script, ITransitionSelectionPolicy selectionPolicy)
        {
            this.script = script;
            this.selectionPolicy = selectionPolicy;
            this.currentState = script.StartState;
            this.globals = script.CreateGlobals();
            this.delayTimer = new Timer(Run);
            this.random = new Random();
            this.mode = Mode.Stop;
        }

        public Actor(Script script):this (script, new WeightedTransitionSelectionPolicy())
        {
            
        }

        public State CurrentState
        {
            get { return currentState; }
        }

        public ITransitionSelectionPolicy TransitionSelectionPolicy
        {
            get { return selectionPolicy; }
        }


        public void ExecuteStep()
        {
            Transition chosenTransition = ChooseTransition();

            ExecuteTransition(chosenTransition);
        }

        public void Start()
        {
            lock(delayTimer)
            {
                if (mode == Mode.Run)
                    return;
                
                mode = Mode.Run;
                delayTimer.Change(GetDelay(), Timeout.Infinite);
            }

        }

        public void Pause()
        {
            lock(delayTimer)
            {
                delayTimer.Change(Timeout.Infinite, Timeout.Infinite);
                mode = Mode.Stop;
            }
        }

        private void Run(object obj)
        {
            lock (delayTimer)
            {
                if (mode != Mode.Run)
                    return;

                ExecuteStep();
                delayTimer.Change(GetDelay(), Timeout.Infinite);
            }
        }

        private int GetDelay()
        {
            return random.Next(currentState.MinDelay, currentState.MaxDelay);
        }

        private void ExecuteTransition(Transition chosenTransition)
        {
            
            try
            {
                script.LeaveStateAction(globals);
            }
            catch (Exception e)
            {
                Registry.Exceptions.Add(e);
            }

            try
            {

                if (chosenTransition.Action(globals))
                {
                    currentState = chosenTransition.ToState;
                    chosenTransition.RecordSuccess();
                }
                else
                {
                    chosenTransition.RecordFailure();
                }
            }
            catch (Exception e)
            {
                chosenTransition.RecordFailure();
                Registry.Exceptions.Add(e);
                if (script.TransitionFailureBehavior == TransitionFailureBehavior.Restart)
                {
                    try
                    {
                        script.RestartAction(globals);
                    }
                    catch (Exception ex)
                    {
                        Registry.Exceptions.Add(ex);
                    }

                    currentState = script.StartState;
                }
            }

        }

        private Transition ChooseTransition()
        {
            if (currentState.Transitions.Count == 0)
                throw new InvalidOperationException(
                    String.Format(ExceptionMessages.STATE_HAS_NO_OUTGOING_TRANSITIONS, currentState.Name));
            return selectionPolicy.Select(currentState, globals); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\TestGateway\2.0\WebClientProxy\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Proxy")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Proxy")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\ExceptionMessages.cs ===
namespace ZeroDownTime.Framework
{
    static class ExceptionMessages
    {
        internal const string STATE_NEGATIVE_DELAY_VALUE = "Delay value is negative. Delay value should be positive or equal to 0.";
        internal const string STATE_MIN_GREATER_THAN_MAX = "minDelay value is greater than maxDelay. Specify minDelay value to be less or equal to maxDelay.";

        internal const string ADD_TRANSITION_NONEXISTANT_STATE =
            "Transition {0}:{1}->{2} can not be added because {3} state has not been defined.";

        internal const string STATE_HAS_NO_OUTGOING_TRANSITIONS =
            "State {0} does not have outgoing transitions. Check the script creation code.";

        internal const string VERBOSE_RESULT_HAS_EMPTY_DESCRIPTION = "Failure Description should not be empty or null.";
    }       
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\ApplyingBag.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace ZeroDownTime.Framework
{
    public class ApplyingBag:IChangeBag
    {
        public void Add(IExpectedChange change)
        {
            change.Apply();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\CollectingBag.cs ===
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace ZeroDownTime.Framework
{
    public class CollectingBag : IChangeBag
    {
        private List<IExpectedChange> pendingChecks = new List<IExpectedChange>();

        public void Add(IExpectedChange change)
        {
            lock (pendingChecks)
            {
                pendingChecks.Add(change);
            }
        }

        public IList<IExpectedChange> PendingChanges
        {
            get { return new ReadOnlyCollection<IExpectedChange>(pendingChecks); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\ExpectedSystemState.cs ===
namespace ZeroDownTime.Framework
{
    public class ExpectedSystemState
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\IExpectedChange.cs ===
namespace ZeroDownTime.Framework
{
    public interface IExpectedChange
    {
        void Apply();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\IChangeBag.cs ===
namespace ZeroDownTime.Framework
{
    public interface IChangeBag
    {
        void Add(IExpectedChange change);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\ExceptionStore.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

namespace ZeroDownTime.Framework
{
    public class ExceptionStore
    {
        private Dictionary<Exception, int> exceptions;

        private class ExceptionComparer : IEqualityComparer<Exception>
        {
            public bool Equals(Exception x, Exception y)
            {
                return x.ToString() == y.ToString();
            }

            public int GetHashCode(Exception obj)
            {
                return obj.ToString().GetHashCode();
            }
        }

        public ExceptionStore()
        {
            exceptions = new Dictionary<Exception, int>(new ExceptionComparer());
        }

        public void Add(Exception e)
        {
            lock (exceptions)
            {
                if (Contains(e))
                    this[e]++;
                else 
                    exceptions.Add(e, 1);
            }
        }

        public void Clear()
        {
            lock(exceptions)
            {
                exceptions.Clear();
            }
        }

        public bool Contains(Exception e)
        {
            lock (exceptions)
            {
                return exceptions.ContainsKey(e);
            }
        }

        public int this[Exception s]
        {
            get
            {
                lock (exceptions)
                {
                    return exceptions[s];
                }
            }
            set
            {
                lock (exceptions)
                {
                    exceptions[s] = value;
                }
            }
        }

        public IDictionary<Exception, int> CreateSnapshot()
        {
            lock (exceptions)
            {
                return new Dictionary<Exception, int>(exceptions);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\ITransitionSelectionPolicy.cs ===
namespace ZeroDownTime.Framework
{
    public interface ITransitionSelectionPolicy
    {
        Transition Select(State state, object globals);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Registry.cs ===
namespace ZeroDownTime.Framework
{
    public class Registry
    {
        #region Basic Registry pattern machinery
        private static Registry instance;

        static Registry()
        {
            Initialize(new Registry());
        }

        public static void Initialize(Registry newInstance)
        {
            instance = newInstance;
        }
        #endregion

        #region ZDT specific registry content

        protected ExceptionStore exceptionStore = new ExceptionStore();
        public static ExceptionStore Exceptions
        {
            get { return instance.exceptionStore; }
        }
        
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\SystemStateVerifier.cs ===
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace ZeroDownTime.Framework
{
    public class SystemStateVerifier : IChangeBag
    {
        private List<IExpectedChange> pendingChecks = new List<IExpectedChange>();

        public void Add(IExpectedChange change)
        {
            lock (pendingChecks)
            {
                pendingChecks.Add(change);
            }
        }

        public IList<IExpectedChange> PendingChanges
        {
            get { return new ReadOnlyCollection<IExpectedChange>(pendingChecks); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\TransitionFailureBehavior.cs ===
namespace ZeroDownTime.Framework
{
    public enum TransitionFailureBehavior
    {
        Repeat,
        Restart
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\State.cs ===
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;

namespace ZeroDownTime.Framework
{
    public class State
    {
        public const int MIN_DELAY = 1000;
        public const int MAX_DELAY = 20000;

        private class TransitionCollection: KeyedCollection<string, Transition>
        {
            protected override string GetKeyForItem(Transition item)
            {
                return item.Name;
            }
        }

        private string name;
        TransitionCollection transitions = new TransitionCollection();

        private int minDelay;
        private int maxDelay;

        public State(string name):this (name, MIN_DELAY, MAX_DELAY)
        {
        }

        public State(string name, int minDelay, int maxDelay)
        {
            if (minDelay <0)
                throw new ArgumentException(ExceptionMessages.STATE_NEGATIVE_DELAY_VALUE, "minDelay");
            if (maxDelay < 0)
                throw new ArgumentException(ExceptionMessages.STATE_NEGATIVE_DELAY_VALUE, "maxDelay");
            if (minDelay > maxDelay)
                throw new ArgumentException(ExceptionMessages.STATE_MIN_GREATER_THAN_MAX, "minDelay");
            
            this.name = name;
            this.minDelay = minDelay;
            this.maxDelay = maxDelay;
        }

        public string Name
        {
            get { return name; }
        }

        public IList<Transition> Transitions
        {
            get { return new ReadOnlyCollection<Transition>(transitions); }
        }

        public int MinDelay
        {
            get { return minDelay; }
        }

        public int MaxDelay
        {
            get { return maxDelay; }
        }

        public Transition AddTransition(string transitionName, State toState, Script.Action action)
        {
            return AddTransition(transitionName, toState, Transition.DEFAULT_WEIGHT, action, Script.AlwaysTrue);
        }

        public Transition AddTransition(string transitionName, State toState, int weight, Script.Action action, Script.Action condition)
        {
            Transition t = new Transition(transitionName, toState, weight, action, condition);
            transitions.Add(t);
            return t;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Transition.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace ZeroDownTime.Framework
{
    public class Transition
    {
        internal const int DEFAULT_WEIGHT = 1;
        private string name;
        private State toState;
        private Script.Action action;
        private int weight;
        private Script.Action condition;

        private long successCount;
        private long failureCount;

        public Transition(string name, State toState, int weight, Script.Action action, Script.Action condition)
        {
            this.name = name;
            this.toState = toState;
            this.action = action;
            this.weight = weight;
            this.successCount = 0;
            this.failureCount = 0;
            this.condition = condition;
        }

        public string Name
        {
            get { return name; }
        }

        public State ToState
        {
            get { return toState; }
        }

        public Script.Action Action
        {
            get { return action; }
        }

        public int Weight
        {
            get { return weight; }
        }

        public long SuccessCount
        {
            get {return Interlocked.Read(ref successCount);}
            set {Interlocked.Exchange(ref successCount, value);}
        }

        public long FailureCount
        {
            get { return Interlocked.Read(ref failureCount); }
            set { Interlocked.Exchange(ref failureCount, value); }
        }

        public Script.Action Condition
        {
            get { return condition; }
        }

        public void RecordSuccess()
        {
            Interlocked.Increment(ref this.successCount);
        }

        public void RecordFailure()
        {
            Interlocked.Increment(ref this.failureCount);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\VerboseResult.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace ZeroDownTime.Framework
{
    public class VerboseResult
    {
        private bool successful;
        private string description;
        private static VerboseResult successInstance = new VerboseResult(true, String.Empty);

        public static VerboseResult Success
        {
            get { return successInstance; }
        }

        private VerboseResult(bool success, string description)
        {
            this.successful = success;
            this.description = description;
        }

        public bool Successful
        {
            get { return successful; }
        }

        public string Description
        {
            get { return description; }
        }

        public static VerboseResult CreateFailure(string description)
        {
            if (String.IsNullOrEmpty(description))
                throw new ArgumentException(ExceptionMessages.VERBOSE_RESULT_HAS_EMPTY_DESCRIPTION, "description");

            return new VerboseResult(false, description);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(this,obj)) return true;
            VerboseResult verboseResult = obj as VerboseResult;
            if (verboseResult == null) return false;
            return Equals(successful, verboseResult.successful) && Equals(description, verboseResult.description);
        }

        public override int GetHashCode()
        {
            return successful.GetHashCode()^description.GetHashCode();
        }

        public static bool operator ==(VerboseResult a, VerboseResult b)
        {
            // If both are null, or both are same instance, return true.
            if (ReferenceEquals(a, b))
            {
                return true;
            }

            // If one is null, but not both, return false.
            if (((object)a == null) || ((object)b == null))
            {
                return false;
            }

            // Return true if the fields match:
            return a.successful == b.successful && a.description == b.description;
        }

        public static bool operator !=(VerboseResult a, VerboseResult b)
        {
            return !(a == b);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\WeightedTransitionSelectionPolicy.cs ===
using System;
using System.Collections.Generic;

namespace ZeroDownTime.Framework
{
    public class WeightedTransitionSelectionPolicy : ITransitionSelectionPolicy
    {
        private Random random = new Random();
        public Transition Select(State state, object globals)
        {
            IList<Transition> candidates = SelectCandidates(state, globals);
            int range = CalculateRange(candidates);
            int choice = random.Next(range);
            foreach (Transition t in candidates)
            {
                choice -= t.Weight;
                if (choice < 0)
                    return t;
            }

            return candidates[candidates.Count - 1];
        }

        private static int CalculateRange(IEnumerable<Transition> transitions)
        {
            int range = 0;
            foreach (Transition t in transitions)
                range += t.Weight;
            return range;
        }

        public IList<Transition> SelectCandidates(State state, object globals)
        {
            List<Transition> candidates = new List<Transition>();
            foreach (Transition t in state.Transitions)
                if (t.Condition(globals))
                    candidates.Add(t);
            return candidates;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Script.cs ===
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace ZeroDownTime.Framework
{
    public class Script
    {
        public delegate bool Action(object globals);

        private class StateCollection : KeyedCollection<string, State>
        {
            protected override string GetKeyForItem(State item)
            {
                return item.Name;
            }
        }


        private string name;
        private State startState;
        private StateCollection states = new StateCollection();
        private Action leaveStateAction = NullAction;

        private static bool NullAction(object globals)
        {
            return true;
        }

        private TransitionFailureBehavior transitionFailureBehavior = TransitionFailureBehavior.Repeat;
        private Action restartAction = NullAction;

        public Script (string name)
        {
            this.name = name;
        }

        public string Name
        {
            get { return name; }
        }

        public State StartState
        {
            get { return startState; }
        }

        public IList<State> States
        {
            get { return new ReadOnlyCollection<State>(states); }
        }

        public Action LeaveStateAction
        {
            get { return leaveStateAction; }
            set { leaveStateAction = value; }
        }

        public TransitionFailureBehavior TransitionFailureBehavior
        {
            get { return transitionFailureBehavior; }
            set { transitionFailureBehavior = value; }
        }

        public Action RestartAction
        {
            get { return restartAction; }
            set { restartAction = value; }
        }

        public State AddState(string p)
        {
            return AddState(p, State.MIN_DELAY, State.MAX_DELAY);
        }

        public State AddState(string p, int minDelay, int maxDelay)
        {
            State s = new State(p, minDelay, maxDelay);
            states.Add(s);
            if (startState == null)
            {
                startState = s;
            }
            return s;
        }

        public Transition AddTransition(string transitionName, string fromState, string toState, Action action)
        {
            return AddTransition(transitionName, fromState, toState, Transition.DEFAULT_WEIGHT, action, AlwaysTrue);
        }


        public Transition AddTransition(string transitionName, string fromState, string toState, Action action, Action condition)
        {
            return AddTransition(transitionName, fromState, toState, Transition.DEFAULT_WEIGHT, action, condition);
        }

        public Transition AddTransition(string transitionName, string fromState, string toState, int weight, Action action)
        {
            return AddTransition(transitionName, fromState, toState, weight, action, AlwaysTrue);
        }

        public static bool AlwaysTrue(object globals)
        {
            return true;
        }

        public Transition AddTransition(string transitionName, string fromState, string toState, int weight, Action action, Action condition)
        {
            if (!states.Contains(toState))
                throw new ArgumentException(
                    String.Format(ExceptionMessages.ADD_TRANSITION_NONEXISTANT_STATE, transitionName, fromState, toState,
                                  toState), "toState");
            if (!states.Contains(fromState))
                throw new ArgumentException(
                    String.Format(ExceptionMessages.ADD_TRANSITION_NONEXISTANT_STATE, transitionName, fromState, toState,
                                  toState), "fromState");

            if (action == null)
                throw new ArgumentNullException("action");

            return states[fromState].AddTransition(transitionName, states[toState], weight, action, condition);
        }

        

        public virtual object CreateGlobals()
        {
            return null;
        }
    }

    public class RestartEventArgs : EventArgs
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Counters.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace ZeroDownTime.Framework
{
    public class Counters
    {
        public static readonly string FeedbackCounterCategoryName = "LiveLib Feedback Counter";
        public static readonly string ComplaintCounterName = "Complaint Count";
        public static readonly string ReviewCounterName = "Review Count";
        private PerformanceCounter review;
        private PerformanceCounter complaint;

        public Counters()
        {
            SetupFeedbackCategory();

            review = new PerformanceCounter(FeedbackCounterCategoryName, ReviewCounterName);
            complaint = new PerformanceCounter(FeedbackCounterCategoryName, ComplaintCounterName);
            
            review.ReadOnly = false;
            complaint.ReadOnly = false;

            
        }

        public Counters(int reviewRawValue, int complaintRawValue) : this()
        {
            review.RawValue = reviewRawValue;
            complaint.RawValue = complaintRawValue;
        }


        /// <summary>
        /// Set up the counter category for Feedback Player Review Counts and Complaint Counts.
        /// </summary>
        /// <returns></returns>
        private static bool SetupFeedbackCategory()
        {
            if (!PerformanceCounterCategory.Exists(FeedbackCounterCategoryName))
            {
                CounterCreationDataCollection CCDC = new CounterCreationDataCollection();

                // Add the review counter.
                CounterCreationData reviewCount = new CounterCreationData();
                reviewCount.CounterType = PerformanceCounterType.NumberOfItems32;
                reviewCount.CounterName = ReviewCounterName;
                CCDC.Add(reviewCount);

                // Add the complaint counter.
                CounterCreationData compaintCount = new CounterCreationData();
                compaintCount.CounterType = PerformanceCounterType.NumberOfItems32;
                compaintCount.CounterName = ComplaintCounterName;
                CCDC.Add(compaintCount);

                // Create the category.
                PerformanceCounterCategory.Create(FeedbackCounterCategoryName,
                    "Counts the number of player reviews and complaints during the ZDT Test harness duration.", 
                    PerformanceCounterCategoryType.SingleInstance,
                    CCDC);

                return true;
            }
            else
            {
                return false;
            }
        }

        public void IncrementPlayerReviewCount()
        {
            review.Increment();
        }
        public void IncrementComplaintCount()
        {
            complaint.Increment();
        }

        public int GetPlayerReviewCount()
        {
            return (int)review.NextValue();
        }

        public int GetComplaintCount()
        {
            return (int)complaint.NextValue();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Verifier.cs ===
using System;
using System.Collections.Generic;
using System.IO;

namespace ZeroDownTime.Framework
{
    public class Verifier
    {
        private TextWriter writer;
        private List<Scope> scopes;
  
        public Verifier(TextWriter writer)
        {
            this.writer = writer;
            scopes = new List<Scope>();
        }

        public void Test(object expected, object actual, string name)
        {
            if (!Object.Equals(expected, actual))
            {
                WriteMessage(expected.ToString(), actual.ToString(), name);
            }
        }

        public void Test(DateTime expected, DateTime actual, string name)
        {

            string expectedDT = expected.ToString();
            string actualDT = actual.ToString();

            if (!Object.Equals(expectedDT, actualDT))
            {
                WriteMessage(expected.ToString(), actual.ToString(), name);
            }
        }

        private void WriteMessage(string expected, string actual, string name)
        {
            WriteProlog();
            writer.Write(new string('.', scopes.Count));
            writer.WriteLine("{0}: Expected <{1}>, Actual <{2}>", name, expected, actual);
        }

        private void WriteProlog()
        {
            for (int i = 0; i <scopes.Count;i++)
            {
                if (!scopes[i].Printed)
                {
                    writer.Write(new string('.', i));
                    writer.WriteLine(scopes[i].Name + ":");
                    scopes[i].Printed = true;
                }
            }
        }

        public IDisposable In(string s)
        {
            return new ScopeCreator(s, scopes);
        }

        private class ScopeCreator : IDisposable
        {
            private List<Scope> scopes;

            public ScopeCreator(string s, List<Scope> scopes)
            {
                this.scopes = scopes;
                this.scopes.Add(new Scope(s));
            }

            public void Dispose()
            {
                this.scopes.RemoveAt(scopes.Count-1);
            }
        }

        private class Scope
        {
            public string Name;
            public bool Printed;

            public Scope (string s)
            {
                Name = s;
                Printed = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Globals.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.lfm.xbox360Internal;
using live.common;
using live.protocol;

namespace ZeroDownTime.LiveScenarios
{
    class Globals
    {
        public UserState UserState = new UserState();
        public MarketplaceGlobals Marketplace = new MarketplaceGlobals();
    }

    public class XboxLiveGlobals
    {
        public ProfileGlobals ProfileGlobals = new ProfileGlobals();
        public MatchMakingGlobals MatchMakingGlobals = new MatchMakingGlobals();
        public StatsGlobals StatsGlobals = new StatsGlobals();
    }

    public class MatchMakingGlobals
    {
        public Session Session = null;
        public ulong SessionId;
        public int StartWaitCount = 0;


    }

    public class ProfileGlobals
    {
        public List<Achievement> achievements;
        public List<UserTitle> userTitles;
        public GamercardGlobals gamercardGlobals;
        public string motto;
        public string gamerPicture;
        public int gamerZone;



        public ProfileGlobals()
        {
            achievements = new List<Achievement>();
            userTitles = new List<UserTitle>();
            gamercardGlobals = new GamercardGlobals();
        }
    }

    public class GamercardGlobals
    {
        public GamerProfileScene gamercard;
        public CompareGamesScene games;
        public GameAchievementsScene achievements;
        public FileComplaintScene fileComplaintScene;
        public SubmitPlayerReviewScene playerReviewScene;
        public EditGamerProfileScene editGamercard;


        public void Clear()
        {
            gamercard = null;
            games = null;
            achievements = null;
            fileComplaintScene = null;
            playerReviewScene = null;
            editGamercard = null;
        }
    }

    public class StatsGlobals
    {
        public live.common.StatsBundle stats = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Scenario1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using live.common;
using live.lfm;
using live.lfm.xbox360Internal;
using live.lfm.xbox360Internal.HUD;
using live.protocol.Presence;
using live.server;
using ZeroDownTime.Framework;
using System.Diagnostics;
using live.protocol;
using System.Threading;
using ZeroDownTime.LiveScenarios.TestTitles;

namespace ZeroDownTime.LiveScenarios
{
    public class Scenario1 : Script
    {
        private const int MATCH_MIN_PLAYERS = 2;
        public static readonly uint GAME_TITLE_ID = 0xFFFF0072;
        public static int MaxUsersToCreate = 50;

        public enum StateNames
        {
            Start,
            UserObtained,
            LoggedOn,
            LoggedOnToTitle,
            BrowseMatches,
            MatchSession,
            GamePlay,
            GameResult,

            // Profile
            ViewFriends,
            ViewRecentPlayers,
            ViewingGamercard,
            EditGamercard,
            CompareGames,
            ViewAchievements,



            // Marketplace
            MarketplaceBlade,

            // Marketplace: Acount Mgmt
            AccountManagment,
            DownloadHistoryScene,
            DownloadedContentItemScene,
            DownloadAgain,
            PersonalInfo,
            CurrentSubscriptions,
            CurrentSubscriptionDetails,
            AvailableSubscriptions,
            AvailableSubscriptionDetails,
            PurchaseSubscription,
            ViewPaymentOptions,
            PaymentOptionDetail,
            AddPaymentInstrument,
            RemovePaymentInstrument,
            UpdatePaymentInstrument,
            RedeemPointsCode,
            RedeemSubscriptionsCode,

            // Marketplace: Games
            GamesScene,
            GenresScene,
            GenreScene,
            TitleContentsScene,
            ContentItemPurchaseScene,
            ContentItemPurchase_ConfirmDL,
            ContentItemPurchase_InsufficentPoints,
            ContentItemPurchase_AddPointsWithCode,
            ContentItemPurchase_AddPointsWithCC
        }


        public Scenario1()
            : base("Scenario1")
        {
            TransitionFailureBehavior = TransitionFailureBehavior.Restart;
            AddState(StateNames.Start.ToString());
            AddState(StateNames.UserObtained.ToString());
            AddState(StateNames.LoggedOn.ToString());
            AddState(StateNames.LoggedOnToTitle.ToString());

            // Marketplace
            AddState(StateNames.MarketplaceBlade.ToString());

            // Marketplace: Acount Mgmt
            AddState(StateNames.AccountManagment.ToString());
            AddState(StateNames.DownloadHistoryScene.ToString());
            AddState(StateNames.DownloadedContentItemScene.ToString());
            AddState(StateNames.DownloadAgain.ToString());
            AddState(StateNames.PersonalInfo.ToString());
            AddState(StateNames.CurrentSubscriptions.ToString());
            AddState(StateNames.CurrentSubscriptionDetails.ToString());
            AddState(StateNames.AvailableSubscriptions.ToString());
            AddState(StateNames.AvailableSubscriptionDetails.ToString());
            AddState(StateNames.PurchaseSubscription.ToString());
            AddState(StateNames.ViewPaymentOptions.ToString());
            AddState(StateNames.PaymentOptionDetail.ToString());
            AddState(StateNames.RedeemPointsCode.ToString());
            AddState(StateNames.RedeemSubscriptionsCode.ToString());

            // Marketplace: Games
            AddState(StateNames.GamesScene.ToString());
            AddState(StateNames.GenresScene.ToString());
            AddState(StateNames.GenreScene.ToString());
            AddState(StateNames.TitleContentsScene.ToString());
            AddState(StateNames.ContentItemPurchaseScene.ToString());
            AddState(StateNames.ContentItemPurchase_ConfirmDL.ToString());
            AddState(StateNames.ContentItemPurchase_InsufficentPoints.ToString());
            AddState(StateNames.ContentItemPurchase_AddPointsWithCode.ToString());
            AddState(StateNames.ContentItemPurchase_AddPointsWithCC.ToString());

            // Match
            AddState(StateNames.BrowseMatches.ToString());
            AddState(StateNames.MatchSession.ToString());
            AddState(StateNames.GamePlay.ToString());
            AddState(StateNames.GameResult.ToString());

            //Profile
            AddState(StateNames.ViewingGamercard.ToString());
            AddState(StateNames.EditGamercard.ToString());
            AddState(StateNames.ViewFriends.ToString());
            AddState(StateNames.ViewRecentPlayers.ToString());
            AddState(StateNames.CompareGames.ToString());
            AddState(StateNames.ViewAchievements.ToString());


            #region Login
            AddTransition("GetUser", StateNames.Start.ToString(), StateNames.UserObtained.ToString(), 10, GetNewUser, delegate
                                                                                                                      {
                                                                                                                          return
                                                                                                                              UserState.UsersCreated <=Scenario1.MaxUsersToCreate;
                                                                                                                      });
            AddTransition("GetUserFromPool", StateNames.Start.ToString(), StateNames.UserObtained.ToString(),
                          GetUserFromPool);

            AddTransition("Login", StateNames.UserObtained.ToString(), StateNames.LoggedOn.ToString(), 10, LoginToDashBoard);
            AddTransition("LoginToTitle", StateNames.UserObtained.ToString(), StateNames.LoggedOnToTitle.ToString(), 30, LoginToTitle);
            AddTransition("Logout", StateNames.LoggedOn.ToString(), StateNames.UserObtained.ToString(), 1, Logout);
            AddTransition("LogoutFromTitle", StateNames.LoggedOnToTitle.ToString(), StateNames.UserObtained.ToString(), 1, Logout);
            //AddTransition("ChangeTitle", StateNames.LoggedOnToTitle.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, LoginToTitle);
            AddTransition("ReturnUserToPool", StateNames.UserObtained.ToString(), StateNames.Start.ToString(), 1, ReturnUserToPool);

            #endregion


            #region  Gamer Profile
            //// Gamer Profile
            AddTransition("SendFriendRequest", StateNames.LoggedOnToTitle.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, SendFriendRequest);
            AddTransition("SendGameInvite", StateNames.LoggedOnToTitle.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, SendGameInvite, HasFriends);
            AddTransition("SendMessage", StateNames.LoggedOn.ToString(), StateNames.LoggedOn.ToString(), 3, SendMessage, HasFriends);
            AddTransition("ViewMessages", StateNames.LoggedOn.ToString(), StateNames.LoggedOn.ToString(), 3, ViewMessages);
            AddTransition("ViewFriends", StateNames.LoggedOnToTitle.ToString(), StateNames.ViewFriends.ToString(), 1, ViewFriends);
            AddTransition("ViewGamercardFriend", StateNames.ViewFriends.ToString(), StateNames.ViewingGamercard.ToString(), 2, ViewGamercardFriend, HasFriends);
            AddTransition("outViewFriends", StateNames.ViewFriends.ToString(), StateNames.LoggedOn.ToString(), 1, DoNothing);

            //  AddTransition("ViewRecentPlayers", StateNames.LoggedOnToTitle.ToString(), StateNames.ViewRecentPlayers.ToString(), 1, ViewRecentPlayers, DoesUserHaveRecentPlayers);
            //  AddTransition("ViewGamercardPlayer", StateNames.ViewRecentPlayers.ToString(), StateNames.ViewingGamercard.ToString(), 1, ViewGamercardPlayer);
            //  AddTransition("outViewRecentPlayers", StateNames.ViewRecentPlayers.ToString(), StateNames.LoggedOn.ToString(), 1, DoNothing);
            AddTransition("ViewGamerCard", StateNames.LoggedOnToTitle.ToString(), StateNames.ViewingGamercard.ToString(), 2, ViewGamercard);
            AddTransition("EditGamerProfile", StateNames.ViewingGamercard.ToString(), StateNames.EditGamercard.ToString(), 2, EditGamerProfile);
            AddTransition("EditMotto", StateNames.EditGamercard.ToString(), StateNames.EditGamercard.ToString(), 1, EditMotto);
            AddTransition("EditZone", StateNames.EditGamercard.ToString(), StateNames.EditGamercard.ToString(), 1, EditGamerZone);
            AddTransition("EditGamerPicture", StateNames.EditGamercard.ToString(), StateNames.EditGamercard.ToString(), 1, EditGamerPicture);
            AddTransition("outEditGamerProfile", StateNames.EditGamercard.ToString(), StateNames.ViewingGamercard.ToString(), 1, DoNothing);

            AddTransition("SubmitPlayerReview", StateNames.ViewingGamercard.ToString(), StateNames.ViewingGamercard.ToString(), 2, SubmitPlayerReview, CanSubmitPlayerReview);
            AddTransition("FileComplaint", StateNames.ViewingGamercard.ToString(), StateNames.ViewingGamercard.ToString(), 2, FileComplaint, CanFileComplaint);
            AddTransition("CompareGames", StateNames.ViewingGamercard.ToString(), StateNames.CompareGames.ToString(), 2, CompareGames);
            AddTransition("ViewAchievents", StateNames.CompareGames.ToString(), StateNames.ViewAchievements.ToString(), 2, ViewAchievements, HasGames);
            AddTransition("outOfViewAchievements", StateNames.ViewAchievements.ToString(), StateNames.ViewingGamercard.ToString(), 1, ViewGamercard);
            AddTransition("outCompareGames", StateNames.CompareGames.ToString(), StateNames.LoggedOn.ToString(), 1, DoNothing);
            AddTransition("outGamercard", StateNames.ViewingGamercard.ToString(), StateNames.LoggedOn.ToString(), 1, DoNothing);


            #endregion

            #region Marketplace AddTransitions

            //// Marketplace
            AddTransition("MarketplaceBlade", StateNames.LoggedOn.ToString(), StateNames.MarketplaceBlade.ToString(), 1, MarketplaceBlade);
            AddTransition("outOfMarketplace", StateNames.MarketplaceBlade.ToString(), StateNames.LoggedOn.ToString(), 1, LoginToDashBoard);

            // Marketplace: Acount Mgmt
            AddTransition("AccountManagment", StateNames.LoggedOn.ToString(), StateNames.AccountManagment.ToString(), 1, AccountManagment);
            AddTransition("UpdatePersonalInfo", StateNames.AccountManagment.ToString(), StateNames.PersonalInfo.ToString(), 1, UpdatePersonalInfo);
            AddTransition("ViewCurrentMemberships", StateNames.AccountManagment.ToString(), StateNames.CurrentSubscriptions.ToString(), 1, ViewCurrentMemberships);
            AddTransition("ViewCurrentMembershipDetails", StateNames.CurrentSubscriptions.ToString(), StateNames.CurrentSubscriptionDetails.ToString(), 1, ViewCurrentMembershipDetails);

            AddTransition("DownloadHistoryScene", StateNames.AccountManagment.ToString(), StateNames.DownloadHistoryScene.ToString(), 1, DownloadHistory);
            AddTransition("ReturnToAccountManagmentBlade", StateNames.DownloadHistoryScene.ToString(), StateNames.AccountManagment.ToString(), 1, MarketplaceBlade, UserHasNoDownloadHistory);
            AddTransition("DownloadedContentItemScene", StateNames.DownloadHistoryScene.ToString(), StateNames.DownloadedContentItemScene.ToString(), 1, DownloadedContentItem, UserHasDownloadHistory);
            AddTransition("DownloadAgain", StateNames.DownloadedContentItemScene.ToString(), StateNames.AccountManagment.ToString(), 1, DownloadHistoryItem);

            AddTransition("ViewAvailableMemberships", StateNames.AccountManagment.ToString(), StateNames.AvailableSubscriptions.ToString(), 1, ViewAvailableMemberships);
            AddTransition("ViewMembershipDetails", StateNames.AvailableSubscriptions.ToString(), StateNames.AvailableSubscriptionDetails.ToString(), 1, ViewMembershipDetails);
            AddTransition("PurchaseSubscription", StateNames.AvailableSubscriptionDetails.ToString(), StateNames.PurchaseSubscription.ToString(), 1, PurchaseSubscription, DoesUserHasPI);


            AddTransition("ViewPaymentOptions", StateNames.AccountManagment.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, ViewPaymentOptions);
            AddTransition("PaymentOptionDetail", StateNames.ViewPaymentOptions.ToString(), StateNames.PaymentOptionDetail.ToString(), 1, PaymentOptionDetail, DoesUserHasPI);
       //     AddTransition("RemovePaymentInstrument", StateNames.PaymentOptionDetail.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, RemovePaymentInstrument, CanRemovePI);
            AddTransition("UpdatePaymentInstrument", StateNames.PaymentOptionDetail.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, UpdatePaymentInstrument, DoesUserHasPI);
            AddTransition("AddPaymentInstrument", StateNames.ViewPaymentOptions.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, AddPaymentInstrument);
            //AddTransition("RedeemPointsCode", StateNames.ViewPaymentOptions.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, RedeemPointsCode, CheckPointsCodeLimit);
            //AddTransition("RedeemSubscriptionCode", StateNames.ViewPaymentOptions.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, RedeemSubscriptionCode, CheckSubscriptionCode);
            AddTransition("PurchasePointswithCC", StateNames.ViewPaymentOptions.ToString(), StateNames.ViewPaymentOptions.ToString(), 1, PurchasePointswithCC, CheckPointsAndPI);

            // getting out of Accountmanagment.

            AddTransition("outofAccountManagment1", StateNames.PersonalInfo.ToString(), StateNames.LoggedOn.ToString(), 1, UpdatePersonalInfo);
            AddTransition("outofAccountManagment2", StateNames.CurrentSubscriptions.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofAccountManagment3", StateNames.CurrentSubscriptionDetails.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofAccountManagment4", StateNames.AvailableSubscriptions.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofAccountManagment5", StateNames.AvailableSubscriptionDetails.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofAccountManagment6", StateNames.PurchaseSubscription.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofViewPaymentOptions1", StateNames.ViewPaymentOptions.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);
            AddTransition("outofViewPaymentOptions2", StateNames.PaymentOptionDetail.ToString(), StateNames.LoggedOn.ToString(), 1, AccountManagment);

            // Marketplace: Games
            AddTransition("GamesScene", StateNames.MarketplaceBlade.ToString(), StateNames.GamesScene.ToString(), 1, GamesScene);
            AddTransition("GenresScene", StateNames.GamesScene.ToString(), StateNames.GenresScene.ToString(), 1, GenresScene);
            AddTransition("GenreScene", StateNames.GenresScene.ToString(), StateNames.GenreScene.ToString(), 1, GenreScene);
            AddTransition("ReturnToMarketplaceBlade", StateNames.GenreScene.ToString(), StateNames.MarketplaceBlade.ToString(), 1, MarketplaceBlade, TitlesAreNotAvailable);
            AddTransition("TitleContentsScene", StateNames.GenreScene.ToString(), StateNames.TitleContentsScene.ToString(), 1, TitleContents, TitlesAreAvailable);
            AddTransition("ReturnToMarketplaceBlade", StateNames.TitleContentsScene.ToString(), StateNames.MarketplaceBlade.ToString(), 1, MarketplaceBlade, ContentItemsAreNotAvailable);

            // Marketplace: Content Item Purchase
            AddTransition("ContentItemPurchaseScene", StateNames.TitleContentsScene.ToString(), StateNames.ContentItemPurchaseScene.ToString(), 1, ContentItemPurchase, ContentItemsAreAvailable);
            // Sufficient points
            AddTransition("ContentItemPurchase_ConfirmDL", StateNames.ContentItemPurchaseScene.ToString(), StateNames.ContentItemPurchase_ConfirmDL.ToString(), 10, ContentItemPurchase_ConfirmDL, UserHasSufficientPoints);
            AddTransition("ReturnToMarketplaceBlade", StateNames.ContentItemPurchase_ConfirmDL.ToString(), StateNames.MarketplaceBlade.ToString(), 1, MarketplaceBlade);
            // Insufficient points
            AddTransition("ContentItemPurchase_InsufficentPoints", StateNames.ContentItemPurchaseScene.ToString(), StateNames.ContentItemPurchase_InsufficentPoints.ToString(), 10, ContentItemPurchase_InsufficentPoints, UserHasInsufficientPoints);
            //AddTransition("ContentItemPurchase_AddPointsWithCode", StateNames.ContentItemPurchase_InsufficentPoints.ToString(), StateNames.ContentItemPurchase_ConfirmDL.ToString(), 1, RedeemPointsCode, CheckPointsCodeLimit);
            AddTransition("ContentItemPurchase_AddPointsWithCC", StateNames.ContentItemPurchase_InsufficentPoints.ToString(), StateNames.ContentItemPurchase_ConfirmDL.ToString(), 1, PurchasePointswithCC, CheckPointsAndPI);
            AddTransition("ReturnToMarketplaceBlade", StateNames.ContentItemPurchase_InsufficentPoints.ToString(), StateNames.MarketplaceBlade.ToString(), 1, MarketplaceBlade, CannotPurchaseMorePoints);

            #endregion


            #region Match
            // Match
            AddTransition("CreateSession", StateNames.LoggedOnToTitle.ToString(), StateNames.MatchSession.ToString(), 1, CreateSession, ShouldCreateSession);
            //AddTransition("CreateArbitratedSession", StateNames.LoggedOnToTitle.ToString(), StateNames.MatchSession.ToString(), 1, CreateArbitratedSession, ShouldCreateSession);
            AddTransition("FindMatch", StateNames.LoggedOnToTitle.ToString(), StateNames.BrowseMatches.ToString(), 1, FindMatch);
            AddTransition("JoinMatch", StateNames.BrowseMatches.ToString(), StateNames.MatchSession.ToString(), 2, JoinMatch, CanJoinMatch);
            AddTransition("outBrowseMatches", StateNames.BrowseMatches.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, DoNothing);
            AddTransition("StartSession", StateNames.MatchSession.ToString(), StateNames.GamePlay.ToString(), 2, StartSession, ShouldStartSession);
            AddTransition("WaitForSessionStart", StateNames.MatchSession.ToString(), StateNames.MatchSession.ToString(), 2, Sleep, ShouldWaitSession);
            AddTransition("outWaitForSessionStart", StateNames.MatchSession.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, LeaveSession, ShouldAbortSession);
            AddTransition("EarnAchievement", StateNames.GamePlay.ToString(), StateNames.GamePlay.ToString(), 2, EarnAchievement);
            AddTransition("WaitForSessionEnd", StateNames.GamePlay.ToString(), StateNames.GamePlay.ToString(), 2, Sleep, ShouldWaitSession);
            //AddTransition("outWaitForSessionEnd", StateNames.GamePlay.ToString(), StateNames.LoggedOnToTitle.ToString(), 1, LeaveSession);
            AddTransition("SessionEnd", StateNames.GamePlay.ToString(), StateNames.GameResult.ToString(), 2, EndSession, CanEndSession);
            AddTransition("ViewLeaderboard", StateNames.GameResult.ToString(), StateNames.GameResult.ToString(), 1, ViewLeaderboard);
            AddTransition("DeleteSession", StateNames.GameResult.ToString(), StateNames.LoggedOnToTitle.ToString(), 2, DeleteSession);

            #endregion

            #region Global Actions
            LeaveStateAction = OnLeaveState;
            RestartAction = OnRestart;
            #endregion

            ParseTitles();
        }


        public override object CreateGlobals()
        {
            return new Globals();
        }

        public static void ParseTitles()
        {
            TitleBase titleBase = new TitleBase(GAME_TITLE_ID);

            if (Titles.Default.Title == null || Titles.Default.Title.Count == 0)
            {
                titleBase = new FFFF0072();
                //throw new ApplicationException("No titles have been specified in app.config");
            }
            foreach (string xlastPath in Titles.Default.Title)
            {
                titleBase = new TitleBase(xlastPath);
                titleBase.ParseXlast();
                TitleTable.Instance.Add(titleBase);
            }
        }

        #region Misc Transitions


        private static bool Sleep(object globals)
        {
            Thread.Sleep(5000);
            return true;
        }

        private static bool OnLeaveState(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            if (state == null || state.user == null || state.UserLoggedOn == false)
                return true;
            PNState pn = Presence.GetPresenceForRequest(state.xbox360.Client, state.user);
            IDictionaryEnumerator buddyEnum = pn.BuddyEnumerator;
            while (buddyEnum.MoveNext())
            {
                PNState.BuddyInfo bi = (PNState.BuddyInfo)buddyEnum.Value;
                if (bi.Status == XonPresNoti.P_BUDDY_STATUS_REQUEST)
                {
                    if (bi.User == null)
                        throw new NullReferenceException("blah");
                    pn.AcceptBuddy(bi.User);
                    state.Friends[bi.User.UserId] = true;

                }
                if (bi.Status == XonPresNoti.P_BUDDY_STATUS_ACCEPTED)
                    state.Friends[bi.User.UserId] = true;
            }
            return true;
        }

        private static bool OnRestart(object globals)
        {
            Globals g = globals as Globals;
            if (g.UserState.UserLoggedOn)
            {
                g.UserState.xbox360.Live.Logout(g.UserState.user);
                g.UserState.UserLoggedOn = false;                
            }

            if (g.UserState.user != null)
            {
                UserState.RemoveFromActiveUserState(g.UserState);
                UserState.AddUserStateToPool(g.UserState);
            }
            g.UserState = null;
            return true;
        }

        private static bool DoNothing(object globals)
        {
            return true;
        }


        #endregion

        #region Login Transitions



        private static bool ReturnUserToPool(object globals)
        {
            Globals g = (Globals)globals;
            UserState.RemoveFromActiveUserState(g.UserState);
            UserState.AddUserStateToPool(g.UserState);
            g.UserState = null;

            return true;
        }

        private static bool Logout(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.xbox360.Live.Logout(g.user);
            g.UserLoggedOn = false;
            g.IsDirty = true;
            return true;
        }

        private static bool LoginToDashBoard(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            uint titleId = XOn.DASH_TITLE_ID;
            g.xbox360.Live.Logon(g.user, titleId);
            g.UserLoggedOn = true;
            g.TitleId = titleId;
            g.IsDirty = true;

            return true;
        }




        public static bool LoginToTitle(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            TitleBase titleObj;
            if (!TitleTable.Instance.TryGetTitle(TitleTable.Instance.GetRandomTitleId(), out titleObj))
            {
                throw new ApplicationException("No titles were found.");
            }

            //switch (x)
            //{
            //    case 0:
            //        titleObj = new TitleBase(Titles.Default.Title[0]);
            //        break;
            //    default:
            //        titleObj = new TitleBase(Titles.Default.Title[0]);
            //        //titleObj = new FFFF0072(); //new TitleBase(GAME_TITLE_ID);
            //        break;
            //}
            g.xbox360.Live.Logon(g.user, titleObj);
            g.UserLoggedOn = true;
            
            g.TitleId = titleObj.TitleId;
            g.IsDirty = true;
            return true;
        }

        private static bool GetNewUser(object globals)
        {
            Globals g = globals as Globals;
            g.UserState = new UserState();
            
            g.UserState.user = g.UserState.xbox360.SignUp.CreateUser(new XblUserSettings(XblUserTier.Silver, PassportType.Real));
            Interlocked.Increment(ref UserState.UsersCreated);
            UserState.AddActiveUserState(g.UserState);

            // Subscriptions - used for verification.
            if (g.UserState.SubscriptionStartDate == DateTime.MinValue)
                g.UserState.SubscriptionStartDate = DateTime.UtcNow;
            g.UserState.MonthsINSubRemaining += Offers.GetSubscriptionLength(Offers.BaseOffers.SilverFreeTrial);
            g.UserState.CurrentActiveSubscription = Offers.GetOfferId(Offers.BaseOffers.SilverFreeTrial);
            g.UserState.IsDirty = true;
            return true;

        }

        private static bool GetUserFromPool(object globals)
        {
            Globals g = globals as Globals;
            g.UserState = UserState.GetUserStateFromPool();
            
            if (g.UserState == null)
            {
                return GetNewUser(globals);
            }
            else
            {
                UserState.AddActiveUserState(g.UserState);
                g.UserState.IsDirty = true;
                return true;
            } 

        }



        #endregion

        #region Match

        #region Conditions

        public static bool ShouldStartSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session == null)
            {
                return false;
            }

            if ((g.XboxLiveGlobals.MatchMakingGlobals.Session.InvolvedClientList.Count >= MATCH_MIN_PLAYERS)
                 && (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid))
            {
                return true;
            }
            else
            {
                // Check if session is null because the user might have tried to join, but the slots became full.
                if (g.XboxLiveGlobals.MatchMakingGlobals.Session != null && g.XboxLiveGlobals.MatchMakingGlobals.Session.IsStarted)
                    return true;
                else
                    return false;
            }
        }


        public static bool ShouldWaitSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session == null)
            {
                return false;
            }

            if (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
            {
                if (g.XboxLiveGlobals.MatchMakingGlobals.Session.InvolvedClientList.Count >= MATCH_MIN_PLAYERS)
                {
                // If the actor is the host, and there are enough players, do not wait.
                return false;
                }
            }
            else // Not the host
            {
                // if non-host, don't wait if the Session has been started
                if (g.XboxLiveGlobals.MatchMakingGlobals.Session.IsStarted)
                {
                    return false;
                }
            }
            g.XboxLiveGlobals.MatchMakingGlobals.StartWaitCount++;
            return true;
        }


        public static bool ShouldAbortSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session == null)
            {
                return true;
            }

            if (g.XboxLiveGlobals.MatchMakingGlobals.StartWaitCount > 5)
            {

                return true;
            }
            else
            {
                return false;
            }

        }
        public static bool CanEndSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
            {
                return true;
            }
            else
            {
                // if not host, and session has ended by host, then we can continue to the endsession transition to post stats.
                if (!g.XboxLiveGlobals.MatchMakingGlobals.Session.IsStarted)
                    return true;
                else
                {
                    return false;
                }
            }
        }

        public static bool CanJoinMatch(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            // When in browse matches state, if a match could not be found (sessionID == 0?), then don't join the match.
            return ((g.XboxLiveGlobals.MatchMakingGlobals.Session!=null) && (g.XboxLiveGlobals.MatchMakingGlobals.Session.OpenPublicSlots > 0));
        }

        public static bool ShouldCreateSession(object globals)
        {
            // Check if there are any session's that are waiting for clients.
            //return !SessionTable.Instance.HasSessionsWaitingForPlayers();
            return true;
        }

        public static bool DoesSessionExist(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (SessionTable.Instance.TryGetSession(g.XboxLiveGlobals.MatchMakingGlobals.SessionId, out g.XboxLiveGlobals.MatchMakingGlobals.Session))
                return true;
            else
                return false;
        }



        #endregion 

        #region Transitions

        public static bool CreateSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.MatchMakingGlobals.Session = g.xbox360.Live.Matchmaking.CreateSession(g.user);
            SessionTable.Instance.Add(g.XboxLiveGlobals.MatchMakingGlobals.Session);

            // We will also add the host to the session in this transition.
            g.xbox360.Live.Matchmaking.JoinSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);
            return true;
        }

        public static bool CreateArbitratedSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.MatchMakingGlobals.Session = g.xbox360.Live.Matchmaking.CreateSession(g.user, 4, 0, true);
            SessionTable.Instance.Add(g.XboxLiveGlobals.MatchMakingGlobals.Session);
            // We will also add the host to the session in this transition.
            g.xbox360.Live.Matchmaking.JoinSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);

            return true;
        }

        public static bool FindMatch(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.MatchMakingGlobals.SessionId = 0;
            MatchSearchReply resp = g.xbox360.Live.Matchmaking.FindSession(g.xbox360.ActiveUser);
            // Search for a session that the scenario added.
            if (resp.rgResults != null)
            {
                foreach (SearchResult r in resp.rgResults)
                {
                    // Ideally, we just wnat to select a sessionID from the results, but since sessions are created outside this instance,
                    // we have to check the session table if the session for that session ID exists.  This is redundant in Join Match
                    // which is supposed to do the Session Lookup.
                    SessionTable.Instance.TryGetSession(r.qwSessionId, out g.XboxLiveGlobals.MatchMakingGlobals.Session);
                    if (g.XboxLiveGlobals.MatchMakingGlobals.Session != null)
                    {
                        g.XboxLiveGlobals.MatchMakingGlobals.SessionId = r.qwSessionId;
                        break;
                    }
                }
            }
            return true;
        }


        public static bool JoinMatch(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            // Get the session from globals that maps to the sessionID return by find match.
            if (SessionTable.Instance.TryGetSession(g.XboxLiveGlobals.MatchMakingGlobals.SessionId, out g.XboxLiveGlobals.MatchMakingGlobals.Session))
            {
                lock (g.XboxLiveGlobals.MatchMakingGlobals.Session)
                {
                    if (!g.xbox360.Live.Matchmaking.JoinSession(g.XboxLiveGlobals.MatchMakingGlobals.Session))
                    {
                        // could not join.
                        g.XboxLiveGlobals.MatchMakingGlobals.Session = null;
                        g.XboxLiveGlobals.MatchMakingGlobals.SessionId = 0;
                    }
                }
            }
            // User might want to join a match that was recently deleted by host.
            //else
            //{
            //    throw new ApplicationException(string.Format("Could not find a session with sessionId: {0} in SessionTable", g.XboxLiveGlobals.MatchMakingGlobals.SessionId));
            //}
            return true;
        }

        public static bool StartSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.MatchMakingGlobals.StartWaitCount = 0; 
            // Only the host (Creator of session) should call StartSesssion
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
            {
                lock (g.XboxLiveGlobals.MatchMakingGlobals.Session)
                {
                    g.xbox360.Live.Matchmaking.StartSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);
                }
            }
            return true;
        }

        public static bool EndSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            lock (g.XboxLiveGlobals.MatchMakingGlobals.Session)
            {
                // Only generate the stats once and have all users post the same stats.
                if (g.XboxLiveGlobals.MatchMakingGlobals.Session.Stats == null && g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
                {
                    
                    live.common.StatsBundle stats = g.xbox360.Client.TitleObject.GenerateStatsBundle(g.user);
                    TitleBase title = new TitleBase(g.xbox360.Client.TitleId);
                    //live.common.StatsBundle stats = title.GenerateStatsBundle(g.user);
                    g.XboxLiveGlobals.MatchMakingGlobals.Session.Stats = stats;
                    g.xbox360.Live.Matchmaking.EndSession(g.XboxLiveGlobals.MatchMakingGlobals.Session, stats);

                }

                
            }

            return true;
        }



        public static bool LeaveSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session != null)
            {
                lock (g.XboxLiveGlobals.MatchMakingGlobals.Session)
                {
                    if (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
                    {
                        g.xbox360.Live.Matchmaking.DeleteSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);
                        SessionTable.Instance.Remove(g.XboxLiveGlobals.MatchMakingGlobals.Session.SessionId);
                    }
                    else
                    {
                        // The host may have deleted the session, so check that the session still exists before trying to leave.
                        if (SessionTable.Instance.TryGetSession(g.XboxLiveGlobals.MatchMakingGlobals.Session.SessionId, out g.XboxLiveGlobals.MatchMakingGlobals.Session))
                        {
                            g.xbox360.Live.Matchmaking.LeaveSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);
                        }
                    }
                }
            }
            g.XboxLiveGlobals.MatchMakingGlobals.SessionId = 0;
            return true;
        }

        public static bool DeleteSession(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.XboxLiveGlobals.MatchMakingGlobals.Session.HostingClient.MachinePuid == g.xbox360.Client.MachinePuid)
            {
                lock (g.XboxLiveGlobals.MatchMakingGlobals.Session)
                {
                    g.xbox360.Live.Matchmaking.DeleteSession(g.XboxLiveGlobals.MatchMakingGlobals.Session);
                    SessionTable.Instance.Remove(g.XboxLiveGlobals.MatchMakingGlobals.Session.SessionId);
                    g.XboxLiveGlobals.MatchMakingGlobals.Session = null;
                }
            }
            g.XboxLiveGlobals.MatchMakingGlobals.SessionId = 0;
            
            return true;
        }

        public static bool ViewLeaderboard(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            StatsSpec[] statsSpecs = new StatsSpec[1];
            StatsSpec statsSpec = new StatsSpec();
            uint[] keys = new uint[g.xbox360.Client.TitleObject.Leaderboards.Count];
            g.xbox360.Client.TitleObject.Leaderboards.Keys.CopyTo(keys, 0);
            statsSpec.ViewId = g.xbox360.Client.TitleObject.Leaderboards[keys[ScenarioUtil.GetRandomNumber(g.xbox360.Client.TitleObject.Leaderboards.Count)]].LeaderBoardId;
            
            statsSpecs[0] = statsSpec;

            StatsEnumResponse resp = g.xbox360.Live.Stats.StatsEnumByRank(statsSpecs, (ulong)1);
            resp = g.xbox360.Live.Stats.StatsEnumByRating(statsSpecs, (ulong)1);
            resp = g.xbox360.Live.Stats.StatsEnumByUser(statsSpecs, g.user.Puid);
            return true;
        }


        public static bool SendGameInvite(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            ulong target = PickOne(g.Friends);
            PNState pn = Presence.GetPresenceForRequest(g.xbox360.Client, g.user);
            PNState targetPn = Presence.GetPresence(new XblUser(target, "blah"));
            pn.Invite(new PNState[] { targetPn }, 42);
            return true;
        }


        public static bool EarnAchievement(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            //g.xbox360.Live.Play(g.xbox360.Client.TitleObject);

            // TODO: figure out which achievement they earned.

            live.protocol.Achievement[] achievements = new live.protocol.Achievement[1];
            if (g.xbox360.Client.TitleObject.Achievements.Count > 0)
            {
                int select = ScenarioUtil.GetRandomNumber(g.xbox360.Client.TitleObject.Achievements.Count);
                achievements[0] = new live.protocol.Achievement(g.xbox360.Client.TitleObject.Achievements[select].AchievementId, DateTime.UtcNow, (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED);
                g.xbox360.Live.Profile.SyncAchievements(Scenario1.GAME_TITLE_ID, achievements);
                g.XboxLiveGlobals.ProfileGlobals.achievements.Add(achievements[0]);
            }
            else
            {
                // I'm not sure how there are no achievements so adding this exception to help debug.
                throw new ApplicationException(string.Format("TitleId {0} does not have any achievements.", g.xbox360.Client.TitleObject.TitleId));
            }
            return true;
        }

        #endregion Transitions
        #endregion

        #region Community Transitions

        private static bool CanFileComplaint(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            // User cannot review themself, OR cannot review more than 10 times because of limit exceed exception.
            //if ( (g.xbox360.ActiveUser.Puid == g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid)
            //    ||(g.FeedbackComplaints.ContainsKey(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid)
            //        && (g.FeedbackComplaints[g.xbox360.Live.Profile.GamerProfileScene.GamerPuid] > 10) ) )
            if ((g.xbox360.ActiveUser.Puid == g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid)
                || (g.FeedbackComplaints.ContainsKey(g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid))
                || (g.FeedbackComplaints.Count > 10))
            {
                return false;
            }
            return true;
        }

        private static bool CanSubmitPlayerReview(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            // User cannot review themself, OR cannot review more than 10 times because of limit exceed exception.
            //if ((g.xbox360.ActiveUser.Puid == g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid)
            //    || (g.FeedbackReviews.ContainsKey(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid)
            //        && (g.FeedbackReviews[g.xbox360.Live.Profile.GamerProfileScene.GamerPuid] > 10)))
            if ( (g.xbox360.ActiveUser.Puid == g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid)
                || (g.FeedbackReviews.ContainsKey(g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid))
                || (g.FeedbackReviews.Count > 10) )
               
            {
                return false;
            }
            return true;
        }

        private static ulong PickOne(Dictionary<ulong, bool> users)
        {
            ulong[] friends = new ulong[users.Keys.Count];
            users.Keys.CopyTo(friends, 0);
            return friends[Randomizer.Random.Next(friends.Length)];
        }

        private static bool SendFriendRequest(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            XblUser possibleFriend = state.PickPossibleFriend();
            if (possibleFriend == null)
                return true;
            state.xbox360.Live.Friends.AddFriend(state.user, possibleFriend);
            System.Diagnostics.Debug.WriteLine("User :" + state.user.Puid.ToString("x") + " adds friend " + possibleFriend.Puid.ToString("x"));

            return true;
        }

        public static bool HasFriends(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            return state.Friends.Count != 0;

        }

        private static bool ViewMessages(object globals)
        {
            UserState state = (globals as Globals).UserState;
            state.IsDirty= true;
            PNState pn = Presence.GetPresence(state.user);
            UserMsgFolder msgFolder = new UserMsgFolder(pn);
            ushort numberOfMessages = msgFolder.Load2();

            foreach (UserMessage msg in msgFolder.Inbox)
            {
                if (msg.Type == XonPresNoti.MSG_TYPE_FRIEND_REQUEST)
                    continue;
                uint hr = msg.GetDetails(pn);
                if (!HResult.Succeeded(hr))
                    throw new Exception("Failed to load message details with HR=0x" + hr.ToString("x"));

            }
            return true;
        }

        private static bool SendMessage(object globals)
        {
            UserState state = (globals as Globals).UserState;
            state.IsDirty = true;
            ulong target = PickOne(state.Friends);

            state.xbox360.Live.Messages.SendPersonalMessage(state.user, new XblUser(target, "blah"), "Hello From ZDT!");
            return true;
        }

        //public static bool ViewRecentPlayers(object globals)
        //{
        //    UserState g = ((Globals)globals).UserState;
        //    ///////////////////////////////////////////
        //    // TODO - Get a collection of the user's recent players.
        //    foreach (KeyValuePair<ulong, bool> item in g.Friends)
        //    {
        //        g.XboxLiveGlobals.ProfileGlobals.recentPlayers.Add(item.Key);
        //    }
        //    return true;
        //}


        public static bool ViewFriends(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            //            if (g.Friends.Count == 0)
            //            {
            //                // FOR TESTING: add friends if tehre are no friends.
            //                Xbox360 xbox360 = new Xbox360();
            //                XblUser friend = xbox360.SignUp.CreateUser();
            //                g.Friends.Add(friend.Puid, true);
            //            }
            if (g.Friends.Count != 0)
            {
                ulong[] friends = new ulong[g.Friends.Count];
                g.Friends.Keys.CopyTo(friends, 0);
                UserSettings.ReadSettings(g.xbox360.Client, g.user, g.TitleId, friends,
                                          new uint[]
                                              {
                                                  ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE,
                                                  ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY
                                              });
            }

            return true;
        }

        //public static bool ViewGamercardPlayer(object globals)
        //{
        //    UserState g = ((Globals)globals).UserState;
        //    if (g.XboxLiveGlobals.ProfileGlobals.recentPlayers.Count > 0)
        //    {
        //        int select = ScenarioUtil.GetRandomNumber(g.XboxLiveGlobals.ProfileGlobals.recentPlayers.Count);
        //        return ViewGamercard(g, g.XboxLiveGlobals.ProfileGlobals.recentPlayers[select]);
        //    }
        //    else { return false; }
        //}

        public static bool ViewGamercardFriend(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            if (g.Friends.Count > 0)
            {
                int select = ScenarioUtil.GetRandomNumber(g.Friends.Count);
                ulong[] friends = new ulong[g.Friends.Count];
                g.Friends.Keys.CopyTo(friends, 0);
                return ViewGamercard(g, friends[select]);
            }
            else { return false; }
        }

        public static bool ViewGamercard(object globals)
        {
            UserState g = ((Globals)globals).UserState;

            if (g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard != null && g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid == 0)
            {
                ViewGamercard(g, g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard.GamerPuid);
            }
            else
            {
                // Viewing user's own gamercard.
                ViewGamercard(g, g.user.Puid);
            }
            return true;
        }


        private static bool ViewGamercard(UserState g, ulong userPuid)
        {
            g.IsDirty = true;
            g.xbox360.Live.Profile.GamerProfileScene.InitGamercard(userPuid);
            g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.gamercard = g.xbox360.Live.Profile.GamerProfileScene;
            return true;
        }

        public static bool SubmitPlayerReview(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            FeedbackDefs.PlayerReview playerReview = (FeedbackDefs.PlayerReview)ScenarioUtil.GetRandomNumber(9);
            g.xbox360.Live.Profile.GamerProfileScene.ViewSubmitPlayerReviewScene.SubmitPlayerReview(playerReview);
            if (!g.FeedbackReviews.ContainsKey(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid))
            {
                g.FeedbackReviews.Add(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid, 1);
            }
            else
            {
                // used to investigate feedback problems
                g.FeedbackReviews[g.xbox360.Live.Profile.GamerProfileScene.GamerPuid]++;
            }
            return true;
        }

        public static bool FileComplaint(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            FeedbackDefs.ComplaintType complaintType = (FeedbackDefs.ComplaintType)ScenarioUtil.GetRandomNumber(14);
            g.xbox360.Live.Profile.GamerProfileScene.ViewFileComplaintScene.FileComplaint(complaintType);
            if (!g.FeedbackComplaints.ContainsKey(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid))
            {
                g.FeedbackComplaints.Add(g.xbox360.Live.Profile.GamerProfileScene.GamerPuid, 1);
            }
            else
            {   // used to investigate feedback problems
                g.FeedbackComplaints[g.xbox360.Live.Profile.GamerProfileScene.GamerPuid]++;
            }
            
            return true;
        }

        public static bool CompareGames(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.games = g.xbox360.Live.Profile.GamerProfileScene.ViewCompareGamesScene;
            return true;
        }

        public static bool ViewAchievements(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int total = g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.games.GameSelector.Count();
            int select = ScenarioUtil.GetRandomNumber(total);
            g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.achievements = g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.games.GameSelector[select];
            return true;
        }

        public static bool EditGamerProfile(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.editGamercard = g.xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene;
            return true;
        }

        public static bool EditMotto(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            string motto = string.Format("My Motto - {0}", DateTime.Now.ToShortTimeString());
            g.xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditMotto(motto);
            g.XboxLiveGlobals.ProfileGlobals.motto = motto;
            return true;
        }

        public static bool EditGamerZone(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int gamerZone = 1;
            g.xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditGamerZone(gamerZone);
            g.XboxLiveGlobals.ProfileGlobals.gamerZone = gamerZone;
            return true;
        }


        public static bool EditGamerPicture(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int randomInt = ScenarioUtil.GetRandomNumber(9999);
            string gamerPicture = string.Format("FFFE0700" + "0000" + randomInt.ToString("X4") + "0000" + randomInt.ToString("X4"));
            g.xbox360.Live.Profile.GamerProfileScene.EditGamerProfileScene.EditGamerPicture(gamerPicture);
            g.XboxLiveGlobals.ProfileGlobals.gamerPicture = gamerPicture;
            return true;
        }


        public static bool HasGames(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            return g.XboxLiveGlobals.ProfileGlobals.gamercardGlobals.games.GameSelector.Count() != 0;
        }





        #endregion

        #region Marketplace->Account Management Transitions

        /* Account Management */

        public static bool AccountManagment(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;

            ((Globals)globals).Marketplace.accMgmtGlobals.Clear();

            return true;
        }

        public static bool DownloadHistory(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.ForwardedState = g.xbox360.Marketplace.AccountMgmt.DownloadHistory;
            return true;
        }

        public static bool UserHasDownloadHistory(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            DownloadHistoryScene scene = (DownloadHistoryScene)g.ForwardedState;
            if (scene.DownloadedItems.Count == 0)
            {
                // No items have been downloaded yet
                return false;
            }
            return true;
        }

        public static bool UserHasNoDownloadHistory(object globals)
        {
            return !UserHasDownloadHistory(globals);
        }

        public static bool DownloadedContentItem(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            DownloadHistoryScene scene = (DownloadHistoryScene)g.ForwardedState;
            g.ForwardedState = scene.SelectRandomItem();
            return true;
        }

        public static bool DownloadHistoryItem(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            DownloadedContentItemScene scene = (DownloadedContentItemScene)g.ForwardedState;
            scene.DownloadAgain();
            return true;
        }

        public static bool UpdatePersonalInfo(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.xbox360.Marketplace.AccountMgmt.PersonalInfoScene.UpdateInfo(Randomizer.Persons.RegularUserInfo);
            return true;
        }

        public static bool ViewPaymentOptions(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions = g.xbox360.Marketplace.AccountMgmt.ViewPaymentOptionsScene;
            return true;
        }

        public static bool PaymentOptionDetail(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int total = ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions.PISelector.Count();
            if (total > 0)
            {
                int select = Randomizer.Random.Next(0, total);

                ((Globals)globals).Marketplace.accMgmtGlobals.selectedPaymentInstrument = ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions.PISelector[select];
            }
            return true;
        }

        public static bool RemovePaymentInstrument(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            ((Globals)globals).Marketplace.accMgmtGlobals.selectedPaymentInstrument.Remove();
            ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions = g.xbox360.Marketplace.AccountMgmt.ViewPaymentOptionsScene;
            g.PaymentInstrumentCount = g.PaymentInstrumentCount - 1;
            return true;
        }

        public static bool UpdatePaymentInstrument(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, g.xbox360.ActiveUser.Settings.PersonalInfo);
            ((Globals)globals).Marketplace.accMgmtGlobals.selectedPaymentInstrument.Update(ccinfo);
            ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions = g.xbox360.Marketplace.AccountMgmt.ViewPaymentOptionsScene;
            return true;
        }

        public static bool AddPaymentInstrument(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            CreditCardInfo ccinfo = Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, g.xbox360.ActiveUser.Settings.PersonalInfo);
            ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions.AddPaymentInstrument(ccinfo);
            ((Globals)globals).Marketplace.accMgmtGlobals.paymentOptions = g.xbox360.Marketplace.AccountMgmt.ViewPaymentOptionsScene;
            g.PaymentInstrumentCount += 1;
            return true;
        }

        public static bool RedeemPointsCode(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.TotalPointsPurchased += Offers.GetPointsForOffer(Offers.PointsOffers.PP100);
            g.PointsBalance += Offers.GetPointsForOffer(Offers.PointsOffers.PP100);
            g.xbox360.Marketplace.RedeemMSPointsCode(Offers.PointsOffers.PP100, Offers.GetPrepaid100PointsVoucherCode(g.PointsTokenIdx++)).RedeemNow();

            return true;
        }

        public static bool RedeemSubscriptionCode(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            g.xbox360.Marketplace.RedeemSubscriptionCode(Offers.BaseOffers.GoldPP1Month, Offers.GetPrepaid1monthGoldVoucherCode(g.SubscriptionTokenIndx++)).RedeemNow();
            if (g.SubscriptionStartDate == DateTime.MinValue)
                g.SubscriptionStartDate = DateTime.UtcNow;

            g.MonthsINSubRemaining += Offers.GetSubscriptionLength(Offers.BaseOffers.GoldPP1Month);
            g.CurrentActiveSubscription = Offers.GetOfferId(Offers.BaseOffers.GoldPP1Month);
            return true;
        }

        public static bool ViewCurrentMemberships(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            ((Globals)globals).Marketplace.accMgmtGlobals.Clear();
            ((Globals)globals).Marketplace.accMgmtGlobals.currentSubs = g.xbox360.Marketplace.AccountMgmt.ViewCurrentSubscriptionsScene;
            return true;
        }

        //ViewMembershipDetails

        public static bool ViewCurrentMembershipDetails(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int total = ((Globals)globals).Marketplace.accMgmtGlobals.currentSubs.CurrentSubscriptions.Count();
            int select = Randomizer.Random.Next(0, total);

            //CurrentSubscriptionScene
            ((Globals)globals).Marketplace.accMgmtGlobals.currentSubDetail = ((Globals)globals).Marketplace.accMgmtGlobals.currentSubs.CurrentSubscriptions[select];
            return true;
        }


        public static bool ViewAvailableMemberships(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            ((Globals)globals).Marketplace.accMgmtGlobals.Clear();
            ((Globals)globals).Marketplace.accMgmtGlobals.newSubcriptions = g.xbox360.Marketplace.AccountMgmt.ViewSubscriptionsScene;
            return true;
        }

        //ViewMembershipDetails

        public static bool ViewMembershipDetails(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            int total = ((Globals)globals).Marketplace.accMgmtGlobals.newSubcriptions.availableSubscription.Count();
            if (total > 0)
            {
                int select = Randomizer.Random.Next(0, total);
                //CurrentSubscriptionScene
                ((Globals)globals).Marketplace.accMgmtGlobals.selectedSubscription = ((Globals)globals).Marketplace.accMgmtGlobals.newSubcriptions.availableSubscription[select];

            }

            return true;
        }

        public static bool CheckPILimit(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.PaymentInstrumentCount < 5)
                return true;
            return false;

        }

        public static bool CheckPointsAndPI(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.TotalPointsPurchased < 20000 && g.xbox360.ActiveUser.Settings.BillingInfo.CreditCards.Count > 0)
                return true;
            return false;

        }

        public static bool DoesUserHasPI(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            if (g.xbox360.ActiveUser.Settings.BillingInfo.CreditCards.Count > 0)
                return true;

            return false;
        }

        public static bool CanRemovePI(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;

            if (!DoesUserHasPI(globals))
            {
                return false;
            }

            // Check if payment instrument is the active payment instrument, and if it is being use by a subscription.
            if ((((Globals)globals).Marketplace.accMgmtGlobals.selectedPaymentInstrument.PaymentInstrument.paymentInstrumentId == g.xbox360.ActiveUser.Settings.BillingInfo.ActivePaymentInstrumentId)
                && (g.xbox360.ActiveUser.Settings.BillingInfo.OfferId == g.RenewalSubscription))
            {
                return false;
            }
            return true;

        }

        public static bool CheckPointsCodeLimit(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            if (g.TotalPointsPurchased < 20000 && g.PointsTokenIdx < Offers.GetPrepaid100PointsVoucherCount())
                return true;

            return false;
        }

        public static bool CanPurchaseMorePoints(object globals)
        {
            return CheckPointsAndPI(globals) || CheckPointsCodeLimit(globals);
        }

        public static bool CannotPurchaseMorePoints(object globals)
        {
            return CanPurchaseMorePoints(globals);
        }

        public static bool CheckSubscriptionCode(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            if (g.SubscriptionTokenIndx < Offers.GetPrepaid1monthGoldVoucherCount())
                return true;

            return false;

        }



        public static bool PurchaseSubscription(object globals)
        {
            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;
            //CurrentSubscriptionScene
            ((Globals)globals).Marketplace.accMgmtGlobals.selectedSubscription.ConfirmPurchase();
            if (g.CurrentActiveSubscription == 0)
            {
                g.CurrentActiveSubscription = ((Globals)globals).Marketplace.accMgmtGlobals.selectedSubscription.Subscription.offerID;
                g.MonthsINSubRemaining += 12;
                g.SubscriptionStartDate = DateTime.UtcNow;
            }
            g.RenewalSubscription = ((Globals)globals).Marketplace.accMgmtGlobals.selectedSubscription.Subscription.offerID;

            // ToDo: add code to  track  subscriptins in ZDT
            return true;
        }

        public static bool PurchasePointswithCC(object globals)
        {

            UserState g = ((Globals)globals).UserState;
            g.IsDirty = true;

            g.TotalPointsPurchased += Offers.GetPointsForOffer(Offers.PointsOffers.CC500US);
            g.PointsBalance += Offers.GetPointsForOffer(Offers.PointsOffers.CC500US);

            // what is points used for?
            uint points = UACS.XeGetPointsBalance(g.xbox360.Client, g.xbox360.ActiveUser);

            g.xbox360.Marketplace.PurchasePoints(Offers.PointsOffers.CC500US).Confirm();
            

            return true;
        } 

        #endregion

        #region Marketplace->Games

        private static bool MarketplaceBlade(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            state.ForwardedState = state.xbox360.Marketplace;
            return true;
        }

        private static bool GamesScene(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            MarketplaceScene mp = (MarketplaceScene)state.ForwardedState;
            state.ForwardedState = mp.Games;
            return true;
        }

        private static bool GenresScene(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            GamesInternal games = (GamesInternal)state.ForwardedState;
            state.ForwardedState = games.Genres;
            return true;
        }

        private static bool GenreScene(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            GenresScene genres = (GenresScene)state.ForwardedState;
            state.ForwardedState = genres.RandomGenre;
            return true;
        }

        public static bool TitlesAreAvailable(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            GenreScene genre = (GenreScene)state.ForwardedState;
            if (genre.AvailableTitles.Count == 0)
            {
                return false;
            }
            return true;
        }

        public static bool TitlesAreNotAvailable(object globals)
        {
            return !TitlesAreAvailable(globals);
        }

        private static bool TitleContents(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            GenreScene genre = (GenreScene)state.ForwardedState;
            state.ForwardedState = genre.SelectRandomTitle();
            return true;
        }

        public static bool ContentItemsAreAvailable(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            TitleContentsScene titleContents = (TitleContentsScene)state.ForwardedState;
            if (titleContents.AvailableContent.Count == 0)
            {
                return false;
            }
            return true;
        }

        public static bool ContentItemsAreNotAvailable(object globals)
        {
            return !ContentItemsAreAvailable(globals);
        }

        private static bool ContentItemPurchase(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            TitleContentsScene titleContents = (TitleContentsScene)state.ForwardedState;
            state.ForwardedState = titleContents.SelectRandomContentItem();
            return true;
        }

        public static bool UserHasSufficientPoints(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            ContentItemPurchaseScene purchaseScene = (ContentItemPurchaseScene)state.ForwardedState;
            if (purchaseScene.CurrentBalance > purchaseScene.PointsCost)
            {
                return true;
            }
            return false;
        }

        private static bool ContentItemPurchase_ConfirmDL(object globals)
        {
            UserState state = ((Globals)globals).UserState;
            state.IsDirty = true;
            ContentItemPurchaseScene purchaseScene = (ContentItemPurchaseScene)state.ForwardedState;
            int pointsToDeduct = (int)purchaseScene.PointsCost;
            purchaseScene.ConfirmDownload();
            state.PointsBalance -= pointsToDeduct;

            return true;
        }

        public static bool UserHasInsufficientPoints(object globals)
        {
            return !UserHasSufficientPoints(globals);
        }

        public static bool ContentItemPurchase_InsufficentPoints(object globals)
        {
            // Intentionally a no-op
            // This state was created to ease disambiguating users who:
            //   * can purchase more points with a code
            //   * can purchase more points with a payment instrument
            //   * cannot purchase more points due to points limits or lacking a PI
            return true;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Framework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ZeroDownTime.Framework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ZeroDownTime.Framework")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8659b9f7-d371-47d9-885a-28ca1f2e3bb1")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\SessionTable.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;

namespace ZeroDownTime.LiveScenarios
{
     
    public sealed class SessionTable
    {
        private static volatile SessionTable instance = null;
        private static object syncRoot = new object();
        private Dictionary<ulong, Session> sessions;

        private SessionTable()
        {
            sessions = new Dictionary<ulong,Session>();
        }

        public static SessionTable Instance
        {
            get 
            {
                if (instance == null)
                {
                    lock(syncRoot)
                    {
                        if (instance == null)
                            instance = new SessionTable();
                        
                    }
                }
                return instance;
            }
        }

        public void Add(Session session)
        {
            lock(sessions)
            {
                sessions.Add(session.SessionId, session);
            }
        }

        public void Remove(ulong sessionId)
        {
            lock(sessions)
            {
                sessions.Remove(sessionId);
            }
        }

        public bool TryGetSession(ulong sessionId, out Session session)
        {
            lock(sessions)
            {
                return sessions.TryGetValue(sessionId, out session);
            }
        }

        public bool HasSessionsWaitingForPlayers()
        {
            lock (sessions)
            {
                foreach (KeyValuePair<ulong, Session> s in sessions)
                {
                    if (!s.Value.IsStarted)
                        return true;
                }
            }
            return false;
        }

        /// <summary>
        /// This is just temperary method used for testing joins.
        /// </summary>
        public ulong GetRandomSessionId()
        {
            ulong[] sessionIds = new ulong[sessions.Count];
            sessions.Keys.CopyTo(sessionIds, 0);
            Random r = new Random();
            if (sessions.Count != 0)
            {
                return sessionIds[r.Next(sessions.Count)];
            }
            else
            {
                return 0;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\TitleTable.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;

namespace ZeroDownTime.LiveScenarios
{
    public sealed class TitleTable
    {
        private static volatile TitleTable instance = null;
        private static object syncRoot = new object();
        private Dictionary<ulong, TitleBase> titles;

        private TitleTable()
        {
            titles = new Dictionary<ulong, TitleBase>();
        }

        public static TitleTable Instance
        {
            get 
            {
                if (instance == null)
                {
                    lock(syncRoot)
                    {
                        if (instance == null)
                            instance = new TitleTable();
                        
                    }
                }
                return instance;
            }
        }

        public void Add(TitleBase title)
        {
            lock(titles)
            {
                titles.Add(title.TitleId, title);
            }
        }

        public void Remove(ulong titleId)
        {
            lock(titles)
            {
                titles.Remove(titleId);
            }
        }

        public bool TryGetTitle(ulong titleId, out TitleBase title)
        {
            lock(titles)
            {
                return titles.TryGetValue(titleId, out title);
            }
        }


        public ulong GetRandomTitleId()
        {
            ulong[] titleIds = new ulong[titles.Count];
            titles.Keys.CopyTo(titleIds, 0);
            Random r = new Random();
            if (titles.Count != 0)
            {
                return titleIds[r.Next(titles.Count)];
            }
            else
            {
                return 0;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\ScenarioUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;

namespace ZeroDownTime.LiveScenarios
{
    public class ScenarioUtil
    {
        public static int GetRandomNumber(int max)
        {
            Random r = new Random();
            return r.Next(max);
        }


        public static int GetReviewCountFromDB()
        {
            // Get count of reviews from db.
            string query = "SELECT count(bi_user_puid) FROM UODB.dbo.t_user_review";
            return ExecuteSQLScalar(query);
        }

        public static int GetComplaintCountFromDB()
        {
            // Get count of complaints from db.
            string query = "SELECT count(bi_user_puid) FROM UODB.dbo.t_user_complaint";
            return ExecuteSQLScalar(query);
        }

        /// <summary>
        /// Counts the number of player reviews submitted by a user from the database.
        /// </summary>
        public static int GetReviewCountFromDB(ulong userPuid)
        {
            string query = string.Format("SELECT count(bi_user_puid) FROM UODB.dbo.t_user_review where bi_user_puid = {0}", userPuid);
            return ExecuteSQLScalar(query);
        }

        /// <summary>
        /// Counts the number of complaints by a user from the db.
        /// </summary>
        public static int GetComplaintCountFromDB(ulong userPuid)
        {
            string query = string.Format("SELECT count(bi_user_puid) FROM UODB.dbo.t_user_complaint where bi_user_puid = {0}", userPuid);
            return ExecuteSQLScalar(query);
        }

        private static int ExecuteSQLScalar(string query)
        {
            object o = ServerTestFramework.Database.UodbWS.ExecuteSQLScalar(query, null);
            if (o == null)
                return 0;
            else
                return (int)o;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Titles\FFFF0072.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;

namespace ZeroDownTime.LiveScenarios.TestTitles
{
    public class FFFF0072 : TitleBase
    {
        public FFFF0072() : base(0xFFFF0072)
        {
            TitleName = "LiveBVTs";
            AddAchievements();
            
            
        }

        private void AddAchievements()
        {
            TitleAchievement achievement = new TitleAchievement();
            achievement.AchievementId = 1;
            achievement.DescString = "DOUBLEASYNC1_DESC";
            achievement.DisplayString = "DOUBLEASYNC1_NAME";
            achievement.Gamerscore = 100;
            achievement.HowToString = "DOUBLEASYNC1_HOWTO";
            achievement.Name = "DOUBLEASYNC1";
            achievement.Type = "1";
            _achievements.Add(achievement);
        }


   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Titles.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.832
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ZeroDownTime.LiveScenarios {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Titles : global::System.Configuration.ApplicationSettingsBase {
        
        private static Titles defaultInstance = ((Titles)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Titles())));
        
        public static Titles Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n<ArrayOfString xmlns:xsi=\"http://www.w3." +
            "org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\r\n  <s" +
            "tring>\\Titles\\FFFF0072.xlast</string>\r\n</ArrayOfString>")]
        public global::System.Collections.Specialized.StringCollection Title {
            get {
                return ((global::System.Collections.Specialized.StringCollection)(this["Title"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\UserState.cs ===
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using live.client;
using live.common;
using live.lfm;
using live.lfm.xbox360Internal;
using live.protocol;
using live.protocol.Presence;
using live.server;
using ZeroDownTime.Framework;
using Presence2Item=live.protocol.Presence.Presence2Item;

namespace ZeroDownTime.LiveScenarios
{
    public class UserState
    {
        public static IList<UserState> Instances
        {
            get { return new ReadOnlyCollection<UserState>(instances); }
        }

        private static List<UserState> instances;
        
        public static Counters counters;

        public bool IsDirty = false;

        static UserState()
        {
            instances = new List<UserState>();
            counters = new Counters();
        }

        public Xbox360 xbox360;
        public XblUser user;
       
        public XboxLiveGlobals XboxLiveGlobals = new XboxLiveGlobals();

        public bool UserLoggedOn = false;
        public object ForwardedState = null;

        public int TotalPointsPurchased = 0;
        public int PointsBalance = 0;
        public int MonthsINSubRemaining = 0;
        public ulong CurrentActiveSubscription = 0;
        public ulong RenewalSubscription = 0;
        public DateTime SubscriptionStartDate = DateTime.MinValue;
        public int  PaymentInstrumentCount = 0;
        public int PointsTokenIdx = 0;
        public int SubscriptionTokenIndx = 0;

        private uint _titleId = 0;
        
        private static Dictionary<ulong, UserState> activeInstances = new Dictionary<ulong, UserState>();
        private static Queue<UserState> userPool = new Queue<UserState>(); 

        public Dictionary<ulong, bool> Friends = new Dictionary<ulong, bool>();
        public static int UsersCreated =0;

        private Dictionary<ulong, int> _feedbackReviews = new Dictionary<ulong, int>();
        private Dictionary<ulong, int> _feedbackComplaints = new Dictionary<ulong, int>();

        #region Public Properties

        public Dictionary<ulong, int> FeedbackReviews
        {
            get { return _feedbackReviews; }
            set { _feedbackReviews = value; }
        }

        public Dictionary<ulong, int> FeedbackComplaints
        {
            get { return _feedbackComplaints; }
            set { _feedbackComplaints = value; }
        }

        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        #endregion Public Properties


        public UserState ()
        {
            lock(instances)
            {
                instances.Add(this);
            }

            xbox360 = new Xbox360();
        }

        public static void AddActiveUserState(UserState state)
        {
            lock(activeInstances)
            {
                activeInstances.Add(state.user.Puid, state); 
            }
        }

        public static void RemoveFromActiveUserState(UserState state)
        {
            // null check is needed incase user hasn't been created.
            if (state.user != null)
            {
                lock (activeInstances)
                {
                    activeInstances.Remove(state.user.Puid);
                }
            }
        }
                
        public static void AddUserStateToPool(UserState state)
        {
            lock (userPool)
            {
                userPool.Enqueue(state);
            }
        }

        public static UserState GetUserStateFromPool()
        {
            lock (userPool)
            {
                if (userPool.Count == 0)
                    return null;
                UserState result = userPool.Dequeue();
                return result;
            }
        }

        public XblUser PickPossibleFriend()
        {
            lock(activeInstances)
            {
                List<XblUser> candidates = new List<XblUser>();
                foreach (ulong candidateId in activeInstances.Keys)
                {
                    if (candidateId != user.Puid && !Friends.ContainsKey(candidateId))
                    {
                        candidates.Add(activeInstances[candidateId].user);
                    }
                }

                if (candidates.Count == 0)
                    return null;
                return candidates[Randomizer.Random.Next(candidates.Count)];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Runner\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using ZeroDownTime.Framework;
using ZeroDownTime.LiveScenarios;

namespace ZeroDownTime.Runner
{
    class Program
    {
        private const int NUM_ACTORS = 100;

        static void Main(string[] args)
        {
            Script s = new Scenario1();
            Actor[] actors = new Actor[NUM_ACTORS];
            for (int i =0; i < NUM_ACTORS;i++)
            {
                actors[i] = new Actor(s);
            }

            foreach (Actor a in actors)
               a.Start();
            Thread.Sleep(TimeSpan.FromMinutes(10));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\UserStateVerifier.cs ===
using System;
using System.IO;
using live.client;
using live.common;
using live.lfm;
using live.protocol;
using live.protocol.Presence;
using live.server;
using ZeroDownTime.Framework;
using Presence2Item = live.protocol.Presence.Presence2Item;
using System.Text;

namespace ZeroDownTime.LiveScenarios
{
    class UserStateVerifier
    {
        public static Xbox360 observingBox;
        public static XblUser observer;


        public static void VerifyAll(bool verifyDirtyOnly)
        {
            VerifyAll(Console.Out, verifyDirtyOnly);
        }


  
        /// <summary>
        /// Verify the userstate.
        /// </summary>
        /// <param name="Out"></param>
        /// <param name="verifyDirtyOnly">Set verifyDirtyOnly to TRUE if only instances that have changed userstates should be verified.</param>
        public static void VerifyAll(TextWriter Out, bool verifyDirtyOnly)
        {
            try
            {
                Verifier v = new Verifier(Out);

                observingBox = new Xbox360();
                observer = observingBox.SignUp.CreateUser();
                observingBox.Live.Logon(observer);

                foreach (UserState instance in UserState.Instances)
                {
                    if (instance.user == null)
                        continue;

                    // If onlyDirty is set to true, then only verify users that have a changed userstate.
                    if (verifyDirtyOnly && !instance.IsDirty)
                    {
                        continue;
                    }

                    using (v.In("User 0x" + instance.user.Puid.ToString("x")))
                    {
                        Verify(v, Out, instance);
                    }
                }

                observingBox.Live.Logout(observer);
                observingBox.ShutdownConsole();
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                Out.WriteLine(ex.ToString());
            }
        }

        public static void Verify(Verifier v, TextWriter Out, UserState instance)
        {
            CheckUserExists(v, instance);
            CheckUserLoginStatus(v, instance);
            CheckUserPoints(v, instance);
            CheckSubscription(v, instance);
            CheckPaymentInstrument(v, instance);
            CheckAchievements(v, instance);
            CheckStats(v, instance);
            CheckGamerCard(v, instance);
            CheckFeedbackPerUser(v, instance);
        }



        private static void CheckUserExists(Verifier v, UserState instance)
        {
            try
            {
                Xbox360Client xb = new Xbox360Client();
                xb.UserLoggingOn(instance.user);
                PersonalInfo currentInfo = UACS.XeGetAccountInfo(xb, instance.user.Puid);
                xb.UserLoggingOff(instance.user);
                xb.Shutdown();
                //            PersonalInfo currentInfo = UACS.XeGetAccountInfo(xbox360.Client, user.Puid);
                PersonalInfo expectedInfo = instance.user.Settings.PersonalInfo;
                Test(expectedInfo, currentInfo, v);
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                Test(instance.user.Settings.PersonalInfo, new PersonalInfo(), v);
            }
        }

        private static void CheckUserLoginStatus(Verifier v, UserState instance)
        {
            try
            {
                using (v.In("Presence"))
                {
                    Presence.PeerSubscribeEx(observingBox.Client, observer, new XblUser[] { instance.user });
                    Notification.WaitForPeerPresence(observingBox.Client, observer, new XblUser[] { instance.user });
                    PNState observerState = Presence.GetPresence(observer);
                    PNState.PeerInfo info = observerState.GetPeerInfo(instance.user.Puid);
                    Presence2Item presence2Item = info.RichPresence;
                    bool actualUserLoggedOn = (presence2Item.State & PresDefs.P_STATE_FLAG_ONLINE) != 0;
                    v.Test(instance.UserLoggedOn, actualUserLoggedOn, "LoggedOn");
                    if (actualUserLoggedOn)
                    {   // User must be logged in for client to exist.
                        v.Test(instance.TitleId, info.User.Client.TitleId, "LoggedOnToTitle");
                    }
                }
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                // We need to fail the validation.
                v.Test(instance.UserLoggedOn, !instance.UserLoggedOn, "LoggedOn");
            }
        }


        private static void CheckUserPoints(Verifier v, UserState instance)
        {
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                uint points = UACS.XeGetPointsBalance(instance.xbox360.Client, instance.user);
                v.Test(instance.PointsBalance, (int)points, "Points Balance");
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                //Out.WriteLine(ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
            }
        }

        private static void CheckSubscription(Verifier v, UserState instance)
        {
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                SubscriptionEnumerateFilter filter = new SubscriptionEnumerateFilter();
                filter.OfferType = OfferingTypeEnum.Subscription;
                filter.QueryForCurrent = true;

                EnumeratedSubscriptions Subscriptions = Billing.XeSubscriptionEnumerate(instance.xbox360.Client, instance.user, filter);

                if (instance.CurrentActiveSubscription != 0)
                {
                    v.Test(1, Subscriptions.Subscriptions.Count, "Subscription count");
                    if (Subscriptions.Subscriptions.Count == 1)
                        v.Test(instance.CurrentActiveSubscription, Subscriptions.Subscriptions[0].offerID, "Active Subscription ");
                }

                UserSubscriptionDetails userSubdetails = UACS.XeGetUserSubscriptionDetails(instance.xbox360.Client, instance.user, instance.CurrentActiveSubscription);
                v.Test(instance.RenewalSubscription, userSubdetails.RenewalOfferId, "OfferID for current subscription");
                DateTime enddate = instance.SubscriptionStartDate.AddMonths(instance.MonthsINSubRemaining);
                v.Test(userSubdetails.EndDate.Year, enddate.Year, "Subscription End Date Year");
                v.Test(userSubdetails.EndDate.Month, enddate.Month, "Subscription End Date Month");
                v.Test(userSubdetails.EndDate.Day, enddate.Day, "Subscription End Date Day");
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                // Out.WriteLine(ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
            }

        }

        private static void CheckPaymentInstrument(Verifier v, UserState instance)
        {
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                PaymentInstrumentInfoEx[] PaymentInstruments = UACS.XeGetPaymentInstruments2(instance.xbox360.Client, instance.user, 5);

                foreach (PaymentInstrumentInfoEx piinfo in PaymentInstruments)
                {
                    if (!instance.user.Settings.BillingInfo.CheckPaymentInstrument(new CreditCardInfo(piinfo)))
                        v.Test("PI does not exist in xbluser ", piinfo.paymentInstrumentId.ToString(), "");
                }
            }
            catch (Exception ex)
            {

                Registry.Exceptions.Add(ex);
                // Out.WriteLine(ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
            }

        }

        private static void CheckAchievements(Verifier v, UserState instance)
        {
            uint tempTitleId = instance.xbox360.Client.TitleId;
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                // Temperarily change the titleId so we can get the achievements for that title as the client's title overrules the titleId pass in. 
                // TitleId param in enum is useless?
                instance.xbox360.Client.TitleId = Scenario1.GAME_TITLE_ID;

                AchievementEnumResponse resp = live.server.Achievements.EnumAchievement(instance.xbox360.Client, instance.user, instance.xbox360.Client.TitleId, instance.user.Puid, 0, 0, 32);
                // Go through the expected achievements earned, and check if the actual achievement has been achieved by the Achieved Date.
                foreach (Achievement aExpected in instance.XboxLiveGlobals.ProfileGlobals.achievements)
                {
                    // loop through the achievements enum and find out if the achievement has be achieved since the start of the harness.
                    foreach (Achievement aActual in resp.Achievements)
                    {
                        if (aExpected.AchievementId == aActual.AchievementId)
                        {
                            v.Test((aActual.Flags & (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED), (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED, "achievement flags");
                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {

                Registry.Exceptions.Add(ex);
                //v.Test(true, false, ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
                // set the titleId back to its original state.
                instance.xbox360.Client.TitleId = tempTitleId;
            }

        }

        public static void CheckStats(Verifier v, UserState instance)
        {
            uint tempTitleId = instance.xbox360.Client.TitleId;
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                instance.xbox360.Client.TitleId = Scenario1.GAME_TITLE_ID;
                if (instance.XboxLiveGlobals.StatsGlobals.stats != null)
                {
                    StatsSpec[] statsSpecs = new StatsSpec[1];
                    StatsSpec statsSpec = new StatsSpec();
                    statsSpec.ViewId = 1;   // Leaderboard 1.
                    statsSpecs[0] = statsSpec;

                    // actual
                    StatsReadResponse resp = live.server.Stats.ReadStats(instance.xbox360.Client, instance.user, instance.xbox360.Client.TitleId, new ulong[1] { instance.user.Puid }, statsSpecs);
                    v.Test((ulong)instance.XboxLiveGlobals.StatsGlobals.stats._procs[0]._params[4].Data, resp.Results[0].Rows[0].Rating, "StatsRating");
                }
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                //v.Test(true, false, ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
                // set the titleId back to its original state.
                instance.xbox360.Client.TitleId = tempTitleId;
            }
        }


        public static void CheckGamerCard(Verifier v, UserState instance)
        {
            try
            {
                instance.xbox360.Client.UserLoggingOn(instance.user);
                uint[] settings = new uint[] { ProfileDefs.XPROFILE_GAMERCARD_MOTTO, ProfileDefs.XPROFILE_GAMERCARD_ZONE };
                ReadSettingsResponse resp = UserSettings.ReadSettings(instance.xbox360.Client, instance.user, instance.xbox360.Client.TitleId, new ulong[] { instance.user.Puid }, settings);
                foreach (UserSetting userSetting in resp.Settings)
                {
                    switch (userSetting.SettingId)
                    {
                        case ProfileDefs.XPROFILE_GAMERCARD_MOTTO:
                            if (instance.XboxLiveGlobals.ProfileGlobals.motto != null) // Motto was not edited.
                            {
                                string motto = Encoding.Unicode.GetString(userSetting.Value);
                                v.Test(instance.XboxLiveGlobals.ProfileGlobals.motto, motto, "GamercardMotto");
                            }
                            break;
                        case ProfileDefs.XPROFILE_GAMERCARD_ZONE:
                            if (instance.XboxLiveGlobals.ProfileGlobals.gamerZone != 0)
                            {
                                int gamerZone = BitConverter.ToInt32(userSetting.Value, 0);
                                v.Test(instance.XboxLiveGlobals.ProfileGlobals.gamerZone, gamerZone, "GamercardGamerZone");
                            }
                            break;
                        default:
                            break;
                    }
                }
                instance.xbox360.Client.UserLoggingOff(instance.user);
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                //v.Test(true, false, ex.ToString());
            }
            finally
            {
                instance.xbox360.Client.UserLoggingOff(instance.user);
            }
        }


        private static void CheckFeedbackPerUser(Verifier v, UserState instance)
        {
            try
            {
                int expectedComplaint = instance.FeedbackComplaints.Count;
                int expectedReview = instance.FeedbackReviews.Count;
                using (v.In("Feedback"))
                {
                    int actual = ScenarioUtil.GetReviewCountFromDB(instance.user.Puid);
                    v.Test(expectedReview, actual, "FeedbackReview");

                    actual = ScenarioUtil.GetComplaintCountFromDB(instance.user.Puid);
                    v.Test(expectedComplaint, actual, "FeedbackComplaint");
                }
            }
            catch (Exception ex)
            {
                Registry.Exceptions.Add(ex);
                //v.Test(true, false, ex.ToString());
            }
        }


        private static void Test(PersonalInfo expected, PersonalInfo got, Verifier v)
        {
            using (v.In("PersonalInfo"))
            {
                Test(expected.AddressInfo, got.AddressInfo, v);
                v.Test(expected.BirthDate, got.BirthDate, "BirthDate");
                v.Test(expected.CountryCode, got.CountryCode, "CountrCode");
                v.Test(expected.Email, got.Email, "Email");
                v.Test(expected.FirstName, got.FirstName, "FirstName");
                v.Test(expected.LastName, got.LastName, "LastName");
                v.Test(expected.LanguageId, got.LanguageId, "LanguageId");
                v.Test(expected.MsftOptIn, got.MsftOptIn, "MsftOptIn");
                v.Test(expected.PartnerOptIn, got.PartnerOptIn, "PartnerOptIn");
                Test(expected.PhoneInfo, got.PhoneInfo, v);
            }
        }

        public static void Test(AddressInfo expected, AddressInfo got, Verifier v)
        {
            using (v.In("AddressInfo"))
            {
                v.Test(expected.Street1, got.Street1, "Street1");
                v.Test(expected.Street2, got.Street2, "Street2");
                v.Test(expected.City, got.City, "City");
                v.Test(expected.District, got.District, "District");
                v.Test(expected.State, got.State, "State");
                v.Test(expected.PostalCode, got.PostalCode, "PostalCode");
            }
        }

        public static void Test(PhoneInfo expected, PhoneInfo got, Verifier v)
        {
            using (v.In("PhoneInfo"))
            {
                v.Test(expected.PhonePrefix, got.PhonePrefix, "PhonePrefix");
                v.Test(expected.PhoneNumber, got.PhoneNumber, "PhoneNumber");
                v.Test(expected.PhoneExtension, got.PhoneExtension, "PhoneExtension");
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\ActorTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    /// <summary>
    /// Summary description for ActorTest
    /// </summary>
    [TestClass]
    public class ActorTest
    {

        [TestMethod]
        public void CreateActor()
        {
            Script s = new Script("SimpleScript");
            Actor actor = new Actor(s, new ChooseFirstPolicy());
        }

        [TestMethod]
        public void ExecuteSingleAction()
        {
            Script s = new Script("Test");
            s.AddState("Start");
            bool executed = false;
            Transition t = s.AddTransition("DoNothing", "Start", "Start", delegate(object globals)
                                                               {
                                                                   executed = true;
                                                                   return true;
                                                               });

            Actor actor = new Actor(s, new ChooseFirstPolicy());
            actor.ExecuteStep();
            Assert.IsTrue(executed);
            Assert.AreEqual<long>(1, t.SuccessCount);
        }

        [TestMethod]
        public void ExecuteSuccessfullTransition()
        {
            Script s = new Script("Test");
            State start = s.AddState("Start");
            State end = s.AddState("End");
            s.AddTransition("DoNothing", "Start", "End", delegate(object globals)
                                                               {
                                                                  return true;
                                                               });

            Actor actor = new Actor(s, new ChooseFirstPolicy());
            Assert.AreEqual(start, actor.CurrentState);
            actor.ExecuteStep();
            Assert.AreEqual(end, actor.CurrentState);
        }

        [TestMethod]
        public void ExecuteFailedTransition()
        {
            Script s = new Script("Test");
            State start = s.AddState("Start");
            State end = s.AddState("End");
            Transition t = s.AddTransition("DoNothing", "Start", "End", delegate(object globals)
                                                               {
                                                                   return false;
                                                               });

            Actor actor = new Actor(s, new ChooseFirstPolicy());
            Assert.AreEqual(start, actor.CurrentState);
            actor.ExecuteStep();
            Assert.AreEqual(start, actor.CurrentState);
            Assert.AreEqual<long>(0, t.SuccessCount);
            Assert.AreEqual<long>(1, t.FailureCount);
            
        }

        [TestMethod]
        public void ExecuteThrowingTransition()
        {
            Script s = new Script("Test");
            State start = s.AddState("Start");
            State end = s.AddState("End");
            Transition t = s.AddTransition("DoNothing", "Start", "End", delegate
                                                                            {
                                                                   throw new Exception("Test exception");
                                                                            });
            Actor actor = new Actor(s);
            actor.ExecuteStep();
            Assert.AreEqual<long>(0, t.SuccessCount);
            Assert.AreEqual<long>(1, t.FailureCount);
            Assert.AreEqual(1, Registry.Exceptions.CreateSnapshot().Count);
            
        }

        [TestMethod]
        public void ActorHasPolicy()
        {
            Script s = new Script("Test");
            s.AddState("Start");
            bool firstExecuted = false;
            s.AddTransition("First", "Start", "Start", delegate
                                                           {
                                                                   firstExecuted = true;
                                                                   return true;
                                                               });
            bool secondExecuted = false;
            s.AddTransition("Second", "Start", "Start", delegate
                                                            {
                                                                   secondExecuted = true;
                                                                   return true;
                                                               });
            
            
            Actor actor = new Actor(s, new ChooseSecondPolicy());
            actor.ExecuteStep();
            Assert.IsFalse(firstExecuted);
            Assert.IsTrue(secondExecuted);
        }

        [TestMethod]
        [ExpectedException(typeof(InvalidOperationException), "State Start does not have outgoing transitions. Check the script creation code.")]
        public void StateHasNoOutgoingTransitions()
        {
            Script s = new Script("Test");
            s.AddState("Start");
            Actor actor = new Actor(s, new NotImpelemntedPolicy());
            actor.ExecuteStep();
        }

        [TestMethod]public void ActorPassesGlobalsToAction()
        {
            TestScript s = new TestScript();
            Actor actor = new Actor(s, new ChooseFirstPolicy());
            actor.ExecuteStep();
            Assert.IsNotNull(TestScript.Globals);
            Assert.IsInstanceOfType(TestScript.Globals, typeof(TestScript.TestGlobals));
       }

        [TestMethod]
        public void ActorCallsLeaveStateAction()
        {
            Script s = new Script("Test");
            s.AddState("s1");
            string log = "";
            s.AddTransition("t1", "s1", "s1", delegate
                                                  {
                                                      log += "t1";
                                                      return true;
                                                  });
            s.LeaveStateAction = delegate { log += "la";
                                              return true; };
            Actor actor = new Actor(s);
            actor.ExecuteStep();
            Assert.AreEqual("lat1", log);
        }

        [TestMethod]
        public void LeaveStateActionThrows()
        {
            Script s = new Script("Test");
            s.AddState("s1");
            string log = "";
            s.AddTransition("t1", "s1", "s1", delegate
                                                  {
                                                      log += "t1";
                                                      return true;
                                                  });
            s.LeaveStateAction = delegate { throw new Exception();};
            Actor actor = new Actor(s);
            int previousCount = Registry.Exceptions.CreateSnapshot().Count;
            actor.ExecuteStep();
            Assert.AreEqual("t1", log);
            Assert.AreEqual(previousCount + 1, Registry.Exceptions.CreateSnapshot().Count);
        }

        public class TestScript  : Script
        {
            public static object Globals = null;
            public TestScript() : base("TestScript")
            {
                AddState("Start");
                AddTransition("StartToStart", "Start", "Start", StartToStart);
            }

            private bool StartToStart(object globals)
            {
                TestScript.Globals = globals;
                return true;
            }
            public override object CreateGlobals()
            {
                return new TestGlobals();
            }

            public class TestGlobals
            {
            }

        }

        [TestMethod]
        public void TestDefaultSelectionPolicy()
        {
            Actor actor = new Actor(new Script("Test"));
            Assert.IsInstanceOfType(actor.TransitionSelectionPolicy, typeof(WeightedTransitionSelectionPolicy));
        }

        [TestMethod]
        public void TestActorSelectsEnabledTransitions()
        {
            Script s = new Script("test");
            s.AddState("s1");
            bool first = false;
            bool second = false;
            s.AddTransition("t1", "s1", "s1", int.MaxValue - 1, delegate
                                                                    {
                                                                        first = true;
                                                                        return true;
                                                                    }, delegate { return false; });
            s.AddTransition("t2", "s1", "s1", 1, delegate
                                                                  {
                                                                      second = true;
                                                                      return true;
                                                                  }, delegate { return true; });
            Actor a = new Actor(s);
            a.ExecuteStep();
            Assert.IsFalse(first);
            Assert.IsTrue(second);
        }
        [TestMethod]
        public void TestActorPassesGlobalToCondition()
        {
                Script s = new TestScript();
                bool globalsIsNull = false;
                s.AddTransition("t1", "Start", "Start", 1, delegate { return true; }, 
                    delegate (object globals){globalsIsNull = globals == null; return false; });
                Actor a = new Actor(s);
                a.ExecuteStep();
                Assert.IsFalse(globalsIsNull);
        }

        [TestMethod]
        public void TestActorRestartsOnRestartScript()
        {
            Script s = new Script("Test");
            State start = s.AddState("Start");
            State s1 = s.AddState("S1");
            s.AddTransition("T1", "Start", "S1", delegate { return true; });
            s.AddTransition("Failing", "S1", "S1", delegate { throw new Exception("Blah"); });
            s.TransitionFailureBehavior = TransitionFailureBehavior.Restart;

            Actor a = new Actor(s);
            a.ExecuteStep();
            Assert.AreEqual(s1, a.CurrentState);
            a.ExecuteStep();
            Assert.AreEqual(start, a.CurrentState);
        }

        [TestMethod]
        public void TestActorCallsOnRestartAction()
        {
            Script s = new Script("Test");
            State start = s.AddState("Start");
            State s1 = s.AddState("S1");
            s.AddTransition("T1", "Start", "S1", delegate { return true; });
            s.AddTransition("Failing", "S1", "S1", delegate { throw new Exception("Blah"); });
            s.TransitionFailureBehavior = TransitionFailureBehavior.Restart;
            bool restartExecuted = false;
            s.RestartAction = delegate(object globals)
                                  {
                                      restartExecuted = true;
                                      return true;
                                  };

            Actor a = new Actor(s);
            a.ExecuteStep();
            a.ExecuteStep();

            Assert.IsTrue(restartExecuted);
            Assert.AreEqual(start, a.CurrentState);
        }
    }



    internal class NotImpelemntedPolicy  : ITransitionSelectionPolicy
    {
        public Transition Select(State state, object globals)
        {
            throw new NotImplementedException();
        }
    }


    internal class ChooseSecondPolicy : ITransitionSelectionPolicy
    {
        public Transition Select(State state, object globals)
        {
            return state.Transitions[1];
        }
    }

    internal class ChooseFirstPolicy : ITransitionSelectionPolicy
    {
        public Transition Select(State state, object globals)
        {
            return state.Transitions[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\CollectingBagTest.cs ===
using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    [TestClass]
    public class CollectingBagTest
    {
        [TestMethod]
        public void CreationTest()
        {
            CollectingBag bag = new CollectingBag();
            Assert.IsInstanceOfType(bag, typeof(IChangeBag));
            
        }

        [TestMethod]
        public void CollectingBagHasPendingChecks()
        {
            CollectingBag bag = new CollectingBag();
            Assert.IsNotNull(bag.PendingChanges);
            Assert.AreEqual(0, bag.PendingChanges.Count);
        }

        [TestMethod]
        public void CollectingBagAddTest()
        {
            CollectingBag bag = new CollectingBag();
            TestChange change = new TestChange();
            bag.Add(change);

        }


        public class TestChange : IExpectedChange
        {
            public void Apply()
            {
                throw new NotImplementedException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\ApplyingBagTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    /// <summary>
    /// Summary description for ApplyingBagTest
    /// </summary>
    [TestClass]
    public class ApplyingBagTest
    {
        [TestMethod]
        public void TestMethod1()
        {
            IChangeBag bag = new ApplyingBag();
            TestChange change = new TestChange();
            bag.Add(change);
            Assert.IsTrue(change.applied);
        }

        public class TestChange : IExpectedChange
        {
            public bool applied = false;
            public void Apply()
            {
                applied = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.LiveScenarios\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ZeroDownTime.LiveScenarios")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ZeroDownTime.LiveScenarios")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fd281c7f-bfb8-41eb-9cd7-6fa74eae3cb5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\ChangeTest.cs ===
using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    /// <summary>
    /// Summary description for CheckTest
    /// </summary>
    [TestClass]
    public class ChangeTest
    {
        [TestMethod]
        public void ChangeHasApplyMethod()
        {
            IExpectedChange change = new TestChange();
            change.Apply();
        }

        public class TestChange : IExpectedChange
        {
            public void Apply()
            {

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\E2ETests.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    /// <summary>
    /// Summary description for E2ETests
    /// </summary>
    [TestClass]
    public class E2ETests
    {
        public E2ETests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void ActorBehaviorPrototypeTest()
        {
            Script s = CreateScript();

            State current = s.StartState;
            Transition chosenTransition = current.Transitions[0];
//            bool result = chosenTransition.Action(null, out checks);
            //if (result)
            //{
            //    current = chosenTransition.ToState;
            //    CheckBag.Combine(checks);
            //} else
            //{
            //    LogFailure("Action");
            //}
        }

        private static Script CreateScript()
        {
            Script s;
            s = new Script("SampleScript");
            s.AddState("Start");
            s.AddState("Logged On");
            s.AddState("BrowsingMarketplace");
            s.AddTransition("Logon", "Start", "Logged On", Actions.Logon);
            s.AddTransition("SwitchToBrowse", "Logged On", "BrowsingMarketplace", Actions.SwitchToBrowse);
            s.AddTransition("SwitchBack", "BrowsingMarketplace", "Logged On", Actions.SwitchBack);
            s.AddTransition("CheckFriends", "Logged On", "Logged On", Actions.Logon);
            return s;
        }
    }

    public static class Actions
    {
        public static readonly Script.Action Logon = Actions.DummyAction;
        public static readonly Script.Action SwitchToBrowse = Actions.DummyAction;

        public static readonly Script.Action SwitchBack = Actions.DummyAction;
        public static bool DummyAction(object globals)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\ExceptionStoreTest.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    [TestClass]
    public class ExceptionStoreTest
    {
        private ExceptionStore store;

        [TestInitialize]
        public void SetUp()
        {
            store  = new ExceptionStore();
        }

        [TestMethod]
        public void AddSingleException()
        {
            Exception e = ThrowAndCatchException("message");

            Assert.IsFalse(store.Contains(e));
            
            store.Add(e);

            Assert.IsTrue(store.Contains(e));
        }

        [TestMethod]
        public void AddExceptionTwice()
        {
            Exception e = ThrowAndCatchException("message");

            store.Add(e);
            store.Add(e);
            Assert.IsTrue(store.Contains(e));
            Assert.AreEqual(2, store[e]);
        }

        [TestMethod]
        public void AddDifferentExceptions()
        {
            Exception e = ThrowAndCatchException("Message1");
            Exception e2 = ThrowAndCatchException("Message2");
            store.Add(e);
            store.Add(e2);

            Assert.IsTrue(store.Contains(e));
            Assert.IsTrue(store.Contains(e2));
            Assert.AreEqual(1, store[e]);
            Assert.AreEqual(1, store[e2]);
        }

        [TestMethod]
        public void AddTwoCopiesOfSameException()
        {
            Exception e1 = ThrowAndCatchException("Message");
            Exception e2 = ThrowAndCatchException("Message");
            store.Add(e1);
            store.Add(e2);
            Assert.AreEqual(2, store[e1]);
        }

        [TestMethod]
        public void GetSnapshot()
        {
            Exception e1 = ThrowAndCatchException("M1");
            store.Add(e1);
            IDictionary<Exception, int> snapshot = store.CreateSnapshot();
            Assert.IsTrue(snapshot.ContainsKey(e1));
            Exception e2 = ThrowAndCatchException("M2");
            Assert.IsFalse(snapshot.ContainsKey(e2));
        }

        private static Exception ThrowAndCatchException(string message)
        {
            try
            {
                throw new Exception(message);
            }
            catch (Exception e)
            {
                return e;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDownTime.Runner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ZeroDownTime.Runner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ZeroDownTime.Runner")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("20f4c249-4c02-4c22-ba58-318e540de438")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\StateTest.cs ===
using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    [TestClass]
    public class StateTest
    {
 
    #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void TestCreation()
        {
            State state = new State("FirstState");
        }

        [TestMethod]
        public void TestName()
        {
            State state = new State("StateName");
            Assert.AreEqual("StateName", state.Name);
        }

        [TestMethod]
        public void TestStateHasMinAndMaxDelay()
        {
            State state = new State("Blah");
            Assert.AreEqual(State.MIN_DELAY, state.MinDelay);
            Assert.AreEqual(State.MAX_DELAY, state.MaxDelay);
        }

        [TestMethod]
        public void TestStateConstructorHasMinAndMaxDelay()
        {
            State state = new State("blah", 10, 20);
            Assert.AreEqual(10, state.MinDelay);
            Assert.AreEqual(20, state.MaxDelay);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException),  "minDelay value is greater than maxDelay. Specify minDelay value to be less or equal to maxDelay.")]
        public void TestStateConstructorThrowsIfMinIsGreaterThanMax()
        {
            State state = new State("Blah", 10, 9);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Delay value is negative. Delay value should be positive or equal to 0.")]
        public void TestStateConstructorThrowsOnNegativeMinDelay()
        {
            State state = new State("Blah", -1, 9);

        }
    }

    [TestClass]
    public class StateTransitionTests
    {
        private Script script;
        private State state1;
        private State state2;
        private Script.Action action;

        [TestMethod]
        public void TestAddTransition()
        {
            Transition t = state1.AddTransition("Transition1", this.state2, action);
            Assert.AreEqual("Transition1", t.Name);
            Assert.AreEqual(state2, t.ToState);
            Assert.AreEqual(action, t.Action);
        }

        [TestInitialize]
        public void Init()
        {
            script = new Script("Test");
            state1 = script.AddState("State1");
            state2 = script.AddState("State2");
            action = delegate(object globals)
                         {
                             return true;
                         };
        }

        [TestMethod]
        public void TestTransitionExists()
        {
            Transition t = state1.AddTransition("Transition1", state2, action);
            Assert.IsTrue(state1.Transitions.Contains(t));
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void AddSameNameTranstionTwice()
        {
            state1.AddTransition("Transition", state2, action);
            state1.AddTransition("Transition", state1, action);
        }

        [TestMethod]
        [ExpectedException(typeof(NotSupportedException))]
        public void TransitionsIsReadOnly()
        {
            state1.Transitions.Add(new Transition("Blah", state2, 1, action, null));
        }

        [TestMethod]
        public void TransitionDefaultWeight()
        {
            Transition t = state1.AddTransition("New Transition", state2, action);
            Assert.AreEqual(1, t.Weight);
        }

        [TestMethod]
        public void TransitionWithWeight()
        {
            Transition t = state1.AddTransition("Transition", state2, 10, action, Script.AlwaysTrue);
            Assert.AreEqual(10, t.Weight);
        }

        [TestMethod]
        public void TransitionHasSuccessCount()
        {
            Transition t = state1.AddTransition("Tranisition", state1, action);
            Assert.AreEqual<long>(0, t.SuccessCount);
            t.RecordSuccess();
            Assert.AreEqual<long>(1, t.SuccessCount);
        }

        [TestMethod]
        public void TransitionHasFailureCount()
        {
            Transition t = state1.AddTransition("Tranisition", state1, action);
            Assert.AreEqual<long>(0, t.FailureCount);
            t.RecordFailure();
            Assert.AreEqual<long>(1, t.FailureCount);
            Assert.AreEqual<long>(0, t.SuccessCount);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\VerifierTest.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    [TestClass]
    public class VerifierTest
    {
        private StringWriter result;
        private Verifier v = new Verifier(new StringWriter());

        [TestInitialize]
        public void SetUp()
        {
            result = new StringWriter();
            v = new Verifier(result);
        }

        [TestMethod]
        public void TestTestString()
        {
            v.Test("expected", "got", "String");
            Assert.AreEqual("String: Expected <expected>, Actual <got>"+result.NewLine, result.ToString());
        }

        [TestMethod]
        public void TestInScope()
        {
            using (v.In("Address"))
            {
                v.Test("Summer st", "Winter st", "Street");
            }

            string expected = "Address:"+result.NewLine+".Street: Expected <Summer st>, Actual <Winter st>"+result.NewLine;
            Assert.AreEqual(expected, result.ToString());
        }

        [TestMethod]
        public void TestIn2Scopes()
        {
            using (v.In("S1"))
                using (v.In("S2"))
                v.Test("expected", "actual", "R");

            string expected = "S1:" + result.NewLine + ".S2:" + result.NewLine +
                              "..R: Expected <expected>, Actual <actual>" + result.NewLine;
            Assert.AreEqual(expected, result.ToString());
        }

        [TestMethod]
        public void Test2TestsInScope()
        {
            using (v.In("S1"))
            {
                v.Test("expected", "actual", "R");
                v.Test("expected", "actual", "RR");
            }

            string expected = "S1:" + result.NewLine +
                              ".R: Expected <expected>, Actual <actual>" + result.NewLine +
                              ".RR: Expected <expected>, Actual <actual>" + result.NewLine;
            Assert.AreEqual(expected, result.ToString());
        }

        [TestMethod]
        public void Test2TestsInDifferentScopes()
        {
            using (v.In("S1"))
            {
                v.Test("expected", "actual", "R");
            }

            using (v.In("S2"))
            {
                v.Test("expected", "actual", "RR");
            }

            string expected = "S1:" + result.NewLine +
                              ".R: Expected <expected>, Actual <actual>" + result.NewLine +
                              "S2:" + result.NewLine +
                              ".RR: Expected <expected>, Actual <actual>" + result.NewLine;
            Assert.AreEqual(expected, result.ToString());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\ScriptTest.cs ===
using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using ZeroDownTime.Framework;
namespace ZeroDowntime.Tests
{
    [TestClass]
    public class ScriptTest
    {
        private const string SCRIPT_NAME = "ScriptUnderTest";

        private Script script;
        private Script.Action action;
        [TestInitialize()] 
        public void MyTestInitialize()
        {
            script = new Script(SCRIPT_NAME);
            action = delegate(object globals)
                         {
                             return true;
                         };
        }

        [TestMethod]
        public void CreationTest()
        {
            Script scr = new Script("ScriptName");
        }

        [TestMethod]
        public void NameTest()
        {
            Script scr = new Script("ScriptName");
            Assert.AreEqual("ScriptName", scr.Name);
        }

        [TestMethod]
        public void CreateStateTest()
        {
            State s = script.AddState("NewState");
            Assert.AreEqual("NewState", s.Name);
            Assert.AreEqual(s, script.States[0]);
            Assert.AreEqual(State.MIN_DELAY, s.MinDelay);
            Assert.AreEqual(State.MAX_DELAY, s.MaxDelay);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void CreateSameStateTwice()
        {
            script.AddState("State");
            script.AddState("State");
        }

        [TestMethod]
        public void AddStateWithDelays()
        {
            State s = script.AddState("NewState", 10, 20);
            Assert.AreEqual(10, s.MinDelay);
            Assert.AreEqual(20, s.MaxDelay);
        }

        [TestMethod]
        public void AddTransition()
        {
            State s1= script.AddState("State1");
            script.AddState("State2");
            Transition t= script.AddTransition("Transition 1", "State1", "State2", action);
            Assert.IsTrue(s1.Transitions.Contains(t));
        }

        [TestMethod]
        public void AddTransitionToSelf()
        {
            State s1 = script.AddState("State1");
            Transition t = script.AddTransition("Transition1", "State1", "State1", action);
            Assert.AreEqual(s1, t.ToState);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Transition Transition1:State1->UnknownState can not be added because UnknownState state has not been defined.")]
        public void AddTransitionToUnknownState()
        {
            script.AddState("State1");
            script.AddState("State2");
            script.AddTransition("Transition1", "State1", "UnknownState", action);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Transition Transition1:UnknownState->State2 can not be added because UnknownState state has not been defined.")]
        public void AddTransitionFromUnknownState()
        {
            script.AddState("State1");
            script.AddState("State2");
            script.AddTransition("Transition1", "UnknownState", "State2", action);
        }

        [TestMethod]
        public void AddTransitionToSameState()
        {
            script.AddState("State1");
            script.AddTransition("Transition1", "State1", "State1", action);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void AddTransitionWithNullAction()
        {
            script.AddState("State1");
            script.AddTransition("Transition", "State1", "State1", null);
        }

        [TestMethod]
        public void StartState()
        {
            State s1 = script.AddState("State1");
            script.AddState("State2");
            Assert.AreEqual(s1, script.StartState);
        }

        [TestMethod]
        public void AddTransitionWithWeight()
        {
            State s1 = script.AddState("State1");
            script.AddTransition("Transition1", "State1", "State1", 10, action);
        }

        [TestMethod]
        public void AddConditionToTransition()
        {
            State s1 = script.AddState("s1");

            Script.Action condition = delegate { return false; };
            Transition t=script.AddTransition("T1", "s1", "s1", action, condition);
            Assert.AreEqual(condition, t.Condition);

        }

        [TestMethod]
        public void ScriptCanCreateGlobals ()
        {
            Script s = new Script("Test");
            object globals = s.CreateGlobals();
            Assert.IsNull(globals);
        }

        class TestScript:Script
        {
            internal class Globals {}
            public TestScript() : base("Test")
            {
            }

            public override object CreateGlobals()
            {
                return new Globals();
            }
        }

        [TestMethod]
        public void CreateGlobalsIsOverridable()
        {
            Script s = new TestScript();
            object globals = s.CreateGlobals();
            Assert.IsNotNull(globals);
            Assert.IsInstanceOfType(globals, typeof(TestScript.Globals));
        }

        [TestMethod]
        public void ScriptCanHaveGlobalAction()
        {
            Script s = new Script("Test");
            bool executed = false;
            s.LeaveStateAction = delegate {
                                              executed = true;
                                              return true;};
            Assert.IsNotNull(s.LeaveStateAction);
            s.LeaveStateAction(null);
            Assert.IsTrue(executed);

        }

        [TestMethod]
        public void ScriptHasFailureBehavior()
        {
            Script s = new Script("Test");
            Assert.AreEqual(TransitionFailureBehavior.Repeat, s.TransitionFailureBehavior);
        }

        [TestMethod]
        public void ScriptCanSetFailureBehavior()
        {
            Script s = new Script("Test");
            s.TransitionFailureBehavior = TransitionFailureBehavior.Restart;
            Assert.AreEqual(TransitionFailureBehavior.Restart, s.TransitionFailureBehavior);
           
        }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\VerboseResultTest.cs ===
using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    /// <summary>
    /// Summary description for VerboseResultTest
    /// </summary>
    [TestClass]
    public class VerboseResultTest
    {
        [TestMethod]
        public void SuccessProperties()
        {
            VerboseResult result = VerboseResult.Success;
            Assert.IsTrue(result.Successful);
            Assert.AreEqual(String.Empty, result.Description);
        }

        [TestMethod]
        public void SuccessIsTheSame ()
        {
            Assert.AreSame(VerboseResult.Success, VerboseResult.Success);
        }

        [TestMethod]public void FailureProperties()
        {
            string descr = "This is failure description";
            VerboseResult result = VerboseResult.CreateFailure(descr);
            Assert.IsFalse(result.Successful);
            Assert.AreEqual(descr, result.Description);
        }

        [TestMethod]
        public void FailureWithSameDescrIsEqual()
        {
            VerboseResult failure1 = VerboseResult.CreateFailure("Test");
            VerboseResult failure2 = VerboseResult.CreateFailure("Test");
            Assert.AreEqual(failure1,failure2);
        }

        [TestMethod]
        public void ComparisonIsImplemented()
        {
            VerboseResult failure1 = VerboseResult.CreateFailure("Test");
            VerboseResult failure2 = VerboseResult.CreateFailure("Test");
            Assert.IsTrue(failure1==failure2);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "FailureDescription should not be empty or null.")]
        public void FailureWithNullString()
        {
            VerboseResult.CreateFailure(null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "FailureDescription should not be empty or null.")]
        public void FailureWithEmptyString()
        {
            VerboseResult.CreateFailure("");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ZeroDowntime.Tests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("ZeroDowntime.Tests")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c930ef8e-1654-4ff1-8349-e5807935d143")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\partnermgr\CheckWebCacheReload\MgmtCommand.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;

namespace CheckWebCacheReload
{
	// Source taken and modified from PartnerMgr tool source code
	public class MgmtCommand
	{
		private const int MGMT_TIMEOUT = 5000;
		private const int MGMT_PORT    = 4100;
		static Regex regexSize = new Regex(@"Size=(?<size>[^/n]*)");
		static Regex regexResult = new Regex(@"Result=(?<size>[^/n]*)");
		
		// ----------------------------------------------------------------------------
		// Function RunCommand
		//
		// This function will execute the XMgmt command.
		//
		// Returns: string - the string returned from the webcache after executing the
		//          command.
		//
		// ----------------------------------------------------------------------------
		public static string RunCommand(string target, string command)
		{
			command += "\n";

			//
			//  Set five second send and receive timeouts so we don't hang on management commands.
			//

			TcpClient client = new TcpClient();        
			StringBuilder SB = null;
			client.SendTimeout    = MGMT_TIMEOUT;
			client.ReceiveTimeout = MGMT_TIMEOUT;
			client.NoDelay        = true;
        
			client.Connect(target, MGMT_PORT);

			try
			{
				NetworkStream stream = client.GetStream();
				TextReader    reader = new StreamReader(stream);

				if (!(stream.CanWrite && stream.CanRead))
				{
					throw new Exception("Management command failed, can't read or write network stream");
				}

				byte[] sendBytes = Encoding.ASCII.GetBytes(command);

				stream.Write(sendBytes, 0, sendBytes.Length);

				string t     = reader.ReadLine();
				SB = new StringBuilder();

				while (null != t)
				{
					// Check to see if we have a result code line to parse.
					Match matchResult = regexResult.Match(t);

					if (matchResult.Length != 0)
					{
						// We have finished parsing the response to the query.
						int    resultValue = Convert.ToInt32(matchResult.Groups[1].Value);

						if (0 == resultValue)
						{
							break;
						}
						else
						{
							// Throw an error
							throw new Exception("Management command failed, bad return value." + target + ":" + command + ":" + t + ":" + resultValue);
						}
					}

					// Parse the size line.
					Match  match = regexSize.Match(t);
            
					if (match.Length == 0)
					{
						// Size line not parsed, this must be an error
						throw new Exception("Management command failed, couldn't parse size." + target + ":" + command + ":" + t);
					}
            
					int    dataLength = Convert.ToInt32(match.Groups[1].Value);
					char[] buffer     = new char[dataLength];

					reader.Read(buffer, 0, dataLength);
					SB.Append(buffer);

					t = reader.ReadLine();
				}

			}
			catch (Exception e)
			{
				Trace.WriteLine(e);
			}
			finally
			{
				client.Close();
			}
		
			return SB.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\partnermgr\CheckWebCacheReload\WCEvent.cs ===
using System;
using System.Diagnostics;
using System.Collections;

namespace CheckWebCacheReload
{
	/// <summary>
	/// Class for parsing and logging the web cache events.
	/// </summary>
	public class WCEvent
	{
		public enum WCTYPE {wcgeneral=1, wcusers, wcstats, wcpresence};
		
		/// <summary>
		/// Get all events in the application event log for the given eventID and 
		/// whose date is >= to the given date.
		/// </summary>
		/// <param name="srv"></param>
		/// <param name="eventID"></param>
		/// <param name="date"></param>		
		public bool GetEvents(string srv, int eventID, DateTime date, uint wcType)
		{
			EventLog[] eventLogs = EventLog.GetEventLogs(srv);
			EventLog appLog = null;	
			WCTYPE wcName = GetEnumType(wcType);
			bool result = false;

			try
			{
				foreach (EventLog eventLog in eventLogs)
				{				
					if (eventLog.LogDisplayName == "Application")
					{
						appLog = eventLog;
						break;					
					}
				}

				if (appLog == null)
					throw new Exception("Couldn't find application log.");

				ArrayList wcEvents = new ArrayList();
				EventLogEntryCollection entries = appLog.Entries;	
				string cmd = ":" + wcName.ToString();		
				//
				// NOTE:
				// I am using EventLogEntry.ReplacementStrings instead of 
				// EventLogEntry.Message because the event log is returning
				// a formatting error for Message and ReplacementStrings contains
				// the actual message we are interested in without the extra error
				// that is added to Message.
				//
				// If ReplacementStrings will not work anymore, try using the Message 
				// property instead.
				//				
				foreach(EventLogEntry entry in entries)
				{
					// Parse by eventid, datetime, and web cache name					
					if ((entry.EventID == eventID) && (entry.TimeGenerated >= date)
						&& (entry.ReplacementStrings[0].ToLower().IndexOf(cmd) > -1))		
					{
						wcEvents.Add(entry);						
					}
				}				

				// Validate count of events found
				if (wcEvents.Count == 0)
				{
					throw new WCEventException("No events were found for web cache " + wcName.ToString());
				}				

				// Print the web cache events found
				Trace.WriteLine("EVENTS FOUND FOR " + wcName.ToString().ToUpper() + ":");				
				foreach (EventLogEntry entry1 in wcEvents)
				{
					Trace.WriteLine(entry1.TimeGenerated + " - " + entry1.ReplacementStrings[0]);
				}
				Trace.Write("\r\n");

				// After finding all the events that we are interested in,
				// parse these events.
				if (ParseWCEvents(wcEvents, wcType) == false)
				{
					Trace.WriteLine("\nFAIL: Did not find expected events for web cache " + wcName);					
				}
				else
					result = true;
			}
			catch (WCEventException e)
			{
				Trace.WriteLine(e.Message);
			}
			catch (Exception e)
			{
				Trace.WriteLine(e);
			}
			return result;
		}

		/// <summary>
		/// Parse passed event and look for specific criteria to determine if 
		/// operation was successful.
		/// - mgmt command
		/// - HR: 0x00000000 means operation is successful
		/// </summary>
		/// <param name="entry"></param>
		private bool ParseWCEvents(ArrayList wcEvents, uint wcType)
		{
			WCTYPE wcName = GetEnumType(wcType);
			bool result = false;
			bool resultPartners = false;
			bool resultTitles = false;
			bool resultLBs = false;						

			try
			{				
				// Look only for the first 2 events
				// 3 events if it is wcstats
				foreach (EventLogEntry entry1 in wcEvents)
				{																				
					// Check for expected strings 
					//					
					string msg = entry1.ReplacementStrings[0].ToLower();
					if (msg.IndexOf("reloadpartners") == -1)
					{
						if (msg.IndexOf("reloadtitles") == -1)
						{
							// Look for reloadLeaderBoards in wcstats
							if (wcType == Constants.WCSTATS)
							{
								if (msg.IndexOf("reloadleaderboards") == -1)
								{
									throw new WCEventException("Error: Mgmt command not found in following event entry:\n"
										+ entry1.ReplacementStrings[0]);
								}
								else
								{	// Found the command string, check for HR
									if (CheckHResult(msg) == true)
										resultLBs = true;
								}
							}
							else
							{
								throw new WCEventException("Error: Mgmt command not found in following event entry:\n"
									+ entry1.ReplacementStrings[0]);
							}
						}
						else
						{
							// Found the command string, check for HR
							if (CheckHResult(msg) == true)
								resultTitles = true;
						}						
					}
					else
					{
						// Found the command string, check for HR
						if (CheckHResult(msg) == true)
							resultPartners = true;
					}
					// Stop if we already found the events we are looking for
					if ((resultTitles) && (resultPartners))
					{
						if (wcType == Constants.WCSTATS)
						{
							if (resultLBs)
							{
								result = true;
								break;
							}
						}
						else
						{
							result = true;
							break;
						}
					}
				}				
			}
			catch (WCEventException e)
			{
				Trace.WriteLine(e.Message);
			}
			catch(Exception e)
			{
				Trace.WriteLine(e);
			}
			
			return result;
		}

		// Check for Hr=0x00000000
		private bool CheckHResult(string s)
		{
			bool retval = false;
			int index = s.ToLower().IndexOf("hr");
			if (index > -1)
			{
				// Get HR value
				string HRString = s.ToLower().Substring(index+3,10);
				// HR value should be 0
				if (HRString == "0x00000000")
				{
					retval = true;
				}
				else
					Trace.WriteLine("HR != 0 in this event entry: " + s);
			}

			return retval;
		}		

		private WCTYPE GetEnumType(uint type)
		{
			WCTYPE enumType;

			switch(type)
			{
				case Constants.WCGENERAL:
					enumType = WCTYPE.wcgeneral; break;
				case Constants.WCPRESENCE:
					enumType = WCTYPE.wcpresence; break;
				case Constants.WCSTATS:
					enumType = WCTYPE.wcstats; break;
				case Constants.WCUSERS:
					enumType = WCTYPE.wcusers; break;
				default:
					enumType = WCTYPE.wcgeneral; break;					
			}
			return enumType;
		}

		public void DumpWCEvents()
		{
		}
				
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\partnermgr\CheckWebCacheReload\CheckWebCacheReload.cs ===
using System;
using System.Diagnostics;
using System.Collections;

namespace CheckWebCacheReload
{
	internal class Constants
	{
		public const uint WCGENERAL = 1;
		public const uint WCUSERS = 2;
		public const uint WCSTATS = 4;
		public const uint WCPRESENCE = 8;	
		public const string STR_WCGENERAL = "wcgeneral";
		public const string STR_WCUSERS = "wcusers";
		public const string STR_WCSTATS = "wcstats";
		public const string STR_WCPRESENCE = "wcpresence";
		public const string LOG_FILE = "CheckWebCacheReload.log";
	}

	/// <summary>
	///  Class for identifying the web cache servers
	/// </summary>
	public class WebCache
	{
		public string wcgeneral_server
		{
			get { return m_wcgeneral_server; }
			set { m_wcgeneral_server = value; }
		}		
		public string wcusers_server
		{
			get { return m_wcusers_server; }
			set { m_wcusers_server = value; }
		}
		public string wcstats_server
		{
			get { return m_wcstats_server; }
			set { m_wcstats_server = value; }
		}
		public string wcpresence_server
		{
			get { return m_wcpresence_server; }
			set { m_wcpresence_server = value; }
		}

		private string m_wcgeneral_server;
		private string m_wcusers_server;
		private string m_wcstats_server;
		private string m_wcpresence_server;
		
		/// <summary>
		/// Default constructor
		/// </summary>
		/// <param name="servers"></param>
		public WebCache(string[] servers)
		{
			// Initialize logging -- Add a listener
			TextWriterTraceListener myWriter;
			myWriter = new TextWriterTraceListener(Constants.LOG_FILE);
			Trace.Listeners.Add(myWriter);			
			Trace.AutoFlush = true;			

			for (int i=0;i<servers.Length;i++)
			{
				uint type = GetServerType(servers[i]);				
				AssignServerVariables(servers[i],type);
			}			
		}

		~WebCache()
		{
			Trace.Close();
		}

		// Code in this function is taken and modified from PartnerMgr tool source code
		private uint GetServerType(string srv)
		{			
			uint type = 0;			

			try
			{
				string strResult = null;								
				strResult = MgmtCommand.RunCommand(srv, "list");				

				// Parse the response to get the list of web caches for the server.
				string[] strSplit = null;
				string strDelimeter = "\r\n";
				char[] chDelim = strDelimeter.ToCharArray();

				strSplit = strResult.Split(chDelim);
				foreach (string strTemp in strSplit)
				{					
					if (strTemp != "")
					{
						string[] strTempSplit = null;
						string strTempDelim = "() \t\r\n";
						char[] chTempDelim = strTempDelim.ToCharArray();

						strTempSplit = strTemp.Split(chTempDelim);

						if (strTempSplit.Length < 4)
						{						
							throw new Exception("Did not find cache name in " + strTemp);
						}
						else
						{
							// Look only at the caches we are interested in
							// Ignore other caches
							switch(strTempSplit[3])
							{
								case Constants.STR_WCGENERAL:
									type |= Constants.WCGENERAL; break;
								case Constants.STR_WCPRESENCE:
									type |= Constants.WCPRESENCE; break;
								case Constants.STR_WCSTATS:
									type |= Constants.WCSTATS; break;
								case Constants.STR_WCUSERS:
									type |= Constants.WCUSERS; break;
							}
						}
					}
				}
			}
			catch (Exception e)
			{				
				Trace.WriteLine(e);
			}			

			return type;
		}

		private bool AssignServerVariables(string srv, uint type)
		{				
			// Validation
			if ((type < 1) || (type > 8) || (srv.Length == 0))
				return false;
			
			// Fill up the server values depending on the type
			// Check the which server has which web caches and name
			// the variable names accordingly
			uint val1=0, val2=0, val3=0, val4=0;
			val1 = type & Constants.WCGENERAL;
			val2 = type & Constants.WCUSERS;
			val3 = type & Constants.WCSTATS;
			val4 = type & Constants.WCPRESENCE;

			if (val1 == Constants.WCGENERAL)			
				m_wcgeneral_server = String.Copy(srv);			
			if (val2 == Constants.WCUSERS)
				m_wcusers_server = String.Copy(srv);
			if (val3 == Constants.WCSTATS)
				m_wcstats_server = String.Copy(srv);
			if (val4 == Constants.WCPRESENCE)
				m_wcpresence_server = String.Copy(srv);			
			
			return true;			
		}
		
		public void DumpWebCacheSrvInfo()
		{
			string[] srvs = new string[4];
			const string strNotFound = "Not Found";

			srvs[0] = Constants.STR_WCGENERAL + ": ";
			srvs[1] = Constants.STR_WCUSERS + ": ";
			srvs[2] = Constants.STR_WCSTATS + ": ";
			srvs[3] = Constants.STR_WCPRESENCE + ": ";

			if (m_wcgeneral_server == null) srvs[0] += strNotFound; 
			else srvs[0] +=  m_wcgeneral_server;
			if (m_wcusers_server == null) srvs[1] += strNotFound; 
			else srvs[1] +=  m_wcusers_server;
			if (m_wcstats_server == null) srvs[2] += strNotFound; 
			else srvs[2] +=  m_wcstats_server;
			if (m_wcpresence_server == null) srvs[3] += strNotFound; 
			else srvs[3] +=  m_wcpresence_server;
			
			// Print out info to log file
			Trace.WriteLine("WEB CACHE SERVERS:");
			Trace.WriteLine("------------------");
			Trace.WriteLine(srvs[0]);
			Trace.WriteLine(srvs[1]);
			Trace.WriteLine(srvs[2]);
			Trace.WriteLine(srvs[3]);
			Trace.Write("\r\n");
		}

		public static void Usage()
		{
			Console.WriteLine("Usage:\n");
			Console.WriteLine("CheckWebCacheReload <datetime> <server1,server2,...>");
			Console.WriteLine("\tdatetime: Events are parsed with date >= datetime." +
				" Format: MM-DD-YYY HH:MM:SS");
			Console.WriteLine("\tserver1,server2,...: List of web cache servers.");			
			Console.Write("\n");
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		public static void Main(string[] args)
		{
			try
			{
				if (args.Length < 2)
					Usage();
				else if (args[0] == "/?")
					Usage();
				else
				{
					// PARSE CMD-LINE ARGUMENTS
					//
					// Date
					System.DateTime date = System.DateTime.Parse(args[0]);
					// server names
					char[] delim = {','};
					string[] servers = args[1].Split(delim);

					// WEB CACHES
					//
					// Populate web cache servers with their addresses
					WebCache wc = new WebCache(servers);
					// Log info to log file
					wc.DumpWebCacheSrvInfo();
				
					// PARSE EVENTS
					//
					WCEvent wce = new WCEvent();				
					bool res = true;
					if (wc.m_wcstats_server != null)
						res = wce.GetEvents(wc.m_wcstats_server, 51511, date, Constants.WCSTATS);
					if (wc.m_wcusers_server != null)
						res = wce.GetEvents(wc.m_wcusers_server, 51511, date, Constants.WCUSERS);
					if (wc.m_wcgeneral_server != null)
						res = wce.GetEvents(wc.m_wcgeneral_server, 51511, date, Constants.WCGENERAL);
					if (wc.m_wcpresence_server != null)
						res = wce.GetEvents(wc.m_wcpresence_server, 51511, date, Constants.WCPRESENCE);
					
					if ((wc.m_wcstats_server == null) || (wc.m_wcusers_server == null)
						|| (wc.m_wcgeneral_server == null) || (wc.m_wcpresence_server == null))
					{
						Trace.WriteLine("WARNING: Not all web cache servers were detected.");
						Console.WriteLine("WARNING: Not all web cache servers were detected.");
					}
					
					if (res)
					{
						Console.WriteLine("Web Cache Reload Test PASSED. See log file for more details.");
						Trace.WriteLine("Web Cache Reload Test PASSED.");
					}
					else
					{
						Console.WriteLine("Web Cache Reload Test FAILED. See log file for more details.");
						Trace.WriteLine("Web Cache Reload Test FAILED.");
					}
				}
			}
			catch (System.Exception e)
			{
				Console.WriteLine(e);
			}			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\ZeroDowntime\ZeroDowntime.Tests\WeightedTransitionSelectionPolicyTest.cs ===
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ZeroDownTime.Framework;

namespace ZeroDowntime.Tests
{
    [TestClass]
    public class WeightedTransitionSelectionPolicyTest
    {
        private Script script = null;
        private State state1 = null;
        private WeightedTransitionSelectionPolicy policy = null;

        [TestInitialize]
        public void SetUp()
        {
            script = new Script("s");
            state1 = script.AddState("s1");
            policy = new WeightedTransitionSelectionPolicy();
        }

        [TestMethod]
        public void TestSingleCandidate()
        {
            Transition t1 = script.AddTransition("T1", "s1", "s1", NullAction);
            IList<Transition> candidates = policy.SelectCandidates(state1, null);
            Assert.AreEqual(1,candidates.Count);
            Assert.AreEqual(t1, candidates[0]);
        }

        [TestMethod]
        public void TestTwoCandidates()
        {
            Transition t1=script.AddTransition("T1", "s1", "s1", NullAction);
            Transition t2 = script.AddTransition("T2", "s1", "s1", NullAction);
            IList<Transition> candidates =policy.SelectCandidates(state1, null);
            Assert.AreEqual(2, candidates.Count);
            Assert.AreNotEqual(-1, candidates.IndexOf(t1));
            Assert.AreNotEqual(-1, candidates.IndexOf(t2));
        }

        [TestMethod]
        public void TestNoTransitionsInState()
        {
            IList<Transition> candidates = policy.SelectCandidates(state1, null);
            Assert.AreEqual(0, candidates.Count);
        }

        [TestMethod]
        public void TestOneEnabledOutOfTwo()
        {
            Transition enabled = script.AddTransition("T1", "s1", "s1", NullAction, delegate { return true; });
            Transition disabled = script.AddTransition("T2", "s1", "s1", NullAction, delegate { return false; });
            IList<Transition> candidates = policy.SelectCandidates(state1, null);
            Assert.AreEqual(1, candidates.Count);
            Assert.AreEqual(-1, candidates.IndexOf(disabled));

        }

        public bool NullAction(object g)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\partnermgr\CheckWebCacheReload\WCEventException.cs ===
using System;

namespace CheckWebCacheReload
{
	/// <summary>
	/// Summary description for WCEventException.
	/// </summary>
	public class WCEventException : System.Exception
	{
		public WCEventException()
		{
		}		
		public WCEventException(string s) : base(s)
		{			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\partnermgr\GeneratePartnerXML\PartnerXML.cs ===
using System;
using System.Xml;
using System.Text;

namespace GeneratePartnerXML
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class PartnerXML
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			PartnerXML p = new PartnerXML();
			if (args.Length != 7)
			{
				p.Usage();
				return;
			}						
			
			p.GenerateXMLFile(args[0],args[1],Convert.ToInt32(args[2]),
				Convert.ToInt32(args[3]),args[4],Convert.ToInt32(args[5]),
				Convert.ToInt32(args[6]));
		}
		
		// Generates XML file with partners
		public void GenerateXMLFile(string filename, string partPrefix, int numOfPartners, 
			int partnerStartID, string groupPrefix, int numOfGroups, int groupStartID)
		{
			try
			{				
				XmlDocument xmlDoc = new XmlDocument();
				xmlDoc.LoadXml("<?xml version=\"1.0\" encoding=\"UTF-8\"?><PartnerGroups xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.xboxlive.com\" version=\"1.0.0\"></PartnerGroups>");				

				int numPartnersInGroup = numOfPartners / numOfGroups;
				int leftOverPartners = numOfPartners - numPartnersInGroup*numOfGroups;				

				for (int k=groupStartID;k<(numOfGroups+groupStartID);k++)
				{
					XmlNode xmlNodePartnerGroup = null;
					XmlAttribute xmlNodeAttrib = null;
					
					// <PartnerGroup>
					// Create the node for the partner group
					xmlNodePartnerGroup = xmlDoc.CreateNode(XmlNodeType.Element, "PartnerGroup", null);
					// Create the partner group attributes.						
					xmlNodeAttrib = xmlDoc.CreateAttribute("ID");
					xmlNodeAttrib.Value = k.ToString();
					xmlNodePartnerGroup.Attributes.Append(xmlNodeAttrib);
					xmlNodeAttrib = xmlDoc.CreateAttribute("Description");
					xmlNodeAttrib.Value = groupPrefix + k;
					xmlNodePartnerGroup.Attributes.Append(xmlNodeAttrib);

					// Append the node to the document. Keep the node around so that we can add the children.
					xmlNodePartnerGroup = xmlDoc.DocumentElement.AppendChild(xmlNodePartnerGroup);										

					for (int i=0;i<numPartnersInGroup;i++)
					{												
						XmlNode xmlNodePartner = null;					

						// <Partner>
						// Create the node for the partner
						xmlNodePartner = xmlDoc.CreateNode(XmlNodeType.Element, "Partner", null);
						// Create the partner attributes.
						xmlNodeAttrib = xmlDoc.CreateAttribute("ID");
						xmlNodeAttrib.Value = partnerStartID.ToString();
						xmlNodePartner.Attributes.Append(xmlNodeAttrib);
						xmlNodeAttrib = xmlDoc.CreateAttribute("GroupID");
						xmlNodeAttrib.Value = k.ToString();
						xmlNodePartner.Attributes.Append(xmlNodeAttrib);
						xmlNodeAttrib = xmlDoc.CreateAttribute("Description");
						xmlNodeAttrib.Value = partPrefix + partnerStartID;
						xmlNodePartner.Attributes.Append(xmlNodeAttrib);
						xmlNodeAttrib = xmlDoc.CreateAttribute("CertificateName");
						xmlNodeAttrib.Value = "test.part" + partnerStartID + ".rdo.001";
						xmlNodePartner.Attributes.Append(xmlNodeAttrib);
						xmlNodeAttrib = xmlDoc.CreateAttribute("CredentialType");
						xmlNodeAttrib.Value = "1";
						xmlNodePartner.Attributes.Append(xmlNodeAttrib);						

						// Append <Partner> to <PartnerGroup>
						xmlNodePartner = xmlNodePartnerGroup.AppendChild(xmlNodePartner);

						// <APIs>
						// Add 2 APIs
						// Create the node for the APIs
						XmlNode xmlNodeAPIs = xmlDoc.CreateNode(XmlNodeType.Element, "APIs", "");        				
						// Append the node to the <Partner> node
						xmlNodeAPIs = xmlNodePartner.AppendChild(xmlNodeAPIs);
						// <API>
						XmlNode xmlNodeAPI = xmlDoc.CreateNode(XmlNodeType.Element, "API", "");
						// Add attributes
						xmlNodeAttrib = xmlDoc.CreateAttribute("Name");
						xmlNodeAttrib.Value = "Query.Add";
						xmlNodeAPI.Attributes.Append(xmlNodeAttrib);
						xmlNodeAPIs.AppendChild(xmlNodeAPI);							
						// <API>
						xmlNodeAPI = xmlDoc.CreateNode(XmlNodeType.Element, "API", "");
						// Add attributes
						xmlNodeAttrib = xmlDoc.CreateAttribute("Name");
						xmlNodeAttrib.Value = "Query.CompetitionCreateSingleElimination";
						xmlNodeAPI.Attributes.Append(xmlNodeAttrib);
						xmlNodeAPIs.AppendChild(xmlNodeAPI);	
																

						// <Titles>
						// Create the node for the Titles
						XmlNode xmlNodeTitles = xmlDoc.CreateNode(XmlNodeType.Element, "Titles", "");	        				
						// Append the node to the <Partner> node
						xmlNodeTitles = xmlNodePartner.AppendChild(xmlNodeTitles);
						
						// Add 2 titles
						uint[] titleIDs = new uint[2];
						titleIDs[0] = 1397030931;
						titleIDs[1] = 1397030943;
						for (int j=0;j<2;j++)
						{
							// <Title>
							XmlNode xmlNodeTitle = xmlDoc.CreateNode(XmlNodeType.Element, "Title", "");
							// Add attributes
							xmlNodeAttrib = xmlDoc.CreateAttribute("TitleID");
							xmlNodeAttrib.Value = titleIDs[j].ToString();
							xmlNodeTitle.Attributes.Append(xmlNodeAttrib);
							xmlNodeAttrib = xmlDoc.CreateAttribute("Privileges");
							xmlNodeAttrib.Value = "1";
							xmlNodeTitle.Attributes.Append(xmlNodeAttrib);
							xmlNodeAttrib = xmlDoc.CreateAttribute("Rating");
							xmlNodeAttrib.Value = "MATURE";
							xmlNodeTitle.Attributes.Append(xmlNodeAttrib);
							xmlNodeAttrib = xmlDoc.CreateAttribute("ClusterID");
							xmlNodeAttrib.Value = "1";
							xmlNodeTitle.Attributes.Append(xmlNodeAttrib);

							// Append <Title> to <Titles>
							xmlNodeTitles.AppendChild(xmlNodeTitle);
						}
						
						// <IPAddresses>
						// Add 1 IP address
						XmlNode xmlNodeIPAddresses = xmlDoc.CreateNode(XmlNodeType.Element, "IPAddresses", "");        											
						xmlNodeIPAddresses = xmlNodePartner.AppendChild(xmlNodeIPAddresses);
						XmlNode xmlNodeIPAddress = xmlDoc.CreateNode(XmlNodeType.Element,"IPAddress","");
						xmlNodeAttrib = xmlDoc.CreateAttribute("address");
						xmlNodeAttrib.Value = "192.168.86.12:255.255.255.0";
						xmlNodeIPAddress.Attributes.Append(xmlNodeAttrib);
						xmlNodeIPAddresses.AppendChild(xmlNodeIPAddress);		
				
						++partnerStartID;
						
					}
				}
				XmlTextWriter tw = new XmlTextWriter(filename, Encoding.UTF8);
				tw.Formatting = Formatting.Indented;
				xmlDoc.Save(tw);
				tw.Close();
			}
			catch(Exception e)
			{
				Console.WriteLine(e);				
			}			
		}

		public void Usage()
		{
			Console.WriteLine();
			Console.WriteLine("USAGE:");
			Console.WriteLine("GeneratePartnerXML.exe XMLFileName partnerPrefix numOfPartners " +
				"partnerStartID groupPrefix numOfGroups groupStartID");
			Console.WriteLine();
			Console.WriteLine("XMLFileName:\tName of XML file to hold the created partners.");
			Console.WriteLine("partnerPrefix:\tPrefix of partner name to be appended with partner ID.");
			Console.WriteLine("numOfPartners:\tTotal number of partners to be created.");
			Console.WriteLine("partnerStartID:\tID of the first partner corresponding " +
				"to webdb.dbo.t_partners.i_partner_id.");
			Console.WriteLine("groupPrefix:\tPrefix of group name to be appended with group ID.");						
			Console.WriteLine("numOfGroups:\tNumber of new groups to be created.");
			Console.WriteLine("groupStartID:\tID of the first group corresponding " +
				"to webdb.dbo.t_partner_groups.i_partner_group_id.");
			Console.WriteLine();
			Console.WriteLine("PURPOSE:");
			Console.WriteLine("The purpose of this tool is to generate a large number of partners " +
				"in the XML file to be imported later by PartnerMgr.");
			
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_datagenerator_none_12.4.56.0_none_458ec9a81bf9eefe
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=datagenerator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.manifest
XP_MANIFEST_PATH=manifests\msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.cat
XP_CATALOG_PATH=manifests\msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.cat
XP_PAYLOAD_PATH=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=datagenerator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_datagenerator_none_12.4.56.0_none_458ec9a81bf9eefe
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=datagenerator
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.manifest
XP_MANIFEST_PATH=manifests\msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.cat
XP_CATALOG_PATH=manifests\msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc.cat
XP_PAYLOAD_PATH=msil_datagenerator_no-public-key_12.4.56.0_x-ww_f9700dcc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=datagenerator,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\SQLDataProvider.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace DataGenerator
{
	public class SQLDataProvider
	{
		private SqlConnection m_Conn;
		private SqlCommand m_Cmd;
		private SqlDataReader m_reader;

		public SQLDataProvider() 
		{
			m_Conn = null;
			m_Cmd = null;
		}

		public bool InitializeConnection(
			string server,
			string DB
			)
		{
			bool retval=false;
			try 
			{
				if ((server == "") || (DB == "")) return false;
				m_Conn = new SqlConnection(
					"Data Source=" + server + ";Initial Catalog=" +
					DB + ";Trusted_Connection=Yes"
					);
				m_Conn.Open();
				retval=true;
			}
			catch (Exception e)
			{
				throw(e);
			}
			return retval;
		}

		public SqlDataReader ExecuteQueryReturn(string cmd)
		{
			if (cmd == "") 
				throw new Exception("SQL command string is empty.");

			m_Cmd = new SqlCommand();
			m_Cmd.Connection = m_Conn;
			m_Cmd.CommandType = CommandType.Text;
			m_Cmd.CommandText = cmd;
			m_reader = m_Cmd.ExecuteReader();
			return m_reader;	
		}

		public void ExecuteQuery(string cmd)
		{
			if (cmd == "") 
				throw new Exception("SQL command string is empty.");

			m_Cmd = new SqlCommand();
			m_Cmd.Connection = m_Conn;
			m_Cmd.CommandType = CommandType.Text;
			m_Cmd.CommandText = cmd;			
			m_Cmd.ExecuteNonQuery();
		}
		/*public bool Write(string tableName, Hashtable cols)
		{
			try
			{
				if ((tableName == "") || (cols.Count == 0))
					return false;
				// Generate random values for each column in cols
				// depending on its data type
				if (tableName == "UODB_Users");
				if (tableName == "UODB_Subscriptions");
				if (tableName == "WEBDB_TitleInfo");
				if (tableName == "WEBDB_TitleNameInfo");

				foreach (DictionaryEntry e in cols)
				{
					if (e.Key == "ti_country_id");
					if (e.Key == "i_offer_type_id");
					if (e.Key == "i_credential_type");
					if (e.Key == "vc_api_name");
					if (e.Key == "i_title_id");
					if (e.Key == "bi_team_puid");
					if (e.Key == "bi_user_puid");
				}
			}
			catch (Exception e)
			{
			}
		}
		
		public bool WriteTableValues(string tableName, string[] valueList)
		{
			bool retval=false;
			try
			{
				if ((tableName == "") || (valueList.Length == 0))
					return false;
				m_Cmd = new SqlCommand();
				m_Cmd.Connection = m_Conn;
				m_Cmd.CommandType = CommandType.Text;
				System.Text.StringBuilder values = new System.Text.StringBuilder();
				int i=0;
				for(i=0;i<valueList.Length;i++)
				{
					values.Append(valueList[i]);
					values.Append(",");
				}
				// Remove last colon
				if (i > 0) 
					values.Remove(values.Length-1,1);
				string cmdText = 
					"INSERT " + tableName + " VALUES(" +
					values + ")";					
				m_Cmd.CommandText = cmdText;
				int numRows = m_Cmd.ExecuteNonQuery();
				if (numRows > 0) 
					retval=true;
				else
					throw new Exception("No rows have been inserted!");
			}
			catch (Exception e)
			{
				throw(e);
			}
			return retval;
		}
		*/
		public void Close()
		{
			if (m_Cmd != null)
				m_Cmd = null;
			if (m_reader != null) m_reader.Close();
			if (m_Conn != null)
			{
				m_Conn.Close();m_Conn=null;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\DataGenerator\DataGenerator.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Data.SqlClient;
using System.Text;
using System.IO;

namespace DataGenerator
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class TestData
	{
		private string m_Server;
		private string m_DB;
		private string m_Date;
		private bool m_bUseDate;		
		private string XML_FILE_DIR;		
		internal ArrayList m_CountryCodes;
		internal int m_NumCountries;
		internal uint m_NumRows;
		
		public TestData(string server, string DB, string date, string tablesDir, string sNumRows)
		{
			m_Server = server;
			m_DB = DB;
			
			if (date != "")
			{
				m_Date = date;
				m_bUseDate = true;
			}
			else
				m_bUseDate = false;
			
			if (tablesDir != "")
				XML_FILE_DIR = tablesDir;			
			else
				XML_FILE_DIR = "tables";						

			if (sNumRows != "")
				m_NumRows = System.Convert.ToUInt32(sNumRows);
			else
				m_NumRows = 100;

			m_CountryCodes = new ArrayList();
			m_NumCountries = 0;                        
		}

		public void GenerateXMLFileForTables(string[] tables, bool bAddGeneric)
		{
			// if the tables directory does not exist, create it
			if (!Directory.Exists(XML_FILE_DIR))
			{
				DirectoryInfo dInfo = Directory.CreateDirectory(XML_FILE_DIR);
				if (dInfo == null)
					throw new Exception("Could not create directory " + XML_FILE_DIR + ".");
			}
			
			// Connect to SQL through DMO
			SQLDMO.SQLServer sqlServer = new SQLDMO.SQLServerClass();
			sqlServer.LoginSecure = true;
			sqlServer.LoginTimeout = 30;
			sqlServer.Connect(m_Server,"","");
			
			// Get database ID			
			int id=0;
			bool bFoundDB = false;
			// Find DB ID
			foreach (SQLDMO.Database db in sqlServer.Databases)
			{
				string sname = db.Name.ToLower();
				if (sname == m_DB.ToLower())
				{					
					id = db.ID;
					bFoundDB = true;
					break;
				}				
			}
		
			if (!bFoundDB)
				throw new Exception("Did not find database " + m_DB + ".");

			// Get DB object from ID
			SQLDMO._Database Database = sqlServer.Databases.ItemByID(id);

			SQLDMO.Table[] tableList;
			if (tables != null)
				tableList = new SQLDMO.Table[tables.Length];
			else
				tableList = new SQLDMO.Table[Database.Tables.Count];

			int i=0;
			int tablesFound = 0;
			// Get tables and columns for the tables specified in the array
			if (tables != null)
			{
				foreach(string tbl in tables)
				{				
					// For each table, try to find it in the DMO table list
					foreach (SQLDMO.Table DMOTbl in Database.Tables)
					{									
						// If table is not found in DB, iterate to the next table
						if (DMOTbl.Name.ToLower() != tbl.ToLower()) continue;

						// We found the table, so create the xml file
						XmlTextWriter xmlw = new XmlTextWriter(XML_FILE_DIR + "\\" + 
							tbl + ".xml", Encoding.UTF8);
						xmlw.Formatting = Formatting.Indented;				
						xmlw.WriteStartDocument();

						++tablesFound;
						xmlw.WriteStartElement("TABLE");
						xmlw.WriteAttributeString("NAME",tbl);
						xmlw.WriteStartElement("ADDROWS");
						xmlw.WriteString(m_NumRows.ToString());
						xmlw.WriteEndElement();
						xmlw.WriteStartElement("COLUMNS");
						// We found the table in question, so get the columns
						for(i=1;i <= DMOTbl.Columns.Count; i++)
						{
							SQLDMO._Column col = DMOTbl.Columns.Item(i);
							xmlw.WriteStartElement("COL");
							xmlw.WriteAttributeString("NAME",col.Name);						
							xmlw.WriteAttributeString("DATATYPE",col.Datatype);
							xmlw.WriteAttributeString("SIZE",col.Length.ToString());
							if (bAddGeneric)
								xmlw.WriteString(GetSymbol(col.Datatype,col.Length));
							xmlw.WriteEndElement();
						}
						xmlw.WriteEndElement();
						xmlw.WriteEndElement();
						xmlw.Flush();
						xmlw.Close();

						// If we already found all tables requested, then exit from this loop
						if (tables.Length > 0)
							if (tablesFound == tables.Length) break;
					}				
				}
			}
			// Otherwise, if we did not specify the table list, then in this case
			// get all the tables in the database
			else
			{				
				// Get all tables in the database
				foreach (SQLDMO.Table DMOTbl in Database.Tables)
				{

					// create the xml file
					XmlTextWriter xmlw = new XmlTextWriter(XML_FILE_DIR + "\\" + 
						DMOTbl.Name + ".xml", Encoding.UTF8);
					xmlw.Formatting = Formatting.Indented;				
					xmlw.WriteStartDocument();

					++tablesFound;
					xmlw.WriteStartElement("TABLE");
					xmlw.WriteAttributeString("NAME",DMOTbl.Name);
					xmlw.WriteStartElement("ADDROWS");
					xmlw.WriteString(m_NumRows.ToString());
					xmlw.WriteEndElement();
					xmlw.WriteStartElement("COLUMNS");
					// We found the table in question, so get the columns
					for(i=1;i <= DMOTbl.Columns.Count; i++)
					{
						SQLDMO._Column col = DMOTbl.Columns.Item(i);
						xmlw.WriteStartElement("COL");
						xmlw.WriteAttributeString("NAME",col.Name);						
						xmlw.WriteAttributeString("DATATYPE",col.Datatype);
						xmlw.WriteAttributeString("SIZE",col.Length.ToString());
						if (bAddGeneric)
							xmlw.WriteString(GetSymbol(col.Datatype,col.Length));
						xmlw.WriteEndElement();
					}
					xmlw.WriteEndElement();
					xmlw.WriteEndElement();
					xmlw.Flush();
					xmlw.Close();
				}				
			}

			sqlServer.DisConnect();
		}

		private string GetSymbol(string dataType, int size)
		{
			string symbol = "";
			//char, varchar, text, nchar, nvarchar, or ntext
			if ((dataType == "char")
				|| (dataType == "varchar")
				|| (dataType == "text")
				|| (dataType == "nchar")
				|| (dataType == "nvarchar")
				|| (dataType == "ntext"))
			{
				// random string of maximum length=size
				symbol = "@S[" + size + "]";
			}
				// bigint, int, smallint, tinyint, float, real, decimal, numeric, bit,
				// money, smallmoney
			else if ((dataType == "int")
				|| (dataType == "smallint")
				|| (dataType == "tinyint")
				|| (dataType == "real")
				|| (dataType == "smallmoney"))
			{
				// random number of maximum length=size
				symbol = "@[1," + (Math.Pow(2,(double)(size*8-1))-1).ToString() + "]";
			}
			// the size of bit is smaller than 1 byte, so special case
			else if (dataType == "bit")
			{
				symbol = "@[0,1]";
			}
				// max number for 8 bytes is 9.22337203685478E+18
				// Since we don't want this notation in the file, use @N instead 
			else if ((dataType == "bigint")
				|| (dataType == "float")
				|| (dataType == "decimal")
				|| (dataType == "numeric")
				|| (dataType == "money"))
			{
				symbol = "@N";
			}
				// datetime, smalldatetime
			else if ((dataType == "datetime")
				|| (dataType == "smalldatetime"))
			{
				// Current UTC date
				symbol = "@DATE";
			}
				// binary, varbinary, image
			else if ((dataType == "binary")
				|| (dataType == "varbinary")
				|| (dataType == "image"))
			{
				// Current UTC date
				symbol = "0x1";
			}
			return symbol;
		}

		public void PopulateAllTables(bool bXReport3CountryCodes)
		{
            if (bXReport3CountryCodes)
                GetCountryCodes();

            // Populate each table that has a corresponding XML file
			string[] fileList = Directory.GetFiles(XML_FILE_DIR,"*.xml");
			foreach(string file in fileList)
			{
				ParseXMLFileAndPopulate(file);
			}

			
			/*-----------------------------------------
			  TABLES TO POPULATE
			  -----------------------------------------
				UODB:
				UODB_Users
				UODB_Offers
				UODB_TitleOffers
				UODB_OfferLocations
				UODB_OfferRegions
				UODB_Subscriptions
				UODB_User_Web_Mapping
				
				WEBDB:
				WEBDB_APIs
				WEBDB_CredentialTypes
				WEBDB_PartnerAllowedAPIs
				WEBDB_PartnerAllowedTitles
				WEBDB_PartnerGroups
				WEBDB_Partners
				WEBDB_TitleInfo
				WEBDB_TitleNameInfo
				
				XPROF:
				XPROF_Users
				XPROF_Friend_Lists
				XPROF_TeamMembers
				XPROF_TeamNames
				XPROF_Teams
				XPROF_UserTeams
				
				SPS:
				SPSCustomerAccount
				SPSCustomerSubscription
				
				LOG DATA:
				RawContentDownload
				RawContentRef
				RawCreateAccount
				RawEnforcement				
				RawFeedback
				RawKilled
				RawStorage
				RawUserIPs
				RawWebServices
				
				OTHER:
				AccountsPersonalInfo
			*/

			/*PopulateUODBTables();
			PopulateWEBDBTables();
			PopulateXPROFTables();			
			PopulateLOGData();*/

			//ParseXMLFile
		}

		private void GetCountryCodes()
		{
			SQLDataProvider sql = new SQLDataProvider();
			sql.InitializeConnection(m_Server,m_DB);
			SqlDataReader reader = sql.ExecuteQueryReturn("p_XRSupp_GetCountries");

			while (reader.Read())
			{
				m_CountryCodes.Add( System.Convert.ToString(reader["CountryCode"]));
				++m_NumCountries;
			}
			reader.Close();
			sql.Close();
		}

		/// <summary>
		/// Parses XML file and calls a function to populate the table
		/// </summary>
		/// <param name="fileName"></param>
		/// <returns></returns>
		private void ParseXMLFileAndPopulate(string fileName)
		{			
			XmlDocument doc = new XmlDocument();
			doc.Load(fileName);								

			// Get table name
			XmlNodeList nodeList = doc.SelectNodes("/TABLE/@NAME");
			XmlNode node = nodeList.Item(0);
			if (node == null)
				throw new Exception("No table was defined in " + fileName);			

			// Get rows to add
			nodeList = doc.SelectNodes("/TABLE/ADDROWS");
			// Debugging
            /*Console.WriteLine(nodeList.Item(0).Value);
			Console.WriteLine(nodeList.Item(0).InnerXml);
			Console.WriteLine(nodeList.Item(0).OuterXml);*/

			string rowsToAdd = nodeList.Item(0).FirstChild.InnerText;
			int numRows = System.Convert.ToInt32(rowsToAdd);

            Console.WriteLine("Rows to add: {0}",rowsToAdd);
            Console.WriteLine("Table: {0}",node.Value);
			
			// Get column names
			XmlNodeList cols = doc.SelectNodes("/TABLE/COLUMNS/COL");
			if (cols.Count == 0)
				throw new Exception("No columns were defined in " + fileName);
			// Have a counter for every @N computation for every column in a row				
			long[] counters = new long[cols.Count];
			// same for sequential string
			StringBuilder[] SequentialString = new StringBuilder[cols.Count];
			int character = 65;
            System.Random rnd = new Random();
			// Generate SQL statement to populate table for the given number of rows to add
			for(int j=0;j<numRows;j++)
			{
				// Build SQL statement
				StringBuilder sqlString = new StringBuilder();
				StringBuilder valuesString = new StringBuilder();
				sqlString.Append("INSERT ");
				// Append table name
				string tableName = node.Value;
				sqlString.Append(tableName);
				sqlString.Append(" (");
				string sValues = " values (";
				valuesString.Append(sValues);				
				
				for(int w=0;w<cols.Count;w++)
				{					
					XmlNode col = cols[w];
					XmlAttribute attrib2 = col.Attributes["NAME"];
					sqlString.Append(attrib2.Value);
					sqlString.Append(",");
					XmlAttribute attrib3 = col.Attributes["SIZE"];
					int size = System.Convert.ToInt32(attrib3.Value);
					// Get value
					string val = col.InnerText;
					string replaceVal = "";
					// Determine if we have to compute the value
					if (val.StartsWith("@"))
					{
						// Sequential number generation
						if (val.ToUpper() == "@N")
						{
							++counters[w];
							// Check if number is within the limit of the datatype
							if (counters[w] > Math.Pow(2,size*8-1)-1)
								throw new Exception("Value of @N exceeded limit of column." +
									"\r\nTable [" + tableName + "]" +
									"\r\nColumn [" + attrib2.Value + "]" + 
									"\r\nSize=" + size.ToString() +
									"\r\n@N value = " + counters[w]);
							replaceVal = (counters[w]).ToString();
						}
							// Date generation - today's UTC date
						else if (val.ToUpper() == "@DATE")
						{
							if (m_bUseDate)
								replaceVal = "'" + m_Date + "'";
							else
								replaceVal = "'" + DateTime.UtcNow.ToString("MM/dd/yyyy HH:mm") + "'";
						}
							// Date - Add specified hours to today's UTC date
						else if (val.ToUpper().StartsWith("@DATEADD["))
						{
							// [ is at position 8 in @DATEADD[x]
							// and ] is at position length-1
							string sNum = val.Substring(9,val.Length-10);							
							// dNum holds the hours to add to the UTC date
							double dNum = System.Convert.ToDouble(sNum);
							if (m_bUseDate)
							{
								replaceVal = "'" + 
									System.Convert.ToDateTime(m_Date).AddHours(dNum).ToString("MM/dd/yyyy HH:mm")
									+ "'";
							}
							else
								replaceVal = "'" + DateTime.UtcNow.AddHours(dNum).ToString("MM/dd/yyyy HH:mm") + "'";
						}
							// Get the IDT date from the UTC now date
						else if (val.ToUpper() == "@IDTDATE")
						{
							if (m_bUseDate)
							{
								replaceVal = IDTDate(m_Date);
							}
							else
							{
								System.DateTime dt = DateTime.UtcNow;
								replaceVal = IDTDate(dt.ToString("MM/dd/yyyy HH:mm"));
							}
						}
							// Add hours to IDT Date
						else if (val.ToUpper().StartsWith("@IDTDATEADD["))
						{
							// [ is at position 11 in @DATEADD[x]
							// and ] is at position length-1							
							string sNum = val.Substring(12,val.Length-13);							
							// dNum holds the hours to add to the IDT date
							double dNum = System.Convert.ToDouble(sNum);

							if (m_bUseDate)
							{
								string dt = 
									System.Convert.ToDateTime(m_Date).AddHours(dNum).ToString("MM/dd/yyyy HH:mm");									
								replaceVal = IDTDate(dt);
							}
							else
							{
								System.DateTime dt = DateTime.UtcNow;
								dt = dt.AddHours(dNum);
								replaceVal = IDTDate(dt.ToString("MM/dd/yyyy HH:mm"));
							}
						}
							// Pick one number that falls within the given range
						else if ((val.StartsWith("@[")) && (val.EndsWith("]")))
						{
							char[] separator = new char[]{'[',']',',','@'};
							string[] sNum = val.Split(separator);
							// Remove the empty elements from the array
							// and keep only the 2 numbers we are looking for
							int l=0;
							string[] sNum2 = new string[2];
							for(int k=0;k<sNum.Length;k++)
							{
								if (sNum[k] != "")
									sNum2[l++] = sNum[k];
								if (l > 1) break;
							}
							UInt64 start = System.Convert.ToUInt64(sNum2[0]);
							UInt64 stop = System.Convert.ToUInt64(sNum2[1]);                            							
                            UInt64 uiReplaceVal = start + (UInt64)(rnd.NextDouble()*(stop-start));
							replaceVal = uiReplaceVal.ToString();
						}
							// Get a country
						else if (val.ToUpper() == "@C")
						{							
							replaceVal = m_CountryCodes[rnd.Next(0,m_NumCountries-1)].ToString();
						}
							// Generate random string up to the given maximum size
						else if ((val.ToUpper().StartsWith("@S[")) && (val.EndsWith("]")))
						{	
							int len = System.Convert.ToInt32(val.Substring(3,val.Length-4));																			
							int rndSize = rnd.Next(1,len);							
							char[] charArray = new char[rndSize];
							for(int d=0;d<rndSize;d++)
							{
								// A-Z from 65 - 90
								int number = rnd.Next(25) + 65;								
								charArray[d] = (char)number;
							}																					
							replaceVal = "'" + new string(charArray) + "'";							
						}
						// sequential string - A,B,..,Z,AA,BB,..,ZZ,AAA,...
						else if (val.ToUpper() == "@S")
						{							
							if (SequentialString[w] != null)
							{
								int len = SequentialString[w].Length;	
								int newLen=0;
								if (SequentialString[w].ToString().StartsWith("Z"))
								{
									// we reached the end of our letters, 
									// restart with A or AA, AAA, etc.
									character = 65;
									newLen = ++len;
								}
								else
									newLen = len;
								
								// Add as many characters as required
								for(int k=0;k<newLen;k++)
								{
									SequentialString[w].Append((char)character);
								}								
							}
							// we are filling up this string for the first time
							else
							{
								SequentialString[w] = new StringBuilder();
								SequentialString[w].Append((char)character);
							}
							++character;
							replaceVal = "'" + SequentialString[w].ToString() + "'";
						}
					}
					else
					{
						// determine if we need to enclose the value between single quotes
						string dataType = col.Attributes["DATATYPE"].Value.ToLower();
						if ((dataType == "char")
							|| (dataType == "varchar")
							|| (dataType == "text")
							|| (dataType == "nchar")
							|| (dataType == "nvarchar")
							|| (dataType == "ntext"))
						{
							val = "'" + val + "'";
						}

						replaceVal = val;
					}
					valuesString.Append(replaceVal);
					valuesString.Append(",");
				}
				if (valuesString.Length <= sValues.Length)
					throw new Exception("No replace symbols were found in " + fileName);
				// Remove the last ","
				if (valuesString[valuesString.Length-1] == ',')
					valuesString.Remove(valuesString.Length-1,1);
				sqlString.Remove(sqlString.Length-1,1);
				// Append ')'
				valuesString.Append(")");
				sqlString.Append(")");

				// We finished parsing all the columns, so generate SQL statement
				sqlString.Append(valuesString.ToString());

				PopulateTableRow(sqlString.ToString());                
			}
		}

		private void PopulateTableRow(string sqlStmt)
		{
			if ((sqlStmt == null) || ((sqlStmt != null) && (sqlStmt == "")))
				throw new Exception("Empty SQL statement.");

			SQLDataProvider sql = new SQLDataProvider();
			bool res = sql.InitializeConnection(m_Server,m_DB);
			if (res) sql.ExecuteQuery(sqlStmt);
			sql.Close();
		}
		
		public void PopulateUODBTables()
		{

		}

		public void PopulateWEBDBTables()
		{
		}

		public void PopulateXPROFTables()
		{
		}

		public void PopulateLOGData()
		{
		}

		// For testing purposes only
		/*public void PopulateRawContent(string dtStart)
		{
			SQLDataProvider dw = new SQLDataProvider();
			bool res = dw.InitializeConnection(m_Server,m_DB);
			if (res == true) Console.WriteLine("Connection initialized.");
			long PUID = 2533944968921102;
			int MachinePUID = 2000;	
			string idtWhen = GetIDTFromDate(dtStart);
			for (int i=1;i<101;i++)
			{
				string cmd = "INSERT RawContentRef " +
					"(idtWhen, biMachineID, biUserID0, biUserID1, biUserID2, " +
					"biUserID3, iTitleID, biOfferID, tiServerNum, biNonce) values " +
					"(" + idtWhen + "," + MachinePUID + "," + PUID + ",0,0,0," + i + "," + i + ",1," + i + ")";		
				dw.ExecuteQuery(cmd);
				cmd = "";
				cmd = "INSERT RawContentDownload " +
					"(idtWhen, iDstIP, iSrcIP, siSrcPort, iTitleID, " +
					"vcPackageName, biNonce, siStatus, iDuration, tiServerNum) values " +
					"(" + idtWhen + ",0,0,0," + i + ",'Test Package'," + i + ",0,10000,1)";
				dw.ExecuteQuery(cmd);
				++PUID;			
				++MachinePUID;
			}
			dw.Close();
		}*/		

		/*public void PopulateRawKilled(string dtStart, string dtEnd)
		{
			SQLDataProvider dw = new SQLDataProvider();
			bool res = dw.InitializeConnection(m_Server,m_DB);
			if (res == true) Console.WriteLine("Connection initialized.");
			long PUID = 2533944968921102;	
			string idtStart = GetIDTFromDate(dtStart);
			string idtEnd = GetIDTFromDate(dtEnd);
			for (int i=1;i<101;i++)
			{
				string cmd = "INSERT RawKilled " +
					"(idtStart, idtEnd, iTitleID, biUserID, iState, biSessionID, " +
					"tiServerNum, iXboxIP) values " +					
					"(" + idtStart + "," + idtEnd + "," + i + "," + PUID + ",0," + i + ",1,0)";
				dw.ExecuteQuery(cmd);				
				++PUID;							
			}
			dw.Close();
		}*/				

		private string IDTDate(string strDate)
		{
			SQLDataProvider dw = new SQLDataProvider();
			bool res = dw.InitializeConnection(m_Server,m_DB);
			if (res == true) Console.WriteLine("Connection initialized.");
			string cmd = "select dbo.f_DTasIDT('" + strDate.Trim() + "') As idtDate";
			SqlDataReader dr = dw.ExecuteQueryReturn(cmd);
			if (dr.HasRows == false)
				throw new Exception("Could not get IDT date. No row returned.");
			dr.Read();
			string idtDate = System.Convert.ToString(dr.GetValue(0));
			dr.Close();
			dw.Close();
			return idtDate;
		}

		public static void Main(string[] args)
		{
			try
			{																	
				if (args.Length < 2)
					Usage();
				else
				{
					string srv="",db="",date="",tablesDir="",sNumRows="";
					bool bGenerateXML = false;
                    bool bXReport3CountryCodes = false;
					ParseArgs(args,ref srv,ref db,ref date,ref tablesDir,ref bGenerateXML,ref bXReport3CountryCodes,
                        ref sNumRows);
					TestData test = new TestData(srv,db,date,tablesDir,sNumRows);
					// generate the XML files holding the schema of the DB
					// with generic symbols to be replaced by data for each field
                    if (bGenerateXML)
                    {
                        test.GenerateXMLFileForTables(null,true);
                    }					
                    else
                    {
                        test.PopulateAllTables(bXReport3CountryCodes);
                        Console.WriteLine("Done.");
                    }
				}
				/*if (args.Length == 0)
					throw new Exception("You must specify a date.");			
				DateTime dt = DateTime.Parse(args[0]);
				DateTime dtStart = dt.AddHours(10);
				DateTime dtEnd = dt.AddHours(12);
				test.PopulateRawContent(dtStart.ToString("MM/dd/yyyy HH:mm"));
				test.PopulateRawKilled(dtStart.ToString("MM/dd/yyyy HH:mm"),
					dtEnd.ToString("MM/dd/yyyy HH:mm"));*/

			}
			catch(Exception e)
			{
				Console.WriteLine(e);
			}
		}

		internal static void Usage()
		{
			Console.WriteLine();
			Console.WriteLine("DESCRIPTION:");
			Console.WriteLine("Populates tables based on the XML files in the tables subdirectory.");
			Console.WriteLine();			

			Console.WriteLine("USAGE:");			
			Console.WriteLine("Step 1. Create XML files by using the /genXML switch");
			Console.WriteLine("DataGenerator /s:<SQL_Server> /d:<DB> /genXML [/rows:<n>]");
			Console.WriteLine("\t- Ex: DataGenerator /s:localhost /d:xreport3 /genXML /rows:100");
			Console.WriteLine("Step 2. Populate tables");
			Console.WriteLine("DataGenerator /s:<SQL_Server> /d:<DB> [/date:'MM/dd/yyyy HH:mm'] [/dir:Tables_Directory_Path]  [/countryCodes]");
			Console.WriteLine("\t- Ex: DataGenerator /s:localhost /d:xreport3");
			Console.WriteLine("OR edit and move some files to another subdirectory called CustomDir and then populate specific tables.");
			Console.WriteLine("\t - Ex: DataGenerator /s:localhost /d:xreport3 /dir:CustomDir /date:'2/1/2005 10:00'");
			Console.WriteLine();						

			Console.WriteLine("SWITCHES:");
			Console.WriteLine("- /genXML is used to generate the XML files holding the schema of the tables in the DB.");
			Console.WriteLine("If /genXML is not specified, DateGenerator will populate the tables based on the XML files " +
				"found in the default tables subdirectory. The XML files need to be edited to customize the expected values " +
				"for each field.");
            Console.WriteLine("- /countryCodes is an optional switch. It is used in the xreport3 DB. p_XRSupp_GetCountries " + 
                " is called to get a list of valid country country codes to be used with the @C token.");
			Console.WriteLine("- /date: is an optional switch. If specified, the given date will be used to generate " +
				"the @DATE value.");
			Console.WriteLine("- /dir: is an optional switch. If specified, the xml files in the given directory are " +
				"going to be looked up (instead of the default tables subdirectory.)");
			Console.WriteLine("- /rows: is an optional switch. It indicates how many rows are to be added to each table. The default value is 100.");
			Console.WriteLine();			
		}

		internal static void ParseArgs(string[] args,ref string srv,ref string db,
			ref string date, ref string tablesDir,ref bool bGenerateXML,ref bool bXReport3CountryCodes,ref string sNumRows)
		{
			if (args.Length <= 0)
				throw new Exception("No arguments were supplied.");

			foreach (string arg in args)
			{
				char[] delim = new char[]{':'};
				if (arg.ToLower().StartsWith("/s:"))
				{
					string[] s = arg.Split(delim,2);
					srv = s[1];
				}				
				else if (arg.ToLower().StartsWith("/d:"))
				{
					string[] s = arg.Split(delim,2);
					db = s[1];
				}
				else if (arg.ToLower().StartsWith("/date:"))
				{
					string[] s = arg.Split(delim,2);
					date = s[1];
				}
				else if (arg.ToLower().StartsWith("/dir:"))
				{
					string[] s = arg.Split(delim,2);
					tablesDir = s[1];
				}
				else if (arg.ToLower().StartsWith("/genxml"))
				{
					string[] s = arg.Split(delim,2);
					bGenerateXML = true;
				}
                else if (arg.ToLower().StartsWith("/countrycodes"))
                {
                    string[] s = arg.Split(delim,2);
                    bXReport3CountryCodes = true;
                }
				else if (arg.ToLower().StartsWith("/rows:"))
				{
					string[] s = arg.Split(delim,2);
					sNumRows = s[1];
				}
			}
		}		

		/*---- UNUSED -----
		public void PopulateAllTables()
		{
			System.Xml.XmlDocument doc = new XmlDocument();
			doc.Load(fileName);

			XmlNodeList nodes = doc.SelectNodes("/Tables/Table");
			SQLDataProvider dw = new SQLDataProvider();
			bool res = dw.InitializeConnection(m_Server,m_DB);
			if (res == true)
			{
				foreach (XmlNode node in nodes)
				{
					string tableName;
					Hashtable cols = new Hashtable();
					XmlAttribute attrib = node.Attributes["Name"];
					tableName = attrib.Value;
					XmlNodeList columnNodes = node.SelectNodes("/Columns/Column");
					foreach (XmlNode columnNode in columnNodes)
					{
						cols.Add(columnNode.Attributes["Name"], columnNode.Attributes["DataType"]);
					}
					dw.Write(tableName, cols);
					tableName = null;
					cols = null;
				}
			}
		}
		*/
	}

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\LogReplay\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\reportingTargetTestCPP\ReportingTargetTest.cpp ===
#include "stdafx.h"

XomDefineArea(Test);
XomDefineArea(Reporting);

void WINAPI SendLongMessage()
{
	CHAR s[4000];
    for (int i=0;i<3999;i++) { s[i] = 'a'; }
    s[3999] = '\0';
	printf("sending buffer: %s\n",s);
    // Send message that is too long - expected error event
    XomLog( Test, "%s", s );
}

void WINAPI XPSERVER_TITLESTART_Log()
{
    QWORD qwXboxID = 0x933CF3CF40B4A;
	QWORD m_qwUserID = 0x91555555591D2;
    DWORD m_dwTitleID = 0xFFFF002A;
	DWORD m_dwTitleStart = GetTickCount();
	ULONG m_ipaXbox = 0x4F64FC40;	
	WORD m_ipportXbox = 0x20C;
    DWORD m_dwState = 1;

    // LineType|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey
    XomLog(
        Reporting,
        "TITLESTART|%I64X|%X|%I64X|%X|%X|%X|%X",
        qwXboxID,
        m_dwTitleID,
        m_qwUserID,
        m_dwState,
        m_ipaXbox,
        m_ipportXbox,
        m_dwTitleStart);
    
    printf("Sent log: TITLESTART|%.0f|%i|%.0f|%i|%i|%i|%i\n",
        qwXboxID,
        m_dwTitleID,
        m_qwUserID,
        m_dwState,
        m_ipaXbox,
        m_ipportXbox,
        m_dwTitleStart);

}

void WINAPI XPSERVER_TITLEND_Log()
{
    QWORD qwXboxID = 0x933CF3CF40B4A;
	QWORD m_qwUserID = 0x91555555591D2;
    DWORD m_dwTitleID = 0xFFFF002A;
	DWORD m_dwTitleStart = 100000;
	ULONG m_ipaXbox = 0x4F64FC40;	
	WORD m_ipportXbox = 0x20C;
    DWORD m_dwState = 1;
    DWORD dwDiff = 60000; // 60 ms = 1 min duration

    // LineType|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey|Duration(ms)
    XomLog(
        Reporting,
        "TITLEND|%I64X|%X|%I64X|%X|%X|%X|%X|%X",
        qwXboxID,
        m_dwTitleID,
        m_qwUserID,
        m_dwState,
        m_ipaXbox,
        m_ipportXbox,
        m_dwTitleStart,
        dwDiff);
    
    printf("Sent log: TITLEND|%.0fX|%i|%.0fX|%i|%i|%i|%i|%i\n",
        qwXboxID,
        m_dwTitleID,
        m_qwUserID,
        m_dwState,
        m_ipaXbox,
        m_ipportXbox,
        m_dwTitleStart,
        dwDiff);

}

void WINAPI SendKIAPresenceLog()
{
    QWORD qwXboxID = 0x933CF3CF40B4A;
	QWORD m_qwNonce = 0xA52891F2B3C72FB7;	
	ULONG inaSg = 0x100CC0A;;
	DWORD dwSpiSg = 0xABB52400;
	QWORD m_qwUserID = 0x91555555591D2;
    DWORD m_dwTitleID = 0x4D530064;
	DWORD m_dwTitleVersion = 0x203;
	DWORD m_dwTitleRegion = 7;
	ULONG m_ipaXbox = 0x4F64FC40;	
	WORD m_ipportXbox = 0x20C;
	DWORD dwDiff = 0x92815F;

	XomLog(
            Reporting,
            "KIA|%I64X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X|%X",
            qwXboxID,
            m_qwNonce,
            inaSg,
            dwSpiSg,
            m_qwUserID,
            m_dwTitleID,
            m_dwTitleVersion,
            m_dwTitleRegion,
            m_ipaXbox,
            m_ipportXbox,
            dwDiff);

	printf("Sent KIA log\n");
	
	//CHAR szLog[128];
	//strcpy(szLog,"KIA|933CF3CF40B4A|A52891F2B3C72FB7|100CC0A|ABB52400|91555555591D2|4D530064|203|7|4F64FC40|20C|92815F");
		
	//printf("sending presence log: %s\n",szLog);
    // Send presence message 
    //XomLog( Test, "%s", szLog );
}

void WINAPI SendALIPresenceLog()
{
	QWORD qwXboxID = 0x933CF3CF40B4A;
	QWORD m_qwNonce = 0xA52891F2B3C72FB7;	
	ULONG inaSg = 0x100CC0A;;
	DWORD dwSpiSg = 0xABB52400;
	QWORD m_qwUserID = 0x91555555591D2;
    DWORD m_dwTitleID = 0x4D530064;
	DWORD m_dwTitleVersion = 0x203;
	DWORD m_dwTitleRegion = 7;
	ULONG m_ipaXbox = 0x4F64FC40;	
	WORD m_ipportXbox = 0x20C;	

	XomLog(
		Reporting,
		"ALI|%I64X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X",
		qwXboxID,
		m_qwNonce,
		inaSg,
		dwSpiSg,
		m_qwUserID,
		m_dwTitleID,
		m_dwTitleVersion,
		m_dwTitleRegion,
		m_ipaXbox,
		m_ipportXbox);

	printf("Sent ALI log\n");
}

void WINAPI XPSERVER_SND_Log()
{
	QWORD qwSenderID = 0xFFDD111;
	QWORD qwSenderContext = 0x19;
    DWORD dwSenderTitleID = 0xFFFF002A;
	DWORD dwMessageFlags = 0x2;
	WORD wExpireMinutes = 60;
	WORD cbDetails = 10;
	BYTE bMessageType = 1;
	CHAR szBuffer[64];
	strcpy(szBuffer,"Buffer text");

	XomLog( 
		Reporting, 
		"SND|%X:%X|%I64X|%I64X|%X|%X|%X|%X|%X|%s|%X",
		0, 
		0,
		qwSenderID,
		qwSenderContext,
		dwSenderTitleID,
		dwMessageFlags,
		wExpireMinutes,
		cbDetails,
		bMessageType,
		szBuffer,
		0 );

    printf("Sent log: SND|%i:%i|%.0f|%.0f|%i|%i|%i|%i|%i|%s|%i\n",
		0, 
		0,
		qwSenderID,
		qwSenderContext,
		dwSenderTitleID,
		dwMessageFlags,
		wExpireMinutes,
		cbDetails,
		bMessageType,
		szBuffer,
		0 );
        
}

int __cdecl wmain()
{
    HRESULT hr = S_OK;

    time_t tStart;
	time_t tCurrent;
	time(&tStart);
	time(&tCurrent);

	printf("Waiting 10 seconds...");
	while (difftime(tCurrent,tStart) <= 10)	
	{
		time(&tCurrent);
	}

    
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        fprintf(stderr, "CoInitialize: (0x%08x)\n", hr);
        goto lDone;
    }

    //
    // Initialize mgmt framework
    //
    hr = g_xomcentral.Init("ReportingTargetTestCPP", NULL, "xpserver");	    
    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_TEST_CONFIG_0, "An error occurred during initialization. hr = 0x%08x", hr );
        goto lDone;
    }
    printf("Initialized XomCentral");

    XPSERVER_TITLESTART_Log();
    XPSERVER_TITLEND_Log();
    XPSERVER_SND_Log();

lDone:

    g_xomcentral.Term();
    ::CoUninitialize( );
	return 0;
}

/*__cdecl wmain()
{
    HRESULT hr = S_OK;
    HANDLE rgLoggingThreads[ 4 ];
    DWORD dwThreadId;

    hr = ::CoInitialize( NULL );
    
    /*CComPtr<IConfig> m_pConfig = NULL;
    // Create an instance of the Config class
    hr = CoCreateInstance( __uuidof(ConfigInterop), NULL, CLSCTX_ALL, __uuidof(IConfig), (void**)&m_pConfig);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_TEST_CONFIG_1, "Unrecoverable failure while initializing: Failed to CoCreateInstance ConfigInterop: hr=0x%X", hr);
        goto lDone;
    }        

    // Set the component name
    hr = m_pConfig->put_ComponentName(CComBSTR("xpserver"));*/

    /*time_t tStart;
	time_t tCurrent;
	time(&tStart);
	time(&tCurrent);

	printf("Waiting 10 seconds...");
	while (difftime(tCurrent,tStart) <= 10)	
	{
		time(&tCurrent);
	}

	printf("Init core logging and tracing");
    // Init core logging and tracing
    hr = g_xomcentral.Init("ReportingTargetTestCPP", NULL, "xpserver");
	//hr = g_xomcentral.Init("xpserver");
    
    /*if(FAILED(hr))
    {
        XomNtEvent(XEVENT_TEST_CONFIG_2, "Unrecoverable failure while initializing: Failed to init g_xomcentral: hr=0x%X", hr);
        goto lDone;
    }

	//SendLongMessage();
	/*time_t tStart;
	time_t tCurrent;
	time(&tStart);
	time(&tCurrent);

	while (1)
	{
		if (difftime(tCurrent,tStart) >= 1)	
		{
			SendKIAPresenceLog();
			SendALIPresenceLog();
			time(&tStart);
		}
		time(&tCurrent);
	}*/
	/*SendSNDPresenceLog();
    
lDone:

    g_xomcentral.Term();

    ::CoUninitialize( );

    return;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\LogReplay\LogReplay.cs ===
using System;
using System.IO;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.Reporting)]

namespace xonline.tools.reporting.test.logreplay
{
    class LogReplay
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            if( 2 != rgszArgs.Length )
            {
                Usage( );
                goto lDone;
            }

            try
            {
                Config.ComponentName = rgszArgs[ 0 ];

                XomLoggingControl.Init();

                using( StreamReader sr = new StreamReader( rgszArgs[ 1 ] ) )
                {
                    string line;

                    while( null != ( line = sr.ReadLine( ) ) )
                    {
                        Xom.Log(XomAreaName.Reporting, line );
                    }
                }
            }
            catch( Exception exc )
            {
                Console.WriteLine( exc.ToString( ) );
            }

        lDone:

            return;
        }

        static void Usage( )
        {
            Console.WriteLine( "Usage: LogReplay.exe <component> <logfile>" );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\ReportStress\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\reportingTargetTestCPP\stdafx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once


#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

// Disable warning: unreferenced formal parameter
#pragma warning( disable : 4100 )
// Disable warning: conditional expression is constant
#pragma warning( disable : 4127 )


#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <icecap.h>
#include <atlsafe.h>
#include <time.h>
//#include <atlcomcli.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;


#include "xboxverp.h"
#include "wmsstd.h"
#include "xalloc.h"
#include "xmgmt.h"
#include "wsockntp.h"
#include "xonlinep.h"
#include "servsock.h"
#include "tcpcnt.h"
#include "xeventids.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\reportingTargetTestCPP\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_reportingtargettestcpp_none_12.4.56.0_none_d5ad97a36049ed96
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingtargettestcpp
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.manifest
XP_MANIFEST_PATH=manifests\x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.cat
XP_CATALOG_PATH=manifests\x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.cat
XP_PAYLOAD_PATH=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingtargettestcpp,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\reportingTargetTestCPP\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_reportingtargettestcpp_none_12.4.56.0_none_d5ad97a36049ed96
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingtargettestcpp
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.manifest
XP_MANIFEST_PATH=manifests\x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.cat
XP_CATALOG_PATH=manifests\x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08.cat
XP_PAYLOAD_PATH=x86_reportingtargettestcpp_no-public-key_12.4.56.0_x-ww_be2fec08
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingtargettestcpp,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\xmgmtStress\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\ReportStress\ReportStress.cs ===
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.tools.reporting.test.reportstress
{
    class ReportStress
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            int iNumThreads;
            int iSleepTime;
            Thread[] rgThreads;

            if( 2 != rgszArgs.Length )
            {
                Usage( );
                return;
            }

            try
            {
                iNumThreads = int.Parse( rgszArgs[ 0 ] );
                iSleepTime = int.Parse( rgszArgs[ 1 ] );

                if( iNumThreads <= 0 )
                {
                    return;
                }

                rgThreads = new Thread[ iNumThreads ];

                for( int i = 0; i < iNumThreads; i++ )
                {
                    LogThread lt = new LogThread( );
                    lt.iThreadId = i;
                    lt.iSleepTime = iSleepTime;

                    rgThreads[ i ] = new Thread( new ThreadStart( lt.ThreadProc ) );
                    rgThreads[ i ].Start( );
                }
            }
            catch( Exception exc )
            {
                Console.WriteLine( exc.ToString( ) );
            }
        }

        static void Usage( )
        {
            Console.WriteLine( "Usage: ReportStress.exe <numthreads> <threadsleeptime>" );
        }

        private class LogThread
        {
            public int iSleepTime;
            public int iThreadId;

            private Socket sock;

            public void ThreadProc( )
            {
                ReportMessageConnect connect;
                ReportMessageData data;
                string szContent;
                int iMsg = 0;

                connect = new ReportMessageConnect( );
                connect.iServerID = Config.ServerId;
                connect.iComponentID = ( int ) Component.xbos;

                data = new ReportMessageData( );

                _Connect( );

                _Send( ( byte[] ) connect );

                while( true )
                {
                    szContent = string.Format( "CONTENTREF|9E8D68D68F420|{0}|9E8D68D68F420|53450031|5345003120050111|123123123123123", ( ( ( Int64 ) iThreadId ) << 32 ) + iMsg );
                    data.szMessage = szContent;
                    data.usSize = ( ushort ) Encoding.UTF8.GetByteCount( szContent );
                    _Send( ( byte[] ) data );
                    iMsg++;
                    Thread.Sleep( iSleepTime );
                }
            }

            private void _Connect( )
            {
                IBucketServer pBucket;
                IPEndPoint remoteEP;
            
                sock = new Socket( AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );

                pBucket = Config.GetBucketServer( Interface.cleanser, ( uint ) Config.ServerId );
                remoteEP = new IPEndPoint( Dns.Resolve( pBucket.CurrentServerName ).AddressList[ 0 ], int.Parse( pBucket.Info1 ) );

                sock.Connect( remoteEP );
            }

            private void _Disconnect( )
            {
                sock.Shutdown( SocketShutdown.Both );
                sock.Close( );
                sock = null;
            }

            private void _Send( byte[] buffer )
            {
                int sizeSent = sock.Send( buffer, SocketFlags.None );
                if ( sizeSent != buffer.Length )
                {
                    throw new Exception( "Failed to send full message: original size = " + buffer.Length + " sent size  = " + sizeSent );
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\xmgmtStress\xmgmtStressInit.cs ===
using System;
using System.Threading;
//using xonline.common.config;
using xonline.common.mgmt;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.Test)]

namespace xmgmtStress
{
	public class xmgmtStress : TestSuite
	{				
		public override InitializerInfo GetStressRequiredResources()
		{
			InitializerInfo	ii = new InitializerInfo();
			ii.UseFakeSG = false;
			XomLoggingControl.Init();
			return ii;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\STFDTransformTest\STFDTransformTest.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

namespace STFDTransformTest
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class Test
	{
		private string m_logFilesPath;
		private string m_SQLServer;
		private const string delim = "|";

		public Test()
		{
			m_logFilesPath = @"work\";
			m_SQLServer = "(local)";
		}
		
		public Test(string logFilesPath, string SQLServer)
		{
			m_logFilesPath = logFilesPath;
			m_SQLServer = SQLServer;
		}

		private bool VerifyRowCount()
		{
			return true;
		}

		private void ParseLogFiles(ArrayList rows)
		{
			try
			{
				string[] filePaths = Directory.GetFiles(m_logFilesPath, "stfd*");
				Int16 serverNum;
				FileStream fsWrite = new FileStream("ParsedLog.txt",FileMode.Create,
					FileAccess.Write,FileShare.Read);
				StreamWriter sw = new StreamWriter(fsWrite,Encoding.ASCII);
				sw.AutoFlush = true;
				foreach (string filePath in filePaths)
				{
					string fileName = GetFileNameFromPath(filePath);
					FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, 
						FileShare.Read);
					StreamReader sr = new StreamReader(fs, Encoding.ASCII);
					serverNum = GetServerNumber(fileName);
					while (sr.Peek() >= 0)
					{
						// read one line
						string line = sr.ReadLine();
						int start=0, stop=0;
						RowInfo oneRow = new RowInfo();
						// parse the line
						// Example:
						// 2004/09/12 10:00:04.897|RDF|0|55530037|1|937777777AC3C|103|96F8AF8AFAC73|786B3505933395E1|4|1|9B81381384744|6450|/50511266-4875-4660-445d-5ac5208fe205_c1
						// Get 1st field = date
						start = line.IndexOf(delim,0);
						oneRow.idtWhen = (Int32)GetIDT(line.Substring(0,start-1));
						// Get 2nd field = 3 letter action code (RDF or WRF)
						stop = line.IndexOf(delim, start+1);
						oneRow.actionCode = line.Substring(start+1,stop-start-1);
						// Get 4th field = titleID
						start = stop + 1;
						stop = line.IndexOf(delim,start);
						start = stop + 1;
						stop = line.IndexOf(delim,start);
						string sTitleID = line.Substring(start,stop-start);
						oneRow.titleID = System.Convert.ToInt32(sTitleID,16);
						// Get 6th field = UserID
						start = stop + 1;
						stop = line.IndexOf(delim,start);
						start = stop + 1;
						stop = line.IndexOf(delim,start);
						string sUserID = line.Substring(start,stop-start);
						oneRow.userID = System.Convert.ToInt64(sUserID,16);
						// Get 13th field = storage file size
						for(int i=0;i<7;i++)
						{
							start = stop + 1;
							stop = line.IndexOf(delim,start);
						}
						string sBlobSize = line.Substring(start,stop-start);
						oneRow.blobSize = System.Convert.ToInt32(sBlobSize,10);
						oneRow.serverNum = serverNum;
						rows.Add(oneRow);
						// Debugging
						sw.WriteLine("{0},{1},{2},{3},{4},{5}",oneRow.idtWhen,oneRow.actionCode,
							oneRow.titleID, oneRow.userID, oneRow.blobSize, oneRow.serverNum);
						// End debugging
					}
					fs.Close();sr.Close();
					fs = null; sr=null;
				}
				//fsWrite.Close();sw.Close();
				//fsWrite=null;sw=null;
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
			}
			finally
			{
				
			}
		}

		private bool VerifyTransformedData()
		{
			bool retval=false;

			SqlConnection conn = new SqlConnection(
				"Data Source=" + m_SQLServer + ";Initial Catalog=xreport3;" +
				"Integrated Security=true");
			SqlCommand cmd = new SqlCommand();
			cmd.CommandText = "select * from RawStorage";
			cmd.CommandType = CommandType.Text;
			cmd.Connection = conn;
			conn.Open();
			SqlDataReader reader = cmd.ExecuteReader();
			while (reader.Read())
			{
				
			}
			retval=true;
			return retval;
		}

		private Int64 GetIDT(string date)
		{
			Int64 Hms;
			DateTime dt = DateTime.Parse(date);
			dt = dt.ToLocalTime();
			DateTime beginDt = DateTime.Parse("1/1/2002");
			TimeSpan diff = dt.Subtract(beginDt);
			Hms = (Int64)diff.TotalSeconds * 10;
			Hms += ((dt.Millisecond + 50) / 100) - 2147483648;
			return Hms;
		}

		private Int16 GetServerNumber(string fileName)
		{
			// format "stfd00x-----.log"
			if ((fileName.Length < 11) || (fileName.ToLower().Substring(0,4) != "stfd"))
				throw new Exception("Invalid log file name format: " + fileName);

			// number is from 5th to 7th position
			string sNum = fileName.Substring(4,3);
			return System.Convert.ToInt16(sNum,10);
		}

		private string GetFileNameFromPath(string path)
		{
			int i=-1,last=-1;
			do
			{
				last = i;
				i = path.IndexOf("\\",i+1);
			}
			while (i >= 0);
			
			if (last >= 0)
				return path.Substring(last+1,path.Length - last - 1);
			else
				return path;
		}

		internal class RowInfo
		{
			internal Int32 idtWhen;
			internal string actionCode;
			internal Int32 titleID;
			internal Int64 userID;
			internal Int32 blobSize;
			internal Int16 serverNum; 
		};

		public static void Usage()
		{
			Console.WriteLine("USAGE:");
			Console.WriteLine("STFDTransformTest [Log_Directory]");
			Console.WriteLine("This is to test the STFD transformer. The test "
				+ "parses all stfd log files in the given "
				+ "directory and creates a text file with the parsed data. It "
				+ "basically mimics the STFD transfomer. Use Windiff to compare with "
				+ "bcp file generated by the transformer.");
		}

		public static void Main(string[] args)
		{
			try
			{
				if (args.Length < 1) Usage();
				else
				{
					//Test test = new Test(@"D:\Transformer\work\","(local)");
					Test test = new Test(args[0],"(local)");
					ArrayList rows = new ArrayList();
					test.ParseLogFiles(rows);
				}
			}
			catch(Exception e)
			{
				Console.WriteLine(e);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\livetools\reporting\xmgmtStress\xmgmtStress.cs ===
using System;
using System.Threading;
//using xonline.common.config;
using xonline.common.mgmt;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xmgmtStress
{
	// the higher the priority is, the more times it got executed
	[StressTest(Priority=1000000)]
    [StressInstantiate]
	public class StressLogMsg : TestBase
	{
		protected override void Execute()
		{
			// put your stress test logic here
			Xom.Log(XomAreaName.Test, "Log Message" );
			ResultCode = TEST_RESULTS.PASSED;

		}
	}

	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\sources.inc ===
# Define common paths used by all child projects

XNALS_VER = 1.0.0.19966

ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME =none
USE_ASMMETA=0

PRECOMPILED_OPTION=1 

!ifndef DEBUG_CRTS

XNALS_PATH = $(INETROOT)\public\ext\xnals\$(XNALS_VER)\Release
XNALS_DROP = $(INETROOT)\drop\retail\test\Ls3iStress

!else

XNALS_PATH = $(INETROOT)\public\ext\xnals\$(XNALS_VER)\Debug
XNALS_DROP = $(INETROOT)\drop\debug\test\Ls3iStress

!endif

WTT_PATH = $(INETROOT)\public\ext\WTT
XCEED_PATH=$(INETROOT)\public\ext\Xceed\3.5
LS3ISTRESS_PATH = $(INETROOT)\private\test\ls3istress

# Define common referenced DLL used by all child projects

REFERENCES = \
    $(CLR_REF_PATH)\System.metadata_dll; \
    $(CLR_REF_PATH)\System.Configuration.metadata_dll; \
    $(XNALS_PATH)\Microsoft.Xna.LiveServer.Platform.dll; \
    $(XNALS_PATH)\Microsoft.Xna.LiveServer.Games.dll; \
    $(XNALS_PATH)\App\pages\bin\Microsoft.Xna.LiveServer.WebPages.dll; \
    $(WTT_PATH)\WTTOMBase.dll; \
    $(WTT_PATH)\WTTOMJobs.dll; \
    $(WTT_PATH)\WTTOMIdentity.dll; \
    $(WTT_PATH)\WTTOMParameter.dll; \
    $(WTT_PATH)\WTTOMSQLProvider.dll; \
    $(WTT_PATH)\WTTOMResource.dll; \
    $(WTT_PATH)\WTTOMDimension.dll
    
# Define common properties shared by all child projects

UMTYPE=windows
MANAGED_CODE=1
TESTTARGET=1
TARGETTYPE=DYNLINK
TARGETPATH=obj$(BUILD_ALT_DIR)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Build.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The Build object represents a deployment build version in StressNet against which one or more
    /// Runs can be associated. It is used for grouping Runs in some reporting pages of Sporkfire.
    /// </summary>
    [Serializable]
    public class Build : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum number of characters allowed in the name of a build (SQL constraint)
        /// </summary>
        public const int MaxName = 256;

        /// <summary>
        /// Special ID value to select runs with all builds. 
        /// It is not a valid value to save on the DB, it is only used in Sporkfire's webpage.
        /// </summary>
        public const int AllBuilds = -3;

        /// <summary>
        /// Special ID value to create a new build for a run. 
        /// It is not a valid value to save on the DB, it is only used in Sporkfire's webpage.
        /// </summary>
        public const int NewBuild = -2;

        /// <summary>
        /// Special ID value to select runs with non associated build. 
        /// It is not a valid value to save on the DB, it is only used in Sporkfire's webpage.
        /// </summary>
        public const int NonAssociated = -1;

        #endregion

        #region Persisted data

        /// <summary>
        /// Name of the build. This field is persisted in the DB. 
        /// It is indexed for fast searching and it has Unique constraint.
        /// </summary>
        [PrimitiveMember(Size = MaxName, Unique = true, Index = true)]
        private string m_Name;

        /// <summary>
        /// Gets the name of the build.
        /// </summary>
        public string Name
        {
            get
            {
                return m_Name;
            }
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get
            {
                return (int)InternalId;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor - do NOT use. Call Create instead.
        /// </summary>
        public Build()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public Build(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a new build with an empty name. This will cause a write to the DB at session commit time.
        /// </summary>
        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_Name = "";
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Initializes a build with a given name. This will cause a write to the DB at session commit time.
        /// </summary>
        /// <param name="name">Name for the build</param>
        public void Initialize(string name)
        {
            BeginEdit();
            {
                base.Initialize();
                m_Name = name;
                Validate();
            }
            EndEdit();
        }

        #endregion

        #region Object methods

        /// <summary>
        /// Check that the value of the persisted fields adhere to the SQL table constraints
        /// </summary>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
                m_Name = m_Name.Substring(0, MaxName - 1);
        }

        #endregion

        #region Static methods

        /// <summary>
        /// Creates a new build with a given name. This inserts a new row into the SQL table
        /// </summary>
        /// <param name="name">Name for the build</param>
        /// <returns>The ORM object that represents the new Build row</returns>
        public static Build Create(string name)
        {
            Build build = new Build();
            build.Initialize(name);
            return build;
        }

        /// <summary>
        /// Gets a Build object given its primary key in the SQL table
        /// </summary>
        /// <param name="id">Id of the required build</param>
        /// <returns>The ORM object that represents the requested Build row</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.Platform.Orm.PersistedBase.InvalidIdException">Thrown if the requested id is not found on the SQL table</exception>
        public static Build Get(int id)
        {
            return (Build)PersistedBase.Get(typeof(Build), id);
        }

        /// <summary>
        /// Gets a Build object given its Name column value
        /// </summary>
        /// <param name="name">Name of the required build</param>
        /// <returns>The ORM object that represents the requested Build row or <c>null</c> if not found</returns>
        public static Build GetByName(string name)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Build.GetByName]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Name", name);

            return (Build)PersistedBase.Get(cmd, typeof(Build));
        }

        /// <summary>
        /// Gets all the builds contained in the Build SQL table
        /// </summary>
        /// <returns>An array that contains the ORM objects that represent all the rows in the Build SQL table. It can be empty</returns>
        public static Build[] GetAll()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Build.GetAll]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (Build[])PersistedBase.GetList(typeof(Build), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets all the builds contained in the Build SQL table that have at least one Run associated to them.
        /// This is used from the Runs page, where the Builds filter only requires valid values for the existing runs.
        /// </summary>
        /// <returns>An array that contains the ORM objects that represent the selected rows from the Build SQL table. It can be empty</returns>
        public static Build[] GetAllForRuns()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Build.GetAllForRuns]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (Build[])PersistedBase.GetList(typeof(Build), cmd, 0, -1, out cAvailable);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\FileData.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.Xna.LiveServer.Platform.Orm;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The FileData object is used to store a file in Sporkfire's DB. A file can be either read from WTT input share
    /// when the default run configuration for a job is created. It can also be read from Sporkfire's webpage when a
    /// user uploads a file to override the Job's default value.
    /// The FileData object can belong to both Runs and RunConfigs.
    /// </summary>
    [Serializable]
    public class FileData
    {
        #region Static data

        /// <summary>
        /// Maximum name that any file can take. This excludes the file's path. This is an SQL field size constraint for Name.
        /// </summary>
        public const int MaxFileName = 80;

        #endregion

        #region Persisted data

        /// <summary>
        /// Name of the file. This file is persisted into the DB. It excludes the file's path.
        /// </summary>
        [PrimitiveMember(Size = MaxFileName)]
        public string Name;

        /// <summary>
        /// Size of the data contained in the Data field. This field is persisted into the DB.
        /// </summary>
        public int Size;

        /// <summary>
        /// Data for the file. This field is persisted into the DB. Stored as a variable size byte array.
        /// </summary>
        [PrimitiveMember(Size = 0x0)]
        public byte[] Data;

        #endregion

        #region Object initialization

        /// <summary>
        /// Creates a new empty file
        /// </summary>
        public FileData()
        {
            Name = "";
            Size = 0;
            Data = null;
        }

        /// <summary>
        /// Creates a new file with a given name and data
        /// </summary>
        /// <param name="name"></param>
        /// <param name="data"></param>
        public FileData(string name, byte[] data)
        {
            Name = name;
            Size = data.Length;
            Data = data;
            Validate();
        }

        #endregion

        #region Instance methods

        /// <summary>
        /// Reads the file information from the specified path
        /// </summary>
        /// <param name="filename">Full path to the target file</param>
        public void ReadFrom(string filename)
        {
            Name = Path.GetFileName(filename);
            using (FileStream f = File.OpenRead(filename))
            {
                Size = (int)f.Length;
                Data = new byte[f.Length];
                f.Read(Data, 0, Size);
            }
        }

        /// <summary>
        /// Validates that the file's persisted fields follow its SQL constraints
        /// </summary>
        private void Validate()
        {
            if (Name.Length >= MaxFileName)
                Name.Substring(0, MaxFileName - 1);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Globals.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    #region Globals accessor

    /// <summary>
    /// This interface is used by the WTTOMBroker class to access the Globals
    /// values with a friendly indexer syntax.
    /// </summary>
    public interface IGlobalsAccessor
    {
        string this[string key] { get; }

        bool TryGet(string key, out string value);
    }

    /// <summary>
    /// Implements the IGlobalAccessor interface.
    /// </summary>
    public class GlobalsAccessor : IGlobalsAccessor
    {
        /// <summary>
        /// Default (empty) constructor
        /// </summary>
        public GlobalsAccessor() { }

        /// <summary>
        /// Gets the specified property from the Globals table in Sporkfire's DB
        /// </summary>
        /// <param name="key">Name of the property</param>
        /// <returns>String value, as stored in Sporkfire's DB</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.LS3i.OM.PropertyNotFoundException">If the specified property does not exist in Sporkfire's DB</exception>
        public string this[string key]
        {
            get
            {
                return Globals.GetProperty(key);
            }
        }

        public bool TryGet(string key, out string value)
        {
            return Globals.TryGetProperty(key, out value);
        }
    }

    #endregion

    /// <summary>
    /// The Globals object represents a property/value pair in Sporkfire's DB. These are used throughout several of Sporkfire's components
    /// to allow centralized configuration of the application. 
    /// <remarks>
    /// Both the Webpage and XtsTasks components depend on several of the values stored on this table. 
    /// The following is a list of the expected values in this table:
    /// <list type="bullet">
    /// </list>
    /// <item>OrmDefaultRunConfigOwnerAlias</item>
    /// <item>WebpageScheduleEnvironments</item>
    /// <item>WebpageFindRunConfigsPageSize</item>
    /// <item>WebpageRecentRunsCount</item>
    /// <item>WebpageRunCancelReasonFormat</item>
    /// <item>WebpageDisplayPrivParamaters</item>
    /// <item>IISServerName</item>
    /// <item>SmtpHostName</item>
    /// <item>MailSenderAddress</item>
    /// <item>MailStatusSendToAddress</item>
    /// <item>WttServerName</item>
    /// <item>WttIdentityDS</item>
    /// <item>WttJobsDefinitionDS</item>
    /// <item>WttJobsRuntimeDS</item>
    /// <item>WttRoleDimension</item>
    /// <item>WttRoleDimension_Value_Server</item>
    /// <item>WttRoleDimension_Value_Client</item>
    /// <item>WttRunPoolRootPoolPath</item>
    /// <item>WttRunPrefix</item>
    /// <item>WttRecoveryPoolPath</item>
    /// <item>WttCommandLine_FilePath</item>
    /// <item>WttFileShareRootPath</item>
    /// <item>WttCommandLine_Arguments</item>
    /// <item>WttCommandLine_Parameter_RunId</item>
    /// <item>WttCommandLine_Parameter_ResultSummary</item>
    /// <item>WttCommandLine_Parameter_JobId</item>
    /// <item>WttCommandLine_Parameter_RunPoolPath</item>
    /// <item>WttCommandLine_Parameter_JobParameters</item>
    /// <item>WttNumberOfClientsParameter</item>
    /// <item>WttEnvironmentParameter</item>
    /// <item>WttSingleInstanceTaskExecutorMachineParameter</item>
    /// <item>WttMonitorMachineParameter</item>
    /// <item>WttCancelReason</item>
    /// <item>EnvironmentPoolMappingXml</item>
    /// <item>SqlServerName</item>
    /// <item>SqlReportingDb</item>
    /// <item>SqlSporkfireDb</item>
    /// <item>TSTLSWTTCTL001.TEST.LIVE_CORPNETIP</item>
    /// </remarks>
    /// </summary>
    [Serializable]
    public class Globals : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum length for the Property field. This is an SQL field size constraint.
        /// </summary>
        public const int MaxProperty = 64;

        /// <summary>
        /// Maximum length for the Value field. This is an SQL field size constraint.
        /// </summary>
        public const int MaxValue = 1024;

        #endregion

        #region Persisted data

        /// <summary>
        /// Name of the property. Persisted in the DB. Indexed for fast searching. Must be unique. Can't be NULL.
        /// </summary>
        [PrimitiveMember(Size=MaxProperty,Unique=true,Index=true,AllowNulls=false)]
        private string m_Property;

        /// <summary>
        /// Gets or sets the name of the property in the DB. 
        /// Setting this value will cause a write to the DB at session commit time.
        /// </summary>
        public string Property
        {
            get
            {
                return m_Property;
            }
            set
            {
                if (value != m_Property)
                {
                    BeginEdit();
                    m_Property = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Value of the property. Persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size=MaxValue)]
        private string m_Value;

        /// <summary>
        /// Gets or sets the string value of this property in the DB.
        /// Setting this value will cause a write to the DB at session commit time.
        /// </summary>
        public string Value
        {
            get
            {
                return m_Value;
            }
            set
            {
                if (value != m_Value)
                {
                    BeginEdit();
                    m_Value = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Indicates whether this property is tweakable from Sporkfire's webpage or not. Persisted in the DB.
        /// </summary>
        private bool m_IsTweakable;

        /// <summary>
        /// Gets a boolean indicating whether this property is tweakable from Sporkfire's webpage or not.
        /// </summary>
        public bool IsTweakable
        {
            get
            {
                return m_IsTweakable;
            }
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get
            {
                return (int)InternalId;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor - do NOT use. Call Create instead.
        /// </summary>
        public Globals()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public Globals(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a Globals object with the provided values. This will cause a write to the DB at session commit time.
        /// </summary>
        /// <param name="property"></param>
        /// <param name="value"></param>
        /// <param name="isTweakable"></param>
        public void Initialize(string property, string value, bool isTweakable)
        {
            BeginEdit();
            {
                base.Initialize();
                m_Property = property;
                m_Value = value;
                m_IsTweakable = isTweakable;
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        /// <summary>
        /// Creates a new entry in the Globals table with the specified values.
        /// </summary>
        /// <param name="property">Name of the property</param>
        /// <param name="value">Value of the property</param>
        /// <param name="isTweakable">Determines whether the value is tweakable from the webpage</param>
        /// <returns></returns>
        private static Globals Create(string property, string value, bool isTweakable)
        {
            Globals g = new Globals();
            g.Initialize(property, value, isTweakable);
            return g;
        }

        /// <summary>
        /// Gets a Global object from the DB by property name.
        /// </summary>
        /// <param name="property">Name of the property for the Global row to retrieve</param>
        /// <returns>The Global ORM object that represents the selected row in the DB</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.LS3i.OM.PropertyNotFoundException">If the specified property name is not found on the DB</exception>
        private static Globals Get(string property)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Globals.GetProperty]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Property", property);

            Globals g = (Globals)PersistedBase.Get(cmd, typeof(Globals));

            if (g == null)
                throw new PropertyNotFoundException(property);

            return g;
        }

        /// <summary>
        /// Sets the value of a Globals' value field in the DB by property name. 
        /// This will cause a write to the DB at session commit time.
        /// </summary>
        /// <param name="property">Name of the property to modify</param>
        /// <param name="value">Value to assign to the property</param>
        /// <exception cref="Microsoft.Xna.LiveServer.LS3i.OM.PropertyNotFoundException">If the specified property name is not found on the DB</exception>
        public static void SetProperty(string property, string value)
        {
            Globals.Get(property).Value = value;
        }

        /// <summary>
        /// Gets the string value of a property from the Globals table in the DB.
        /// </summary>
        /// <param name="property">The name of the requested property</param>
        /// <returns>The string value of the property</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.LS3i.OM.PropertyNotFoundException">If the specified property name is not found on the DB</exception>
        public static string GetProperty(string property)
        {
            return Globals.Get(property).Value;
        }

        /// <summary>
        /// Gets the string value of a property from the Globals table in the DB.
        /// This method does not throw an exception if the property is not found on the table.
        /// </summary>
        /// <param name="property">The name of the requested property</param>
        /// <param name="value">The string value of the property</param>
        /// <returns><c>true</c> if the specified property name was found, <c>false</c> otherwise</returns>
        public static bool TryGetProperty(string property, out string value)
        {
            try
            {
                value = GetProperty(property);
                return true;
            }
            catch (PropertyNotFoundException)
            {
                value = null;
                return false;
            }
        }

        /// <summary>
        /// Returns all rows in the Globals table that have its IsTweakable value set to <c>true</c>
        /// </summary>
        /// <returns>Array of Globals ORM objects that represent the selected rows from the table. It can be empty.</returns>
        public static Globals[] GetTweakables()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Globals.GetTweakables]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (Globals[])PersistedBase.GetList(typeof(Globals), cmd, 0, -1, out cAvailable);
        }

        #endregion
    }

    #region Exceptions

    /// <summary>
    /// This exception is thrown by several methods in the Globals class when a property
    /// being searched by name is not found in Sporkfire's DB.
    /// </summary>
    [Serializable]
    public class PropertyNotFoundException : Exception
    {
        private string m_PropertyName;

        /// <summary>
        /// Name of the property that could not be found on the DB
        /// </summary>
        public string PropertyName
        {
            get 
            { 
                return m_PropertyName; 
            }
        }

        /// <summary>
        /// Creates a new PropertyNotFoundException specifying the property name that could not be found.
        /// </summary>
        /// <param name="property">Name of the property that could not be found</param>
        public PropertyNotFoundException(string property)
            : base(String.Format("The property {0} was not found in the Globals table", property))
        {
            m_PropertyName = property;
        }

        /// <summary>
        /// Creates a new PropertyNotFoundException specifying the property name that could not be found.
        /// It allows the caller to specify an internal exception.
        /// </summary>
        /// <param name="property">Name of the property that could not be found</param>
        /// <param name="inner">Internal exception. Can be <c>null</c></param>
        public PropertyNotFoundException(string property, Exception inner)
            : base(String.Format("The property {0} was not found in the Globals table", property), inner)
        {
            m_PropertyName = property;
        }

        /// <summary>
        /// Creates a new PropertyNotFoundException specifying the property name that could not be found.
        /// It allows the caller to specify an alternative message to show to the user.
        /// </summary>
        /// <param name="property">Name of the property that could not be found</param>
        /// <param name="message">Message for this exception</param>
        public PropertyNotFoundException(string property, string message)
            : base(message)
        {
            m_PropertyName = property;
        }

        /// <summary>
        /// Creates a new PropertyNotFoundException specifying the property name that could not be found.
        /// It allows the caller to specify an alternative message to show to the user.
        /// It allows the caller to specify an internal exception.
        /// </summary>
        /// <param name="property">Name of the property that could not be found</param>
        /// <param name="message">Message for this exception</param>
        /// <param name="inner">Internal exception. Can be <c>null</c></param>
        public PropertyNotFoundException(string property, string message, Exception inner)
            : base(message, inner)
        {
            m_PropertyName = property;
        }

        protected PropertyNotFoundException(
          SerializationInfo info,
          StreamingContext context)
            : base(info, context) { }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\JobParameter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.DistributedAutomation;
using Microsoft.Xna.LiveServer.Platform.Orm;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The JobParameter object represents a parameter for a Job, mapped from WTT when the WttOMRefreshTask is run.
    /// </summary>
    [Serializable]
    public class JobParameter
    {
        #region Static data

        /// <summary>
        /// Maximum length of the Name field. This is an SQL field constraint.
        /// </summary>
        public const int MaxName = 64;

        /// <summary>
        /// Maximum length of the Description field. This is an SQL field constraint.
        /// </summary>
        public const int MaxDescription = 1024;

        /// <summary>
        /// Maximum length of the Value field. This is an SQL field constraint.
        /// </summary>
        public const int MaxValue = 128;

        /// <summary>
        /// Maximum length of the WTT Type prefix.
        /// </summary>
        public const int TypePrefixLength = 5;

        /// <summary>
        /// WTT Type prefix for boolean parameters
        /// </summary>
        public const string TypeBooleanPrefix = "BOOL_";

        /// <summary>
        /// WTT Type prefix for string parameters
        /// </summary>
        public const string TypeStringPrefix = "PROP_";

        /// <summary>
        /// WTT Type prefix for file parameters
        /// </summary>
        public const string TypeFilePrefix = "FILE_";

        /// <summary>
        /// WTT Type prefix for private parameters. These do not show on Sporkfire's webpages
        /// </summary>
        public const string TypeHiddenPrefix = "PRIV_";

        #endregion

        #region Persisted data

        /// <summary>
        /// Enumeration of all the supported types in Sporkfire
        /// </summary>
        public enum ParameterType
        {
            Boolean,
            String,
            File,
            /// <summary>
            /// Hiddent parameters do not show on Sporkfire's webpages
            /// </summary>
            Hidden,
        }

        /// <summary>
        /// Id of the related job in the WTT database. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Index=true)]
        private int m_WttId;

        /// <summary>
        /// Gets the Id of the job in WTT that maps to this Sporkfire's job.
        /// </summary>
        public int WttId
        {
            get
            {
                return m_WttId;
            }
        }

        /// <summary>
        /// Name of the job. This field is persisted in the DB. It is indexed for fast searching.
        /// </summary>
        [PrimitiveMember(Size = MaxName, Index=true)]
        private string m_Name;

        /// <summary>
        /// Gets the name of the job.
        /// </summary>
        public string Name
        {
            get
            {
                return m_Name;
            }
        }

        /// <summary>
        /// Description of the job. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxDescription)]
        private string m_Description;

        /// <summary>
        /// Gets the description of the job.
        /// </summary>
        public string Description
        {
            get
            {
                return m_Description;
            }
        }

        /// <summary>
        /// Gets the name of the parameter, as it would appear in the original WTT job.
        /// </summary>
        public string WttName
        {
            get
            {
                switch (Type)
                {
                    case ParameterType.Boolean:
                        return TypeBooleanPrefix + Name;

                    case ParameterType.String:
                        return TypeStringPrefix + Name;

                    case ParameterType.File:
                        return TypeFilePrefix + Name;

                    case ParameterType.Hidden:
                        return TypeHiddenPrefix + Name;

                    default:
                        throw new Exception(String.Format("Unexpected ParameterType: {0}", Type));
                }
            }
        }

        /// <summary>
        /// Default value for this parameter. This is always a string representation. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxValue)]
        private string m_DefaultValue;

        /// <summary>
        /// Gets the default value for this parameter, as a string value.
        /// </summary>
        public string DefaultValue
        {
            get
            {
                return m_DefaultValue;
            }
        }

        /// <summary>
        /// Gets the default value for this parameter, as a boolean value.
        /// </summary>
        public bool DefaultValueAsBool
        {
            get
            {
                if (m_DefaultValue == null)
                    return false;

                return (m_DefaultValue == "1" || m_DefaultValue.ToLower() == "true");
            }
        }

        /// <summary>
        /// Gets the default value for this parameter, as a FileData object.
        /// </summary>
        public FileData DefaultValueAsFileData
        {
            get
            {
                FileData f = new FileData();

                if (m_DefaultValue != null && m_DefaultValue.Length > 0)
                {
                    f.ReadFrom(m_DefaultValue);
                }

                return f;
            }
        }

        /// <summary>
        /// Type of the parameter. This field is persisted in the DB. 
        /// </summary>
        private ParameterType m_Type;

        /// <summary>
        /// Gets the type of the parameter. This type is determined by the prefix of the WTT parameter name.
        /// </summary>
        public ParameterType Type
        {
            get
            {
                return m_Type;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default constructor, sets all persisted fields to its default values.
        /// </summary>
        public JobParameter()
        {
            m_WttId = -1;
            m_Name = "";
            m_Description = "";
            m_DefaultValue = "";
            m_Type = ParameterType.Boolean;
        }

        /// <summary>
        /// Updates the values of this parameter from the WTT parameter object that it maps. If the specified WTT parameter
        /// is not of a type supported by the Sporkfire system, this method will return <c>false</c> which indicates that it
        /// should not be stored in the Job's parameter dictionary.
        /// </summary>
        /// <param name="wttParam">The WTT parameter that this JobParameter maps to.</param>
        /// <returns><c>true</c> if this parameter is supported by Sporkfire, <c>false</c> if it is not.</returns>
        public bool UpdateFrom(Parameter wttParam)
        {
            // All parameter types are identified by a 5 character prefix of the form XXXX_<ParameterName>
            if (!wttParam.IsScheduleDisplay || wttParam.Name.Length <= TypePrefixLength)
                return false;

            switch (wttParam.Name.Substring(0, TypePrefixLength))
            {
                case TypeBooleanPrefix:
                    m_Type = ParameterType.Boolean;
                    break;

                case TypeStringPrefix:
                    m_Type = ParameterType.String;
                    break;

                case TypeFilePrefix:
                    m_Type = ParameterType.File;
                    break;

                case TypeHiddenPrefix:
                    m_Type = ParameterType.Hidden;
                    break;

                default:
                    return false;
            }

            m_Name = wttParam.Name.Substring(TypePrefixLength);
            m_Description = (wttParam.Prompt != "<NULL>") ? wttParam.Prompt : "";
            m_WttId = wttParam.Id;
            m_DefaultValue = (wttParam.ParameterVal != "<NULL>") ? wttParam.ParameterVal : "";

            Validate();

            return true;
        }

        /// <summary>
        /// Validates that the persisted fields of this object follow the specified SQL constraints.
        /// </summary>
        /// <exception cref="Microsoft.Xna.LiveServer.LS3i.OM.JobParameterValidationException">Thrown when the length of the name on the WTT job exceeds the specified SQL constraint for the Job's name field</exception>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
            {
                // Clipping the parameter name is not really an option
                throw new JobParameterValidationException(m_Name, String.Format("The parameter name exceeds the maximum length of {0} characters", MaxName));
            }

            if (m_Description.Length >= MaxDescription)
            {
                m_Description = m_Description.Substring(0, MaxDescription - 1);
            }
        }
        #endregion
    }
    #region Exceptions

    /// <summary>
    /// This exception is thrown by the JobParameter Validate() method when one of the SQL constraints on its
    /// persisted fields can't be satisfied.
    /// </summary>
    [Serializable]
    public class JobParameterValidationException : Exception
    {
        private string m_ParameterName;

        /// <summary>
        /// Gets the name of the parameter which didn't met the SQL constraint
        /// </summary>
        public string ParameterName
        {
            get
            {
                return m_ParameterName;
            }
        }

        /// <summary>
        /// Creates a new JobParameterValidationException specifying the name of the parameter that caused the validation fault
        /// </summary>
        /// <param name="parameter">Name of the parameter that failed validation</param>
        public JobParameterValidationException(string parameter)
            : base(string.Format("The JobParameter {0} failed validation: {1}", parameter))
        {
            m_ParameterName = parameter;
        }

        /// <summary>
        /// Creates a new JobParameterValidationException specifying the name of the parameter that caused the validation fault.
        /// It also allows the caller to specify an internal exception.
        /// </summary>
        /// <param name="parameter">Name of the parameter that failed validation</param>
        /// <param name="inner">Internal exception. Can be <c>null</c>.</param>
        public JobParameterValidationException(string parameter, Exception inner)
            : base(string.Format("The JobParameter {0} failed validation: {1}", parameter), inner)
        {
            m_ParameterName = parameter;
        }

        /// <summary>
        /// Creates a new JobParameterValidationException specifying the name of the parameter that caused the validation fault.
        /// It also allows the caller to specify an alternative message to display to the user.
        /// </summary>
        /// <param name="parameter">Name of the parameter that failed validation</param>
        /// <param name="message">Message for this exception</param>
        public JobParameterValidationException(string parameter, string message)
            : base(string.Format("The JobParameter {0} failed validation: {1}", parameter, message))
        {
            m_ParameterName = parameter;
        }

        /// <summary>
        /// Creates a new JobParameterValidationException specifying the name of the parameter that caused the validation fault.
        /// It also allows the caller to specify an alternative message to display to the user.
        /// It also allows the caller to specify an internal exception.
        /// </summary>
        /// <param name="parameter">Name of the parameter that failed validation</param>
        /// <param name="message">Message for this exception</param>
        /// <param name="inner">Internal exception. Can be <c>null</c>.</param>
        public JobParameterValidationException(string parameter, string message, Exception inner)
            : base(string.Format("The JobParameter {0} failed validation: {1}", parameter, message), inner)
        {
            m_ParameterName = parameter;
        }

        protected JobParameterValidationException(
          SerializationInfo info,
          StreamingContext context)
            : base(info, context) { }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Machine.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Asset;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The Machine object represents a WTT machine resource in the StressNet environment.
    /// </summary>
    [Serializable]
    public class Machine : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum length for the Name field. This is an SQL constraint.
        /// </summary>
        public const int MaxName = 256;

        /// <summary>
        /// Maximum length for the Status field. This is an SQL constraint.
        /// </summary>
        public const int MaxStatus = 16;

        #endregion

        #region Persisted data

        /// <summary>
        /// Id of the machine as it appears in WTT resource DB. This field is persisted in the DB.
        /// </summary>
        private int m_WttId;

        /// <summary>
        /// Gets the Id for this machine in WTT's resource DB
        /// </summary>
        public int WttId
        {
            get
            {
                return m_WttId;
            }
        }

        /// <summary>
        /// Id of the Run that is currently using this machine as one of its resources. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Index=true)]
        private int m_RunId;

        /// <summary>
        /// Gets or sets the Id of the Run that is currently using this machine as one of its resources.
        /// Setting this property will cause a write to the DB when the current session is committed.
        /// </summary>
        public int RunId
        {
            get { return m_RunId; }
            set
            {
                if (m_RunId != value)
                {
                    BeginEdit();
                    m_RunId = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Name of the machine. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxName)]
        private string m_Name;

        /// <summary>
        /// Gets the name of the machine.
        /// </summary>
        public string Name
        {
            get { return m_Name; }
        }

        /// <summary>
        /// Name of the machine Owner. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxName)]
        private string m_OwnerName;

        /// <summary>
        /// Gets the name of the machine owner.
        /// </summary>
        public string OwnerName
        {
            get { return m_OwnerName; }
        }
        

        /// <summary>
        /// Status of the machine. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxStatus)]
        private string m_Status;

        /// <summary>
        /// Gets the status of the machine.
        /// </summary>
        public string Status
        {
            get { return m_Status; }
        }

        /// <summary>
        /// Monitor data for this machine. This field is persisted in the DB. 
        /// This field's value is usually set by a runtime tool executing in the machine represented by this object.
        /// The data contained in this field should be an Xml document.
        /// $$$avgarcia: Describe the DTD of the XML document.
        /// </summary>
        [PrimitiveMember(Size = 0)]
        private string m_MonitorData;

        /// <summary>
        /// Gets the monitor data for this machine.
        /// This value will be an XML that describes the state of the machine during a run.
        /// </summary>
        public string MonitorData
        {
            get { return m_MonitorData; }
        }

        /// <summary>
        /// Last time that the monitor data has been updated. This field is persisted in the DB.
        /// This field's value is usually set by the same runtime tool that updates MonitorData.
        /// </summary>
        private DateTime m_LastPost;

        /// <summary>
        /// Gets the last time that the value in <c>MonitorData</c> was updated in the DB.
        /// </summary>
        public DateTime LastPost
        {
            get { return m_LastPost; }
        }

        /// <summary>
        /// Name of the pool that contains this machine. This field is persisted in the DB.
        /// </summary>
        private string m_Pool;

        /// <summary>
        /// Gets the name of the WTT pool where this machine is currently located.
        /// </summary>
        public string Pool
        {
            get { return m_Pool; }
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get { return (int)InternalId; }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor. Do NOT use - call Create() instead.
        /// </summary>
        public Machine()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public Machine(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a machine object and populates its fields with the given WTT <c>Resource</c> object data and resource pool path.
        /// </summary>
        /// <param name="resource">The related resource on the WTT database. This <c>Machine</c>'s fields will be populated based on its data.</param>
        /// <param name="resourcePoolPath">The pool on the WTT database where this machine is currently located.</param>
        public void Initialize(Resource resource, string resourcePoolPath)
        {
            BeginEdit();
            {
                base.Initialize();
                m_WttId = resource.Id;
                m_Name = resource.Name;
                m_Status = resource.ResourceStatusId.ToString();
                m_Pool = resourcePoolPath;
                m_OwnerName = resource.CurrentOwnerAlias;
                m_LastPost = DateTime.MinValue;
                m_MonitorData = "";
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Updates the information of this <c>Machine</c> given the values of a WTT <c>Resource</c>.
        /// </summary>
        /// <param name="resource">The related resource on the WTT database which will be used to populate this object's fields.</param>
        /// <param name="resourcePoolPath">The pool on the WTT database where this machine is currently located.</param>
        public void UpdateFrom(Resource resource, string resourcePoolPath)
        {
            BeginEdit();
            {
                m_WttId = resource.Id;
                m_Name = resource.Name;
                m_Status = resource.ResourceStatusId.ToString();
                m_OwnerName = resource.CurrentOwnerAlias;
                m_Pool = resourcePoolPath;
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Change the owner name of a machine.
        /// </summary>
        /// <param name="ownerAlias">Alias of an owner.</param>
        public void ChangeOwner(string ownerAlias)
        {
            BeginEdit();
            {
                m_OwnerName = ownerAlias;
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Validates the persisted fields of this object against its SQL constraints
        /// </summary>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
                m_Name = m_Name.Substring(0, MaxName - 1);

            if (m_Status.Length >= MaxStatus)
                m_Status = m_Status.Substring(0, MaxStatus - 1);
        }

        #endregion

        #region Static methods

        /// <summary>
        /// Creates a new Machine object that will represent the provided WTT <c>Resource</c>
        /// The machine is assigned an empty pool path.
        /// </summary>
        /// <param name="resource">The WTT resource that this <c>Machine</c> maps to.</param>
        /// <returns>The ORM object for the newly insterted row in the Machine's table</returns>
        public static Machine Create(Resource resource)
        {
            Machine m = new Machine();
            m.Initialize(resource, "");
            return m;
        }

        /// <summary>
        /// Creates a new Machine object that will represent the provided WTT <c>Resource</c>
        /// The machine is assigned the specified pool name
        /// </summary>
        /// <param name="resource">The WTT resource that this <c>Machine</c> maps to.</param>
        /// <param name="resourcePoolName">The pool on the WTT database where this machine is currently located.</param>
        /// <returns>The ORM object for the newly insterted row in the Machine's table</returns>
        public static Machine Create(Resource resource, string resourcePoolName)
        {
            Machine m = new Machine();
            m.Initialize(resource, resourcePoolName);
            return m;
        }

        /// <summary>
        /// Gets a <c>Machine</c> from the Machine's table given its primary key (Id)
        /// </summary>
        /// <param name="id">Id of the row in the Machine's table</param>
        /// <returns>The ORM object for the selected row from the Machine's table</returns>
        public static Machine Get(int id)
        {
            return PersistedBase.Get(typeof(Machine), id) as Machine;
        }

        /// <summary>
        /// Inserts or updates all <c>Machine</c> information for the given list of WTT <c>Resource</c>s.
        /// Sets the specified RunId to all related machines.
        /// </summary>
        /// <param name="resources">List of WTT resources that should get assigned the specified RunId</param>
        /// <param name="runId">The value to assign to the RunId on the selected <c>Machine</c> objects</param>
        public static void InsertOrUpdateRunId(List<Resource> resources, int runId)
        {
            Dictionary<int, Resource> dirtyResources = new Dictionary<int, Resource>();
            foreach (Resource resource in resources)
            {
                dirtyResources.Add(resource.Id, resource);
            }

            int[] wttIds = new int[resources.Count];
            for (int i = 0; i < resources.Count; i++)
            {
                wttIds[i] = resources[i].Id;
            }

            Machine[] machines = GetWithWttIds(wttIds);
            foreach (Machine machine in machines)
            {
                machine.RunId = runId;
                dirtyResources.Remove(machine.WttId);
            }

            foreach (Resource resource in dirtyResources.Values)
            {
                Machine m = Create(resource);
                m.RunId = runId;
            }
        }

        /// <summary>
        /// Gets all the rows from the Machine's table
        /// </summary>
        /// <returns>An array of objects that represent all the rows in the Machine's table. It can be empty.</returns>
        public static Machine[] GetAll()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Machine.GetAll]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (Machine[])GetList(typeof(Machine), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets all the rows from the Machine's table that have one of the specified WttId values
        /// </summary>
        /// <param name="wttIds">An array with all the WttId values that should be matched against</param>
        /// <returns>An array of objects that represent all the selected rows from the Machine's table. It can be empty.</returns>
        public static Machine[] GetWithWttIds(int[] wttIds)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Machine.GetWithWttIds]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@IdList", Data.TransformIdList<int>(wttIds));

            int cAvailable;
            return (Machine[])GetList(typeof(Machine), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets all the rows from the Machine's table that have the specified RunId value
        /// </summary>
        /// <param name="runId">The RunId that the returned values should match against</param>
        /// <returns>An array of objects that represent all the selected rows from the Machine's table. It can be empty.</returns>
        public static Machine[] GetByRunId(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Machine.GetByRunId]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                int cAvailable;
                cmd.Connection.Open();
                return PersistedBase.GetList(typeof(Machine), cmd, 0, -1, out cAvailable) as Machine[];
            }
        }

        /// <summary>
        /// Deletes all the rows from the Machine's table whose WttId value is not within the specified values.
        /// This method is used to delete all the <c>Machine</c> entries that have broken links against WTT <c>Resource</c> entries.
        /// </summary>
        /// <param name="wttIds">All the WttIds that exist in the WTT Resource table</param>
        public static void DeleteBrokenWttLinks(int[] wttIds)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Machine.DeleteBrokenWttLinks]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@IdList", Data.TransformIdList<int>(wttIds));

            int nDeleted = 0;

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                nDeleted = (int)cmd.ExecuteScalar();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Job.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

[assembly: InternalsVisibleTo("Microsoft.Xna.LiveServer.LS3i.WebPages")]

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The Job object represents a job mapped from the WTT controller DB and stored into Sporkfire's DB. 
    /// When scheduling a Job, Run and RunConfig objects are used to specify the parameter values passed into WTT.
    /// Job objects in Sporfire's DB are kept up to date by the WttOMRefreshTask task.
    /// </summary>
    [Serializable]
    public class Job : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum length of the Name field. This is an SQL field constraint.
        /// </summary>
        public const int MaxName = 256;

        /// <summary>
        /// Maximum length of the Description field. This is an SQL field constraint.
        /// </summary>
        public const int MaxDescription = 1024;

        /// <summary>
        /// Maximum length of the Owner field. This is an SQL field constraint.
        /// </summary>
        public const int MaxOwner = 64;

        /// <summary>
        /// Maximum length of the ParameterName field. This is an SQL field constraint.
        /// </summary>
        public const int MaxParameterName = 256;

        /// <summary>
        /// Maximum length of the ParameterValue field. This is an SQL field constraint.
        /// </summary>
        public const int MaxParameterValue = 1024;

        #endregion

        #region Persisted data

        /// <summary>
        /// Id of the job in the WTT database. This field is persisted in the DB.
        /// </summary>
        private int m_WttId;

        /// <summary>
        /// Gets the Id of the job in the WTT database.
        /// </summary>
        public int WttId
        {
            get
            {
                return m_WttId;
            }
        }

        /// <summary>
        /// Name of the job. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size=MaxName)]
        private string m_Name;

        /// <summary>
        /// Gets the name of the job
        /// </summary>
        public string Name
        {
            get
            {
                return m_Name;
            }
        }

        /// <summary>
        /// Description of the job. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxDescription)]
        private string m_Description;

        /// <summary>
        /// Gets a description for the job.
        /// </summary>
        public string Description
        {
            get
            {
                return m_Description;
            }
        }

        /// <summary>
        /// Alias of the owner of the WTT job. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxOwner)]
        private string m_OwnerAlias;

        /// <summary>
        /// Gets the alias of the owner of the WTT job.
        /// </summary>
        public string OwnerAlias
        {
            get
            {
                return m_OwnerAlias;
            }
        }

        /// <summary>
        /// Dictionary of parameters for this job. The key on the dictionary is the name of the parameters.
        /// Elements on the dictionary are sorted by parameter name. This field is persisted in the DB.
        /// </summary>
        [DictionaryMember(KeyType=typeof(string), KeySize=MaxParameterName, ElementType=typeof(JobParameter))]
        private FastDictionarySorted<string, JobParameter> m_Parameters;

        /// <summary>
        /// Gets a collection of JobParameter objects for this Job.
        /// </summary>
        public ICollection<JobParameter> Parameters
        {
            get
            {
                return m_Parameters.Values;
            }
        }

        /// <summary>
        /// Gets a JobParameter by index. 
        /// This is the index in which the parameter appears in the <c>Parameters</c> collection.
        /// </summary>
        /// <param name="index">Index of the requested parameter</param>
        /// <returns>The requested JobParameter</returns>
        /// <exception cref="System.IndexOutOfRangeException">Thrown when the requested index goes beyond the number of parameters for this job</exception>
        public JobParameter GetParameter(int index)
        {
            return m_Parameters.GetByIndex(index);
        }

        /// <summary>
        /// Gets a JobParameter by name.
        /// </summary>
        /// <param name="name">The name of the requested parameter</param>
        /// <returns>The requested JobParameter</returns>
        public JobParameter GetParameter(string name)
        {
            return m_Parameters[name];
        }

        /// <summary>
        /// Gets a boolean indicating if the job contains a WTT parameter with the specified name
        /// </summary>
        /// <param name="name">Name of the WTT parameter</param>
        /// <returns><c>true</c> if the job has the specified WTT parameter, <c>false</c> otherwise</returns>
        public bool HasWttParameter(string name)
        {
            foreach(JobParameter parameter in m_Parameters.Values)
            {
                if (parameter.WttName == name)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get
            {
                return (int)InternalId;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor - do NOT use. Call Create instead.
        /// </summary>
        public Job()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public Job(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a new job with all default values. This will cause a write to the DB at session commit time.
        /// </summary>
        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_WttId = -1;
                m_Name = "";
                m_Description = "";
                m_OwnerAlias = "";
                m_Parameters = new FastDictionarySorted<string, JobParameter>();
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Updates all the values for this Job based on the specified WTT job object.
        /// This will cause a write to the DB at session commit time.
        /// </summary>
        /// <param name="wttJob">The WTT job to read for properties and parameters</param>
        public void UpdateFrom(Microsoft.DistributedAutomation.Jobs.Job wttJob)
        {
            BeginEdit();
            {
                m_WttId = wttJob.Id;
                m_Name = wttJob.Name;
                m_Description = wttJob.Description;
                m_OwnerAlias = wttJob.OwnerAlias;
                m_Parameters.Clear();
                foreach (Parameter wttParam in wttJob.CommonContext.ParameterCollection)
                {
                    JobParameter param = new JobParameter();
                    if(param.UpdateFrom(wttParam))
                        m_Parameters.Add(param.Name, param);
                }
                RunConfig.DeleteDefaultForJob(Id);
                RunConfig.CreateDefault(this);
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Validates all the fields of this job against its SQL constriants
        /// </summary>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
                m_Name = m_Name.Substring(0, MaxName - 1);

            if (m_Description.Length >= MaxDescription)
                m_Description = m_Description.Substring(0, MaxDescription - 1);

            if (m_OwnerAlias.Length >= MaxOwner)
                m_OwnerAlias = m_OwnerAlias.Substring(0, MaxOwner - 1);
        }

        #endregion

        #region Static methods

        /// <summary>
        /// Creates a new Job and insterts it into the DB. 
        /// This will cause a write to the DB at session commit time.
        /// </summary>
        /// <returns>The Job object that maps against the newly created row on the DB</returns>
        public static Job Create()
        {
            Job j = new Job();
            j.Initialize();
            return j;
        }

        /// <summary>
        /// Creates a new Job, initialized from the specified WTT job, and inserts it into the DB.
        /// This will cause a write to the DB at session commit time.
        /// </summary>
        /// <param name="wttJob">WTT job to use for reading properties and parameters to populate the ORM job.</param>
        /// <returns>The Job object that maps against the newly created row on the DB</returns>
        public static Job Create(Microsoft.DistributedAutomation.Jobs.Job wttJob)
        {
            Job j = new Job();
            j.Initialize();
            j.UpdateFrom(wttJob);
            return j;
        }

        /// <summary>
        /// Gets a job based on its primary key (id) in the DB.
        /// </summary>
        /// <param name="id">Id of the job to retrieve</param>
        /// <returns>The Job object that maps against the row specified by Id</returns>
        public static Job Get(int id)
        {
            return (Job)PersistedBase.Get(typeof(Job), id);
        }

        /// <summary>
        /// Gets all the jobs in Sporkfire's DB that map against the specified WTT job ids.
        /// </summary>
        /// <param name="wttIds">All the WTT job ids to look for. This parameter can't be NULL nor empty.</param>
        /// <returns>An array of Job objects that map against the selected rows from the Job table. It can be empty.</returns>
        public static Job[] GetWithWttIds(int[] wttIds)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Job.GetWithWttIds]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@IdList", Data.TransformIdList<int>(wttIds));

            int cAvailable;
            return (Job[])GetList(typeof(Job), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Deletes all the jobs in Sporkfire's DB that have broken links against the WTT job ids.
        /// Through this method, the WttOMRefreshTask is able to delete all ORM jobs that map to a WTT job that has
        /// been deleted from the WTT controller (via WTT Studio).
        /// </summary>
        /// <param name="wttIds">All the WTT job ids that exist in the WTT database.</param>
        public static void DeleteBrokenWttLinks(int[] wttIds)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Job.DeleteBrokenWttLinks]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@IdList", Data.TransformIdList<int>(wttIds));

            int nDeleted = 0;

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                nDeleted = (int)cmd.ExecuteScalar();
            }

            if (nDeleted > 0)
            {
                Run.DeleteWithInvalidJobIds();
                RunConfig.DeleteWithInvalidJobIds();
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\makefile.inc ===
XLSFramework:
    if "%NOLINK%"=="1" xcopy /i /e /y $(XNALS_PATH)\* $(XNALS_DROP) /EXCLUDE:%MAKEDIR%\makefile.excludes
    
WTTOM:
    if "%NOLINK%"=="1" xcopy /i /y $(WTT_PATH)\* $(XNALS_DROP)\App\Services\Bin && \
    if "%NOLINK%"=="1" xcopy /i /y $(WTT_PATH)\* $(XNALS_DROP)\App\Pages\Bin && \
    if "%NOLINK%"=="1" xcopy /i /y $(WTT_PATH)\* $(XNALS_DROP)\App\Tasks && \
    corflags $(XNALS_DROP)\App\Tasks\XtsTasks.exe /32BIT+
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\RunConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The RunConfig object represents a configuration for a Job that overrides some or
    /// all of the default parameters, and is saved for a specific user. A RunConfig takes
    /// a name, that will show up as the name of the Run once it is scheduled. Runs are created
    /// by copying all the parameter values of a RunConfig.
    /// </summary>
    [Serializable]
    public class RunConfig : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum length of the Name field. This is an SQL constraint.
        /// </summary>
        public const int MaxName = 256;

        /// <summary>
        /// Maximum length of the Description field. This is an SQL constraint.
        /// </summary>
        public const int MaxDescription = 512;

        /// <summary>
        /// Id of RunConfig not specified.
        /// </summary>
        public const int IdNotSpecified = -1;

        #endregion

        #region Persisted data

        /// <summary>
        /// Name of the RunConfig. This field is persisted in the DB. Indexed for fast searching
        /// </summary>
        [PrimitiveMember(Size=MaxName, Index=true)]
        private string m_Name;

        /// <summary>
        /// Gets or sets the name of this RunConfig.
        /// Setting this property causes a write to the DB when the current session is committed.
        /// </summary>
        public string Name
        {
            get 
            { 
                return m_Name; 
            }
            set
            {
                if (m_Name != value)
                {
                    BeginEdit();
                    m_Name = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Descriptin of the RunConfig. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxDescription)]
        private string m_Description;

        /// <summary>
        /// Gets or sets the description for this RunConfig
        /// Setting this property causes a write to the DB when the current session is committed.
        /// </summary>
        public string Description
        {
            get 
            {
                return m_Description;
            }
            set
            {
                if (m_Description != value)
                {
                    BeginEdit();
                    m_Description = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Alias of the user that owns this RunConfig. This field is persisted in the DB. Indexed for fast searches.
        /// </summary>
        [PrimitiveMember(Size = Job.MaxOwner, Index=true)]
        private string m_OwnerAlias;

        /// <summary>
        /// Gets or sets the alias of the user that owns this RunConfig.
        /// </summary>
        public string OwnerAlias
        {
            get
            {
                return m_OwnerAlias;
            }
            set
            {
                if (!String.IsNullOrEmpty(value))
                {
                    BeginEdit();
                    m_OwnerAlias = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Id of the Job configured by this RunConfig. This field is persisted in the DB. Indexed for fast searches.
        /// </summary>
        [PrimitiveMember(Index=true)]
        private int m_JobId;

        /// <summary>
        /// Gets the Id of the Job configured by this RunConfig.
        /// </summary>
        public int JobId
        {
            get
            {
                return m_JobId;
            }
        }

        /// <summary>
        /// Gets the Job configured by this RunConfig.
        /// </summary>
        public Job Job
        {
            get
            {
                return Job.Get(m_JobId);
            }
        }

        /// <summary>
        /// Configuration data contained by this RunConfig. This field is persisted in the DB.
        /// </summary>
        private RunConfigData m_RunConfigData;

        /// <summary>
        /// Gets the configuration data contained by this RunConfig.
        /// </summary>
        public RunConfigData RunConfigData
        {
            get
            {
                return m_RunConfigData;
            }
        }

        /// <summary>
        /// This method signals the starting point of a write to the RunConfigData.
        /// </summary>
        public new void BeginEdit()
        {
            base.BeginEdit();
        }

        /// <summary>
        /// This method signals the ending point of a write to the RunConfigData.
        /// User must have called BeginEdit() previously.
        /// Calling Begin/EndEdit causes a write to the DB when the current Session is committed.
        /// </summary>
        /// <exception cref="System.Exception">When the number of EndEdit calls do not match the number of BeginEdit calls.</exception>
        public new void EndEdit()
        {
            base.EndEdit();
        }

        /// <summary>
        /// Gets a boolean that indicates if this RunConfig is the default configuration for its related Job.
        /// </summary>
        /// <remarks>
        /// The default configuration for a Job is identified by the alias that owns the configuration. There is a 'sentinel' value
        /// used throughout Sporkfire in the alias field that is reserved only for default configurations. This alias is stored
        /// in the Globals table under the property name of 'OrmDefaultRunConfigOwnerAlias'. By default this value is 'system'.
        /// The default configuration for a Job is created by the WttOMRefresh task when a new Job is detected. When a Job 
        /// configuration changes, the refresh task will delete the previous default RunConfig and create a new one.
        /// </remarks>
        public bool IsDefault
        {
            get
            {
                return (m_OwnerAlias == Globals.GetProperty("OrmDefaultRunConfigOwnerAlias"));
            }
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get 
            {
                return (int)this.InternalId;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor. Do NOT use - call Create() instead
        /// </summary>
        public RunConfig()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public RunConfig(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a new RunConfig with the default persisted field values.
        /// </summary>
        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_Name = "";
                m_OwnerAlias = "";
                m_Description = "";
                m_JobId = -1;
                m_RunConfigData = new RunConfigData();
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Initializes a new RunConfig, copying all the information from the specified parameter.
        /// </summary>
        /// <param name="copyFrom">The RunConfig to copy from</param>
        /// <param name="owner">The alias of the user that owns the new RunConfig</param>
        public void Initialize(RunConfig copyFrom, string ownerAlias)
        {
            BeginEdit();
            {
                base.Initialize();
                m_Name = copyFrom.Name;
                m_OwnerAlias = ownerAlias;
                m_Description = copyFrom.Description;
                m_JobId = copyFrom.JobId;
                m_RunConfigData = new RunConfigData(copyFrom.RunConfigData);
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Initializes a new RunConfig, using all default values specified by the provided Job.
        /// </summary>
        /// <param name="defaultFrom"></param>
        public void Initialize(Job defaultFrom)
        {
            BeginEdit();
            {
                base.Initialize();
                m_Name = defaultFrom.Name + "(default)";
                m_OwnerAlias = Globals.GetProperty("OrmDefaultRunConfigOwnerAlias");
                m_Description = "Auto populated from WTT default parameter values for this job.";
                m_JobId = defaultFrom.Id;
                m_RunConfigData = new RunConfigData();
                foreach (JobParameter p in defaultFrom.Parameters)
                {
                    switch (p.Type)
                    {
                        case JobParameter.ParameterType.Boolean:
                            m_RunConfigData.AddParameterValue(p.Name, p.DefaultValueAsBool);
                            break;
                        
                        case JobParameter.ParameterType.String:
                            m_RunConfigData.AddParameterValue(p.Name, p.DefaultValue);
                            break;

                        case JobParameter.ParameterType.File:
                            m_RunConfigData.AddParameterValue(p.Name, p.DefaultValueAsFileData);
                            break;
                    }
                }
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Validates the persisted fields values against their SQL constraints.
        /// </summary>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
                m_Name = m_Name.Substring(0, MaxName - 1);

            if (m_Description.Length >= MaxDescription)
                m_Description = m_Description.Substring(0, MaxDescription - 1);
        }

        #endregion

        #region Static methods

        /// <summary>
        /// Creates a copy of the provided RunConfig and assigns the provided alias as the owner
        /// of the newly created copy.
        /// </summary>
        /// <param name="copyFrom">RunConfig that will be copied.</param>
        /// <param name="ownerAlias">Alias of the user that owns the new copy.</param>
        /// <returns>The newly created RunConfig object.</returns>
        public static RunConfig CreateCopy(RunConfig copyFrom, string ownerAlias)
        {
            RunConfig c = new RunConfig();
            c.Initialize(copyFrom, ownerAlias);
            return c;
        }

        /// <summary>
        /// Creates a default RunConfig for the specified Job.
        /// </summary>
        /// <remarks>
        /// This method should only be used from WttOMRefreshTask.
        /// </remarks>
        /// <param name="job">The Job that provides the default parameter values to use.</param>
        /// <returns>The newly created RunConfig object.</returns>
        public static RunConfig CreateDefault(Job job)
        {
            RunConfig c = new RunConfig();
            c.Initialize(job);
            return c;
        }

        /// <summary>
        /// Gets the RunConfig object that has the specified primary key (Id) in the DB
        /// </summary>
        /// <param name="id">The Id of the requested RunConfig</param>
        /// <returns>The RunConfig object for the specified Id</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.Platform.Orm.PersistedBase.InvalidIdException">Thrown when the RunConfig with the specified Id is not found on the DB.</exception>
        public static RunConfig Get(int id)
        {
            return (RunConfig)PersistedBase.Get(typeof(RunConfig), id);
        }

        /// <summary>
        /// Gets all the Runconfig for all environments.
        /// </summary>
        /// <returns></returns>
        public static RunConfig[] GetAll()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.GetAll]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (RunConfig[])PersistedBase.GetList(typeof(RunConfig), cmd, 0, -1, out cAvailable);

        }

        /// <summary>
        /// Get all runconfig for given environment.
        /// </summary>
        /// <param name="environmentName"></param>
        /// <returns></returns>
        public static RunConfig[] GetAllByEnvironment(string environmentName)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.GetAllByEnvironment]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@EnvironmentName", environmentName);

            int cAvailable;
            return (RunConfig[])PersistedBase.GetList(typeof(RunConfig), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets the RunConfig objects owned by the specified user.
        /// </summary>
        /// <param name="ownerAlias">Alias of the user that is used to search for RunConfigs</param>
        /// <returns>An array of all RunConfig objects owned by the specified user. It can be empty.</returns>
        public static RunConfig[] SearchByOwner(string ownerAlias)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.SearchByOwner]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@OwnerAlias", ownerAlias);

            int cAvailable;
            return (RunConfig[])PersistedBase.GetList(typeof(RunConfig), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets the RunConfig objects that match the specified string pattern.
        /// </summary>
        /// <param name="nameLike">List of string tokens that will be used on the search operation.</param>
        /// <param name="startAt">Starting index of the results that will be returned. Used for pagination support.</param>
        /// <param name="maxResults">Maximum number of results to return. Use <c>-1</c> to return all available results. Used for pagination support.</param>
        /// <returns>An array of all RunConfig objects that match the specified pattern. It can be empty.</returns>
        /// <remarks>
        /// The search operation looks for all RunConfig objects using a LIKE search on the DB for every string token
        /// in the <c>nameLike</c> parameter. String tokens are separated by spaces. Each token will be searched separately and
        /// the results will be OR'd together. Example:
        /// If we have the following RunConfig object names:
        /// 1. A sample runconfig
        /// 2. Another sample
        /// 3. One with different name
        /// Then:
        /// - Searching for 'another runconfig' will return 1 and 2.
        /// - Searching for 'run name' will return 1 and 2.
        /// - Searching for 'config sample name' will return 1, 2 and 3.
        /// </remarks>
        public static RunConfig[] SearchByName(string nameLike, int startAt, int maxResults)
        {
            // if nameLike has more than one word in it, create a comma seperated list and pass that to SQL.
            nameLike = string.Join(",", nameLike.Split(' ')).Trim();
            
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.SearchByName]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@NameLike", nameLike);

            int cAvailable;
            return (RunConfig[])PersistedBase.GetList(typeof(RunConfig), cmd, startAt, maxResults, out cAvailable);
        }

        /// <summary>
        /// Deletes the default RunConfig for the specified Job
        /// </summary>
        /// <param name="jobId">Job used to search for the default RunConfig to delete</param>
        public static void DeleteDefaultForJob(int jobId)
        {
            DeleteForJobAndOwner(jobId, Globals.GetProperty("OrmDefaultRunConfigOwnerAlias"));
        }

        /// <summary>
        /// Deletes all RunConfig objects for the specified Job that are owned by the specified user.
        /// </summary>
        /// <param name="jobId">Job used to search for related RunConfig objects.</param>
        /// <param name="ownerAlias">Alias of the user used to search for owned RunConfig objects.</param>
        public static void DeleteForJobAndOwner(int jobId, string ownerAlias)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.DeleteForJobAndOwner]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@JobId", jobId);
            cmd.Parameters.AddWithValue("@OwnerAlias", ownerAlias);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Deletes all RunConfig objects from the DB that do not have a valid link to the Job they configure.
        /// </summary>
        /// <remarks>
        /// This operation shoudl be called from the WttOMRefreshTask every time that Jobs are updated in the DB, to
        /// avoid having orphaned RunConfig objects.
        /// </remarks>
        public static void DeleteWithInvalidJobIds()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.RunConfig.DeleteWithInvalidJobIds]";
            cmd.CommandType = CommandType.StoredProcedure;

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Run.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using Xceed.FileSystem;
using Xceed.Zip;

using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The Run object represents a scheduled Job. It holds the values that were used for the Job's parameters and
    /// has the status of the Run and its end result.
    /// </summary>
    [PersistedRefType(WriteLocked = true)]
    [Serializable]
    public class Run : PersistedBase
    {
        #region Static data

        /// <summary>
        /// Maximum length for the Name field. This is an SQL constraint.
        /// </summary>
        public const int MaxName = 256;

        /// <summary>
        /// Maximum length for the Reason field. This is an SQL constraint.
        /// </summary>
        public const int MaxReason = 2048;

        /// <summary>
        /// Maximum length for the LogPath field. This is an SQL constraint.
        /// </summary>
        public const int MaxLogPath = 1024;

        /// <summary>
        /// Default text to use for runs that do not have an associated build.
        /// This value is only used for display on Sporkfire's webpage.
        /// </summary>
        public const string NoAssociatedBuild = "[No associated Build]";

        #endregion

        #region Persisted data

        /// <summary>
        /// Enumerates the different possible states that a Run can be in. This status is
        /// internal to Sporkfire, it does not maps to the job's run in WTT.
        /// </summary>
        public enum RunStatus
        {
            Unscheduled,
            Scheduled,
            Complete,
            Canceled,
        }

        /// <summary>
        /// Enumerates the different possible results that a Run can get from WTT. This result
        /// maps to the result on the WTT job's run.
        /// </summary>
        public enum RunResult
        {
            Pending,
            Pass,
            Fail,
        }

        /// <summary>
        /// Name of the run. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size=MaxName)]
        private string m_Name;

        /// <summary>
        /// Gets the name of the run.
        /// </summary>
        public string Name
        {
            get
            {
                return m_Name;
            }
        }

        /// <summary>
        /// Reason why this Run was canceled. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxReason)]
        private string m_Reason;

        /// <summary>
        /// Gets or sets the reason why the run was canceled.
        /// When this property is set, it will cause a write to the DB when the current session is commited.
        /// </summary>
        public string Reason
        {
            get
            {
                return m_Reason;
            }
            set
            {
                BeginEdit();
                m_Reason = value;
                EndEdit();
            }
        }

        /// <summary>
        /// Id of the WTT <c>Result</c> that maps to this run. This field is persisted in the DB.
        /// </summary>
        private int m_WttResultId;

        /// <summary>
        /// Gets or sets the Id of the WTT <c>Result</c> that maps to this run.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public int WttResultId
        {
            get
            {
                return m_WttResultId;
            }
            set
            {
                if (m_WttResultId != value)
                {
                    BeginEdit();
                    m_WttResultId = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Path to the share where the WTT logs can be found for this Run. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size=MaxLogPath)]
        private string m_LogPath;

        /// <summary>
        /// Gets or sets the path to the share where the WTT logs can be found for this Run.
        /// This path might not be accessible from CorpNet. For Sporkfire Webpage, use <c>IpLogPath</c> instead.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public string LogPath
        {
            get
            {
                return m_LogPath;
            }
            set
            {
                if (m_LogPath != value)
                {
                    BeginEdit();
                    m_LogPath = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Id of the RunConfig that was used as input to schedule this Run. This field is persisted in the DB.
        /// </summary>
        private int m_RunConfigId;

        /// <summary>
        /// Gets the Id of the RunConfig used to schedule this Run.
        /// </summary>
        public int RunConfigId
        {
            get
            {
                return m_RunConfigId;
            }
        }

        /// <summary>
        /// Id of the Build that was deployed in the related TestNet servers when this Run was scheduled. This field is persisted in the DB.
        /// </summary>
        private int m_BuildId;

        /// <summary>
        /// Gets the Id of the Build that was deployed in the related TestNet servers when this Run was scheduled.
        /// </summary>
        public int BuildId
        {
            get
            {
                return m_BuildId;
            }
        }

        /// <summary>
        /// Gets the Name of the Build that was deployed in the related TestNet servers when this Run was scheduled.
        /// </summary>
        public string BuildName
        {
            get
            {
                try
                {
                    Build b = Build.Get(BuildId);
                    if (b != null)
                    {
                        return b.Name;
                    }
                }
                catch (InvalidIdException) { }

                return NoAssociatedBuild;
            }
        }

        /// <summary>
        /// Id of the Job executed by this Run. This field is persisted in the DB.
        /// </summary>
        private int m_JobId;

        /// <summary>
        /// Gets the Job executed by this Run.
        /// </summary>
        public Job Job
        {
            get
            {
                return Job.Get(m_JobId);
            }
        }

        /// <summary>
        /// Current status of the Run. This field is persisted in the DB.
        /// </summary>
        private RunStatus m_Status;

        /// <summary>
        /// Gets or sets the current status of the Run.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public RunStatus Status
        {
            get
            {
                return m_Status;
            }
            set
            {
                if (m_Status != value)
                {
                    BeginEdit();
                    m_Status = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Final result of this Run, as reported by WTT. This field is persisted in the DB.
        /// </summary>
        private RunResult m_Result;

        /// <summary>
        /// Gets or sets the final result of this Run, as reported by WTT.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public RunResult Result
        {
            get
            {
                return m_Result;
            }
            set
            {
                if (m_Result != value)
                {
                    BeginEdit();
                    m_Result = value;
                    EndEdit();
                }
            }
        }
        /// <summary>
        /// Indicates whether the cancel was requested from Sporkfire's webpage. This field is persisted in the DB.
        /// </summary>
        private bool m_CancelRequested;

        /// <summary>
        /// Gets or sets a boolean flag that indicates whether this Run was canceled from Sporkfire's webpage.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public bool CancelRequested
        {
            get
            {
                return m_CancelRequested;
            }
            set
            {
                if (m_CancelRequested != value)
                {
                    BeginEdit();
                    m_CancelRequested = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Indicates whether this run is pending cleanup by the WttRunCleanupTask task. This field is persisted in the DB.
        /// </summary>
        private bool m_PendingCleanup;

        /// <summary>
        /// Gets or sets a boolean flag that indicates whether this Run is pending cleanup by the WttRunCleanupTask task.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public bool PendingCleanup
        {
            get
            {
                return m_PendingCleanup;
            }
            set
            {
                if (m_PendingCleanup != value)
                {
                    BeginEdit();
                    m_PendingCleanup = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Indicates whether a mail has been sent or not, indicating the result of this Run. This field is persisted in the DB.
        /// </summary>
        private bool m_MailSent;

        /// <summary>
        /// Gets or sets a boolean flag that indicates whether a mail with the results of this Run has been sent or not.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public bool MailSent
        {
            get
            {
                return m_MailSent;
            }
            set
            {
                if (m_MailSent != value)
                {
                    BeginEdit();
                    m_MailSent = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Priority of this Run relative to other scheduled runs. This field is persisted in the DB.
        /// </summary>
        private int m_Priority;

        /// <summary>
        /// Gets or sets the relative priority of this Run. When unscheduled, Runs with higher priorities will be scheduled into WTT first.
        /// Setting this property will cause a write to the DB when the current session is commited.
        /// </summary>
        public int Priority
        {
            get
            {
                return m_Priority;
            }
            set
            {
                if (m_Priority != value)
                {
                    BeginEdit();
                    m_Priority = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Boolean flag that indicates this Run is marked for deletion from SporkfireDB and WTTLogs. 
        /// This field is persisted in the DB. This field is indexed for fast searches.
        /// </summary>
        [PrimitiveMember(Index=true)]
        private bool m_MarkedForDeletion;

        /// <summary>
        /// Returns a boolean flag that indicates this Run is marked for deletion from SporkfireDB and WTTLogs
        /// </summary>
        public bool IsMarkedForDeletion
        {
            get
            {
                return m_MarkedForDeletion;
            }
        }

        /// <summary>
        /// Time at which this Run was scheduled from the Sporkfire webpage. This field is persisted in the DB.
        /// </summary>
        private DateTime m_ScheduleTime;

        /// <summary>
        /// Gets the time at which this Run was scheduled from the Sporkfire webpage.
        /// </summary>
        public DateTime ScheduleTime
        {
            get
            {
                return m_ScheduleTime;
            }
        }

        /// <summary>
        /// Alias of the user who scheduled this Run. This field is persisted in the DB.
        /// </summary>
        private string m_SchedulerAlias;

        /// <summary>
        /// Gets the alias of the user who scheduled this Run.
        /// </summary>
        public string SchedulerAlias
        {
            get
            {
                return m_SchedulerAlias;
            }
        }

        /// <summary>
        /// RunConfigData used to schedule this Run. This field is persisted in the DB.
        /// </summary>
        private RunConfigData m_RunConfigData;

        /// <summary>
        /// Gets the RunConfigData used to scheduled this Run.
        /// </summary>
        public RunConfigData RunConfigData
        {
            get
            {
                return m_RunConfigData;
            }
        }

        /// <summary>
        /// Enumerates the possible state of raw data generation for a run. In sequential order, the state starts
        /// as <c>NotRequested</c> until a user requests the data from the webpage. Then its value is set to
        /// <c>Requested</c>. The <c>OrmRawDataTask</c> will then pick it up and generate the raw data. During this
        /// operation the state will be set to <c>FetchingFromDatabase</c> and after it is done it will set the
        /// state to either <c>Empty</c> if no data for the run is found, or <c>Generated</c> if the file has
        /// been successfully saved.
        /// </summary>
        public enum RawDataStatus
        {
            NotRequested,
            Requested,
            FetchingFromDatabase,
            Empty,
            Generated,
        }

        /// <summary>
        /// Raw data state. This is a persisted field. Indexed for fast searches.
        /// </summary>
        [PrimitiveMember(Index=true)]
        private RawDataStatus m_RawData;

        /// <summary>
        /// Gets or sets the state of the raw data generate operation.
        /// When changing the value of this property, a DB write will be issued when the current session is commited.
        /// </summary>
        public RawDataStatus RawData
        {
            get
            {
                return m_RawData;
            }
            set
            {
                if (m_RawData != value)
                {
                    BeginEdit();
                    m_RawData = value;
                    EndEdit();
                }
            }
        }

        /// <summary>
        /// Gets the internal ORM id of this object
        /// </summary>
        public int Id
        {
            get
            {
                return (int)InternalId;
            }
        }

        #endregion

        #region Object initialization

        /// <summary>
        /// Default (empty) constructor. Do NOT use - call Create() instead
        /// </summary>
        public Run()
        {
        }

        /// <summary>
        /// Serialization constructor - do NOT use.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public Run(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Initializes a new Run with the default persisted field values.
        /// </summary>
        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_JobId = -1;
                m_RunConfigId = -1;
                m_WttResultId = -1;
                m_BuildId = Build.NonAssociated;
                m_Name = "";
                m_SchedulerAlias = "";
                m_Reason = "";
                m_RunConfigData = new RunConfigData();
                m_Status = RunStatus.Unscheduled;
                m_Result = RunResult.Pending;
                m_Priority = 1;
                m_ScheduleTime = DateTime.MaxValue;
                m_LogPath = "";
                m_MarkedForDeletion = false;
                m_RawData = RawDataStatus.NotRequested;
                Validate();
            }
            EndEdit();
        }

        /// <summary>
        /// Initializes a new Run with the specified values
        /// </summary>
        /// <param name="build">The build (TestNet deployment) that this Run will execute against</param>
        /// <param name="config">The RunConfig that provides the parameter values to schedule the Run</param>
        /// <param name="schedulerAlias">The alias of the user scheduling this Run</param>
        public void Initialize(Build build, RunConfig config, string schedulerAlias)
        {
            BeginEdit();
            {
                base.Initialize();
                m_JobId = config.JobId;
                m_RunConfigId = config.Id;
                m_WttResultId = -1;
                if (build != null)
                {
                    m_BuildId = build.Id;
                }
                else
                {
                    m_BuildId = -1;
                }
                m_Name = config.Name;
                m_SchedulerAlias = schedulerAlias;
                m_Reason = "";
                m_RunConfigData = new RunConfigData(config.RunConfigData);
                m_Status = RunStatus.Unscheduled;
                m_Result = RunResult.Pending;
                m_Priority = 1;
                m_ScheduleTime = DateTime.UtcNow;
                m_LogPath = "";
                m_MarkedForDeletion = false;
                m_RawData = RawDataStatus.NotRequested;
                Validate();
            }
            EndEdit();
        }

        #endregion

        #region Object methods

        /// <summary>
        /// Gets a list of all the files in the results path from WTT that match the specified filename pattern
        /// </summary>
        /// <param name="pattern">The pattern used to scan for files on the results path</param>
        /// <param name="option">The search option to use when matching against the pattern</param>
        /// <returns>A list of paths to the log files that match the pattern. These are fully qualified paths. This could be NULL.</returns>
        public string[] FindLogFiles(string pattern, SearchOption option)
        {
            List<string> files = new List<string>();
            DirectoryInfo root = new DirectoryInfo(LogPath);
            if (root.Exists)
            {
                foreach (FileInfo file in root.GetFiles(pattern, option))
                {
                    files.Add(file.FullName);
                }
            }

            return files.ToArray();
        }

        /// <summary>
        /// Cancels this instance of the Run, with the specified string as the reason for the Run cancelation.
        /// </summary>
        /// <param name="reason">Reason for which the Run has been canceled</param>
        public void Cancel(string reason)
        {
            Cancel(Id, reason);
        }

        /// <summary>
        /// Marks this Run for deletion. Once a Run has been marked for deletion it will no longer be returned
        /// by any of the static Get methods. A task in XtsTasks will eventually pick up all Runs marked for 
        /// deletion and cleanup their resources from SporkfireDB as well as the WTTLogs share.
        /// </summary>
        public void MarkForDeletion()
        {
            BeginEdit();
            m_MarkedForDeletion = true;
            EndEdit();
        }

        /// <summary>
        /// Reads a table from the provided SqlDataReader and generates a CSV file that contains
        /// the information in the following format:
        /// COL1_NAME,COL2_NAME,COL3_NAME,...
        /// ROW1_COL1,ROW1_COL2,ROW1_COL3,...
        /// ROW2_COL1,ROW2_COL2,ROW2_COL3,...
        /// ...
        /// </summary>
        /// <param name="folder">The folder where the new CSV file will be saved to</param>
        /// <param name="tableName">Name of the table being dumped. Used to generate the CSV file name</param>
        /// <param name="r">Data reader that contains the table information. Must be located at row 0.</param>
        /// <remarks>If the data readers contains no rows, no CSV file will be generated.</remarks>
        private static void DumpTable(AbstractFolder folder, string tableName, SqlDataReader r)
        {
            if (r.Read())
            {
                AbstractFile file = folder.CreateFile(tableName + ".csv", false);

                using (StreamWriter sw = new StreamWriter(file.OpenWrite(true)))
                {

                    List<string> columns = new List<string>();
                    for (int i = 0; i < r.FieldCount; ++i)
                    {
                        columns.Add(r.GetName(i));
                    }

                    sw.WriteLine(String.Join(",", columns.ToArray()));

                    do
                    {
                        int i;
                        for (i = 0; i < columns.Count - 1; ++i)
                        {
                            sw.Write(r.GetValue(i).ToString() + ",");
                        }
                        sw.WriteLine(r.GetValue(i));
                    } while (r.Read());
                }
            }
        }

        /// <summary>
        /// Dumps all tables specified in the <c>tables</c> parameter in CSV format. Only records relevate to <c>runId</c> are dumped.
        /// The result of the operation is a CSV file per-table will be saved into the provided <c>folder</c>.
        /// </summary>
        /// <param name="folder">Folder where the generated CSV files will be saved</param>
        /// <param name="connectionString">Connection string used to connect to the database</param>
        /// <param name="tables">Dictionary that maps table name against stored procedure name used to obtain the data reader</param>
        /// <param name="runId">Id of the Run which should be looked for on the specified tables</param>
        /// <remarks>
        /// Each entry in <c>tables</c> maps the name of a table that must be saved in CSV format against a stored procedure that
        /// will be executed to populate an <c>SqlDataReader</c>. This stored procedure must accept a parameter called @RunId, which
        /// will receive the Id of the Run that the results should be filtered by.
        /// </remarks>
        private static void DumpTablesByRunId(AbstractFolder folder, string connectionString, Dictionary<string, string> tables, int runId)
        {
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                conn.Open();
                foreach (KeyValuePair<string, string> table in tables)
                {
                    using (SqlCommand cmd = new SqlCommand())
                    {
                        cmd.CommandText = table.Value;
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.Parameters.AddWithValue("@RunId", runId);
                        cmd.Connection = conn;
                        cmd.CommandTimeout = 60; // 1 minute

                        using (SqlDataReader r = cmd.ExecuteReader())
                        {
                            DumpTable(folder, table.Key, r);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Generates a ZIP file that contains a collection of CSV files which have the information of several
        /// tables from both SporkfireDB and ReportDB, with their records filtered by the specified RunId.
        /// </summary>
        public RawDataStatus GetRawData()
        {
            AbstractFolder root = null;

            try
            {
                root = new DiskFolder(Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("D")));

                // Default connection properties
                SqlConnectionStringBuilder sqlsb = new SqlConnectionStringBuilder();
                sqlsb.ApplicationName = "Pages.Server";
                sqlsb.ConnectTimeout = 60;
                sqlsb.DataSource = Globals.GetProperty("SqlServerName");
                sqlsb.IntegratedSecurity = true;
                sqlsb.Enlist = false;
                sqlsb.MinPoolSize = 1;
                sqlsb.MaxPoolSize = 200;
                sqlsb.Pooling = true;
                sqlsb.MultipleActiveResultSets = true;

                // All tables that will be grabbed from the DB and exported into CSV
                Dictionary<string, string> tables = new Dictionary<string, string>();
                tables["DisplayToID"] = "[DisplayToID.SelectByRunId]";
                tables["CounterData"] = "[CounterData.SelectByRunId]";
                tables["CounterDetails"] = "[CounterDetails.SelectByRunId]";
                tables["Events"] = "[Events.SelectByRunId]";

                // Dump tables from the ReportingDb catalog
                sqlsb.InitialCatalog = Globals.GetProperty("SqlReportingDb");
                DumpTablesByRunId(root, sqlsb.ConnectionString, tables, Id);
                tables.Clear();

                //Repeat for the TestCaseTotals table
                tables["TestCaseTotals"] = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.GetByRunIdRawData]";
                sqlsb.InitialCatalog = Globals.GetProperty("SqlSporkfireDb");
                DumpTablesByRunId(root, sqlsb.ConnectionString, tables, Id);

                // No files have been written? Then return null.
                if (!root.Exists || root.GetFiles(true).Length == 0)
                {
                    return RawDataStatus.Empty;
                }
                else
                {
                    // Create a ZipArchive and copy all created files into it
                    ZipArchive zip = new ZipArchive(new DiskFile(System.IO.Path.Combine(LogPath, "rawdata.zip")));
                    root.CopyFilesTo(zip, false, true);
                    return RawDataStatus.Generated;
                }
            }
            finally
            {
                if (root != null && root.Exists)
                {
                    foreach (AbstractFile file in root.GetFiles(true))
                    {
                        // This liberates memory right away, instead of waiting for the GC to kick in
                        file.Delete();
                    }
                    root.Delete();
                }
            }
        }

        /// <summary>
        /// Validates the persisted fields against the SQL constraints
        /// </summary>
        private void Validate()
        {
            if (m_Name.Length >= MaxName)
                m_Name = m_Name.Substring(0, MaxName - 1);

            if (m_Reason.Length >= MaxReason)
                m_Reason = m_Reason.Substring(0, MaxReason - 1);
        }

        #endregion

        #region Static methods

        /// <summary>
        /// Creates a new Run and queues it to run on WTT. It initializes the Run with the provided parameters.
        /// </summary>
        /// <param name="build">The build (TestNet deployment) that this Run will execute against</param>
        /// <param name="config">The RunConfig that provides the parameter values to schedule the Run</param>
        /// <param name="schedulerAlias">The alias of the user scheduling this Run</param>
        /// <returns>The newly created Run</returns>
        public static Run CreateSchedule(Build build, RunConfig config, string schedulerAlias)
        {
            Run r = new Run();
            r.Initialize(build, config, schedulerAlias);
            return r;
        }

        /// <summary>
        /// Retrieves all Run objects that have been scheduled to run on WTT.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetScheduled()
        {
            return GetByStatus(RunStatus.Scheduled);
        }

        /// <summary>
        /// Retrieves all Run objects that are queued to run on WTT.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetUnscheduled()
        {
            return GetByStatus(RunStatus.Unscheduled);
        }

        /// <summary>
        /// Retrieves all Run objects that have completed its run on WTT.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetComplete()
        {
            return GetByStatus(RunStatus.Complete);
        }

        /// <summary>
        /// Retrieves all Run objects that have been scheduled, either from the webpage or from WTT Studio.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetCanceled()
        {
            return GetByStatus(RunStatus.Canceled);
        }

        /// <summary>
        /// Retrieves all Run objects that are scheduled to run on WTT, canceled from the webpage and pending cancelation on WTT.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetScheduledAndCancelRequested()
        {
            return GetByStatusAndCancelRequested(RunStatus.Scheduled);
        }

        /// <summary>
        /// Retrieves all Run objects that have completed its run on WTT but are still pending to be processed by the WttRunCleanupTask task.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetCompleteAndPendingCleanup()
        {
            return GetByStatusAndPendingCleanup(RunStatus.Complete);
        }

        /// <summary>
        /// Retrieves all Run objects that have completed its run on WTT but have not sent a completed email.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetCompleteAndNoMailSent()
        {
            return GetByStatusAndNoMailSent(RunStatus.Complete);
        }

        /// <summary>
        /// Retrieves all Run objects that have been canceled but are still pending to be processed by the WttRunCleanupTask task.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetCanceledAndPendingCleanup()
        {
            return GetByStatusAndPendingCleanup(RunStatus.Canceled);
        }

        /// <summary>
        /// Retrieves all Run objects that have been canceled and have not sent a cancelation email.
        /// </summary>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetCanceledAndNoMailSent()
        {
            return GetByStatusAndNoMailSent(RunStatus.Canceled);
        }

        /// <summary>
        /// Retrieves the Run objects that have been canceled from the webpage and match the given RunStatus.
        /// </summary>
        /// <param name="status">The status value to search for on Run table.</param>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        private static Run[] GetByStatusAndCancelRequested(RunStatus status)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByStatusAndCancelRequested]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Status", status);

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Retrieves all Run objects that are pending to be processed by the WttRunCleanupTask and match the given RunStatus.
        /// </summary>
        /// <param name="status">The status value to search for on Run table.</param>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        private static Run[] GetByStatusAndPendingCleanup(RunStatus status)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByStatusAndPendingCleanup]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Status", status);

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Retrieves all Run objects that have not sent a completion mail and match the given RunStatus.
        /// </summary>
        /// <param name="status">The status value to search for on Run table.</param>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        private static Run[] GetByStatusAndNoMailSent(RunStatus status)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByStatusAndNoMailSent]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Status", status);

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Retrieves all Run objects that match the given RunStatus.
        /// </summary>
        /// <param name="status">The status value to search for on Run table.</param>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        private static Run[] GetByStatus(RunStatus status)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByStatus]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Status", status);

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Retrieves all Run objects that were scheduled by the given user.
        /// </summary>
        /// <param name="status">Alias of the scheduling user.</param>
        /// <returns>Array of all the Run objects retrieved from the DB. It can be empty.</returns>
        public static Run[] GetBySchedulerAlias(string alias)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetBySchedulerAlias]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@SchedulerAlias", alias);

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Retrieves all Run objects. This method includes parameters to support pagination. 
        /// The returned Run objects are sorted by Schedule time.
        /// </summary>
        /// <param name="startAt">First index</param>
        /// <param name="maxResults">Maximum number of results to return</param>
        /// <param name="cAvailable">Number of returned Run objects</param>
        /// <returns>An array with all the retrieved Run objects. It can be empty</returns>
        public static Run[] GetAll(int startAt, int maxResults, out int cAvailable)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetAll]";
            cmd.CommandType = CommandType.StoredProcedure;

            return (Run[])PersistedBase.GetList(typeof(Run), cmd, startAt, maxResults, out cAvailable);
        }

        public static int GetCount()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetCount]";
            cmd.CommandType = CommandType.StoredProcedure;

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                return (int)cmd.ExecuteScalar();
            }
        }

        /// <summary>
        /// Retrieves all Run objects that were scheduled under the specified build. 
        /// This method includes parameters to support pagination. The returned Run objects
        /// are sorted by Schedule time.
        /// </summary>
        /// <param name="buildId">Id of the build used in the search operation</param>
        /// <param name="startAt">First index</param>
        /// <param name="maxResults">Maximum number of results to return</param>
        /// <param name="cAvailable">Number of returned Run objects</param>
        /// <returns>An array with all the retrieved Run objects. It can be empty</returns>
        public static Run[] GetByBuild(int buildId, int startAt, int maxResults, out int cAvailable)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByBuild]";
            cmd.Parameters.AddWithValue("@BuildId", buildId);

            return (Run[])PersistedBase.GetList(typeof(Run), cmd, startAt, maxResults, out cAvailable);
        }

        public static int GetCountByBuild(int buildId)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetCountByBuild]";
            cmd.Parameters.AddWithValue("@BuildId", buildId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                return (int)cmd.ExecuteScalar();
            }
        }

        /// <summary>
        /// Retrieves all Run objects that were scheduled under the specified runConfig. 
        /// This method includes parameters to support pagination. The returned Run objects
        /// are sorted by Schedule time.
        /// </summary>
        /// <param name="runConfigId">Id of the runConfig used in the search operation</param>
        /// <param name="startAt">First index</param>
        /// <param name="maxResults">Maximum number of results to return</param>
        /// <param name="cAvailable">Number of returned Run objects</param>
        /// <returns>An array with all the retrieved Run objects. It can be empty</returns>
        public static Run[] GetByRunConfig(int runConfigId, int startAt, int maxResults, out int cAvailable)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByRunConfig]";
            cmd.Parameters.AddWithValue("@RunConfigId", runConfigId);

            return (Run[])PersistedBase.GetList(typeof(Run), cmd, startAt, maxResults, out cAvailable);
        }

        public static int GetCountByRunConfig(int runConfigId)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetCountByRunConfig]";
            cmd.Parameters.AddWithValue("@RunConfigId", runConfigId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                return (int)cmd.ExecuteScalar();
            }
        }

        /// <summary>
        /// Retrieves all Run objects that were scheduled under the specified build or specified RunConfig. 
        /// This method includes parameters to support pagination. The returned Run objects
        /// are sorted by Schedule time.
        /// </summary>
        /// <param name="buildId">Id of the build used in the search operation</param>
        /// <param name="runConfigId">RunConfigID used in the search operation</param>
        /// <param name="startAt">First index</param>
        /// <param name="maxResults">Maximum number of results to retu  rn</param>
        /// <param name="cAvailable">Number of returned Run objects</param>
        /// <returns>An array with all the retrieved Run objects. It can be empty</returns>
        public static Run[] GetByBuildAndRunConfig(int buildId, int runConfigId, int startAt, int maxResults, out int cAvailable)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetByRunConifgAndBuild]";
            cmd.Parameters.AddWithValue("@BuildId", buildId);
            cmd.Parameters.AddWithValue("@RunConfigId", runConfigId);
            
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, startAt, maxResults, out cAvailable);
        }

        public static int GetCountByBuildAndRunConfig(int buildId, int runConfigId)
        {
            SqlCommand cmd = Data.GetSqlCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetCountByRunConifgAndBuild]";
            cmd.Parameters.AddWithValue("@BuildId", buildId);
            cmd.Parameters.AddWithValue("@RunConfigId", runConfigId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                return (int)cmd.ExecuteScalar();
            }
        }

        /// <summary>
        /// Returns all Run entries that have been marked for deletion.
        /// </summary>
        /// <returns>An array with all retrieved Run objects. It can be empty.</returns>
        public static Run[] GetMarkedForDeletion()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetMarkedForDeletion]";
            cmd.CommandType = CommandType.StoredProcedure;

            int cAvailable;
            return (Run[])PersistedBase.GetList(typeof(Run), cmd, 0, -1, out cAvailable);
        }

        /// <summary>
        /// Gets the Run object that matches the given primary key (Id)
        /// </summary>
        /// <param name="id">The Id of the requested Run</param>
        /// <returns>The Run object retrieved from the DB</returns>
        /// <exception cref="Microsoft.Xna.LiveServer.Platform.Orm.PersistedBase.InvalidIdException">Thrown when the Run with the specified Id is not found on the DB.</exception>
        public static Run Get(int id)
        {
            return (Run)PersistedBase.Get(typeof(Run), id);
        }

        /// <summary>
        /// Deletes all Runs from the DB that point to Jobs that do not exist anymore.
        /// This is used by the WttOMRefreshTask after deleting Jobs from the DB that do not map to any existing WTT Job.
        /// </summary>
        public static void DeleteWithInvalidJobIds()
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.DeleteWithInvalidJobIds]";
            cmd.CommandType = CommandType.StoredProcedure;

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Marks all the Runs with specified Ids for deletion. After being marked for deletion, runs will no longer
        /// be visible from Sporkfire! website and they will eventually be picked up by the OrmRunDeletionTask task.
        /// </summary>
        /// <param name="ids">Array of ids of the Run objects to mark for deletion</param>
        /// <remarks>
        /// When used from a Session that has any of the specified Run objects loaded into ORM, making a change to any
        /// of the delete Run objects and attempting to save after calling MarkForDeletionWithIds will generate a version
        /// mismatch error at the time the Session is committed. The Run objects will remain marked for deletion even
        /// if such conflict happens (which is the desired behavior).
        /// </remarks>
        public static void MarkForDeletionWithIds(int[] ids)
        {
            string idString = Data.TransformIdList<int>(ids);
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.MarkForDeletionWithIds]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Ids", idString);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Returns all the Runs that have the specified RawData status. This method supports pagination.
        /// </summary>
        /// <param name="status">The status for raw data being searched</param>
        /// <param name="startAt">The initial index to return from the results returned by SQL</param>
        /// <param name="maxResults">Maximum number of Runs to return</param>
        /// <param name="cAvailable">Total number of Runs returned by SQL</param>
        /// <returns>An array of Runs that match the sepcified RawData status. Can be empty.</returns>
        public static Run[] GetWithRawDataStatus(RawDataStatus status, int startAt, int maxResults, out int cAvailable)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.GetWithRawDataStatus]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RawDataStatus", status);

            return (Run[])GetList(typeof(Run), cmd, startAt, maxResults, out cAvailable);
        }

        /// <summary>
        /// Deletes all the Runs with specified Ids. This will delete the Run objects and all the RunConfigData elements
        /// linked to the Runs being deleted.
        /// </summary>
        /// <param name="ids">Array of ids of the Run objects to delete.</param>
        public static void DeleteWithIds(int[] ids)
        {
            string idString = Data.TransformIdList<int>(ids);
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Run.DeleteWithIds]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@Ids", idString);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Cancels an Unscheduled or Scheduled run.
        /// This operation requires acquiring the object's lock, in order to avoid having the WttSchedulingTask
        /// making changes to the same object at the same time. Generally, ORM conflict resolution logic would be good enough
        /// to resolve such conflicts, however WttSchedulingTask launches a process (WttCl) that can't be easily
        /// rolled back when ORM detects the versioning conflict.
        /// </summary>
        /// <param name="runId">Id of the run to cancel</param>
        /// <param name="reason">Reason that explains why is the Run being canceled</param>
        /// <exception cref="Microsoft.Xna.LiveServer.Platform.Orm.Session.AlreadyLockedException">This exception is launched when the WttSchedulingTask holds a lock to this object while trying to cancel the job.</exception>
        public static void Cancel(int runId, string reason)
        {
            using (SessionRef session = Session.Create())
            {
                Run r = Run.Get(runId);
                Guid g = r.Lock();
                try
                {
                    switch (r.Status)
                    {
                        case RunStatus.Unscheduled:
                            r.CancelRequested = true;
                            r.Status = RunStatus.Canceled;
                            r.Reason = reason;
                            session.Commit();
                            break;

                        case RunStatus.Scheduled:
                            r.CancelRequested = true;
                            r.Reason = reason;
                            session.Commit();
                            break;

                        default:
                            // $$avgarcia: Throw an exception? There is really nothing to do here.
                            break;
                    }
                }
                finally
                {
                    r.Unlock(g);
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_none_12.4.56.0_none_98b6e276f20ecbca
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.om
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.om,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_none_12.4.56.0_none_98b6e276f20ecbca
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.om
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.om_no-public-key_12.4.56.0_x-ww_623c93d6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.om,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\RunConfigData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.Xna.LiveServer.Platform.Orm;

namespace Microsoft.Xna.LiveServer.LS3i.OM
{
    /// <summary>
    /// The RunConfigData is used by both Run and RunConfig objects. It holds a collection of parameter values,
    /// stored into 3 different dictionaries, one for each data type. Boolean, String and FileData are the
    /// supported parameter types. The 3 different dictionaries are used to optimize storage space in the DB.
    /// </summary>
    [Serializable]
    public class RunConfigData
    {
        #region Static data

        /// <summary>
        /// Maximum length of the Environment field. This is an SQL field constraint.
        /// </summary>
        public const int MaxEnvironment = 64;

        #endregion

        #region Persisted data

        /// <summary>
        /// Environment used on TestNet to schedule this job. E.g.: StressNet2. This field is persisted in the DB.
        /// </summary>
        [PrimitiveMember(Size = MaxEnvironment)]
        public string Environment;

        /// <summary>
        /// Dictionary of Boolean parameters, using the parameter name as key. Unsorted. This field is persisted in the DB.
        /// </summary>
        [DictionaryMember(KeyType = typeof(string), KeySize = Job.MaxParameterName, ElementType = typeof(bool))]
        public FastDictionaryUnsorted<string, bool> BooleanValues;

        /// <summary>
        /// Dictionary of String parameters, using the parameter name as key. Unsorted. This field is persisted in the DB.
        /// </summary>
        [DictionaryMember(KeyType = typeof(string), KeySize = Job.MaxParameterName, ElementType = typeof(string), ElementSize = Job.MaxParameterValue)]
        public FastDictionaryUnsorted<string, string> StringValues;

        /// <summary>
        /// Dictionary of FileData parameters, using the parameter name as key. Unsorted. This field is persisted in the DB.
        /// </summary>
        [DictionaryMember(KeyType = typeof(string), KeySize = Job.MaxParameterName, ElementType = typeof(FileData))]
        public FastDictionaryUnsorted<string, FileData> FileValues;

        #endregion

        #region Object initialization

        /// <summary>
        /// Default constructor. Initializes all fields to their default values.
        /// </summary>
        public RunConfigData()
        {
            Environment = "";
            BooleanValues = new FastDictionaryUnsorted<string, bool>();
            StringValues = new FastDictionaryUnsorted<string, string>();
            FileValues = new FastDictionaryUnsorted<string, FileData>();
        }

        /// <summary>
        /// Initializes all fields to the values from the specified RunConfigData.
        /// </summary>
        /// <param name="copyFrom">RunConfigData used to copy the field values</param>
        public RunConfigData(RunConfigData copyFrom)
        {
            Environment = copyFrom.Environment;
            BooleanValues = new FastDictionaryUnsorted<string, bool>();
            foreach (string key in copyFrom.BooleanValues.Keys)
            {
                BooleanValues.Add(key, copyFrom.BooleanValues[key]);
            }
            StringValues = new FastDictionaryUnsorted<string, string>();
            foreach (string key in copyFrom.StringValues.Keys)
            {
                StringValues.Add(key, copyFrom.StringValues[key]);
            }
            FileValues = new FastDictionaryUnsorted<string, FileData>();
            foreach (string key in copyFrom.FileValues.Keys)
            {
                FileValues.Add(key, copyFrom.FileValues[key]);
            }
        }

        /// <summary>
        /// Adds a boolean parameter to the parameter dictionaries.
        /// </summary>
        /// <param name="name">Name of the parameter</param>
        /// <param name="value">Value of the parameter</param>
        public void AddParameterValue(string name, bool value)
        {
            if (BooleanValues.ContainsKey(name))
                BooleanValues.Remove(name);

            BooleanValues.Add(name, value);
        }

        /// <summary>
        /// Adds a string parameter to the parameter dictionaries.
        /// </summary>
        /// <param name="name">Name of the parameter</param>
        /// <param name="value">Value of the parameter</param>
        public void AddParameterValue(string name, string value)
        {
            if (StringValues.ContainsKey(name))
                StringValues.Remove(name);

            StringValues.Add(name, value);
        }

        /// <summary>
        /// Adds a FileData parameter to the parameter dictionaries.
        /// </summary>
        /// <param name="name">Name of the parameter</param>
        /// <param name="value">Value of the parameter</param>
        public void AddParameterValue(string name, FileData value)
        {
            if (FileValues.ContainsKey(name))
                FileValues.Remove(name);

            FileValues.Add(name, value);
        }

        /// <summary>
        /// Removes a FileData parameter from the parameter dictionaries.
        /// </summary>
        /// <param name="name">Name of the file to remove</param>
        public void DeleteFileParameterValue(string name)
        {
            if (FileValues.ContainsKey(name))
            {
                FileValues.Remove(name);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Results\RunTotals.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM.Results
{
    [Serializable]
    public class RunTotals : PersistedBase
    {
        #region Persisted data

        private int m_RunId;

        public int RunId
        {
            get
            {
                return m_RunId;
            }
        }

        [PrimitiveMember(Size = TestCaseTotals.MaxTestCase)]
        private string m_TestCase;

        public string TestCase
        {
            get
            {
                return m_TestCase;
            }
        }

        private int m_InProgress;

        public int InProgress
        {
            get
            {
                return m_InProgress;
            }
        }

        private int m_Passed;

        public int Passed
        {
            get
            {
                return m_Passed;
            }
        }

        private int m_Failed;

        public int Failed
        {
            get
            {
                return m_Failed;
            }
        }

        private float m_TotalTPS;

        public float TotalTPS
        {
            get
            {
                return m_TotalTPS;
            }
        }

        #endregion

        #region Object initialization

        public RunTotals()
        {
        }

        public RunTotals(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_RunId = 0;
                m_TestCase = "";
                m_InProgress = 0;
                m_Passed = 0;
                m_Failed = 0;
                m_TotalTPS = 0;
            }
            EndEdit();
        }

        #endregion

        #region Static methods

        public static void GenerateForRun(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.RunTotals.GenerateForRun]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        public static RunTotals[] GetForRun(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.RunTotals.GetForRun]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            int cAvailable;
            return (RunTotals[])GetList(typeof(RunTotals), cmd, 0, -1, out cAvailable);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\PerfCounter.cs ===
﻿using System;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfCounter
    {
        #region Members

        private int m_CounterId;
        private string m_MachineName;
        private string m_ObjectName;
        private string m_CounterName;
        private int m_CounterType;
        private int m_Scale;
        private string m_InstanceName;
        private int m_InstanceIndex;

        #endregion

        #region Constructors and Factories

        private PerfCounter(
            int counterId,
            string machineName,
            string objectName,
            string counterName,
            int counterType,
            int scale,
            string instanceName,
            int instanceIndex)
        {
            m_MachineName = machineName;
            m_ObjectName = objectName;
            m_CounterName = counterName;
            m_CounterType = counterType;
            m_Scale = scale;
            m_InstanceName = instanceName;
            m_InstanceIndex = instanceIndex;
        }

        internal PerfCounter(
            string machineName,
            string objectName,
            string counterName) :
            this(0, machineName, objectName, counterName, 0, 0, null, 0)
        {
        }

        public static PerfCounter GetByCounterId(
            string connectionString,
            int counterId)
        {
            PerfCounter counter = null;
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.GetCounterById]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@CounterId", counterId);

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (reader.HasRows)
                {
                    reader.Read();
                    counter =
                        new PerfCounter(
                            reader.GetInt32(0),
                            reader.GetString(1),
                            reader.GetString(2),
                            reader.IsDBNull(3) ? String.Empty : reader.GetString(3),
                            reader.IsDBNull(4) ? 0 : reader.GetInt32(4),
                            reader.IsDBNull(5) ? 0 : reader.GetInt32(5),
                            reader.IsDBNull(6) ? String.Empty : reader.GetString(6),
                            reader.IsDBNull(7) ? 0 : reader.GetInt32(7)
                            );
                }
                reader.Close();
            }
            return counter;
        }

        #endregion

        #region Methods

        internal bool WriteToDb(SqlConnection connection)
        {
            if (m_CounterId != 0)
            {
                return false;
            }

            SqlCommand command = new SqlCommand("[dbo].[PerfCounters.AddCounter]", connection);
            command.CommandType = System.Data.CommandType.StoredProcedure;
            command.Parameters.AddWithValue("@MachineName", m_MachineName);
            command.Parameters.AddWithValue("@ObjectName", m_ObjectName);
            command.Parameters.AddWithValue("@CounterName", m_CounterName);
            command.Parameters.AddWithValue("@CounterType", m_CounterType);
            command.Parameters.AddWithValue("@DefaultScale", m_Scale);
            command.Parameters.AddWithValue("@InstanceName", m_InstanceName == null ? string.Empty : m_InstanceName);
            command.Parameters.AddWithValue("@CounterId", 0).Direction = System.Data.ParameterDirection.Output;
            if (command.ExecuteNonQuery() < 1)
            {
                return false;
            }

            m_CounterId = Convert.ToInt32(command.Parameters["@CounterId"]);
            return true;
        }

        #endregion

        #region Properties

        public string MachineName
        {
            get { return m_MachineName; }
        }

        public string ObjectName
        {
            get { return m_ObjectName; }
        }

        public int CounterId
        {
            get { return m_CounterId; }
        }

        public string CounterName
        {
            get { return m_CounterName; }
        }

        public int CounterType
        {
            get { return m_CounterType; }
        }

        public int Scale
        {
            get { return m_Scale; }
        }

        public string InstanceName
        {
            get { return m_InstanceName; }
        }

        public int InstanceIndex
        {
            get { return m_InstanceIndex; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Results\GlobalRunResults.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM.Results
{
    [Serializable]
    public class GlobalRunResults : PersistedBase
    {
        #region Static data

        public const int MaxRunGuid = 40;

        public const int MaxExplanation = 2048;

        #endregion

        #region Persisted data

        private int m_RunId;

        public int RunId
        {
            get
            {
                return m_RunId;
            }
        }

        [PrimitiveMember(Index = true, Size = MaxRunGuid)]
        private string m_RunGuid;

        public string RunGuid
        {
            get
            {
                return m_RunGuid;
            }
        }

        [PrimitiveMember(Size = MaxExplanation)]
        private string m_Explanation;

        public string Explanation
        {
            get
            {
                return m_Explanation;
            }
        }

        private int m_TestCaseSuccessCount;

        public int TestCaseSuccessCount
        {
            get
            {
                return m_TestCaseSuccessCount;
            }
        }

        private int m_TestCaseFailureCount;

        public int TestCaseFailureCount
        {
            get
            {
                return m_TestCaseFailureCount;
            }
        }

        private int m_TestInstanceSuccessCount;

        public int TestInstanceSuccessCount
        {
            get
            {
                return m_TestInstanceSuccessCount;
            }
        }

        private int m_TestInstanceFailureCount;

        public int TestInstanceFailureCount
        {
            get
            {
                return m_TestInstanceFailureCount;
            }
        }

        private bool m_Succeeded;

        public bool Succeeded
        {
            get
            {
                return m_Succeeded;
            }
        }

        #endregion

        #region Object initialization

        public GlobalRunResults()
        {
        }

        public GlobalRunResults(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_RunId = 0;
                m_RunGuid = "";
                m_Explanation = "";
                m_TestCaseSuccessCount = 0;
                m_TestCaseFailureCount = 0;
                m_TestInstanceSuccessCount = 0;
                m_TestInstanceFailureCount = 0;
                m_Succeeded = false;
            }
            EndEdit();
        }

        #endregion

        #region Static methods

        public static void SetRunIdForGuid(Guid guid, int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.GlobalRunResults.SetRunIdForGuid]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunGuid", guid.ToString("D"));
            cmd.Parameters.AddWithValue("@RunId", runId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\Main.cs ===
using System;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfAggregatorMain
    {
        private const string AppName = "PerfAggregator.exe";

        public static void Main(string[] args)
        {
            string sqlServerName;
            string sqlDatabase;
            string configFilePath;
            Guid runGuid;

            if (!ParseArgs(args, out sqlServerName, out sqlDatabase, out configFilePath, out runGuid))
            {
                Console.WriteLine("\nUsage: {0} <sqlServerName> <sqlDatabase> <configFilePath> <runGuid>", AppName);
                Console.WriteLine("\tAny valid guid format may be used for the runGuid.");
                Console.WriteLine("\nExample: {0} localhost ls3i_reporting c:\\RunAnalyzer.xml 12345678-1234-1234-1234-123456789012", AppName);
                return;
            }

            PerfCounterAggregator aggregator = new PerfCounterAggregator(configFilePath, sqlServerName, sqlDatabase, runGuid);
            aggregator.Aggregate();
        }

        private static bool ParseArgs(
            string[] args,
            out string sqlServerName,
            out string sqlDatabase,
            out string configFilePath,
            out Guid runGuid)
        {
            sqlServerName = null;
            sqlDatabase = null;
            configFilePath = null;
            runGuid = Guid.Empty;

            if (args.Length != 4)
            {
                return false;
            }

            sqlServerName = args[0];
            sqlDatabase = args[1];
            configFilePath = args[2];
            try
            {
                runGuid = new Guid(args[3]);
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }
    }     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\OM\Results\TestCaseTotals.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;

namespace Microsoft.Xna.LiveServer.LS3i.OM.Results
{
    [Serializable]
    public class TestCaseTotals : PersistedBase
    {
        #region Static data

        public const int MaxRunGuid = 40;

        public const int MaxMachineName = 35;

        public const int MaxTestCase = 64;

        #endregion

        #region Persisted data

        private int m_RunId;

        public int RunId
        {
            get
            {
                return m_RunId;
            }
        }

        [PrimitiveMember(Index = true, Size = MaxRunGuid)]
        private string m_RunGuid;

        public string RunGuid
        {
            get
            {
                return m_RunGuid;
            }
        }

        [PrimitiveMember(Index = true, Size = MaxMachineName)]
        private string m_MachineName;

        public string MachineName
        {
            get
            {
                return m_MachineName;
            }
        }

        [PrimitiveMember(Size = MaxTestCase)]
        private string m_TestCase;

        public string TestCase
        {
            get
            {
                return m_TestCase;
            }
        }

        private int m_InProgress;

        public int InProgress
        {
            get
            {
                return m_InProgress;
            }
        }

        private int m_Passed;

        public int Passed
        {
            get
            {
                return m_Passed;
            }
        }

        private int m_Failed;

        public int Failed
        {
            get
            {
                return m_Failed;
            }
        }

        private float m_TotalTPS;

        public float TotalTPS
        {
            get
            {
                return m_TotalTPS;
            }
        }

        private float m_RunningTPS;

        public float RunningTPS
        {
            get
            {
                return m_RunningTPS;
            }
        }

        private bool m_Succeeded;

        public bool Succeeded
        {
            get
            {
                return m_Succeeded;
            }
        }

        #endregion

        #region Object initialization

        public TestCaseTotals()
        {
        }

        public TestCaseTotals(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            BeginEdit();
            {
                base.Initialize();
                m_RunId = 0;
                m_RunGuid = "";
                m_MachineName = "";
                m_TestCase = "";
                m_InProgress = 0;
                m_Passed = 0;
                m_Failed = 0;
                m_TotalTPS = 0;
                m_RunningTPS = 0;
                m_Succeeded = false;
            }
            EndEdit();
        }

        #endregion

        #region Static methods

        public static string[] GetMachinesForRunId(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.GetMachinesForRunId]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            List<string> machines = new List<string>();

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                SqlDataReader r = cmd.ExecuteReader();
                while (r.Read())
                {
                    machines.Add(r.GetString(0));
                }
            }

            return machines.ToArray();
        }

        public static string[] GetTestCasesForRunId(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.GetTestCasesForRunId]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            List<string> testCases = new List<string>();

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                SqlDataReader r = cmd.ExecuteReader();
                while (r.Read())
                {
                    testCases.Add(r.GetString(0));
                }
            }

            return testCases.ToArray();
        }

        public static TestCaseTotals[] GetForRun(int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.GetForRun]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunId", runId);

            int cAvailable;
            return (TestCaseTotals[])GetList(typeof(TestCaseTotals), cmd, 0, -1, out cAvailable);
        }

        public static void SetRunIdForGuid(Guid guid, int runId)
        {
            SqlCommand cmd = Data.GetSqlCommand();

            cmd.CommandText = "[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.SetRunIdForGuid]";
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@RunGuid", guid.ToString("D"));
            cmd.Parameters.AddWithValue("@RunId", runId);

            using (cmd.Connection = Session.Current.GetSqlConnection())
            {
                cmd.Connection.Open();
                cmd.ExecuteNonQuery();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\PerfCounterAggregator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Xml;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfCounterAggregator
    {
        #region Members

        private string m_ConfigFilePath;
        private string m_SqlConnectionString;
        private Guid m_RunGuid;
        private IList<PerfCounterSession> m_Sessions;
        private Dictionary<string, IList<string>> m_Config;

        #endregion

        #region Constructors

        public PerfCounterAggregator(
            string configFilePath,
            string sqlServerName,
            string databaseName,
            Guid runGuid)
        {
            m_ConfigFilePath = configFilePath;
            m_RunGuid = runGuid;

            SqlConnectionStringBuilder strBuilder = new SqlConnectionStringBuilder();
            strBuilder.DataSource = sqlServerName;
            strBuilder.InitialCatalog = databaseName;
            strBuilder.IntegratedSecurity = true;
            m_SqlConnectionString = strBuilder.ToString();
        }

        #endregion

        #region Methods

        public bool Aggregate()
        {
            LoadConfigurationFromXml();
            if (!GetSessionsFromDb())
            {
                return false;
            }

            foreach (KeyValuePair<string, IList<string>> configEntry in m_Config)
            {
                PerfCounterRecordSet aggregate = CreateAggregateCounter(configEntry.Key, configEntry.Value);
                string sessionName = m_RunGuid.ToString("D") + "_AGGREGATE_" + configEntry.Key;
                PerfCounterSession session = new PerfCounterSession(sessionName, aggregate);
                session.WriteToDb(m_SqlConnectionString);
            }

            return true;
        }

        private PerfCounterRecordSet CreateAggregateCounter(string aggregateName, IEnumerable<string> componentNames)
        {
            DateTime startTime, endTime;
            IList<PerfCounterRecordSet> components = FindMatchingRecordSets(componentNames);
            int[] componentIndices = new int[components.Count];

            FindStartAndEndTimes(components, out startTime, out endTime);
            double recordInterval = FindRecordIntervalInMilliseconds(components);
            int estimatedRecords = Convert.ToInt32((endTime - startTime).TotalMilliseconds / recordInterval) + 1;
            List<PerfCounterRecord> aggRecords = new List<PerfCounterRecord>(estimatedRecords);
            DateTime nextTime = startTime;
            while (true)
            {
                DateTime currTime = nextTime;
                double counterValue = 0;
                long firstValue = 0;
                long secondValue = 0;
                uint included = 0;

                for (int i=0; i<components.Count; i++)
                {
                    if (componentIndices[i] >= components[i].Records.Count)
                    {
                        continue;
                    }

                    PerfCounterRecord record = components[i].Records[componentIndices[i]];
                    if (componentIndices[i] > 0 || record.Timestamp <= currTime)
                    {
                        counterValue += record.CounterValue;
                        firstValue += record.FirstValue;
                        secondValue += record.SecondValue;
                        ++included;
                        ++componentIndices[i];

                        if (record.Timestamp == currTime &&
                            components[i].Records.Count > componentIndices[i])
                        {
                            nextTime = components[i].Records[componentIndices[i]].Timestamp;
                        }
                    }
                }

                if (included > 0)
                {
                    aggRecords.Add(new PerfCounterRecord(currTime, counterValue, firstValue, secondValue));
                    if (currTime == nextTime)
                    {
                        nextTime = currTime.AddMilliseconds(recordInterval);
                    }
                }
                else
                {
                    break;
                }
            }

            string aggObjectName, aggCounterName;
            SplitFriendlyCounterName(aggregateName, out aggObjectName, out aggCounterName);
            PerfCounter aggCounter = new PerfCounter("AGGREGATE", aggObjectName, aggCounterName);
            
            return new PerfCounterRecordSet(aggCounter, aggRecords);
        }

        private IList<PerfCounterRecordSet> FindMatchingRecordSets(IEnumerable<string> friendlyCounterNames)
        {
            List<PerfCounterRecordSet> resultSet = new List<PerfCounterRecordSet>();
            foreach (string friendlyName in friendlyCounterNames)
            {
                string objectName, counterName;
                SplitFriendlyCounterName(friendlyName, out objectName, out counterName);
                foreach (PerfCounterSession session in m_Sessions)
                {
                    foreach (PerfCounterRecordSet recordSet in session.RecordSets)
                    {
                        if ((recordSet.PerfCounter.ObjectName.CompareTo(objectName) == 0) &&
                            (recordSet.PerfCounter.CounterName.CompareTo(counterName) == 0))
                        {
                            resultSet.Add(recordSet);
                        }
                    }
                }
            }

            return resultSet;
        }

        private void SplitFriendlyCounterName(string friendlyName, out string objectName, out string counterName)
        {
            string[] components = friendlyName.Split('\\');
            if (components.Length != 2)
            {
                throw new FormatException(
                    string.Format(
                        "Counter names in the configuration file must contain a performance object name and counter name, separated by a backslash (\\). '{0}' is not formatted correctly.",
                        friendlyName));
            }

            objectName = components[0];
            counterName = components[1];
        }

        private void FindStartAndEndTimes(IEnumerable<PerfCounterRecordSet> recordSets, out DateTime startTime, out DateTime endTime)
        {
            startTime = DateTime.MaxValue;
            endTime = DateTime.MinValue;
            foreach (PerfCounterRecordSet recordSet in recordSets)
            {
                if (recordSet.Records.Count > 0)
                {
                    DateTime thisStart = recordSet.Records[0].Timestamp;
                    DateTime thisEnd = recordSet.Records[recordSet.Records.Count - 1].Timestamp;

                    if (thisStart < startTime)
                    {
                        startTime = thisStart;
                    }

                    if (thisEnd > endTime)
                    {
                        endTime = thisEnd;
                    }
                }
            }
        }

        private double FindRecordIntervalInMilliseconds(IEnumerable<PerfCounterRecordSet> recordSets)
        {
            double interval = 0;
            foreach (PerfCounterRecordSet set in recordSets)
            {
                DateTime startTime, endTime;
                FindStartAndEndTimes(new PerfCounterRecordSet[] {set}, out startTime, out endTime);
                TimeSpan duration = endTime - startTime;
                interval = duration.TotalMilliseconds / (set.Records.Count != 1 ? set.Records.Count - 1 : 1);
                break;
            }
            return interval;
        }

        private bool GetSessionsFromDb()
        {
            if (m_Sessions != null)
            {
                return false;
            }

            IList<Guid> sessionGuids = GetSessionGuidsFromDb();
            m_Sessions = new List<PerfCounterSession>(sessionGuids.Count);
            foreach (Guid sessionGuid in sessionGuids)
            {
                PerfCounterSession session = PerfCounterSession.GetBySessionGuid(m_SqlConnectionString, sessionGuid);
                if (session == null)
                {
                    break;
                }
                m_Sessions.Add(session);
            }

            if (m_Sessions.Count != sessionGuids.Count || m_Sessions.Count == 0)
            {
                m_Sessions = null;
                return false;
            }

            return true;
        }

        private IList<Guid> GetSessionGuidsFromDb()
        {
            IList<Guid> sessionGuids = new List<Guid>();
            using (SqlConnection connection = new SqlConnection(m_SqlConnectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.GetSessionGuidsByRunGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@RunGuid", m_RunGuid.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                while (reader.Read())
                {
                    sessionGuids.Add(reader.GetGuid(0));
                }
                reader.Close();
            }

            return sessionGuids;
        }

        protected void LoadConfigurationFromXml()
        {
            const string rootElement = "PerfAggregatorConfig";
            const string AggregateCounterElement = "AggregateCounter";
            const string AggregateCounterNameAttribute = "name";
            const string ComponentCounterElement = "ComponentCounter";

            m_Config = new Dictionary<string, IList<string>>();
            XmlReader xmlReader = XmlReader.Create(new StreamReader(m_ConfigFilePath));
            xmlReader.ReadStartElement(rootElement);
            while (xmlReader.Read())
            {
                if (xmlReader.IsStartElement(AggregateCounterElement))
                {
                    string aggregateName = xmlReader.GetAttribute(AggregateCounterNameAttribute);
                    if (String.IsNullOrEmpty(aggregateName))
                    {
                        throw new FormatException(
                            string.Format(
                                "Configuration contains a '{0}' element without a '{1}' attribute.",
                                AggregateCounterElement,
                                AggregateCounterNameAttribute));
                    }

                    List<string> componentNames = new List<string>();
                    while (xmlReader.Read())
                    {
                        // Read child elements until we hit the end of the AggregateCounter element.
                        //
                        if (xmlReader.NodeType == XmlNodeType.EndElement &&
                            xmlReader.Name.CompareTo(AggregateCounterElement) == 0)
                        {
                            break;
                        }

                        if (xmlReader.IsStartElement(ComponentCounterElement))
                        {
                            componentNames.Add(xmlReader.ReadElementContentAsString());
                        }
                    }

                    if (componentNames.Count == 0)
                    {
                        throw new FormatException(
                            string.Format(
                                "Configuration contains a '{0}' element without any '{1}' sub-elements.",
                                AggregateCounterElement,
                                ComponentCounterElement));
                    }
                    m_Config.Add(aggregateName, componentNames);
                }
            }
            xmlReader.Close();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\PerfCounterRecord.cs ===
﻿using System;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfCounterRecord
    {
        #region Members

        private DateTime m_Timestamp;
        private double m_CounterValue;
        private Int64 m_FirstValue;
        private Int64 m_SecondValue;

        #endregion

        #region Constructors

        internal PerfCounterRecord(
            DateTime timestamp,
            double counterValue,
            int firstValueA,
            int firstValueB,
            int secondValueA,
            int secondValueB)
        {
            m_Timestamp = timestamp;
            m_CounterValue = counterValue;
            m_FirstValue = (Int64)((Convert.ToUInt64((uint)firstValueB) << 32) | Convert.ToUInt64((uint)firstValueA));
            m_SecondValue = (Int64)((Convert.ToUInt64((uint)secondValueB) << 32) | Convert.ToUInt64((uint)secondValueA));
        }

        internal PerfCounterRecord(
            DateTime timestamp,
            double counterValue,
            long firstValue,
            long secondValue)
        {
            m_Timestamp = timestamp;
            m_CounterValue = counterValue;
            m_FirstValue = firstValue;
            m_SecondValue = secondValue;
        }

        #endregion

        #region Properties

        public DateTime Timestamp
        {
            get { return m_Timestamp; }
        }

        public double CounterValue
        {
            get { return m_CounterValue; }
        }

        public Int64 FirstValue
        {
            get { return m_FirstValue; }
        }

        public int FirstValueA
        {
            get { return Convert.ToInt32(m_FirstValue & 0xFFFFFFFF); }
        }

        public int FirstValueB
        {
            get { return Convert.ToInt32((m_FirstValue >> 32) & 0xFFFFFFFF); }
        }

        public Int64 SecondValue
        {
            get { return m_SecondValue; }
        }

        public int SecondValueA
        {
            get { return Convert.ToInt32(m_SecondValue & 0xFFFFFFFF); }
        }

        public int SecondValueB
        {
            get { return Convert.ToInt32((m_SecondValue >> 32) & 0xFFFFFFFF); }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\PerfCounterRecordSet.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfCounterRecordSet
    {
        private PerfCounter m_PerfCounter;
        private IList<PerfCounterRecord> m_Records;

        #region Constructors and Factories

        internal PerfCounterRecordSet(
            PerfCounter perfCounter,
            IList<PerfCounterRecord> records)
        {
            m_PerfCounter = perfCounter;
            m_Records = records;
        }

        public static PerfCounterRecordSet GetBySessionGuidAndCounterId(
            string connectionString,
            Guid sessionGuid,
            int counterId,
            int recordCount)
        {
            PerfCounter counter = PerfCounter.GetByCounterId(connectionString, counterId);
            if (counter == null)
            {
                return null;
            }

            IList<PerfCounterRecord> records = GetRecordsFromDb(connectionString, sessionGuid, counterId, recordCount);
            if (records == null)
            {
                return null;
            }

            return new PerfCounterRecordSet(counter, records);
        }

        #endregion

        #region Methods

        internal bool WriteToDb(Guid sessionGuid, SqlConnection connection)
        {
            // Write to the CounterDetails table before writing individual data points.
            if (!m_PerfCounter.WriteToDb(connection))
            {
                return false;
            }

            // Write all the data points to the CounterData table.
            string guidString = sessionGuid.ToString("D");
            int counterId = m_PerfCounter.CounterId;
            DataSet dataSet = new DataSet();
            SqlDataAdapter adapter =
                new SqlDataAdapter(
                    string.Format(
                        "select [GUID], [CounterID], [RecordIndex], [CounterDateTime], " +
                        "       [CounterValue], [FirstValueA], [FirstValueB], " +
                        "       [SecondValueA], [SecondValueB], [MultiCount] " +
                        " from [dbo].[CounterData] where [GUID] = '{0}' and [CounterID] = {1}",
                        guidString,
                        counterId),
                    connection);
            adapter.Fill(dataSet);

            DataTable table = dataSet.Tables[0];
            DataRowCollection rows = table.Rows;
            int i = 0;
            foreach (PerfCounterRecord record in m_Records)
            {
                DataRow row = table.NewRow();
                row["GUID"] = guidString;
                row["CounterID"] = counterId;
                row["RecordIndex"] = i;
                row["CounterDateTime"] = record.Timestamp.ToString("u");
                row["CounterValue"] = record.CounterValue;
                row["FirstValueA"] = record.FirstValueA;
                row["FirstValueB"] = record.FirstValueB;
                row["SecondValueA"] = record.SecondValueA;
                row["SecondValueB"] = record.SecondValueB;
                row["MultiCount"] = 0;
                rows.Add(row);
                i++;
            }
            table.AcceptChanges();

            SqlCommand command = adapter.InsertCommand;
            if (command.ExecuteNonQuery() < m_Records.Count)
            {
                return false;
            }

            return true;
        }

        private static IList<PerfCounterRecord> GetRecordsFromDb(
            string connectionString,
            Guid sessionGuid,
            int counterId,
            int recordCount)
        {
            int recordsReceived = 0;
            PerfCounterRecord[] records = new PerfCounterRecord[recordCount];
            IList<PerfCounterRecord> recordList = null;
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.GetCounterDataByIdAndSessionGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@CounterId", counterId);
                command.Parameters.AddWithValue("@SessionGuid", sessionGuid.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                while (reader.Read())
                {
                    int index = reader.GetInt32(0) - 1;
                    PerfCounterRecord record =
                        new PerfCounterRecord(
                            DateTime.Parse(reader.GetString(1)),
                            reader.GetDouble(2),
                            reader.IsDBNull(3) ? 0 : reader.GetInt32(3),
                            reader.IsDBNull(4) ? 0 : reader.GetInt32(4),
                            reader.IsDBNull(5) ? 0 : reader.GetInt32(5),
                            reader.IsDBNull(6) ? 0 : reader.GetInt32(6));
                    if (index >= 0 && index < recordCount && records[index] == null)
                    {
                        records[index] = record;
                        ++recordsReceived;
                    }
                    else
                    {
                        break;
                    }
                }
                reader.Close();
            }

            if (recordsReceived == recordCount)
            {
                recordList = new List<PerfCounterRecord>(records);
            }
            return recordList;
        }

        #endregion

        #region Properties

        public PerfCounter PerfCounter
        {
            get { return m_PerfCounter; }
        }

        public IList<PerfCounterRecord> Records
        {
            get { return m_Records; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\PerfAggregator\PerfCounterSession.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.PerfAggregator
{
    public class PerfCounterSession
    {
        private Guid m_SessionId;
        private string m_DisplayName;
        private DateTime m_StartTime;
        private DateTime m_StopTime;
        private int m_RecordCount;
        private int m_MinutesToUtc;
        private string m_TimeZoneName;
        private PerfCounterRecordSet[] m_RecordSets;

        #region Constructors and Factories

        private PerfCounterSession(
            Guid sessionId,
            string displayName,
            DateTime startTime,
            DateTime stopTime,
            int recordCount,
            int minutesToUtc,
            string timeZoneName)
        {
            m_SessionId = sessionId;
            m_DisplayName = displayName;
            m_StartTime = startTime;
            m_StopTime = stopTime;
            m_RecordCount = recordCount;
            m_MinutesToUtc = minutesToUtc;
            m_TimeZoneName = timeZoneName;
        }

        internal PerfCounterSession(
            string displayName,
            PerfCounterRecordSet recordSet)
            : this(
                Guid.NewGuid(),
                displayName,
                recordSet.Records[0].Timestamp,
                recordSet.Records[recordSet.Records.Count - 1].Timestamp,
                recordSet.Records.Count,
                0,
                null)
        {
            m_RecordSets = new PerfCounterRecordSet[] { recordSet };
        }

        public static PerfCounterSession GetBySessionGuid(
            string connectionString,
            Guid sessionGuid)
        {
            PerfCounterSession session = null;
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.GetSessionByGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Guid", sessionGuid.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (reader.HasRows)
                {
                    reader.Read();
                    session =
                        new PerfCounterSession(
                            reader.GetGuid(0),
                            reader.GetString(2),
                            DateTime.Parse(reader.GetString(3)),
                            DateTime.Parse(reader.GetString(4)),
                            reader.GetInt32(5),
                            reader.GetInt32(6),
                            reader.GetString(7));
                }
                reader.Close();
            }

            if (!session.PopulateRecordSets(connectionString))
            {
                session = null;
            }
            return session;
        }

        #endregion

        #region Methods

        internal bool WriteToDb(string connectionString)
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                // First write to DisplayToID table.
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.AddSession]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@Guid", m_SessionId.ToString("D"));
                command.Parameters.AddWithValue("@DisplayString", m_DisplayName);
                command.Parameters.AddWithValue("@LogStartTime", m_StartTime.ToString("u"));
                command.Parameters.AddWithValue("@LogStopTime", m_StopTime.ToString("u"));
                command.Parameters.AddWithValue("@NumberOfRecords", m_RecordCount);
                command.Parameters.AddWithValue("@MinutesToUTC", m_MinutesToUtc);
                command.Parameters.AddWithValue("@TimeZoneName", m_TimeZoneName == null ? string.Empty : m_TimeZoneName);
                if (command.ExecuteNonQuery() < 1)
                {
                    return false;
                }

                // Second, write each counter's CounterDetails and CounterData table entries.
                foreach (PerfCounterRecordSet set in m_RecordSets)
                {
                    if (!set.WriteToDb(m_SessionId, connection))
                    {
                        return false;
                    }
                }

                return true;
            }
        }

        private bool PopulateRecordSets(string connectionString)
        {
            if (m_RecordSets != null)
            {
                return false;
            }

            IList<int> counterIds = GetCounterIdsFromDb(connectionString);
            if (counterIds.Count == 0)
            {
                return false;
            }

            m_RecordSets = new PerfCounterRecordSet[counterIds.Count];
            int counterIndex = 0;
            foreach (int counterId in counterIds)
            {
                m_RecordSets[counterIndex] =
                    PerfCounterRecordSet.GetBySessionGuidAndCounterId(
                        connectionString,
                        m_SessionId,
                        counterId,
                        m_RecordCount);
                if (m_RecordSets[counterIndex] == null)
                {
                    break;
                }
                ++counterIndex;
            }

            if (counterIndex != counterIds.Count)
            {
                m_RecordSets = null;
                return false;
            }

            return true;
        }

        private IList<int> GetCounterIdsFromDb(string connectionString)
        {
            IList<int> counterList = new List<int>();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[PerfCounters.GetCounterIdsBySessionGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@SessionGuid", m_SessionId.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                while (reader.Read())
                {
                    counterList.Add(reader.GetInt32(0));
                }
                reader.Close();
            }
            return counterList;
        }

        #endregion

        #region Properties

        public string DisplayName
        {
            get { return m_DisplayName; }
        }

        public PerfCounterRecordSet[] RecordSets
        {
            get { return m_RecordSets; }
        }

        public Guid SessionId
        {
            get { return this.m_SessionId; }
        }

        public DateTime StartTime
        {
            get { return m_StartTime; }
        }

        public DateTime StopTime
        {
            get { return m_StopTime; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\RunAnalyzer.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using Microsoft.DistributedAutomation.Logger;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public abstract class RunAnalyzer
    {
        #region Members

        private string m_ConfigFilePath;
        private string m_SqlConnectionString;
        private Guid m_RunGuid;

        #endregion

        #region Constructors

        public RunAnalyzer(
            string configFilePath,
            string sqlServerName,
            string databaseName,
            Guid runGuid)
        {
            m_ConfigFilePath = configFilePath;
            m_RunGuid = runGuid;

            SqlConnectionStringBuilder strBuilder = new SqlConnectionStringBuilder();
            strBuilder.DataSource = sqlServerName;
            strBuilder.InitialCatalog = databaseName;
            strBuilder.IntegratedSecurity = true;
            m_SqlConnectionString = strBuilder.ToString();
        }

        #endregion

        #region Instance Methods

        public void Analyze()
        {
            bool runSucceeded;
            string explanation;
            int testCaseSuccessCount;
            int testCaseFailureCount;
            int testInstanceSuccessCount;
            int testInstanceFailureCount;

            // Load algorithm-specific configuration from the input XML file.
            //
            try
            {
                XmlReader configReader = XmlReader.Create(new StreamReader(m_ConfigFilePath));
                LoadConfigurationFromXml(configReader);
                configReader.Close();
            }
            catch (Exception ex)
            {
                throw new FormatException(
                    "Failed to load configuration file.  See InnerException for details.",
                    ex);
            }

            // Load each machine's results from the database.
            //
            Dictionary<string, MachineRunResult> machineResults =
                MachineRunResult.GetMachineRunResultsByRunGuid(m_SqlConnectionString, m_RunGuid);

            // Before we give the machine results to our subclasses (which could muck with them), sum up the test case
            // success and failure counts.
            //
            SumTestCaseCounts(
                machineResults,
                out testCaseSuccessCount,
                out testCaseFailureCount,
                out testInstanceSuccessCount,
                out testInstanceFailureCount);

            // Let the subclass' algorithm decide whether the run as a whole is a success.
            //
            runSucceeded = RunPassed(machineResults, out explanation);

            // Create a new GlobalRunResult with all the data we have so far and write it to the database.
            //
            GlobalRunResult globalResult = 
                GlobalRunResult.CreateAndSaveToDatabase(
                    m_SqlConnectionString,    
                    m_RunGuid,
                    runSucceeded,
                    explanation,
                    testCaseSuccessCount,
                    testCaseFailureCount,
                    testInstanceSuccessCount,
                    testInstanceFailureCount,
                    machineResults.Values);

            // Also log the global results to the WTT log.
            //
            WriteResultsToWttLog(globalResult);
        }

        protected void SumTestCaseCounts(
            Dictionary<string, MachineRunResult> machineResults,
            out int testCaseSuccessCount,
            out int testCaseFailureCount,
            out int testInstanceSuccessCount,
            out int testInstanceFailureCount)
        {
            testCaseSuccessCount = 0;
            testCaseFailureCount = 0;
            testInstanceSuccessCount = 0;
            testInstanceFailureCount = 0;

            foreach (MachineRunResult machineResult in machineResults.Values)
            {
                foreach (TestCaseResult testResult in machineResult.TestCaseResults)
                {
                    testInstanceSuccessCount += testResult.CountPassed;
                    testInstanceFailureCount += testResult.CountFailed;

                    if (testResult.Succeeded)
                    {
                        ++testCaseSuccessCount;
                    }
                    else
                    {
                        ++testCaseFailureCount;
                    }
                }
            }
        }

        private void WriteResultsToWttLog(GlobalRunResult globalResult)
        {
            using (TestLogger wttLog = new TestLogger("$LogFile"))
            {
                wttLog.EnableTraceLevels("Msg|PFRollup");

                wttLog.StartContext("Run Summary");
                wttLog.StartTest("Run Aggregate Result");
                wttLog.Trace(new LevelRollup(globalResult.TestCaseSuccessCount, 0, globalResult.TestCaseFailureCount, 0, 0));

                foreach (MachineRunResult machineResult in globalResult.MachineRunResults)
                {
                    string machineContext = "Machine:" + machineResult.MachineName;
                    wttLog.StartContext(machineContext);

                    foreach (TestCaseResult testResult in machineResult.TestCaseResults)
                    {
                        wttLog.StartTest(testResult.TestName);
                        wttLog.Trace(new LevelRollup(testResult.CountPassed, 0, testResult.CountFailed, 0, 0));
                        wttLog.EndTest(
                            testResult.TestName,
                            testResult.Succeeded ?
                                Microsoft.DistributedAutomation.Logger.TestResult.Pass :
                                Microsoft.DistributedAutomation.Logger.TestResult.Fail,
                            null);
                    }

                    wttLog.EndContext(machineContext);
                }

                wttLog.EndTest(
                    "Run Aggregate Result",
                    globalResult.Succeeded ?
                        Microsoft.DistributedAutomation.Logger.TestResult.Pass :
                        Microsoft.DistributedAutomation.Logger.TestResult.Fail,
                        null);
                wttLog.EndContext("Run Summary");
            }
        }

        public string ConnectionString
        {
            get { return m_SqlConnectionString; }
        }

        #endregion

        #region Abstract Methods

        // Overridden to support multiple decision-making algorithms.
        //
        protected abstract bool RunPassed(
            Dictionary<string, MachineRunResult> machineResults,
            out string explanation);
        protected abstract void LoadConfigurationFromXml( XmlReader xmlReader );

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\Main.cs ===
using System;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public class RunAnalyzerMain
    {
        private const string AppName = "RunAnalyzer.exe";

        public static void Main(string[] args)
        {
            string sqlServerName;
            string sqlDatabase;
            string configFilePath;
            Guid runGuid;

            if (!ParseArgs(args, out sqlServerName, out sqlDatabase, out configFilePath, out runGuid))
            {
                Console.WriteLine("\nUsage: {0} <sqlServerName> <sqlDatabase> <configFilePath> <runGuid>", AppName);
                Console.WriteLine("\tAny valid guid format may be used for the runGuid.");
                Console.WriteLine("\nExample: {0} localhost ls3i_reporting c:\\RunAnalyzer.xml 12345678-1234-1234-1234-123456789012", AppName);
                return;
            }

            TpsAndErrorRunAnalyzer analyzer = new TpsAndErrorRunAnalyzer(configFilePath, sqlServerName, sqlDatabase, runGuid);
            analyzer.Analyze();

            GlobalRunResult runResult = GlobalRunResult.GetFromDatabaseByRunGuid(analyzer.ConnectionString, runGuid);
            if (runResult == null)
            {
                Console.WriteLine("\nFAILED to generate GlobalRunResult from analysis.");
                return;
            }
            Console.WriteLine("\nSuccessfully generated GlobalRunResult:");
            Console.WriteLine("\tGuid: {0}", runResult.RunGuid);
            Console.WriteLine("\tSucceeded?: {0}", runResult.Succeeded);
            Console.WriteLine("\tExplanation: {0}", runResult.Explanation);
            Console.WriteLine("\tTestCaseSuccessCount: {0}", runResult.TestCaseSuccessCount);
            Console.WriteLine("\tTestCaseFailureCount: {0}", runResult.TestCaseFailureCount);
            Console.WriteLine("\tTestInstanceSuccessCount: {0}", runResult.TestInstanceSuccessCount);
            Console.WriteLine("\tTestInstanceFailureCount: {0}", runResult.TestInstanceFailureCount);
        }

        private static bool ParseArgs(
            string[] args,
            out string sqlServerName,
            out string sqlDatabase,
            out string configFilePath,
            out Guid runGuid)
        {
            sqlServerName = null;
            sqlDatabase = null;
            configFilePath = null;
            runGuid = Guid.Empty;

            if (args.Length != 4)
            {
                return false;
            }

            sqlServerName = args[0];
            sqlDatabase = args[1];
            configFilePath = args[2];
            try
            {
                runGuid = new Guid(args[3]);
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }
    }     
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\MachineRunResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public class MachineRunResult
    {
        #region Members

        private string m_MachineName;
        private Dictionary<string, TestCaseResult> m_TestCases;

        #endregion

        #region Constructors and Factories

        // Used internally by the factories.
        //
        private MachineRunResult(string machineName)
        {
            m_MachineName = machineName;
            m_TestCases = new Dictionary<string, TestCaseResult>();
        }

        // Public factory for fetching a set of MachineRunResults from the database.
        //
        public static Dictionary<string, MachineRunResult> GetMachineRunResultsByRunGuid(
            string connectionString,
            Guid runGuid)
        {
            Dictionary<string, MachineRunResult> machineRunResults = new Dictionary<string, MachineRunResult>();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.GetByGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@RunGuid", runGuid.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                while (reader.Read())
                {
                    TestCaseResult testCaseResult =
                        new TestCaseResult(
                            reader.GetString(0),
                            reader.GetString(1),
                            reader.GetInt32(2),
                            reader.GetInt32(3),
                            reader.GetInt32(4),
                            reader.GetFloat(5),
                            reader.GetFloat(6),
                            reader.GetBoolean(7));

                    // If we haven't yet seen any records from this machine, create a new entry for it in our MachineResults map.
                    //
                    if (!machineRunResults.ContainsKey(testCaseResult.MachineName))
                    {
                        machineRunResults.Add(testCaseResult.MachineName, new MachineRunResult(testCaseResult.MachineName));
                    }

                    machineRunResults[testCaseResult.MachineName].AddTestCase(testCaseResult);
                }
                reader.Close();
            }
            return machineRunResults;
        }

        #endregion

        #region Accessors

        public string MachineName
        {
            get { return m_MachineName; }
        }

        public IEnumerable<TestCaseResult> TestCaseResults
        {
            get { return m_TestCases.Values; }
        }

        #endregion

        #region Instance Methods

        public TestCaseResult GetTestCaseByName(string testCaseName)
        {
            TestCaseResult testCase;
            if (!m_TestCases.TryGetValue(testCaseName, out testCase))
            {
                testCase = null;
            }
            return testCase;
        }
        
        private void AddTestCase(TestCaseResult testCaseResult)
        {
            if (testCaseResult.MachineName.CompareTo(m_MachineName) != 0)
            {
                throw new ArgumentException("Cannot add a test case for a different machine to this machine's result set.");
            }

            m_TestCases.Add(testCaseResult.TestName, testCaseResult);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\GlobalRunResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public class GlobalRunResult
    {
        #region Members

        private Guid m_RunGuid;
        private bool m_Succeeded;
        private string m_Explanation;
        private int m_TestCaseSuccessCount;
        private int m_TestCaseFailureCount;
        private int m_TestInstanceSuccessCount;
        private int m_TestInstanceFailureCount;
        private Dictionary<string, MachineRunResult> m_MachineResults;

        #endregion

        #region Constructors and Factories

        // Used internally by GetFromDatabaseByRunGuid to recreate a previously-saved GlobalRunResult from the database.
        //
        private GlobalRunResult()
        {
            m_MachineResults = new Dictionary<string, MachineRunResult>();
        }

        // Used to create a novel GlobalRunResult (i.e. one that hasn't yet been saved in the database).
        //
        private GlobalRunResult(
            Guid runGuid,
            bool succeeded,
            string explanation,
            int testCaseSuccessCount,
            int testCaseFailureCount,
            int testInstanceSuccessCount,
            int testInstanceFailureCount,
            IEnumerable<MachineRunResult> machineRunResults)
        {
            m_RunGuid = runGuid;
            m_Succeeded = succeeded;
            m_Explanation = explanation;
            m_TestCaseSuccessCount = testCaseSuccessCount;
            m_TestCaseFailureCount = testCaseFailureCount;
            m_TestInstanceSuccessCount = testInstanceSuccessCount;
            m_TestInstanceFailureCount = testInstanceFailureCount;
            m_MachineResults = new Dictionary<string, MachineRunResult>();

            foreach (MachineRunResult machineResult in machineRunResults)
            {
                if (machineResult != null)
                {
                    m_MachineResults.Add(machineResult.MachineName, machineResult);
                }
            }
        }

        // Public factory to create a novel GlobalRunResult and save it to the database.
        //
        public static GlobalRunResult CreateAndSaveToDatabase(
            string connectionString,
            Guid runGuid,
            bool succeeded,
            string explanation,
            int testCaseSuccessCount,
            int testCaseFailureCount,
            int testInstanceSuccessCount,
            int testInstanceFailureCount,
            IEnumerable<MachineRunResult> machineRunResults)
        {
            GlobalRunResult runResult =
                new GlobalRunResult(
                    runGuid,
                    succeeded,
                    explanation,
                    testCaseSuccessCount,
                    testCaseFailureCount,
                    testInstanceSuccessCount,
                    testInstanceFailureCount,
                    machineRunResults);

            runResult.SaveToDatabase(connectionString);
            return runResult;
        }

        // Public factory to recreate a previously-saved GlobalRunResult from the database.
        //
        public static GlobalRunResult GetFromDatabaseByRunGuid(
            string connectionString,
            Guid runGuid)
        {
            GlobalRunResult runResult = new GlobalRunResult();;
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[Microsoft.Xna.LiveServer.LS3i.OM.Results.GlobalRunResults.GetByGuid]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;
                command.Parameters.AddWithValue("@RunGuid", runGuid.ToString("D"));

                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (!reader.HasRows)
                {
                    runResult = null;
                }
                else
                {
                    reader.Read();
                    runResult.m_RunGuid = new Guid(reader.GetString(0));
                    runResult.m_Succeeded = reader.GetBoolean(1);
                    runResult.m_Explanation = reader.GetString(2);
                    runResult.m_TestCaseSuccessCount = reader.GetInt32(3);
                    runResult.m_TestCaseFailureCount = reader.GetInt32(4);
                    runResult.m_TestInstanceSuccessCount = reader.GetInt32(5);
                    runResult.m_TestInstanceFailureCount = reader.GetInt32(6);
                }
                reader.Close();
            }

            if (runResult != null)
            {
                runResult.m_MachineResults = MachineRunResult.GetMachineRunResultsByRunGuid(connectionString, runGuid);
            }

            return runResult;
        }


        #endregion

        #region Instance Methods

        private void SaveToDatabase( string connectionString )
        {
            GlobalRunResult runResult = new GlobalRunResult(); ;
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                SqlCommand command = new SqlCommand("[dbo].[Microsoft.Xna.LiveServer.LS3i.OM.Results.GlobalRunResults.Add]", connection);
                command.CommandType = System.Data.CommandType.StoredProcedure;

                // other params needed
                command.Parameters.AddWithValue("@RunGuid", m_RunGuid.ToString("D"));
                command.Parameters.AddWithValue("@Succeeded", m_Succeeded);
                command.Parameters.AddWithValue("@Explanation", m_Explanation);
                command.Parameters.AddWithValue("@TestCaseSuccessCount", m_TestCaseSuccessCount);
                command.Parameters.AddWithValue("@TestCaseFailureCount", m_TestCaseFailureCount);
                command.Parameters.AddWithValue("@TestInstanceSuccessCount", m_TestInstanceSuccessCount);
                command.Parameters.AddWithValue("@TestInstanceFailureCount", m_TestInstanceFailureCount);

                connection.Open();
                command.ExecuteNonQuery();
            }
        }

        #endregion

        #region Accessors

        public Guid RunGuid
        {
            get { return m_RunGuid; }
        }

        public bool Succeeded
        {
            get { return m_Succeeded; }
        }

        public string Explanation
        {
            get { return m_Explanation != null ? m_Explanation : String.Empty; }
        }

        public int TestCaseSuccessCount
        {
            get { return m_TestCaseSuccessCount; }
        }

        public int TestCaseFailureCount
        {
            get { return m_TestCaseFailureCount; }
        }

        public int TestInstanceSuccessCount
        {
            get { return m_TestInstanceSuccessCount; }
        }

        public int TestInstanceFailureCount
        {
            get { return m_TestInstanceFailureCount; }
        }

        public IEnumerable<MachineRunResult> MachineRunResults
        {
            get { return m_MachineResults.Values; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_runanalyzer_none_12.4.56.0_none_7f0a847f6fe34bba
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=runanalyzer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.manifest
XP_MANIFEST_PATH=manifests\msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.cat
XP_CATALOG_PATH=manifests\msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.cat
XP_PAYLOAD_PATH=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=runanalyzer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\TestCaseResult.cs ===
﻿using System;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public class TestCaseResult
    {
        #region Members

        private string m_MachineName;
        private string m_TestCaseName;
        private int m_CountPassed;
        private int m_CountFailed;
        private int m_CountInProgress;
        private float m_TotalTps;
        private float m_RunningTps;
        private bool m_Succeeded;

        #endregion

        #region Constructors

        public TestCaseResult(
            string machineName,
            string testName,
            int countPassed,
            int countFailed,
            int countInProgress,
            float totalTps,
            float runningTps,
            bool succeeded)
        {
            m_MachineName = machineName;
            m_TestCaseName = testName;
            m_CountPassed = countPassed;
            m_CountFailed = countFailed;
            m_CountInProgress = countInProgress;
            m_TotalTps = totalTps;
            m_RunningTps = runningTps;
            m_Succeeded = succeeded;
        }

        #endregion

        #region Accessors

        public string MachineName
        {
            get { return m_MachineName; }
        }

        public string TestName
        {
            get { return m_TestCaseName; }
        }

        public int CountPassed
        {
            get { return m_CountPassed; }
        }

        public int CountFailed
        {
            get { return m_CountFailed; }
        }

        public int CountInProgress
        {
            get { return m_CountInProgress; }
        }

        public float TotalTps
        {
            get { return m_TotalTps; }
        }

        public float RunningTps
        {
            get { return m_RunningTps; }
        }

        public bool Succeeded
        {
            get { return m_Succeeded; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_runanalyzer_none_12.4.56.0_none_7f0a847f6fe34bba
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=runanalyzer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.manifest
XP_MANIFEST_PATH=manifests\msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.cat
XP_CATALOG_PATH=manifests\msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74.cat
XP_PAYLOAD_PATH=msil_runanalyzer_no-public-key_12.4.56.0_x-ww_30eded74
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=runanalyzer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\RunAnalysis\TpsAndErrorRunAnalyzer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace Microsoft.Xna.LiveServer.LS3i.RunAnalysis
{
    public class TpsAndErrorRunAnalyzer : RunAnalyzer
    {
        private class TestCriteria
        {
            public float MinAggregateTps;
            public int MaxFailuresPerClient;
        }

        private Dictionary<string, TestCriteria> m_TestCriteria;

        public TpsAndErrorRunAnalyzer(
            string configFilePath,
            string sqlServerName,
            string databaseName,
            Guid runGuid) :
            base(configFilePath, sqlServerName, databaseName, runGuid)
        {
            m_TestCriteria = new Dictionary<string, TestCriteria>();
        }

        protected override bool RunPassed(
            Dictionary<string, MachineRunResult> machineResults,
            out string explanation)
        {
            bool passed = true;
            StringBuilder sb = new StringBuilder();

            foreach (string testName in m_TestCriteria.Keys)
            {
                bool testFound = false;
                float totalTps = 0;
                TestCriteria criteria = m_TestCriteria[testName];

                foreach (string machineName in machineResults.Keys)
                {
                    MachineRunResult machineResult = machineResults[machineName];
                    TestCaseResult testResult = machineResult.GetTestCaseByName(testName);
                    if (testResult != null)
                    {
                        testFound = true;
                        totalTps += testResult.TotalTps;
                        if (testResult.CountFailed > criteria.MaxFailuresPerClient)
                        {
                            passed = false;
                            sb.Append(testName);
                            sb.Append(": MaxFailuresPerClient exceeded on machine '");
                            sb.Append(machineName);
                            sb.Append("' (actual: ");
                            sb.Append(testResult.CountFailed);
                            sb.Append(" target: ");
                            sb.Append(criteria.MaxFailuresPerClient);
                            sb.AppendLine(")");
                        }
                    }
                }

                if (!testFound)
                {
                    passed = false;
                    sb.Append(testName);
                    sb.AppendLine(": Test case not recorded for any machines.");
                }
                else if (totalTps < criteria.MinAggregateTps)
                {
                    passed = false;
                    sb.Append(testName);
                    sb.Append(": MinTotalTps not reached (actual: ");
                    sb.Append(totalTps);
                    sb.Append(" target: ");
                    sb.Append(criteria.MinAggregateTps);
                    sb.AppendLine(")");
                }
            }

            explanation = sb.ToString();
            return passed;
        }

        protected override void LoadConfigurationFromXml(XmlReader xmlReader)
        {
            const string rootElement = "RunAnalysisConfig";
            const string TestCaseElement = "TestCase";
            const string TestCaseNameAttribute = "name";
            const string MinTpsElement = "MinAggregateTps";
            const string MaxFailuresElement = "MaxFailuresPerClient";

            xmlReader.ReadStartElement(rootElement);
            while (xmlReader.Read())
            {
                if (xmlReader.IsStartElement(TestCaseElement))
                {
                    string testName = xmlReader.GetAttribute(TestCaseNameAttribute);
                    if (String.IsNullOrEmpty(testName))
                    {
                        throw new FormatException(
                            string.Format(
                                "Configuration contains a '{0}' element without a '{1}' attribute.",
                                TestCaseElement,
                                TestCaseNameAttribute));
                    }
                    TestCriteria testCriteria = new TestCriteria();
                    while (xmlReader.Read())
                    {
                        // Read child elements until we hit the end of the TestCase element.
                        //
                        if (xmlReader.NodeType == XmlNodeType.EndElement &&
                            xmlReader.Name.CompareTo(TestCaseElement) == 0)
                        {
                            break;
                        }

                        if (xmlReader.IsStartElement(MinTpsElement))
                        {
                            testCriteria.MinAggregateTps = xmlReader.ReadElementContentAsFloat();
                        }
                        else if (xmlReader.IsStartElement(MaxFailuresElement))
                        {
                            testCriteria.MaxFailuresPerClient = xmlReader.ReadElementContentAsInt();
                        }
                    }

                    m_TestCriteria.Add(testName, testCriteria);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\OrmRawDataTask.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    [Serializable]
    public class OrmRawDataTask : ScheduledTask
    {
        #region Object initialization

        public OrmRawDataTask()
        {
        }

        public OrmRawDataTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void  Initialize()
        {
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(10, PeriodicSchedule.PeriodType.Seconds);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            OrmRawDataTask.Create();
        }

        public static OrmRawDataTask Create()
        {
            OrmRawDataTask task = new OrmRawDataTask();
            task.Initialize();
            return task;
        }

        public static OrmRawDataTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(OrmRawDataTask)));
            if (dt.Length == 0)
                return OrmRawDataTask.Create();
            else
                return (OrmRawDataTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            int cAvailable;
            Run[] runs = Run.GetWithRawDataStatus(Run.RawDataStatus.Requested, 0, 1, out cAvailable);

            if (runs.Length == 1)
            {
                using (SessionRef session = Session.Create())
                {
                    Run run = Run.Get(runs[0].Id);
                    run.RawData = Run.RawDataStatus.FetchingFromDatabase;
                    session.Commit();
                }

                Run.RawDataStatus status = runs[0].GetRawData();

                using (SessionRef session = Session.Create())
                {
                    Run run = Run.Get(runs[0].Id);
                    run.RawData = status;
                    session.Commit();
                }
            }

            // Return value of this function is irrelevant
            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttFilterIncompleteTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;

using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    /// <summary>
    /// This Task calls WTTScheduleManager to determine which Runs have completed. The methods it calls also
    /// perform various finalization actions on Runs that are found to be complete. It does not perform
    /// general cleanup of the Run (as that is handled by the WttRunCleanupTask. This Task does, however, change
    /// non-incomplete Runs' status from Scheduled to Complete or Canceled.
    /// </summary>
    [Serializable]
    public class WttFilterIncompleteTask : ScheduledTask
    {
        #region Object initialization

        public WttFilterIncompleteTask()
        {
        }

        public WttFilterIncompleteTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            int periodInSeconds = 15;
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(periodInSeconds, PeriodicSchedule.PeriodType.Seconds);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttFilterIncompleteTask.Create();
        }

        public static WttFilterIncompleteTask Create()
        {
            WttFilterIncompleteTask task = new WttFilterIncompleteTask();
            task.Initialize();
            return task;
        }

        public static WttFilterIncompleteTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttFilterIncompleteTask)));
            if (dt.Length == 0)
                return WttFilterIncompleteTask.Create();
            else
                return (WttFilterIncompleteTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            OrmRun[] runs = OrmRun.GetScheduled();

            if (runs.Length > 0)
            {
                WTTScheduleManager.FilterIncompleteRuns(runs, new GlobalsAccessor());
            }

            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttCancelingTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;

using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    /// <summary>
    /// This Task cancels those tasks which have been marked for cancellation.
    /// </summary>
    [Serializable]
    public class WttCancelingTask : ScheduledTask
    {
        #region Object initialization

        public WttCancelingTask()
        {
        }

        public WttCancelingTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            int periodInSeconds = 5;
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(periodInSeconds, PeriodicSchedule.PeriodType.Seconds);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttCancelingTask.Create();
        }

        public static WttCancelingTask Create()
        {
            WttCancelingTask task = new WttCancelingTask();
            task.Initialize();
            return task;
        }

        public static WttCancelingTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttSchedulingTask)));
            if (dt.Length == 0)
                return WttCancelingTask.Create();
            else
                return (WttCancelingTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            OrmRun[] runs = OrmRun.GetScheduledAndCancelRequested();
            foreach (OrmRun run in runs)
            {
                using (SessionRef session = Session.Create())
                {
                    // Need to retrieve a new Run that is created by the inner session
                    Guid g = Guid.Empty;
                    OrmRun r = OrmRun.Get(run.Id);
                    try
                    {
                        // This run could have been canceled from the webpage while we iterated through the collection
                        g = r.Lock();
                        if (r.Status != OrmRun.RunStatus.Scheduled || !r.CancelRequested)
                            continue;
                        if (WTTScheduleManager.CancelRun(r, new GlobalsAccessor()))
                        {
                            r.Status = OrmRun.RunStatus.Canceled;
                            r.PendingCleanup = true;
                            session.Commit();
                        }
                    }
                    finally
                    {
                        if (g != Guid.Empty)
                        {
                            r.Unlock(g);
                        }
                    }
                }
            }

            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttRunCleanupTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;

using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    /// <summary>
    /// This task calls the WTTScheduleManager to cleanup after a completed or cancelled Run. Cleanup
    /// includes returning all Resources (machines) to their original pools and deleting the dynamic Run pool.
    /// </summary>
    [Serializable]
    public class WttRunCleanupTask : ScheduledTask
    {
        #region Object initialization

        public WttRunCleanupTask()
        {
        }

        public WttRunCleanupTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            int periodInMinutes = 1;
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(periodInMinutes, PeriodicSchedule.PeriodType.Minutes);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttRunCleanupTask.Create();
        }

        public static WttRunCleanupTask Create()
        {
            WttRunCleanupTask task = new WttRunCleanupTask();
            task.Initialize();
            return task;
        }

        public static WttRunCleanupTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttRunCleanupTask)));
            if (dt.Length == 0)
                return WttRunCleanupTask.Create();
            else
                return (WttRunCleanupTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            // Cleanup completed Runs.
            OrmRun[] completeRuns = OrmRun.GetCompleteAndPendingCleanup();

            for (int i = 0; i < completeRuns.Length; i++)
            {
                WTTScheduleManager.CleanupRun(completeRuns[i], new GlobalsAccessor());
                completeRuns[i].PendingCleanup = false;
            }

            // Cleanup cancelled Runs.
            OrmRun[] cancelledRuns = OrmRun.GetCanceledAndPendingCleanup();

            for (int i = 0; i < cancelledRuns.Length; i++)
            {
                WTTScheduleManager.CleanupRun(cancelledRuns[i], new GlobalsAccessor());
                cancelledRuns[i].PendingCleanup = false;
            }

            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\OrmRunDeletionTask.cs ===
﻿using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    [Serializable]
    public class OrmRunDeletionTask : ScheduledTask
    {
        #region Object initialization

        public OrmRunDeletionTask()
        {
        }

        public OrmRunDeletionTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void  Initialize()
        {
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(5, PeriodicSchedule.PeriodType.Minutes);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            OrmRunDeletionTask.Create();
        }

        public static OrmRunDeletionTask Create()
        {
            OrmRunDeletionTask task = new OrmRunDeletionTask();
            task.Initialize();
            return task;
        }

        public static OrmRunDeletionTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(OrmRunDeletionTask)));
            if (dt.Length == 0)
                return OrmRunDeletionTask.Create();
            else
                return (OrmRunDeletionTask)dt[0];
        }

        #endregion

        #region Task execution

        /// <summary>
        /// Deletes all non-ORM assets for the specified Run. This includes ReportDB information (EventLog and PerfCounter tables)
        /// as well as WTT related resources. For the moment, for WTT, this task only removes the WTTLog folder for the Run.
        /// It does not remove the Result entry from the WTT DB.
        /// </summary>
        /// <param name="run">Run that should have all assets deleted</param>
        private void DeleteRunAssets(Run run, int sqlTimeout)
        {
            // Delete all ReportingDB related information for this Run, if there is any.
            SqlConnectionStringBuilder sqlsb = new SqlConnectionStringBuilder("Application Name=XtsTasks.OrmRunDeletionTask;Connect Timeout=60;Integrated Security=SSPI;Enlist=False;Min Pool Size=1;Max Pool Size=200;Pooling=True;MultipleActiveResultSets=True");
            sqlsb.DataSource = Globals.GetProperty("SqlServerName");
            sqlsb.InitialCatalog = Globals.GetProperty("SqlReportingDb");
            using (SqlConnection conn = new SqlConnection(sqlsb.ConnectionString))
            {
                conn.Open();
                using (SqlTransaction trans = conn.BeginTransaction())
                {
                    try
                    {
                        using (SqlCommand cmd = new SqlCommand())
                        {
                            cmd.CommandText = "[ReportingDb.DeleteForRunId]";
                            cmd.CommandType = System.Data.CommandType.StoredProcedure;
                            cmd.Parameters.AddWithValue("@RunId", run.Id);
                            cmd.Connection = conn;
                            cmd.Transaction = trans;
                            if (sqlTimeout > 0)
                                cmd.CommandTimeout = sqlTimeout;
                            cmd.ExecuteNonQuery();
                        }
                        trans.Commit();
                    }
                    catch (Exception)
                    {
                        trans.Rollback();
                        throw;
                    }
                }
            }

            // Delete the WTTLog folder for this Run
            if (!String.IsNullOrEmpty(run.LogPath) && System.IO.Directory.Exists(run.LogPath))
                System.IO.Directory.Delete(run.LogPath, true);
        }

        protected override object Execute()
        {
            List<int> runIds = new List<int>();
            int sqlTimeout = -1;
            string strTimeout;

            if (Globals.TryGetProperty("ReportingDbSqlTimeout", out strTimeout))
            {
                sqlTimeout = int.Parse(strTimeout);
            }

            foreach (Run run in Run.GetMarkedForDeletion())
            {
                try
                {
                    DeleteRunAssets(run, sqlTimeout);
                    runIds.Add(run.Id);
                }
                catch (Exception e)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendFormat("Exception {0} thrown when deleting assets for run {1}: {2}\r\n", e.GetType().FullName, run.Id, e.Message);
                    sb.Append(e);
                    Logging.LogAlways(LoggingCore.Severity.Warning, null, sb.ToString());
                }
            }

            // Delete only those runs that had its assets successfully deleted
            Run.DeleteWithIds(runIds.ToArray());

            // Return value of this function is irrelevant
            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttOMRefreshTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;
using Microsoft.DistributedAutomation.Asset;

// Aliasing the WTT Job class because it collides with our own Job type
using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    [Serializable]
    public class WttOMRefreshTask : ScheduledTask
    {
        #region Persisted data

        private DateTime m_lastUpdatedTime;

        public DateTime LastUpdatedTime
        {
            get
            {
                return m_lastUpdatedTime;
            }
            set
            {
                BeginEdit();
                // $$avgarcia: Should we check that value >= m_lastUpdateTime?
                m_lastUpdatedTime = value;
                EndEdit();
            }
        }

        #endregion

        #region Object initialization

        public WttOMRefreshTask()
        {
        }

        public WttOMRefreshTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void  Initialize()
        {
            // $$avgarcia: Need to allow this setting to be changed at runtime
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(15, PeriodicSchedule.PeriodType.Seconds);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
                m_lastUpdatedTime = DateTime.MinValue;
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttOMRefreshTask.Create();
        }

        public static WttOMRefreshTask Create()
        {
            WttOMRefreshTask task = new WttOMRefreshTask();
            task.Initialize();
            return task;
        }

        public static WttOMRefreshTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttOMRefreshTask)));
            if (dt.Length == 0)
                return WttOMRefreshTask.Create();
            else
                return (WttOMRefreshTask)dt[0];
        }

        #endregion

        #region Task execution

        bool UpdateJobs()
        {
            bool hadChanges = false;

            // Get from WTT DB the list of all jobs that have been modified since the last update time
            SqlIdentityConnectInfo sqlConnInfo = new SqlIdentityConnectInfo(Globals.GetProperty("WttServerName"), Globals.GetProperty("WttIdentityDS"));
            DataStore ds = Enterprise.Connect(Globals.GetProperty("WttJobsRuntimeDS"), JobsRuntimeDataStore.ServiceName, sqlConnInfo);
            Query query = new Query(typeof(WttJob));
            //$$$avgarcia: Why is WTTOMBase complaining about this expression?!
            //query.AddExpression("JobExecutionTypeId", QueryOperator.Equals, (int)JobExecutionType.Automated);
            JobCollection jobColl = (JobCollection)ds.Query(query);
            List<int> wttJobIds = new List<int>();

            if (jobColl.Count > 0)
            {
                // Saving the WTT collection into a dictionary for fast browsing
                Dictionary<int, WttJob> wttJobs = new Dictionary<int, WttJob>();
                foreach (WttJob wttJob in jobColl)
                {
                    if (wttJob.JobExecutionTypeId == JobExecutionType.Automated)
                    {
                        wttJobIds.Add(wttJob.Id);
                        if (wttJob.LastUpdatedTime.ToUniversalTime() >= LastUpdatedTime)
                            wttJobs[wttJob.Id] = wttJob;
                    }
                }

                if (wttJobs.Count > 0)
                {
                    hadChanges = true;

                    // Get all the ORM jobs that match the retrieved WTT jobs
                    int[] wttIds = new int[wttJobs.Count];
                    wttJobs.Keys.CopyTo(wttIds, 0);

                    int currentWttId = -1;

                    try
                    {
                        // For those ORM jobs that have a matching WTT job, update the info
                        // And delete the ones whose matching WTT job has been deleted
                        OrmJob[] ormJobs = OrmJob.GetWithWttIds(wttIds);
                        foreach (OrmJob ormJob in ormJobs)
                        {
                            currentWttId = ormJob.WttId;
                            ormJob.UpdateFrom(wttJobs[ormJob.WttId]);
                            wttJobs.Remove(ormJob.WttId);
                        }

                        // For any remaining WTT job that has no matching ORM job, create a new one
                        foreach (WttJob wttJob in wttJobs.Values)
                        {
                            currentWttId = wttJob.Id;
                            OrmJob.Create(wttJob);
                        }
                    }
                    catch (Exception e)
                    {
                        throw new WttOMRefreshException(typeof(WttJob), currentWttId, e);
                    }
                }
            }

            OrmJob.DeleteBrokenWttLinks(wttJobIds.ToArray());

            return hadChanges;
        }

        bool UpdateMachines()
        {
            bool hadChanges = false;

            // Resources indexed by [poolpath][resourceId]
            Dictionary<string, Dictionary<int, Resource>> resourcesByPoolName = new Dictionary<string, Dictionary<int, Resource>>();

            XmlDataDocument mappingXml = new XmlDataDocument();
            mappingXml.LoadXml(Globals.GetProperty("EnvironmentPoolMappingXml"));

            XmlElement environmentsXml = mappingXml.GetElementsByTagName("Environments")[0] as XmlElement;
            foreach (XmlElement environmentXml in environmentsXml.GetElementsByTagName("Environment"))
            {
                foreach (XmlElement roleXml in environmentXml.GetElementsByTagName("Role"))
                {
                    string poolPath = roleXml.InnerText;

                    resourcesByPoolName.Add(poolPath, new Dictionary<int, Resource>());
                }
                break;
            }

            resourcesByPoolName.Add(Globals.GetProperty("WttRecoveryPoolPath"), new Dictionary<int, Resource>());
            resourcesByPoolName.Add(Globals.GetProperty("WttRunPoolRootPoolPath"), new Dictionary<int, Resource>());

            // Get from WTT DB the list of all jobs that have been modified since the last update time
            SqlIdentityConnectInfo sqlConnInfo = new SqlIdentityConnectInfo(Globals.GetProperty("WttServerName"), Globals.GetProperty("WttIdentityDS"));
            DataStore ds = Enterprise.Connect(Globals.GetProperty("WttJobsRuntimeDS"), JobsRuntimeDataStore.ServiceName, sqlConnInfo);

            List<int> resourceIds = new List<int>();

            foreach (string resourcePoolPath in resourcesByPoolName.Keys)
            {
                Dictionary<int, Resource> resourcesInPool = resourcesByPoolName[resourcePoolPath];
                int lastDelimeterIndex = resourcePoolPath.LastIndexOf('\\');
                string poolPathRoot = resourcePoolPath.Substring(0, lastDelimeterIndex + 1);
                string poolName = resourcePoolPath.Substring(lastDelimeterIndex + 1);

                Query poolQueryActual = new Query(typeof(ResourcePool));
                poolQueryActual.AddColumn("Id");
                poolQueryActual.AddExpression("Name", QueryOperator.Equals, poolName);
                poolQueryActual.AddConjunction(Conjunction.And);
                poolQueryActual.AddExpression("Path", QueryOperator.Equals, poolPathRoot);

                Query poolQueryUnder = new Query(typeof(ResourcePool));
                poolQueryUnder.AddColumn("Id");
                poolQueryUnder.AddExpression("Path", QueryOperator.BeginsWith, resourcePoolPath);

                Query resourceQuery = new Query(typeof(Resource));
                resourceQuery.AddExpression("ResourcePoolId", QueryOperator.Within, poolQueryActual, "ResourcePool.Id");
                resourceQuery.AddConjunction(Conjunction.Or);
                resourceQuery.AddExpression("ResourcePoolId", QueryOperator.Within, poolQueryUnder, "ResourcePool.Id");

                ResourceCollection resources = ds.Query(resourceQuery) as ResourceCollection;

                foreach (Resource resource in resources)
                {
                    resourceIds.Add(resource.Id);
                    if (resource.LastUpdatedTime.ToUniversalTime() >= LastUpdatedTime)
                    {
                        resourcesInPool.Add(resource.Id, resource);
                    }
                }

                if (resourcesInPool.Count > 0)
                {
                    hadChanges = true;

                    // Get all the ORM jobs that match the retrieved WTT jobs
                    int[] wttIds = new int[resourcesInPool.Count];
                    resourcesInPool.Keys.CopyTo(wttIds, 0);

                    int currentWttId = -1;
                    Machine[] machines = Machine.GetWithWttIds(wttIds);

                    try
                    {
                        // For those ORM Machines that have a matching WTT Resource, update the info
                        // And delete the ones whose matching WTT Resource has been deleted
                        foreach (Machine machine in machines)
                        {
                            currentWttId = machine.WttId;
                            machine.UpdateFrom(resourcesInPool[machine.WttId], resourcePoolPath);
                            resourcesInPool.Remove(machine.WttId);
                        }

                        // For any remaining WTT Resource that has no matching ORM Machine, create a new one
                        foreach (Resource resource in resourcesInPool.Values)
                        {
                            currentWttId = resource.Id;
                            Machine.Create(resource, resourcePoolPath);
                        }
                    }
                    catch (Exception e)
                    {
                        throw new WttOMRefreshException(typeof(Resource), currentWttId, e);
                    }
                }
            }

            Machine.DeleteBrokenWttLinks(resourceIds.ToArray());

            return hadChanges;
        }

        protected override object Execute()
        {
            bool hadChanges = false;

            // First, save the time before we start iterating through WTT DB
            DateTime updateTime = DateTime.UtcNow;

            hadChanges |= UpdateMachines();
            hadChanges |= UpdateJobs();

            if (hadChanges)
                LastUpdatedTime = updateTime;

            // Return value of this function is irrelevant
            return null;
        }

        #endregion
    }

    /// <summary>
    /// This Exception is thrown when there is an error updating an OrmJob based on a WttJob.
    /// </summary>
    public class WttOMRefreshException : Exception
    {
        public WttOMRefreshException(Type wttType, int wttJobId, Exception innerException)
            : base(String.Format("There was an error updating {0} with WTT Id {1}.{2}   The Exception was {3}: {4}{5}   Please inspect and fix this Job in WTT Studio as soon as possible.{6}InnerException Stack:{7}{8}",
                wttType.Name, wttJobId, Environment.NewLine, innerException.GetType().Name, innerException.Message, Environment.NewLine, Environment.NewLine, Environment.NewLine, innerException.StackTrace))
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttSchedulingTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;

using Resource = Microsoft.DistributedAutomation.Asset.Resource;
using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    /// <summary>
    /// Calls the WTTScheduleManager to attempt to schedule Runs that are in the queue.
    /// </summary>
    [Serializable]
    public class WttSchedulingTask : ScheduledTask
    {
        #region Object initialization

        public WttSchedulingTask()
        {
        }

        public WttSchedulingTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            int periodInSeconds = 15;
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(periodInSeconds, PeriodicSchedule.PeriodType.Seconds);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttSchedulingTask.Create();
        }

        public static WttSchedulingTask Create()
        {
            WttSchedulingTask task = new WttSchedulingTask();
            task.Initialize();
            return task;
        }

        public static WttSchedulingTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttSchedulingTask)));
            if (dt.Length == 0)
                return WttSchedulingTask.Create();
            else
                return (WttSchedulingTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            // This session queries unscheduled runs and sends each one to the WTTScheduleManager. If a run is scheduled, then a positive wttResultId
            // is returned and the run is marked with that Id and that it has been scheduled. If a run fails to be scheduled because of insufficient
            // resources, then a non-positive wttResultId will be returned and the run will remain in an unscheduled state. Only one Run will ever
            // be scheduled per execution of this task.
            OrmRun[] runs = OrmRun.GetUnscheduled();
            foreach (OrmRun run in runs)
            {
                using (SessionRef session = Session.Create())
                {
                    // Need to retrieve a new Run that is created by the inner session
                    Guid g = Guid.Empty;
                    OrmRun r = OrmRun.Get(run.Id);
                    try
                    {
                        // This run could have been canceled from the webpage while we iterated through the collection
                        g = r.Lock();
                        if (r.Status != OrmRun.RunStatus.Unscheduled)
                            continue;
                        List<Resource> runResources = null;
                        int wttResultId = WTTScheduleManager.ScheduleRun(r, new GlobalsAccessor(), out runResources);
                        if (wttResultId > 0)
                        {
                            r.WttResultId = wttResultId;
                            r.Status = Microsoft.Xna.LiveServer.LS3i.OM.Run.RunStatus.Scheduled;
                            Machine.InsertOrUpdateRunId(runResources, r.Id);
                            // Once we successfully schedule, exit. 
                            break;
                        }
                    }
                    catch (SchedulingException x)
                    {
                        r.Status = Microsoft.Xna.LiveServer.LS3i.OM.Run.RunStatus.Canceled;
                        r.Reason = x.Message;
                    }
                    finally
                    {
                        session.Commit();
                        if (g != Guid.Empty)
                        {
                            r.Unlock(g);
                        }
                    }
                }
            }

            return null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\WttRunCompletionMailTask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Net.Mail;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.ScheduleEngines;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;

using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Jobs;

using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmJob = Microsoft.Xna.LiveServer.LS3i.OM.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.Tasks
{
    /// <summary>
    /// This task checks for completed or cancelled Runs and sends a mail to each one's scheduler.
    /// </summary>
    [Serializable]
    public class WttRunCompletionMailTask : ScheduledTask
    {
        #region Object initialization

        public WttRunCompletionMailTask()
        {
        }

        public WttRunCompletionMailTask(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public override void Initialize()
        {
            int periodInMinutes = 1;
            PeriodicSchedule.SPeriod period = new PeriodicSchedule.SPeriod(periodInMinutes, PeriodicSchedule.PeriodType.Minutes);
            PeriodicSchedule schedule = PeriodicSchedule.Create(DateTime.UtcNow, period);
            BeginEdit();
            {
                base.Initialize(StateEnum.Pending, DateTime.UtcNow, schedule);
            }
            EndEdit();
        }

        #endregion

        #region Static fields and methods

        [OnDatabaseInstall]
        public static void InstallTask(DatabaseInstallParams installParams)
        {
            WttRunCompletionMailTask.Create();
        }

        public static WttRunCompletionMailTask Create()
        {
            WttRunCompletionMailTask task = new WttRunCompletionMailTask();
            task.Initialize();
            return task;
        }

        public static WttRunCompletionMailTask Get()
        {
            // $$avgarcia: Is this logic even necessary? OnDatabaseInstall ensures that one (and only one) instance is saved to the DB.
            DistributedTask[] dt = DistributedTask.GetTasksByType(SystemType.Get(typeof(WttRunCompletionMailTask)));
            if (dt.Length == 0)
                return WttRunCompletionMailTask.Create();
            else
                return (WttRunCompletionMailTask)dt[0];
        }

        #endregion

        #region Task execution

        protected override object Execute()
        {
            // Send mails for Complete Runs who have not already had a mail sent.
            OrmRun[] completeRuns = OrmRun.GetCompleteAndNoMailSent();

            for (int i = 0; i < completeRuns.Length; i++)
            {
                if (!completeRuns[i].MailSent && !completeRuns[i].PendingCleanup)
                {
                    SendMail(completeRuns[i]);
                    completeRuns[i].MailSent = true;
                }
            }

            // Send mails for Cancelled Runs who have not already had a mail sent.
            OrmRun[] cancelledRuns = OrmRun.GetCanceledAndNoMailSent();

            for (int i = 0; i < cancelledRuns.Length; i++)
            {
                if (!cancelledRuns[i].MailSent && !cancelledRuns[i].PendingCleanup)
                {
                    SendMail(cancelledRuns[i]);
                    cancelledRuns[i].MailSent = true;
                }
            }

            return null;
        }

        /// <summary>
        /// Sends a status mail for a completed or cancelled Run.
        /// </summary>
        /// <param name="run">the Run for which to send out a mail</param>
        private void SendMail(OrmRun run)
        {
            MailMessage mail = new MailMessage();
            mail.To.Add(run.SchedulerAlias + "@microsoft.com");
            string mailStatusSendToAddress;
            if (Globals.TryGetProperty("MailStatusSendToAddress", out mailStatusSendToAddress))
            {
                // This can be a comma-separated list of addresses
                foreach (string address in mailStatusSendToAddress.Split(','))
                {
                    mail.To.Add(address);
                }
            }
            mail.From = new MailAddress(Globals.GetProperty("MailSenderAddress"));
            mail.Subject = String.Format("Run {0} '{1}' has {2}.", run.Id, run.Name,
                (run.Status == Microsoft.Xna.LiveServer.LS3i.OM.Run.RunStatus.Complete) ? "completed" : "been cancelled");

            StringBuilder body = new StringBuilder();
            body.AppendFormat("Name: {0}", run.Name);
            body.AppendLine();
            body.AppendFormat("Status: {0}", run.Status.ToString());
            body.AppendLine();
            body.AppendFormat("Result: {0}", run.Result.ToString());
            body.AppendLine();
            body.AppendFormat("Build: {0}", run.BuildName);
            body.AppendLine();
            body.AppendFormat("Scheduled On: {0} (Coordinated Universal Time)", run.ScheduleTime.ToUniversalTime().ToString());
            body.AppendLine();
            body.AppendLine();
            body.AppendFormat("Click here to see more details: http://{0}/pages.server/Run.aspx?runid={1}", Globals.GetProperty("IISServerName"), run.Id);

            mail.Body = body.ToString();

            SmtpClient client = new SmtpClient(Globals.GetProperty("SmtpHostName"));
            client.UseDefaultCredentials = true;
            client.Send(mail);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_none_12.4.56.0_none_2da2ad5f8b031bce
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.tasks
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.tasks,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\makefile.inc ===
WTTOM:
    xcopy /i /y $(WTT_PATH)\WTTOM* $(XNALS_DROP)\App\Services\Bin && \
    xcopy /i /y $(WTT_PATH)\WTTOM* $(XNALS_DROP)\App\Pages\Bin && \
    xcopy /i /y $(WTT_PATH)\WTTOM* $(XNALS_DROP)\App\Tasks\Bin && \
    xcopy /i /y $(WTT_PATH)\WTTOM* $(XNALS_DROP)\App\Utility\Bin
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Tasks\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_none_12.4.56.0_none_2da2ad5f8b031bce
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.tasks
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.tasks_no-public-key_12.4.56.0_x-ww_0aad8c9c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.tasks,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_none_12.4.56.0_none_dce7ac88226b01d1
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.wtt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.wtt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_none_12.4.56.0_none_dce7ac88226b01d1
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.wtt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.wtt_no-public-key_12.4.56.0_x-ww_ec850105
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.wtt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\WttHelper.cs ===
﻿//--------------------------------------------------------------
// <copyright file="WttHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// <summary>
// Helper class for working around design issues of WTT
// </summary>
//--------------------------------------------------------------

namespace Microsoft.Xna.LiveServer.LS3i.WTT
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Reflection;
    using System.Data.SqlClient;


    using Microsoft.DistributedAutomation;
    using Microsoft.DistributedAutomation.Provider.Sql;
    using System.Text.RegularExpressions;
    //using Microsoft.Win32;
    using Microsoft.DistributedAutomation.Jobs;

    /// <summary>
    /// Helper class for working around design issues of WTT
    /// </summary>
    internal static class WttHelper
    {
        #region Private Data

        private static Dictionary<Type, Dictionary<string, int>> fieldLookup = new Dictionary<Type, Dictionary<string, int>>();

        #endregion // Private Data

        #region Public Members

        /// <summary>
        /// Adds a Join to the specifed query
        /// </summary>
        /// <param name="query">Query to add the join to</param>
        /// <param name="objectType">wtt object type to join</param>
        /// <param name="joinType">type of the join</param>
        /// <param name="column1">fully qualified name of the first column in the join</param>
        /// <param name="column2">fully qualified name of the second column in the join</param>
        /// <returns>a QueryObject for the join</returns>
        public static QueryObject AddJoin(Query query, Type objectType, JoinType joinType, string column1, string column2)
        {
            QueryObject join = new QueryObject(objectType, joinType);
            join.JoinStatement = new QueryStatement(StatementType.Join);
            join.JoinStatement.AddExpression(column1, QueryOperator.Equals, "@" + column2);

            //HACK: WTT Query requires you to fully qualify column names when using joins but does
            //      does not allow fully qualified names when not using joins
            //      so when the first join is added we need to fully qualify all the existing expressions
            if (query.ObjectList.Count == 1)
                FullyQualifyQueryExpressions(query.PrimaryObject.Name, query.DefaultStatement.QueryElementList);

            query.ObjectList.Add(join);
            return join;
        }

        /// <summary>
        /// Adds a wtt query expression to the query including a conjunction if needed
        /// </summary>
        /// <param name="query">the wtt query to add the expression to</param>
        /// <param name="conjunction">the conjunction to use if needed</param>
        /// <param name="expression">the query expression to add </param>
        public static void AddExpression(Query query, Conjunction conjunction, object expression)
        {
            AddExpression(query.DefaultStatement.QueryElementList, conjunction, expression);
        }

        /// <summary>
        /// Adds a wtt query expression to the elmenet list including a conjunction if needed
        /// </summary>
        /// <param name="wttElementList">the wtt query element list to add the expression to</param>
        /// <param name="conjunction">the conjunction to use if needed</param>
        /// <param name="expression">the query expression to add </param>
        public static void AddExpression(IList wttElementList, Conjunction conjunction, object expression)
        {
            //Add the conjunction if the element list already has expressions
            if (wttElementList.Count > 0)
                wttElementList.Add(new QueryExpressionConjunction(conjunction));

            //add the expression
            wttElementList.Add(expression);
        }

        /// <summary>
        /// Adds a WTT Expression based
        /// </summary>
        /// <param name="query">WTT Query to add an expression to</param>        
        /// <param name="dataObjects">List of IPersistable objects</param>
        /// <param name="innerQuery">The inner query which if run would return the list of dataobjects</param>
        /// <param name="columnName">the column the expression applies to</param>
        /// <param name="innerColumnName">the column to select in the inner query</param>
        public static void AddExpression(Query query, IList dataObjects, Query innerQuery, string columnName, string innerColumnName)
        {
            //Add the conjunction if the element list already has expressions
            if ((dataObjects == null) && (innerQuery == null))
                throw new ArgumentNullException("dataObjects and innQuery cannot be null");

            query.AddExpression(columnName, QueryOperator.Within, innerQuery, innerColumnName);
        }

        /// <summary>
        /// Gets the WTT Field object from any datastore object
        /// </summary>
        /// <param name="fieldName">Name of the field you want</param>
        /// <param name="targetObject">Target datastore object to retrieve field from</param>
        /// <returns>The field specified field on the datastore object</returns>
        public static Field GetFieldFromName(string fieldName, DataStoreObject targetObject)
        {
            if (fieldName == null)
                throw new ArgumentNullException("fieldName");
            if (targetObject == null)
                throw new ArgumentNullException("targetObject");

            Type targetType = targetObject.GetType();
            //Index the fields in the object
            if (fieldLookup.Count == 0 || fieldLookup.ContainsKey(targetType) == false)
            {
                fieldLookup.Add(targetType, new Dictionary<string, int>());

                int i = 0;
                foreach (Field field in targetObject.Attributes.GetValueFields())
                {
                    fieldLookup[targetType].Add(field.Name, i);
                    i++;
                }
            }
            if (fieldLookup.ContainsKey(targetType) && fieldLookup[targetType].ContainsKey(fieldName))
                return ((DataStoreObject)targetObject).Attributes.GetValueFields()[fieldLookup[targetType][fieldName]];
            else
                return null;
        }

        /// <summary>
        /// Validates a field value doesn't have invalid characters
        /// </summary>
        /// <param name="fieldName"></param>
        /// <param name="target"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static string EnsureValidValueForField(string fieldName, DataStoreObject target, string value)
        {
            //HACK: implement input validation correctly
            //Just strip invalid chars from string
            Field propField = WttHelper.GetFieldFromName(fieldName, target);
            string regEx = propField.RegularExpression;
            if (!String.IsNullOrEmpty(regEx))
                value = Regex.Replace(value, regEx, " ");
            if ((propField.MaxLength > 0) && (value.Length > propField.MaxLength))
                value = value.Substring(0, propField.MaxLength);

            return value;
        }

        /// <summary>
        /// Get the index containing the provided dimensionId.
        /// </summary>
        /// <param name="job">WTT Job object to find the dimension on.</param>
        /// <param name="dimensionId">(string)dimensionId of the Dimension to find.</param>
        /// <returns>(int) index of the Dimension.</returns>
        public static int FindConstraint(Job job, int dimensionId)
        {
            int returnConstraint = -1;

            if (job != null)
            {
                for (int i = 0; i < job.CommonContext.ConstraintCollection.Count; i++)
                {
                    if (job.CommonContext.ConstraintCollection[i].DimensionId == dimensionId)
                    {
                        returnConstraint = i;
                        break;
                    }
                }
            }

            return returnConstraint;
        }

        /// <summary>
        /// Get the index containing the provided parameterId.
        /// </summary>
        /// <param name="job">WTT Job object to find the parameter on.</param>
        /// <param name="parameterId">parameterId of the Parameter to find.</param>
        /// <returns>(int) index of the Dimension.</returns>
        public static int FindGlobalParameter(Job job, int parameterId)
        {
            int returnParameter = -1;

            if (job != null)
            {
                for (int i = 0; i < job.CommonContext.ParameterCollection.Count; i++)
                {
                    if (job.CommonContext.ParameterCollection[i].Id == parameterId)
                    {
                        returnParameter = i;
                        break;
                    }
                }
            }

            return returnParameter;
        }

        #endregion // Public Members

        #region Private Members

        /// <summary>
        /// This is a recursive function that ensure that all expressions for a query have fully qualified column names (Table.Field)
        /// </summary>
        /// <param name="nameQualifier"></param>
        /// <param name="expressionList"></param>
        private static void FullyQualifyQueryExpressions(string nameQualifier, ArrayList expressionList)
        {
            foreach (object exp in expressionList)
            {
                QueryExpression queryExp = exp as QueryExpression;
                QueryExpressionGroup groupExp = exp as QueryExpressionGroup;
                if (queryExp != null && !queryExp.Reference.Contains("."))
                    queryExp.Reference = nameQualifier + "." + queryExp.Reference;
                else if (groupExp != null)
                    FullyQualifyQueryExpressions(nameQualifier, groupExp.ElementList);
            }
        }

        #endregion // Private Members
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\WTTScheduleManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.LiveServer.LS3i.OM;

using Resource = Microsoft.DistributedAutomation.Asset.Resource;
using WttRun = Microsoft.DistributedAutomation.Jobs.Run;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.WTT
{
    public static class WTTScheduleManager
    {
        /// <summary>
        /// Attempt to schedule a Run in WTT. 
        /// </summary>
        /// <param name="run">the Run to attempt to schedule</param>
        /// <param name="globals">the Globals object from which to draw global parameters</param>
        /// <param name="runResources">output list of Resources that were assigned to this run's pool</param>
        /// <returns>the WTT Result Id if the Run was scheduled, or -1 if not</returns>
        public static int ScheduleRun(OrmRun run, IGlobalsAccessor globals, out List<Resource> runResources)
        {
            WTTOMBroker wtt = new WTTOMBroker(globals);
            try
            {
                return wtt.ScheduleRun(run, out runResources);
            }
            catch (InsufficientResourcesException)
            {
                runResources = null;
                return -1;
            }
        }

        /// <summary>
        /// Attempt to cancel a Run in WTT. 
        /// </summary>
        /// <param name="run">the Run to attempt to cancel</param>
        /// <param name="globals">the Globals object from which to draw global parameters</param>
        public static bool CancelRun(OrmRun run, IGlobalsAccessor globals)
        {
            WTTOMBroker wtt = new WTTOMBroker(globals);
            return wtt.CancelRun(run);
        }

        /// <summary>
        /// Query the WTT database to figure out which of the given runs are complete. Complete runs are returned in an array.
        /// </summary>
        /// <param name="runs">the collection of runs on which to filter</param>
        /// <returns>the collection of runs which were not incomplete</returns>
        public static OrmRun[] FilterIncompleteRuns(OrmRun[] runs, IGlobalsAccessor globals)
        {
            WTTOMBroker wtt = new WTTOMBroker(globals);
            return wtt.FilterIncompleteRuns(runs);
        }

        /// <summary>
        /// Cleanup a Run that has completed execution. This returns all machines which were allocated to this Run to their original
        /// pools (or to the Recovery pool if they are in a not-Ready state). It also deletes the Run pool and the Run file share folder.
        /// </summary>
        /// <param name="run">the Run which needs to be cleaned up</param>
        public static void CleanupRun(OrmRun run, IGlobalsAccessor globals)
        {
            WTTOMBroker wtt = new WTTOMBroker(globals);
            wtt.CleanupRun(run);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\blank.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Blank page class. Copy for use in a new page.
    /// </summary>
    public class BlankPage : BasePage
    {
        
        #region events
        /// <summary>
        /// Page_Load event handler
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            
        }

        /// <summary>
        /// On Init event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }

        #endregion

        /// <summary>
        /// IntializeComponent method called from OnInit()
        /// </summary>
        private void InitializeComponent()
        {
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\download.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.IO;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Download page. Inherits Live Server Admin Pages BasePage class.
    /// </summary>
    public class DownloadPage : BasePage
    {
        #region events
        
        /// <summary>
        /// Page Load event handler. Gets key values off the query string, looks up file and fills response stream with file data
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            int runId = -1;
            string fileName = null;
            FileData file = null;

            switch (WebUtilities.GetParam(HttpContext.Current, "filetype", true, false, String.Empty).ToLower())
            {
                case "runparam":
                    runId = WebUtilities.GetParam(HttpContext.Current, "configid", true, false, 0);
                    fileName = WebUtilities.GetParam(HttpContext.Current, "fileid", true, false, false, String.Empty);
                    if (runId > 0 && !String.IsNullOrEmpty(fileName))
                    {
                        Run run = Run.Get(runId);
                        if (run.RunConfigData.FileValues.ContainsKey(fileName))
                        {
                            file = run.RunConfigData.FileValues[fileName];
                            if (file.Size <= 0)
                            {
                                file = null;
                            }
                        }
                    }
                    break;

                case "runconfigparam":
                    int configId = WebUtilities.GetParam(HttpContext.Current, "configid", true, false, 0);
                    fileName = WebUtilities.GetParam(HttpContext.Current, "fileid", true, false, false, String.Empty);
                    if (configId > 0 && !String.IsNullOrEmpty(fileName))
                    {
                        RunConfig config = RunConfig.Get(configId);
                        if (config.RunConfigData.FileValues.ContainsKey(fileName))
                        {
                            file = config.RunConfigData.FileValues[fileName];
                            if (file.Size <= 0)
                            {
                                file = null;
                            }
                        }
                    }
                    break;

            }

            if (file != null)
            {
                Response.AddHeader("Content-disposition", "attachment; filename=" + file.Name);
                Response.ContentType = "application/octet-stream";
                Response.BinaryWrite(file.Data);
                Response.End();
            }
            else
            {
                Response.Write("File not specified or not found");
            }
        }

        /// <summary>
        /// OnInit Event handler.
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }

        #endregion
        
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\default.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Default page. Inherits Live Server Admin Pages BasePage
    /// </summary>
    public class _Default : BasePage
    {
        /// <summary>
        /// Button for submitting search
        /// </summary>
        protected Button        goButton;

        /// <summary>
        /// GridView for search results
        /// </summary>
        protected GridView      findRunConfigGridView;

        /// <summary>
        /// GridView for "My Run Configs" results
        /// </summary>
        protected GridView      myRunConfigsGridView;

        /// <summary>
        /// GridView for "My Recent Runs" results
        /// </summary>
        protected GridView      myRecentRunsGridView;

        /// <summary>
        /// Row in primary table that contains the search results repeater
        /// </summary>
        protected HtmlTableRow findRunConfigRow;

        /// <summary>
        /// Row in the primary table that contains the My RunConfigs repeater
        /// </summary>
        protected HtmlTableRow myRunConfigsRow;

        /// <summary>
        /// Row in the primary table that contains the myRecentRuns repeater
        /// </summary>
        protected HtmlTableRow myRecentRunsRow;

        /// <summary>
        /// Parent container for most of the page. 
        /// Used for setting the DefaultButton to [Enter] for the page since we don't have a pointer to the page container.
        /// </summary>
        protected Panel         defaultPanel;

        /// <summary>
        /// Search text input.
        /// </summary>
        protected TextBox       findText;
            
        /// <summary>
        /// OnInit event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            base.OnInit(e);
            InitializeComponent();
        }

        /// <summary>
        /// Gets the default page size for search results.
        /// </summary>
        protected int FindRunConfigPageSize
        {
            get
            {
                string property;
                if (Globals.TryGetProperty("WebpageFindRunConfigsPageSize", out property))
                {
                    return int.Parse(property);
                }
                else
                {
                    return 10;
                }
            }
        }

        /// <summary>
        /// Gets the default page size for recent runs
        /// </summary>
        protected int FindRecentRunConfigPageSize
        {
            get
            {
                string property;
                if (Globals.TryGetProperty("WebpageRecentRunsCount", out property))
                {
                    return int.Parse(property);
                }
                else
                {
                    return 10;
                }
            }
        }

        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// Used here to setup event handlers for the search button and the defaultButton for the <c>defaultPanel</c> as well as 
        /// default page sizes and DataBound event handlers for the MyRunCOnfigs, myRecentRuns and findRunConfig GridViews.
        /// </summary>
        private void InitializeComponent()
        {
            this.goButton.Click += new System.EventHandler(this.GoButton_Click);
            this.defaultPanel.DefaultButton = "goButton";

            myRunConfigsGridView.DataBound += MyRunConfigsGridView_DataBound;
            myRecentRunsGridView.DataBound += MyRecentRunsGridView_DataBound;
            findRunConfigGridView.PageSize = FindRunConfigPageSize;
            myRecentRunsGridView.PageSize = FindRecentRunConfigPageSize;
        }

        /// <summary>
        /// Eventhandler for search "Go" button.
        /// </summary>
        /// <param name="o"></param>
        /// <param name="e"></param>
        protected void GoButton_Click(object o, EventArgs e)
        {
            this.findRunConfigRow.Visible = true;
        }

        /// <summary>
        /// DataBound event handler for the My Run Configs gridView. 
        /// Sets visibility if the gridView contains results.
        /// </summary>
        /// <param name="o"></param>
        /// <param name="e"></param>
        protected void MyRunConfigsGridView_DataBound(object o, EventArgs e)
        {
            myRunConfigsRow.Visible = myRunConfigsGridView.Rows.Count > 0;
        }

        /// <summary>
        /// DataBound event handler for the My Recent Runs gridView
        /// Sets visibility if hte gridView contains results.
        /// </summary>
        /// <param name="o"></param>
        /// <param name="e"></param>
        protected void MyRecentRunsGridView_DataBound(object o, EventArgs e)
        {
            myRecentRunsRow.Visible = myRecentRunsGridView.Rows.Count > 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\chart.ascx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;

using Dundas.Charting.WebControl;



namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    public class chart : Microsoft.Xna.LiveServer.WebPages.UserControl
    {
        /// <summary>
        /// Instance of Dundas chart object
        /// </summary>
        private Chart m_chart;

        /// <summary>
        /// Chart height 
        /// </summary>
        private int m_chartHeight;

        /// <summary>
        /// Gets or sets the height of the chart.
        /// </summary>
        public int ChartHeight
        {
            get
            {
                return m_chartHeight;
            }

            set
            {
                m_chartHeight = value;
            }
        }

        /// <summary>
        /// Chart width 
        /// </summary>
        private int m_chartWidth;

        /// <summary>
        /// Gets or sets chart width
        /// </summary>
        public int ChartWidth
        {
            get
            {
                return m_chartWidth;
            }

            set 
            {
                m_chartWidth = value;
            }
        }

        /// <summary>
        /// Title of chart.
        /// </summary>
        private string m_Title;

        /// <summary>
        /// Gets or sets chart title
        /// </summary>
        public string Title
        {
            get
            {
                return m_Title;
            }

            set
            {
                m_Title = value;
            }
        }

        /// <summary>
        /// chart background color
        /// </summary>
        private Color m_backColor;

        /// <summary>
        /// Gets or sets chart background color
        /// </summary>
        public Color BackColor
        {
            get
            {
                return m_backColor;
            }

            set
            {
                m_backColor = value;
            }
        }

        /// <summary>
        /// categories for the chart
        /// </summary>
        private IEnumerable<string> m_categories;

        /// <summary>
        /// Gets or sets a set of categories for the chart
        /// </summary>
        public IEnumerable<string> Categories
        {
            get
            {
                return m_categories;
            }

            set
            {
                m_categories = value;
            }
        }

        /// <summary>
        /// Contains the chart type (i.e. line, bar, etc) and associated value collection
        /// </summary>
        private struct ChartTypeWithValues
        {
            /// <summary>
            /// The chart type (i.e. line, bar, etc) for this value collection
            /// </summary>
            public SeriesChartType ChartType;

            /// <summary>
            /// The associated value collection
            /// </summary>
            public IEnumerable<int> Values;
        }

        /// <summary>
        /// A collection of <c>ChartTypeWithValues</c> for this chart 
        /// </summary>
        private Dictionary<string, ChartTypeWithValues> m_values;
        
        /// <summary>
        /// Adds a value collection to <c>m_values</c>
        /// </summary>
        /// <param name="name">The name of this series that will be shown in the legend</param>
        /// <param name="chartType">The type of chart to associate with this series (i.e. line, bar, etc)</param>
        /// <param name="vals">The collection of values to use as data points</param>
        public void AddValueCollection(string name, SeriesChartType chartType, IEnumerable<int> vals)
        {
            if (m_values == null)
            {
                m_values = new Dictionary<string, ChartTypeWithValues>();
            }

            ChartTypeWithValues toAdd;
            toAdd.ChartType = chartType;
            toAdd.Values = vals;

            if (m_values.ContainsKey(name))
            {
                m_values[name] = toAdd;
            }
            else
            {
                m_values.Add(name, toAdd);
            }
        }

        /// <summary>
        /// The parent page for this chart. Needed for OnRender method.
        /// </summary>
        private Page m_ParentPage;

        /// <summary>
        /// Gets or Sets a referance to the parent page for this chart. The parent page is needed for the OnRener method.
        /// </summary>
        public Page ParentPage
        {
            get
            {
                return m_ParentPage;
            }

            set
            {
                m_ParentPage = value;
            }
        }

        /// <summary>
        /// PageLoad event handler
        /// Sets up the chart based on previously set values, intializes the chart and adds all series in <c>m_values</c> to the chart.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            string chartAreaName = "Default Chart Area";
            m_chart = new Chart();
            m_chart.Width = Unit.Pixel(this.m_chartWidth);
            m_chart.Height = Unit.Pixel(this.m_chartHeight);
            m_chart.Title = m_Title;
            m_chart.ChartAreas.Add(chartAreaName);
            m_chart.ChartAreas[chartAreaName].BackColor = m_backColor;
            
                        
            foreach (string key in this.m_values.Keys)
            {
                m_chart.Series.Add(key);
                m_chart.Series[key].Type = m_values[key].ChartType;
                m_chart.Series[key].Points.DataBindXY(m_categories, m_values[key].Values);
            }

            m_chart.Page = m_ParentPage;
        }

        /// <summary>
        /// OnInit event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }

        /// <summary>
        /// Overloads the Render method and actually writes the chart to the response stream.
        /// </summary>
        /// <param name="writer"></param>
        protected override void Render(HtmlTextWriter writer)
        {
            m_chart.RenderControl(writer);
            writer.Write("<BR><BR>");
        }

        /// <summary>
        /// IntializeComponent called from <c>OnInit</c> event
        /// </summary>
        private void InitializeComponent()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WTTScheduleManager")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("WTTScheduleManager")]
[assembly: AssemblyCopyright("Copyright © MS 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9bbb0c77-08ca-443a-860c-213e88f11440")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\grid.ascx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.OM.Results;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Grid class wraps a datagrid. Used on the Run.aspx page to display results. 
    /// Inherits the Live Server Admin Pages UserControl
    /// </summary>
    public class grid : Microsoft.Xna.LiveServer.WebPages.UserControl
    {
        /// <summary>
        /// The data grid used to display resluts
        /// </summary>
        protected DataGrid resultsGrid;

        /// <summary>
        /// The data we will use to display
        /// </summary>
        private object m_Data;

        /// <summary>
        /// Gets or sets the object used to generate the display.
        /// Currently only an array of <c>RunResults</c> is accepted.
        /// </summary>
        public object Data
        {
            get
            {
                return m_Data;
            }

            set
            {
                m_Data = value;
            }
        }
        
        /// <summary>
        /// PageLoad event handler. Loads the Data into a Datatable and binds that to the DataGrid.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            if (m_Data != null && !IsPostBack)
            {
                DataTable dt = GetDataTable();

                if (dt != null && dt.Rows.Count > 0)
                {
                    resultsGrid.DataSource = GetView(dt, String.Empty);
                    resultsGrid.DataBind();
                }
            }
        }

        /// <summary>
        /// OnInit event handler.
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }

        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {   
        }

        /// <summary>
        /// SortCommand event handler for the grid.
        /// Implements sorting by processing the DataTable with a different sort string.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void resultsGrid_SortCommand(object source, DataGridSortCommandEventArgs e)
        {
            string sortExp;
            string testString = (Session["SortString"] != null) ? (string)Session["SortString"] : string.Empty;
            
            if ( !string.IsNullOrEmpty(testString) && 
                testString.ToUpper().Contains(e.SortExpression.ToUpper()) && 
                testString.ToUpper().Contains(" DESC") )
            {
                sortExp = e.SortExpression + " ASC";
            }
            else
            {
                sortExp = e.SortExpression + " DESC";
            }

            if (Session["SortString"] == null)
            {
                Session.Add("SortString", sortExp);
            }
            else
            {
                Session["SortString"] = sortExp;
            }
            
            //We can safely call GetTable on a post back because it existed on Page_Load.
            resultsGrid.DataSource = GetView(GetDataTable(), sortExp);
            resultsGrid.DataBind();
        }

        /// <summary>
        /// Generates a DataView based off the supplied DataTable and sort expression
        /// </summary>
        /// <param name="dt">The DataTable to sort.</param>
        /// <param name="sort">The sort expression to use.</param>
        /// <returns>Sorted DataView</returns>
        private DataView GetView(DataTable dt, string sort)
        {
            DataView dv = new DataView(dt);
            dv.Sort = sort;
            return dv;
        }

        /// <summary>
        /// Creates a DataTable based off of the data in m_Data.
        /// If extending this class to support more types than arrays of RunTotals, change this function.
        /// </summary>
        /// <returns>The generated DataTable</returns>
        private DataTable GetDataTable()
        {
            DataTable dt = null;

            //Handle other boxed types here.
            if (m_Data is RunTotals[])
            {
                dt = InitTable((RunTotals[])m_Data);
            }

            return dt;
        }

        /// <summary>
        /// Generates a DataTable from the supplied array of RunTotals.
        /// </summary>
        /// <param name="totals">An array of RunTotals to populate the table with</param>
        /// <returns>The DataTable</returns>
        private DataTable InitTable(RunTotals[] totals)
        {
            DataTable gridTable = new DataTable("gridTable");

            DataColumn machineCol = new DataColumn();
            DataColumn tpsCol = new DataColumn();
            DataColumn successCol = new DataColumn();
            DataColumn failCol = new DataColumn();
            DataColumn stillCol = new DataColumn();

            machineCol.DataType = System.Type.GetType("System.String");
            machineCol.ColumnName = "Test Case";
            machineCol.AutoIncrement = false;
            machineCol.Unique = true;
            gridTable.Columns.Add(machineCol);

            tpsCol.DataType = System.Type.GetType("System.Decimal");
            tpsCol.ColumnName = "TPS";
            tpsCol.AutoIncrement = false;
            tpsCol.Unique = false;
            gridTable.Columns.Add(tpsCol);

            successCol.DataType = System.Type.GetType("System.Int32");
            successCol.ColumnName = "Passed";
            successCol.AutoIncrement = false;
            successCol.Unique = false;
            gridTable.Columns.Add(successCol);

            failCol.DataType = System.Type.GetType("System.Int32");
            failCol.ColumnName = "Failed";
            failCol.AutoIncrement = false;
            failCol.Unique = false;
            gridTable.Columns.Add(failCol);

            foreach (RunTotals total in totals)
            {
                DataRow r = gridTable.NewRow();
                r["Test Case"] = total.TestCase;
                r["TPS"] = total.TotalTPS;
                r["Passed"] = total.Passed;
                r["Failed"] = total.Failed;
                gridTable.Rows.Add(r);
            }
            gridTable.AcceptChanges();
            return gridTable;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\MachineData.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.OM.Results;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// MachineData page. Inherits Live Server Admin Pages BasePage
    /// Displays machine status for a single stress client machine
    /// </summary>
    public class MachineDataPage : BasePage
    {
        #region UIControlDefs
        /// <summary>
        /// Machine object for current machine
        /// </summary>
        protected Machine machine;

        /// <summary>
        /// Gridview to display machines
        /// </summary>
        protected System.Web.UI.WebControls.GridView gdvMachines;

        /// <summary>
        /// Gridview of stfGui jobs curretnly running
        /// </summary>
        protected System.Web.UI.WebControls.GridView gdvStfGuiJobs;

        /// <summary>
        /// Message Label
        /// </summary>
        protected System.Web.UI.WebControls.Label lblMessage;

        /// <summary>
        /// XmlDataSource for machine data
        /// </summary>
        protected System.Web.UI.WebControls.XmlDataSource dtsMachine;

        /// <summary>
        /// XmlDataSource for jobs
        /// </summary>
        protected System.Web.UI.WebControls.XmlDataSource dtsJobs;
        
        /// <summary>
        /// Message repeater
        /// </summary>
        protected System.Web.UI.WebControls.Repeater rprMessage;

        /// <summary>
        /// XmlDataSource for messages
        /// </summary>
        protected System.Web.UI.WebControls.XmlDataSource dtsMessage;
        #endregion

        #region events

        /// <summary>
        /// PageLoad Event handler. Populates machine based off of querystring value and sets up the XMLDataSourcs
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            int machineId = WebUtilities.GetParam(HttpContext.Current, "machineid", true, true, -1);
            machine = Machine.Get(machineId);

            // setup dtsMachines
            dtsMachine.Data = machine.MonitorData;
            dtsMachine.TransformFile = "./RealTimeUpdate_Machine.xslt";
            dtsMachine.XPath = "Machine";
            dtsMachine.EnableCaching = false;
            dtsMachine.DataBind();

            // Setup dtsJobs
            dtsJobs.Data = machine.MonitorData;
            dtsJobs.XPath = "Monitor/StfGui/Plugins/Plugin[@Name='STFGui.Plugins.StressPlugin']/Jobs/Job";
            dtsJobs.EnableCaching = false;
            dtsJobs.DataBind();

            // Setup dtsMessage
            dtsMessage.Data = machine.MonitorData;
            dtsMessage.XPath = "/Monitor/StfGui/Message";
            dtsMessage.EnableCaching = false;
            dtsMessage.DataBind();
        }

        /// <summary>
        /// OnInit Event handler.
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            base.OnInit(e);

        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\Utility\WTTScheduleManager\WTTOMBroker.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Reflection;
using System.Configuration;
using System.Diagnostics;
using System.Xml;
using Microsoft.DistributedAutomation;
using Microsoft.DistributedAutomation.Asset;
using Microsoft.DistributedAutomation.Jobs;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.Platform.Utils;

using WttJob = Microsoft.DistributedAutomation.Jobs.Job;
using OrmRun = Microsoft.Xna.LiveServer.LS3i.OM.Run;

namespace Microsoft.Xna.LiveServer.LS3i.WTT
{
    /// <summary>
    /// The WTTOMBroker is responsible for communication with WTT in order to schedule Jobs and manipulate WTT objects (like Resources/Machines). 
    /// For most interactions with WTT objects (including querying and updating) it uses the WTTOM. However, for scheduling it calls the 
    /// command-line tool WTTCL.exe, which is installed with WTTStudio.
    /// </summary>
    public class WTTOMBroker
    {
        #region Private Constants

        private const int MAX_POOL_NAME_LENGTH = 128;
        private const int MAX_RESULTSUMMARY_NAME_LENGTH = 128;

        #endregion // Private Constants

        #region Private Data

        private IGlobalsAccessor g = null;
        private JobsDefinitionDataStore jdDataStore = null;
        private JobsRuntimeDataStore jrDataStore = null;
        private Dimension roleDimension = null;
        private ResourcePool runPoolRootPool = null;
        private ResourcePool recoveryPool = null;

        private Microsoft.DistributedAutomation.Provider.Sql.SqlProvider sqlProvider = null;

        #endregion // Private Data

        #region Private On-Demand Properties

        /// <summary>
        /// The DataStore against which all objects will be queried and committed.
        /// The connection is made according to the globals WttServerName, WttIdentityDS, and WttJobsDefinitionDS.
        /// </summary>
        private JobsDefinitionDataStore JDDataStore
        {
            get
            {
                if (jdDataStore == null)
                {
                    SqlIdentityConnectInfo info = new SqlIdentityConnectInfo(g["WttServerName"], g["WttIdentityDS"]);
                    jdDataStore = Enterprise.Connect(g["WttJobsDefinitionDS"], JobsDefinitionDataStore.ServiceName, info) as JobsDefinitionDataStore;
                }

                return jdDataStore;
            }
        }

        /// <summary>
        /// The DataStore used for calls to the method CancelResults. In practice, both JRDataStore and JDDataStore are the same
        /// DataStore, but only JobsRuntimeDataStore contains the CancelResults method. This method tells WTT to abort in-progress
        /// Jobs, even after they have started execution on a WTT client.
        /// The connection is made according to the globals WttServerName, WttIdentityDS, and WttJobsRuntimeDS.
        /// </summary>
        private JobsRuntimeDataStore JRDataStore
        {
            get
            {
                if (jrDataStore == null)
                {
                    SqlIdentityConnectInfo info = new SqlIdentityConnectInfo(g["WttServerName"], g["WttIdentityDS"]);
                    jrDataStore = Enterprise.Connect(g["WttJobsRuntimeDS"], JobsRuntimeDataStore.ServiceName, info) as JobsRuntimeDataStore;
                }

                return jrDataStore;
            }
        }

        /// <summary>
        /// This is used for debugging purposes only. It allows us to turn the contents of a WTT Query object into SQL text
        /// via the call sqlProvider.GetProviderQueryString(query) where query is a WTT Query object. You can use this to inspect
        /// WTT query text generated by the Query object in Visual Studio's Quick Watch or Immediate windows.
        /// </summary>
        private Microsoft.DistributedAutomation.Provider.Sql.SqlProvider SqlProvider
        {
            get
            {
                if (sqlProvider == null)
                {
                    sqlProvider = typeof(DataStore).GetProperty("Provider", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(JDDataStore, null) as Microsoft.DistributedAutomation.Provider.Sql.SqlProvider;
                }

                return sqlProvider;
            }
        }

        /// <summary>
        /// The Dimension used to indicate that a Resource can be used for a particular role (i.e. Server, Client, Monitor).
        /// This is populated according to the global WttRoleDimension.
        /// </summary>
        private Dimension RoleDimension
        {
            get
            {
                if (roleDimension == null)
                {
                    Query dimensionQuery = new Query(typeof(Dimension));
                    dimensionQuery.AddExpression("Name", QueryOperator.Equals, g["WttRoleDimension"]);

                    DimensionCollection dimensions = JDDataStore.Query(dimensionQuery) as DimensionCollection;
                    if (dimensions.Count > 0)
                    {
                        roleDimension = dimensions[0];
                    }
                    else
                    {
                        throw new ConfigurationErrorsException("The RoleDimension with name '" + g["WttRoleDimension"] + "' was not found in the datastore.");
                    }
                }
                return roleDimension;
            }
        }

        /// <summary>
        /// The ResourcePool under which all dynamic Run Pools will be created.
        /// This is populated according to the global WttRunPoolRootPoolPath.
        /// </summary>
        private ResourcePool RunPoolRootPool
        {
            get
            {
                if (runPoolRootPool == null)
                {
                    string pathAndName = g["WttRunPoolRootPoolPath"];
                    ResourcePool pool = GetResourcePoolFromPath(pathAndName);
                    if (pool != null)
                    {
                        runPoolRootPool = pool;
                    }
                    else
                    {
                        throw new ConfigurationErrorsException("The RunPoolRootPool with path '" + pathAndName + "' was not found in the datastore.");
                    }
                }
                return runPoolRootPool;
            }
        }

        /// <summary>
        /// The ResourcePool into which "bad" (Debug, Manual, Unsafe, etc.) Resources will be put during Run Pool cleanup.
        /// This is populated according to the global WttRecoveryPoolPath.
        /// </summary>
        private ResourcePool RecoveryPool
        {
            get
            {
                if (recoveryPool == null)
                {
                    string pathAndName = g["WttRecoveryPoolPath"];
                    int lastDelimeterIndex = pathAndName.LastIndexOf('\\');
                    string path = pathAndName.Substring(0, lastDelimeterIndex + 1);
                    string name = pathAndName.Substring(lastDelimeterIndex + 1);

                    Query poolQuery = new Query(typeof(ResourcePool));
                    WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Path", QueryOperator.Equals, path));
                    WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Name", QueryOperator.Equals, name));

                    ResourcePoolCollection pools = JDDataStore.Query(poolQuery) as ResourcePoolCollection;
                    if (pools.Count > 0)
                    {
                        recoveryPool = pools[0];
                    }
                    else
                    {
                        throw new ConfigurationErrorsException("The RecoveryPool with path '" + pathAndName + "' was not found in the datastore.");
                    }
                }

                return recoveryPool;
            }
        }

        #endregion // Private On-Demand Properties

        #region Public Constructors

        /// <summary>
        /// Creates a new WTTOMBroker which will connect to WTT DataStores according to the settings in globals.
        /// </summary>
        /// <param name="globals">the interface by which to access global parameters</param>
        public WTTOMBroker(IGlobalsAccessor globals)
        {
            g = globals;
        }

        #endregion // Public Constructors

        #region Public Methods

        /// <summary>
        /// Schedule a single Job to a dynamically created Run Pool.  This method handles creating the Run Pool, moving the requested Resources into it
        /// and calling WTTCL to schedule the Run. This method is eventually called by the WttSchedulingTask.
        /// </summary>
        /// <param name="run">the Run to schedule</param>
        /// <param name="runResources">a list containing all of the Resources which have been allocated to this run</param>
        /// <returns>the Id of the WTT Result object representing this Run, or -1 if the schedule was unsuccessful</returns>
        public int ScheduleRun(OrmRun run, out List<Resource> runResources)
        {
            // Query for the pools from which to draw idle client and server resources for the Run
            Dictionary<string, ResourcePool> idlePools = GetIdleResourcePoolsForEnvironment(run);
            ResourcePool idleServerPool = idlePools[g["WttRoleDimension_Value_Server"]];
            ResourcePool idleClientPool = idlePools[g["WttRoleDimension_Value_Client"]];
            int clientsRequested = -1;

            // Load the parameters from the run into a dictionary of name-value pairs, so that these can be passed into
            // WTTCL when the Job is scheduled.
            Dictionary<string, string> jobParameters = GetJobParametersAsStrings(run);
            if (jobParameters.ContainsKey(g["WttNumberOfClientsParameter"]))
            {
                try
                {
                    clientsRequested = Int32.Parse(jobParameters[g["WttNumberOfClientsParameter"]]);
                }
                catch (FormatException) { }
            }

            string resultSummary = null;
            int runPoolId = -1;
            try
            {
                // This function creates a new Run pool and moves clients and servers into it from the idle pools according to the Run.
                string firstClientName = null;
                ResourcePool runPool = MoveMatchingResourcesToRunPool(run.Job.WttId, run.Id, clientsRequested, idleClientPool, idleServerPool, out firstClientName, out runResources);

                // Some Jobs require one--and only one--of the clients to perform special tasks. Thus this function records the name of the first
                // client to be moved into the Run Pool and sets it in the Job's parameters if appropriate.
                if (!String.IsNullOrEmpty(firstClientName))
                {
                    string sitemParameter = g["WttSingleInstanceTaskExecutorMachineParameter"];
                    if (run.Job.HasWttParameter(sitemParameter))
                    {
                        jobParameters.Add(sitemParameter, firstClientName);
                    }

                    string monitorMachineParameter = g["WttMonitorMachineParameter"];
                    if (jobParameters.ContainsKey(monitorMachineParameter))
                    {
                        if (String.IsNullOrEmpty(jobParameters[monitorMachineParameter]))
                        {
                            jobParameters[monitorMachineParameter] = firstClientName;
                        }
                    }
                }

                // This function calls WTTCL.exe to schedule the Run. It returns the name of the ResultSummary
                // object which contains the Result corresponding to the Run that has been scheduled.
                resultSummary = LaunchWTTCLToSchedule(run.Id, run.Name, run.Job.WttId, jobParameters, runPool);
                runPoolId = runPool.Id;
            }
            catch (Exception)
            {
                // If there are any exceptions during scheduling, then if resources were moved to a run pool, return them to their origin pools and delete the run pool.
                ReturnResourcesToOrigin(run);
                DeleteRunPool(run);

                try
                {
                    Directory.Delete(g["WttFileShareRootPath"] + @"\" + g["WttRunPrefix"] + run.Id.ToString(), true);
                }
                catch (DirectoryNotFoundException) { }

                throw;
            }

            // Query for the Result by using the ResultSummaryName acquired when the Run was scheduled.
            Query rsrQuery = new Query(typeof(ResultSummaryResult));
            WttHelper.AddJoin(rsrQuery, typeof(ResultSummary), JoinType.Inner, "ResultSummaryResult.ResultSummaryId", "ResultSummary.Id");
            WttHelper.AddExpression(rsrQuery, Conjunction.And, new QueryExpression("ResultSummary.Name", QueryOperator.Equals, resultSummary));

            ResultSummaryResultCollection rsrCollection = JDDataStore.Query(rsrQuery) as ResultSummaryResultCollection;
            if (rsrCollection.Count > 0)
            {
                return rsrCollection[0].ResultId;
            }
            else
            {
                throw new SchedulingException("Unable to find ResultSummary with Run Id = " + run.Id + ".");
            }
        }

        /// <summary>
        /// Cancels a scheduled result associated with the given run.
        /// </summary>
        /// <param name="run">the Run to cancel</param>
        /// <returns>true if the Run was successfully canceled, false if not</returns>
        public bool CancelRun(OrmRun run)
        {
            if (run.WttResultId > 0)
            {
                Query resultQuery = new Query(typeof(Result));
                resultQuery.AddExpression("Id", QueryOperator.Equals, run.WttResultId);
                ResultCollection results = JDDataStore.Query(resultQuery) as ResultCollection;
                if (results.Count > 0)
                {
                    // This call cancels a Result in WTT, even if the Result is in-progress on a WTT client.
                    JRDataStore.CancelResults(results);
                    results = JDDataStore.Query(resultQuery) as ResultCollection;
                    if (results[0].ResultStatusId == ResultStatus.InProgress)
                    {
                        return false;
                    }
                    else
                    {
                        run.LogPath = results[0].LogLocation;
                        return true;
                    }
                }
                else
                {
                    throw new InvalidOperationException("The result with Id " + run.WttResultId + " does not exist in WTT.");
                }
            }
            else
            {
                throw new InvalidOperationException("The value " + run.WttResultId + " is not a valid result Id.");
            }
        }

        /// <summary>
        /// Return an array of Runs containing all of those from the input array whose status was not Incomplete.
        /// This method is eventually called by the WttFilterIncompleteTask.
        /// </summary>
        /// <param name="runs">the array of Runs to filter</param>
        /// <returns>the filtered array of non-Incomplete Runs</returns>
        public OrmRun[] FilterIncompleteRuns(OrmRun[] runs)
        {
            Dictionary<int, OrmRun> runsByWttResultId = new Dictionary<int, OrmRun>();
            int[] wttResultIds = new int[runs.Length];

            for (int i = 0; i < runs.Length; i++)
            {
                runsByWttResultId.Add(runs[i].WttResultId, runs[i]);
                wttResultIds[i] = runs[i].WttResultId;
            }

            // Query for the results corresponding to the Runs in the array
            Query resultQuery = new Query(typeof(Result));
            WttHelper.AddExpression(resultQuery, Conjunction.And, new QueryExpression("Id", QueryOperator.Within, wttResultIds));
            WttHelper.AddExpression(resultQuery, Conjunction.And, new QueryExpression("ResultStatusId", QueryOperator.NotEquals, (int)ResultStatus.InProgress));

            ResultCollection completeResults = JDDataStore.Query(resultQuery) as ResultCollection;
            List<OrmRun> completeRuns = new List<OrmRun>();

            foreach (Result result in completeResults)
            {
                OrmRun run = runsByWttResultId[result.Id];

                // $$ericvo: This breaks with the pattern established in the other Wtt Tasks, since the WTTOMBroker is directly modifying the OrmRun
                // which means it is assuming that it is being called within a session. Right now this is the most performant way to do this though.
                completeRuns.Add(run);
                run.LogPath = result.LogLocation;
                run.PendingCleanup = true;

                bool updateTestCaseResults = false;

                switch(result.ResultStatusId)
                {
                    case ResultStatus.Completed:
                        run.Status = Microsoft.Xna.LiveServer.LS3i.OM.Run.RunStatus.Complete;
                        run.Result = OrmRun.RunResult.Pass;
                        updateTestCaseResults = true;
                        break;

                    case ResultStatus.Investigate:
                        run.Status = Microsoft.Xna.LiveServer.LS3i.OM.Run.RunStatus.Complete;
                        run.Result = OrmRun.RunResult.Fail;
                        updateTestCaseResults = true;
                        break;

                    case ResultStatus.Cancelled:
                        run.Status = OrmRun.RunStatus.Canceled;
                        if (run.Reason.Length == 0)
                            run.Reason = g["WttCancelReason"];
                        break;
                }

                if (updateTestCaseResults)
                {
                    // The RunAnalyzer tool should have inserted all the rows into TestCaseTotals and GlobalRunResults with
                    // the result GUID as the key. Search fot the GUID and insert the ID of the ORM Run object.
                    Microsoft.Xna.LiveServer.LS3i.OM.Results.TestCaseTotals.SetRunIdForGuid(result.Guid, run.Id);
                    Microsoft.Xna.LiveServer.LS3i.OM.Results.GlobalRunResults.SetRunIdForGuid(result.Guid, run.Id);
                    // Also generate the totals per-run (test case aggregated data) for the run
                    // $$avgarcia: Is there a better place to execute this operation? A new task perhaps?
                    Microsoft.Xna.LiveServer.LS3i.OM.Results.RunTotals.GenerateForRun(run.Id);

                    // Also update the EventLog and PerfData information on the DB
                    SqlConnectionStringBuilder sqlsb = new SqlConnectionStringBuilder("Application Name=XtsTasks.FilterIncompleteRuns;Connect Timeout=60;Integrated Security=SSPI;Enlist=False;Min Pool Size=1;Max Pool Size=200;Pooling=True;MultipleActiveResultSets=True");
                    sqlsb.DataSource = g["SqlServerName"];
                    sqlsb.InitialCatalog = g["SqlReportingDb"];
                    using (SqlConnection conn = new SqlConnection(sqlsb.ConnectionString))
                    {
                        conn.Open();
                        using (SqlTransaction trans = conn.BeginTransaction())
                        {
                            try
                            {
                                using (SqlCommand cmd = new SqlCommand())
                                {
                                    string strTimeout;
                                    if (g.TryGet("ReportingDbSqlTimeout", out strTimeout))
                                        cmd.CommandTimeout = int.Parse(strTimeout);
                                    cmd.CommandText = "[ReportingDb.UpdateWithResultGuid]";
                                    cmd.CommandType = System.Data.CommandType.StoredProcedure;
                                    cmd.Parameters.AddWithValue("@RunId", run.Id);
                                    cmd.Parameters.AddWithValue("@ResultGuid", result.Guid.ToString("D"));
                                    cmd.Connection = conn;
                                    cmd.Transaction = trans;
                                    cmd.ExecuteNonQuery();
                                }
                                trans.Commit();
                            }
                            catch (Exception e)
                            {
                                trans.Rollback();
                                StringBuilder sb = new StringBuilder();
                                sb.AppendFormat("Exception {0} thrown when updating ReportingDB from FilterIncompleteRuns task: {1}\r\n", e.GetType().FullName, e.Message);
                                sb.AppendFormat("Failed to execute [ReportingDb.UpdateWithResultGuid] with parameters @RunId={0}, @ResultGuid={1}\r\n", run.Id, result.Guid.ToString("D"));
                                sb.Append(e);
                                Logging.LogAlways(LoggingCore.Severity.Warning, null, sb.ToString());
                            }
                        }
                    }
                }
            }

            return completeRuns.ToArray();
        }

        /// <summary>
        /// Return machines in a Run pool to their original idle pools and delete the Run pool, for the given Run.
        /// </summary>
        /// <param name="run">the Run to cleanup after</param>
        public void CleanupRun(OrmRun run)
        {
            if (run.Status != OrmRun.RunStatus.Complete && run.Status != OrmRun.RunStatus.Canceled)
                throw new InvalidOperationException("You cannot return machines from a Run Pool whose Run is not complete or canceled.");

            ReturnResourcesToOrigin(run);
            DeleteRunPool(run);

            try
            {
                Directory.Delete(g["WttFileShareRootPath"] + @"\" + g["WttRunPrefix"] + run.Id.ToString(), true);
            }
            catch (DirectoryNotFoundException) { }
        }

        /// <summary>
        /// Change the owner of a machine in WTT.
        /// </summary>
        /// <param name="machineName">Name of the machine.</param>
        /// <param name="userAlias">Alias of a machine.</param>
        /// <param name="status">WTT ResourceStatus. Manual/Reset etc.</param>
        /// <returns>true if success.</returns>
        public bool ChangeMachineOwner(string machineName, string userAlias, ResourceStatus status)
        {
            Resource machine;
            Query queryResource = new Query(typeof(Resource));
            queryResource.AddExpression("Name", QueryOperator.Equals, machineName);

            ResourceCollection mcList = (ResourceCollection)JDDataStore.Query(queryResource, true);

            if (mcList.Count == 0)
            {
                throw new InvalidOperationException("No machine found with the given name.");
            }
            //if you dont want to add user manually, you can do it programmatically. for that:
            //Query for useralias, and see if it exists.
            //If not, create new DSUser and Commit.
            //Change user alias and commit.
            machine = mcList[0];
            machine.CurrentOwnerAlias = userAlias;
            machine.ResourceStatusId = status;
            mcList.CommitToDataStore();
            
            return true;
        }

        /// <summary>
        /// Reserve Machine for a user.
        /// </summary>
        /// <param name="resourceName">Name of a machine.</param>
        /// <param name="userAlias">User Alias.</param>
        /// <returns>success or fail.</returns>
        public bool ReserveResource(string resourceName, string userAlias)
        {
            return ChangeMachineOwner(resourceName, userAlias, ResourceStatus.Manual);
        }

        /// <summary>
        /// Release a reserved machine and return it back to stress user.
        /// </summary>
        /// <param name="resourceName">Name of the machine.</param>
        /// <returns>success or fail.</returns>
        public bool ReleaseResource(string resourceName)
        {
            return ChangeMachineOwner(resourceName, "xblstress", ResourceStatus.Reset);
        }

        #endregion // Public Methods

        #region Private Methods

        /// <summary>
        /// Return a Dictionary of ResourcePools, indexed by role (i.e. Server, StressClient).
        /// Machines will be drawn from these pools in order to satisfy ResourceSet (LMS) requirements
        /// of Job that is being scheduled. For example, an LMS requiring MachineRole = StressClient
        /// will have its machines drawn from the pool tagged with the StressClient role in the
        /// global EnvironmentPoolMappingXml.
        /// </summary>
        /// <param name="run">the Run containing the Environment to use</param>
        /// <returns>Dictionary of ResourcePools indexed by role name</returns>
        private Dictionary<string, ResourcePool> GetIdleResourcePoolsForEnvironment(OrmRun run)
        {
            Dictionary<string, ResourcePool> resourcePools = new Dictionary<string, ResourcePool>();
            try
            {
                XmlDataDocument mappingXml = new XmlDataDocument();
                mappingXml.LoadXml(g["EnvironmentPoolMappingXml"]);

                XmlElement environmentsXml = mappingXml.GetElementsByTagName("Environments")[0] as XmlElement;
                foreach (XmlElement environmentXml in environmentsXml.GetElementsByTagName("Environment"))
                {
                    if (environmentXml.GetAttribute("name").ToLowerInvariant() == run.RunConfigData.Environment.ToLowerInvariant())
                    {
                        foreach (XmlElement roleXml in environmentXml.GetElementsByTagName("Role"))
                        {
                            string poolRole = roleXml.GetAttribute("name");
                            string poolPath = roleXml.InnerText;

                            resourcePools.Add(poolRole, GetResourcePoolFromPath(poolPath));
                        }
                        break;
                    }
                }
            }
            catch (Exception x)
            {
                throw new ConfigurationErrorsException("Error reading XML from EnvironmentMappingXml. See InnerException for details.", x);
            }

            return resourcePools;
        }

        /// <summary>
        /// Retrieves a ResourcePool object from the WTT database, given a path of that pool.
        /// </summary>
        /// <param name="poolPath">the path of the pool to retrieve</param>
        /// <returns>the ResourcePool with the given path</returns>
        private ResourcePool GetResourcePoolFromPath(string poolPath)
        {
            // In WTT, ResourcePools have two fields, Path and Name. Path is a string which includes
            // all of the ancestor pools (ending with a \) and Name is a string containing the real
            // name of the pool. Thus if MyPool exists in $\UserPools\MyPool, its Path will be "$\UserPools\"
            // and its Name will be "MyPool." The function takes the full path "$\UserPools\MyPool" which
            // is broken up into Path and Name below.
            int lastDelimeterIndex = poolPath.LastIndexOf('\\');
            string path = poolPath.Substring(0, lastDelimeterIndex + 1);
            string name = poolPath.Substring(lastDelimeterIndex + 1);

            Query poolQuery = new Query(typeof(ResourcePool));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Path", QueryOperator.Equals, path));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Name", QueryOperator.Equals, name));

            ResourcePoolCollection pools = JDDataStore.Query(poolQuery) as ResourcePoolCollection;
            if (pools.Count > 0)
            {
                return pools[0];
            }
            else
            {
                throw new ConfigurationErrorsException("Unable to find ResourcePool with path '" + poolPath + "'.");
            }
        }

        /// <summary>
        /// Produces a Dictionary of name-value pairs for all parameters for the given Run. This method
        /// creates or overrides values for a few specific special parameters. These parameters are passed
        /// onto the Job when it is scheduled by WTTCL.exe.
        /// </summary>
        /// <param name="run">the Run whose parameters should be collected</param>
        /// <returns>a name-value pair Dictionary of parameters</returns>
        private Dictionary<string, string> GetJobParametersAsStrings(OrmRun run)
        {
            Dictionary<string, string> jobParameters = new Dictionary<string, string>();

            // Collect normal string (property) parameters
            foreach (string key in run.RunConfigData.StringValues.Keys)
            {
                jobParameters.Add(JobParameter.TypeStringPrefix + key, run.RunConfigData.StringValues[key]);
            }

            // Collect boolean parameters
            foreach (string key in run.RunConfigData.BooleanValues.Keys)
            {
                string bitValue = "0";
                if (run.RunConfigData.BooleanValues[key])
                    bitValue = "1";
                jobParameters.Add(JobParameter.TypeBooleanPrefix + key, bitValue);
            }

            // File parameters are stored in the ORM database as fields of binary data. The WTTOMBroker
            // downloads that data, converts it into a file of the file-parameter's original format, and
            // then copies that to a share specified in the global WttFileShareRootPath. The path to that file
            // is passed onto the Job when it is scheduled by WTTCL.exe.
            if (run.RunConfigData.FileValues.Count > 0)
            {
                DirectoryInfo runDirectory = Directory.CreateDirectory(g["WttFileShareRootPath"] + @"\" + g["WttRunPrefix"] + run.Id.ToString());

                foreach (string key in run.RunConfigData.FileValues.Keys)
                {
                    FileData fileData = run.RunConfigData.FileValues[key];
                    string filePath = runDirectory.FullName + @"\" + Guid.NewGuid().ToString() + "_" + fileData.Name;

                    using (FileStream fileStream = File.Create(filePath))
                    {
                        for (int i = 0; i < fileData.Size; i++)
                        {
                            fileStream.WriteByte(fileData.Data[i]);
                        }
                        fileStream.Flush();
                        fileStream.Close();
                    }

                    jobParameters.Add(JobParameter.TypeFilePrefix + key, filePath);
                }
            }

            // Some Jobs need to know in which environment they are running (i.e. StressNet, Corpnet, StressNet2)
            // so we pass it as a parameter to the Job.
            string envParameter = g["WttEnvironmentParameter"];
            if (run.Job.HasWttParameter(envParameter))
                jobParameters.Add(envParameter, run.RunConfigData.Environment);

            return jobParameters;
        }

        /// <summary>
        /// Creates a Run pool and moves Resources mathcing the Run's requirements from idle pools to that Run Pool.
        /// </summary>
        /// <param name="jobId">WTT id of the Job being run</param>
        /// <param name="runId">ORM id of the Run</param>
        /// <param name="clientsRequested">number of clients requested by the Run for the variable JobResourceSet</param>
        /// <param name="clientPool">pool from which to draw clients</param>
        /// <param name="serverPool">pool from which to draw servers</param>
        /// <param name="firstClientName">output variable which returns the name of the first client Resource</param>
        /// <param name="runResources">output variable which returns a list of all Resource in the Run pool</param>
        /// <returns></returns>
        private ResourcePool MoveMatchingResourcesToRunPool(
            int jobId,
            int runId,
            int clientsRequested,
            ResourcePool clientPool,
            ResourcePool serverPool,
            out string firstClientName,
            out List<Resource> runResources)
        {
            firstClientName = "";
            runResources = new List<Resource>();
            Query jobQuery = new Query(typeof(WttJob));
            jobQuery.AddExpression("Id", QueryOperator.Equals, jobId);

            JobCollection jobs = JDDataStore.Query(jobQuery) as JobCollection;
            if (jobs.Count == 0)
                throw new SchedulingException("Job with Id " + jobId + " not found in WTT.");

            // A JobResourceSet indicates a group of Resources (machines) the Job needs to run, and 
            // what requirements Resources in that group must meet.
            JobResourceSetCollection jrsCollection = jobs[0].JobResourceSetCollection;

            if (jrsCollection.Count > 0)
            {
                // The variableClientResourceSet is the JobResourceSet whose number of Resources is to be
                // determined at schedule time (though falling between a min and max). There can be only one
                // such JobResourceSet per Job. The scheduler will attempt to allocate a number
                // of Resources to this JobResourceSet equal to the clientsRequested parameter.
                JobResourceSet variableClientResourceSet = null;

                // The constantClientResourceSets are any additional JobResourceSets which require Resources
                // set to fill the client role. These JobResourceSets must have a fixed number of machines.
                // That is, min and max must both be equal. 
                List<JobResourceSet> constantClientResourceSets = new List<JobResourceSet>();

                // The serverResourceSets are those JobResourceSets which require Resources set to fill the
                // server role. These JobResourceSets must have a fixed number of machines.
                // That is, min and max must both be equal.
                List<JobResourceSet> serverResourceSets = new List<JobResourceSet>();

                // This Dictionary will be filled with Resources matching the requirements of each JobResourceSet.
                // The keys for the Dictionary are the Ids of the JobResourceSets.
                Dictionary<int, ResourceCollection> matchingResourcesBySetId = new Dictionary<int, ResourceCollection>();

                // For each JobResourceSet, collect the relevant dimension requirements and find machines which match them
                foreach (JobResourceSet jrs in jrsCollection)
                {
                    // A JobResourceSet marked as fulfilling a Server role is special, and all machines must be drawn from the idle server pool
                    // All other roles are populated by machines from the client pool
                    List<Constraint> constraints = new List<Constraint>();

                    Context jrsContext = jrs.CommonContext;
                    foreach (Constraint constraint in jrsContext.ConstraintCollection)
                    {
                        constraints.Add(constraint);
                        if (constraint.DimensionId == RoleDimension.Id)
                        {
                            if (constraint.ConstraintValueCollection[0].ConstraintVal.ToLowerInvariant() == g["WttRoleDimension_Value_Client"].ToLowerInvariant())
                            {
                                // When a JobResourceSet requiring clients is found, check the min and max. If they are not
                                // equal, then this is the variableClientResourceSet, of which there can only be one per Job.
                                // If min and max are equal, then this is a constantClientResourceSet.
                                if (clientsRequested >= 0 && jrs.MinCount != jrs.MaxCount)
                                {
                                    if (variableClientResourceSet != null)
                                    {
                                        throw new SchedulingException("Job with Id " + jobId + " contains more than one ResourceSet marked with " + g["WttRoleDimension"] +
                                            " = \"" + g["WttRoleDimension_Value_Client"] + "\" and having a variable machine count. This is not supported.");
                                    }
                                    else
                                    {
                                        if (clientsRequested < jrs.MinCount || clientsRequested > jrs.MaxCount)
                                        {
                                            throw new SchedulingException("The number of requested clients (" + clientsRequested + ") falls outside the bounds of ResourceSet '" +
                                                jrs.Name + "' on Job with Id " + jobId + ". The ResourceSet supports between " + jrs.MinCount + " and " + jrs.MaxCount + " clients.");
                                        }
                                        else
                                        {
                                            variableClientResourceSet = jrs;
                                        }
                                    }
                                }
                                else
                                {
                                    constantClientResourceSets.Add(jrs);
                                }
                            }
                            else if (constraint.ConstraintValueCollection[0].ConstraintVal.ToLowerInvariant() == g["WttRoleDimension_Value_Server"].ToLowerInvariant())
                            {
                                serverResourceSets.Add(jrs);
                            }
                        }
                    }
                }

                // If no variableClientResourceSet has been identified, then find the first constantClientResourceSet
                // which specifies a number of clients equal to the clientsRequested parameter.
                if (clientsRequested >= 0 && variableClientResourceSet == null)
                {
                    for (int i = 0; i < constantClientResourceSets.Count; i++)
                    {
                        JobResourceSet jrs = constantClientResourceSets[i];
                        if (clientsRequested == jrs.MinCount && clientsRequested == jrs.MaxCount)
                        {
                            variableClientResourceSet = jrs;
                            constantClientResourceSets.RemoveAt(i);
                            break;
                        }
                    }

                    if (variableClientResourceSet == null)
                    {
                        throw new SchedulingException("The number of requested clients (" + clientsRequested + ") does not fall within the bounds of any ResourceSet for Job " +
                            jobId + " which is marked with " + g["WttRoleDimension"] + " = \"" + g["WttRoleDimension_Value_Client"] + "\".");
                    }
                }

                // Query for Resources matching requirements of the variableClientResourceSet.
                if (clientsRequested >= 0)
                {
                    matchingResourcesBySetId.Add(variableClientResourceSet.Id, GetResourcesMatchingContext(variableClientResourceSet.CommonContext, clientPool));
                    if (matchingResourcesBySetId[variableClientResourceSet.Id].Count < clientsRequested)
                    {
                        throw new InsufficientResourcesException("Not enough clients available to fulfill variable request of " + clientsRequested +
                            " clients for group '" + variableClientResourceSet.Name + ".");
                    }
                }

                // Query for Resources matching requirements of each constantClientResourceSet.
                foreach (JobResourceSet jrs in constantClientResourceSets)
                {
                    matchingResourcesBySetId.Add(jrs.Id, GetResourcesMatchingContext(jrs.CommonContext, clientPool));
                    if (matchingResourcesBySetId[jrs.Id].Count < jrs.MinCount)
                    {
                        throw new InsufficientResourcesException("Not enough clients available to fulfill minimum count for group " + jrs.Name + ".");
                    }
                }

                // Query for Resources matching requirements of each serverResourceSet.
                foreach (JobResourceSet jrs in serverResourceSets)
                {
                    matchingResourcesBySetId.Add(jrs.Id, GetResourcesMatchingContext(jrs.CommonContext, serverPool));
                    if (matchingResourcesBySetId[jrs.Id].Count < jrs.MinCount)
                    {
                        throw new InsufficientResourcesException("Not enough servers available to fullfill minimum count for group " + jrs.Name + ".");
                    }
                }

                // Create the Run pool
                ResourcePool runPool = CreateRunPool(runId);

                // Transfer resources for the variableClientResourceSet into the Run pool. Record the name
                // of the first client as some Jobs need to know this information.
                if (clientsRequested >= 0)
                {
                    try
                    {
                        runResources.AddRange(VerifiedTransferResourcesToPool(matchingResourcesBySetId[variableClientResourceSet.Id], clientsRequested, clientPool, runPool));
                        firstClientName = matchingResourcesBySetId[variableClientResourceSet.Id][0].Name;                      
                    }
                    catch (InsufficientResourcesException)
                    {
                        throw new InsufficientResourcesException("Did not find expected number of clients available to fulfill variable request of " +
                            clientsRequested + " clients for group '" + variableClientResourceSet.Name + "'.");
                    }
                }

                // Transfer resources for the constantClientResourceSets into the Run pool.
                foreach (JobResourceSet jrs in constantClientResourceSets)
                {
                    try
                    {
                        runResources.AddRange(VerifiedTransferResourcesToPool(matchingResourcesBySetId[jrs.Id], jrs.MinCount, clientPool, runPool));
                    }
                    catch (InsufficientResourcesException)
                    {
                        throw new InsufficientResourcesException("Did not find expected number of clients available to fulfill minimum count " +
                          " for group '" + jrs.Name + "'.");
                    }
                }

                // Transfer resources for the serverResourceSets into the Run pool.
                foreach (JobResourceSet jrs in serverResourceSets)
                {
                    try
                    {
                        runResources.AddRange(VerifiedTransferResourcesToPool(matchingResourcesBySetId[jrs.Id], jrs.MinCount, serverPool, runPool));
                    }
                    catch (InsufficientResourcesException)
                    {
                        throw new InsufficientResourcesException("Did not find expected number of server available to fulfill minimum count " +
                          " for group '" + jrs.Name + "'.");
                    }
                }

                return runPool;
            }
            else
            {
                // If there are no JobResourceSets defined on the Job, then simply use the Job's own requirements
                // to identify a single Resource to execute the Job.
                ResourcePool runPool = CreateRunPool(runId);
                ResourceCollection matchingResources = GetResourcesMatchingContext(jobs[0].CommonContext, clientPool);
                if (matchingResources.Count == 0)
                {
                    throw new InsufficientResourcesException("No clients available which fulfill requirements of Job with Id " + jobId + ".");
                }
                else
                {
                    try
                    {
                        runResources.AddRange(VerifiedTransferResourcesToPool(matchingResources, 1, clientPool, runPool));
                    }
                    catch (InsufficientResourcesException)
                    {
                        throw new InsufficientResourcesException("Did not find expected client available to fulfill requirements of Job with Id " + jobId + ".");
                    }
                }
                return runPool;
            }
        }

        /// <summary>
        /// Find all Resources in a given ResourcePool which match the Constraints (requirements) in a Context.
        /// </summary>
        /// <param name="commonContext">the Context to match, either from a Job or a JobResourceSet</param>
        /// <param name="pool">the pool in which to search for matching Resources</param>
        /// <returns></returns>
        private ResourceCollection GetResourcesMatchingContext(Context commonContext, ResourcePool pool)
        {
            Query resourceQuery = new Query(typeof(Resource));
            WttHelper.AddExpression(resourceQuery, Conjunction.And, new QueryExpression("Resource.ResourcePoolId", QueryOperator.Equals, pool.Id));
            WttHelper.AddExpression(resourceQuery, Conjunction.And, new QueryExpression("Resource.ResourceStatusId", QueryOperator.Equals, (int)ResourceStatus.Ready));
            foreach (Constraint constraint in commonContext.ConstraintCollection)
            {
                Query rcQuery = new Query(typeof(ResourceConfiguration));
                WttHelper.AddJoin(rcQuery, typeof(ResourceConfigurationValue), JoinType.Inner, "ResourceConfiguration.Id", "ResourceConfigurationValue.ResourceConfigurationId");
                WttHelper.AddExpression(rcQuery, Conjunction.And, 
                    new QueryExpression("ResourceConfigurationValue.DimensionId", QueryOperator.Equals, constraint.DimensionId));
                WttHelper.AddExpression(rcQuery, Conjunction.And,
                    new QueryExpression("ResourceConfigurationValue.ResourceConfigurationVal", QueryOperator.Equals, constraint.ConstraintValueCollection[0].ConstraintVal));
                WttHelper.AddExpression(resourceQuery, Conjunction.And, 
                    new QueryExpression("Resource.LatestResourceConfigurationId", QueryOperator.Within, rcQuery, "ResourceConfiguration.Id"));
            }

            Dictionary<int, Resource> resourcesById = new Dictionary<int, Resource>();
            ResourceCollection distinctMatches = new ResourceCollection(JDDataStore);

            // To debug this query, uncomment the following line and view querySqlText in a debugger.
            // string querySqlText = SqlProvider.GetProviderQueryString(resourceQuery);
            foreach (Resource match in JDDataStore.Query(resourceQuery))
            {
                if (!resourcesById.ContainsKey(match.Id))
                {
                    distinctMatches.Add(match);
                    resourcesById.Add(match.Id, match);
                }
            }
            
            return distinctMatches;
        }

        /// <summary>
        /// Create a Run pool for the given Run Id
        /// </summary>
        /// <param name="runId">the id of the Run for which to create a Run pool</param>
        /// <returns>the created Run pool</returns>
        private ResourcePool CreateRunPool(int runId)
        {
            ResourcePool runPool = new ResourcePool(JDDataStore);
            runPool.ParentId = RunPoolRootPool.Id;
            string runPoolName = g["WttRunPrefix"] + runId.ToString();
            if (runPoolName.Length > MAX_POOL_NAME_LENGTH)
                runPool.Name = runPoolName.Substring(0, MAX_POOL_NAME_LENGTH);
            else
                runPool.Name = runPoolName;
            runPool.PushDaemonResourceId = 1;
            runPool.CommitToDataStore();

            return runPool;
        }

        /// <summary>
        /// Delete a Run's pool
        /// </summary>
        /// <param name="run">the Run whose pool should be deleted</param>
        private void DeleteRunPool(OrmRun run)
        {
            Query poolQuery = new Query(typeof(ResourcePool));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("ParentId", QueryOperator.Equals, RunPoolRootPool.Id));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Name", QueryOperator.BeginsWith, g["WttRunPrefix"] + run.Id.ToString()));

            ResourcePoolCollection pools = JDDataStore.Query(poolQuery) as ResourcePoolCollection;

            ResourcePool runPool = null;
            if (pools.Count > 0)
                runPool = pools[0];
            else
                return;

            runPool.DataStoreOperation = DataStoreOperation.Delete;
            runPool.CommitToDataStore();
        }

        /// <summary>
        /// Re-queries a collection of candidte Resources and moves a specified number of them
        /// from a source pool to a destination pool. Re-querying them ensures that they are still
        /// in the source pool before they are moved.
        /// </summary>
        /// <param name="resources">the collection of Resources who are candidates for moving</param>
        /// <param name="numberOfResourcesToMove">the number of Resources which must be moved</param>
        /// <param name="sourcePool">the pool from which the Resources must be moved</param>
        /// <param name="destinationPool">the pool to which the Resources will be moved</param>
        /// <returns></returns>
        private List<Resource> VerifiedTransferResourcesToPool(ResourceCollection resources, int numberOfResourcesToMove, ResourcePool sourcePool, ResourcePool destinationPool)
        {
            int[] ids = new int[resources.Count];
            for (int i = 0; i < resources.Count; i++)
            {
                ids[i] = resources[i].Id;
            }

            Query resourceQuery = new Query(typeof(Resource));
            WttHelper.AddExpression(resourceQuery, Conjunction.And, new QueryExpression("Id", QueryOperator.Within, ids));
            WttHelper.AddExpression(resourceQuery, Conjunction.And, new QueryExpression("ResourcePoolId", QueryOperator.Equals, sourcePool.Id));

            return TransferResourcesToPool(JDDataStore.Query(resourceQuery) as ResourceCollection, numberOfResourcesToMove, destinationPool.Id);
        }

        /// <summary>
        /// Transfer a collection of Resources to a target pool.
        /// </summary>
        /// <param name="resources">the candidate Resources to move</param>
        /// <param name="numberOfResourcesToMove">the number of Resources which must be moved</param>
        /// <param name="targetPoolId">the Id of the pool to which the Resources will be moved</param>
        /// <returns></returns>
        private List<Resource> TransferResourcesToPool(ResourceCollection resources, int numberOfResourcesToMove, int targetPoolId)
        {
            if (resources.Count < numberOfResourcesToMove)
                throw new InsufficientResourcesException();

            List<Resource> resourcesTransfered = new List<Resource>();

            for (int i = 0; i < numberOfResourcesToMove; i++)
            {
                Resource resource = resources[i];
                resource.ResourcePoolId = targetPoolId;
                resourcesTransfered.Add(resource);
            }

            resources.CommitToDataStore();

            return resourcesTransfered;
        }

        /// <summary>
        /// Returns Resources from a Run pool to their original idle pools.
        /// </summary>
        /// <param name="run">the Run whose Resources can be returned</param>
        private void ReturnResourcesToOrigin(OrmRun run)
        {
            Query poolQuery = new Query(typeof(ResourcePool));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("ParentId", QueryOperator.Equals, RunPoolRootPool.Id));
            WttHelper.AddExpression(poolQuery, Conjunction.And, new QueryExpression("Name", QueryOperator.BeginsWith, g["WttRunPrefix"] + run.Id.ToString()));

            ResourcePoolCollection pools = JDDataStore.Query(poolQuery) as ResourcePoolCollection;

            ResourcePool runPool = null;
            if (pools.Count > 0)
                runPool = pools[0];
            else
                return;

            // This Dictionary holds collections of Resources who came from the same original idle pool,
            // which each collection keyed by the name of role these Resources fill. Using this Dictionary
            // allows returning the Resources in batches for better performance.
            Dictionary<string,ResourceCollection> kindredResources = new Dictionary<string,ResourceCollection>();

            // This collection of Resources contains those found in a non-Ready state, which will be moved
            // to the Recovery pool.
            ResourceCollection debugResources = new ResourceCollection(JDDataStore);

            Query resourceQuery = new Query(typeof(Resource));
            resourceQuery.AddExpression("ResourcePoolId", QueryOperator.Equals, runPool.Id);

            ResourceCollection resources = JDDataStore.Query(resourceQuery) as ResourceCollection;
            foreach (Resource resource in resources)
            {
                if (resource.ResourceStatusId == ResourceStatus.Ready || resource.ResourceStatusId == ResourceStatus.Running)
                {
                    foreach (ResourceConfigurationValue rcv in resource.LatestResourceConfiguration.ResourceConfigurationValueCollection)
                    {
                        if (rcv.DimensionId == RoleDimension.Id)
                        {
                            string role = rcv.ResourceConfigurationVal;
                            if (!kindredResources.ContainsKey(role))
                            {
                                kindredResources.Add(role, new ResourceCollection(JDDataStore));
                            }

                            kindredResources[role].Add(resource);
                        }
                    }
                }
                else
                {
                    debugResources.Add(resource);
                }
            }

            // This Dictionary contains idle ResourcePools keyed by role name (i.e. Server, StressClient).
            Dictionary<string, ResourcePool> originPools = GetIdleResourcePoolsForEnvironment(run);

            foreach (string role in kindredResources.Keys)
            {
                if (originPools.ContainsKey(role))
                {
                    ResourceCollection resourceBatch = kindredResources[role];
                    TransferResourcesToPool(resourceBatch, resourceBatch.Count, originPools[role].Id);
                }
                else
                {
                    foreach (Resource homelessResource in kindredResources[role])
                    {
                        debugResources.Add(homelessResource);
                    }
                }
            }

            TransferResourcesToPool(debugResources, debugResources.Count, RecoveryPool.Id);
        }

        /// <summary>
        /// Call WTTCL.exe to schedule a Run.
        /// </summary>
        /// <param name="runId">the ORM Id of the Run to schedule</param>
        /// <param name="runName">the Name of the Run to schedule</param>
        /// <param name="jobId">the WTT Id of the Job to schedule</param>
        /// <param name="jobParameters">the Dictionary containing name-value parameters for the Job</param>
        /// <param name="runPool">the Run pool to which the Job should be scheduled</param>
        /// <returns>the name of the ResultSummary which contains the WTT Result for the Run</returns>
        private string LaunchWTTCLToSchedule(int runId, string runName, int jobId, Dictionary<string, string> jobParameters, ResourcePool runPool)
        {
            // The specific command line used to call WTTCL.exe is highly parameterized. The globals
            // contain both the base template command-line as well as the names of the tokens which should
            // be replaced with values corresponding to this particular Run.
            string wttclFileName = g["WttCommandLine_FilePath"];
            string wttclArguments = g["WttCommandLine_Arguments"];
            string resultSummary = g["WttRunPrefix"] + runId.ToString() + "_" + Guid.NewGuid() + ":" + runName;
            if (resultSummary.Length > MAX_RESULTSUMMARY_NAME_LENGTH)
            {
                resultSummary = resultSummary.Substring(0, MAX_RESULTSUMMARY_NAME_LENGTH);
            }

            wttclArguments = wttclArguments.Replace(g["WttCommandLine_Parameter_RunId"], runId.ToString());
            wttclArguments = wttclArguments.Replace(g["WttCommandLine_Parameter_ResultSummary"], resultSummary);
            wttclArguments = wttclArguments.Replace(g["WttCommandLine_Parameter_JobId"], jobId.ToString());
            wttclArguments = wttclArguments.Replace(g["WttCommandLine_Parameter_RunPoolPath"], runPool.Path + runPool.Name);

            string parametersArgument = "";

            // Add the Job's parameters to the command line.
            if (jobParameters.Keys.Count > 0)
            {
                StringBuilder parameterBuilder = new StringBuilder();
                foreach (string parameterName in jobParameters.Keys)
                {
                    parameterBuilder.Append("/CommonParameter { /Name:\"" + parameterName + "\" /Value:\"" + jobParameters[parameterName] + "\" } ");
                }
                parametersArgument = parameterBuilder.ToString();
            }

            wttclArguments = wttclArguments.Replace(g["WttCommandLine_Parameter_JobParameters"], parametersArgument);

            // Create the process for WTTCL.exe and launch it. Wait for the process to exit. WTTCL.exe
            // will return when the Job is scheduled, not when the Job is complete.
            Process wttclProcess = new Process();
            wttclProcess.StartInfo.FileName = Environment.ExpandEnvironmentVariables(wttclFileName).Replace("\n", " ").Replace("\r", " ");
            wttclProcess.StartInfo.Arguments = Environment.ExpandEnvironmentVariables(wttclArguments).Replace("\n", " ").Replace("\r", " ");
            wttclProcess.StartInfo.UseShellExecute = false;

            if (wttclProcess.Start())
            {
                while (!wttclProcess.HasExited)
                {
                    System.Threading.Thread.Sleep(100);
                }
            }

            if (wttclProcess.ExitCode != 0)
            {
                string logPath = wttclFileName.Substring(0, wttclFileName.LastIndexOf('\\') + 1) + @"WTTCL\Log";
                throw new SchedulingException("When trying to schedule Job " + jobId + ", WTTCL returned an error code of " + wttclProcess.ExitCode +
                    ". See the WTTCL log for time " + DateTime.Now.ToString() + " on " + System.Environment.MachineName + " in " + logPath);
            }

            return resultSummary;
        }

        #endregion // Private Methods
    }

    /// <summary>
    /// This Exception is thrown when there are not enough machines to meet a Run's requirements. In this case, the Run remains
    /// in the queue until enough resources are available.
    /// </summary>
    public class InsufficientResourcesException : Exception
    {
        public InsufficientResourcesException() : base() { }

        public InsufficientResourcesException(string message) : base(message) { }
    }

    /// <summary>
    /// This Exception is thrown when the scheduling of a particular Run fails, but the cause is most likely
    /// due to something wrong with the Run or its Job. This Run will then be removed from the queue so the WttSchedulingTask
    /// can continue scheduling other Runs.
    /// </summary>
    public class SchedulingException : Exception
    {
        public SchedulingException(string message) : base(message) { }

        public SchedulingException(string message, Exception innerException) : base(message, innerException) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\run.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Drawing;
using System.IO;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.OM.Results;

using Dundas.Charting.WebControl;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Run page. Displays current status and results of a given run.
    /// Inherits Live Server Admin Pages BasePage class.
    /// </summary>
    public class RunPage : BasePage
    {
        /// <summary>
        /// Grid Web control used to dispaly results in a data grid format.
        /// </summary>
        protected grid          gridWc;

        /// <summary>
        /// Results table used to display results grids / graphs. 
        /// We're using this to fake a tab control on the web page.
        /// </summary>
        protected HtmlTable     resultsTable;

        /// <summary>
        /// Table cell used to represent the fist tab.
        /// </summary>
        protected HtmlTableCell tab1;

        /// <summary>
        /// Table cell used to represent the second tab
        /// </summary>
        protected HtmlTableCell tab2;

        /// <summary>
        /// The HTMLTable row used for results display
        /// </summary>
        protected HtmlTableRow  ResultRow;

        /// <summary>
        /// The HTMLTable row used for Export results link
        /// </summary>
        protected HtmlTableRow ExportRow;

        /// <summary>
        /// The HTMLTable cell that shows the status of the raw data export operation
        /// </summary>
        protected HtmlTableCell ExportCell;

        /// <summary>
        /// The HTMLTable row used for the sysmon data link
        /// </summary>
        protected HtmlTableRow  sysmonRow;

        /// <summary>
        /// The link to the sysmon results
        /// </summary>
        protected HyperLink     sysmonLink;

        /// <summary>
        /// The panel for the chart results used in the fake tab control
        /// </summary>
        protected Panel         chartPanel;

        /// <summary>
        /// The panel for the grid results used in the fake tab control
        /// </summary>
        protected Panel         gridPanel;

        /// <summary>
        /// Panel used to let the user know that no valid Run was specified.
        /// </summary>
        protected Panel         noRunPanel;

        /// <summary>
        /// Panel used to control visibility of all results. Turned off when noRunPanel is turned on.
        /// </summary>
        protected Panel         runPanel;

        /// <summary>
        /// Radio button used to designate stackedBar chart type
        /// </summary>
        protected RadioButton   stackedRadioButton;

        /// <summary>
        /// Radio button used to designate bar chart type
        /// </summary>
        protected RadioButton   barRadioButton;
        
        /// <summary>
        /// Repeater to display machine data.
        /// </summary>
        protected Repeater      machineRepeater;

        /// <summary>
        /// RunId for current instance. Default value is -1.
        /// </summary>
        private int currentRunId = -1;

        /// <summary>
        /// Id for the currently displayed tab. Default value is -1
        /// 0 is the graph panel, 1 is the grid panel.
        /// </summary>
        private int currentTabId = -1;

        /// <summary>
        /// Instance of the Run we are displaying results for.
        /// </summary>
        private Run currentRun = null;

        /// <summary>
        /// Used to set series chart type.
        /// </summary>
        private SeriesChartType selectedChartType;

        /// <summary>
        /// Gets the current run we are displaying results for.
        /// </summary>
        public Run CurrentRun
        {
            get
            {
                return currentRun;
            }
        }

        /// <summary>
        /// Gets the current run Id
        /// </summary>
        public int CurrentRunId
        {
            get
            {
                return currentRunId;
            }
        }

        /// <summary>
        /// Gets the path to the results share for this run.
        /// </summary>
        public string RunResultsShare
        {
            get
            {
                return WebUtilities.ReplaceWithCorpNetUrn(CurrentRun.LogPath);
            }
        }

        /// <summary>
        /// Gets the current status in a displayable format for this Run
        /// If the status is canceled, it concatenates on the reason for the cancelation.
        /// </summary>
        public string RunStatus
        {
            get
            {
                if (CurrentRun.Status == Run.RunStatus.Canceled)
                {
                    ResultRow.Visible = false;
                    ExportRow.Visible = false;
                    return string.Format("Canceled. Reason: {0}", CurrentRun.Reason);
                }

                return CurrentRun.Status.ToString();
            }
        }

        /// <summary>
        /// Requests to the XtsTasks server that the raw data for this run is generated.
        /// It reloads the webpage afterwards.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void RequestRawData_Click(object sender, EventArgs e)
        {
            CurrentRun.RawData = Run.RawDataStatus.Requested;
            CommitAndReload();
        }

        /// <summary>
        /// Populates the MachineRepeater with the data on machines used for this run.
        /// </summary>
        private void PopulateMachineRepeater()
        {
            Machine[] machines = Machine.GetByRunId(currentRunId);
            if (machines.Length == 0)
            {
                // Setting a null collection on the repeater causes it to not show at all on the webpage
                machines = null;
            }

            machineRepeater.DataSource = machines;
            machineRepeater.DataBind();
        }

        #region events
        /// <summary>
        /// PageLoad event handler. Calls PopulateMachineRepeater
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            PopulateMachineRepeater();

            switch (CurrentRun.RawData)
            {
                case Run.RawDataStatus.Empty:
                    ExportCell.InnerText = "Not available for this run.";
                    break;

                case Run.RawDataStatus.FetchingFromDatabase:
                    ExportCell.InnerText = "Currently fetching from database...";
                    break;

                case Run.RawDataStatus.Requested:
                    ExportCell.InnerText = "Request sent to server...";
                    break;

                case Run.RawDataStatus.Generated:
                    ExportCell.InnerText = "Available at log path as rawdata.zip";
                    break;

                case Run.RawDataStatus.NotRequested:
                    Button b = new Button();
                    b.Click += new EventHandler(RequestRawData_Click);
                    b.Text = "Request";
                    ExportCell.Controls.Add(b);
                    break;
            }
        }

        /// <summary>
        /// OnInit event handler
        /// Pulls the currentRunId and currentTabId off the query string, loads the associated Run,
        /// sets panel visibility and sets up the sysmon data link
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);

            currentRunId = WebUtilities.GetParam(HttpContext.Current, "runid", true, false, 0);
            currentTabId = WebUtilities.GetParam(HttpContext.Current, "tabid", true, false, 1);

            if (currentRunId > 0)
            {
                try
                {
                    currentRun = Run.Get(currentRunId);
                }
                catch (PersistedBase.InvalidIdException)
                {
                    Response.Redirect("runs.aspx", true);
                }
            }

            if (CurrentRun == null)
            {
                noRunPanel.Visible = true;
                runPanel.Visible = false;
                return;
            }

            switch (CurrentRun.Status)
            {
                case Run.RunStatus.Unscheduled:
                case Run.RunStatus.Scheduled:
                case Run.RunStatus.Canceled:
                    break;

                case Run.RunStatus.Complete:
                    int major, minor;
                    sysmonRow.Visible = true;
                    sysmonLink.Target = "_blank";
                    if (WebUtilities.GetClientOSVersion(HttpContext.Current, out major, out minor) && major >= 6)
                        sysmonLink.NavigateUrl = String.Format("sysmon.aspx?runid={0}", CurrentRunId);
                    else
                        sysmonLink.NavigateUrl = String.Format("sysmonxp.aspx?runid={0}", CurrentRunId);

                    if (!IsPostBack)
                    {
                        AddResults();
                    }
                    break;
            }

            //if (!IsPostBack)
            //{
            //}
        }

        #endregion
        
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
            this.barRadioButton.CheckedChanged += new EventHandler(barRadioButton_CheckedChanged);
            this.stackedRadioButton.CheckedChanged += new EventHandler(stackedRadioButton_CheckedChanged);
            
        }

        public bool IsMachineLinkVisible(Machine m)
        {
            return (m != null && !String.IsNullOrEmpty(m.MonitorData) && DateTime.Compare(m.LastPost, CurrentRun.ScheduleTime) >= 0);
        }

        void stackedRadioButton_CheckedChanged(object sender, EventArgs e)
        {
            this.selectedChartType = SeriesChartType.StackedBar;
            AddResults();
        }

        void barRadioButton_CheckedChanged(object sender, EventArgs e)
        {
            this.selectedChartType = SeriesChartType.Bar;
            AddResults();
        }
    
        /// <summary>
        /// Adds result reports to the page 
        /// called in OnInit if the run is complete
        /// </summary>
        private void AddResults()
        {
            RunTotals[] totals = RunTotals.GetForRun(currentRunId);

            if (totals.Length == 0)
            {
                return;
            }
            
            resultsTable.Visible = true;
            SelectTab(currentTabId, totals);
        }

        /// <summary>
        /// Builds graphs off of the RunTotals if the run is complete. Called in OnInit.
        /// </summary>
        /// <param name="totals"></param>
        private void MakeGraphs(RunTotals[] totals)
        {
            chart totalsChart = new chart();
            totalsChart.ChartHeight = 250;
            totalsChart.ChartWidth = 500;
            totalsChart.Title = "Test Totals";
            totalsChart.BackColor = System.Drawing.Color.FromArgb(204, 204, 204);
            totalsChart.ParentPage = this;

            string[] totalsCategories = { "Passed", "Failed" };
            totalsChart.Categories = totalsCategories;

            chart tpsChart = new chart();
            tpsChart.ChartHeight = 250;
            tpsChart.ChartWidth = 500;
            tpsChart.Title = "TPS Totals";
            tpsChart.BackColor = System.Drawing.Color.FromArgb(204, 204, 204);
            tpsChart.ParentPage = this;

            string[] tpsCategories = { "TPS" };
            tpsChart.Categories = tpsCategories;

            SeriesChartType selectedType = IsPostBack ? this.selectedChartType : SeriesChartType.Bar; 

            foreach (RunTotals total in totals)
            {
                int[] totalsValues = { total.Passed,
                                   total.Failed};

                int[] tpsTotals = { ((int)total.TotalTPS) };

                totalsChart.AddValueCollection(total.TestCase, selectedType, totalsValues);
                tpsChart.AddValueCollection(total.TestCase, selectedType, tpsTotals);
            }

            chartPanel.Controls.Add(totalsChart);
            chartPanel.Controls.Add(tpsChart);
        }
                
        /// <summary>
        /// Builds data grids off of the RunTotals if the run is complete. Called in OnInit.
        /// </summary>
        /// <param name="totals"></param>
        private void MakeCharts(RunTotals[] totals)
        {
            gridWc.Data = (object)RunTotals.GetForRun(currentRunId);
        }

        /// <summary>
        /// Sets the tab based on the query string value captured in OnInit
        /// </summary>
        /// <param name="id"></param>
        /// <param name="totals"></param>
        private void SelectTab(int id, RunTotals[] totals)
        {
            tab1.Attributes.Clear();
            tab2.Attributes.Clear();

            switch (id)
            {
                case 1:
                    tab1.Attributes.Add("class", "selectedTab");
                    tab2.Attributes.Add("class", "tab");
                    chartPanel.Visible = true;
                    gridPanel.Visible = false;
                    MakeGraphs(totals);
                    break;
                case 2:
                    tab1.Attributes.Add("class", "tab");
                    tab2.Attributes.Add("class", "selectedTab");
                    chartPanel.Visible = false;
                    gridPanel.Visible = true;
                    MakeCharts(totals);
                    break;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\parameters.ascx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.Platform.Utils;
using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Parameters web control. 
    /// Inherits the Live Server Admin Pages UserControl
    /// Displays all wtt_variables with their values for a RunConfiguration or Run
    /// </summary>
    public class parameters : Microsoft.Xna.LiveServer.WebPages.UserControl
    {
        /// <summary>
        /// Flag to display private variables. Turned on during debug times.
        /// Value is set in <c>m_displayPrivFields</c>
        /// </summary>
        private bool? m_globalDisplayPriv = null;

        /// <summary>
        /// Gets a bool indicating weather private fields should be displayed.
        /// Value is loaded from the Globals object and cached locally.
        /// </summary>
        private bool m_displayPrivFields
        {
            get
            {
                if (!m_globalDisplayPriv.HasValue)
                {
                    m_globalDisplayPriv = bool.Parse(Globals.GetProperty("WebpageDisplayPrivParamaters"));
                }

                return m_globalDisplayPriv.Value;
            }
        }

        /// <summary>
        /// repeater for displaying the parameters
        /// </summary>
        protected Repeater parameterRepeater;

        /// <summary>
        /// Enumerates the acceptable source data types
        /// </summary>
        public enum SourceType
        {
            None,
            Run,
            RunConfig,
        }

        /// <summary>
        /// The current source data type
        /// </summary>
        private SourceType m_source = SourceType.None;

        /// <summary>
        /// Gets or sets the source data type. When setting converts the supplied string to a <c>SourceType</c>
        /// </summary>
        public string Source
        {
            set
            {
                switch (value.ToLower())
                {
                    case "run":
                        m_source = SourceType.Run;
                        break;

                    case "runconfig":
                        m_source = SourceType.RunConfig;
                        break;

                    default:
                        throw new Exception("Unrecognized source type: " + value);
                }
            }
            get
            {
                return m_source.ToString();
            }
        }

        /// <summary>
        /// The Id for the source data object to use in this instance.
        /// </summary>
        private int m_sourceId = -1;

        /// <summary>
        /// Gets or sets the Id for the source data object to use in this instance
        /// </summary>
        public string SourceId
        {
            set { m_sourceId = WebUtilities.GetParam(HttpContext.Current, value, true, false, -1); }
            get { return m_sourceId.ToString(); }
        }

        /// <summary>
        /// Readonly flag
        /// </summary>
        protected bool m_ReadOnly;

        /// <summary>
        /// Gets or sets the Readonly flag.
        /// When set to true, causes all child controls to be rendered with Enabled == false
        /// </summary>
        public bool ReadOnly
        {
            get 
            {
                return m_ReadOnly;
            }

            set
            {
                m_ReadOnly = value;
            }
        }

        /// <summary>
        /// Gets the Job associated with the source data object for this instance
        /// </summary>
        private Job Job
        {
            get
            {
                switch (m_source)
                {
                    case SourceType.Run:
                        return Run.Get(m_sourceId).Job;

                    case SourceType.RunConfig:
                        return RunConfig.Get(m_sourceId).Job;

                    default:
                        throw new Exception("Unsupported source type: " + m_source.ToString());
                }
            }
        }

        /// <summary>
        /// Gets the RunConfigData associated with the source data object for this instance
        /// </summary>
        private RunConfigData RunConfigData
        {
            get
            {
                switch (m_source)
                {
                    case SourceType.Run:
                        return Run.Get(m_sourceId).RunConfigData;

                    case SourceType.RunConfig:
                        return RunConfig.Get(m_sourceId).RunConfigData;

                    default:
                        throw new Exception("Unsupported source type: " + m_source.ToString());
                }
            }
        }

        /// <summary>
        /// PageLoad event handler
        /// Populates the paramater repeater
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            PopulateRepeater();
        }

        /// <summary>
        /// OnInit event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// IntializeComponent called from <c>OnInit</c> event
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Populates the paramater repeater.
        /// </summary>
        private void PopulateRepeater()
        {
            if (m_sourceId >= 0)
            {
                parameterRepeater.DataSource = Job.Parameters;
                parameterRepeater.DataBind();
            }
        }

        /// <summary>
        /// Repeater ItemDataBound event handler.
        /// Ensures the noWrap class is applied to the correct HTML Table cells. 
        /// Also hides rows that contain hidden fields.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Parameter_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                JobParameter item = e.Item.DataItem as JobParameter;
                HtmlTableRow row = e.Item.FindControl("itemRow") as HtmlTableRow;

                if (item != null && (item.Type != JobParameter.ParameterType.Hidden || m_displayPrivFields))
                {
                    Label itemTitle = e.Item.FindControl("itemTitle") as Label;
                    HtmlTableCell formCell = e.Item.FindControl("formItemCell") as HtmlTableCell;
                    
                    if (itemTitle == null || formCell == null)
                    {
                        // Something's gone horribly wrong. Bail.
                        return;
                    }

                    itemTitle.Text = item.Name;
                    itemTitle.ToolTip = item.Description;
                
                    formCell.Attributes.Add("class", "noWrap");
                    formCell.Controls.Add(CreateInputControl(item));
                }
                else
                {
                    row.Visible = false;
                }
            }
        }

        /// <summary>
        /// Click handler for delete button in repeater. Note it gets the file name from the ID of the button.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void deleteButton_Click(object sender, EventArgs e)
        {
            Button senderButton = sender as Button;
            // This function is only callable if we are NOT in readOnly mode hence on the Schedule page with a ConfigId in the QS.
            int runConfigId = WebUtilities.GetParam(HttpContext.Current, "configid", true, false, 0);

            if (senderButton != null && runConfigId > 0)
            {
                using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
                {
                    RunConfig config = RunConfig.Get(runConfigId);
                    config.BeginEdit();
                    config.RunConfigData.DeleteFileParameterValue(senderButton.CommandArgument);
                    config.EndEdit();
                    sessionRef.Commit();
                }

                Response.Redirect(String.Format("schedule.aspx?configid={0}", runConfigId), true);
            }
        }

        /// <summary>
        /// Fills a given dictionary with the submitted values. Also does form validation.
        /// </summary>
        /// <param name="submittedParams">out paramater. referance to dictionary to fill</param>
        /// <returns>true if form is valid and dictionary is filled</returns>
        public bool FillParamaters(out Dictionary<string, object> submittedParams )
        {
            bool valid = true;
            submittedParams = new Dictionary<string, object>();
            foreach (RepeaterItem item in this.parameterRepeater.Items)
            {
                if (item.ItemType == ListItemType.Item || item.ItemType == ListItemType.AlternatingItem)
                {
                    HtmlTableCell formCell = item.FindControl("formItemCell") as HtmlTableCell;
                    Label itemTitle = item.FindControl("itemTitle") as Label;
                    if (formCell != null && itemTitle != null)
                    {
                        JobParameter param = Job.GetParameter(itemTitle.Text);
                        if (param != null)
                        {
                            object val;
                            valid = valid & this.GetFormValue(formCell, param, out val);
                            submittedParams.Add(param.Name, val);
                        }
                    }
                }
            }

            return valid;
        }
        
        /// <summary>
        /// Gets the value submitted for the control in a given cell.
        /// </summary>
        /// <param name="cell"></param>
        /// <param name="param"></param>
        /// <param name="returnValue"></param>
        /// <returns></returns>
        private bool GetFormValue(HtmlTableCell cell, JobParameter param, out object returnValue)
        {
            returnValue = null;
            Trace.Write("Cell Control count: " + cell.Controls.Count);

            switch (param.Type)
            {
                case JobParameter.ParameterType.Boolean:
                    CheckBox cb = cell.FindControl(param.Name) as CheckBox;
                    if (cb != null)
                    {
                        returnValue = cb.Checked ? "Yes" : String.Empty;
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                case JobParameter.ParameterType.String:
                    TextBox tb = cell.FindControl(param.Name) as TextBox;
                    if (tb != null)
                    {
                        returnValue = String.IsNullOrEmpty(tb.Text) ? param.DefaultValue : tb.Text;
                    }
                    else
                    {
                        returnValue = param.DefaultValue;
                    }

                    if (String.IsNullOrEmpty(((string)returnValue)) && String.IsNullOrEmpty(param.DefaultValue))
                    {
                        return true;
                    }
                    else
                    {
                        return true;
                    }

                case JobParameter.ParameterType.File:
                    FileUpload fu = cell.FindControl(param.Name) as FileUpload;
                    if (fu != null && fu.HasFile)
                    {
                        FileData fd = new FileData(fu.FileName, fu.FileBytes);
                        fd.Size = fu.FileBytes.Length;
                        returnValue = fd;
                        return true;
                    }
                    else
                    {
                        returnValue = null;

                        if (String.IsNullOrEmpty(this.getDefaultValue(param.Name)))
                        {
                            return true; // defalt valid value if a file is not present.
                        }

                        return true;
                    }
                default:
                    return true;
            }
        }

        /// <summary>
        /// Creates a Panel containing one or more webControls based off of a <c>JobParameter</c>. The panel is added to the repeater for display to the user.
        /// </summary>
        /// <param name="item">the JobParameter to base this control off of</param>
        /// <returns>The created Panel</returns>
        private WebControl CreateInputControl(JobParameter item)
        {
            string controlValue = String.Empty;
            Panel container = new Panel();

            WebControl control = GetInputControl(item);
            if (control != null)
            {
                control.ID = item.Name;
                container.Controls.Add(control);

                if (item.Type == JobParameter.ParameterType.File && this.getDefaultValue(item.Name) == "!!!!!!FILEEXISTS!!!!!!")
                {
                    Button downloadButton = new Button();
                    downloadButton.CommandArgument = String.Format("download.aspx?filetype={0}param&configid={1}&fileid={2}", this.m_source, this.m_sourceId, item.Name);
                    downloadButton.Click += new EventHandler(downloadButton_Click);
                    downloadButton.Text = "Download";
                    downloadButton.Height = 22;
                    container.Controls.Add(downloadButton);

                    if (!this.ReadOnly)
                    {
                        Button deleteButton = new Button();
                        deleteButton.CommandArgument = item.Name;
                        deleteButton.Click += new EventHandler(deleteButton_Click);
                        deleteButton.Text = "Delete File";
                        deleteButton.Height = 22;
                        container.Controls.Add(deleteButton);
                    }
                }
            }

            return container;            
        }

        /// <summary>
        /// Click event handler for download button. Redirects user to the download page.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void downloadButton_Click(object sender, EventArgs e)
        {
            Button senderButton = sender as Button;
            if (senderButton != null)
            {
                Response.Redirect(senderButton.CommandArgument, true);
            }
        }

        /// <summary>
        /// Creates an individual web control based off of a <c>JobParameter</c>
        /// </summary>
        /// <param name="item">the JobParameter to base this control off of</param>
        /// <returns>The created Control</returns>
        private WebControl GetInputControl(JobParameter item)
        {
            switch (item.Type)
            {
                case JobParameter.ParameterType.String:
                    TextBox tb = new TextBox();
                    tb.Text = this.getDefaultValue(item.Name);
                    tb.Enabled = !m_ReadOnly;
                    return tb;
                case JobParameter.ParameterType.Boolean:
                    CheckBox cb = new CheckBox();
                    cb.Checked = (String.Compare("yes", getDefaultValue(item.Name), true) == 0 || String.Compare("true", getDefaultValue(item.Name), true) == 0);
                    cb.Enabled = !m_ReadOnly;
                    return cb;
                case JobParameter.ParameterType.File:
                    FileUpload fu= new FileUpload();
                    fu.Enabled = !m_ReadOnly;
                    return fu;
            }

            return null;
        }

        /// <summary>
        /// Gets the default value for field based off the name
        /// </summary>
        /// <param name="name">the name of the field to look up</param>
        /// <returns>the string representation of the default value</returns>
        private string getDefaultValue(string name)
        {
            switch (Job.GetParameter(name).Type)
            { 
                case JobParameter.ParameterType.String :
                    return RunConfigData.StringValues[name];

                case JobParameter.ParameterType.Boolean :
                    return RunConfigData.BooleanValues[name].ToString();

                case JobParameter.ParameterType.File :
                    if (RunConfigData.FileValues.ContainsKey(name) && RunConfigData.FileValues[name].Size > 0)
                        return "!!!!!!FILEEXISTS!!!!!!";
                    break;
            }

            return string.Empty;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\Machines.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;
using Microsoft.Xna.LiveServer.LS3i.WTT;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Machines page. Inherits Live Server Admin Pages BasePage
    /// Displays high level report of machine status.
    /// </summary>
    public class MachinesPage : BasePage
    {
        /// <summary>
        /// HtmlTableRow for individual machine
        /// </summary>
        protected HtmlTableRow machineRow;
        

        /// <summary>
        /// Repeater for display of report.
        /// </summary>
        protected Repeater machineRepeater;

        #region MachineSorter
        /// <summary>
        /// IComparer classed used to sort the machine list based on their status.
        /// From top to bottom: Debug -> Running -> Ready -> Manual
        /// </summary>
        private class MachineSorter : IComparer<Machine>
        {
            /// <summary>
            /// Compares 2 Machines based on status.
            /// </summary>
            /// <param name="m1"></param>
            /// <param name="m2"></param>
            /// <returns></returns>
            public int Compare(Machine m1, Machine m2)
            {
                int m1Status = StatusToValue(m1.Status);
                int m2Status = StatusToValue(m2.Status);

                if (m1Status < m2Status) return -1;
                else if (m1Status > m2Status) return 1;
                else
                {
                    return m1.Name.CompareTo(m2.Name);
                }
            }

            /// <summary>
            /// Helper function to turn strings into ints for easy comparison to determine order
            /// </summary>
            /// <param name="status"></param>
            /// <returns></returns>
            private int StatusToValue(string status)
            {
                if (status == null)
                    return 10;

                if (status.Equals("Debug"))
                    return 1;
                else if (status.Equals("Running"))
                    return 2;
                else if (status.Equals("Ready"))
                    return 3;
                else if (status.Equals("Manual"))
                    return 4;

                return 1;
            }
        }
        #endregion

        /// <summary>
        /// OnLoad event. 
        /// Gets the list of machines, their status and binds the machineRepeater.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            Machine[] machineResults = this.GetMachines();

            // Sort the machines based on their status
            Array.Sort(machineResults, new MachineSorter());

            // Only populate the drop down and repeater if this is the page's first load. If it's a post-back, then
            // the event which initiated the postback will handle population.

            //If there is no query string, page is requested from Menu.
            if (HttpContext.Current.Request.QueryString.Count == 0)
            {
                if (!IsPostBack)
                {
                    if (machineResults.Length > 0)
                    {
                        this.machineRepeater.DataSource = machineResults;
                        this.machineRepeater.DataBind();

                        this.machineRow.Visible = true;
                    }
                    else
                    {
                        this.machineRow.Visible = false;
                    }
                }
            }
            //If you have query strings, you are revisiting page to reserve/release machine. Take appropriate action.
            else
            {
                //Get machine name from context.
                string mName = WebUtilities.GetParam(HttpContext.Current, "machinename", true, false, String.Empty).ToLower();
                //Get action from context and throw if you dont find it.
                string action = WebUtilities.GetParam(HttpContext.Current, "action", true, false, String.Empty).ToLower();
                if (string.IsNullOrEmpty(mName) || string.IsNullOrEmpty(action))
                    throw new ArgumentNullException();

                //Get user alias from context.
                WTTOMBroker wtt = new WTTOMBroker(new GlobalsAccessor());
                string userAlias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);

                if (action.ToLower() == "release")
                {
                    //Loop through the machines, and release the machine when you find a match.
                    foreach (Machine m in machineResults)
                    {
                        using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
                        {
                            if (m.Name == mName)
                                m.ChangeOwner(WebUtilities.GetDefaultStressUserAlias());
                            sessionRef.Commit();
                        }
                    }
                    wtt.ReleaseResource(mName);
                }
                else
                {
                    //Loop through the machines, and reserve the machine when you find a match.
                    foreach (Machine m in machineResults)
                    {
                        using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
                        {
                            if (m.Name == mName)
                                m.ChangeOwner(userAlias);
                            sessionRef.Commit();
                        }
                    }
                    wtt.ReserveResource(mName, userAlias);
                }
                Response.Redirect("machines.aspx");
            }
        }

        protected void machineRepeater_ItemDataBound(Object Sender, RepeaterItemEventArgs e)
        {
            // This event is raised for the header, the footer, separators, and items.
            // Execute the following logic for Items and Alternating Items.
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                string userAlias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);
                if (((Machine)e.Item.DataItem).OwnerName.ToLower() == userAlias.ToLower())
                {
                    e.Item.FindControl("ReserveLink").Visible = false;
                    e.Item.FindControl("ReleaseLink").Visible = true;
                    HtmlTableRow row = (HtmlTableRow)e.Item.FindControl("repeaterRow");
                    row.Style[HtmlTextWriterStyle.BackgroundColor] = "green";
                }
                else if (((Machine)e.Item.DataItem).OwnerName.ToLower() == WebUtilities.GetDefaultStressUserAlias().ToLower())
                {
                    e.Item.FindControl("ReserveLink").Visible = true;
                    e.Item.FindControl("ReleaseLink").Visible = false;
                }
                else
                {
                    e.Item.FindControl("ReserveLink").Visible = false;
                    e.Item.FindControl("ReleaseLink").Visible = false;
                    HtmlTableRow row = (HtmlTableRow)e.Item.FindControl("repeaterRow");
                    row.Style[HtmlTextWriterStyle.BackgroundColor] = "red";
                }

                if (((Machine)e.Item.DataItem).Status == "Running")
                {
                    e.Item.FindControl("ReserveLink").Visible = false;
                    e.Item.FindControl("ReleaseLink").Visible = false;
                    HtmlTableRow row = (HtmlTableRow)e.Item.FindControl("repeaterRow");
                    row.Style[HtmlTextWriterStyle.BackgroundColor] = "yellow";
                }
                
            }
        }  


        /// <summary>
        /// OnInit event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }
        
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Gets an array of <c>Machine</c> objects.
        /// </summary>
        /// <returns></returns>
        private Machine[] GetMachines()
        {
            return Machine.GetAll();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\queue.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Queue page. Inherits Live Server Admin Pages BasePage
    /// Displays the currently running and waiting to be scheduled job queues.
    /// </summary>
    public class QueuePage : BasePage
    {
        /// <summary>
        /// Used to display errors to the user1
        /// </summary>
        protected Literal   errorLiteral;

        /// <summary>
        /// Panel used to hide or display teh currently running queue.
        /// </summary>
        protected Panel     currentlyRunningPanel;

        /// <summary>
        /// Repeater used to display the currently running jobs.
        /// </summary>
        protected Repeater  currentlyRunningRepeater;

        /// <summary>
        /// The repeater used to display jobs waiting to be scheduled.
        /// </summary>
        protected Repeater  queueRepeater;
        
        #region events
        /// <summary>
        /// PageLoad event handler. Calls <c>PopulateRepeaters()</c>
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            PopulateRepeaters();
        }

        /// <summary>
        /// OnInit event handler
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
        }

        #endregion
        
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Gets the lists of scheduled and unscheduled jobs and binds them to their respective repeaters
        /// </summary>
        private void PopulateRepeaters()
        {
            queueRepeater.DataSource = Run.GetUnscheduled();
            queueRepeater.DataBind();

            currentlyRunningRepeater.DataSource = Run.GetScheduled();
            currentlyRunningRepeater.DataBind();
        }

        /// <summary>
        /// OnItemDataBound event handler for the currentlyRunning repeater.
        /// sets up the cancel button for this repeater.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void CurrentlyRunning_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {
            HtmlTableCell formCell = e.Item.FindControl("buttonCell1") as HtmlTableCell;
            
            Run item = e.Item.DataItem as Run;

            if (item != null && formCell != null && !item.CancelRequested)
            {
                Button cancelButton = new Button();
                cancelButton.ID = item.Id.ToString() + "_cancel";
                cancelButton.Click += new EventHandler(Cancel_Click);
                cancelButton.Text = "Cancel";
                formCell.Controls.Add(cancelButton);
            }
        }

        /// <summary>
        /// OnItemDataBound event handler for the queue repeater
        /// Sets up the Move To Top and Cancel buttons for this repeater
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Queue_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {

            HtmlTableCell formMoveCell = e.Item.FindControl("buttonCellMove") as HtmlTableCell;
            HtmlTableCell formCancelCell = e.Item.FindControl("buttonCellCancel") as HtmlTableCell;

            Run item = e.Item.DataItem as Run;

            if (item != null && formMoveCell != null && !item.CancelRequested)
            {
                if (queueRepeater.Items.Count != 0)
                {
                    Button btn = new Button();
                    btn.ID = item.Id.ToString();
                    btn.Click += new EventHandler(QueueChange_Click);
                    btn.Text = "Move to top";
                    formMoveCell.Controls.Add(btn);
                }
                
                Button cancelButton = new Button();
                cancelButton.ID = item.Id.ToString() + "_cancel";
                cancelButton.Click += new EventHandler(Cancel_Click);
                cancelButton.Text = "Cancel";
                formCancelCell.Controls.Add(cancelButton);
            }
        }

        /// <summary>
        /// Click event handler for all cancel buttons. 
        /// Parses the id of the button to get the Id of the run to cancel, then calls <c>Run.Cancel</c>
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        protected void Cancel_Click(object sender, EventArgs args)
        {
            Button btn = sender as Button;

            if (btn == null)
            {
                return;
            }

            int id = int.Parse(btn.ID.Split('_')[0]);
            string alias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);
            string reason = String.Format(Globals.GetProperty("WebpageRunCancelReasonFormat"), alias);

            try
            {
                Run.Cancel(id, reason);
            }
            catch (Session.AlreadyLockedException)
            {
                errorLiteral.Text = "<strong><span class='color:red;'>Unable to cancel job. It is being scheduled by the WTT controller</span></strong>";
            }

            // Canceling a run could invalidate the ORM session cache
            // Spawning a new session around repeater re-populate
            using (SessionRef s = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {
                PopulateRepeaters();
            }
        }

        /// <summary>
        /// Click event handler for the refresh button.
        /// Doesn't actually do anything other than causing a post back which refreshes the repeaters.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        protected void Refresh_Click(object sender, EventArgs args)
        { 
            //Don't do anything. Just allow the post back.
        }

        /// <summary>
        /// Click event handler for the Move To Top buttons
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        protected void QueueChange_Click(object sender, EventArgs args)
        {
            Button btn = sender as Button;

            if (btn == null)
            {
                return;
            }

            using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {

                Run toBeFirstRun = Run.Get(int.Parse(btn.ID));

                if (toBeFirstRun == null)
                {
                    return;
                }

                int maxPri = 0;

                foreach (Run r in Run.GetUnscheduled())
                {
                    maxPri = System.Math.Max(maxPri, r.Priority);
                }

                maxPri++;
                            
                toBeFirstRun.Priority = maxPri;
                sessionRef.Commit();
            }

            Response.Redirect("queue.aspx", true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\RunConfigs.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Runs page. Inherits Live Server Admin Pages BasePage
    /// displays a high level report of runs in the system.
    /// </summary>
    public class RunConfigsPage : BasePage
    {
        /// <summary>
        /// The gridview used to show the list.
        /// </summary>
        protected GridView runConfigsGridView;

        /// <summary>
        /// RunConfig deletion button. NYI.
        /// </summary>
        protected Button deleteRunConfigsButton;

        /// <summary>
        /// RunConfig schedule button.
        /// </summary>
        protected Button scheduleRunConfigsButton;

        /// <summary>
        /// Environment dropdwon.
        /// </summary>
        protected DropDownList environmentDropDownList;

        /// <summary>
        /// Gets the default page size for runconfig page. We dont have that in globals, so for now we will fallback to 25.
        /// </summary>
        protected int RunConfigsPageSize
        {
            get
            {
                string property;
                if (Globals.TryGetProperty("WebpageRunConfigsPageSize", out property))
                {
                    return int.Parse(property);
                }
                else
                {
                    return 25;
                }
            }
        }

        /// <summary>
        /// The OnInit event handler.
        /// Adds the RowCreated event handler to the runGridView RunCreated event handler's list.
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            base.OnInit(e);

            this.runConfigsGridView.RowCreated += new GridViewRowEventHandler(runConfigGridView_RowCreated);
            this.deleteRunConfigsButton.Click += DeleteRunConfigsButton_Click;
            this.scheduleRunConfigsButton.Click += ScheduleRunConfigsButton_Click;

            this.environmentDropDownList.SelectedIndexChanged += new EventHandler(environmentDropDownList_SelectedIndexChanged);

            InitializeComponent();
        }

        protected void Page_Load(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Event handler for dropdown selection
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void environmentDropDownList_SelectedIndexChanged(object sender, EventArgs e)
        {
            runConfigsGridView.DataBind();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void runConfigGridView_DataBound(object sender, EventArgs e)
        {
            //If there is no record dont show buttons.
            deleteRunConfigsButton.Visible = runConfigsGridView.Rows.Count > 0;
            scheduleRunConfigsButton.Visible = runConfigsGridView.Rows.Count > 0;
        }

        /// <summary>
        /// Event handler for the RowCreated Event on the GridView
        /// Adds conditional formatting to two cells
        /// We have to manually assign the id since ORM object dont have ID public prop.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void runConfigGridView_RowCreated(object sender, GridViewRowEventArgs e)
        {
            GridViewRow row = e.Row;
            RunConfig r = e.Row.DataItem as RunConfig;
            if (r != null)
            {
                row.Cells[1].Text = r.Id.ToString() ;
            }
        }

        /// <summary>
        /// Schedule the runconfigs which are selected.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void ScheduleRunConfigsButton_Click(object sender, EventArgs e)
        {
            foreach (GridViewRow row in runConfigsGridView.Rows)
            {
                //Loop through all the rows in grid, and if checkbox is checked, then schedule the run.
                CheckBox chk = row.FindControl("SelectionBox") as CheckBox;
                if (chk != null && chk.Checked)
                {
                    using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
                    {
                        RunConfig runConfig = RunConfig.Get(int.Parse(row.Cells[1].Text));
                        Run createdRun = Run.CreateSchedule(null, runConfig, WebUtilities.GetInternalUserAlias(HttpContext.Current, false));
                        sessionRef.Commit();
                    }
                }
            }

            Response.Redirect("queue.aspx", true);
        }

        void DeleteRunConfigsButton_Click(object sender, EventArgs e)
        {
            throw new NotImplementedException("muhahahahaha.. do you think I will let you delete them?");
        }
 
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
            runConfigsGridView.PageSize = RunConfigsPageSize;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\runs.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;


namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Runs page. Inherits Live Server Admin Pages BasePage
    /// displays a high level report of runs in the system.
    /// </summary>
    public class RunsPage : BasePage
    {
        /// <summary>
        /// The gridview used to generate the report.
        /// </summary>
        protected GridView runGridView;

        protected HiddenField runIdsInGrid;

        protected Button deleteRunsButton;

        protected DropDownList buildDropDownList;

        /// <summary>
        /// Row for displaying RunConfig filter
        /// </summary>
        protected HtmlTableRow runConfigFilterRow;

        /// <summary>
        /// Gets the default page size for recent runs
        /// </summary>
        protected int RunsPageSize
        {
            get
            {
                string property;
                if (Globals.TryGetProperty("WebpageRunsPageSize", out property))
                {
                    return int.Parse(property);
                }
                else
                {
                    return 10;
                }
            }
        }

        /// <summary>
        /// The OnInit event handler.
        /// Adds the RowCreated event handler to the runGridView RunCreated event handler's list.
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            base.OnInit(e);
            this.runGridView.RowCreated += new GridViewRowEventHandler(runGridView_RowCreated);
            this.runGridView.DataBound += new EventHandler(runGridView_DataBound);
            this.runGridView.PageIndexChanging += new GridViewPageEventHandler(runGridView_PageIndexChanging);
            this.deleteRunsButton.Click += deleteRunsButton_Click;
            this.buildDropDownList.SelectedIndexChanged += new EventHandler(buildDropDownList_SelectedIndexChanged);

            int runConfigId = WebUtilities.GetParam(HttpContext.Current, "RunConfigId", true, false, 0);
            if ( runConfigId > 0)
            {
                this.runConfigFilterRow.Visible = true;
            }

            if (!IsPostBack)
            {
                runIdsInGrid.Value = "";
            }

            InitializeComponent();
        }

        void buildDropDownList_SelectedIndexChanged(object sender, EventArgs e)
        {
            runIdsInGrid.Value = "";
        }

        void runGridView_PageIndexChanging(object sender, GridViewPageEventArgs e)
        {
            runIdsInGrid.Value = "";
        }

        protected void Page_Load(object sender, EventArgs e)
        {
        }

        void runGridView_DataBound(object sender, EventArgs e)
        {
            deleteRunsButton.Visible = runGridView.Rows.Count > 0;
        }

        /// <summary>
        /// Event handler for the RowCreated Event on the GridView
        /// Adds conditional formatting to two cells
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void runGridView_RowCreated(object sender, GridViewRowEventArgs e)
        {
            GridViewRow row = e.Row;
            Run r = e.Row.DataItem as Run;
            if (r != null)
            {
                runIdsInGrid.Value += r.Id.ToString() + ",";
                CheckBox chk = row.FindControl("SelectionBox") as CheckBox;
                if (chk != null)
                {
                    if (r.Status != Run.RunStatus.Canceled && r.Status != Run.RunStatus.Complete)
                    {
                        chk.ToolTip = "A run must complete or be canceled before being deleted";
                        chk.Enabled = false;
                    }
                    else if (r.PendingCleanup)
                    {
                        chk.ToolTip = "The run is still pending resource cleanup before it can be deleted";
                        chk.Enabled = false;
                    }
                }
                e.Row.Cells[1].Attributes.Add("class", String.Format("runsPageRunStatus{0}", ((Run)e.Row.DataItem).Status.ToString()));
                e.Row.Cells[2].Attributes.Add("class", String.Format("runsPageRunResult{0}", ((Run)e.Row.DataItem).Result.ToString()));
            }
        }

        void deleteRunsButton_Click(object sender, EventArgs e)
        {
            List<int> runIds = new List<int>();
            List<int> deleteIds = new List<int>();
            foreach (string sid in runIdsInGrid.Value.Split(',')) 
            {
                int id;
                if (int.TryParse(sid, out id) && id >= 0)
                    runIds.Add(id);
            }
            if (runIds.Count != runGridView.Rows.Count)
            {
                throw new Exception("The count of rows in the grid view does not match the number of Runs parsed at bind time");
            }
            foreach (GridViewRow row in runGridView.Rows)
            {
                CheckBox chk = row.FindControl("SelectionBox") as CheckBox;
                if (chk != null && chk.Checked)
                {
                    deleteIds.Add(runIds[row.RowIndex]);
                }
            }
            if (deleteIds.Count > 0)
            {
                Run.MarkForDeletionWithIds(deleteIds.ToArray());
                HttpContext c = HttpContext.Current;
                c.Response.Redirect(c.Request.Url.PathAndQuery, true);
            }
        }
 
        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
            runGridView.PageSize = RunsPageSize;
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\RunDataSource.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Used to lookup or modify Run data in the database.
    /// </summary>
    public class RunDataSource
    {
        /// <summary>
        /// Basic constructor
        /// </summary>
        public RunDataSource()
        {
        }

        /// <summary>
        /// Gets an array of Run objects owned by the current user. 
        /// </summary>
        /// <returns>The array of Run objects</returns>
        public Run[] GetMyRecentRuns()
        {
            return Run.GetBySchedulerAlias(WebUtilities.GetInternalUserAlias(System.Web.HttpContext.Current, true));
        }

        public int CountRunsByBuild(int buildId, int runConfigId)
        {
            if (buildId == Build.AllBuilds && runConfigId == RunConfig.IdNotSpecified)
            {
                return Run.GetCount();
            }
            else if (buildId == Build.AllBuilds)
            {
                return Run.GetCountByRunConfig(runConfigId);
            }
            else if (runConfigId == RunConfig.IdNotSpecified)
            {
                return Run.GetCountByBuild(buildId);
            }
            else
            {
                return Run.GetCountByBuildAndRunConfig(buildId, runConfigId);
            }
        }

        /// <summary>
        /// Gets an array of Run objects based on a given build and or runConfigId.
        /// </summary>
        /// <param name="buildId">The buildId to query for.</param>
        /// <param name="runConfigId">The RunConfig to query for</param>
        /// <returns>The array of Run objects corresponding to the supplied BuildId.</returns>
        public Run[] GetRunsByBuild(int buildId, int runConfigId, int startIndex, int maxResults)
        {
            int cAvailable;
            if (buildId == Build.AllBuilds && runConfigId == RunConfig.IdNotSpecified)
            {
                return Run.GetAll(startIndex, maxResults, out cAvailable);
            }
            else if (buildId == Build.AllBuilds)
            {
                return Run.GetByRunConfig(runConfigId, startIndex, maxResults, out cAvailable);
            }
            else if (runConfigId == RunConfig.IdNotSpecified)
            {
                return Run.GetByBuild(buildId, startIndex, maxResults, out cAvailable);
            }
            else
            {
                return Run.GetByBuildAndRunConfig(buildId, runConfigId, startIndex, maxResults, out cAvailable);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\Utils.cs ===
//---------------------------------------------------------------------
// <copyright file="WebUtilities.cs" company="Microsoft">
//      Copyright 1999-2004 (c) Microsoft Corporation. All Rights Reserved.
//      Information Contained Herein is Proprietary and Confidential.
// </copyright>
// <summary>Static class with useful utility functions</summary>
//---------------------------------------------------------------------

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Text;
    using System.Web;
    using System.Xml;
    using System.Web.UI;
    using System.Text.RegularExpressions;
    using System.Security.Principal;
    using System.Threading;
    using Microsoft.Xna.LiveServer.LS3i.OM;

    /// <summary>
    /// Static class with utilities for the web site.
    /// </summary>
    public static class WebUtilities
    {
        /// <summary>
        /// Get a string value from either query string or form collection as required.
        /// Will trim the value.
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>string value</returns>
        public static string GetParam(NameValueCollection collection, string name, bool required, string defaultValue)
        {
            return WebUtilities.GetParam(collection, name, required, true, defaultValue);
        }

        /// <summary>
        /// Get a string value from either query string or form collection as required.
        /// Will trim the value.
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="cleansed">true if string will be cleaned</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>string value</returns>
        public static string GetParam(NameValueCollection collection, string name, bool required, bool cleansed, string defaultValue)
        {
            if (collection == null)
            {
                throw new ArgumentNullException("collection");
            }

            string val = collection[name];

            if (val != null)
            {
                val = val.Trim();
            }

            if (String.IsNullOrEmpty(val))
            {
                if (required)
                {
                    throw new Exception("Required value not present");
                }

                return defaultValue;
            }

            return val;
        }

        /// <summary>
        /// Get an long value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">Collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>long value</returns>
        public static long GetParam(NameValueCollection collection, string name, bool required, long defaultValue)
        {
            string val = WebUtilities.GetParam(collection, name, required, null);

            if (val == null)
            {
                return defaultValue;
            }

            long result;

            if (!long.TryParse(val, out result))
            {
                throw new ArgumentException("Unable to parse value");
            }

            return result;
        }

        /// <summary>
        /// Get an double value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">Collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>double value</returns>
        public static double GetParam(NameValueCollection collection, string name, bool required, double defaultValue)
        {
            string val = WebUtilities.GetParam(collection, name, required, null);

            if (val == null)
            {
                return defaultValue;
            }

            double result;

            if (!double.TryParse(val, out result))
            {
                throw new ArgumentException("Unable to parse value");
            }

            return result;
        }

        /// <summary>
        /// Get an float value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">Collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>float value</returns>
        public static float GetParam(NameValueCollection collection, string name, bool required, float defaultValue)
        {
            string val = WebUtilities.GetParam(collection, name, required, null);

            if (val == null)
            {
                return defaultValue;
            }

            float result;

            if (!float.TryParse(val, out result))
            {
                throw new ArgumentException("Unable to parse value");
            }

            return result;
        }

        /// <summary>
        /// Get an int value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">Collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>int value</returns>
        public static int GetParam(NameValueCollection collection, string name, bool required, int defaultValue)
        {
            long v = WebUtilities.GetParam(collection, name, required, (long)defaultValue);

            if (v < Int32.MinValue || v > Int32.MaxValue)
            {
                throw new ArgumentException("parsed value out of range for type");
            }

            return (int)v;
        }

        /// <summary>
        /// Get a bool value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="collection">Collection to use</param>
        /// <param name="name">arg to get</param>
        /// <param name="required">true if required</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>bool value</returns>
        public static bool GetParam(NameValueCollection collection, string name, bool required, bool defaultValue)
        {
            string val = WebUtilities.GetParam(collection, name, required, null);

            if (val == null)
            {
                return defaultValue;
            }

            bool outValue = defaultValue;
            if (bool.TryParse(val, out outValue))
            {
                return outValue;
            }

            return defaultValue;
        }

        /// <summary>
        /// Get a string value from either query string or form collection as required.
        /// Will trim the value.
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>string value</returns>
        public static string GetParam(HttpContext context, string name, bool queryString, bool required, string defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Get a string value from either query string or form collection as required.
        /// Will trim the value.
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="cleanse">true if string needs to be cleansed</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>string value</returns>
        public static string GetParam(HttpContext context, string name, bool queryString, bool required, bool cleanse, string defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, cleanse, defaultValue);
        }

        /// <summary>
        /// Get an integer value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>int value</returns>
        public static int GetParam(HttpContext context, string name, bool queryString, bool required, int defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Get a long value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>long value</returns>
        public static long GetParam(HttpContext context, string name, bool queryString, bool required, long defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Get a double value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>double value</returns>
        public static double GetParam(HttpContext context, string name, bool queryString, bool required, double defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Get a float value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>float value</returns>
        public static float GetParam(HttpContext context, string name, bool queryString, bool required, float defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Get an bool value from the qs/form
        /// If there is no value (or it's empty, after trimming) the default is returned.
        /// If required then an exception is thrown if missing.
        /// </summary>
        /// <param name="context">context to get from</param>
        /// <param name="name">arg to get</param>
        /// <param name="queryString">true if from query string, else form</param>
        /// <param name="required">true if required (will throw if not present)</param>
        /// <param name="defaultValue">Default to use if not present</param>
        /// <returns>bool value</returns>
        public static bool GetParam(HttpContext context, string name, bool queryString, bool required, bool defaultValue)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            NameValueCollection collection = queryString ? context.Request.QueryString : context.Request.Form;
            return WebUtilities.GetParam(collection, name, required, defaultValue);
        }

        /// <summary>
        /// Retrieves the alias of the user under the specified context.
        /// </summary>
        /// <param name="context">Context that will be used to retrieve the user's identity</param>
        /// <param name="validate">If <c>true</c>, this method will check that the user name is in the form: DOMAIN\USER</param>
        /// <returns></returns>
        public static string GetInternalUserAlias(HttpContext context, bool validate)
        {
            string name = context.User.Identity.Name.ToString();
            string[] tokens = name.Split('\\');
            if (tokens.Length != 2 || String.IsNullOrEmpty(tokens[1]) || tokens[1].Length > 8)
            {
                if (validate)
                    throw new Exception(String.Format("Alias '{0}' is invalid.", tokens[1]));
                else
                    return name;
            }
            else
            {
                return tokens[1];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GetDefaultStressUserAlias()
        {
            return "xblstress";
        }

        /// <summary>
        /// Replaces the name of a TestNet server with the name of its matching CorpNet IP or server name.
        /// </summary>
        /// <param name="testNetUrn">URN to perform the replace operation</param>
        /// <returns>The URN with the CorpNet server/IP instead</returns>
        /// <remarks>
        /// The provided URN is scanned for a server name using regular expression: \\(?<Server>[a-zA-Z0-9_\.]+)\(?<Path>.+)
        /// The 'Server' group is then searched in the Globals database as SERVERNAME_CORPNETIP and the value of the property
        /// is used instead.
        /// </remarks>
        public static string ReplaceWithCorpNetUrn(string testNetUrn)
        {
            Regex r = new Regex(@"\\\\(?<Server>[a-zA-Z0-9_\.\-]+)\\(?<Path>.+)");
            Match m = r.Match(testNetUrn);
            if (m.Success)
            {
                string testNetServer = m.Groups["Server"].Value.ToUpper();
                string testNetPath = m.Groups["Path"].Value;
                string corpNetServer;
                if (Globals.TryGetProperty(testNetServer + "_CORPNETIP", out corpNetServer))
                {
                    return String.Format(@"\\{0}\{1}", corpNetServer, testNetPath);
                }
            }
            return testNetUrn;
        }

        /// <summary>
        /// Attempts to parse the client version from the UserAgent string as sent by the user's web browser
        /// </summary>
        /// <param name="context">HttpContext for the current request</param>
        /// <param name="major">Output parameter for the OS major version</param>
        /// <param name="minor">Output parameter for the OS minor version</param>
        /// <returns><c>true</c> if the OS version could be parsed from the string, <c>false</c> otherwise</returns>
        public static bool GetClientOSVersion(HttpContext context, out int major, out int minor)
        {
            major = minor = -1;
            Regex r = new Regex(@"Windows NT (?<Major>\d+)\.(?<Minor>\d+)");
            Match m = r.Match(context.Request.UserAgent);
            return m.Success && int.TryParse(m.Groups["Major"].Value, out major) && int.TryParse(m.Groups["Minor"].Value, out minor);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\RunConfigDataSource.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Used to look up or modify RunConfig data in the database.
    /// </summary>
    public class RunConfigDataSource
    {
        /// <summary>
        /// Basic constructor
        /// </summary>
        public RunConfigDataSource()
        {
        }

        /// <summary>
        /// Returns an array of RunConfig objects based off results searching for the supplied keywords.
        /// </summary>
        /// <param name="keywords">The keywords to search fro</param>
        /// <returns>an array of RunConfig objects</returns>
        public RunConfig[] GetRunConfigsByKeywords(string keywords)
        {
            if (keywords == null)
                keywords = "";

            return RunConfig.SearchByName(keywords, 0, -1);
        }

        /// <summary>
        /// Get all runconfig for a given environment.
        /// </summary>
        /// <param name="environmentName">Name of environment. e.g StressNet or StressNet2</param>
        /// <returns>An array of RunConfig objects.</returns>
        public RunConfig[] GetAllRunConfigsByEnvironment(string environmentName)
        {
            return RunConfig.GetAllByEnvironment(environmentName);
        }

        /// <summary>
        /// Returns an array of RunConfig objects based off the Identity of the current user.
        /// </summary>
        /// <returns>an array of RunConfig objects</returns>
        public RunConfig[] GetMyRunConfigs()
        {
            return RunConfig.SearchByOwner(WebUtilities.GetInternalUserAlias(System.Web.HttpContext.Current, true));
        }

        /// <summary>
        /// Deletes the RunConfig with the supplied id
        /// </summary>
        /// <param name="id">the Id of the RunConfig to delete.</param>
        public void DeleteRunConfig(int id)
        {
            RunConfig.Get(id).Erase();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\schedule.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.IO;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using Microsoft.Xna.LiveServer;
using Microsoft.Xna.LiveServer.WebPages;
using Microsoft.Xna.LiveServer.WebPages.MasterPages;
using Microsoft.Xna.LiveServer.Platform.Orm;
using Microsoft.Xna.LiveServer.LS3i.OM;

namespace Microsoft.Xna.LiveServer.LS3i.WebPages
{
    /// <summary>
    /// Schedule page. Inherits Live Server Admin Pages BasePage
    /// Displays RunConfig based on ID passed on Query string. Allows for creating a Run based off that RunConfig.
    /// </summary>
    public class SchedulePage : BasePage
    {
        // $$ericvo: We need to make come from the UI when we do pagination
        private const int MaxResults = 20;

        /// <summary>
        /// Text box for input of build number
        /// </summary>
        protected TextBox       buildTextBox;

        /// <summary>
        /// Text box for input of RunConfiguration Name
        /// </summary>
        protected TextBox       configurationNameTextBox;

        /// <summary>
        /// Text box for input of RunConfiguration Description
        /// </summary>
        protected TextBox       configurationDescriptionTextBox;

        /// <summary>
        /// Button for copying RunConfig that belongs to another user
        /// </summary>
        protected Button        copyConfigButton;

        /// <summary>
        /// Button for copying the runconfig if the user already owns the RunConfig
        /// </summary>
        protected Button        copyMyRunConfigButton;

        /// <summary>
        /// Button for copying RunConfig owned by the system
        /// </summary>
        protected Button        copySystemConfigButton;

        /// <summary>
        /// Button for saving changes only.
        /// </summary>
        protected Button        saveOnlyButton;

        /// <summary>
        /// Button for saving changes and scheduling a run.
        /// </summary>
        protected Button        saveScheduleButton;

        /// <summary>
        /// Button for taking ownership of this RunConfig;
        /// </summary>
        protected Button        takeOwnerShipButton;

        /// <summary>
        /// Table Cell for extra tools.
        /// </summary>
        protected HtmlTableCell myTools;

        /// <summary>
        /// Literal for displaying error messages to user.
        /// </summary>
        protected Literal       resultLiteral;

        /// <summary>
        /// Panel used to warn user that this runConfig belongs to another user
        /// </summary>
        protected Panel         notYoursPanel;

        /// <summary>
        /// Panel used to warn user that this runConfig belongs to the system
        /// </summary>
        protected Panel         notYoursSystemPanel;

        /// <summary>
        /// Webcontrol for displaying WTT parameters and corresponding input fields
        /// </summary>
        protected parameters    parameterWc;

        /// <summary>
        /// Dropdownlist for displaying existing environments
        /// </summary>
        protected DropDownList  environmentDropDownList;

        /// <summary>
        /// Dropdownlist for displaying existing builds.
        /// </summary>
        protected DropDownList  buildDropDownList;
        
        /// <summary>
        /// Current runconfig id. default of 0.
        /// </summary>
        public int currentConfigId = 0;

        /// <summary>
        /// Current runconfig
        /// </summary>
        private RunConfig currentRunConfig;

        /// <summary>
        /// Readonly flag
        /// </summary>
        private bool m_ReadOnly;

        /// <summary>
        /// Gets or sets 
        /// </summary>
        protected bool ReadOnly
        {
            get
            {
                return m_ReadOnly;
            }

            set
            {
                m_ReadOnly = value;
            }
        }

        #region events
        /// <summary>
        /// Click Event handler for the Save button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Save_Click(object sender, EventArgs e)
        {
            if (SaveForm())
            {
                Response.Redirect(String.Format("schedule.aspx?configid={0}", this.currentConfigId), true);
            }
        }

        /// <summary>
        /// Click event handler for the Save & Schedule button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void SaveSchedule_Click(object sender, EventArgs e)
        {
            if (SaveForm())
            {
                Schedule();
            }
        }

        /// <summary>
        /// Click event handler for the Copy button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ConfigCopy_Click(object sender, EventArgs e)
        {
            RunConfig newConfig;
            string userAlias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);

            using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {
                newConfig = RunConfig.CreateCopy(currentRunConfig, userAlias);
                newConfig.Name = "Copy of: " + currentRunConfig.Name;
                sessionRef.Commit();
            }

            Button senderButton = sender as Button;

            string redirectFormat = (senderButton != null && senderButton.ID == "copyMyRunConfig") ?
                "Schedule.aspx?configid={0}&allowCopy=false" :
                "Schedule.aspx?configid={0}";
            
            Response.Redirect(String.Format(redirectFormat, newConfig.Id), true);
        }

        /// <summary>
        /// Click event handler for the Take Ownership button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void TakeOwnership_Click(object sender, EventArgs e)
        {
            string userAlias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);

            using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {
                RunConfig temp = RunConfig.Get(this.currentConfigId);
                temp.OwnerAlias = userAlias;
                sessionRef.Commit();
            }

            Response.Redirect(String.Format("Schedule.aspx?configid={0}", currentConfigId), true);
        }

        /// <summary>
        /// OnInit event handler.
        /// Sets up the page including looking up the current RunConfig, populating the Parameters control and setting the readOnly flag
        /// </summary>
        /// <param name="e"></param>
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();

            base.OnInit(e);
            // wait until after base.OnInit to init ORM session..

            if (!IsPostBack)
            {
                m_ReadOnly = false;
            }

            currentConfigId = WebUtilities.GetParam(HttpContext.Current, "configid", true, false, 0);

            if (currentConfigId > 0)
            {
                parameterWc.ReadOnly = m_ReadOnly;

                try
                {
                    currentRunConfig = RunConfig.Get(currentConfigId);
                }
                catch (PersistedBase.InvalidIdException)
                {
                    Response.Redirect("default.aspx", true);
                    return;
                }

                configurationDescriptionTextBox.Enabled = !m_ReadOnly;
                configurationNameTextBox.Enabled = !m_ReadOnly;

                // Make sure we're editing a run config owned by this user.
                string userAlias = WebUtilities.GetInternalUserAlias(HttpContext.Current, true);
                if (String.Compare(currentRunConfig.OwnerAlias, userAlias, true) != 0)
                {
                    // Don't allow edits of default run configs.
                    if (currentRunConfig.IsDefault)
                    {
                        this.notYoursSystemPanel.Visible = true;
                        this.saveOnlyButton.Enabled = false;
                        this.saveScheduleButton.Enabled = false;
                        this.parameterWc.ReadOnly = true;
                        this.configurationDescriptionTextBox.Enabled = false;
                        this.configurationNameTextBox.Enabled = false;
                        this.buildDropDownList.Enabled = false;
                        this.buildTextBox.Enabled = false;
                        this.environmentDropDownList.Enabled = false;
                    }
                    else
                    {
                        notYoursPanel.Visible = true;
                    }
                }
                else
                {
                    copyMyRunConfigButton.Visible = true;
                    copyMyRunConfigButton.Enabled = (WebUtilities.GetParam(HttpContext.Current, "allowCopy", true, false, true));
                }

                if (!IsPostBack)
                {
                    this.configurationNameTextBox.Text = currentRunConfig.Name;
                    this.configurationDescriptionTextBox.Text = currentRunConfig.Description;
                }
            }
            else 
            {
                Response.Redirect("default.aspx", true);
            }
        }

        #endregion

        /// <summary>
        /// IntializeComponent is called from OnInit. 
        /// </summary>
        private void InitializeComponent()
        {
            
        }

        /// <summary>
        /// Does the work of validating the form and saving the data.
        /// </summary>
        /// <returns></returns>
        private bool SaveForm()
        {
            using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {
                Dictionary<string, object> submittedValues;
                bool validForm = parameterWc.FillParamaters(out submittedValues);
                RunConfig runConfig = RunConfig.Get(this.currentConfigId);

                if (validForm)
                {
                    RunConfigData runConfigData = runConfig.RunConfigData;
                    runConfig.BeginEdit();
                    runConfigData.Environment = environmentDropDownList.SelectedValue;

                    foreach (JobParameter param in runConfig.Job.Parameters)
                    {
                        if (submittedValues.ContainsKey(param.Name))
                        {
                            switch (param.Type)
                            {
                                case JobParameter.ParameterType.Boolean:
                                    runConfigData.AddParameterValue(param.Name, String.Compare(((string)submittedValues[param.Name]), "Yes", true) == 0 );
                                    break;

                                case JobParameter.ParameterType.String:
                                    runConfigData.AddParameterValue(param.Name, ((string)submittedValues[param.Name])); 
                                    break;

                                case JobParameter.ParameterType.File:
                                    if ((FileData)submittedValues[param.Name] != null)
                                    {
                                        runConfigData.AddParameterValue(param.Name, ((FileData)submittedValues[param.Name]));
                                    }
                                    break;
                            }
                        }
                    }

                    resultLiteral.Text = "<p><strong>Configuration Saved</strong></p>";
                    runConfig.Name = configurationNameTextBox.Text.ToString();
                    runConfig.Description = configurationDescriptionTextBox.Text.ToString();

                    runConfig.EndEdit();
                    sessionRef.Commit();
                }
                else
                {
                    resultLiteral.Text = "<P><span style='color:red'><strong> FORM IS NOT VALID!! </strong></span></P>";
                }

                if (validForm)
                {
                    ReadOnly = true;
                }

                resultLiteral.Visible = true;
                return validForm;
            }
            
        }

        /// <summary>
        /// Creates a run based on the current RunConfig.
        /// </summary>
        private void Schedule()
        {
            using (SessionRef sessionRef = Microsoft.Xna.LiveServer.Platform.Orm.Session.Create())
            {
                Build build = null;
                int buildId = int.Parse(buildDropDownList.SelectedValue);
                switch (buildId)
                {
                    case Build.NonAssociated:
                        // No associated build
                        break;

                    case Build.NewBuild:
                        // Create new build
                        string buildName = buildTextBox.Text.Trim();
                        if (buildName.Length > 0)
                            build = Build.Create(buildName);
                        break;

                    default:
                        build = Build.Get(buildId);
                        break;
                }

                RunConfig runConfig = RunConfig.Get(currentConfigId);
                Run createdRun = Run.CreateSchedule(build, runConfig, WebUtilities.GetInternalUserAlias(HttpContext.Current, false));
                sessionRef.Commit();
            }
            
            Response.Redirect("queue.aspx", true);
        }
    }

    #region Data sources
    /// <summary>
    /// DataSource for environment data
    /// </summary>
    public class EnvironmentDataSource
    {
        /// <summary>
        /// Basic constructor
        /// </summary>
        public EnvironmentDataSource()
        {
        }

        /// <summary>
        /// Gets all environments in the system from the <c>Globals</c> object.
        /// </summary>
        /// <returns></returns>
        public string[] GetEnvironments()
        {
            return Globals.GetProperty("WebpageScheduleEnvironments").Split(',');
        }
    }

    /// <summary>
    /// DataSource for Build data
    /// </summary>
    public class BuildDataSource
    {
        /// <summary>
        /// Lightwight object for displaying build data on web page. Ment to be a lighter copy of the Build object.
        /// </summary>
        public class BuildData
        {
            /// <summary>
            /// Build name
            /// </summary>
            string m_name;

            /// <summary>
            /// Build ID
            /// </summary>
            int m_id;

            /// <summary>
            /// Gets the name
            /// </summary>
            public string Name 
            { 
                get 
                { 
                    return m_name; 
                } 
            }

            /// <summary>
            /// Gets the ID
            /// </summary>
            public int Id 
            { 
                get 
                { 
                    return m_id; 
                } 
            }

            /// <summary>
            /// Copy constructor. Copies the Name and Id fields from the supplied Build to a BuildData object.
            /// </summary>
            /// <param name="b"></param>
            public BuildData(Build b)
            {
                m_id = b.Id;
                m_name = b.Name;
            }
            
            /// <summary>
            /// Basic constructor. Intializes a BuildData object with the supplied values.
            /// </summary>
            /// <param name="id"></param>
            /// <param name="name"></param>
            public BuildData(int id, string name)
            {
                m_id = id;
                m_name = name;
            }
        }

        /// <summary>
        /// Basic constructor
        /// </summary>
        public BuildDataSource()
        {
        }

        /// <summary>
        /// Gets an array of build objects from the database, converts them into an array of BuildData objects and returns them.
        /// </summary>
        /// <returns></returns>
        public BuildData[] GetBuilds()
        {
            List<BuildData> builds = new List<BuildData>();

            builds.Add(new BuildData(Build.NonAssociated, "No associated build"));

            foreach (Build b in Build.GetAll())
            {
                if (!String.IsNullOrEmpty(b.Name))
                {
                    builds.Add(new BuildData(b));
                }
            }

            builds.Add(new BuildData(Build.NewBuild, "New build ..."));

            return builds.ToArray();
        }

        /// <summary>
        /// Gets an array of build objects from the database filtered by Runs, converts them into an array of BuildData objects and returns them.
        /// </summary>
        /// <returns></returns>
        public BuildData[] GetBuildFilter()
        {
            List<BuildData> builds = new List<BuildData>();

            builds.Add(new BuildData(Build.AllBuilds, "All builds"));
            builds.Add(new BuildData(Build.NonAssociated, "No associated build"));

            foreach (Build b in Build.GetAllForRuns())
            {
                if (!String.IsNullOrEmpty(b.Name))
                {
                    builds.Add(new BuildData(b));
                }
            }

            return builds.ToArray();
        }
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_none_12.4.56.0_none_4ad970a439211130
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.webpages
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.webpages,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\website\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_none_12.4.56.0_none_4ad970a439211130
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.xna.liveserver.ls3i.webpages
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.cat
XP_CATALOG_PATH=manifests\msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968.cat
XP_PAYLOAD_PATH=msil_microsoft.xna.liveserver.ls3i.webpages_no-public-key_12.4.56.0_x-ww_0db2d968
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.xna.liveserver.ls3i.webpages,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\WTT\src\strrepalce\strreplace.cs ===
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;

namespace strreplace
{
    class strreplace
    {

        [STAThread]
        public static int Main(string[] args)
        {

            if (args.Length == 0 || args[0].Contains("?") || args[0].ToLower().Contains("help"))
            {
                ShowUsage();
                return 1;
            }

            Dictionary<string, string> dict = new Dictionary<string, string>();
            
            try
            {
                for (int i = 0; i < args.Length; i++)
                {
                    string[] nvpair = args[i].Split("=".ToCharArray());
                    dict.Add(nvpair[0], nvpair[1]);
                }
            }
            catch 
            {
                Console.WriteLine("Error parsing the input parameters.");
                ShowUsage();
                return 1;
            }

            //If we are told to work on specific file, do that and return.
            string fileName = string.Empty;
            if (dict.ContainsKey("filename"))
                fileName = dict["filename"];
            if (!string.IsNullOrEmpty(fileName))
            {
                bool b = ParseFile(fileName, dict);
                if (b == false)
                    Console.WriteLine("Nothing to change for " + fileName);
                return 0;
            }

            //If we are told to work on specific directory, do that and return.
            string dirName = string.Empty;
            if (dict.ContainsKey("dirname"))
                dirName = dict["dirname"];
            else
                dirName = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);

            string extensions = string.Empty;
            if (dict.ContainsKey("ext"))
                extensions = dict["ext"];
            else
                extensions = ".txt.cfg.ini.xml";

            string[] files = null;
            files = Directory.GetFiles(dirName);

            foreach (string file in files)
            {
                //if this extension is in our list, parse it.
                if (extensions.Contains(System.IO.Path.GetExtension(file)))
                {
                    //Parse The file.
                    bool b = ParseFile(file, dict);
                    if (b == false)
                        Console.WriteLine("Nothing to change for " + file);
                }
            }

            return 0;

         }

        static void ShowUsage()
        {
            Console.WriteLine("This will scan the directory in which the exe is, and replace the tokens.");
            Console.WriteLine("user need to pass the name value pairs seperated by = sign.");
            Console.WriteLine("Usage: strreplace @INSTANCENAME=ContentServerInstanceName");
            Console.WriteLine("Note. if filename parameter is given, it will process only that file.");
            Console.WriteLine("Note. if dirname parameter is given, it will process all files in that dir.");
            Console.WriteLine("Note. default is GetExecutingAssembly().Location");
            Console.WriteLine("Note. if ext is provided it will look for only those extension.");
            Console.WriteLine("Note. default ext is .txt.cfg.ini.xml yeah, I know its not very good way to get parameter.");
            Console.WriteLine("Note. Enclose the values in quotes if they have spaces in it");
        }

        static bool ParseFile(string filename, Dictionary<string, string> dict)
        {
            string strFileContents = null;
            //read the file.
            try
            {
                using (TextReader reader = new StreamReader(filename))
                {
                    strFileContents = reader.ReadToEnd();
                }
            }

            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                return false;
            }

            string strOldContent = strFileContents;

            foreach (KeyValuePair<string, string> kvp in dict)
            {
                strFileContents = strFileContents.Replace(kvp.Key, kvp.Value);
            }

            if (strOldContent == strFileContents)
            {
                //Everything is same. Get out.
                return false;
            }

            //write back to file.
            try
            {
                using (TextWriter writer = new StreamWriter(filename))
                {
                    writer.Write(strFileContents);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                return false;
            }

            return true;
 
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\Ls3iStress\WTT\src\createdsn\Program.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace CreateODBCDataSource
{
    class Program
    {
        static int Main(string[] args)
        {
            int pass = 0;
            int fail = 1;

            if (args.Length != 2)
            {
                ShowHelpMsg();
                return fail;
            }

            Dictionary<string, string> dict = new Dictionary<string, string>();
            try
            {
                foreach (string arg in args)
                {
                    string[] nvpair = arg.Split("=".ToCharArray());
                    dict.Add(nvpair[0], nvpair[1]);
                }
            }
            catch
            {
                //Will throw if for any reason we couldn't generate name value pairs.
                ShowHelpMsg();
                return fail;
            }

            if (!(dict.ContainsKey("server") || dict.ContainsKey("db")))
            {
                ShowHelpMsg();
                return fail;
            }

            if (string.IsNullOrEmpty(dict["server"]) || string.IsNullOrEmpty(dict["db"]))
            {
                ShowHelpMsg();
                return fail;
            }

            if (Helper.CreateSystemDSN("XBLStress", dict["server"], dict["db"]))
            {
                return pass;
            }
            else
            {
                return fail;
            }
        }
        static void ShowHelpMsg()
        {
            Console.WriteLine("Usage: CreateODBCDataSource.exe server=<instanceName> db=<dbName>");
        }
    }

    class Helper
    {
        public static bool CreateSystemDSN(string dsnName, string serverName, string dbName)
        {
            string driver="SQL Server";
            string attribs;
            uint NULL_HWND = 0;
            attribs = "SERVER=" + serverName + Convert.ToChar(0);
            attribs = attribs + "DESCRIPTION=Xbox LIVE Stress test reporting DSN" + Convert.ToChar(0);
            attribs = attribs + "DSN=" + dsnName + Convert.ToChar(0);
            attribs = attribs + "DATABASE=" + dbName + Convert.ToChar(0);
            attribs = attribs + "Trusted_Connection=yes" + Convert.ToChar(0);

            //If this fails, that means it doesn't exist, so create it.
            int intRet = win32apis.SQLConfigDataSource(NULL_HWND, win32apis.ODBC_CONFIG_SYS_DSN, driver, attribs);
            if (intRet != 1)
                intRet = win32apis.SQLConfigDataSource(NULL_HWND, win32apis.ODBC_ADD_SYS_DSN, driver, attribs);
            //If this is still failing, something is wrong.
            if (intRet == 1)
                return true;
            return false;
        }
    }

    internal class win32apis
    {
        internal const int ODBC_ADD_SYS_DSN = 4;
        internal const int ODBC_CONFIG_SYS_DSN = 5;

        [DllImport("ODBCCP32.DLL", CharSet = CharSet.Unicode)]
        internal extern static int SQLConfigDataSource(uint hwndParent, int fRequest, string lpszDriver, string lpszAttributes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\InputFiles\LiveTitle\ArcadeMappedGenres\Config update FFFE080E.spa.h ===
////////////////////////////////////////////////////////////////////
//
// Config update FFFE080E.spa.h
//
// Auto-generated on Monday, 24 March 2008 at 11:22:57
// XLAST project version 1.0.28.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __TEST_GAME_FFFE080E_SPA_H__
#define __TEST_GAME_FFFE080E_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_TEST_GAME_FFFE080E                  0xFFFE080E

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE_MODE              0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RANKING                            0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A12                             2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A2                              12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     2

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERRY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 13


#ifdef __cplusplus
}
#endif

#endif // __TEST_GAME_FFFE080E_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\InputFiles\LiveTitle\ArcadeMappedGenres\FFFE080E.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE080E.spa.h
//
// Auto-generated on Monday, 31 March 2008 at 10:40:11
// XLAST project version 1.0.32.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_TEST_GAME_FFFE080E_SPA_H__
#define __MKP_TEST_GAME_FFFE080E_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_TEST_GAME_FFFE080E              0xFFFE080E

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE_MODE              0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RANKING                            0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A12                             2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A2                              12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     2

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERRY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 13


#ifdef __cplusplus
}
#endif

#endif // __MKP_TEST_GAME_FFFE080E_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\InputFiles\LiveTitle\TitleMediaRatings\Test Config for TID FFFE080A.spa.h ===
////////////////////////////////////////////////////////////////////
//
// Test Config for TID FFFE080A.spa.h
//
// Auto-generated on Friday, 07 March 2008 at 11:37:14
// XLAST project version 1.0.15.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __TEST_GAME_SPA_H__
#define __TEST_GAME_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_TEST_GAME                           0xFFFE080A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_RICH_PRESENCE              0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_MODE_0                    0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_MODE_0              0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_MODE_0            0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD_FOR_TID_080A        1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD_FOR_TID_080A


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//


//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __TEST_GAME_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\InputFiles\LiveTitle\TitleMediaRatings\FFFE080A.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE080A.spa.h
//
// Auto-generated on Thursday, 03 April 2008 at 16:47:12
// XLAST project version 1.0.19.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_TESTGAME_FFFE080A_SPA_H__
#define __MKP_TESTGAME_FFFE080A_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_TESTGAME_FFFE080A               0xFFFE080A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_RICH_PRESENCE              0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_MODE_0                    0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_MODE_0              0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_MODE_0            0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD_FOR_TID_080A        1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD_FOR_TID_080A


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//


//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __MKP_TESTGAME_FFFE080A_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livetools-4998-functional_none_12.4.56.0_none_8b82707701d0bf5f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetools-4998-functional
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.manifest
XP_MANIFEST_PATH=manifests\msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.cat
XP_CATALOG_PATH=manifests\msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.cat
XP_PAYLOAD_PATH=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetools-4998-functional,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livetools-4998-functional_none_12.4.56.0_none_8b82707701d0bf5f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livetools-4998-functional
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.manifest
XP_MANIFEST_PATH=manifests\msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.cat
XP_CATALOG_PATH=manifests\msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1.cat
XP_PAYLOAD_PATH=msil_livetools-4998-functional_no-public-key_12.4.56.0_x-ww_0f3ec9f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livetools-4998-functional,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\TestDataMigration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;

namespace LiveTools_4998_Functional
{
    /*
     * LiveTitle, LiveContent, LiveOffer
     */
    public static class TestDataMigration
    {
        /* FUNCTIONS NEEDED:
         *  
         * Create a directory if one doesn't exist.
         * Create an xml file if one doesn't exist.
         * Open an xml file.
         * Read an xml file.
         * Extract filenames from xml & copy files to directory.
         * Add a new node with data to an xml file.
         * Close an xml file.
         */
        public enum TestType
        {
            LIVE_TITLE,
            LIVE_CONTENT,
            LIVE_OFFER,
        };

        private static string liveTitleTestsXml = "LiveTitleTests.xml";
        private static string liveContentTestsXml = "LiveContentTests.xml";
        private static string liveOfferTestsXml = "LiveOfferTests.xml";
        private static string liveToolsPath = "C:\\ESP\\Webroot\\xbltools\\";
        private static string absoluteDirectoryPath = "C:\\LiveToolsInputFiles\\";
        private static string relativeDirectoryPath;
        private static string nameOfTest;
        private static string fullFileName;
        private static TestType testType;
        
        private static void CreateDirectory(string relativePath)
        {
            //If the directory already exists, this function does nothing.
            Directory.CreateDirectory(absoluteDirectoryPath + relativePath);
        }

        public static void StartTestCapture(TestType type, string relativePath, string testName, string description, string titleId, string consoleTypeId, string offerIds)
        {

            //Values needed for main test files:
            //Name
            //Description
            //TitleId
            //ConsoleTypeId
            //OfferIds
            testType = type;
            relativeDirectoryPath = relativePath + "\\";
            nameOfTest = testName;
            fullFileName = absoluteDirectoryPath + relativeDirectoryPath + nameOfTest + "\\" + TestTypeToText(type) + ".xml";

            CreateDirectory(relativeDirectoryPath + nameOfTest);
            CreateBaseXmlDocument();

            string xmlFileToUse = "FAIL";
            string elementToAppend = "FAIL";
            if (testType == TestType.LIVE_TITLE)
            {
                xmlFileToUse = liveTitleTestsXml;
                elementToAppend = "LiveTitleTest";
            } 
            if (testType == TestType.LIVE_CONTENT)
            {
                xmlFileToUse = liveContentTestsXml;
                elementToAppend = "LiveContentTest";
            }
            if (testType == TestType.LIVE_OFFER)
            {
                xmlFileToUse = liveOfferTestsXml;
                elementToAppend = "LiveOfferTest";
            }
                
            AppendNewTestToMainList(absoluteDirectoryPath + xmlFileToUse, elementToAppend, nameOfTest, description, titleId, consoleTypeId, offerIds);


         }

        public static void MigrateTest(string commandLine, string arguments)
        {

            commandLine = commandLine.Replace(liveToolsPath, ""); //remove the path for livetools, just leave the executable name

            //Creates the test folder & xml file
            arguments = ReplaceValueInArgument(arguments, "/lbs:", "%LBS%");
            arguments = ReplaceValueInArgument(arguments, "/matchsvr:", "%MATCHSVR%");
            FindAndCopyFiles(arguments, "/xlastpath:", "Image");
            FindAndCopyFiles(arguments, "/offerfile:", "imageFilePath");
            FindAndCopyFiles(arguments, "/offerfile2:", "imageFilePath");
            FindAndCopyFiles(arguments, "/package:", null);
            FindAndCopyFiles(arguments, "-file:", "imageFilePath");
            FindAndCopyFiles(arguments, "-ExpireFilename:", null);
            arguments = RemoveAbsolutePath(arguments, "/xlastpath:");
            arguments = RemoveAbsolutePath(arguments, "/ltcpath:");
            arguments = RemoveAbsolutePath(arguments, "/package:");
            arguments = RemoveAbsolutePath(arguments, "/offerfile:");
            arguments = RemoveAbsolutePath(arguments, "/offerfile2:");
            arguments = RemoveAbsolutePath(arguments, "-file:");
            arguments = RemoveArgument(arguments, "/tempdir", '/');
            arguments = RemoveArgument(arguments, "/shares:", '/');
            arguments = RemoveArgument(arguments, "/xrls:", ' ');

            AppendCommandLineNode(fullFileName, commandLine, arguments);

            //Appends the test to the main test files

        }

        private static void CreateBaseXmlDocument()
        {
            XmlTextWriter writer = new XmlTextWriter(fullFileName, null);

            writer.WriteStartDocument();

            writer.WriteStartElement("CommandLines");
            writer.WriteEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        private static void CreateMainTestXmlDocument()
        {
            //<LiveTitleTests>
            //  <LiveTitleTest Name="Sample Test Case" Description="Sample Test Case" TitleId="00000000" ConsoleTypeId="0" />
            //</LiveTitleTests>
            XmlTextWriter writer = new XmlTextWriter(absoluteDirectoryPath + liveTitleTestsXml, null);

            writer.WriteStartDocument();

            writer.WriteStartElement("LiveTitleTests");
            writer.WriteEndElement();

            writer.WriteEndDocument();
            writer.Close();


            //<LiveContentTests>
            //  <LiveContentTest Name="Sample Test Case" Description="Sample Test Case" TitleId="00000000" ConsoleTypeId="0" OfferIds="0000000000000000" />
            //</LiveContentTests>
            writer = new XmlTextWriter(absoluteDirectoryPath + liveContentTestsXml, null);

            writer.WriteStartDocument();

            writer.WriteStartElement("LiveContentTests");
            writer.WriteEndElement();

            writer.WriteEndDocument();
            writer.Close();

            //<LiveOfferTests>
            //  <LiveOfferTest Name="Sample Test Case" Description="Sample Test Case" TitleId="00000000" ConsoleTypeId="0" OfferIds="0000000000000000" />
            //</LiveOfferTests>
            writer = new XmlTextWriter(absoluteDirectoryPath + liveOfferTestsXml, null);

            writer.WriteStartDocument();

            writer.WriteStartElement("LiveOfferTests");
            writer.WriteEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        private static XmlDocument LoadXmlDocument(string file)
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(file);
            return doc;
        }

        private static void AppendCommandLineNode(string xmlFile, string commandLine, string arguments)
        {
            XmlDocument doc = LoadXmlDocument(xmlFile);

            XmlNode newNode = doc.CreateNode("element", "CommandLine", "");
            newNode.InnerText = commandLine + " " + arguments;

            XmlElement root = doc.DocumentElement;
            root.AppendChild(newNode);

            doc.Save(xmlFile);
 
        }

        private static void AppendNewTestToMainList(string xmlFile, string elementName, string name, string description, string titleId, string consoleTypeId, string offerIds)
        {
            if (!File.Exists(xmlFile))
                CreateMainTestXmlDocument();

            XmlDocument doc = LoadXmlDocument(xmlFile);

            XmlNode newNode = doc.CreateNode("element", elementName, "");

            if (name != null)
            {
                XmlAttribute nameAttrib = doc.CreateAttribute("Name");
                nameAttrib.Value = name;
                newNode.Attributes.Append(nameAttrib);
            }

            if (description != null)
            {
                XmlAttribute descriptionAttrib = doc.CreateAttribute("Description");
                descriptionAttrib.Value = description;
                newNode.Attributes.Append(descriptionAttrib);
            }

            if (titleId != null)
            {
                XmlAttribute titleIdAttrib = doc.CreateAttribute("TitleId");
                titleIdAttrib.Value = titleId;
                newNode.Attributes.Append(titleIdAttrib);
            }

            if (consoleTypeId != null)
            {
                XmlAttribute consoleTypeIdAttrib = doc.CreateAttribute("ConsoleTypeId");
                consoleTypeIdAttrib.Value = consoleTypeId;
                newNode.Attributes.Append(consoleTypeIdAttrib);
            }

            if (offerIds != null)
            {
                XmlAttribute offerIdsAttrib = doc.CreateAttribute("OfferIds");
                offerIdsAttrib.Value = offerIds;
                newNode.Attributes.Append(offerIdsAttrib);
            }            

            XmlElement root = doc.DocumentElement;
            root.AppendChild(newNode);

            doc.Save(xmlFile);
        }

        private static void FindAndCopyFiles(string arguments, string argumentToFind, string imageTag)
        {
            if (arguments.Contains(argumentToFind))
            {
                int index = arguments.IndexOf(argumentToFind);
                index += argumentToFind.Length;

                //remove the current value for this argument
                index = arguments.IndexOf('\"', index) + 1;
                int endIndex = arguments.IndexOf('\"', index + 1);

                string fileName = arguments.Substring(index, endIndex - index);

                if (File.Exists(fileName))
                {
                    File.Copy(fileName, absoluteDirectoryPath + relativeDirectoryPath + nameOfTest + "\\" + fileName.Substring(fileName.LastIndexOf('\\') + 1), true);

                    FileInfo info = new FileInfo(fileName);
                    if (imageTag != null && info.Length > 0 && !info.Extension.EndsWith("txt"))
                    {
                        XmlDocument doc = new XmlDocument();
                        doc.Load(fileName);

                        XmlNodeList imageNodes = doc.GetElementsByTagName(imageTag);

                        foreach (XmlNode image in imageNodes)
                        {
                            string imageFileName = image.InnerText;

                            if (!imageFileName.Contains("\\"))
                                imageFileName = "\\" + imageFileName;

                            string source = fileName.Substring(0, fileName.LastIndexOf('\\')) + imageFileName;
                            string dest = absoluteDirectoryPath + relativeDirectoryPath + nameOfTest + "\\" + imageFileName.Substring(imageFileName.LastIndexOf('\\') + 1);

                            if(File.Exists(source))
                                File.Copy(source, dest, true);
                        }
                    }
                }
            }
        }

        private static string ReplaceValueInArgument(string arguments, string argumentToFind, string replacementValue)
        {
            if (arguments.Contains(argumentToFind))
            {
                int index = arguments.IndexOf(argumentToFind);
                
                //remove the current value for this argument
                int endIndex = index + argumentToFind.Length;
                while (endIndex < arguments.Length && arguments[endIndex] != ' ')
                    ++endIndex;

                arguments = arguments.Replace(arguments.Substring(index, endIndex - index), argumentToFind + replacementValue);
            }
            return arguments;
        }

        private static string RemoveAbsolutePath(string arguments, string argumentToFind)
        {
            if (arguments.Contains(argumentToFind))
            {
                int index = arguments.IndexOf(argumentToFind);

                string testTypeStr = TestTypeToText(testType);

                //remove the current value for this argument
                index = arguments.IndexOf('\"', index) + 1;
                int endIndex = arguments.IndexOf('\"', index);
                if (endIndex < 0)
                {
                    endIndex = arguments.Length;
                }

                string pathToTrim = arguments.Substring(index, endIndex - index);
                int trimEndIndex = pathToTrim.LastIndexOf("\\");

                arguments = arguments.Replace(pathToTrim.Substring(0, trimEndIndex), nameOfTest);
            }
            return arguments;
        }

        private static string RemoveArgument(string arguments, string argumentToFind, char delimiter)
        {
            if (!arguments.Contains(argumentToFind))
                return arguments;

            int index = arguments.IndexOf(argumentToFind);

            //remove the current value for this argument
            int endIndex = arguments.IndexOf(delimiter, index + 1);
            if (endIndex < 0)
            {
                endIndex = arguments.Length;
            }
            
            string argToRemove = arguments.Substring(index, endIndex - index);
            arguments = arguments.Replace(argToRemove, " ");

            return arguments;
        }

        private static string TestTypeToText(TestType type)
        {
            switch (type)
            {
                case TestType.LIVE_TITLE:
                    return "LiveTitle";

                case TestType.LIVE_CONTENT:
                    return "LiveContent";

                case TestType.LIVE_OFFER:
                    return "LiveOffer";
            }

            return "BAD_TYPE";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\ISampleAdapter.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.Protocols.TestTools;
using Adapter.CatalogWebService;

namespace Adapter
{

    public interface ISampleAdapter : IAdapter
    {
        void GetLegalText();
        void SaveLegalText(int id, int lcid);
     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\Enums.cs ===
﻿namespace InputTypes
{
    public enum ChangeType
    {
        Add,
        Update,
        Delete
    }
    
    public enum InsertChangeType
    {
        Add,
        Update
    }

    public enum IdType
    {
        Existing,
        New
    }

    public enum TreeParentIdType
    {
        Self,
        ExistingNotSelf,
        NonExisting,
        None
    }

    public enum ShortStringType
    {
        Null,
        Empty,
        Length50,
        Length51
    }

    public enum MediumStringType
    {
        Null,
        Empty,
        Length255,
        Length256,
        Length500,
        Length501
    }

    public enum LongStringType
    {
        Null,
        Empty,
        Length2000,
        Length2001
    }

    public enum XmlType
    {
        Null,
        Empty,
        Valid,
//        WellFormed,
//        NotWellFormed,
        Invalid
    }

    public enum IntegerType
    {
        Negative,
        MinValue,
        MaxValue,
        Existing
    }

    public enum ContentBitFilterType
    {
        Existing
    }

    public enum DecimalType
    {
        Negative,
        MinValue,
        MaxValue,
        Existing,
    }

    public enum RelatedItemIdType
    {
        NotSpecified,
        Existing
    }

    public enum DateTimeType
    {
        Past,
        Today,
        Future,
        Max
    }

    public enum ArrayType
    {
        Null,
        Empty,
        OnlyOneElement,
        TwoElementsOneEmpty,
        Full
    }

    public enum OfferType
    {
        Standalone,
        StandaloneAllEpisodeSeason,
        StandaloneAllEpisodeSeries,
        VideoSeason,
        VideoSeries
    }

    public enum PublishingVisibilityStatusType
    {
        Live,
        NoChange,
        Withdraw
    }

    public enum ExternalFeedArrayType
    {
        FeedSource,
        MappingObject
    }

    public enum FindType
    {
        Null,
        Existing,
        New
    }

    public enum MaxRows
    {
        Length0,
        Length1,
        Length250,
        Length251,
        Length500
    }

    public enum StringType
    {
        Null,
        ExistingFull,
        ExistingFirst,
        ExistingMiddle,
        ExistingLast,
        New
    }

    public enum ServiceType
    {
        CorrectHeader,
        WrongHeader,
        NoHeader
    }
}

namespace ReturnTypes
{
    public class ExternalMappingTableItem
    {
        public int catalogId;
        public string externalId;
        public int feedSourceId;
        public int externalmappingObjectId;
        public InputTypes.ChangeType DataChangeType;
    }
    
    public class ExceptionType
    {
        private ExceptionType(bool isError)
        {
            if (Adapter.Configuration.EnableErrors == false && isError == true)
            {
                Microsoft.Modeling.Contracts.Requires(false);
            }
        }

        public override string ToString()
        {
            return GetType().ToString().Replace("ReturnTypes.ExceptionType+","").Replace("Type","");
        }

        public class NoErrorType : ExceptionType { public NoErrorType(bool isError) : base(isError) { } }
        public class SqlParameterMissingExceptionType : ExceptionType { public SqlParameterMissingExceptionType(bool isError) : base(isError) { } }
        public class ArgumentNullExceptionType : ExceptionType { public ArgumentNullExceptionType(bool isError) : base(isError) { } }
        public class NotSupportedExceptionType : ExceptionType { public NotSupportedExceptionType(bool isError) : base(isError) { } }
        public class ArgumentExceptionType : ExceptionType { public ArgumentExceptionType(bool isError) : base(isError) { } }
        public class SqlPrimaryKeyViolationExceptionType : ExceptionType { public SqlPrimaryKeyViolationExceptionType(bool isError) : base(isError) { } }
        public class InvalidPodcastUriExceptionType : ExceptionType { public InvalidPodcastUriExceptionType(bool isError) : base(isError) { } }
        public class NoQualifiedMediaInstanceExceptionType : ExceptionType { public NoQualifiedMediaInstanceExceptionType(bool isError) : base(isError) { } }
        public class XmlSchemaValidationExceptionType : ExceptionType { public XmlSchemaValidationExceptionType(bool isError) : base(isError) { } }
        public class WebSGErrorExceptionType : ExceptionType { public WebSGErrorExceptionType(bool isError) : base(isError) { } }
        public static string NoError
        {
            get { return new NoErrorType(false).ToString(); }
        }

        public static string SqlParameterMissingException
        {
            get { return new SqlParameterMissingExceptionType(true).ToString(); }
        }

        public static string ArgumentNullException
        {
            get { return new ArgumentNullExceptionType(true).ToString(); }
        }
        public static string NotSupportedException
        {
            get { return new NotSupportedExceptionType(true).ToString(); }
        }

        public static string ArgumentException
        {
            get { return new ArgumentExceptionType(true).ToString(); }
        }

        public static string SqlPrimaryKeyViolationException
        {
            get { return new SqlPrimaryKeyViolationExceptionType(true).ToString(); }
        }

        public static string InvalidPodcastUriException
        {
            get { return new InvalidPodcastUriExceptionType(true).ToString(); }
        }

        public static string NoQualifiedMediaInstanceException
        {
            get { return new NoQualifiedMediaInstanceExceptionType(true).ToString(); }
        }

        public static string XmlSchemaValidationException
        {
            get { return new XmlSchemaValidationExceptionType(true).ToString(); }
        }

        public static string WebSGErrorException
        {
            get { return new WebSGErrorExceptionType(true).ToString();}
        }
    }

    //public enum ExceptionType
    //{
    //    NoError,
    //    SqlParameterMissingException,
    //    ArgumentNullException,
    //    NotSupportedException,
    //    ArgumentException
    //}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\ICatalogWebServiceAdapter.cs ===
﻿using System;
using InputTypes;
using ReturnTypes;

using Microsoft.Protocols.TestTools;

namespace Adapter
{
    public interface ICatalogWebServiceAdapter : IAdapter
    {
        string SaveAudioEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType service);
        string SaveCategory(ChangeType change, IdType id, IdType categorySystemId, TreeParentIdType parentCategoryId, ArrayType locales, ArrayType categories, ArrayType localeMap, ServiceType service);
        string SaveContributor(ChangeType change, IdType id, DateTimeType birthDate, MediumStringType birthPlace, DateTimeType deathDate, MediumStringType deathPlace, ShortStringType displayBirthDate, ShortStringType displayDeathDate, bool isGroup, RelatedItemIdType metadataProviderId, ArrayType aliases, ArrayType articles, ArrayType categories, ArrayType locales, ArrayType relationships, ServiceType service);
        string SaveEntity(ServiceType service, ChangeType change, IdType id, MediumStringType name, MediumStringType contactInfo, ShortStringType accountNumber, ShortStringType externalEntityId, bool isProvider, bool isMetadataProvider, bool isDrmLicenseIssuer);
        string SaveGame(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, IntegerType liveTitleId, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType gameLocales, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);
//        string SaveGameConsumable(ChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, IntegerType effectiveLiveTitleId, RelatedItemIdType gameMediaId, bool geoCheckPolicy, IntegerType liveTitleAssetId, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, IntegerType providerCategoryId, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus);
        string SaveGameContent(InsertChangeType change, IdType id, bool consumable, ShortStringType displayOriginalReleaseDate, IntegerType effectiveLiveTitleId, RelatedItemIdType gameMediaId, bool geoCheckPolicy, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ContentBitFilterType contentBitFilter, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);
        string SaveImage(InsertChangeType change, IdType id, MediumStringType creator, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, MediumStringType issuer, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);
        string SaveLicenseType(ServiceType service, ChangeType change, IdType id, RelatedItemIdType licenseClassId, ShortStringType name, XmlType xml, ArrayType legalTextLocales);
        string SaveOffer(InsertChangeType change, IdType id, RelatedItemIdType mediaId, MediumStringType name, OfferType offerMode, ArrayType offerInstances, ArrayType offerStores, ServiceType service);
        string SavePricingRule(ServiceType service,ChangeType change, IdType id, RelatedItemIdType countryCode, RelatedItemIdType currencyCodeRetail, RelatedItemIdType currencyCodeWholesale, RelatedItemIdType mediaType, ShortStringType name, RelatedItemIdType provider, DecimalType rate, DecimalType margin, DateTimeType startDate, ArrayType pricingRuleInstances);
        string SavePublishingBatchRequest(ChangeType change, DateTimeType offerStartTime, DateTimeType offerEndTime, PublishingVisibilityStatusType visibilityStatus, ArrayType publishingIds, ServiceType service);
        string SaveTask(ServiceType service, XmlType xml);
        string SaveTask(ServiceType service, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType taskStatusId);
        string SaveDRMTask(ServiceType service, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType mediaInstanceId, bool isDRMRequired, RelatedItemIdType taskStatusId);
        string SaveVideo(InsertChangeType change, IdType id, ShortStringType crid, ShortStringType displayOriginalReleaseDate, IntegerType duration, IntegerType episodeNumber, bool geoCheckPolicy, ShortStringType isan, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, RelatedItemIdType spokenLanguage, ShortStringType subTitle, ShortStringType upc, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);
        string SaveVideoEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType service);
        string SaveVideoSeason(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isComplete, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, IntegerType seasonNumber, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);
        string SaveVideoSeries(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isOrderBySeason, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service);

        string GetArticle(IdType id, ServiceType service);
        string GetArticleArray(ArrayType ids, ServiceType service);
        string GetAudioEncodingArray(ServiceType service);
        string GetCategorySystem(IdType id, ServiceType service);
        string GetCategorySystemArray(ServiceType service);
        string GetClientTypeArray(ServiceType service);
        string GetContributor(IdType id, ServiceType service);
        string GetContributorArray(ArrayType ids, ServiceType service);
        string GetContributorRelationshipTypeArray(ServiceType service);
        string GetCountry(IdType id, ServiceType service);
        string GetCountryArray(ServiceType service);
        string GetCurrency(IdType id, ServiceType service);
        string GetCurrencyArray(ServiceType service);
        string GetDRMLicenseIssuer(IdType id, ServiceType service);
        string GetDRMLicenseIssuerArray(ServiceType service);
        string GetEntity(IdType id, ServiceType service);
        string GetEntityArray(ServiceType service);
        string GetGame(IdType id, ServiceType service);
//        string GetGameConsumable(IdType id);
        string GetGameContent(IdType id, ServiceType service);
        string GetImage(IdType id, ServiceType service);
        string GetImageFormat(ServiceType service);
        string GetImageSizeArray(ServiceType service);
        string GetLicenseClass(IdType id, ServiceType service);
        string GetLicenseClassArray(ServiceType service);
        string GetLicenseType(IdType id, ServiceType service);
        string GetLicenseTypeArray(ServiceType service);
        string GetLocaleArray(ServiceType service);
//        string GetMediaConcernArray(IdType id);
//        string GetMediaConcernCountArray(IdType id, DateTimeType submittedAfter, IntegerType threshold, IntegerType maxRows);
//        string GetMediaOffer(IdType id);
        string GetMediaRelationshipTypeArray(ServiceType service);
        string GetMediaTypeArray(ServiceType service);
        string GetMetadataProvider(IdType id, ServiceType service);
        string GetMetadataProviderArray(ServiceType service);
        string GetOffer(IdType id, ServiceType service);
        string GetPodcastById(IdType id, ServiceType service);
        string GetPodcastByUri(IdType id, ServiceType service);
//        string GetPodcastSubmissionsArray(IntegerType maxRows);
        string GetPreviewMediaInstanceTypeArray(ServiceType service);
        string GetPricingRule(IdType id, ServiceType service);
        string GetPricingRuleArray(ServiceType service);
        string GetProvider(IdType id, ServiceType service);
        string GetProviderArray(ServiceType service);
        string GetRatingSystem(IdType id, ServiceType service);
        string GetRatingSystemArray(ServiceType service);
        string GetRoleArray(ServiceType service);
        string GetStoreArray(ServiceType service);
        string GetTasks(ServiceType service);
        string GetAvailableTaskAsXML(ServiceType service);
        string GetTaskStatusArray(ServiceType service);
        string GetTaskByStatus(IdType id, ServiceType service);
        string GetUserTypeArray(ServiceType service);
        string GetVideo(IdType id, ServiceType service);
        string GetVideoDefinitionArray(ServiceType service);
        string GetVideoEncodingArray(ServiceType service);
        string GetVideoSeason(IdType id, ServiceType service);
        string GetVideoSeries(IdType id, ServiceType service);
        string GetVisibilityLevelArray(ServiceType service);
        string GetVisibilityStatusArray(ServiceType service);
        string GetAvailableEntityId(ServiceType service);
        string GetAvailableCategoryId(ServiceType service);
        string GetAvailableCategorySystemId(ServiceType service);
        string GetAvailableRatingSystemId(ServiceType service);
        string GetAvailableRatingValueId(ServiceType service);
        string GetAvailableRatingDescriptorId(ServiceType service);
        string GetAvailableLicenseTypeId(ServiceType service);
        string GetCatalogId(ServiceType service);
        string GetExternalId(ServiceType service);
        string GetExternalFeedSource(ServiceType service);
        string GetExternalFeedMappingObject(ServiceType service);
        string SaveExternalFeedMapping1(ServiceType service);
        string SaveExternalFeedMapping2();
        string SaveExternalFeedMapping3();
        string Ping(ServiceType service);
        string PurgeTaskQueue(ServiceType service);
        string GetPaymentMethod(IdType id, ServiceType service);
        string GetPaymentMethodArray(ServiceType service);
        string GetExternalFeedSourceArray(ServiceType service);
        string GetExternalFeedMappingObjectArray(ServiceType service);
        string GameOfferSearch(StringType Title, MaxRows rows, ServiceType service);
        string GamePublisherSearch(FindType Id, MaxRows rows, ServiceType service);
        string GameTitleSearch(StringType Title, IntegerType Lcid, MaxRows rows, ServiceType service);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveTools-4998-Functional")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("LiveTools-4998-Functional")]
[assembly: AssemblyCopyright("Copyright ©  2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("168ec298-0437-4a4f-8f17-9881bb853704")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\MyCatalogServicesWrongHeader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace ContentIngestionService
{
    public class MyCatalogServicesWrongHeader : CatalogServices
    {
        /// <summary>
        /// OverRidden Implementation for GetWebRequest
        /// </summary>
        /// <param name="uri"></param>
        /// <returns></returns>
        protected override System.Net.WebRequest GetWebRequest(Uri uri)
        {
            System.Net.HttpWebRequest webRequest = (System.Net.HttpWebRequest)base.GetWebRequest(uri);
            webRequest.Headers.Add("Subject-Name", "MarketplaceInternalPartner1");
            webRequest.Headers.Add("Client-IP-Port", "127.0.0.1:80");
            webRequest.Headers.Add("RequestId", "xyz");

            return webRequest;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\MyCatalogServices.cs ===
﻿using System;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;

namespace ContentIngestionService
{
    public class MyCatalogServices : CatalogServices
    {
     
        private static RNGCryptoServiceProvider cryptoProvider = new RNGCryptoServiceProvider();
        
        /// <summary>
        /// OverRidden Implementation for GetWebRequest
        /// </summary>
        /// <param name="uri"></param>
        /// <returns></returns>
        protected override System.Net.WebRequest GetWebRequest(Uri uri)
        {
            System.Net.HttpWebRequest webRequest = (System.Net.HttpWebRequest)base.GetWebRequest(uri);
            webRequest.Headers.Add("Subject-Name", "MarketplaceInternalPartner");
            webRequest.Headers.Add("Client-IP-Port", "10.124.130.132:80");
            webRequest.Headers.Add("RequestId", GetRandomRequestId());

            return webRequest;
        }
        
        /// <summary>
        /// Generates Random Request ID
        /// </summary>
        /// <returns></returns>
        private string GetRandomRequestId()
        {
            byte[] randomBytes = new byte[8];
            cryptoProvider.GetBytes(randomBytes);
            StringBuilder sb = new StringBuilder(randomBytes.Length * 2);
            foreach (byte b in randomBytes)
            {
                sb.AppendFormat("{0:x2}", b);
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\CatalogWebServiceAdapter.cs ===
using System;

using Microsoft.Protocols.TestTools;
using ContentIngestionService;
using System.Diagnostics;

using InputTypes;
using ReturnTypes;
using System.Data;
using System.Collections.Generic;

namespace Adapter
{
    public class CatalogWebServiceAdapter : ManagedAdapterBase, ICatalogWebServiceAdapter
    {
        private static CatalogServices service;

        private static MyCatalogServices serviceCorrectHeader;

        private static MyCatalogServicesWrongHeader serviceWrongHeader;

        public static CatalogServices ServiceInstance
        {
            get { return service; }
        }

        public static MyCatalogServices ServiceInstanceHeader
        {
            get { return serviceCorrectHeader; }
        }

        public static MyCatalogServicesWrongHeader ServiceInstanceWrongHeader
        {
            get { return serviceWrongHeader; }
        }

        static CatalogWebServiceAdapter()
        {
            service = new CatalogServices();
            service.Url = Properties.Settings.Default.WebServiceUrl;

            serviceCorrectHeader = new MyCatalogServices();
            serviceCorrectHeader.Url = Properties.Settings.Default.WebServiceUrl;

            serviceWrongHeader = new MyCatalogServicesWrongHeader();
            serviceWrongHeader.Url = Properties.Settings.Default.WebServiceUrl;
        }

        public string SaveAudioEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType serviceType)
        {
            AudioEncoding encoding = new AudioEncoding();
            encoding.Name = Utilities.GetString(name);
            encoding.Id = Utilities.GetId(id, "AudioEncoding", "audioEncodingId");
            encoding.Modified = Utilities.ConvertChangeType(change);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveAudioEncoding(encoding);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveAudioEncoding(encoding);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveAudioEncoding(encoding);
                        break;

                }
                
                if (encoding.Modified != DataChangeType.Delete)
                {
                    DataSet expected = new DataSet();
                    DataSet actual = new DataSet();
                    expected = Utilities.ActualDataset("AudioEncoding", encoding.Id, ref actual);
                    Utilities.ExpectedDatasetAudioEncoding(encoding, ref expected, typeof(AudioEncoding));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                    return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveCategory(ChangeType change, IdType id, IdType categorySystemId, TreeParentIdType parentCategoryId, ArrayType locales, ArrayType categories, ArrayType localeMap, ServiceType serviceType)
        {
            Category category = new Category();
            category.Id = Utilities.GetId(id, "Category", "categoryId");
            category.Categories = Utilities.GetArray<Category>(categories, "CategorySystem", "categorySystemId", "GetCategorySystem", new Category(), "Categories", "Categories");
            category.CategoryLocaleMap = Utilities.GetArray<CategoryLocaleMap>(localeMap, "CategoryLocale", "lcid", null, new CategoryLocaleMap(), "FromLcid", "DefaultLCID");
            category.CategorySystemId = Utilities.GetId(categorySystemId, "CategorySystem", "categorySystemId");
            category.Locales = Utilities.GetArray<CategoryLocale>(locales, "Locale", "lcid", null, new CategoryLocale(), "Lcid", "Locales");
            category.Modified = Utilities.ConvertChangeType(change);
            category.ParentCategoryId = Utilities.GetParentId(parentCategoryId, "Category", "categoryId", category.Id);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveCategory(category);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveCategory(category);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveCategory(category);
                        break;

                }
                
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveContributor(ChangeType change, IdType id, DateTimeType birthDate, MediumStringType birthPlace, DateTimeType deathDate, MediumStringType deathPlace, ShortStringType displayBirthDate, ShortStringType displayDeathDate, bool isGroup, RelatedItemIdType metadataProviderId, ArrayType aliases, ArrayType articles, ArrayType categories, ArrayType locales, ArrayType relationships, ServiceType serviceType)
        {
            Contributor contributor = new Contributor();
            contributor.Modified = Utilities.ConvertChangeType(change);
            contributor.BirthDate = Utilities.GetDateTime(birthDate);
            contributor.BirthPlace = Utilities.GetString(birthPlace);
            contributor.DeathDate = Utilities.GetDateTime(deathDate);
            contributor.DeathPlace = Utilities.GetString(deathPlace);
            contributor.DisplayBirthDate = Utilities.GetString(displayBirthDate);
            contributor.DisplayDeathDate = Utilities.GetString(displayDeathDate);
            contributor.Id = Utilities.GetGuid(id, "Contributor", "contributorId");
            contributor.IsGroup = isGroup;
            contributor.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            contributor.Aliases = Utilities.GetArray<ContributorAlias>(aliases, "Contributor", "contributorId", "GetContributor", new ContributorAlias(), "Alias", "Aliases");
            contributor.Articles = Utilities.GetArray<ContributorArticle>(articles, "Contributor", "contributorId", "GetContributor", new ContributorArticle(), "ArticleId", "Articles");
            contributor.Categories = Utilities.GetArray<ContributorCategory>(categories, "Contributor", "contributorId", "GetContributor", new ContributorCategory(), "CategoryId", "Categories");
            contributor.Locales = Utilities.GetArray<ContributorLocale>(locales, "Contributor", "contributorId", "GetContributor", new ContributorLocale(), "Lcid", "Locales");
            contributor.Relationships = Utilities.GetArray<ContributorRelationship>(relationships, "Contributor", "contributorId", "GetContributor", new ContributorRelationship(), "RoleId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveContributor(contributor);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveContributor(contributor);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveContributor(contributor);
                        break;

                }
                
                if (contributor.Modified != DataChangeType.Delete)
                {
                    DataSet expected = new DataSet();
                    DataSet actual = new DataSet();
                    expected = Utilities.ActualDataset("Contributor", contributor.Id, ref actual);
                    Utilities.ExpectedDataSetContributor(contributor, ref expected, typeof(Contributor));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveEntity(ServiceType serviceType, ChangeType change, IdType id, MediumStringType name, MediumStringType contactInfo, ShortStringType accountNumber, ShortStringType externalEntityId, bool isProvider, bool isMetadataProvider, bool isDrmLicenseIssuer)
        {
            Entity entity = new Entity();
            entity.AccountNumber = Utilities.GetString(accountNumber);
            entity.ContactInfo = Utilities.GetString(contactInfo);
            entity.Name = Utilities.GetString(name);
            entity.ExternalEntityId = Utilities.GetString(externalEntityId);
            entity.Id = Utilities.GetId(id, "Provider", "providerId");
            entity.IsDrmLicenseIssuer = isDrmLicenseIssuer;
            entity.IsMetadataProvider = isMetadataProvider;
            entity.IsProvider = isProvider;
            entity.Modified = Utilities.ConvertChangeType(change);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveEntity(entity);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveEntity(entity);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveEntity(entity);
                        break;

                }
                if (entity.Modified != DataChangeType.Delete && id == IdType.New)
                {
                    DataSet expected = new DataSet();
                    DataSet actual = new DataSet();
                    expected = Utilities.ActualDataset("Entity", entity.Id, ref actual);
                    Utilities.ExpectedDatasetEntity(entity, ref expected, typeof(Entity));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveGame(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, IntegerType liveTitleId, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType gameLocales, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            Game game = new Game();
            game.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            game.GeoCheckPolicy = geoCheckPolicy;
            game.Id = Utilities.GetGuid(id, "Game", "gameMediaId");
            game.LiveTitleId = Utilities.GetInteger(liveTitleId, "Game", "liveTitleId");
            game.MediaTitle = Utilities.GetString(mediaTitle);
            game.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            game.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            game.Modified = Utilities.ConvertInsertChangeType(change);
            game.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            game.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            game.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            game.Articles = Utilities.GetArray<MediaArticle>(articles, "Game", "gameMediaId", "GetGame", new MediaArticle(), "ArticleId", "Articles");
            game.Categories = Utilities.GetArray<MediaCategory>(categories, "Game", "gameMediaId", "GetGame", new MediaCategory(), "CategoryId", "Categories");
            game.Contributors = Utilities.GetArray<MediaContributor>(contributors, "Game", "gameMediaId", "GetGame", new MediaContributor(), "ContributorId", "Contributors");
            game.GameLocales = Utilities.GetArray<GameLocale>(gameLocales, "Game", "gameMediaId", "GetGame", new GameLocale(), "Lcid", "GameLocales");
            game.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "Game", "gameMediaId", "GetGame", new VideoInstance(), "Id", "Instances");
            game.Locales = Utilities.GetArray<MediaLocale>(locales, "Game", "gameMediaId", "GetGame", new MediaLocale(), "Lcid", "Locales");
            game.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "Game", "gameMediaId", "GetGame", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            game.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "Game", "gameMediaId", "GetGame", new MediaRating(), "RatingValueId", "RatingValues");
            game.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "Game", "gameMediaId", "GetGame", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveGame(game);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveGame(game);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveGame(game);
                        break;

                }
                DataSet expected = new DataSet();
                DataSet actual = new DataSet();
                expected = Utilities.ActualDataset("Game", game.Id, ref actual);
                Utilities.ExpectedDataSetGame(game, ref expected, typeof(Game));
                Utilities.CompareDataset(actual, expected);
                
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        /*        public string SaveGameConsumable(ChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, IntegerType effectiveLiveTitleId, RelatedItemIdType gameMediaId, bool geoCheckPolicy, IntegerType liveTitleAssetId, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, IntegerType providerCategoryId, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus)
                {
                    GameConsumable gameConsumable = new GameConsumable();
                    gameConsumable.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
                    gameConsumable.EffectiveLiveTitleId = Utilities.GetInteger(effectiveLiveTitleId, "GameContent", "effectiveLiveTitleId");
                    gameConsumable.GameMediaId= Utilities.GetRelatedItemIdGuid(gameMediaId, "Game", "gameMediaId");
                    gameConsumable.GeoCheckPolicy = geoCheckPolicy;
                    gameConsumable.Id = Utilities.GetGuid(id, "GameConsumable", "gameAssetMediaId");
                    gameConsumable.LiveTitleAssetId = Utilities.GetInteger(liveTitleAssetId, "GameConsumable", "liveTitleAssetId");
                    gameConsumable.MediaTitle = Utilities.GetString(mediaTitle);
                    gameConsumable.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
                    gameConsumable.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
                    gameConsumable.Modified = Utilities.ConvertChangeType(change);
                    gameConsumable.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
                    gameConsumable.ProviderCategoryId = Utilities.GetInteger(providerCategoryId, "GameContent", "providerCategoryId");
                    gameConsumable.VisibilityDate = Utilities.GetDateTime(visibilityDate);
                    gameConsumable.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");

                    try
                    {
                        service.SaveGameConsumable(gameConsumable);
                    }
                    catch (Exception e)
                    {
                        return Utilities.GetExceptionType(e);
                    }

                    return ExceptionType.NoError;
                }
        */

        public string SaveGameContent(InsertChangeType change, IdType id, bool consumable, ShortStringType displayOriginalReleaseDate, IntegerType effectiveLiveTitleId, RelatedItemIdType gameMediaId, bool geoCheckPolicy, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ContentBitFilterType contentBitFilter, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            GameContent gameContent = new GameContent();
            gameContent.Consumable = consumable;
            gameContent.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            gameContent.EffectiveLiveTitleId = Utilities.GetInteger(effectiveLiveTitleId, "GameContent", "effectiveLiveTitleId");
            gameContent.GameMediaId = Utilities.GetRelatedItemIdGuid(gameMediaId, "Game", "gameMediaId");
            gameContent.GeoCheckPolicy = geoCheckPolicy;
            gameContent.Id = Utilities.GetGuid(id, "GameConsumable", "gameAssetMediaId");
            gameContent.MediaTitle = Utilities.GetString(mediaTitle);
            gameContent.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            gameContent.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            gameContent.Modified = Utilities.ConvertInsertChangeType(change);
            gameContent.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            gameContent.ContentBitFilter = (int)Utilities.GetContentBitFilter(contentBitFilter, "GameContent", "contentBitFilter");
            gameContent.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            gameContent.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            gameContent.Articles = Utilities.GetArray<MediaArticle>(articles, "GameContent", "gameContentMediaId", "GetGameContent", new MediaArticle(), "ArticleId", "Articles");
            gameContent.Categories = Utilities.GetArray<MediaCategory>(categories, "GameContent", "gameContentMediaId", "GetGameContent", new MediaCategory(), "CategoryId", "Categories");
            gameContent.Contributors = Utilities.GetArray<MediaContributor>(contributors, "GameContent", "gameContentMediaId", "GetGameContent", new MediaContributor(), "ContributorId", "Contributors");
            gameContent.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "GameContent", "gameContentMediaId", "GetGameContent", new VideoInstance(), "Id", "Instances");
            gameContent.Locales = Utilities.GetArray<MediaLocale>(locales, "GameContent", "gameContentMediaId", "GetGameContent", new MediaLocale(), "Lcid", "Locales");
            gameContent.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "GameContent", "gameContentMediaId", "GetGameContent", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            gameContent.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "GameContent", "gameContentMediaId", "GetGameContent", new MediaRating(), "RatingValueId", "RatingValues");
            gameContent.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "GameContent", "gameContentMediaId", "GetGameContent", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveGameContent(gameContent);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveGameContent(gameContent);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveGameContent(gameContent);
                        break;

                }

                DataSet expected = new DataSet();
                DataSet actual = new DataSet();
                expected = Utilities.ActualDataset("GameContent", gameContent.Id, ref actual);
                Utilities.ExpectedDatasetGameContent(gameContent, ref expected, typeof(GameContent));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveImage(InsertChangeType change, IdType id, MediumStringType creator, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, MediumStringType issuer, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            Image image = new Image();
            image.Creator = Utilities.GetString(creator);
            image.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            image.GeoCheckPolicy = geoCheckPolicy;
            image.Id = Utilities.GetGuid(id, "Image", "imageMediaId");
            image.Issuer = Utilities.GetString(issuer);
            image.MediaTitle = Utilities.GetString(mediaTitle);
            image.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            image.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            image.Modified = Utilities.ConvertInsertChangeType(change);
            image.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            image.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            image.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            image.Articles = Utilities.GetArray<MediaArticle>(articles, "Image", "imageMediaId", "GetImage", new MediaArticle(), "ArticleId", "Articles");
            image.Categories = Utilities.GetArray<MediaCategory>(categories, "Image", "imageMediaId", "GetImage", new MediaCategory(), "CategoryId", "Categories");
            image.Contributors = Utilities.GetArray<MediaContributor>(contributors, "Image", "imageMediaId", "GetImage", new MediaContributor(), "ContributorId", "Contributors");
            image.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "Image", "imageMediaId", "GetImage", new VideoInstance(), "Id", "Instances");
            image.Locales = Utilities.GetArray<MediaLocale>(locales, "Image", "imageMediaId", "GetImage", new MediaLocale(), "Lcid", "Locales");
            image.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "Image", "imageMediaId", "GetImage", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            image.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "Image", "imageMediaId", "GetImage", new MediaRating(), "RatingValueId", "RatingValues");
            image.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "Image", "imageMediaId", "GetImage", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveImage(image);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveImage(image);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveImage(image);
                        break;

                }

                DataSet expected = new DataSet();
                DataSet actual = new DataSet();
                expected = Utilities.ActualDataset("Image", image.Id, ref actual);
                Utilities.ExpectedDatasetImage(image, ref expected, typeof(Image));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveLicenseType(ServiceType serviceType, ChangeType change, IdType id, RelatedItemIdType licenseClassId, ShortStringType name, XmlType xml, ArrayType legalTextLocales)
        {
            LicenseType licenseType = new LicenseType();
            licenseType.Modified = Utilities.ConvertChangeType(change);
            licenseType.Id = Utilities.GetId(id, "LicenseType", "licenseTypeId");
            licenseType.LicenseClassId = Utilities.GetRelatedItemId(licenseClassId, "LicenseClass", "licenseClassId");
            licenseType.Name = Utilities.GetString(name);
            licenseType.LicenseXML = Utilities.GetXml(xml);
            licenseType.LegalTextLocales = Utilities.GetArray<LicenseTypeLegalTextLocale>(legalTextLocales, "LicenseTypeLegalTextLocale", "legalLcid", null, new LicenseTypeLegalTextLocale(), "Legaltextlcid", null);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveLicenseType(licenseType);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveLicenseType(licenseType);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveLicenseType(licenseType);
                        break;
                }
                if (licenseType.Modified != DataChangeType.Delete)
                {
                    DataSet actual = new DataSet();
                    DataSet expected = new DataSet();
                    expected = Utilities.ActualDataset("LicenseType", licenseType.Id, ref actual);
                    Utilities.ExpectedDataSetLicenseType(licenseType, ref expected, typeof(LicenseType));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveOffer(InsertChangeType change, IdType id, RelatedItemIdType mediaId, MediumStringType name, OfferType offerMode, ArrayType instances, ArrayType stores, ServiceType serviceType)
        {
            Offer offer = new Offer();
            offer.Id = Utilities.GetGuid(id, "Offer", "offerId");
            offer.MediaId = Utilities.GetRelatedItemIdGuid(mediaId, "Media", "mediaId");
            offer.Modified = Utilities.ConvertInsertChangeType(change);
            offer.Name = Utilities.GetString(name);
            offer.OfferType = Utilities.ConvertOfferMode(offerMode);
            offer.Instances = Utilities.GetArray<OfferInstance>(instances, "Offer", "offerId", "GetOffer", new OfferInstance(), null, "Instances");
            offer.Stores = Utilities.GetArray<OfferStore>(stores, "Offer", "offerId", "GetOffer", new OfferStore(), "StoreId", "Stores");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveOffer(offer);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveOffer(offer);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveOffer(offer);
                        break;
                }
                
                DataSet actual = new DataSet();
                DataSet expected = new DataSet();
                expected = Utilities.ActualDataset("Offer", offer.Id, ref actual);
                Utilities.ExpectedDataSetOffer(offer, ref expected, typeof(Offer));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SavePricingRule(ServiceType serviceType, ChangeType change, IdType id, RelatedItemIdType countryCode, RelatedItemIdType currencyCodeRetail, RelatedItemIdType currencyCodeWholesale, RelatedItemIdType mediaType, ShortStringType name, RelatedItemIdType provider, DecimalType rate, DecimalType margin, DateTimeType startDate, ArrayType pricingRuleInstances)
        {
            PricingRule pricingRule = new PricingRule();

            pricingRule.Modified = Utilities.ConvertChangeType(change);
            pricingRule.CountryCode = Utilities.GetRelatedItemString(countryCode, "Country", "countryCode");
            pricingRule.RetailCurrencyCode = Utilities.GetRelatedItemString(currencyCodeRetail, "Currency", "currencyCode");
            pricingRule.WholesaleCurrencyCode = Utilities.GetRelatedItemString(currencyCodeWholesale, "Currency", "currencyCode");
            pricingRule.PrimaryId = Utilities.GetId(id, "PricingRule", "pricingRuleId");
            pricingRule.Margin = Utilities.GetDecimal(margin, "PricingRule", "margin");
            pricingRule.MediaTypeId = Utilities.GetRelatedItemId(mediaType, "MediaType", "mediaTypeId");
            pricingRule.Name = Utilities.GetString(name);
            pricingRule.PricingRuleInstances = Utilities.GetArray<PricingRuleInstance>(pricingRuleInstances, "PricingRuleInstance", "pricingRuleInstanceId", null, new PricingRuleInstance(), null, null);
            pricingRule.ProviderId = Utilities.GetRelatedItemId(provider, "Provider", "providerId");
            pricingRule.Rate = Utilities.GetDecimal(rate, "PricingRule", "margin");
            pricingRule.StartDateTime = Utilities.GetDateTime(startDate);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SavePricingRule(pricingRule);
                        break;

                    case ServiceType.NoHeader:
                        service.SavePricingRule(pricingRule);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SavePricingRule(pricingRule);
                        break;
                }
               
                if (pricingRule.Modified != DataChangeType.Delete)
                {
                    DataSet actual = new DataSet();
                    DataSet expected = new DataSet();
                    expected = Utilities.ActualDataset("PricingRule", pricingRule.PrimaryId, ref actual);
                    Utilities.ExpectedDatasetPricingRule(pricingRule, ref expected, typeof(PricingRule));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SavePublishingBatchRequest(ChangeType change, DateTimeType offerStartTime, DateTimeType offerEndTime, PublishingVisibilityStatusType visibilityStatus, ArrayType offerInstanceIDs, ServiceType serviceType)
        {
            Publishing publishing = new Publishing();
            publishing.Modified = Utilities.ConvertChangeType(change);
            publishing.OfferinstanceStartDateTime = Utilities.GetDateTime(offerStartTime);
            publishing.OfferinstanceEndDateTime = Utilities.GetDateTime(offerEndTime);
            publishing.VisibilityStatus = Utilities.ConvertPublishingVisibilityStatus(visibilityStatus);
            publishing.OfferInstanceIDs = Utilities.GetArray<Guid>(offerInstanceIDs, "OfferInstance", "offerInstanceId", null);
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SavePublishingBatchRequest(publishing);
                        break;

                    case ServiceType.NoHeader:
                        service.SavePublishingBatchRequest(publishing);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SavePublishingBatchRequest(publishing);
                        break;
                }
                service.SavePublishingBatchRequest(publishing);
                /*No Validation Added as this API is no longer supported */
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveVideo(InsertChangeType change, IdType id, ShortStringType crid, ShortStringType displayOriginalReleaseDate, IntegerType duration, IntegerType episodeNumber, bool geoCheckPolicy, ShortStringType isan, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, RelatedItemIdType spokenLanguage, ShortStringType subTitle, ShortStringType upc, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            Video video = new Video();
            video.Crid = Utilities.GetString(crid);
            video.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            video.Duration = Utilities.GetInteger(duration, "Video", "durationSecs");
            video.EpisodeNumber = Utilities.GetInteger(episodeNumber, "VideoEpisode", "episodeNumber");
            video.GeoCheckPolicy = geoCheckPolicy;
            video.Id = Utilities.GetGuid(id, "Video", "videoMediaId");
            video.Isan = Utilities.GetString(isan);
            video.MediaTitle = Utilities.GetString(mediaTitle);
            video.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            video.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            video.Modified = Utilities.ConvertInsertChangeType(change);
            video.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            video.ProductionCompany = Utilities.GetString(productionCompany);
            video.SpokenLanguage = Utilities.GetRelatedItemId(spokenLanguage, "Locale", "lcid");
            video.Subtitle = Utilities.GetString(subTitle);
            video.Upc = Utilities.GetString(upc);
            video.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            video.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            video.Articles = Utilities.GetArray<MediaArticle>(articles, "Video", "videoMediaId", "GetVideo", new MediaArticle(), "ArticleId", "Articles");
            video.Categories = Utilities.GetArray<MediaCategory>(categories, "Video", "videoMediaId", "GetVideo", new MediaCategory(), "CategoryId", "Categories");
            video.Contributors = Utilities.GetArray<MediaContributor>(contributors, "Video", "videoMediaId", "GetVideo", new MediaContributor(), "ContributorId", "Contributors");
            video.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "Video", "videoMediaId", "GetVideo", new VideoInstance(), "Id", "Instances");
            video.Locales = Utilities.GetArray<MediaLocale>(locales, "Video", "videoMediaId", "GetVideo", new MediaLocale(), "Lcid", "Locales");
            video.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "Video", "videoMediaId", "GetVideo", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            video.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "Video", "videoMediaId", "GetVideo", new MediaRating(), "RatingValueId", "RatingValues");
            video.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "Video", "videoMediaId", "GetVideo", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveVideo(video);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveVideo(video);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveVideo(video);
                        break;
                }
    
                DataSet actual = new DataSet();
                DataSet expected = new DataSet();
                expected = Utilities.ActualDataset("Video", video.Id, ref actual);
                Utilities.ExpectedDataSetVideo(video, ref expected, typeof(Video));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveVideoEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType serviceType)
        {
            VideoEncoding videoEncoding = new VideoEncoding();
            videoEncoding.Id = Utilities.GetId(id, "VideoEncoding", "videoEncodingId");
            videoEncoding.Modified = Utilities.ConvertChangeType(change);
            videoEncoding.Name = Utilities.GetString(name);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveVideoEncoding(videoEncoding);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveVideoEncoding(videoEncoding);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveVideoEncoding(videoEncoding);
                        break;
                }
                
                if (videoEncoding.Modified != DataChangeType.Delete)
                {
                    DataSet expected = new DataSet();
                    DataSet actual = new DataSet();
                    expected = Utilities.ActualDataset("VideoEncoding", videoEncoding.Id, ref actual);
                    Utilities.ExpectedDatasetVideoEncoding(videoEncoding, ref expected, typeof(VideoEncoding));
                    Utilities.CompareDataset(actual, expected);
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveVideoSeason(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isComplete, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, IntegerType seasonNumber, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            VideoSeason videoSeason = new VideoSeason();
            videoSeason.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            videoSeason.GeoCheckPolicy = geoCheckPolicy;
            videoSeason.Id = Utilities.GetGuid(id, "VideoSeason", "videoSeasonMediaId");
            videoSeason.IsComplete = isComplete;
            videoSeason.MediaTitle = Utilities.GetString(mediaTitle);
            videoSeason.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            videoSeason.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            videoSeason.Modified = Utilities.ConvertInsertChangeType(change);
            videoSeason.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            videoSeason.SeasonNumber = Utilities.GetInteger(seasonNumber, "VideoSeason", "seasonNumber");
            videoSeason.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            videoSeason.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            videoSeason.Articles = Utilities.GetArray<MediaArticle>(articles, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaArticle(), "ArticleId", "Articles");
            videoSeason.Categories = Utilities.GetArray<MediaCategory>(categories, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaCategory(), "CategoryId", "Categories");
            videoSeason.Contributors = Utilities.GetArray<MediaContributor>(contributors, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaContributor(), "ContributorId", "Contributors");
            videoSeason.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new VideoInstance(), "Id", "Instances");
            videoSeason.Locales = Utilities.GetArray<MediaLocale>(locales, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaLocale(), "Lcid", "Locales");
            videoSeason.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            videoSeason.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaRating(), "RatingValueId", "RatingValues");
            videoSeason.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "VideoSeason", "videoSeasonMediaId", "GetVideoSeason", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveVideoSeason(videoSeason);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveVideoSeason(videoSeason);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveVideoSeason(videoSeason);
                        break;
                }
                DataSet expected = new DataSet();
                DataSet actual = new DataSet();
                expected = Utilities.ActualDataset("VideoSeason", videoSeason.Id, ref actual);
                Utilities.ExpectedDataSetVideoSeason(videoSeason, ref expected, typeof(VideoSeason));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveVideoSeries(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isOrderBySeason, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType serviceType)
        {
            VideoSeries videoSeries = new VideoSeries();
            videoSeries.DisplayOriginalReleaseDate = Utilities.GetString(displayOriginalReleaseDate);
            videoSeries.GeoCheckPolicy = geoCheckPolicy;
            videoSeries.Id = Utilities.GetGuid(id, "VideoSeries", "videoSeriesMediaId");
            videoSeries.IsOrderBySeason = isOrderBySeason;
            videoSeries.MediaTitle = Utilities.GetString(mediaTitle);
            videoSeries.MediaTypeId = Utilities.GetRelatedItemId(mediaTypeId, "MediaType", "mediaTypeId");
            videoSeries.MetadataProviderId = Utilities.GetRelatedItemId(metadataProviderId, "MetadataProvider", "metadataProviderId");
            videoSeries.Modified = Utilities.ConvertInsertChangeType(change);
            videoSeries.OriginalReleaseDate = Utilities.GetDateTime(originalReleaseDate);
            videoSeries.ProductionCompany = Utilities.GetString(productionCompany);
            videoSeries.VisibilityDate = Utilities.GetDateTime(visibilityDate);
            videoSeries.VisibilityStatusId = Utilities.GetRelatedItemId(visibilityStatus, "VisibilityStatus", "visibilityStatusId");
            videoSeries.Articles = Utilities.GetArray<MediaArticle>(articles, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaArticle(), "ArticleId", "Articles");
            videoSeries.Categories = Utilities.GetArray<MediaCategory>(categories, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaCategory(), "CategoryId", "Categories");
            videoSeries.Contributors = Utilities.GetArray<MediaContributor>(contributors, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaContributor(), "ContributorId", "Contributors");
            videoSeries.Instances = Utilities.GetArray<MediaInstance>(mediaInstances, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new VideoInstance(), "Id", "Instances");
            videoSeries.Locales = Utilities.GetArray<MediaLocale>(locales, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaLocale(), "Lcid", "Locales");
            videoSeries.RatingDescriptors = Utilities.GetArray<MediaRatingDescriptor>(ratingDescriptors, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaRatingDescriptor(), "RatingDescriptorId", "RatingDescriptors");
            videoSeries.RatingValues = Utilities.GetArray<MediaRating>(ratingValues, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaRating(), "RatingValueId", "RatingValues");
            videoSeries.Relationships = Utilities.GetArray<MediaRelationship>(relationships, "VideoSeries", "videoSeriesMediaId", "GetVideoSeries", new MediaRelationship(), "RelatedMediaId", "Relationships");

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveVideoSeries(videoSeries);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveVideoSeries(videoSeries);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveVideoSeries(videoSeries);
                        break;
                }

                DataSet expected = new DataSet();
                DataSet actual = new DataSet();
                expected = Utilities.ActualDataset("VideoSeries", videoSeries.Id, ref actual);
                Utilities.ExpectedDataSetVideoSeries(videoSeries, ref expected, typeof(VideoSeries));
                Utilities.CompareDataset(actual, expected);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string GetArticle(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Article", "articleId");
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetArticle(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetArticle(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetArticle(actualId);
                        break;

                }
                
                Utilities.CompareWithDatabase(
                    typeof(Article),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string GetArticleArray(ArrayType ids, ServiceType serviceType)
        {
            try
            {
                Guid[] actualIds = Utilities.GetArray<Guid>(ids, "Article", "articleId", null);
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetArticle(actualIds);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetArticle(actualIds);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetArticle(actualIds);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Article),
                    result,
                    null,
                    null,
                    actualIds,
                    typeof(Guid));
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string GetAudioEncodingArray(ServiceType serviceType)
        {
            try
            {
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAudioEncoding();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAudioEncoding();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAudioEncoding();
                        break;

                }

                Utilities.CompareWithDatabase(
                    typeof(AudioEncoding),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCategorySystem(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "CategorySystem", "categorySystemId");
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCategorySystem(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCategorySystem(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCategorySystem(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(CategorySystem),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCategorySystemArray(ServiceType serviceType)
        {
            try
            {
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCategorySystem();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCategorySystem();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCategorySystem();
                        break;

                }

                Utilities.CompareWithDatabase(
                    typeof(CategorySystem),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetClientTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetClientType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetClientType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetClientType();
                        break;

                }

                Utilities.CompareWithDatabase(
                    typeof(ClientType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetContributorArray(ArrayType ids, ServiceType serviceType)
        {
            try
            {
                Guid[] actualIds = Utilities.GetArray<Guid>(ids, "Contributor", "contributorId", null);
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetContributor(actualIds);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetContributor(actualIds);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetContributor(actualIds);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Contributor),
                    result,
                    null,
                    null,
                    actualIds,
                    typeof(Guid));
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetContributor(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Contributor", "contributorId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetContributor(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetContributor(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetContributor(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Contributor),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetContributorRelationshipTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetContributorRelationshipType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetContributorRelationshipType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetContributorRelationshipType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(ContributorRelationshipType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCountry(IdType id, ServiceType serviceType)
        {
            try
            {
                string actualId = Utilities.GetString(id, "country", "countryCode");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCountry(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCountry(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCountry(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Country),
                    result,
                    actualId,
                    "countryCode");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCountryArray(ServiceType serviceType)
        {
            try
            {
                Country[] result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCountry();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCountry();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCountry();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Country),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCurrency(IdType id, ServiceType serviceType)
        {
            try
            {
                string actualId = Utilities.GetString(id, "currency", "currencyCode");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCurrency(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCurrency(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCurrency(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Currency),
                    result,
                    actualId,
                    "currencyCode");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCurrencyArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCurrency();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCurrency();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCurrency();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Currency),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetDRMLicenseIssuer(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "DRMLicenseIssuer", "drmLicenseIssuerId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetDRMLicenseIssuer(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetDRMLicenseIssuer(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetDRMLicenseIssuer(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(DRMLicenseIssuer),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetDRMLicenseIssuerArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetDRMLicenseIssuer();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetDRMLicenseIssuer();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetDRMLicenseIssuer();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(DRMLicenseIssuer),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetEntity(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "Entity", "entityId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetEntity(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetEntity(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetEntity(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Entity),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetEntityArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetEntity();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetEntity();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetEntity();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Entity),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetGame(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Game", "gameMediaId");
                object result = null;

                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetGame(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetGame(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetGame(actualId);
                        break;

                }

                Utilities.CompareWithDatabase(
                    typeof(Game),
                    result,
                    actualId,
                    "gameMediaId"
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        /*        public string GetGameConsumable(IdType id)
                {
                    try
                    {
                        Guid actualId = Utilities.GetGuid(id, "GameConsumable", "gameAssetMediaId");
                        Utilities.CompareWithDatabase(
                            typeof(GameConsumable),
                            service.GetGameConsumable(actualId),
                            actualId,
                            "gameAssetMediaId"
                            );
                    }
                    catch (Exception e)
                    {
                        return Utilities.GetExceptionType(e);
                    }
                    return ExceptionType.NoError;
                }
        */
        public string GetGameContent(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "GameContent", "gameContentMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetGameContent(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetGameContent(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetGameContent(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(GameContent),
                    result,
                    actualId,
                    "gameContentMediaId"
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetImage(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Image", "imageMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetImage(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetImage(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetImage(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Image),
                    result,
                    actualId,
                    "imageMediaId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetImageFormat(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetImageFormat();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetImageFormat();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetImageFormat();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(ImageFormat),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetImageSizeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetImageSize();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetImageSize();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetImageSize();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(ImageSize),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetLicenseClass(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "LicenseClass", "licenseClassId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetLicenseClass(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetLicenseClass(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetLicenseClass(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(LicenseClass),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetLicenseClassArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetLicenseClass();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetLicenseClass();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetLicenseClass();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(LicenseClass),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetLicenseType(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "LicenseType", "licenseTypeId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetLicenseType(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetLicenseType(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetLicenseType(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(LicenseType),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetLicenseTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetLicenseType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetLicenseType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetLicenseType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(LicenseType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetLocaleArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetLocale();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetLocale();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetLocale();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Locale),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        //TODO: Fix this
        public string GetMediaOffer(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Media", "mediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetMediaOffer(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetMediaOffer(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetMediaOffer(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(MediaOffer),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetMediaRelationshipTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetMediaRelationshipType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetMediaRelationshipType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetMediaRelationshipType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(MediaRelationshipType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetMediaTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetMediaType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetMediaType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetMediaType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(MediaType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetMetadataProvider(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "MetadataProvider", "metadataProviderId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetMetadataProvider(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetMetadataProvider(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetMetadataProvider(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(MetadataProvider),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetMetadataProviderArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetMetadataProvider();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetMetadataProvider();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetMetadataProvider();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(MetadataProvider),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetOffer(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Offer", "offerId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetOffer(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetOffer(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetOffer(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Offer),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetPodcastById(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Podcast", "podcastMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPodcast(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPodcast(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPodcast(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Podcast),
                    result,
                    actualId,
                    "podcastMediaId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetPodcastByUri(IdType id, ServiceType serviceType)
        {
            try
            {
                String actualId = Utilities.GetString(id, "Podcast", "rssUrl");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPodcast(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPodcast(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPodcast(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Podcast),
                    result,
                    actualId,
                    "rssUrl");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetPreviewMediaInstanceTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPreviewMediaInstanceType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPreviewMediaInstanceType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPreviewMediaInstanceType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(PreviewMediaInstanceType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetPricingRule(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "PricingRule", "pricingRuleId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPricingRule(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPricingRule(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPricingRule(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(PricingRule),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetPricingRuleArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPricingRule();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPricingRule();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPricingRule();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(PricingRule),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetProvider(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "Provider", "providerId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetProvider(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetProvider(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetProvider(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Provider),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetProviderArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetProvider();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetProvider();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetProvider();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Provider),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetRatingSystem(IdType id, ServiceType serviceType)
        {
            try
            {
                int actualId = Utilities.GetId(id, "RatingSystem", "ratingSystemId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetRatingSystem(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetRatingSystem(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetRatingSystem(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(RatingSystem),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetRatingSystemArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetRatingSystem();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetRatingSystem();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetRatingSystem();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(RatingSystem),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetRoleArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetRole();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetRole();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetRole();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Role),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetStoreArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetStore();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetStore();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetStore();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Store),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetUserTypeArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetUserType();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetUserType();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetUserType();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(UserType),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVideo(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "Video", "videoMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVideo(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVideo(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVideo(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Video),
                    result,
                    actualId,
                    "videoMediaId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVideoDefinitionArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVideoDefinition();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVideoDefinition();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVideoDefinition();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VideoDefinition),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVideoEncodingArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVideoEncoding();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVideoEncoding();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVideoEncoding();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VideoEncoding),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVideoSeason(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "VideoSeason", "videoSeasonMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVideoSeason(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVideoSeason(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVideoSeason(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VideoSeason),
                    result,
                    actualId,
                    "videoSeasonMediaId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVideoSeries(IdType id, ServiceType serviceType)
        {
            try
            {
                Guid actualId = Utilities.GetGuid(id, "VideoSeries", "videoSeriesMediaId");
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVideoSeries(actualId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVideoSeries(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVideoSeries(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VideoSeries),
                    result,
                    actualId,
                    "videoSeriesMediaId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVisibilityLevelArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVisibilityLevel();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVisibilityLevel();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVisibilityLevel();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VisibilityLevel),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetVisibilityStatusArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetVisibilityStatus();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetVisibilityStatus();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetVisibilityStatus();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(VisibilityStatus),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableEntityId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableEntityId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableEntityId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableEntityId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "Entity",
                    "EntityID");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableCategoryId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableCategoryId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableCategoryId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableCategoryId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "Category",
                    "categoryID");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableCategorySystemId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableCategorySystemId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableCategorySystemId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableCategorySystemId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "CategorySystem",
                    "categorySystemID");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableRatingSystemId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableRatingSystemId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableRatingSystemId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableRatingSystemId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "RatingSystem",
                    "RatingSystemId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableRatingValueId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableRatingValueId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableRatingValueId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableRatingValueId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "RatingValue",
                    "RatingValueId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableRatingDescriptorId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableRatingDescriptorId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableRatingDescriptorId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableRatingDescriptorId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "RatingDescriptor",
                    "RatingDescriptorId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableLicenseTypeId(ServiceType serviceType)
        {
            try
            {
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetAvailableLicenseTypeId();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetAvailableLicenseTypeId();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetAvailableLicenseTypeId();
                        break;

                }
                Utilities.DoAvailableIdComparison(
                    result,
                    "LicenseType",
                    "LicenseTypeId");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetCatalogId(ServiceType serviceType)
        {
            try
            {
                //call query to retrieve a valid value to test with
                ExternalMappingTableItem randomMappingTableItem = Utilities.GetMappingTableEntry();
                int result = 0;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetCatalogId(randomMappingTableItem.externalId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId); 
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetCatalogId(randomMappingTableItem.externalId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId); 
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetCatalogId(randomMappingTableItem.externalId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId); 
                        break;

                }
                //make service call
                if (randomMappingTableItem.catalogId != result)
                {
                    throw new System.Data.DataException(String.Format("Service did not return the correct CatalogId: Actual='{0}', Expected='{1}'", result, randomMappingTableItem.catalogId));
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetExternalId(ServiceType serviceType)
        {
            try
            {
                //call query to retrieve a valid value to test with
                ExternalMappingTableItem randomMappingTableItem = Utilities.GetMappingTableEntry();

                string result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetExternalId(randomMappingTableItem.catalogId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId);
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetExternalId(randomMappingTableItem.catalogId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetExternalId(randomMappingTableItem.catalogId, randomMappingTableItem.feedSourceId, randomMappingTableItem.externalmappingObjectId);
                        break;

                }
                //make service call
                
                if (randomMappingTableItem.externalId != result)
                {
                    throw new System.Data.DataException(String.Format("Service did not return the correct ExternalId: Actual='{0}', Expected='{1}'", result, randomMappingTableItem.externalId));
                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetExternalFeedSource(ServiceType serviceType)
        {
            try
            {
                //query for random ExternalFeedSource
                ExternalFeedSource test = Utilities.GetRandomExternalFeedSource();
                //make service call and compare
                ExternalFeedSource verification = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        verification = serviceCorrectHeader.GetExternalFeedSource(test.Id);
                        break;

                    case ServiceType.NoHeader:
                        verification = service.GetExternalFeedSource(test.Id);
                        break;

                    case ServiceType.WrongHeader:
                        verification = serviceWrongHeader.GetExternalFeedSource(test.Id);
                        break;

                }

                if (verification.Id != test.Id)
                    throw new System.Data.DataException(String.Format("Service returned invalid ID.  Test ID: '{0}', Service ID: '{1}'.", test.Id, verification.Id));
                if (verification.Name != test.Name)
                    throw new System.Data.DataException(String.Format("Service returned invalid ID.  Test Name: '{0}', Service Name: '{1}'.", test.Name, verification.Name));
            }
            catch (Exception e)
            {
                //fail
                return Utilities.GetExceptionType(e);
            }
            //pass
            return ExceptionType.NoError;
        }

        public string GetExternalFeedMappingObject(ServiceType serviceType)
        {
            try
            {
                //query for random ExternalFeedSource
                ExternalFeedMappingObject test = Utilities.GetRandomExternalFeedMappingObject();
                //make service call and compare
                ExternalFeedMappingObject verification = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        verification = serviceCorrectHeader.GetExternalFeedMappingObject(test.Id);
                        break;

                    case ServiceType.NoHeader:
                        verification = service.GetExternalFeedMappingObject(test.Id);
                        break;

                    case ServiceType.WrongHeader:
                        verification = serviceWrongHeader.GetExternalFeedMappingObject(test.Id);
                        break;

                }
                if (verification.Id != test.Id)
                    throw new System.Data.DataException(String.Format("Service returned invalid ID.  Test ID: '{0}', Service ID: '{1}'.", test.Id, verification.Id));
                if (verification.Name != test.Name)
                    throw new System.Data.DataException(String.Format("Service returned invalid ID.  Test Name: '{0}', Service Name: '{1}'.", test.Name, verification.Name));
            }
            catch (Exception e)
            {
                //fail
                return Utilities.GetExceptionType(e);
            }
            //pass
            return ExceptionType.NoError;
        }

        public string SaveExternalFeedMapping1(ServiceType serviceType)
        {
            try
            {
                //test new external ID with new valid catalogId not in the mapping table
                int unmappedEntityId = Utilities.GetUnmappedEntityId();
                string randomValidString = "FEFE";                              //HexValue that follows LiveTools style
                int feedSource = 1;
                int feedMappingObject = 1;

                ExternalFeedMapping newExternal = new ExternalFeedMapping();
                newExternal.ExternalId = randomValidString;
                newExternal.CatalogId = unmappedEntityId;
                newExternal.ExternalFeedSourceId = feedSource;                    //LiveTools Source
                newExternal.ExternalFeedmappingObjectId = feedMappingObject;             //Entity Object Type
                newExternal.Modified = DataChangeType.Add;   //not totally usefull, but here for completeness

                string testValue = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveExternalFeedMapping(newExternal);
                        testValue = serviceCorrectHeader.GetExternalId(unmappedEntityId, feedSource, feedMappingObject);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveExternalFeedMapping(newExternal);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveExternalFeedMapping(newExternal);
                        break;

                }
                if (randomValidString != testValue)
                    throw new System.Data.DataException(
                        String.Format("Service failed to return the new ExternalId.  Actual: '{0}', Expected: '{1}'.", testValue, randomValidString));
            }

            catch (Exception e)
            {
                //fail
                return Utilities.GetExceptionType(e);
            }
            //pass
            return ExceptionType.NoError;
        }

        public string SaveExternalFeedMapping2()
        {
            try
            {
                //test new external ID with new valid catalogId not in the mapping table
                int unmappedEntityId = Utilities.GetUnmappedEntityId();
                string randomValidString = "FEFE";                              //HexValue that follows LiveTools style
                int feedSource = 1;
                int feedMappingObject = 2;

                ExternalFeedMapping newExternal = new ExternalFeedMapping();
                newExternal.ExternalId = randomValidString;
                newExternal.CatalogId = unmappedEntityId;
                newExternal.ExternalFeedSourceId = feedSource;                  //LiveTools Source
                newExternal.ExternalFeedmappingObjectId = feedMappingObject;    //Category Object Type
                newExternal.Modified = DataChangeType.Add;          //not totally usefull, but here for completeness

                //call the service with the new value
                serviceCorrectHeader.SaveExternalFeedMapping(newExternal);

                string testValue = serviceCorrectHeader.GetExternalId(unmappedEntityId, feedSource, feedMappingObject);

                if (randomValidString != testValue)
                    throw new System.Data.DataException(
                        String.Format("Service failed to return the new ExternalId.  Actual: '{0}', Expected: '{1}'.", testValue, randomValidString));
            }

            catch (Exception e)
            {
                //fail
                return Utilities.GetExceptionType(e);
            }
            //pass
            return ExceptionType.NoError;
        }

        public string SaveExternalFeedMapping3()
        {
            try
            {
                //retrieve valid starting data to work with
                ExternalMappingTableItem randomMappingTableItem = Utilities.GetMappingTableEntry();

                //test invalidating the Uniqueness Constraint on ExternalId (same ExternalId, FeedSourceID and FeedMapping Id) 
                ExternalFeedMapping newValidExternalId = new ExternalFeedMapping();
                newValidExternalId.ExternalId = randomMappingTableItem.externalId;
                newValidExternalId.CatalogId = randomMappingTableItem.catalogId + 10;  //should be a new or existing catalogId, though it shouldn't matter
                newValidExternalId.ExternalFeedSourceId = randomMappingTableItem.feedSourceId;
                newValidExternalId.ExternalFeedmappingObjectId = randomMappingTableItem.externalmappingObjectId;
                newValidExternalId.Modified = DataChangeType.Add;           //not totally usefull, but here for completeness

                serviceCorrectHeader.SaveExternalFeedMapping(newValidExternalId);  //should throw SQL Exception here

            }

            catch                   //TODO: should validate that the correct exception is thrown
            {
                //pass
                return ExceptionType.NoError;
            }
            //fail
            return Utilities.GetExceptionType(new System.Data.DataException("Service did not prevent Uniqueness exception."));
        }

        public string Ping(ServiceType serviceType)
        {
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.Ping();
                        break;

                    case ServiceType.NoHeader:
                        service.Ping();
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.Ping();
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string PurgeTaskQueue(ServiceType serviceType)
        {
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.PurgeTaskQueue();
                        break;

                    case ServiceType.NoHeader:
                        service.PurgeTaskQueue();
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.PurgeTaskQueue();
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string GetTasks(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetTasks();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetTasks();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetTasks();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(Task),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetAvailableTaskAsXML(ServiceType serviceType)
        {
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.GetAvailableTaskAsXML();
                        break;

                    case ServiceType.NoHeader:
                        service.GetAvailableTaskAsXML();
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.GetAvailableTaskAsXML();
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetTaskByStatus(IdType id, ServiceType serviceType)
        {
            int actualId = Utilities.GetId(id, "TaskStatus", "taskStatusId");
            object result = null;
            
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.GetTaskStatus();
                        break;

                    case ServiceType.NoHeader:
                        service.GetTaskStatus();
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.GetTaskStatus();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(TaskStatus),
                    result,
                    actualId);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GetTaskStatusArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetTaskStatus();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetTaskStatus();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetTaskStatus();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(TaskStatus),
                    result,
                    null);
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string SaveDRMTask(ServiceType serviceType, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType mediaInstanceId, bool isDRMRequired, RelatedItemIdType taskStatusId)
        {
            DRMTask drmTask = new DRMTask();
            drmTask.Modified = Utilities.ConvertChangeType(change);
            drmTask.EndDate = Utilities.GetDateTime(endDate);
            drmTask.FileName = Utilities.GetString(fileName);
            drmTask.InputFileLocation = Utilities.GetString(inputFileLocation);
            drmTask.MediaInstanceId = Utilities.GetRelatedItemIdGuid(mediaInstanceId, "MediaInstance", "mediaInstanceId");
            drmTask.OutputFileLocation = Utilities.GetString(outputFileLocation);
            drmTask.StartDate = Utilities.GetDateTime(startDate);
            drmTask.TaskInstanceId = Utilities.GetGuid(taskInstanceId, "TaskQueue", "taskInstanceId");
            drmTask.TaskStatusId = Utilities.GetRelatedItemId(taskStatusId, "TaskStatus", "taskStatusId");
            drmTask.AsperaFileLocation = Utilities.GetString(asperaFileLocation);
            drmTask.StatusMessage = Utilities.GetString(statusMessage);
            drmTask.IsDRMRequired = isDRMRequired;
            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveDRMTask(drmTask);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveDRMTask(drmTask);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveDRMTask(drmTask);
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string SaveTask(ServiceType serviceType, XmlType xml)
        {
            string actualXml = xml == XmlType.Valid ?
                String.Format("<TaskData><DRMTaskData><isDRMRequired>false</isDRMRequired><mediaInstanceId>{0}</mediaInstanceId></DRMTaskData></TaskData>", Utilities.GetGuid(IdType.Existing, "MediaInstance", "mediaInstanceId"))
                :
                Utilities.GetXml(xml);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveTask(actualXml);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveTask(actualXml);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveTask(actualXml);
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string SaveTask(ServiceType serviceType, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType taskStatusId)
        {
            Task task = new Task();
            task.Modified = Utilities.ConvertChangeType(change);
            task.EndDate = Utilities.GetDateTime(endDate);
            task.FileName = Utilities.GetString(fileName);
            task.InputFileLocation = Utilities.GetString(inputFileLocation);
            task.OutputFileLocation = Utilities.GetString(outputFileLocation);
            task.StartDate = Utilities.GetDateTime(startDate);
            task.TaskInstanceId = Utilities.GetGuid(taskInstanceId, "TaskQueue", "taskInstanceId");
            task.TaskStatusId = Utilities.GetRelatedItemId(taskStatusId, "TaskStatus", "taskStatusId");
            task.AsperaFileLocation = Utilities.GetString(asperaFileLocation);
            task.StatusMessage = Utilities.GetString(statusMessage);

            try
            {
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.SaveTask(task);
                        break;

                    case ServiceType.NoHeader:
                        service.SaveTask(task);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.SaveTask(task);
                        break;

                }
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }

            return ExceptionType.NoError;
        }

        public string GetPaymentMethod(IdType id, ServiceType serviceType)
        {
            try
            {
                //int actualId = Utilities.GetId(id, "PaymentType", "PaymentTypeId");
                int actualId = Utilities.GetPaymentId();
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        serviceCorrectHeader.GetPaymentMethod(actualId);
                        break;

                    case ServiceType.NoHeader:
                        service.GetPaymentMethod(actualId);
                        break;

                    case ServiceType.WrongHeader:
                        serviceWrongHeader.GetPaymentMethod(actualId);
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(PaymentType),
                    result,
                    actualId
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }
        public string GetPaymentMethodArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetPaymentMethod();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetPaymentMethod();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetPaymentMethod();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(PaymentType),
                    result,
                    null
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }
        public string GetExternalFeedSourceArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetExternalFeedSource();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetExternalFeedSource();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetExternalFeedSource();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(ExternalFeedSource),
                    result,
                    null
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }
        public string GetExternalFeedMappingObjectArray(ServiceType serviceType)
        {
            try
            {
                object result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.GetExternalFeedMappingObject();
                        break;

                    case ServiceType.NoHeader:
                        result = service.GetExternalFeedMappingObject();
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.GetExternalFeedMappingObject();
                        break;

                }
                Utilities.CompareWithDatabase(
                    typeof(ExternalFeedMappingObject),
                    result,
                    null
                    );
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }
        public string GameOfferSearch(StringType Title, MaxRows rows, ServiceType serviceType)
        {
            try
            {
                GameOfferSearchRequest input = new GameOfferSearchRequest();
                input.Title = Utilities.GetString(Title, "O.name", 255, "Offer O", "GameOfferSearch");
                input.MaxResults = Utilities.GetRows(rows);

                List<GameOfferSearchResponse> d = new List<GameOfferSearchResponse>();

                Response[] result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.Search(input);
                        break;

                    case ServiceType.NoHeader:
                        result = service.Search(input);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.Search(input);
                        break;

                }

                foreach (Response obj in result)
                {
                    d.Add((GameOfferSearchResponse)obj);
                }

                string query = Utilities.QueryBuilderGameOfferSearch(input.MaxResults,input.Title);
                Utilities.CompareWithDatabase2(typeof(GameOfferSearchResponse), result, query, "GameOfferSearch");

            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }

        public string GamePublisherSearch(FindType Id, MaxRows rows, ServiceType serviceType)
        {
            try
            {
                GamePublisherSearchRequest request = new GamePublisherSearchRequest();
                request.PublisherId = Utilities.GetExternalId(Id, "ExternalId", "ExternalFeedMapping", "GamePublisherSearch", 50);

                request.MaxResults = Utilities.GetRows(rows);
                bool isNew = false;

                if (Id == FindType.New)
                    isNew = true;

                List<GamePublisherSearchResponse> list = new List<GamePublisherSearchResponse>();

                Response[] result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.Search(request);
                        break;

                    case ServiceType.NoHeader:
                        result = service.Search(request);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.Search(request);
                        break;

                }
                foreach (Response obj in result)
                {
                    list.Add((GamePublisherSearchResponse)obj);
                }

                string query = Utilities.QueryBuilderGamePublisherSearch(request.MaxResults, request.PublisherId, isNew);
                Utilities.CompareWithDatabase2(typeof(GamePublisherSearchResponse), result, query, "GamePublisherSearch");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;

        }

        public string GameTitleSearch(StringType Title, IntegerType Lcid, MaxRows rows, ServiceType serviceType)
        {
            try
            {
                GameTitleSearchRequest request = new GameTitleSearchRequest();
                request.Lcid = Utilities.GetInteger(Lcid, "MediaLocaleMap", "lcid");
                request.Title = Utilities.GetString(Title, "ML.title", 255, "MediaLocale As ML ", "GameTitleSearch");
                request.MaxResults = Utilities.GetRows(rows);

                List<GameTitleSearchResponse> list = new List<GameTitleSearchResponse>();

                Response[] result = null;
                switch (serviceType)
                {
                    case ServiceType.CorrectHeader:
                        result = serviceCorrectHeader.Search(request);
                        break;

                    case ServiceType.NoHeader:
                        result = service.Search(request);
                        break;

                    case ServiceType.WrongHeader:
                        result = serviceWrongHeader.Search(request);
                        break;

                }
                foreach (Response obj in result)
                    list.Add((GameTitleSearchResponse)obj);

                string query = Utilities.QueryBuilderGameTitleSearch(request.MaxResults, request.Title, request.Lcid);
                Utilities.CompareWithDatabase2(typeof(GameTitleSearchResponse), result, query, "GameTitleSearch");
            }
            catch (Exception e)
            {
                return Utilities.GetExceptionType(e);
            }
            return ExceptionType.NoError;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Model\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc

copyConfigFile: $(TARGETNAME).$(TARGETEXT).config

$(TARGETNAME).$(TARGETEXT).config: app.config
     copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Adapter\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Adapter.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://localhost:12010/ContentIngestion/CatalogServices.asmx")]
        public string WebServiceUrl {
            get {
                return ((string)(this["WebServiceUrl"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("localhost")]
        public string DatabaseServer {
            get {
                return ((string)(this["DatabaseServer"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\Model\CatalogWebServiceModel.cs ===
using Microsoft.Modeling;
using InputTypes;
using ReturnTypes;

namespace Model
{
    [Feature("Catalog Web Service")]
    static class CatalogWebServiceModel
    {
        [Action("SaveAudioEncoding(change, id, name, service)/result")]
        static string SaveAudioEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (name > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Empty)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Null)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveCategory(change, id, categorySystemId, parentCategoryId, locales, categories, localeMap, service)/result")]
        static string SaveCategory(ChangeType change, IdType id, IdType categorySystemId, TreeParentIdType parentCategoryId, ArrayType locales, ArrayType categories, ArrayType localeMap, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (locales == ArrayType.Null || locales == ArrayType.Empty)
                return ExceptionType.ArgumentException;

            if (categorySystemId != IdType.Existing)
                return ExceptionType.ArgumentNullException;

            if (parentCategoryId == TreeParentIdType.Self)
                return ExceptionType.ArgumentException;

            if (parentCategoryId == TreeParentIdType.NonExisting)
                return ExceptionType.ArgumentException;

            if (change == ChangeType.Delete)
                return ExceptionType.NotSupportedException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveContributor(change, id, birthDate, birthPlace, deathDate, deathPlace, displayBirthDate, displayDeathDate, isGroup, metadataProviderId, aliases, articles, categories, locales, relationships, service)/result")]
        static string SaveContributor(ChangeType change, IdType id, DateTimeType birthDate, MediumStringType birthPlace, DateTimeType deathDate, MediumStringType deathPlace, ShortStringType displayBirthDate, ShortStringType displayDeathDate, bool isGroup, RelatedItemIdType metadataProviderId, ArrayType aliases, ArrayType articles, ArrayType categories, ArrayType locales, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (displayBirthDate > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (displayDeathDate > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (birthPlace > MediumStringType.Length255)
                return ExceptionType.ArgumentException;

            if (deathPlace > MediumStringType.Length255)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveEntity(service, change, id, name, contactInfo, accountNumber, externalEntityId, isProvider, isMetadataProvider, isDrmLicenseIssuer)/result")]
        static string SaveEntity(ServiceType service, ChangeType change, IdType id, MediumStringType name, MediumStringType contactInfo, ShortStringType accountNumber, ShortStringType externalEntityId, bool isProvider, bool isMetadataProvider, bool isDrmLicenseIssuer)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (name > MediumStringType.Length255)
                return ExceptionType.ArgumentException;

            if (accountNumber > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (contactInfo > MediumStringType.Length500)
                return ExceptionType.ArgumentException;

            if (externalEntityId > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (name == MediumStringType.Empty)
                return ExceptionType.ArgumentException;

            if (name == MediumStringType.Null)
                return ExceptionType.ArgumentException;

            if (change == ChangeType.Delete)
                return ExceptionType.NotSupportedException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveGame(change, id, displayOriginalReleaseDate, geoCheckPolicy, liveTitleId, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, visibilityDate, visibilityStatus, articles, categories, contributors, gameLocales, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveGame(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, IntegerType liveTitleId, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType gameLocales, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveGameContent(change, id, consumable, displayOriginalReleaseDate, effectiveLiveTitleId, gameMediaId, geoCheckPolicy, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, contentBitFilter, visibilityDate, visibilityStatus, articles, categories, contributors, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveGameContent(InsertChangeType change, IdType id, bool consumable, ShortStringType displayOriginalReleaseDate, IntegerType effectiveLiveTitleId, RelatedItemIdType gameMediaId, bool geoCheckPolicy, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ContentBitFilterType contentBitFilter, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (gameMediaId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

           
            return ExceptionType.NoError;
        }

        [Action("SaveImage(change, id, creator, displayOriginalReleaseDate, geoCheckPolicy, issuer, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, visibilityDate, visibilityStatus, articles, categories, contributors, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveImage(InsertChangeType change, IdType id, MediumStringType creator, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, MediumStringType issuer, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (creator > MediumStringType.Length255)
                return ExceptionType.ArgumentException;

           
            return ExceptionType.NoError;
        }

        [Action("SaveLicenseType(service, change, id, licenseClassId, name, xml, legalTextLocales)/result")]
        static string SaveLicenseType(ServiceType service, ChangeType change, IdType id, RelatedItemIdType licenseClassId, ShortStringType name, XmlType xml, ArrayType legalTextLocales)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (name > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Empty)
                return ExceptionType.ArgumentException;

            if (xml == XmlType.Empty)
                return ExceptionType.ArgumentException;

            if (licenseClassId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Null)
                return ExceptionType.ArgumentException;

            if (xml == XmlType.Null)
                return ExceptionType.ArgumentException;

            if (change == ChangeType.Delete)
                return ExceptionType.NotSupportedException;

            
            return ExceptionType.NoError;
        }

        //[Action("SaveOffer(change, id, mediaId, name, offerMode, offerInstances, offerStores)/result")]
        static string SaveOffer(InsertChangeType change, IdType id, RelatedItemIdType mediaId, MediumStringType name, OfferType offerMode, ArrayType offerInstances, ArrayType offerStores, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (name > MediumStringType.Length255)
                return ExceptionType.ArgumentException;

            if (name == MediumStringType.Empty)
                return ExceptionType.ArgumentException;

            if (mediaId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (offerInstances == ArrayType.Null)
                return ExceptionType.NoQualifiedMediaInstanceException;

            if (offerInstances == ArrayType.Empty)
                return ExceptionType.NoQualifiedMediaInstanceException;

            if (name == MediumStringType.Null)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SavePricingRule(service, change, id, countryCode, currencyCodeRetail, currencyCodeWholesale, mediaType, name, provider, rate, margin, startDate, pricingRuleInstances)/result")]
        static string SavePricingRule(ServiceType service,ChangeType change, IdType id, RelatedItemIdType countryCode, RelatedItemIdType currencyCodeRetail, RelatedItemIdType currencyCodeWholesale, RelatedItemIdType mediaType, ShortStringType name, RelatedItemIdType provider, DecimalType rate, DecimalType margin, DateTimeType startDate, ArrayType pricingRuleInstances)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaType == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (provider == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (countryCode == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (currencyCodeRetail == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (currencyCodeWholesale == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (change == ChangeType.Delete)
                return ExceptionType.NotSupportedException;

            if (name > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Null)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Empty)
                return ExceptionType.ArgumentException;

            return ExceptionType.NoError;
        }

        //[Action("SavePublishingBatchRequest(change, offerStartTime, offerEndTime, visibilityStatus, publishingIds)/result")]
        static string SavePublishingBatchRequest(ChangeType change, DateTimeType offerStartTime, DateTimeType offerEndTime, PublishingVisibilityStatusType visibilityStatus, ArrayType publishingIds, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("SaveTask(service, xml)/result")]
        static string SaveTask(ServiceType service, XmlType xml)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (xml == XmlType.Invalid)
                return ExceptionType.XmlSchemaValidationException;

            if (xml == XmlType.Null)
                return ExceptionType.ArgumentException;

            if (xml == XmlType.Empty)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveDRMTask(service, change, taskInstanceId, startDate, endDate, fileName, inputFileLocation, outputFileLocation, asperaFileLocation,statusMessage, mediaInstanceId,isDRMRequired, taskStatusId)/result")]
        static string SaveDRMTask(ServiceType service, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType mediaInstanceId, bool isDRMRequired, RelatedItemIdType taskStatusId)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (taskStatusId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (fileName == MediumStringType.Null)
                return ExceptionType.ArgumentException;

            if (fileName == MediumStringType.Empty)
                return ExceptionType.ArgumentException;

            if (inputFileLocation == LongStringType.Null)
                return ExceptionType.ArgumentException;

            if (inputFileLocation == LongStringType.Empty)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveTask(service, change, taskInstanceId, startDate, endDate, fileName, inputFileLocation, outputFileLocation,asperaFileLocation,statusMessage,taskStatusId)/result")]
        static string SaveTask(ServiceType service, ChangeType change, IdType taskInstanceId, DateTimeType startDate, DateTimeType endDate, MediumStringType fileName, LongStringType inputFileLocation, LongStringType outputFileLocation, LongStringType asperaFileLocation, LongStringType statusMessage, RelatedItemIdType taskStatusId)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (taskStatusId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (fileName == MediumStringType.Null)
                return ExceptionType.ArgumentException;

            if (fileName == MediumStringType.Empty)
                return ExceptionType.ArgumentException;

            if (inputFileLocation == LongStringType.Null)
                return ExceptionType.ArgumentException;

            if (inputFileLocation == LongStringType.Empty)
                return ExceptionType.ArgumentException;

           
            return ExceptionType.NoError;
        }

        [Action("SaveVideoEncoding(change, id, name, service)/result")]
        static string SaveVideoEncoding(ChangeType change, IdType id, ShortStringType name, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (name > ShortStringType.Length50)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Empty)
                return ExceptionType.ArgumentException;

            if (name == ShortStringType.Null)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveVideoSeason(change, id, displayOriginalReleaseDate, geoCheckPolicy, isComplete, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, seasonNumber, visibilityDate, visibilityStatus, articles, categories, contributors, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveVideoSeason(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isComplete, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, IntegerType seasonNumber, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (seasonNumber == IntegerType.MinValue)
                return ExceptionType.ArgumentException;

            if (seasonNumber == IntegerType.Negative)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("SaveVideoSeries(change, id, displayOriginalReleaseDate, geoCheckPolicy, isOrderBySeason, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, productionCompany, visibilityDate, visibilityStatus, articles, categories, contributors, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveVideoSeries(InsertChangeType change, IdType id, ShortStringType displayOriginalReleaseDate, bool geoCheckPolicy, bool isOrderBySeason, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            
            return ExceptionType.NoError;
        }

        [Action("GetArticle(id, service)/result")]
        static string GetArticle(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetArticleArray(ids, service)/result")]
        static string GetArticleArray(ArrayType ids, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAudioEncodingArray(service)/result")]
        static string GetAudioEncodingArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCategorySystem(id, service)/result")]
        static string GetCategorySystem(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCategorySystemArray(service)/result")]
        static string GetCategorySystemArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetClientTypeArray(service)/result")]
        static string GetClientTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetContributor(id, service)/result")]
        static string GetContributor(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetContributorArray(ids, service)/result")]
        static string GetContributorArray(ArrayType ids, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetContributorRelationshipTypeArray(service)/result")]
        static string GetContributorRelationshipTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCountry(id, service)/result")]
        static string GetCountry(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCountryArray(service)/result")]
        static string GetCountryArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCurrency(id, service)/result")]
        static string GetCurrency(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCurrencyArray(service)/result")]
        static string GetCurrencyArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetDRMLicenseIssuer(id, service)/result")]
        static string GetDRMLicenseIssuer(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetDRMLicenseIssuerArray(service)/result")]
        static string GetDRMLicenseIssuerArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetEntity(id, service)/result")]
        static string GetEntity(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetEntityArray(service)/result")]
        static string GetEntityArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetGame(id, service)/result")]
        static string GetGame(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
               return ExceptionType.WebSGErrorException;
            return ExceptionType.NoError;
        }

/*        [Action("GetGameConsumable(id)/result")]
        static string GetGameConsumable(IdType id)
        {
            return ExceptionType.NoError;
        }
*/
        [Action("GetGameContent(id, service)/result")]
        static string GetGameContent(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetImage(id, service)/result")]
        static string GetImage(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetImageFormat(service)/result")]
        static string GetImageFormat(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetImageSizeArray(service)/result")]
        static string GetImageSizeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetLicenseClass(id, service)/result")]
        static string GetLicenseClass(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetLicenseClassArray(service)/result")]
        static string GetLicenseClassArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetLicenseType(id, service)/result")]
        static string GetLicenseType(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetLicenseTypeArray(service)/result")]
        static string GetLicenseTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetLocaleArray(service)/result")]
        static string GetLocaleArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        //[Action("GetMediaConcernArray(id)/result")]
        static string GetMediaConcernArray(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetMediaRelationshipTypeArray(service)/result")]
        static string GetMediaRelationshipTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetMediaTypeArray(service)/result")]
        static string GetMediaTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetMetadataProvider(id, service)/result")]
        static string GetMetadataProvider(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetMetadataProviderArray(service)/result")]
        static string GetMetadataProviderArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetOffer(id, service)/result")]
        static string GetOffer(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetPreviewMediaInstanceTypeArray(service)/result")]
        static string GetPreviewMediaInstanceTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetPricingRule(id, service)/result")]
        static string GetPricingRule(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetPricingRuleArray(service)/result")]
        static string GetPricingRuleArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetProvider(id, service)/result")]
        static string GetProvider(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetProviderArray(service)/result")]
        static string GetProviderArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetRatingSystem(id, service)/result")]
        static string GetRatingSystem(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetRatingSystemArray(service)/result")]
        static string GetRatingSystemArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetRoleArray(service)/result")]
        static string GetRoleArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetStoreArray(service)/result")]
        static string GetStoreArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetTasks(service)/result")]
        static string GetTasks(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableTaskAsXML(service)/result")]
        static string GetAvailableTaskAsXML(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetTaskStatusArray(service)/result")]
        static string GetTaskStatusArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetTaskByStatus(id, service)/result")]
        static string GetTaskByStatus(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetUserTypeArray(service)/result")]
        static string GetUserTypeArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVideo(id, service)/result")]
        static string GetVideo(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVideoDefinitionArray(service)/result")]
        static string GetVideoDefinitionArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVideoEncodingArray(service)/result")]
        static string GetVideoEncodingArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVideoSeason(id, service)/result")]
        static string GetVideoSeason(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVideoSeries(id, service)/result")]
        static string GetVideoSeries(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVisibilityLevelArray(service)/result")]
        static string GetVisibilityLevelArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetVisibilityStatusArray(service)/result")]
        static string GetVisibilityStatusArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableEntityId(service)/result")]
        static string GetAvailableEntityId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableCategoryId(service)/result")]
        static string GetAvailableCategoryId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableCategorySystemId(service)/result")]
        static string GetAvailableCategorySystemId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableRatingSystemId(service)/result")]
        static string GetAvailableRatingSystemId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableRatingValueId(service)/result")]
        static string GetAvailableRatingValueId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableRatingDescriptorId(service)/result")]
        static string GetAvailableRatingDescriptorId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetAvailableLicenseTypeId(service)/result")]
        static string GetAvailableLicenseTypeId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetCatalogId(service)/result")]
        static string GetCatalogId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetExternalId(service)/result")]
        static string GetExternalId(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetExternalFeedSource(service)/result")]
        static string GetExternalFeedSource(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetExternalFeedMappingObject(service)/result")]
        static string GetExternalFeedMappingObject(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("SaveExternalFeedMapping1(service)/result")]
        static string SaveExternalFeedMapping1(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("SaveExternalFeedMapping2()/result")]
        static string SaveExternalFeedMapping2()
        {           
            return ExceptionType.NoError;
        }

        [Action("SaveExternalFeedMapping3()/result")]
        static string SaveExternalFeedMapping3()
        {
            return ExceptionType.NoError;
        }

        [Action("Ping(service)/result")]
        static string Ping(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("PurgeTaskQueue(service)/result")]
        static string PurgeTaskQueue(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("GetPaymentMethod(id, service)/result")]
        static string GetPaymentMethod(IdType id, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("GetPaymentMethodArray(service)/result")]
        static string GetPaymentMethodArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("GetExternalFeedSourceArray(service)/result")]
        static string GetExternalFeedSourceArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

        [Action("GetExternalFeedMappingObjectArray(service)/result")]
        static string GetExternalFeedMappingObjectArray(ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("SaveVideo(change, id, crid, displayOriginalReleaseDate, duration, episodeNumber, geoCheckPolicy, isan, mediaTitle, mediaTypeId, metadataProviderId, originalReleaseDate, productionCompany, spokenLanguage, subTitle, upc, visibilityDate, visibilityStatus, articles, categories, contributors, mediaInstances, locales, ratingDescriptors, ratingValues, relationships, service)/result")]
        static string SaveVideo(InsertChangeType change, IdType id, ShortStringType crid, ShortStringType displayOriginalReleaseDate, IntegerType duration, IntegerType episodeNumber, bool geoCheckPolicy, ShortStringType isan, MediumStringType mediaTitle, RelatedItemIdType mediaTypeId, RelatedItemIdType metadataProviderId, DateTimeType originalReleaseDate, ShortStringType productionCompany, RelatedItemIdType spokenLanguage, ShortStringType subTitle, ShortStringType upc, DateTimeType visibilityDate, RelatedItemIdType visibilityStatus, ArrayType articles, ArrayType categories, ArrayType contributors, ArrayType mediaInstances, ArrayType locales, ArrayType ratingDescriptors, ArrayType ratingValues, ArrayType relationships, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            if (mediaTypeId == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (spokenLanguage == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            if (visibilityStatus == RelatedItemIdType.NotSpecified)
                return ExceptionType.ArgumentException;

            return ExceptionType.NoError;
        }
        [Action("GameOfferSearch(Title,rows, service)/result")]
        static string GameOfferSearch(StringType Title, MaxRows rows, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("GamePublisherSearch(Id,rows, service)/result")]
        static string GamePublisherSearch(FindType Id, MaxRows rows, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }
        [Action("GameTitleSearch(Title,Lcid,rows, service)/result")]
        static string GameTitleSearch(StringType Title, IntegerType Lcid, MaxRows rows, ServiceType service)
        {
            if (service == ServiceType.WrongHeader || service == ServiceType.NoHeader)
                return ExceptionType.WebSGErrorException;

            return ExceptionType.NoError;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\archive\LiveTools\functional\LiveToolsTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;

using Microsoft.VisualStudio.TestTools.UnitTesting;

using ContentIngestionService;
using xonline.common.tools.stutilcore;
using xonline.common.protocol;
using xonline.common.utilities;

namespace LiveTools_4998_Functional
{
    internal class Config
    {
        static Config()
        {
            System.Reflection.Assembly thisAssembly = System.Reflection.Assembly.GetExecutingAssembly();

            Configuration config = ConfigurationManager.OpenExeConfiguration(thisAssembly.Location);

            NpdbServer = config.AppSettings.Settings["NpdbServer"].Value;
            NpdbDatabase = config.AppSettings.Settings["NpdbDatabase"].Value;

            UodbServer = config.AppSettings.Settings["UodbServer"].Value;
            UodbDatabase = config.AppSettings.Settings["UodbDatabase"].Value;

            WebServiceMachine = config.AppSettings.Settings["WebServiceMachine"].Value;
            WebServicePort = int.Parse(config.AppSettings.Settings["WebServicePort"].Value);
            WebServicePath = config.AppSettings.Settings["WebServicePath"].Value;

            DatabaseServer = config.AppSettings.Settings["DatabaseServer"].Value;
            
            DownloadMachine = config.AppSettings.Settings["DownloadMachine"].Value;
            
            LiveToolsPath = config.AppSettings.Settings["LiveToolsPath"].Value;
            TitleVaultPath = config.AppSettings.Settings["TitleVaultPath"].Value;
        }

        static public string DatabaseServer;
        static public string DownloadMachine;
        static public string NpdbServer;
        static public string NpdbDatabase;
        static public string LiveToolsPath;
        static public string TitleVaultPath;
        static public string UodbServer;
        static public string UodbDatabase;
        static public string WebServiceMachine;
        static public string WebServicePath;
        static public int WebServicePort;
    }

    internal class CatalogServicesInternal : CatalogServices
    {
        private Random random = new Random();

        protected override System.Net.WebRequest GetWebRequest(Uri uri)
        {
            System.Net.HttpWebRequest webRequest = (System.Net.HttpWebRequest)base.GetWebRequest(uri);
            webRequest.Headers.Add("Subject-Name", "MarketplaceInternalPartner");
            webRequest.Headers.Add("Client-IP-Port", "127.0.0.1:80");

            byte[] randomBytes = new byte[8];
            random.NextBytes(randomBytes);

            StringBuilder stringBuilder = new StringBuilder();

            foreach (byte randomByte in randomBytes)
            {
                stringBuilder.AppendFormat("{0:x2}", randomByte);
            }

            webRequest.Headers.Add("RequestId", stringBuilder.ToString());

            return webRequest;
        }
    }

    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class LiveToolsTests
    {
        public LiveToolsTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;
        private static CatalogServicesInternal webService;
        private static string liveContentOutputPath = String.Empty;
        private static string liveContentLocalPath = String.Empty;
        private DateTime VisibilityDate = DateTime.UtcNow;
        private static StringBuilder sbOutput;
        private static bool extractTestData = false;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        [ClassInitialize()]
        public static void ClassInitialize(TestContext testContext)
        {
            string databaseAddress = Dns.GetHostAddresses(Config.DatabaseServer)[0].ToString();

            //connectionString = String.Format("Data Source={0};Initial Catalog=RawCatalogDB;Integrated Security=True;Pooling=False", Config.DatabaseServer);
            //connection = new SqlConnection(connectionString);

            //connection.Open();

            webService = new CatalogServicesInternal();
            webService.Url = String.Format("http://{0}:{1}/{2}", Config.WebServiceMachine, Config.WebServicePort, Config.WebServicePath);

            liveContentLocalPath = String.Format("{0}\\Content\\LiveToolsTests\\", Config.LiveToolsPath);
            liveContentOutputPath = String.Format("\\\\{0}\\Content\\LiveToolsTests\\", Config.DownloadMachine);

            SetupTestFiles(testContext);
        }

        private static string ExecuteSql(SqlConnection sqlConnection, string commandText)
        {
            Trace.WriteLine(String.Format("ExecuteSql(): SQL command is: '{0}'", commandText));

            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.CommandText = commandText;

            object returnValue = sqlCommand.ExecuteScalar();

            if (null != returnValue)
            {
                Trace.WriteLine(String.Format("ExecuteSql(): Return value is: '{0}'", returnValue));
                return returnValue.ToString();
            }

            Trace.WriteLine("ExecuteSql(): No return value.");
            return null;
        }

        private static SqlDataReader ExecuteSqlReader(SqlConnection sqlConnection, string commandText)
        {
            Trace.WriteLine(String.Format("ExecuteSqlReader(): SQL command is: '{0}'", commandText));

            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.CommandText = commandText;

            return sqlCommand.ExecuteReader();
        }

        private static void DeleteLtc(string titleId)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.NpdbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.NpdbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                Trace.WriteLine("Deleting LTC from NPDB...");

                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.CommandText = "p_live_title_config_delete";

                sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = Convert.ToInt32(titleId, 16);
                sqlCommand.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();
            }
        }

        private static void PropXboxTitle(string path, string titleId)
        {
            string ltcFile = String.Format("{0}\\{1}_ltc.xml", Config.LiveToolsPath, titleId);
            if (true == File.Exists(ltcFile))
            {
                File.Delete(ltcFile);
            }

            DeleteLtc(titleId);

            string commandLine = String.Format("{0}\\livetitle.exe", Config.LiveToolsPath);

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/lbs:{0} /matchsvr:{1} ", Config.DatabaseServer, Config.DatabaseServer);
            arguments.Append("/xboxdefault /noreload /verbose ");
            arguments.AppendFormat("/xboxpath:\"{0}\\{1}.xbox\"", path, titleId);

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            string liveTitleOutput = RunLiveTool(commandLine, arguments.ToString());

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Trace.WriteLine(liveTitleOutput);
                Assert.Fail("An error occurred in the tool");
            }

            arguments = new StringBuilder();
            arguments.Append("/deployxbox /noreload /verbose ");
            arguments.AppendFormat("/xboxpath:\"{0}\\{1}.xbox\" ", path, titleId);
            arguments.AppendFormat("/ltcpath:\"{0}\"", ltcFile);

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            liveTitleOutput = RunLiveTool(commandLine, arguments.ToString());

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Trace.WriteLine(liveTitleOutput);
                Assert.Fail("An error occurred in the tool");
            }
        }

        private static void PropXlastTitle(string path, string titleId)
        {
            string ltcFile = String.Format("{0}\\{1}_ltc.xml", Config.LiveToolsPath, titleId);
            if (true == File.Exists(ltcFile))
            {
                File.Delete(ltcFile);
            }

            DeleteLtc(titleId);

            string commandLine = String.Format("{0}\\livetitle.exe", Config.LiveToolsPath);

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/lbs:{0} /matchsvr:{1} ", Config.DatabaseServer, Config.DatabaseServer);
            arguments.Append("/livetitledefault /noreload /verbose ");
            arguments.AppendFormat("/xlastpath:\"{0}\\{1}.xlast\"", path, titleId);

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            string liveTitleOutput = RunLiveTool(commandLine, arguments.ToString());

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Trace.WriteLine(liveTitleOutput);
                Assert.Fail("An error occurred in the tool");
            }

            arguments = new StringBuilder();
            arguments.Append("/deploy /noreload /verbose ");
            arguments.AppendFormat("/xlastpath:\"{0}\\{1}.xlast\" ", path, titleId);
            arguments.AppendFormat("/ltcpath:\"{0}\"", ltcFile);

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            liveTitleOutput = RunLiveTool(commandLine, arguments.ToString());

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Trace.WriteLine(liveTitleOutput);
                Assert.Fail("An error occurred in the tool");
            }
        }

        private static void PropMarketPlaceTitle(string path, string titleId)
        {
            string commandLine = String.Format("{0}\\livetitle.exe", Config.LiveToolsPath);

            StringBuilder arguments = new StringBuilder();
            arguments.Append("/deploy /verbose ");
            arguments.AppendFormat("/marketplacepath:\"{0}\\{1}.marketplace\"", path, titleId);

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            string liveTitleOutput = RunLiveTool(commandLine, arguments.ToString());

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:"))
            {
                Trace.WriteLine(liveTitleOutput);
                Assert.Fail("An error occurred in the tool");
            }
        }

        private static void SetupTestFiles(TestContext testContext)
        {
            if (true == Directory.Exists(Config.TitleVaultPath))
            {
                Directory.Delete(Config.TitleVaultPath, true);
            }

            Directory.CreateDirectory(Config.TitleVaultPath);

            Directory.CreateDirectory(String.Format("{0}\\FFFE07F1\\", Config.TitleVaultPath));

            string defaultOfferTarget = String.Format("{0}\\xblob\\ZDefault", Config.TitleVaultPath);
            Directory.CreateDirectory(defaultOfferTarget);

            string defaultOfferSource = String.Format("{0}\\", testContext.TestDeploymentDir);
            string[] defaultOffers = Directory.GetFiles(defaultOfferSource, "Default_*.offer");

            foreach (string defaultOffer in defaultOffers)
            {
                string targetFile = defaultOffer.Replace(Path.GetDirectoryName(defaultOffer), defaultOfferTarget);
                File.Copy(defaultOffer, targetFile, true);
            }

            File.Copy(String.Format("{0}\\0xFFFFFFFFFFFFFFFF.PNG", defaultOfferSource), String.Format("{0}\\0xFFFFFFFFFFFFFFFF.PNG", defaultOfferTarget), true);

            string setupDirSource = String.Format("{0}\\Setup", testContext.TestDeploymentDir);
            string[] setupDirs = Directory.GetDirectories(setupDirSource);

            foreach (string setupDir in setupDirs)
            {
                string titleId = Path.GetFileName(setupDir);

                if (true == File.Exists(setupDir + "\\" + titleId + ".xbox"))
                {
                    PropXboxTitle(setupDir, titleId);
                }

                if (true == File.Exists(setupDir + "\\" + titleId + ".xlast"))
                {
                    PropXlastTitle(setupDir, titleId);
                }

                if (true == File.Exists(setupDir + "\\" + titleId + ".marketplace"))
                {
                    PropMarketPlaceTitle(setupDir, titleId);
                }
            }
        }

        #region Additional test attributes
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        #region LiveOffer
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveOffers.xml", "OfferBVT", DataAccessMethod.Sequential), TestMethod]
        public void LiveOfferBVTs()
        {
            RunLiveOfferTests();
        }

        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveOffers.xml", "Offer", DataAccessMethod.Sequential), TestMethod]
        public void LiveOfferFunctionalTests()
        {
            RunLiveOfferTests();
        }

        public void RunLiveOfferTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string titleId = (string)TestContext.DataRow["TitleId"];
            string consoleTypeIdString = TryGetColumnValue("ConsoleTypeId");
            string filename1 = (string)TestContext.DataRow["Filename1"];
            string filename2 = TryGetColumnValue("Filename2");
            string actionList = (string)TestContext.DataRow["Action"];
            string originalOfferId1 = (string)TestContext.DataRow["OfferId1"];
            string originalOfferId2 = TryGetColumnValue("OfferId2");
            string packageFile = TryGetColumnValue("PackageFile");
            string exceptionText = TryGetColumnValue("ExceptionText");
            string[] exceptions = (null == exceptionText) ? null : exceptionText.Split(';');
            string mediaType = TryGetColumnValue("MediaType");
            string commandLineArgs = TryGetColumnValue("CommandLineArgs");
            string expireList = TryGetColumnValue("ExpireFilename");
            string expirationDate = TryGetColumnValue("ExpirationDate");
            string expectedCategories = TryGetColumnValue("ExpectedCategories");
            string expectedAvatarItemBodyTypeId = TryGetColumnValue("ExpectedAvatarItemBodyTypeId");
            string hasContributorString = TryGetColumnValue("HasContributor");
            string finalTitleId = ((titleId == XNArelatedTitle1) || (titleId == XNArelatedTitle2)) ? originalOfferId1.Substring(0, 10) : titleId;
            string finalAltTitleId = ((titleId == XNArelatedTitle1) || (titleId == XNArelatedTitle2)) ? titleId : null;
            string finalTitleId2 = null;
            string providerIdstring = TryGetColumnValue("providerId");  // the default providerId for providerId test cases.
            string testName = TryGetColumnValue("Name");
            string description = TryGetColumnValue("Description");

            int consoleTypeId = 2;
            int providerId = -1;

            if (null != consoleTypeIdString)
            {
                consoleTypeId = Convert.ToInt16(consoleTypeIdString);
            }

            if (extractTestData)
            {
                string offerIds = "";
                if (originalOfferId1 != null)
                    offerIds += originalOfferId1;
                if (originalOfferId2 != null)
                    offerIds += ";" + originalOfferId2;
                TestDataMigration.StartTestCapture(TestDataMigration.TestType.LIVE_OFFER, "LiveOffer", testName, description, titleId, consoleTypeIdString, offerIds);
            }

            bool hasContributor = false;

            if (null != hasContributorString)
            {
                hasContributor = Convert.ToBoolean(hasContributorString);
            }

            if (!string.IsNullOrEmpty(providerIdstring))
            {
                if (!Int32.TryParse(providerIdstring, out providerId))
                {
                    providerId = -1;
                }
            }


            string offerId1 = String.Format("{0}-0000-4000-8000-0000{1}", originalOfferId1.Substring(10, 8), originalOfferId1.Substring(2, 8));
            string offerId2 = null != originalOfferId2 ? String.Format("{0}-0000-4000-8000-0000{1}", originalOfferId2.Substring(10, 8), originalOfferId2.Substring(2, 8)) : null;

            bool shouldBeVisible = Convert.ToBoolean(TestContext.DataRow["Visible"]);
            bool isExpirationTest = null != expirationDate ? true : false;

            CleanLiveContentOutput();

            CleanOffer(offerId1);

            if (null != offerId2)
            {
                CleanOffer(offerId2);
            }

            if (null != packageFile)
            {
                RunLiveContent(packageFile, filename1, originalOfferId1, null, null, titleId, "build", null, true);
            }
            else
            {
                if (null == commandLineArgs)
                {
                    commandLineArgs = "-skipxrl";
                }
                else
                {
                    commandLineArgs += " -skipxrl";
                }
            }

            string liveOfferOutput = null;

            foreach (string action in actionList.Split(';'))
            {
                if (isExpirationTest)
                {
                    Directory.CreateDirectory(String.Format("{0}\\{1}", Config.TitleVaultPath, titleId.Substring(2)));
                    File.Copy(String.Format("{0}\\{1}", testContextInstance.TestDeploymentDir, filename1), String.Format("{0}\\{1}\\{2}", Config.TitleVaultPath, titleId.Substring(2), Path.GetFileName(filename1)), true);
                }

                if (action.Equals("expire", StringComparison.InvariantCultureIgnoreCase))
                {
                    liveOfferOutput = RunLiveOffer(expireList, titleId, action, commandLineArgs);
                }
                else
                {
                    liveOfferOutput = RunLiveOffer(filename1, titleId, action, commandLineArgs);
                }
            }

            if (null != filename2)
            {
                foreach (string action in actionList.Split(';'))
                {
                    liveOfferOutput = RunLiveOffer(filename2, titleId, action, commandLineArgs);

                    if ((liveOfferOutput.Contains("LiveTool exit code: -1")) || (liveOfferOutput.Contains("Exception:")) || (liveOfferOutput.Contains("LiveOffer error (aborting)")))
                    {
                        Assert.Fail("An error occurred in the tool");
                    }
                }
            }

            if (!String.IsNullOrEmpty(exceptionText))
            {
                bool expectedException = false;

                foreach (string exception in exceptions)
                {
                    if (true == liveOfferOutput.Contains(exception))
                    {
                        expectedException = true;
                        return;
                    }
                }

                Assert.IsTrue(expectedException, "Expected exception did not occur");
            }
            else if ((liveOfferOutput.Contains("LiveTool exit code: -1")) || (liveOfferOutput.Contains("Exception:")) || (liveOfferOutput.Contains("LiveOffer error (aborting)")))
            {
                Assert.Fail("An error occurred in the tool");
            }

            // Action="validate" Visible="false" offers can't be validated
            // because livetoolsbvts infrastructure doesn't support cleaning up of offers and gamecontent, so skip this validation
            if (actionList == "validate")
                return;

            if (!extractTestData)
            {
                VerifyOffer(offerId1, filename1, shouldBeVisible, (null == filename2) ? 3 : 5, finalTitleId, finalAltTitleId, consoleTypeId, 1, originalOfferId1, mediaType, isExpirationTest, expirationDate, expectedCategories, hasContributor, expectedAvatarItemBodyTypeId, providerId);

                if (null != offerId2)
                {
                    finalTitleId2 = ((titleId == XNArelatedTitle1) || (titleId == XNArelatedTitle2)) ? originalOfferId2.Substring(0, 10) : titleId;
                    VerifyOffer(offerId2, filename1, shouldBeVisible, 3, finalTitleId2, finalAltTitleId, consoleTypeId, 2, originalOfferId2, mediaType, isExpirationTest, expirationDate, expectedCategories, hasContributor, expectedAvatarItemBodyTypeId, providerId);
                }
            }
        }

        private void CleanOffer(string offerId)
        {
            Trace.WriteLine(String.Format("Calling GetOffer on the Catalog Web Service to find offer '{0}'...", offerId));

            Offer offer = webService.GetOffer(new Guid(offerId));

            if (null != offer)
            {
                Trace.WriteLine("Offer found.  Calling SaveOffer on the Catalog Web Service to delete the offer.");

                // TODO: Remove this when bug LSG3741 is fixed 
                // UPDATE 2009/03/18: This bug was resolved as By Design. a-jsmoll
                //                    Do not remove this code!            a-jsmoll
                offer.OfferType = OfferMode.Game;
                webService.SaveOffer(offer);
            }
            else
            {
                Trace.WriteLine("Offer not found.");
            }
        }

        private string RunLiveOffer(string filename, string titleId, string action, string commandLineArgs)
        {
            string commandLine = String.Format("{0}\\liveoffer.exe", Config.LiveToolsPath);
            string arguments = null;

            if (action.Equals("expireall", StringComparison.InvariantCultureIgnoreCase))
            {
                arguments = String.Format("-action:{0} -titleid:{1}", action, titleId);
            }
            else
            {
                arguments = String.Format("-action:{0} -file:\"{1}\\{2}\" -titleid:{3}", action, testContextInstance.TestDeploymentDir, filename, titleId);
            }

            if (null != commandLineArgs)
            {
                arguments = String.Format("{0} {1}", arguments, commandLineArgs);
            }

            Trace.WriteLine(String.Format("Running LiveOffer.  Command line is: '{0} {1}'", commandLine, arguments));

            if(extractTestData)
                TestDataMigration.MigrateTest(commandLine, arguments.ToString());

            return RunLiveTool(commandLine, arguments);
        }

        private void VerifyOffer(string offerId, string filename, bool shouldBeVisible, int visibilityStatusId, string titleId, string altTitleId, int consoleTypeId, int offerIndex, string originalOfferId, string mediaType, bool isExpirationTest, string expirationDate, string expectedCategories, bool hasContributor, string expectedAvatarItemBodyTypeId, int providerId)
        {
            string inheritRatingXPath = "/x:LiveOffer/x:contentOffer/x:inheritRating";
            string ratingXPath = "/x:LiveOffer/x:contentOffer/x:rating";
            string offerRegionInfoXPath = "/x:LiveOffer/x:contentOffer/x:offerBasicInfo/x:offerRegionInfo";

            Trace.WriteLine(String.Format("Verifying that offer '{0}' is {1}visible...", offerId, shouldBeVisible ? String.Empty : "not "));

            Offer offer = webService.GetOffer(new Guid(offerId));
            Guid expectedMediaInstanceId = Guid.Empty;

            DateTime newEndDate = DateTime.Now;

            if (null != expirationDate)
                newEndDate = DateTime.Parse(expirationDate);

            List<string> listImages = new List<string>();

            if (true == shouldBeVisible)
            {
                Assert.IsNotNull(offer, "GetOffer returned NULL.  The offer is expected to be in the EMS catalog but doees not appear to be there");
                Assert.IsTrue(CheckOfferInstancesVisibility(offer, visibilityStatusId), "GetOffer returned an offer object but not all offer instances are visible/live");

                foreach (OfferInstance instance in offer.Instances)
                {
                    string[] guidParts = instance.Id.ToString().Split('-');

                    string actualUserType = guidParts[1].Substring(0, 1);
                    string expectedUserType = instance.UserTypes.Length > 1 ? "0" : instance.UserTypes[0].UserTypeId.ToString("X1");

                    Trace.WriteLine(String.Format("Verifying that the ID for OfferInstance {0} contains a UserType of {1}", instance.Id, expectedUserType));

                    Assert.AreEqual(expectedUserType, actualUserType, "The OfferInstance ID does not contain the expected user type");

                    Assert.IsTrue(guidParts[2].StartsWith("400"), "The OfferInstance ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                    Assert.IsTrue(guidParts[2].EndsWith(instance.PaymentTypeId.ToString()), "The OfferInstance ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                    Assert.AreEqual("8000", guidParts[3], "The OfferInstance ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                    Assert.AreEqual("0000", guidParts[4].Substring(0, 4), "The OfferInstance ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                    Assert.AreEqual(titleId.Substring(2).ToUpper(), guidParts[4].Substring(4, 8).ToUpper(), "The OfferInstance ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");

                    foreach (ProviderTerm term in instance.ProviderTerms)
                    {
                        guidParts = term.Id.ToString().Split('-');

                        Trace.WriteLine(String.Format("Verifying that the ID for ProviderTerm {0} contains a DRMLicenseIssuerId of 38", term.Id));

                        Assert.AreEqual(38, term.DRMLicenseIssuerId, "The DRMLicenseIssuerId for one or more ProviderTerm instances for this offer is not 38 (Microsoft)");

                        Assert.IsTrue(guidParts[2].StartsWith("400"), "The ProviderTerm ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                        Assert.IsTrue(guidParts[2].EndsWith(instance.PaymentTypeId.ToString()), "The ProviderTerm ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                        Assert.AreEqual("8000", guidParts[3], "The ProviderTerm ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                        Assert.AreEqual("0000", guidParts[4].Substring(0, 4), "The ProviderTerm ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");
                        Assert.AreEqual(titleId.Substring(2).ToUpper(), guidParts[4].Substring(4, 8).ToUpper(), "The ProviderTerm ID does not match the expected pattern of nnnnnnnn-nnnn-4001-8000-0000<title-id>");

                        foreach (ProviderTermMediaInstance termMediaInstance in term.MediaInstances)
                        {
                            if (expectedMediaInstanceId == Guid.Empty)
                            {
                                expectedMediaInstanceId = termMediaInstance.MediaInstanceId;
                            }
                            else
                            {
                                Assert.IsTrue(expectedMediaInstanceId == termMediaInstance.MediaInstanceId,
                                    "The ProviderTermMediaInstances are not all using the same MediaInstance. This is expected for game offers.");
                            }
                        }
                    }
                }
                // BUG 3174 - LSG.  By design
                //if (offer.OfferType != OfferMode.Game)
                //    throw new DataException(String.Format("The OfferType is {0} when it should be OfferMode.Game.", offer.OfferType));

                XmlDocument offerFile = new XmlDocument();
                offerFile.Load(String.Format(".\\{0}", filename));
                XmlNamespaceManager namespaceManager = new XmlNamespaceManager(offerFile.NameTable);
                namespaceManager.AddNamespace("x", offerFile.DocumentElement.NamespaceURI);

                if (offerFile.DocumentElement.NamespaceURI.EndsWith("xboxoffer"))
                {
                    // Xbox1 offer
                    CompareXmlToPropertyValue(offerFile, namespaceManager, "/x:XboxOffers/x:XboxContentOffer/x:xboxOfferBasicInfo/@friendlyName", offer.Name);
                }
                else
                {
                    string xPath = String.Format("/x:LiveOffer/x:contentOffer[{0}]", offerIndex);

                    // Xbox360 offer
                    CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:friendlyName", offer.Name);
                    //                    CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerRegionInfo[1]/x:paymentTypePoints/x:priceInPoints", offer.Instances[0].Price);
                    CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerDMPInfo/x:sku/x:sku", offer.Instances[0].Sku);
                    CompareXmlToPropertyValue(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:contentID", offer.Instances[0].ProviderTerms[0].ExternalProviderContentId);

                    // verify license type
                    VerifyLicenseType(mediaType, offer, offerFile, namespaceManager, xPath);

                    CompareXmlNodesToArray(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerRegionInfo", offer.Instances, "x:startDate", "StartDateTime", null, null, null);

                    if (!isExpirationTest)
                    {
                        CompareXmlNodesToArray(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerRegionInfo", offer.Instances, "x:endDate", "EndDateTime", null, null, null);
                    }
                    else
                    {
                        foreach (OfferInstance instance in offer.Instances)
                        {
                            Trace.WriteLine(String.Format("Checking that new end date for offer instance {0} is {1}.", instance.Id, newEndDate));

                            Assert.AreEqual(newEndDate, instance.EndDateTime, "OfferInstance end date does not match the expected end date");
                        }
                    }

                    CompareXmlNodesToArray(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerRegionInfo", offer.Instances, "x:paymentTypePoints/x:priceInPoints", "Price", null, null, null);

                    Trace.WriteLine("Checking payment types for each offer instance.");

                    XmlNodeList nodeList = offerFile.SelectNodes(xPath + "/x:offerBasicInfo/x:offerRegionInfo", namespaceManager);
                    XmlNodeList nodeListPoints = offerFile.SelectNodes(xPath + "/x:offerBasicInfo/x:offerRegionInfo/x:paymentTypePoints", namespaceManager);
                    XmlNodeList nodeListCreditCards = offerFile.SelectNodes(xPath + "/x:offerBasicInfo/x:offerRegionInfo/x:paymentTypeCreditCard", namespaceManager);

                    Assert.AreEqual(nodeList.Count + nodeListPoints.Count + nodeListCreditCards.Count, offer.Instances.Length, "OfferInstances count does not match the expected count");

                    int nextNode = 0;
                    int nextNodeForCreditCards = 0;
                    int nextInstance = 0;
                    foreach (OfferInstance instance in offer.Instances)
                    {
                        nextInstance++;
                        if (2 == instance.PaymentTypeId)
                        {
                            Assert.AreEqual(3, instance.VisibilityLevelId, "Payment type is token but VisibilityLevelId is not 3 (NeverEumerate)!");

                            continue;
                        }

                        if (3 == instance.PaymentTypeId)
                        {

                            CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerEnumerationType", instance.VisibilityLevelId);

                            XmlNode nodeForCC = nodeList.Item(nextNodeForCreditCards++);

                            Assert.IsTrue(IsPaymentTypeExpected(nodeForCC, namespaceManager, instance.PaymentTypeId), "Payment type does not match the expected payment type");

                            continue;
                        }

                        CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerBasicInfo/x:offerEnumerationType", instance.VisibilityLevelId);

                        XmlNode node = nodeList.Item(nextNode++);

                        Assert.IsTrue(IsPaymentTypeExpected(node, namespaceManager, instance.PaymentTypeId), "Payment type does not match the expected payment type");
                    }
                }

                if ((null != originalOfferId) && (3 == visibilityStatusId))
                {
                    Guid gameContentId = BuildGameContentId(titleId, consoleTypeId, ulong.Parse(originalOfferId.Substring(2), System.Globalization.NumberStyles.HexNumber), mediaType);

                    if (mediaType == MediaTypeAvatarItem)
                    {
                        XmlNode node = offerFile.SelectSingleNode("/x:LiveOffer/x:contentOffer/x:gameContentMediaId", namespaceManager);

                        Assert.IsNotNull(node, "documentContentXPath did not return a node for gameContentMediaId. This is expected for this media type.");

                        gameContentId = new Guid(node.InnerText.Trim());
                    }

                    Trace.WriteLine(String.Format("Calling the catalog web service to get game content {0}", gameContentId));

                    GameContent gameContent = webService.GetGameContent(gameContentId);

                    Assert.IsNotNull(gameContent, "The web service returned null.  The game content was not found in the catalog.");

                    //Verify Contributor
                    if (hasContributor)
                    {
                        Contributor contributor = webService.GetContributor(gameContent.Contributors[0].ContributorId);
                        string xPath = String.Format("/x:LiveOffer/x:contentOffer[{0}]", offerIndex);
                        if (contributor != null)
                        {
                            CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:creatorContributorId", contributor.Id);
                        }
                        else
                            Trace.WriteLine("The contributor is expected to be in the EMS catalog but doesn't appears to be there");
                    }

                    Trace.WriteLine("Checking GameContentInstanceFiles against source XML document...");

                    foreach (GameContentInstance contentInstance in gameContent.Instances)
                    {
                        // media instances from previous runs are not removed by livetools
                        // and just become old objects not referenced by any offers
                        if (contentInstance.Id == expectedMediaInstanceId)
                        {
                            CompareXmlNodesToArray(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:contentLocation", contentInstance.GameContentInstanceFiles, "x:rank", "SortOrder", null, null, null);
                            CompareXmlNodesToArray(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:contentLocation", contentInstance.GameContentInstanceFiles, "x:xrl", "FileUrl", null, null, null);
                            CompareXmlToPropertyValue(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:symKey", contentInstance.EncryptedKey.EncryptedSymKey);
                            CompareXmlToPropertyValue(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:publicKey", contentInstance.EncryptedKey.EncryptedPublicKey);
                            CompareXmlToPropertyValue(offerFile, namespaceManager, "/x:LiveOffer/x:content/x:contentID", contentInstance.LiveContentId);

                            int defaultGameRegionMaskId = -1;
                            XmlNode gameRegionMask = offerFile.SelectSingleNode("/x:LiveOffer/x:content/x:gameRegion", namespaceManager);
                            //If gameRegionMask is null, it means the gameRegion node isn't in the offer file.
                            //This occurs in older offer files.
                            if (gameRegionMask == null) 
                                Assert.AreEqual(contentInstance.SupportedGameRegionMaskId, defaultGameRegionMaskId);
                            else
                                Assert.AreEqual(contentInstance.SupportedGameRegionMaskId, (int)Convert.ToUInt32(gameRegionMask.InnerText));
                        }
                    }

                    List<ImageInstance> images = new List<ImageInstance>();

                    Trace.WriteLine("Checking image filenames...");
                    foreach (MediaRelationship relationship in gameContent.Relationships)
                    {
                        Image image = webService.GetImage(relationship.RelatedMediaId);

                        if (null != image && image.Instances.Length > 0 && image.Instances[0] is ImageInstance)
                        {
                            Assert.AreEqual(1, image.Instances.Length, "Image has an instance count greater than 1");

                            images.Add((ImageInstance)image.Instances[0]);

                            // only check all images when the gameContent is independent of the game itself
                            // because if they are the same media, the game might have been propped before and
                            // some of their images will have a different VisibilityDate
                            if ((null != image) && (gameContent.Id != gameContent.GameMediaId))
                            {
                                Trace.WriteLine("Checking VisibilityDate (Image)...");
                                Assert.AreEqual(VisibilityDate.ToShortDateString(), image.VisibilityDate.Value.ToShortDateString(), "Image visibility date does not match the expected visibility date");
                            }
                        }
                    }

                    // Verify ProviderId
                    if (providerId != -1)
                    {
                        Trace.WriteLine("Checking ProviderID values for all Offer Instances...");
                        int defaultProviderId = providerId;   // the default providerID is used when no providerId tag is in offer file.
                                                              // default providerID is generated from the title ID; so it is the same value for all countries in the offer.
                        const int goldUser = 2;               
                        const int silverUser = 3;
                        XmlNodeList regionInfoNodes = offerFile.SelectNodes(offerRegionInfoXPath, namespaceManager);

                        foreach (OfferInstance oi in offer.Instances)
                        {
                            foreach (OfferInstanceUserType userType in oi.UserTypes)
                            {
                                string userTypeName;

                                switch (userType.UserTypeId)
                                {
                                    case goldUser:
                                        userTypeName = "Gold";
                                        break;
                                    case silverUser:
                                        userTypeName = "Silver";
                                        break;
                                    default:
                                        userTypeName = "undefined";
                                        break;
                                }

                                foreach (XmlNode regionInfoNode in regionInfoNodes)    
                                {
                                    string countryCodeFromXml = CountryDictionary.CountryCode(Byte.Parse(regionInfoNode.SelectSingleNode("x:countryID", namespaceManager).InnerText));
                                    string liveTierFromXml = regionInfoNode.SelectSingleNode("x:liveTier", namespaceManager).InnerText;

                                    if (countryCodeFromXml == oi.CountryCode && liveTierFromXml == userTypeName)  // find an xml node that matches web service offer instance.
                                    {
                                        XmlNode providerNode = regionInfoNode.SelectSingleNode("x:providerId", namespaceManager);
                                        
                                        if (null != providerNode)
                                        {
                                            // get the providerId from xml.
                                            int providerIdFromXml = Int32.Parse(providerNode.InnerText);

                                            CheckProviderId(oi.ProviderTerms, userTypeName, providerIdFromXml, countryCodeFromXml, liveTierFromXml);
                                        }
                                        else
                                        {
                                            // The providerId node does not exist.
                                            CheckProviderId(oi.ProviderTerms, userTypeName, defaultProviderId, countryCodeFromXml, liveTierFromXml);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //Checking for Categories
                    if (expectedCategories != null)
                    {

                        Trace.WriteLine("Checking Categories...");
                        Assert.AreEqual(expectedCategories.Split(',').Length, gameContent.Categories.Length, "Number of Categories in the catalog does not match the number of expected categories");

                        List<string> gameContentCategories = new List<string>();
                        foreach (MediaCategory cat in gameContent.Categories)
                        {
                            gameContentCategories.Add(cat.CategoryId.ToString());
                        }

                        foreach (String expectedValue in expectedCategories.Split(','))
                        {
                            if (!gameContentCategories.Contains(expectedValue))
                            {
                                Assert.IsTrue(gameContentCategories.Contains(expectedValue), string.Format("Expected Category {0} not found", expectedValue));
                            }
                        }
                    }

                    if (0 < listImages.Count)
                    {
                        CompareXmlNodesToArray(offerFile, namespaceManager, "/x:LiveOffer/x:contentOffer/x:offerBasicInfo/x:offerCultureDetails", images.ToArray(), "x:imageFilePath", "FileUrl", null, null, null);
                    }

                    Trace.WriteLine("Checking VisibilityDate (GameContent)...");
                    Assert.AreEqual(VisibilityDate.ToShortDateString(), gameContent.VisibilityDate.Value.ToShortDateString(), "GameContent visibility date does not match the expected visibility date");

                    //Rating verifications game content
                    if (gameContent.Id != gameContent.GameMediaId)    // this is game content, not a game.
                    {
                        Trace.WriteLine("Checking Rating Counts for GameContent...");
                        CompareXmlNodeCountToArrayLength(offerFile, namespaceManager, ratingXPath,
                                                         gameContent.RatingValues.Length, true);

                        Trace.WriteLine("Checking Rating Values for GameContent...");
                        CompareXmlNodesToArray(offerFile, namespaceManager, ratingXPath,
                                               gameContent.RatingValues, "", "RatingValueId", null, null, null);

                        // Inherit Ratings verifications
                        Trace.WriteLine("\nChecking Inherit Rating value for GameContent...");
                        CompareXmlToInheritRating(offerFile, namespaceManager, inheritRatingXPath, 
                            ratingXPath, gameContent.InheritRating);
                    }

                    if (expectedAvatarItemBodyTypeId != null)
                    {
                        Trace.WriteLine(String.Format("Checking AvatarItemBodyType value {0} for GameContent...", expectedAvatarItemBodyTypeId));

                        Assert.IsNotNull(gameContent.AvatarItem, "The AvatarItem is not expected to be in the EMS catalog but appears to be there.");
                        Assert.AreEqual(expectedAvatarItemBodyTypeId, gameContent.AvatarItem.AvatarBodyTypeId.ToString(), "AvatarItemBodyTypeId does not match the expected value");
                    }

                }

                Trace.WriteLine("Checking TitleVault (Offer)...");

                string titleVaultPath = String.Format("{0}\\{1}", Config.TitleVaultPath, (null == altTitleId) ? titleId.Substring(2) : altTitleId.Substring(2));

                int count = offerFile.SelectNodes("/x:LiveOffer/x:contentOffer", namespaceManager).Count;

                string titleVaultOffer = String.Format("{0}\\{1}_[{2}]{3}", titleVaultPath, Path.GetFileNameWithoutExtension(filename), count, Path.GetExtension(filename));
                Trace.WriteLine(String.Format("Checking {0}", titleVaultOffer));
                Assert.IsTrue(File.Exists(titleVaultOffer), "File does not exist and it should");

                foreach (string imageFile in listImages)
                {
                    string titleVaultImage = String.Format("{0}\\{1}", titleVaultPath, imageFile);
                    Trace.WriteLine(String.Format("Checking {0}", titleVaultImage));
                    Assert.IsTrue(File.Exists(titleVaultImage), "File does not exist and it should");
                }
            }
            else
            {
                Assert.IsNull(offer, "GetOffer returned an offer object.  The offer is not expected to be in the EMS catalog but appears to be there.");
            }
        }

        private void VerifyLicenseType(string mediaType, Offer offer, XmlDocument offerFile, XmlNamespaceManager namespaceManager, string xPath)
        {
            if (mediaType == MediaTypeAvatarItem)
            {
                Assert.AreEqual(LicenseTypeRestrictedToUser, offer.Instances[0].ProviderTerms[0].MediaInstances[0].LicenseTypeId);
            }
            else
            {
                string licenseType = GetLicenseTypeString(offer.Instances[0].ProviderTerms[0].MediaInstances[0].LicenseTypeId);

                CompareXmlToPropertyValue(offerFile, namespaceManager, xPath + "/x:offerContentInfo/x:licenseLevel", licenseType);
            }
        }

        private void CheckProviderId(ProviderTerm[] providerTerms, string userType, int providerId, string countryCode, string liveTier)
        {
                foreach (ProviderTerm pt in providerTerms)
                {
                    Assert.AreEqual(pt.ProviderId, providerId, "ProviderID from web service does not match test data value.");
                    Assert.AreEqual(pt.CountryCode, countryCode, "Country Code from web service does not match test data value.");
                    Assert.AreEqual(userType, liveTier, "User Type from web service does not match test data value.");
                    Trace.WriteLine(string.Format("ProviderTerm.ProviderID values '{0}:{1}:{2}' match expected xml values '{3}:{4}:{5}'.", pt.CountryCode, userType, pt.ProviderId, countryCode, liveTier, providerId));
                }
        }

        private bool IsPaymentTypeExpected(XmlNode node, XmlNamespaceManager namespaceManager, int actualPaymentType)
        {
            XmlNode xboxToken = node.SelectSingleNode("x:paymentTypeXboxToken", namespaceManager);
            XmlNode scgToken = node.SelectSingleNode("x:paymentTypeSCGToken", namespaceManager);
            XmlNode pointsNode = node.SelectSingleNode("x:paymentTypePoints", namespaceManager);
            XmlNode creditCardNode = node.SelectSingleNode("x:paymentTypeCreditCard", namespaceManager);

            if (actualPaymentType == 3)
            {
                if(null != creditCardNode && creditCardNode.HasChildNodes)
                {
                    return true;
                }
            }
            if (actualPaymentType == 2)
            {
                // LSG bug 6314
                // LiveOffer will add an OfferInstance for token payment time always
                return true;
            }

            if (actualPaymentType == 1)
            {
                if (null != pointsNode && pointsNode.HasChildNodes)
                {
                    return true;
                }
            }

            return false;
        }

        private string GetLicenseTypeString(int catalogLicenseType)
        {
            switch (catalogLicenseType)
            {
                case 11: return "RestrictedToMachine";
                case 14: return "RestrictedToUserAndMachine";
                case 13: return "Unrestricted";
            }

            Assert.Fail(String.Format("The license type ID on the catalog object is {0} but only 11, 13 and 14 are valid values.", catalogLicenseType));

            return "Unknown";
        }

        private bool CheckOfferInstancesVisibility(Offer offer, int visibilityStatusId)
        {
            foreach (OfferInstance instance in offer.Instances)
            {
                if (instance.VisibilityStatusId != visibilityStatusId)
                    return false;
            }

            return true;
        }

        #endregion

        #region LiveTitle
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveTitles.xml", "TitleBVT", DataAccessMethod.Sequential), TestMethod]
        public void LiveTitleBVTs()
        {
            RunLiveTitleTests();
        }

        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveTitles.xml", "Title", DataAccessMethod.Sequential), TestMethod]
        public void LiveTitleFunctionalTests()
        {
            RunLiveTitleTests();
        }

        public void RunLiveTitleTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string filenameText = TryGetColumnValue("Filename");
            string xscFilenameText = TryGetColumnValue("XSCFilename");
            string actionList = (string)TestContext.DataRow["Actions"];
            string titleId = TryGetColumnValue("TitleId");
            string consoleTypeIdString = TryGetColumnValue("ConsoleTypeId");
            string exceptionText = TryGetColumnValue("ExceptionText");
            string[] exceptions = (null == exceptionText) ? null : exceptionText.Split(';');
            string mediaTypeId = TryGetColumnValue("MediaTypeId");
            string commandLineArgs = TryGetColumnValue("CommandLineArgs");
            string includeDefaultCommandLineArgsString = TryGetColumnValue("IncludeDefaultCommandLineArgs");
            string isMarketplaceFileString = TryGetColumnValue("IsMarketplaceFile");
            string TestName = TryGetColumnValue("Name");
            string Description = TryGetColumnValue("Description");
            string versionString = TryGetColumnValue("Version"); //for Action: /addbasever & /delbasever only
            string platformString = TryGetColumnValue("Platform"); //for Action: /addbasever & /delbasever only

            //having to implement xbox1 code into this is a mess.  I'm just adding a different path all-together
            //for legacy xbox1 tests.
            if (null != xscFilenameText)
            {
                foreach (string action in actionList.Split(';'))
                {
                    RunLiveTitleXbox1(filenameText, xscFilenameText, titleId, action);
                }
                return;
            }

            int consoleTypeId = 2;

            if (null != consoleTypeIdString)
            {
                consoleTypeId = Convert.ToInt16(consoleTypeIdString);
            }

            if (extractTestData)
                TestDataMigration.StartTestCapture(TestDataMigration.TestType.LIVE_TITLE, "LiveTitle", TestName, Description, titleId, consoleTypeIdString, null);

            bool shouldBeVisible = Convert.ToBoolean(TestContext.DataRow["Visible"]);

            bool includeDefaultCommandLineArgs = true;

            if (null != includeDefaultCommandLineArgsString)
            {
                includeDefaultCommandLineArgs = Convert.ToBoolean(includeDefaultCommandLineArgsString);
            }

            bool isMarketplaceFile = false;

            if (null != isMarketplaceFileString)
            {
                isMarketplaceFile = Convert.ToBoolean(isMarketplaceFileString);
            }

            CleanGame(titleId, consoleTypeId);

            string liveTitleOutput = null;

            foreach (string filename in filenameText.Split(';'))
            {
                foreach (string action in actionList.Split(';'))
                {
                    liveTitleOutput = RunLiveTitle(filename, titleId, action, includeDefaultCommandLineArgs, commandLineArgs, false, platformString, versionString);

                    if (!String.IsNullOrEmpty(exceptionText))
                    {
                        foreach (string exception in exceptions)
                        {
                            if (true == liveTitleOutput.Contains(exception))
                            {
                                return;
                            }
                        }
                    }
                }
            }

            if (!String.IsNullOrEmpty(exceptionText))
            {
                Assert.Fail("Expected exception did not occur");
            }
            else if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Assert.Fail("An error occurred in the tool");
            }

            string[] filenames = filenameText.Split(';');
            if (!extractTestData)
                VerifyTitle(titleId, consoleTypeId, mediaTypeId, filenames[filenames.Length - 1], null, 0, shouldBeVisible, isMarketplaceFile);
        }

        private void CleanGame(string titleId, int consoleTypeId)
        {
            Guid gameId = BuildGameId(titleId, consoleTypeId);
            Trace.WriteLine(String.Format("Calling GetGame on the Catalog Web Service to find game '{0}'...", gameId));

            Game game = webService.GetGame(gameId);
            if (null != game)
            {
                Trace.WriteLine("Game found.  Calling SaveGame on the Catalog Web Service to delete the game.");
                webService.SaveGame(game);
            }
            else
            {
                Trace.WriteLine("Game not found.");
            }
        }

        private string RunLiveTitle(string filename, string titleId, string action, bool includeDefaultCommandLineArgs, string commandLineArgs, bool runAsMarketplaceFile, string platform, string version)
        {
            string commandLine = String.Format("{0}\\livetitle.exe", Config.LiveToolsPath);
            StringBuilder arguments = new StringBuilder();
            
            if (includeDefaultCommandLineArgs)
            {
                if (null != action)
                {
                    arguments.AppendFormat("/{0} ", action);
                }

                if (null != titleId && action.EndsWith("ver", StringComparison.InvariantCultureIgnoreCase))
                {
                    arguments.AppendFormat("/titleid:{0} ", titleId);
                }
                else if (null != filename)
                {
                    if (runAsMarketplaceFile)
                    {
                        arguments.AppendFormat("/marketplacepath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, filename);
                    }
                    else
                    {
                        arguments.AppendFormat("/xlastpath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, filename);
                    }
                }

                if (null != commandLineArgs)
                {
                    arguments.AppendFormat(commandLineArgs, testContextInstance.TestDeploymentDir);
                }

                if (action.Equals("livetitledefault", StringComparison.InvariantCultureIgnoreCase))
                {
                    string ltcFile = String.Format("{0}\\{1}_ltc.xml", Config.LiveToolsPath, titleId.Substring(2));
                    if (true == File.Exists(ltcFile))
                    {
                        File.Delete(ltcFile);
                    }

                    DeleteLtc(titleId);

                    arguments.AppendFormat("/lbs:{0} /matchsvr:{1} /titleId:{2} ", Config.DatabaseServer, Config.DatabaseServer, titleId);
                }
                else if (action.Equals("deploy", StringComparison.InvariantCultureIgnoreCase) && !runAsMarketplaceFile)
                {
                    arguments.AppendFormat("/ltcpath:\"{0}\\{1}_ltc.xml ", Config.LiveToolsPath, titleId.Substring(2));
                }
                else if (action.Equals("addbasever", StringComparison.InvariantCultureIgnoreCase) || action.Equals("delbasever", StringComparison.InvariantCultureIgnoreCase))
                {
                    arguments.AppendFormat("/version:{0} /platform:{1} ", version, platform);
                }
            }
            else if (null != commandLineArgs)
            {
                arguments.AppendFormat(commandLineArgs, testContextInstance.TestDeploymentDir);
            }
            
            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            if (extractTestData)
                TestDataMigration.MigrateTest(commandLine, arguments.ToString());

            return RunLiveTool(commandLine, arguments.ToString());
        }

        private string RunLiveTitleXbox1(string filename, string xscFilename, string titleId, string action)
        {
            string commandLine = String.Format("{0}\\livetitle.exe", Config.LiveToolsPath);
            StringBuilder arguments = new StringBuilder();

            if (null != action)
            {
                arguments.AppendFormat("/{0} ", action);
            }

            if (action.Equals("xboxdefault", StringComparison.InvariantCultureIgnoreCase) && null != xscFilename)
            {
                arguments.AppendFormat("/xboxpath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, filename);
                arguments.AppendFormat("/xscpath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, xscFilename);
                arguments.AppendFormat("/lbs:{0} /matchsvr:{1} ", Config.DatabaseServer, Config.DatabaseServer);
            }
            else if (action.Equals("deployxbox", StringComparison.InvariantCultureIgnoreCase))
            {
                arguments.AppendFormat("/xboxpath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, filename);
                arguments.AppendFormat("/xscpath:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, xscFilename);
                arguments.AppendFormat("/ltcpath:\"{0}\\{1}_ltc.xml ", Config.LiveToolsPath, titleId.Substring(2));
            }

            Trace.WriteLine(String.Format("Running LiveTitle.  Command line is: '{0} {1}'", commandLine, arguments));

            return RunLiveTool(commandLine, arguments.ToString());
        }

        private void VerifyTitle(string titleId, int consoleTypeId, string mediaType, string xlastFilename, string offerFilename, int offerIndex, bool shouldBeVisible, bool isMarketplaceFile)
        {
            Trace.WriteLine(String.Format("Verifying that game is {0}visible...", shouldBeVisible ? String.Empty : "not "));

            int liveTitleId = Int32.Parse(titleId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            int mediaTypeId = null != mediaType ? Int32.Parse(mediaType) : 0;

            Guid gameId = BuildGameId(titleId, consoleTypeId);

            Trace.WriteLine(String.Format("Calling the catalog web service to get game {0}", gameId));
            Game game = webService.GetGame(gameId);

            if (true == shouldBeVisible)
            {
                Assert.IsNotNull(game, "GetGame returned NULL.  The game is expected to be in the EMS catalog but doees not appear to be there.");

                XmlNamespaceManager xNamespaceManager = null;

                if (false == isMarketplaceFile)
                {
                    XmlDocument ltcFile = new XmlDocument();
                    ltcFile.Load(String.Format("{0}\\{1}_ltc.xml", Config.LiveToolsPath, titleId.Substring(2)));
                    xNamespaceManager = new XmlNamespaceManager(ltcFile.NameTable);
                    xNamespaceManager.AddNamespace("x", ltcFile.DocumentElement.NamespaceURI);

                    CompareXmlToPropertyValue(ltcFile, xNamespaceManager, "/x:LiveTitleConfig/x:TitleGeneration", "Xenon");
                    CompareXmlToPropertyValue(ltcFile, xNamespaceManager, "/x:LiveTitleConfig/x:TitleID", liveTitleId);

                    // 4-30-08 pbarnett: Disabling this check for Fusion because the verification will fail
                    if (!titleId.Equals("0xFFFE07D2", StringComparison.InvariantCultureIgnoreCase))
                    {
                        CompareXmlToPropertyValue(ltcFile, xNamespaceManager, "/x:LiveTitleConfig/x:MatchServerList", Config.DatabaseServer.ToLower());
                    }
                }

                XmlDocument xlastFile = new XmlDocument();
                xlastFile.Load(String.Format("{0}\\{1}", testContextInstance.TestDeploymentDir, xlastFilename));
                xNamespaceManager = new XmlNamespaceManager(xlastFile.NameTable);
                xNamespaceManager.AddNamespace("x", xlastFile.DocumentElement.NamespaceURI);

                XmlDocument offerFile = null;
                XmlNamespaceManager oNamespaceManager = null;
                if (null != offerFilename)
                {
                    offerFile = new XmlDocument();
                    offerFile.Load(String.Format("{0}\\{1}", testContextInstance.TestDeploymentDir, offerFilename));
                    oNamespaceManager = new XmlNamespaceManager(offerFile.NameTable);
                    oNamespaceManager.AddNamespace("o", offerFile.DocumentElement.NamespaceURI);
                }

                if (true == isMarketplaceFile)
                {
                    CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:ProductInformation/x:Rating", game.RatingValues.Length, true /*Can be larger to allow for KMRB and GRM double propping*/);

                    // 4-30-08 pbarnett: Disabling this check for Fusion and XNA because the verification will fail
                    if (!titleId.Equals("0xFFFE07D2", StringComparison.InvariantCultureIgnoreCase))
                    {
                        CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:SupportedLocale", game.GameLocales.Length, true);
                        // The genre node count won't always be the same as the Categories length since some genres are mapped to the same single category
                        //CompareXmlNodeCountToArrayLength(xlastFile, namespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:ProductInformation/x:Genre", game.Categories.Length);

                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:SupportedLocale", game.GameLocales, "@locale", "Lcid", "GetLocale", "LCID", "LocaleCode");

                        if (null != offerFile)
                        {
                            CompareXmlNodesToArray(offerFile, oNamespaceManager, String.Format("/o:LiveOffer/o:contentOffer[{0}]/o:offerBasicInfo/o:offerCultureDetails", offerIndex), game.Locales, "./o:name", "Title", null, null, null);
                        }
                        else
                        {
                            CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:LocalizedString[@friendlyName='X_STRINGID_TITLENAME']/x:Translation", game.Locales, ".", "Title", null, null, null);
                        }

                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:LocalizedString[@friendlyName='X_STRINGID_TITLENAME']/x:Translation", game.Locales, ".", "ReducedTitle", null, null, null);

                        if (null != offerFile)
                        {
                            CompareXmlNodesToArray(offerFile, oNamespaceManager, String.Format("/o:LiveOffer/o:contentOffer[{0}]/o:offerBasicInfo/o:offerCultureDetails", offerIndex), game.Locales, "./o:sellText", "Description", null, null, null);
                        }
                        else
                        {
                            string sellId = xlastFile.SelectSingleNode("/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:ProductInformation", xNamespaceManager).Attributes["sellTextStringId"].Value;
                            CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:LocalizedString[@id='" + sellId + "']/x:Translation", game.Locales, ".", "Description", null, null, null);
                        }

                        if ((null != offerFile) && (21 == mediaTypeId))
                        {
                            CompareXmlNodesToArray(offerFile, oNamespaceManager, String.Format("/o:LiveOffer/o:contentOffer[{0}]/o:offerBasicInfo/o:offerCultureDetails", offerIndex), game.Locales, "./o:sellText", "ReducedDescription", null, null, null);
                        }
                        else
                        {
                            string sellId = xlastFile.SelectSingleNode("/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:ProductInformation", xNamespaceManager).Attributes["sellTextStringId"].Value;
                            CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:LocalizedStrings/x:LocalizedString[@id='" + sellId + "']/x:Translation", game.Locales, ".", "ReducedDescription", null, null, null);
                        }
                    }

                    CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:MarketplaceConfigProject/x:Images/x:Image", game.Relationships.Length, true);
                }
                else
                {
                    CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation/x:Rating", game.RatingValues.Length, true /*Can be larger to allow for KMRB and GRM double propping*/);

                    // 4-30-08 pbarnett: Disabling this check for Fusion and XNA because the verification will fail
                    if (!titleId.Equals("0xFFFE07D2", StringComparison.InvariantCultureIgnoreCase))
                    {
                        CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:SupportedLocale", game.GameLocales.Length, true);
                        // The genre node count won't always be the same as the Categories length since some genres are mapped to the same single category
                        //CompareXmlNodeCountToArrayLength(xlastFile, namespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation/x:Genre", game.Categories.Length);
                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:SupportedLocale", game.GameLocales, "@locale", "Lcid", "GetLocale", "LCID", "LocaleCode");

                        // Validate Title and Description
                        if ((null != offerFile)
                            && ((MediaTypeGame == mediaType) || (MediaTypeArcade == mediaType) || (MediaTypeXboxOriginals == mediaType) || (MediaTypeXNA == mediaType)))
                        {
                            // validate Title is coming from the offer file
                            CompareXmlNodesToArray(offerFile, oNamespaceManager, String.Format("/o:LiveOffer/o:contentOffer[{0}]/o:offerBasicInfo/o:offerCultureDetails", offerIndex), game.Locales, "./o:name", "Title", null, null, null);
                            // validate Description is coming from the offer file
                            CompareXmlNodesToArray(offerFile, oNamespaceManager, String.Format("/o:LiveOffer/o:contentOffer[{0}]/o:offerBasicInfo/o:offerCultureDetails", offerIndex), game.Locales, "./o:sellText", "Description", null, null, null);
                        }
                        else
                        {
                            // validate Title is coming from the xlast file
                            CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:LocalizedString[@friendlyName='X_STRINGID_TITLENAME']/x:Translation", game.Locales, ".", "Title", null, null, null);
                            // validate Description is coming from the xlast file
                            CompareXmlNodesToArray(xlastFile, xNamespaceManager, 
                                "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:LocalizedString[@id='" 
                                + xlastFile.SelectSingleNode("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation", xNamespaceManager).Attributes["sellTextStringId"].Value 
                                + "']/x:Translation",
                                game.Locales, ".", "Description", null, null, null);
                        }

                        // Validate Publisher for Title
                        string pubId = xlastFile.SelectSingleNode("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation", xNamespaceManager).Attributes["publisherStringId"].Value;
                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:LocalizedString[@id='" + pubId + "']/x:Translation", game.GameLocales, ".", "Publisher", null, null, null);

                        // Validate Reduced Title (always comes from the .xlast)
                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:LocalizedString[@friendlyName='X_STRINGID_TITLENAME']/x:Translation", game.Locales, ".", "ReducedTitle", null, null, null);

                        // Validate Reduced Description (always comes from the .xlast)
                        CompareXmlNodesToArray(xlastFile, xNamespaceManager, 
                            "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:LocalizedStrings/x:LocalizedString[@id='" 
                            + xlastFile.SelectSingleNode("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation", xNamespaceManager).Attributes["sellTextStringId"].Value
                            + "']/x:Translation",
                            game.Locales, ".", "ReducedDescription", null, null, null);
                    }

                    //Rating verifications for Game
                    Trace.WriteLine("Checking Rating Counts for Game...");
                    CompareXmlNodeCountToArrayLength(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation/x:Rating",
                                                     game.RatingValues.Length, true /*Can be larger to allow for KMRB and GRM double propping*/);

                    Trace.WriteLine("Checking Rating Values for Game...");
                    CompareXmlNodesToArray(xlastFile, xNamespaceManager, "/x:XboxLiveSubmissionProject/x:GameConfigProject/x:ProductInformation/x:Rating",
                                           game.RatingValues, "", "RatingValueId", null, null, null);


                    Trace.WriteLine("Checking Avatar Items for Game...");
                    CompareXmlToAvatarItems(xlastFile, xNamespaceManager, titleId);

                    List<ImageInstance> images = new List<ImageInstance>();
                    List<string> listImagesGame = new List<string>();

                    Trace.WriteLine("Checking image filenames...");
                    foreach (MediaRelationship relationship in game.Relationships)
                    {
                        Image image = webService.GetImage(relationship.RelatedMediaId);

                        if (null != image && image.Instances.Length > 0 && image.Instances[0] is ImageInstance)
                        {
                            Assert.AreEqual(1, image.Instances.Length, "Image has an instance count greater than 1");

                            ImageInstance instance = (ImageInstance)image.Instances[0];
                            images.Add(instance);
                            listImagesGame.Add(instance.FileUrl);

                            Trace.WriteLine("Checking VisibilityDate (Image)...");
                            Assert.AreEqual(VisibilityDate.ToShortDateString(), image.VisibilityDate.Value.ToShortDateString(), "Image visibility date does not match the expected visibility date");
                        }
                    }

                    Assert.IsTrue((2 <= listImagesGame.Count) && (3 >= listImagesGame.Count), "Game has an image count less than 2 or more than 3");
                }


                if (titleId.StartsWith("0x5855", StringComparison.InvariantCultureIgnoreCase))
                {
                    Trace.WriteLine("Checking contributor for XNA title...");

                    Assert.AreEqual(1, game.Contributors.Length, "The Contributors collection for this XNA title does not contain the expected number of contributors");

                    Contributor contributor = webService.GetContributor(game.Contributors[0].ContributorId);

                    foreach (ContributorLocale contributorLocale in contributor.Locales)
                    {
                        if (contributorLocale.Lcid == 1033)
                        {
                            Assert.AreEqual("** Developer Name **", contributorLocale.DisplayName, "The Contributors collection for this XNA title does not have the expected contributor name");
                            break;
                        }
                    }
                }

                Trace.WriteLine("Checking LiveTitleId...");
                Assert.AreEqual(liveTitleId, game.LiveTitleId, "Game.LiveTitleId does not match expected value");

                Trace.WriteLine("Checking VisibilityStatusId...");
                Assert.AreEqual(3, game.VisibilityStatusId, "Game.VisibilityStatusId does not match expected value");

                // only check mediaTypeId if we read a value from the test xml file
                if (mediaTypeId > 0)
                {
                    Trace.WriteLine("Checking MediaTypeId...");
                    Assert.AreEqual(mediaTypeId, game.MediaTypeId, "Game.MediaTypeId does not match expected value");
                }

                Trace.WriteLine("Checking VisibilityDate (Game)...");
                Assert.AreEqual(VisibilityDate.ToShortDateString(), game.VisibilityDate.Value.ToShortDateString(), "Game.VisibilityDate does not match expected value");

                Trace.WriteLine("Checking TitleVault (Title)...");

                string titleVaultPath = String.Format("{0}\\{1}", Config.TitleVaultPath, titleId.Substring(2));

                string titleVaultFile = String.Format("{0}\\{1}{2}", titleVaultPath, titleId.Substring(2), Path.GetExtension(xlastFilename));
                Trace.WriteLine(String.Format("Checking {0}", titleVaultFile));
                Assert.IsTrue(File.Exists(titleVaultFile), "File does not exist and it should");

                if (false == isMarketplaceFile)
                {
                    string titleVaultLtc = String.Format("{0}\\{1}_ltc.xml", titleVaultPath, titleId.Substring(2));
                    Trace.WriteLine(String.Format("Checking {0}", titleVaultLtc));
                    Assert.IsTrue(File.Exists(titleVaultLtc), "File does not exist and it should");
                }

                List<string> listImagesTitleVault = new List<string>();
                XmlNodeList xmlNodeListImages = xlastFile.SelectNodes("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:Images/x:Image[@friendlyName='X_IMAGEID_GAME' or @friendlyName='X_IMAGEID_GAME_MARKETPLACE']", xNamespaceManager);
                foreach (XmlNode xmlNode in xmlNodeListImages)
                {
                    listImagesTitleVault.Add(xmlNode.SelectSingleNode("x:Path", xNamespaceManager).InnerText);
                }

                foreach (string imageFile in listImagesTitleVault)
                {
                    string titleVaultImage = String.Format("{0}\\{1}", titleVaultPath, Path.GetFileName(imageFile));
                    Trace.WriteLine(String.Format("Checking {0}", titleVaultImage));
                    Assert.IsTrue(File.Exists(titleVaultImage), "File does not exist and it should");
                }
            }
            else
            {
                Assert.IsNull(game, "GetGame returned an offer object.  The game is not expected to be in the EMS catalog but appears to be there.");
            }
        }

        private Guid BuildGameId(string titleId, int consoleTypeId)
        {
            return new Guid("66acd000-77fe-1000-9115-D8" + consoleTypeId.ToString("D2") + titleId.Substring(2));
        }

        private Guid BuildGameContentId(string titleId, int consoleTypeId, ulong offerId, string mediaType)
        {
            if ((MediaTypeArcade == mediaType) || (MediaTypeGame == mediaType) || (MediaTypeXboxOriginals == mediaType) || (MediaTypeXNA == mediaType))
            {
                return BuildGameId(titleId, consoleTypeId);
            }

            ulong low = offerId & 0x00000000FFFFFFFF;
            ulong high = offerId >> 32;

            return new Guid("00000000-0000-40" + (low >> 24).ToString("X2") + "-80" + ((low & 0x00FF0000) >> 16).ToString("X2") + "-" + (low & 0x0000FFFF).ToString("X4") + high.ToString("X8"));
        }

        #endregion

        #region LiveContent
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveContent.xml", "ContentBVT", DataAccessMethod.Sequential), TestMethod]
        public void LiveContentBVTs()
        {
            RunLiveContentTests();
        }

        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveContent.xml", "Content", DataAccessMethod.Sequential), TestMethod]
        public void LiveContentFunctionalTests()
        {
            RunLiveContentTests();
        }

        public void RunLiveContentTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string offerFile1 = TryGetColumnValue("OfferFile1");
            string offerFile2 = TryGetColumnValue("OfferFile2");
            string action = (string)TestContext.DataRow["Actions"];
            string titleId = TryGetColumnValue("TitleId");
            string consoleTypeIdString = TryGetColumnValue("ConsoleTypeId");
            string originalOfferId1 = TryGetColumnValue("OfferId1");
            string originalOfferId2 = TryGetColumnValue("OfferId2");
            string packageFile = TryGetColumnValue("PackageFile");
            string commandLineArgs = TryGetColumnValue("CommandLineArgs");
            string expectedXcpSizeString = TryGetColumnValue("ExpectedXcpSize");
            string expectedCategoryIdString = TryGetColumnValue("ExpectedCategoryId");
            string expectedOptionalPNGCountString = TryGetColumnValue("expectedOptionalPNGCount");
            string exceptionText = TryGetColumnValue("ExceptionText");
            string[] exceptions = (null == exceptionText) ? null : exceptionText.Split(';');
            string includeDefaultArgsString = TryGetColumnValue("IncludeDefaultCommandLineArgs");
            string expectedRegion = TryGetColumnValue("ExpectedGameRegion");
            string TestName = TryGetColumnValue("Name");
            string Description = TryGetColumnValue("Description");
            string shouldExistInTitleVaultString = TryGetColumnValue("ShouldExistInTitleVault");
            bool includeDefaultArgs = true;
            bool shouldExistInTitleVault = true;

            if (null != shouldExistInTitleVaultString && shouldExistInTitleVaultString.Equals("false"))
            {
                shouldExistInTitleVault = false;
            }

            int consoleTypeId = 2;

            if (null != consoleTypeIdString)
            {
                consoleTypeId = Convert.ToInt16(consoleTypeIdString);
            }
            if (extractTestData)
            {
                string offerIds = "";
                if (originalOfferId1 != null)
                    offerIds += originalOfferId1;
                if (originalOfferId2 != null)
                    offerIds += ";" + originalOfferId2;

                TestDataMigration.StartTestCapture(TestDataMigration.TestType.LIVE_CONTENT, "LiveContent", TestName, Description, titleId, consoleTypeIdString, offerIds);
            }
            if (null != includeDefaultArgsString)
            {
                includeDefaultArgs = Convert.ToBoolean(includeDefaultArgsString);
            }

            if (null != commandLineArgs)
            {
                commandLineArgs = String.Format(commandLineArgs, testContextInstance.TestDeploymentDir);
            }

            string offerId1 = null;
            string offerId2 = null;

            if (null != originalOfferId1)
            {
                offerId1 = String.Format("{0}-0000-4000-8000-0000{1}", originalOfferId1.Substring(10, 8), originalOfferId1.Substring(2, 8));
            }

            if (null != originalOfferId2)
            {
                offerId2 = String.Format("{0}-0000-4000-8000-0000{1}", originalOfferId2.Substring(10, 8), originalOfferId2.Substring(2, 8));
            }

            bool shouldBeVisible = Convert.ToBoolean(TestContext.DataRow["Visible"]);

            CleanLiveContentOutput();

            string liveContentOutput = RunLiveContent(packageFile, offerFile1, originalOfferId1, offerFile2, originalOfferId2, titleId, action, commandLineArgs, includeDefaultArgs);

            if (!String.IsNullOrEmpty(exceptionText))
            {
                bool expectedException = false;

                foreach (string exception in exceptions)
                {
                    if (true == liveContentOutput.Contains(exception))
                    {
                        expectedException = true;
                        return;
                    }
                }

                Assert.IsTrue(expectedException, "Expected exception did not occur");
            }
            else if ((true == liveContentOutput.Contains("ERROR:")) || (true == liveContentOutput.Contains("EXCEPTION")) || (true == liveContentOutput.Contains("FAILED:")))
            {
                Assert.Fail("An error occurred in the tool");
            }
            else if (("xbox1content" != action) && (false == liveContentOutput.Contains("Package(s) built and deployed succesfully")))
            {
                Assert.Fail("An error occurred in the tool");
            }

            //For use as a parameter for VerifyLiveContentOutput
            int expectedXcpSize = (null != expectedXcpSizeString) ? int.Parse(expectedXcpSizeString) : 0;

            //This parameter is required for Avatar Item content package
            int expectedOptionalPNGCount = (!String.IsNullOrEmpty(expectedOptionalPNGCountString) ? int.Parse(expectedOptionalPNGCountString) : 0);
          
            if (!extractTestData)
            {
                //VerifyLiveContentOutput(offerFile1, originalOfferId1, titleId, null, shouldBeVisible); 
                VerifyLiveContentOutput(offerFile1, originalOfferId1, titleId, packageFile, shouldBeVisible, consoleTypeId, commandLineArgs, expectedXcpSize, expectedCategoryIdString, expectedOptionalPNGCount, expectedRegion, shouldExistInTitleVault);


                if (null != offerFile2)
                {
                    //  VerifyLiveContentOutput(offerFile2, originalOfferId2, titleId,  null, shouldBeVisible);
                    VerifyLiveContentOutput(offerFile2, originalOfferId2, titleId, packageFile, shouldBeVisible, consoleTypeId, commandLineArgs, expectedXcpSize, expectedCategoryIdString, expectedOptionalPNGCount, expectedRegion, shouldExistInTitleVault);

                }
            }
        }

        private void CleanLiveContentOutput()
        {
            if (Directory.Exists(liveContentLocalPath))
            {
                Trace.WriteLine(String.Format("Cleaning up LiveContent output folder {0}...", liveContentLocalPath));

                try
                {
                    Directory.Delete(liveContentLocalPath, true);
                }
                catch (Exception e)
                {
                    Trace.WriteLine(String.Format("Warning: Cleaning up LiveContent local path failed with an exception: {0}", e.Message));
                }
            }

            //string[] titleDirs = Directory.GetDirectories(liveContentOutputPath);
            //foreach (string titleDir in titleDirs)
            //{
            //    try
            //    {
            //        Directory.Delete(titleDir, true);
            //    }
            //    catch (Exception e)
            //    {
            //        Trace.WriteLine(String.Format("Warning: Cleaning up LiveContent output path failed with an exception: {0}", e.Message));
            //    }
            //}
        }

        private string RunLiveContent(string packageFile, string offerFile1, string offerId1, string offerFile2, string offerId2, string titleId, string action, string commandLineArgs, bool includeDefaultCommandLineArgs)
        {
            string commandLine = String.Format("{0}\\livecontent.exe", Config.LiveToolsPath);
            StringBuilder arguments = new StringBuilder();

            if (includeDefaultCommandLineArgs)
            {
                if (null != action)
                {
                    arguments.AppendFormat("/action:{0} ", action);

                    if (null != packageFile)
                    {
                        arguments.AppendFormat("/package:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, packageFile);
                    }

                    if (null != titleId)
                    {
                        arguments.AppendFormat("/titleid:{0} ", titleId);
                    }

                    if (null != offerFile1 && null != offerId1)
                    {
                        arguments.AppendFormat("/offerfile:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, offerFile1);
                    }

                    if (null != offerId1)
                    {
                        arguments.AppendFormat("/offerid:{0} ", offerId1);
                    }

                    if (null != offerFile2 && null != offerId2)
                    {
                        arguments.AppendFormat("/offerfile2:\"{0}\\{1}\" ", testContextInstance.TestDeploymentDir, offerFile2, offerId2);
                    }

                    if (null != offerId2)
                    {
                        arguments.AppendFormat("/offerid2:{0} ", offerId2);
                    }

                    if ((action == "xbox1content") || (action == "xbox1update"))
                    {
                        arguments.Append("/site:1 ");
                    }

                    arguments.AppendFormat("/overwrite /noreload /timeout:2000 /tempdir:\"{0}\\Temp\" /shares:{1} /xrls:{2}:3074/content/LiveToolsTests/ ", testContextInstance.TestDeploymentDir, liveContentOutputPath, Config.DownloadMachine);
                }
            }

            arguments.AppendFormat("{0}", commandLineArgs);

            Trace.WriteLine(String.Format("Running LiveContent.  Command line is: '{0} {1}'", commandLine, arguments));

            if (extractTestData)
                TestDataMigration.MigrateTest(commandLine, arguments.ToString());

            return RunLiveTool(commandLine, arguments.ToString());
        }


        private void VerifyLiveContentOutput(string offerFilename, string offerId, string titleId, string packageFilename, bool shouldExist, int consoleTypeId, string commandLineArgs, int expectedXcpSize, string expectedCategoryId, int expectedOptionalPNGCount, string expectedRegion, bool shouldExistInTitleVault)
        {
            List<string> listContentIds = new List<string>();
            XmlDocument offerFile = new XmlDocument();
            XmlNamespaceManager namespaceManager = null;

            offerFilename = String.Format(".\\{0}", offerFilename);

            if (File.Exists(offerFilename) && !offerFilename.EndsWith("empty.offer", StringComparison.InvariantCultureIgnoreCase))
            {
                offerFile.Load(offerFilename);
                namespaceManager = new XmlNamespaceManager(offerFile.NameTable);
                namespaceManager.AddNamespace("x", offerFile.DocumentElement.NamespaceURI);

                if (offerFile.DocumentElement.NamespaceURI.EndsWith("xboxoffer"))
                {
                    Trace.WriteLine("Checking TitleVault (Content)...");

                    string titleVaultFile = String.Format("{0}\\{1}\\{2}.xcp", Config.TitleVaultPath, titleId.Substring(2), offerId.Substring(2));
                    Trace.WriteLine(String.Format("Checking {0}", titleVaultFile));
                    Assert.IsTrue(File.Exists(titleVaultFile), "File does not exist and it should");

                    return;
                }
                else
                {
                    XmlNodeList xmlNodeList = offerFile.SelectNodes("/x:LiveOffer/x:content/x:contentID", namespaceManager);
                    foreach (XmlNode xmlNode in xmlNodeList)
                    {
                        if ("0X" != xmlNode.InnerText.Substring(0, 2).ToUpper())
                        {
                            listContentIds.Add(xmlNode.InnerText);
                        }
                        else
                        {
                            listContentIds.Add(xmlNode.InnerText.Substring(2));
                        }
                    }
                } 
                
                XmlNode gameRegion = offerFile.SelectSingleNode("/x:LiveOffer/x:content/x:gameRegion", namespaceManager);
                if (gameRegion != null && expectedRegion != null)
                {
                    Trace.WriteLine(String.Format("Checking gameRegion {0}", gameRegion.InnerText));
                    Assert.AreEqual(expectedRegion, gameRegion.InnerText, "gameRegion value does not match expected.");
                }

                XmlNode offerTypeNode = offerFile.SelectSingleNode("/x:LiveOffer/x:contentOffer/x:contentOfferType", namespaceManager);
                Assert.IsNotNull(offerTypeNode, "documentContentXPath did not return a node for contentOfferType. This is expected for every offer file.");
                String contentOfferType = offerTypeNode.InnerText.Trim();
                const String AvatarItemTypeStr = "AvatarItem";

                //verifies that expected CategoryId occurs in offer file output
                if (expectedCategoryId != null)
                {   
                    XmlNodeList xmlNodeList = offerFile.SelectNodes("/x:LiveOffer/x:contentOffer/x:category", namespaceManager);
                    List<string> actualCategoryList = new List<string>();
                    List<string> expectedCategoryList = new List<string>(); 

                    foreach (string category in expectedCategoryId.Split(','))
                    {
                        expectedCategoryList.Add(category);                        
                    }

                    Trace.WriteLine("Checking categoryId...");

                    //checks that each categoryId from the Offer file is from the expected list
                    foreach (XmlNode xmlNode in xmlNodeList)
                    {
                        string categoryIdStr = xmlNode.Attributes.GetNamedItem("categoryId").Value;
                        if (expectedCategoryList.Contains(categoryIdStr))
                        {
                            Trace.WriteLine("Expected CategoryId " + categoryIdStr + " found");

                            string externalTypeStr = xmlNode.Attributes.GetNamedItem("externalType").Value;

                            if (contentOfferType.Equals(AvatarItemTypeStr))
                            {
                                Trace.WriteLine("Checking category's externalType...");

                                uint categoryId = uint.Parse(categoryIdStr);

                                switch (externalTypeStr)
                                {
                                    case "8": //Avatar categories and sub-categories
                                        Assert.IsTrue(1400 > categoryId, 
                                                      String.Format("ExternalType 8 does not match with categoryId {0}", categoryId));
                                        break;
                                    case "9": //Avatar body types
                                        Assert.IsTrue(3 >= categoryId && 1 <= categoryId, 
                                                      String.Format("ExternalType 9 does not match with categoryId {0}", categoryId));
                                        break;
                                    case "0": //Avatar extended categories
                                        Assert.IsTrue(1400 < categoryId,
                                                      String.Format("ExternalType 0 does not match with categoryId {0}", categoryId));
                                        break;
                                    default:
                                        Assert.IsTrue(false, 
                                                      String.Format("ExternalType {0} for avatar categories is incorrect.", externalTypeStr));
                                        break;
                                        
                                }
                            }

                            actualCategoryList.Add(categoryIdStr);
                        }
                        else
                        {
                            Trace.WriteLine("Unexpected CategoryId found" + categoryIdStr);
                            Assert.IsFalse(shouldExist, "Found unexpected CategoryId" + categoryIdStr); 
                        }
                    }
                    
                    //checks that each categoryId from the expected list appears in the Offer file
                    foreach (string category in expectedCategoryList)
                    {
                        if (!actualCategoryList.Contains(category))
                        {
                            Trace.WriteLine("Expected CategoryId not found");
                            Assert.IsFalse(shouldExist, "Could not retrieve matching CategoryId"); 
                        }
                    }
                }

                if (contentOfferType.Equals(AvatarItemTypeStr))
                {
                    Trace.WriteLine(String.Format("Checking avatar files for offer {0}...", offerId));

                    //Get avatar GUID
                    XmlNode mediaIdNode = offerFile.SelectSingleNode("/x:LiveOffer/x:contentOffer/x:gameContentMediaId", namespaceManager);
                    Assert.IsNotNull(mediaIdNode, "documentContentXPath did not return a node for gameContentMediaId. This is expected for this media type.");
                    String avatarItemGuid = mediaIdNode.InnerText.Trim();
                    Assert.IsNotNull(avatarItemGuid, "AvatarItem GUID must not be NULL.");

                    if (!String.IsNullOrEmpty(avatarItemGuid))
                    {
                        //Check for bin
                        VerifyAvatarItemBin(avatarItemGuid, true);

                        //Check for pngs
                        VerifyAvatarItemIcons(avatarItemGuid, true, expectedOptionalPNGCount);
                    }
                }
            }
            else
            {
                Trace.WriteLine("Offer file does not exist so the existence of an .xcp file cannot be verified.");

                Assert.IsFalse(shouldExist, "This appears to be a negative test case missing an offer file, but the test settings expect an .xcp file to exist which is not possible.  Check the entry in LiveContent.xml for this test case.");

                return;
            }

            if ((true == shouldExist) && (null != offerId))
            {
                Trace.WriteLine("Checking TitleVault (Content)...");

                string titleVaultPath = String.Format("{0}\\{1}", Config.TitleVaultPath, titleId.Substring(2));

                foreach (string contentId in listContentIds)
                {
                    string titleVaultFile = String.Format("{0}\\{1}_{2}.cab", titleVaultPath, offerId.Substring(2), contentId);
                    Trace.WriteLine(String.Format("Checking {0}", titleVaultFile));
                    if(shouldExistInTitleVault)
                        Assert.IsTrue(File.Exists(titleVaultFile), "File does not exist and it should");
                    else
                        Assert.IsFalse(File.Exists(titleVaultFile), "File exists and it should not");
                    
                }
            }

            int pcConsoleTypeId = 4; //console type for PCs
            if (null != packageFilename && pcConsoleTypeId == consoleTypeId)
            {
                string filename = String.Format("\\\\{0}\\Content\\LiveToolsTests\\{1}\\{2}", Config.DownloadMachine, titleId.Substring(2), Path.GetFileName(packageFilename));

                Trace.WriteLine(String.Format("Checking {0}", filename));
                if (true == shouldExist)
                {
                    Assert.IsTrue(File.Exists(filename), "File does not exist and it should");
                }
                else
                {
                    Assert.IsFalse(File.Exists(filename), "File exists and it should not");
                }
            }
            else
            {
                foreach (string contentId in listContentIds)
                {
                    string filename = String.Format("\\\\{0}\\Content\\LiveToolsTests\\{1}\\{2}.xcp", Config.DownloadMachine, titleId.Substring(2), contentId);

                    Trace.WriteLine(String.Format("Checking {0}", filename));
                    if (true == shouldExist)
                    {
                        Assert.IsTrue(File.Exists(filename), "File does not exist and it should");
                    }
                    else
                    {
                        Assert.IsFalse(File.Exists(filename), "File exists and it should not");
                    }

                    if (null != packageFilename && packageFilename.ToUpper().EndsWith("XPKG")) //svod file case
                    {

                        //Size validation for file compression
                        //The xcp file smaller than the original xpkg, even when skipping compression.
                        //If we skip compression, compare the output file size with the expected xcp size.

                        FileInfo inputFileInfo = new FileInfo(packageFilename); //original xpkg file info
                        FileInfo outputFileInfo = new FileInfo(filename); //converted xcp file info
                        int inputFileLength = (int)inputFileInfo.Length;
                        int outputFileLength = (int)outputFileInfo.Length;

                        //no compression
                        if (null != commandLineArgs && commandLineArgs.Contains("skipsvodcompression") && expectedXcpSize > 0)
                        {
                            Assert.IsTrue(outputFileLength == expectedXcpSize, "Files are not the same size and they should be.");
                        }
                        else //compressed
                        {
                            Assert.IsTrue(outputFileLength < inputFileLength, "The file was not compressed; the file is not smaller than the original and it should be.");
                        }
                    }
                }
            }
        }
        #endregion

        #region LiveToolsScenarios
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveToolsScenarios.xml", "ScenarioBVT", DataAccessMethod.Sequential), TestMethod]
        public void LiveToolsScenarioBVTs()
        {
            RunLiveToolsScenarioTests();
        }

        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveToolsScenarios.xml", "Scenario", DataAccessMethod.Sequential), TestMethod]
        public void LiveToolsScenarioTests()
        {
            RunLiveToolsScenarioTests();
        }

        public void RunLiveToolsScenarioTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string titleId = (string)TestContext.DataRow["TitleId"];
            string consoleTypeIdString = TryGetColumnValue("ConsoleTypeId");
            string liveTitleFile = (string)TestContext.DataRow["LiveTitleInputFile"];
            string liveContentFile = TryGetColumnValue("LiveContentInputFile");
            string liveOfferFile = (string)TestContext.DataRow["LiveOfferInputFile"];
            string originalOfferIdsDelimited = (string)TestContext.DataRow["OfferId"];
            string mediaTypeId = TryGetColumnValue("MediaTypeId");
            string offerMediaTypeId = TryGetColumnValue("OfferMediaTypeId");
            string associatedLiveTitleFile = TryGetColumnValue("AssociatedLiveTitleInputFile");
            string associatedTitleId = TryGetColumnValue("AssociatedTitleId");
            string isMarketplaceFileString = TryGetColumnValue("IsMarketplaceFile");
            string hasContributorString = TryGetColumnValue("HasContributor");
            bool hasContributor = false;
            string finalAltTitleId = ((titleId == XNArelatedTitle1) || (titleId == XNArelatedTitle2)) ? titleId : null;
            string testName = TryGetColumnValue("Name");
            string description = TryGetColumnValue("Description");
            string shouldExistInTitleVaultString = TryGetColumnValue("ShouldExistInTitleVault");
            bool shouldExistInTitleVault = true;

            if (null != shouldExistInTitleVaultString && shouldExistInTitleVaultString.Equals("false"))
            {
                shouldExistInTitleVault = false;
            }

            //if (extractTestData)
            //{
            //    TestDataMigration.StartTestCapture(TestDataMigration.TestType.LIVE_OFFER, "LiveToolsScenario", testName, description, titleId, consoleTypeIdString, originalOfferIdsDelimited);
            //}

            if (null != hasContributorString)
            {
                hasContributor = Convert.ToBoolean(hasContributorString);
            }

            int consoleTypeId = 2;

            if (null != consoleTypeIdString)
            {
                consoleTypeId = Convert.ToInt16(consoleTypeIdString);
            }

            string[] originalOfferIds = originalOfferIdsDelimited.Split(';');
            string[] offerIds = new string[originalOfferIds.Length];

            for (int index = 0; index < originalOfferIds.Length; index++)
            {
                offerIds[index] = String.Format("{0}-0000-4000-8000-0000{1}", originalOfferIds[index].Substring(10, 8), originalOfferIds[index].Substring(2, 8));
            }

            string[] MediaTypeArray = null;

            if (null != offerMediaTypeId && hasContributor)
            {
                MediaTypeArray = offerMediaTypeId.Split(';');
                Assert.AreEqual(originalOfferIds.Length, MediaTypeArray.Length, String.Format("For Verifying Contributors Number of OfferIds {0} must be equal to number of OfferMediaTypeIds {1}", originalOfferIds.Length, MediaTypeArray.Length));
            }

            bool shouldBeVisible = Convert.ToBoolean(TestContext.DataRow["Visible"]);

            bool isMarketplaceFile = false;

            if (null != isMarketplaceFileString)
            {
                isMarketplaceFile = Convert.ToBoolean(isMarketplaceFileString);
            }

            CleanLiveContentOutput();

            foreach (string offerId in offerIds)
            {
                CleanOffer(offerId);
            }

            try
            {
                CleanGame(titleId, consoleTypeId);
            }
            catch (Exception e)
            {
                Trace.WriteLine(String.Format("WARNING: Deleting the title for this test failed.  See LSG bug 4371: {0}", e.Message));
            }

            string liveTitleOutput = null;

            if (null != associatedLiveTitleFile)
            {
                liveTitleOutput = RunLiveTitle(associatedLiveTitleFile, associatedTitleId, "livetitledefault", true, "/images ", false, null, null);

                if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
                {
                    Assert.Fail("An error occurred in the tool");
                }

                liveTitleOutput = RunLiveTitle(associatedLiveTitleFile, associatedTitleId, "deploy", true, "/images ", false, null, null);

                if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
                {
                    Assert.Fail("An error occurred in the tool");
                }

                if (false == isMarketplaceFile)
                {
                    liveTitleOutput = RunLiveTitle(liveTitleFile, titleId, "livetitledefault", true, "/images /verbose ", false, null, null);

                    if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
                    {
                        Assert.Fail("An error occurred in the tool");
                    }
                }
            }
            else if (false == isMarketplaceFile)
            {
                liveTitleOutput = RunLiveTitle(liveTitleFile, titleId, "livetitledefault", true, "/images /verbose ", false, null, null);

                if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
                {
                    Assert.Fail("An error occurred in the tool");
                }
            }

            liveTitleOutput = RunLiveTitle(liveTitleFile, titleId, "deploy", true, "/images ", isMarketplaceFile, null, null);

            if (liveTitleOutput.Contains("error:") || liveTitleOutput.Contains("warning:") || liveTitleOutput.Contains("Error in XLast file"))
            {
                Assert.Fail("An error occurred in the tool");
            }

            string arguments = null;

            if (null != liveContentFile)
            {
                foreach (string originalOfferId in originalOfferIds)
                {
                    string liveContentOutput = RunLiveContent(liveContentFile, liveOfferFile, originalOfferId, null, null, titleId, "build", null, true);

                    if ((true == liveContentOutput.Contains("ERROR:")) || (true == liveContentOutput.Contains("EXCEPTION")) || (true == liveContentOutput.Contains("FAILED:")))
                    {
                        Assert.Fail("An error occurred in the tool");
                    }
                    else if (false == liveContentOutput.Contains("Package(s) built and deployed succesfully"))
                    {
                        Assert.Fail("An error occurred in the tool");
                    }
                }
            }
            else
            {
                arguments = "-skipxrl";
            }

            string liveOfferOutput = RunLiveOffer(liveOfferFile, titleId, "prop", arguments);

            if ((liveOfferOutput.Contains("LiveTool exit code: -1")) || (liveOfferOutput.Contains("Exception:")) || (liveOfferOutput.Contains("LiveOffer error (aborting)")))
            {
                Assert.Fail("An error occurred in the tool");
            }

            VerifyTitle(((titleId == "0xFFFE07D2") || (titleId == "0x584E07D2")) ? originalOfferIds[0].Substring(0, 10) : titleId, consoleTypeId, mediaTypeId, liveTitleFile, liveOfferFile, 1, shouldBeVisible, isMarketplaceFile);

            for (int index = 0; index < originalOfferIds.Length; index++)
            {
                string finalTitleId = ((titleId == XNArelatedTitle1) || (titleId == XNArelatedTitle2)) ? originalOfferIds[index].Substring(0, 10) : titleId;

                if (offerMediaTypeId != null && hasContributor)
                    VerifyOffer(offerIds[index], liveOfferFile, true, 3, finalTitleId, finalAltTitleId, consoleTypeId, index + 1, originalOfferIds[index], MediaTypeArray[index], false, null,null, hasContributor, null, -1);
                else
                    VerifyOffer(offerIds[index], liveOfferFile, true, 3, finalTitleId, finalAltTitleId, consoleTypeId, index + 1, originalOfferIds[index], offerMediaTypeId, false, null,null,hasContributor, null, -1);
            }

            if (null != liveContentFile)
            {

                VerifyLiveContentOutput(liveOfferFile, originalOfferIds[0], titleId, liveContentFile, true, consoleTypeId, null, 0, null, 0, null, shouldExistInTitleVault);
            }
        }

        #endregion

        #region LiveHive
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveHive.xml", "HiveBVT", DataAccessMethod.Sequential), TestMethod]
        public void LiveHiveBVTs()
        {
            RunLiveHiveTests();
        }

        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\LiveHive.xml", "Hive", DataAccessMethod.Sequential), TestMethod]
        public void LiveHiveFunctionalTests()
        {
            RunLiveHiveTests();
        }

        public void RunLiveHiveTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string packageFile = TryGetColumnValue("PackageFile");
            string titleId = TryGetColumnValue("TitleId");
            string updateString = TryGetColumnValue("Update");
            bool selective = false;
            string uodbBaseString = TryGetColumnValue("UodbBase");
            int uodbBase = Convert.ToInt32(uodbBaseString);
            string uodbVersionString = TryGetColumnValue("UodbVersion");
            int uodbBaseVersion = Convert.ToInt32(uodbVersionString);
            string buildString = TryGetColumnValue("Build");
            string qfeString = TryGetColumnValue("Qfe");
            string manifestString = TryGetColumnValue("Manifest");
            string packagesString = TryGetColumnValue("Packages");

            string[] packages = packagesString.Split(';');

            CleanLiveContentOutput();
            CleanLiveHiveOutputNpdb(buildString, qfeString, manifestString);
            CleanLiveHiveOutputUodb(titleId);

            if (null != updateString)
            {
                updateString = "/update:selective";
                selective = true;
            }
            else
            {
                updateString = "/update:full";
            }

            string liveContentOutput = RunLiveContent(packageFile, null, null, null, null, titleId, "build", updateString, true);

            if ((liveContentOutput.Contains("ERROR:")) || (liveContentOutput.Contains("EXCEPTION")) || (liveContentOutput.Contains("FAILED:")))
            {
                Assert.Fail("An error occurred in the tool");
            }
            else if (false == liveContentOutput.Contains("Package(s) built and deployed succesfully"))
            {
                Assert.Fail("An error occurred in the tool");
            }

            VerifyLiveHiveOutputFiles(buildString, qfeString, manifestString, packages);
            VerifyLiveHiveOutputNpdb(buildString, qfeString, manifestString, selective);
            VerifyLiveHiveOutputUodb(titleId, uodbBase, uodbBaseVersion, selective);
        }

        private void CleanLiveHiveOutputNpdb(string buildString, string qfeString, string manifestString)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.NpdbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.NpdbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_live_registry_settings where vc_environment='xblob' and vc_client_config='xenon' and si_build='{0}' and si_qfe='{1}'", buildString, qfeString));
                }
                catch (SqlException)
                {
                }
            }
        }

        private void CleanLiveHiveOutputUodb(string titleId)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.UodbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.UodbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_versions where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_update_packages where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_update_locations where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }
            }
        }

        private void VerifyLiveHiveOutputFiles(string buildString, string qfeString, string manifestString, string[] packages)
        {
            string packagesPath = String.Format("\\\\{0}\\Content\\LiveToolsTests\\xenon\\{1}\\{2}\\{3}", Config.DownloadMachine, buildString, qfeString, manifestString);

            string manifestname = String.Format("{0}\\system.manifest", packagesPath);
            Trace.WriteLine(String.Format("Checking {0}", manifestname));
            Assert.IsTrue(File.Exists(manifestname), "File does not exist and it should");

            foreach (string package in packages)
            {
                string filename = String.Format("{0}\\{1}", packagesPath, package);
                Trace.WriteLine(String.Format("Checking {0}", filename));
                Assert.IsTrue(File.Exists(filename), "File does not exist and it should");
            }
        }

        private void VerifyLiveHiveOutputNpdb(string buildString, string qfeString, string manifestString, bool selective)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.NpdbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.NpdbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_live_registry_settings where vc_environment='xblob' and vc_client_config='xenon' and si_build='{0}' and si_qfe='{1}'", buildString, qfeString));

                string packageUriRoot = null;
                string currentManifestRevision = null;
                int count = 0;

                while (true == sqlDataReader.Read())
                {
                    count++;

                    Assert.AreEqual(selective, Convert.ToBoolean(sqlDataReader["ti_beta_machine"]), "ti_beta_machine does not match expected value");

                    if ("CurrentManifestRevision" == (string)sqlDataReader["vc_setting"])
                    {
                        currentManifestRevision = (string)sqlDataReader["vc_value"];
                    }

                    if ("PackageUriRoot1" == (string)sqlDataReader["vc_setting"])
                    {
                        packageUriRoot = (string)sqlDataReader["vc_value"];
                    }
                }

                sqlDataReader.Close();

                Assert.AreEqual(2, count, "t_live_registry_settings does not have a row count of 2");
                Assert.AreEqual(manifestString, currentManifestRevision, "CurrentManifestRevision does not match expected value");

                string uriString = String.Format("http://{0}:3074/content/LiveToolsTests/xenon/{1}/{2}/{3}", Config.DownloadMachine, buildString, qfeString, manifestString);
                Assert.AreEqual(uriString, packageUriRoot, "PackageUriRoot1 does not match expected value");
            }
        }

        private void VerifyLiveHiveOutputUodb(string titleId, int uodbBase, int uodbVersion, bool selective)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.UodbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.UodbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_versions where i_title_id={0}", titleId));

                int count = 0;
                bool baseVersion = false;
                bool updateVersion = false;

                while (true == sqlDataReader.Read())
                {
                    count++;

                    if (uodbBase == (int)sqlDataReader["i_base_version"])
                    {
                        baseVersion = true;

                        if (true == selective)
                        {
                            Assert.AreEqual(uodbBase, (int)sqlDataReader["i_update_version"], String.Format("t_title_versions i_base_version = {0}, i_update_version = {1} when i_base_version = {0}, i_update_version = {0} expected", uodbBase, sqlDataReader["i_update_version"]));
                        }
                        else
                        {
                            Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_update_version"], String.Format("t_title_versions i_base_version = {0}, i_update_version = {1} when i_base_version = {0}, i_update_version = {2} expected", uodbBase, sqlDataReader["i_update_version"], uodbVersion));
                        }

                        Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_beta_version"], String.Format("t_title_versions i_base_version = {0}, i_beta_version = {1} when i_base_version = {0}, i_beta_version = {2} expected", uodbBase, sqlDataReader["i_beta_version"], uodbVersion));
                    }

                    if (uodbVersion == (int)sqlDataReader["i_update_version"])
                    {
                        updateVersion = true;

                        Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_update_version"], String.Format("t_title_versions i_base_version = {0}, i_update_version = {1} when i_base_version = {0}, i_update_version = {2} expected", uodbBase, sqlDataReader["i_update_version"], uodbVersion));

                        Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_beta_version"], String.Format("t_title_versions i_base_version = {0}, i_beta_version = {1} when i_base_version = {0}, i_beta_version = {2} expected", uodbBase, sqlDataReader["i_beta_version"], uodbVersion));
                    }
                }

                sqlDataReader.Close();

                Assert.AreEqual(2, count, "t_title_versions does not have a row count of 2");
                Assert.IsTrue(baseVersion, "t_title_versions missing base version row");
                Assert.IsTrue(updateVersion, "t_title_versions missing update version row");
            }

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_update_packages where i_title_id={0}", titleId));

                int count = 0;

                while (true == sqlDataReader.Read())
                {
                    count++;

                    Assert.AreEqual(uodbBase, (int)sqlDataReader["i_title_base_version"], String.Format("t_title_update_packages i_title_base_version = {0} when {1} expected", sqlDataReader["i_title_base_version"], uodbBase));
                    Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_title_update_version"], String.Format("t_title_update_packages i_title_update_version = {0} when {1} expected", sqlDataReader["i_title_update_version"], uodbVersion));
                }

                sqlDataReader.Close();

                Assert.AreEqual(1, count, "t_title_update_packages does not have a row count of 1");
            }

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_update_locations where i_title_id={0}", titleId));

                int count = 0;

                while (true == sqlDataReader.Read())
                {
                    count++;

                    Assert.AreEqual(uodbBase, (int)sqlDataReader["i_title_base_version"], String.Format("t_title_update_packages i_title_base_version = {0} when {1} expected", sqlDataReader["i_title_base_version"], uodbBase));
                    Assert.AreEqual(uodbVersion, (int)sqlDataReader["i_title_update_version"], String.Format("t_title_update_packages i_title_update_version = {0} when {1} expected", sqlDataReader["i_title_update_version"], uodbVersion));
                }

                sqlDataReader.Close();

                Assert.AreEqual(1, count, "t_title_update_packages does not have a row count of 1");
            }
        }

        #endregion

        #region TitleUpdate
        [DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\TitleUpdate.xml", "TitleUpdateBVT", DataAccessMethod.Sequential), TestMethod]
        public void TitleUpdateBVTs()
        {
            RunTitleUpdateTests();
        }

        public void RunTitleUpdateTests()
        {
            DataColumnCollection columns = TestContext.DataRow.Table.Columns;

            foreach (DataColumn column in columns)
            {
                Trace.WriteLine(String.Format("{0}: {1}", column.ColumnName, TestContext.DataRow[column]));
            }

            string packageFile = TryGetColumnValue("PackageFile");
            string titleId = TryGetColumnValue("TitleId");
            string updateString = TryGetColumnValue("Update");
            string uodbBaseVersionString = TryGetColumnValue("UodbBaseVersion");
            int uodbBaseVersion = Convert.ToInt32(uodbBaseVersionString);
            string uodbUpdateVersionString = TryGetColumnValue("UodbUpdateVersion");
            int uodbUpdateVersion = Convert.ToInt32(uodbUpdateVersionString);
            string baseVersion = TryGetColumnValue("BaseVersion");
            string updateVersion = TryGetColumnValue("UpdateVersion");
            bool pcPlatform = Convert.ToBoolean(TryGetColumnValue("PCPlatform"));
            string contentId = Convert.ToString(TryGetColumnValue("ContentId"));


            CleanLiveContentOutput();
            CleanTitleUpdateOutputUodb(titleId);

            if (updateString == null)
            {
                updateString = "/update:full";
            }

            string liveContentOutput = RunLiveContent(packageFile, null, null, null, null, titleId, "build", updateString, true);

            if ((liveContentOutput.Contains("ERROR:")) || (liveContentOutput.Contains("EXCEPTION")) || (liveContentOutput.Contains("FAILED:")))
            {
                Assert.Fail("An error occurred in the tool");
            }
            else if (false == liveContentOutput.Contains("Package(s) built and deployed succesfully"))
            {
                Assert.Fail("An error occurred in the tool");
            }

            VerifyTitleUpdateOutputFiles(baseVersion, updateVersion, titleId, contentId, pcPlatform);
            VerifyTitleUpdateOutputUodb(titleId, uodbBaseVersion, uodbUpdateVersion, baseVersion, updateVersion, pcPlatform, contentId);
        }

        /// <summary>
        /// Cleaning up the test data from the UODB database.
        /// </summary>  
        private void CleanTitleUpdateOutputUodb(string titleId)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.UodbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.UodbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                sqlConnection.Open();

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_versions where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_update_packages where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }

                try
                {
                    ExecuteSql(sqlConnection, String.Format("delete t_title_update_locations where i_title_id={0}", titleId));
                }
                catch (SqlException)
                {
                }
            }
        }

        /// <summary>
        /// Verifying the Existence of the Output Files generated by Title Update.
        /// </summary>  
        private void VerifyTitleUpdateOutputFiles(string baseVersion, string updateVersion, string titleId, string ContentId, bool pcPlatform)
        {
            string filename = null;

            if (pcPlatform)
                filename = String.Format("\\\\{0}\\Content\\LiveToolsTests\\{1}\\tu{2}_{3}.cab", Config.DownloadMachine, titleId.Substring(2), baseVersion.Substring(2), updateVersion.Substring(2));
            else
                filename = String.Format("\\\\{0}\\Content\\LiveToolsTests\\{1}\\{2}.xcp", Config.DownloadMachine, titleId.Substring(2), ContentId);

            Trace.WriteLine(String.Format("Checking {0}", filename));
            if (false == File.Exists(filename))
            {
                Assert.Fail("File does not exist and it should");
            }
        }

        /// <summary>
        /// Verifying the tables got updated properly with the correct data in UODB.
        /// </summary>  
        private void VerifyTitleUpdateOutputUodb(string titleId, int uodbBaseVersion, int uodbUpdateVersion, string baseVersion, string updateVersion, bool pcPlatform, string contentId)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            string[] fullNameDelimited = Assembly.GetExecutingAssembly().FullName.Split(',');

            sqlConnectionStringBuilder.ApplicationName = fullNameDelimited[0] + " (" + fullNameDelimited[1].TrimStart() + ")";
            sqlConnectionStringBuilder.DataSource = Config.UodbServer;
            sqlConnectionStringBuilder.InitialCatalog = Config.UodbDatabase;
            sqlConnectionStringBuilder.IntegratedSecurity = true;

            int uodbBaseVersionBk = uodbBaseVersion;

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                int count = 0;

                sqlConnection.Open();

                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_versions where i_title_id={0}", titleId));

                while (true == sqlDataReader.Read())
                {
                    if ((int)sqlDataReader["i_base_version"] != 0)
                        count++;

                    if (uodbBaseVersion == (int)sqlDataReader["i_base_version"])
                    {
                        Assert.AreEqual(uodbUpdateVersion, (int)sqlDataReader["i_update_version"], String.Format("t_title_versions i_base_version = {0}, i_update_version = {1} when i_base_version = {0}, i_update_version = {2} expected", uodbBaseVersion, sqlDataReader["i_update_version"], uodbUpdateVersion));
                    }

                    if (uodbUpdateVersion == (int)sqlDataReader["i_update_version"])
                    {
                        Assert.AreEqual(uodbUpdateVersion, (int)sqlDataReader["i_update_version"], String.Format("t_title_versions i_base_version = {0}, i_update_version = {1} when i_base_version = {0}, i_update_version = {2} expected", uodbBaseVersion, sqlDataReader["i_update_version"], uodbUpdateVersion));
                        uodbBaseVersion = uodbUpdateVersion;
                    }
                }

                sqlDataReader.Close();
                Assert.AreEqual(2, count, "t_title_versions does not have a row count of 2");
            }

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                uodbBaseVersion = uodbBaseVersionBk;
                sqlConnection.Open();

                int count = 0;
                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_update_packages where i_title_id={0}", titleId));

                while (true == sqlDataReader.Read())
                {
                    count++;
                    Assert.AreEqual(uodbBaseVersion, (int)sqlDataReader["i_title_base_version"], String.Format("t_title_update_packages i_title_base_version = {0} when {1} expected", sqlDataReader["i_title_base_version"], uodbBaseVersion));
                    Assert.AreEqual(uodbUpdateVersion, (int)sqlDataReader["i_title_update_version"], String.Format("t_title_update_packages i_title_update_version = {0} when {1} expected", sqlDataReader["i_title_update_version"], uodbUpdateVersion));
                    Assert.AreNotEqual(0, (int)sqlDataReader["i_install_size"], String.Format("t_title_update_packages i_install_size = {0} when should not be equal to {1}", sqlDataReader["i_install_size"], 0));
                }

                sqlDataReader.Close();
                Assert.AreEqual(1, count, "t_title_update_packages does not have a row count of 1");
            }

            using (SqlConnection sqlConnection = new SqlConnection(sqlConnectionStringBuilder.ConnectionString))
            {
                uodbBaseVersion = uodbBaseVersionBk;
                sqlConnection.Open();
                string filename = null;
                int count = 0;
                SqlDataReader sqlDataReader = ExecuteSqlReader(sqlConnection, String.Format("select * from t_title_update_locations where i_title_id={0}", titleId));

                while (true == sqlDataReader.Read())
                {
                    count++;
                    if (pcPlatform)
                        filename = String.Format("http://{0}:3074/content/LiveToolsTests/{1}/tu{2}_{3}.cab", Config.DownloadMachine, titleId.Substring(2), baseVersion.Substring(2), updateVersion.Substring(2));
                    else
                        filename = String.Format("http://{0}:3074/content/LiveToolsTests/{1}/{2}.xcp", Config.DownloadMachine, titleId.Substring(2), contentId.ToLower());

                    Assert.AreEqual(uodbBaseVersion, (int)sqlDataReader["i_title_base_version"], String.Format("t_title_update_locations i_title_base_version = {0} when {1} expected", sqlDataReader["i_title_base_version"], uodbBaseVersion));
                    Assert.AreEqual(uodbUpdateVersion, (int)sqlDataReader["i_title_update_version"], String.Format("t_title_update_locations i_title_update_version = {0} when {1} expected", sqlDataReader["i_title_update_version"], uodbUpdateVersion));
                    Assert.AreEqual(filename, (string)sqlDataReader["vc_XRL"], String.Format("t_title_update_locations vc_XRL = {0} when {1} expected", sqlDataReader["vc_XRL"], filename));
                }

                sqlDataReader.Close();
                Assert.AreEqual(1, count, "t_title_update_locations does not have a row count of 1");
            }
        }
        #endregion

        #region Utilities
        private string TryGetColumnValue(string column)
        {
            string columnValue = null;

            try
            {
                columnValue = TestContext.DataRow[column] as string;
            }
            catch { }
            return columnValue;
        }

        private static string RunLiveTool(string commandLine, string arguments)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo(commandLine, arguments);
            startInfo.ErrorDialog = false;
            startInfo.RedirectStandardOutput = true;
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.WorkingDirectory = Config.LiveToolsPath;

            Process process = new Process();
            process.StartInfo = startInfo;

            sbOutput = new StringBuilder();
            process.OutputDataReceived += new DataReceivedEventHandler(OutputHandler);

            process.Start();
            process.BeginOutputReadLine();
            process.WaitForExit();

            string message = String.Format("LiveTool exit code: {0}", process.ExitCode);
            Trace.WriteLine(message);

            return sbOutput.ToString() + "\r\n" + message;
        }

        private static void OutputHandler(object sender, DataReceivedEventArgs e)
        {
            if (null != e.Data)
            {
                Trace.WriteLine(e.Data);
                sbOutput.AppendLine(e.Data);
            }
        }

        private void CompareXmlNodeCountToArrayLength(XmlDocument document, XmlNamespaceManager namespaceManager, string documentContentXPath, int expectedCount, bool canBeLarger)
        {
            Trace.WriteLine(String.Format("Comparing xml document content (node count) from '{0}' against value '{1}'...", documentContentXPath, expectedCount));

            XmlNodeList nodeList = document.SelectNodes(documentContentXPath, namespaceManager);

            Assert.IsNotNull(nodeList, "documentContentXPath did not return any nodes");

            if ((true == documentContentXPath.EndsWith("Rating")) && (0 == nodeList.Count) && (1 == expectedCount))
            {
                Trace.WriteLine("No Rating entries were specified in the input file so one Rating is specified in the catalog.");
            }
            else if (true == canBeLarger)
            {
                Assert.IsTrue(expectedCount >= nodeList.Count, String.Format("XmlDocument node count '{0}' from {1} does not match returned object's Length property value of '{2}'", nodeList.Count, documentContentXPath, expectedCount));
            }
            else
            {
                Assert.AreEqual(expectedCount, nodeList.Count, String.Format("XmlDocument node count '{0}' from {1} does not match returned object's Length property value of '{2}'", nodeList.Count, documentContentXPath, expectedCount));
            }
        }

        private void CompareXmlNodesToArray(XmlDocument document, XmlNamespaceManager namespaceManager, string documentContentXPath, Array array, string comparisonValueXPath, string arrayElementPropertyName, string webServiceMethodToCallForMapping, string webServiceObjectPropertyForMapping, string webServiceObjectPropertyForComparison)
        {
            Trace.WriteLine(String.Format("\r\nComparing xml document content from '{0}' against array {1}...", documentContentXPath, array.ToString()));

            XmlNodeList nodeList = document.SelectNodes(documentContentXPath, namespaceManager);

            Assert.IsNotNull(nodeList, "documentContentXPath did not return any nodes");

            if (0 == nodeList.Count)
            {
                return;
            }

            PropertyInfo property = array.GetValue(0).GetType().GetProperty(arrayElementPropertyName);

            Assert.IsNotNull(property, "arrayElementPropertyName did not an object");

            Trace.WriteLine(String.Format("The value of property '{0}' will be compared against the value from the source xml document.", arrayElementPropertyName));

            MethodInfo webServiceMethod = null;

            if (null != webServiceMethodToCallForMapping)
            {
                webServiceMethod = webService.GetType().GetMethod(webServiceMethodToCallForMapping);

                Assert.IsNotNull(webServiceMethod, String.Format("Method '{0}' is needed to look up a value but it could not be found on the web service proxy.  Check the method name used in the test code.", webServiceMethodToCallForMapping));

                Trace.WriteLine(String.Format("Method '{0}' will be used to map values from the source xml document to EMS catalog values.", webServiceMethodToCallForMapping));
            }


            if ("RatingValueId" == arrayElementPropertyName)
            {
                List<int> xmlRatings = new List<int>();
                Dictionary<uint, uint> dictionary = new Dictionary<uint, uint>();

                foreach (XmlNode xmlNode in nodeList)
                {
                    XmlAttributeCollection ratingAttributes = xmlNode.Attributes;
                    uint ratingId = UInt32.Parse(ratingAttributes["ratingId"].InnerText);
                    uint ratingSystemId = UInt32.Parse(ratingAttributes["ratingSystemId"].InnerText);

                    //Duplicate ratings should have failed propping.  Should never get here.
                    try
                    {
                        dictionary.Add(ratingSystemId, ratingId);

                        int catalogRatingId = GetRatingValueId(ratingId, ratingSystemId);
                        xmlRatings.Add(catalogRatingId);

                        #region special case (bug 37096)
                        // double prop GRB and KMRB values
                        // this region can be deleted once console moves to only use GRB rating system
                        if ((15001 <= catalogRatingId) && (catalogRatingId <= 15004))
                        {
                            // will give a rating id between 11001 and 11004, which is KMRB
                            xmlRatings.Add(catalogRatingId - 4000);                            
                        }
                        #endregion
                    }
                    catch (ArgumentException)
                    {
                        throw new ArgumentException(String.Format("Input file containing duplicate ratingSystemId {0} should have failed to prop.",
                                                                  ratingSystemId));
                    }

                }

                List<int> catalogRatings = new List<int>();
                foreach (MediaRating mediaRating in array)
                {
                    catalogRatings.Add(mediaRating.RatingValueId);
                }

                foreach (int rating in xmlRatings)
                {
                    Assert.IsTrue(-1 != rating, "Input file containing invalid rating(s) should have failed to prop.");

                    Trace.WriteLine(String.Format("Checking xml rating {0} against catalog rating.", rating));
                    Assert.IsTrue(catalogRatings.Contains(rating), "Catalog does not containt this rating.");
                }

                Assert.IsTrue(catalogRatings.Count <= xmlRatings.Count, "There exists more ratings in the database than defined in xml.");
                return;
            }

            object xmlDocumentMappedValue = null;
            object webServiceObjectPropertyValue = null;

            List<object> listObjects = new List<object>();

            foreach (object item in array)
            {
                listObjects.Add(item);
            }


            foreach (XmlNode xmlNode in nodeList)
            {
                XmlNode childNode = xmlNode.SelectSingleNode(comparisonValueXPath, namespaceManager);

                if (null == childNode)
                {
                    continue;
                }

                string xmlDocumentOriginalValue = childNode.InnerText;

                if ("zh-CHT" == xmlDocumentOriginalValue)
                {
                    xmlDocumentOriginalValue = "zh-TW";
                }

                if (("Description" == arrayElementPropertyName) || ("ReducedDescription" == arrayElementPropertyName))
                {
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[ESRB.*\]", "");
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[FPB.*\]", "");
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[KMRB.*\]", "");
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[OFLC.*\]", "");
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[PEGI.*\]", "");
                    xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[USK.*\]", "");
                    //xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[CERO.*\]", "");
                    //xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[GRB.*\]", "");
                    //xmlDocumentOriginalValue = Regex.Replace(xmlDocumentOriginalValue, @"\[BBFC.*\]", "");
                }

                if ("Description" == arrayElementPropertyName)
                {
                    xmlDocumentOriginalValue = xmlDocumentOriginalValue.Trim();
                }

                if ("ReducedDescription" == arrayElementPropertyName)
                {
                    int start = 0;
                    int end = 499;

                    if (!String.IsNullOrEmpty(xmlDocumentOriginalValue) && ' ' == xmlDocumentOriginalValue[0])
                    {
                        start = 1;
                        end = 498;
                    }

                    if ((end + 1) < xmlDocumentOriginalValue.Length)
                    {
                        xmlDocumentOriginalValue = xmlDocumentOriginalValue.Substring(start, end) + "…";
                    }
                    else
                    {
                        xmlDocumentOriginalValue = xmlDocumentOriginalValue.Trim();
                    }
                }

                Trace.WriteLine(String.Format("Checking {0}", xmlDocumentOriginalValue));

                bool found = false;
                int nextItem = 0;

            GetNextItem:
                object item = listObjects[nextItem++];

                xmlDocumentMappedValue = null;

                webServiceObjectPropertyValue = property.GetValue(item, null); ;

                if (null != webServiceMethod)
                {
                    object valueContainer = null;

                    if (webServiceMethod.GetParameters().Length > 0)
                    {
                        valueContainer = webServiceMethod.Invoke(webService, new object[] { xmlDocumentMappedValue });

                        xmlDocumentMappedValue = GetPropertyValue(webServiceMethodToCallForMapping, webServiceObjectPropertyForComparison, valueContainer);
                    }
                    else
                    {
                        GetValueFromServiceForComparison(webServiceMethodToCallForMapping, webServiceObjectPropertyForMapping, webServiceObjectPropertyForComparison, webServiceMethod, xmlDocumentOriginalValue, ref xmlDocumentMappedValue, ref valueContainer);
                    }

                }
                else
                {
                    xmlDocumentMappedValue = xmlDocumentOriginalValue;
                }

                if (webServiceObjectPropertyValue is DateTime)
                {
                    xmlDocumentMappedValue = DateTime.Parse(xmlDocumentMappedValue.ToString(), System.Globalization.CultureInfo.InvariantCulture.DateTimeFormat, System.Globalization.DateTimeStyles.AssumeLocal);
                }

                if (property.Name.Equals("FileUrl", StringComparison.InvariantCultureIgnoreCase))
                {
                    webServiceObjectPropertyValue = Path.GetFileName(webServiceObjectPropertyValue as string);
                    xmlDocumentMappedValue = Path.GetFileName(xmlDocumentMappedValue as string);
                }

                Assert.IsNotNull(xmlDocumentMappedValue, "The value from the EMS catalog's object is unexpectedly null so no comparison can be made.");

                try
                {
                    xmlDocumentMappedValue = Convert.ChangeType(xmlDocumentMappedValue, property.PropertyType);
                }
                catch (Exception e)
                {
                    Trace.WriteLine(String.Format("Warning: conversion of the value from the xml document to the object property type ('{0}') failed: {1}", property.PropertyType, e.Message));
                }

                if (webServiceObjectPropertyValue.Equals(xmlDocumentMappedValue))
                {
                    found = true;
                }
                else if (nextItem < listObjects.Count)
                {
                    goto GetNextItem;
                }

                Trace.WriteLine(String.Format("The value from the web service object containing data inserted by the LiveTool is '{0}'", webServiceObjectPropertyValue));

                Assert.IsTrue(found, "The value was not found in the original file");

                listObjects.RemoveAt(nextItem - 1);
            }

            Trace.WriteLine(String.Format("All nodes matching '{0}' in the source xml file appear to be in the EMS catalog\r\n", documentContentXPath));
        }

        private void GetValueFromServiceForComparison(string webServiceMethodToCallForMapping, string webServiceObjectPropertyForMapping, string webServiceObjectPropertyForComparison, MethodInfo webServiceMethod, string expectedValue, ref object value, ref object valueContainer)
        {
            valueContainer = webServiceMethod.Invoke(webService, new object[] { });

            Array returnedItems = valueContainer as Array;

            Assert.IsNotNull(returnedItems, "No objects were returned from the web service method, so no values can be verified.");

            foreach (object returnedItem in returnedItems)
            {
                value = GetPropertyValue(webServiceMethodToCallForMapping, webServiceObjectPropertyForComparison, returnedItem);

                if (0 == String.Compare(expectedValue, value.ToString(), true))
                {
                    value = GetPropertyValue(webServiceMethodToCallForMapping, webServiceObjectPropertyForMapping, returnedItem);
                    break;
                }

                value = null;
            }
        }

        private object GetPropertyValue(string webServiceMethodToCallForMapping, string webServiceObjectPropertyForMapping, object valueContainer)
        {
            object value = null;

            if (null != valueContainer)
            {
                PropertyInfo actualValueField = valueContainer.GetType().GetProperty(webServiceObjectPropertyForMapping);

                Assert.IsNotNull(actualValueField, String.Format("Property '{0} is needed to look up a value but it could not be found on the object of type {1} returned from method {2}.", webServiceObjectPropertyForMapping, valueContainer.ToString(), webServiceMethodToCallForMapping));

                value = actualValueField.GetValue(valueContainer, null);
            }

            return value;
        }

        private void CompareXmlToPropertyValue(XmlDocument document, XmlNamespaceManager namespaceManager, string documentContentXPath, object propertyValue)
        {
            Trace.WriteLine(String.Format("Comparing xml document content from '{0}' against value '{1}'...", documentContentXPath, propertyValue));

            XmlNode node = document.SelectSingleNode(documentContentXPath, namespaceManager);

            Assert.IsNotNull(node, "documentContentXPath did not return a node");

            Object xmlDocumentValue = node.InnerText.Trim();
            try
            {
                if (documentContentXPath.EndsWith("TitleID"))
                {
                    uint intermediateValue = UInt32.Parse(xmlDocumentValue.ToString());

                    if (intermediateValue > (uint)Int32.MaxValue)
                        xmlDocumentValue = -(-intermediateValue & 0xFFFFFFFF);
                }
                else if (documentContentXPath.EndsWith("offerEnumerationType"))
                {
                    switch ((string)xmlDocumentValue)
                    {
                        case "AlwaysEnumerate":
                            xmlDocumentValue = 1;
                            break;

                        case "AlwaysEnumerateExceptInPartnerNetDash":
                            xmlDocumentValue = 2;
                            break;

                        case "NeverEnumerate":
                            xmlDocumentValue = 3;
                            break;
                    }
                }

                if (propertyValue.GetType() == typeof(byte[]))
                {
                    propertyValue = "0x" + BitConverter.ToString((byte[])propertyValue).Replace("-", "");
                    Trace.WriteLine(String.Format("System.Byte[] has been converted to the string '{0}'", propertyValue));
                }
                else if (propertyValue.GetType() == typeof(Guid))
                {
                    Guid convertedxmlDocumentValue = new Guid(Convert.ToString(xmlDocumentValue));
                    Assert.AreEqual(convertedxmlDocumentValue, propertyValue, String.Format("XmlDocument value '{0}' from {1} does not match returned object's property value of '{2}'", convertedxmlDocumentValue, documentContentXPath, propertyValue));
                    return;
                }
                else
                {
                    xmlDocumentValue = Convert.ChangeType(xmlDocumentValue, propertyValue.GetType());
                }
            }
            catch (Exception e)
            {
                Trace.WriteLine(String.Format("Warning: conversion of the value from the xml document to the object property type ('{0}') failed: {1}", propertyValue.GetType(), e.Message));
            }

            if (propertyValue is string && null != xmlDocumentValue)
            {
                Assert.AreEqual(((string)xmlDocumentValue).ToUpper(), ((string)propertyValue).ToUpper(), String.Format("XmlDocument value '{0}' from {1} does not match returned object's property value of '{2}'", xmlDocumentValue, documentContentXPath, propertyValue));
            }
            else if (!propertyValue.Equals(xmlDocumentValue))
            {
                Assert.AreEqual(xmlDocumentValue, propertyValue, String.Format("XmlDocument value '{0}' from {1} does not match returned object's property value of '{2}'", xmlDocumentValue, documentContentXPath, propertyValue));
            }
        }

        /*
         * This function verifies a proper ingestion of avatar items from an input xlast file.
         */
        private void CompareXmlToAvatarItems(XmlDocument document, XmlNamespaceManager namespaceManager, string titleId)
        {
            XmlNodeList avatarItemList = document.SelectNodes("/x:XboxLiveSubmissionProject/x:GameConfigProject/x:AvatarItems/x:AvatarItem",
                                                               namespaceManager);
            if (null != avatarItemList)
            {
                foreach (XmlNode avatarItem in avatarItemList)
                {
                    String avatarItemGuid1 = avatarItem.Attributes["guid1"].InnerText.TrimEnd('}');
                    avatarItemGuid1 = avatarItemGuid1.TrimStart('{');
                    Assert.IsNotNull(avatarItemGuid1, "The input file with undefined avatar guid should have failed to prop.");

                    VerifyAvatarItemBin(avatarItemGuid1, false);
                    VerifyAvatarItemACP(avatarItemGuid1, false);
                    VerifyAvatarItemIcons(avatarItemGuid1, false, 0);

                    String bodyType = avatarItemGuid1.Substring(17, 1);
                  
                    if (bodyType.Equals("2") || bodyType.Equals("1"))
                    {
                        String avatarItemGuid2 = avatarItem.Attributes["guid2"].InnerText.TrimEnd('}');
                        avatarItemGuid2 = avatarItemGuid2.TrimStart('{');
                        Assert.IsNotNull(avatarItemGuid2, "The input file with undefined avatar guid should have failed to prop.");

                        VerifyAvatarItemBin(avatarItemGuid2, false);
                        VerifyAvatarItemACP(avatarItemGuid2, false);
                        VerifyAvatarItemIcons(avatarItemGuid2, false, 0);
                    }                   
                }
            }
            else
                Trace.WriteLine("Avatar items not defined.  Skip checking...");
         

        }//End avatar item verification

        /*
         * This function verifies the existence of avatar BIN file in CDN.
         */
        private void VerifyAvatarItemBin(String avatarItemGuid, Boolean isAvatarItemOffer)
        {
            string titleId = avatarItemGuid.Substring(28);

            string binName = String.Format("\\\\{0}\\Content\\{1}{2}\\avataritems\\{3}.bin", 
                                           Config.DownloadMachine, 
                                           isAvatarItemOffer? "LiveToolsTests\\" : "", 
                                           titleId, avatarItemGuid);

            Trace.WriteLine(String.Format("Checking avatar bin {0}", binName));
            
            Assert.IsTrue(File.Exists(binName), "Unable to locate the avatar bin file.  File does not exist!");

        }

        private void VerifyAvatarItemACP(String avatarItemGuid, Boolean isAvatarItemOffer)
        {
            string titleId = avatarItemGuid.Substring(28);

            string binName = String.Format("\\\\{0}\\Content\\{1}{2}\\avataritems\\{3}.acp",
                                           Config.DownloadMachine,
                                           isAvatarItemOffer ? "LiveToolsTests\\" : "",
                                           titleId, avatarItemGuid);

            Trace.WriteLine(String.Format("Checking avatar acp {0}", binName));

            Assert.IsTrue(File.Exists(binName), "Unable to locate the avatar bin file.  File does not exist!");

        }

        /*
         * This function verifies the existence of all avatar icons in the storage: 
         *          For avatar awards - 64x64 and 128x128 icons
         *          For avatar offers - In addition to those two, 300x300 icon
         */
        private void VerifyAvatarItemIcons(String avatarItemGuid, Boolean isAvatarItemOffer, int expectedOptionalPNGCount)
        {
            string titleId = avatarItemGuid.Substring(28);
            string smallAvatarIconSuffix = "64";
            string mediumAvatarIconSuffix = "128";
            string largeAvatarIconSuffix = "300";

            VerifyAvatarItemIcon(avatarItemGuid, titleId, smallAvatarIconSuffix);
            VerifyAvatarItemIcon(avatarItemGuid, titleId, mediumAvatarIconSuffix);

            if (isAvatarItemOffer)
            {
                VerifyAvatarItemIcon(avatarItemGuid, titleId, largeAvatarIconSuffix);
                Assert.IsTrue(0 <= expectedOptionalPNGCount && 10 >= expectedOptionalPNGCount, "There can only be 0-10 optional avatar icons.");

                for (int i = 0; i < expectedOptionalPNGCount; i++)
                    VerifyAvatarItemIcon(avatarItemGuid, titleId, i.ToString());
            }
        }

        /*
         * A helper function to verify an existence of an avatar icon in storage.
         */
        private void VerifyAvatarItemIcon(String avatarItemGuid, String titleId, String suffix)
        {
            uint fileCount = 0;
            uint titleIdNum = uint.Parse(titleId, System.Globalization.NumberStyles.AllowHexSpecifier);

            string iconName = String.Format("//global/t:{0}/avataritem/{1}/{2}", titleId, avatarItemGuid, suffix);

            Trace.WriteLine(String.Format("Checking avatar icon-{0}, {1}", suffix, iconName));
            
            Assert.IsNotNull(StUtil.GetStorageEntries(iconName, titleIdNum, 0, 1, ref fileCount),
                             "Unable to locate the avatar icon.  File does not exist!");
            
            Assert.IsTrue(1 == fileCount, "Wrong icon count.  Found {0} icons.", fileCount);
        }

        /* This mapping function takes a UODB rating pair  
         * and converts it to a CatalogDB rating value.
         */
        private int GetRatingValueId(uint ratingId, uint ratingSystemId)
        {
            int catalogRatingValueId = -1;
            if (ratingId == 1 && ratingSystemId == 0) catalogRatingValueId = 0;
            if (ratingId == 2 && ratingSystemId == 0) catalogRatingValueId = 10;
            if (ratingId == 3 && ratingSystemId == 0) catalogRatingValueId = 20;
            if (ratingId == 4 && ratingSystemId == 0) catalogRatingValueId = 30;
            if (ratingId == 5 && ratingSystemId == 0) catalogRatingValueId = 40;
            if (ratingId == 6 && ratingSystemId == 0) catalogRatingValueId = 50;
            if (ratingId == 7 && ratingSystemId == 0) catalogRatingValueId = 60;
            if (ratingId == 8 && ratingSystemId == 0) catalogRatingValueId = 25;
            if (ratingId == 11 && ratingSystemId == 1) catalogRatingValueId = 14001;
            if (ratingId == 12 && ratingSystemId == 1) catalogRatingValueId = 14002;
            if (ratingId == 13 && ratingSystemId == 1) catalogRatingValueId = 14003;
            if (ratingId == 14 && ratingSystemId == 1) catalogRatingValueId = 14004;
            if (ratingId == 15 && ratingSystemId == 1) catalogRatingValueId = 14005;
            if (ratingId == 21 && ratingSystemId == 2) catalogRatingValueId = 4001;
            if (ratingId == 22 && ratingSystemId == 2) catalogRatingValueId = 4002;
            if (ratingId == 23 && ratingSystemId == 2) catalogRatingValueId = 4003;
            if (ratingId == 24 && ratingSystemId == 2) catalogRatingValueId = 4004;
            if (ratingId == 25 && ratingSystemId == 2) catalogRatingValueId = 4005;
            if (ratingId == 31 && ratingSystemId == 3) catalogRatingValueId = 5001;
            if (ratingId == 32 && ratingSystemId == 3) catalogRatingValueId = 5002;
            if (ratingId == 33 && ratingSystemId == 3) catalogRatingValueId = 5003;
            if (ratingId == 34 && ratingSystemId == 3) catalogRatingValueId = 5004;
            if (ratingId == 35 && ratingSystemId == 3) catalogRatingValueId = 5005;
            if (ratingId == 41 && ratingSystemId == 4) catalogRatingValueId = 6001;
            if (ratingId == 42 && ratingSystemId == 4) catalogRatingValueId = 6002;
            if (ratingId == 43 && ratingSystemId == 4) catalogRatingValueId = 6003;
            if (ratingId == 44 && ratingSystemId == 4) catalogRatingValueId = 6004;
            if (ratingId == 45 && ratingSystemId == 4) catalogRatingValueId = 6005;
            if (ratingId == 46 && ratingSystemId == 4) catalogRatingValueId = 6006;
            if (ratingId == 47 && ratingSystemId == 4) catalogRatingValueId = 6007;
            if (ratingId == 48 && ratingSystemId == 4) catalogRatingValueId = 6008;
            if (ratingId == 51 && ratingSystemId == 5) catalogRatingValueId = 100;
            if (ratingId == 52 && ratingSystemId == 5) catalogRatingValueId = 110;
            if (ratingId == 53 && ratingSystemId == 5) catalogRatingValueId = 120;
            if (ratingId == 54 && ratingSystemId == 5) catalogRatingValueId = 130;
            if (ratingId == 56 && ratingSystemId == 5) catalogRatingValueId = 140;
            if (ratingId == 61 && ratingSystemId == 6) catalogRatingValueId = 7001;
            if (ratingId == 62 && ratingSystemId == 6) catalogRatingValueId = 7002;
            if (ratingId == 63 && ratingSystemId == 6) catalogRatingValueId = 7003;
            if (ratingId == 64 && ratingSystemId == 6) catalogRatingValueId = 7004;
            if (ratingId == 65 && ratingSystemId == 6) catalogRatingValueId = 7005;
            if (ratingId == 71 && ratingSystemId == 7) catalogRatingValueId = 8001;
            if (ratingId == 72 && ratingSystemId == 7) catalogRatingValueId = 8002;
            if (ratingId == 73 && ratingSystemId == 7) catalogRatingValueId = 8003;
            if (ratingId == 74 && ratingSystemId == 7) catalogRatingValueId = 8004;
            if (ratingId == 75 && ratingSystemId == 7) catalogRatingValueId = 8005;
            if (ratingId == 81 && ratingSystemId == 8) catalogRatingValueId = 9001;
            if (ratingId == 82 && ratingSystemId == 8) catalogRatingValueId = 9002;
            if (ratingId == 83 && ratingSystemId == 8) catalogRatingValueId = 9003;
            if (ratingId == 84 && ratingSystemId == 8) catalogRatingValueId = 9004;
            if (ratingId == 85 && ratingSystemId == 8) catalogRatingValueId = 9005;
            if (ratingId == 91 && ratingSystemId == 9) catalogRatingValueId = 15001;
            if (ratingId == 92 && ratingSystemId == 9) catalogRatingValueId = 15002;
            if (ratingId == 93 && ratingSystemId == 9) catalogRatingValueId = 15003;
            if (ratingId == 94 && ratingSystemId == 9) catalogRatingValueId = 15004;
            if (ratingId == 101 && ratingSystemId == 10) catalogRatingValueId = 12001;
            if (ratingId == 102 && ratingSystemId == 10) catalogRatingValueId = 12002;
            if (ratingId == 103 && ratingSystemId == 10) catalogRatingValueId = 12003;
            if (ratingId == 104 && ratingSystemId == 10) catalogRatingValueId = 12004;
            if (ratingId == 105 && ratingSystemId == 10) catalogRatingValueId = 12005;
            if (ratingId == 111 && ratingSystemId == 11) catalogRatingValueId = 13001;
            if (ratingId == 112 && ratingSystemId == 11) catalogRatingValueId = 13002;
            if (ratingId == 113 && ratingSystemId == 11) catalogRatingValueId = 13003;
            if (ratingId == 114 && ratingSystemId == 11) catalogRatingValueId = 13004;
            if (ratingId == 115 && ratingSystemId == 11) catalogRatingValueId = 13005;
            if (ratingId == 116 && ratingSystemId == 11) catalogRatingValueId = 13006;

            return catalogRatingValueId;

        }

        /// <summary>
        /// Converts XML node InnerText strings ("true" or "1") to their Boolean equivalents.
        /// </summary>
        /// <param name="xmlNodeText">The XMLNode.InnerText string.</param>
        /// <returns>The boolean equivalent of the string.</returns>
        private bool ConvertXmlToBoolean(string xmlNodeText)
        {
            if ("false" == xmlNodeText.ToLower() | "true" == xmlNodeText.ToLower())
            {
                return bool.Parse(xmlNodeText);
            }
            else if ("0" == xmlNodeText | "1" == xmlNodeText)
            {
                return Convert.ToBoolean(Convert.ToInt32(xmlNodeText));
            }
            else
            {
                throw new ArgumentException(string.Format("The string '{0}' cannot be converted to a boolean value.", xmlNodeText));
            }
        }

        /// <summary>
        /// This function verifies the proper handling of the inheritRating node in the offer file.
        /// </summary>
        /// <param name="offerFile">This offer.</param>
        /// <param name="namespaceManager"></param>
        /// <param name="inheritRatingXPath">string Xpath to the inheritRating node.</param>
        /// <param name="ratingXPath">string Xpath to the rating node.</param>
        /// <param name="p">bool InheritRating value returned from web service.</param>
        private void CompareXmlToInheritRating(XmlDocument offerFile, XmlNamespaceManager namespaceManager, string inheritRatingXPath, string ratingXPath, bool gameContentInheritRating)
        {
            bool inheritRatingFlagExists = false;

            XmlNode inheritRatingNode = offerFile.SelectSingleNode(inheritRatingXPath, namespaceManager);

            if (null != inheritRatingNode)
            {
                inheritRatingFlagExists = true;
            }

            Trace.WriteLine(string.Format("XML Document inheritRating node {0}", inheritRatingFlagExists ? "exists." : "does not exist."));

            XmlNodeList ratingNode = offerFile.SelectNodes(ratingXPath, namespaceManager);

            Assert.IsNotNull(ratingNode, "XMLNodeList ratingNode is null. Expected not null.");
            Trace.WriteLine(string.Format("XML Document rating node count={0}", ratingNode.Count));

            if (true == gameContentInheritRating)    // ratings are inherited. There should not be any ratings 
            {                                         // nodes in the XML document when gameContent.InheritRating is true.
                Trace.WriteLine("Verify XML Document when web service Inherit Rating is true...");

                if (inheritRatingFlagExists && ConvertXmlToBoolean(inheritRatingNode.InnerText))
                {
                    Trace.WriteLine(string.Format("XML Document inherit rating node value '{0}' matches web service value '{1}'. Expected:'True'.", ConvertXmlToBoolean(inheritRatingNode.InnerText), gameContentInheritRating));
                    Trace.WriteLine(string.Format("Verfiy XML Document content node '{0}' does not exist.", ratingXPath));
                    Assert.IsTrue(0 == ratingNode.Count, "XML Document Rating nodes count is '{0}' when XML Document node '{1}' does not exist.", ratingNode.Count, ratingXPath);
                }
                else    // there should not be an inherit rating node or rating nodes.
                {
                    Trace.WriteLine(string.Format("Verify XML Document content node '{0}' does not exist.", inheritRatingXPath));
                    Assert.IsNull(inheritRatingNode, "XML Document Inherit Rating node is not null: expected null, this node should not be in the XML.");
                    Trace.WriteLine(string.Format("Verfiy XML Document content node '{0}' does not exist.", ratingXPath));
                    Assert.IsTrue(0 == ratingNode.Count, "XML Document Rating nodes count is '{0}' when XML Document node {1} does not exist.", ratingNode.Count, inheritRatingXPath);
                }
            }
            else                                     // ratings are not inherited. 
            {
                Trace.WriteLine("Verify XML Document when web service Inherit Rating is false...");

                if (inheritRatingFlagExists && !ConvertXmlToBoolean(inheritRatingNode.InnerText))
                {
                    Trace.WriteLine(string.Format("XML Document inherit rating node value '{0}' matches web service value '{1}'. Expected:'False'", ConvertXmlToBoolean(inheritRatingNode.InnerText), gameContentInheritRating));
                }
                else   // there should not be an inherit rating node but ratings nodes should exist.
                {
                    Trace.WriteLine(string.Format("Verify XML Document content node '{0}' does not exist.", inheritRatingXPath));
                    Assert.IsNull(inheritRatingNode, "XML Document Inherit Rating node is not null: expected null, this node should not be in the XML.");
                    Trace.WriteLine(string.Format("Verify XML Document content node '{0}' exists.", ratingXPath));
                    Assert.IsFalse(0 == ratingNode.Count, "XML Document Rating nodes count is '{0}' when XML Document node {1} does not exist.", ratingNode.Count, inheritRatingXPath);
                }
            }
        }


        #endregion



        #region constants

        private readonly static string MediaTypeGame = "1";
        private readonly static string MediaTypeXboxOriginals = "21";
        private readonly static string MediaTypeArcade = "23";
        private readonly static string MediaTypeXNA = "37";
        private readonly static string MediaTypeAvatarItem = "47";
        private readonly static string XNArelatedTitle1 = "0xFFFE07D2";
        private readonly static string XNArelatedTitle2 = "0x584E07D2";
        private readonly static int LicenseTypeRestrictedToUser = 12;

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\marketplace\CatalogWebService\TestSuite\ModelProgram.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.SpecExplorer.Runtime;
using Microsoft.SpecExplorer.Runtime.Infrastructure;
using System.Reflection;
using Microsoft.SpecExplorer;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Protocols.TestTools;

[assembly:
	LoadAssembly(typeof(Adapter.ICatalogWebServiceAdapter)),
	LoadAssembly(typeof(InputTypes.ChangeType)),
	LoadAssembly(typeof(InputTypes.IdType)),
	LoadAssembly(typeof(InputTypes.RelatedItemIdType)),
	LoadAssembly(typeof(InputTypes.StringType)),
	LoadAssembly(typeof(InputTypes.DecimalType)),
	LoadAssembly(typeof(InputTypes.DateTimeType)),
	LoadAssembly(typeof(ReturnTypes.ExceptionType)),
	LoadAssembly(typeof(InputTypes.ArrayType)),
	LoadAssembly(typeof(InputTypes.IntegerType)),
	LoadAssembly(typeof(InputTypes.BigStringType)),
	LoadAssembly(typeof(InputTypes.XmlType)),
	LoadAssembly(typeof(InputTypes.OfferType)),
]

namespace GeneratedTests
{
	[TestClass]
	public partial class ModelProgram : SpecExplorerTestClass
	{

		#region Variables            
		#endregion
		
		#region Adapters
		private static Adapter.ICatalogWebServiceAdapter icatalogwebserviceadapterInstance;
		#endregion
		
		bool finished;
		bool failed;
		bool nonAcceptingEnd;
		bool firstTime; // The flag for checking if it is the first initialization
        static bool needResetManager = false; // The flag for checking if need to reset the manager.
   
		public ModelProgram() :
			base(
				new string[] { "S0", "S1", "S3", "S5", "S7", "S9", "S11", "S13", "S15", "S17", "S19", "S21", "S23", "S25", "S27", "S29", "S31", "S33", "S35", "S37", "S39", "S41", "S43", "S45", "S47", "S49", "S51", "S53", "S55", "S57", "S59", "S61", "S63", "S65", "S67", "S69", "S71", "S73", "S75", "S77", "S79", "S81", "S83", "S85", "S87", "S89", "S91", "S93", "S95", "S97", "S99", "S2", "S4", "S6", "S8", "S10", "S12", "S14", "S16", "S18", "S20", "S22", "S24", "S26", "S28", "S30", "S32", "S34", "S36", "S38", "S40", "S42", "S44", "S46", "S48", "S50", "S52", "S54", "S56", "S58", "S60", "S62", "S64", "S66", "S68", "S70", "S72", "S74", "S76", "S78", "S80", "S82", "S84", "S86", "S88", "S90", "S92", "S94", "S96", "S98", "S100" },
				new int[] { 0 }
			)
		{
			QuiescenceTimeout = TimeSpan.FromMilliseconds(5000);
			ProceedControlTimeout = TimeSpan.FromMilliseconds(20);
			firstTime = true;
		}
	

		static ITestManager NewManager(ITestSite testSite)
		{
			ITestManager newManager = new StandaloneTestManager(testSite);
			newManager.ReRuns = 1;
			newManager.DepthBound = 5;
			return newManager;	
		}       
	
        #region Initializing methods
	    
        [ClassInitialize()]
        public static void InitializeBeforeAllTests(TestContext context)
        {
            // Create the test site instance.
            TestClassBase.Initialize(context);
            ITestSite testSite = TestClassBase.BaseTestSite;

            // Initialize adapters
            testSite.Log.Add(LogEntryKind.Debug, "Found {0} adapter(s).", 1);
			             
            testSite.Log.Add(LogEntryKind.Debug, "Initializing adapter: {0}", "Adapter.ICatalogWebServiceAdapter");
            icatalogwebserviceadapterInstance= testSite.GetAdapter<Adapter.ICatalogWebServiceAdapter>();
            

            testSite.Log.Add(LogEntryKind.Debug, "Initializing the test manager.");
            
            // Loads necessary assemblies. 
            Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(LoadAssemblyAttribute), false);
            
            manager = NewManager(testSite);
            
            #region initialize actions
            
			actions = new MemberInfo[8];
			
			actions[0] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SavePricingRule(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.RelatedItemIdType countryCode_p3, InputTypes.RelatedItemIdType currencyCode_p4, InputTypes.RelatedItemIdType mediaType_p5, InputTypes.StringType name_p6, InputTypes.RelatedItemIdType provider_p7, InputTypes.DecimalType rate_p8, InputTypes.DecimalType margin_p9, InputTypes.DateTimeType startDate_p10)");
			
			actions[1] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveProvider(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.StringType name_p3, InputTypes.StringType contactInfo_p4, InputTypes.StringType accountNumber_p5)");
			
			actions[2] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveEditorialCollection(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.RelatedItemIdType type_p3, InputTypes.DateTimeType startDate_p4, InputTypes.DateTimeType endDate_p5, InputTypes.ArrayType items_p6)");
			
			actions[3] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveEditorialItem(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.RelatedItemIdType itemType_p3, InputTypes.DateTimeType startDate_p4, InputTypes.DateTimeType endDate_p5)");
			
			actions[4] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveLegalText(InputTypes.IdType id_p1, InputTypes.IntegerType lcid_p2, InputTypes.StringType name_p3, InputTypes.BigStringType text_p4)");
			
			actions[5] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveLicenser(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.StringType name_p3, InputTypes.StringType accountNumber_p4, InputTypes.StringType contactInfo_p5)");
			
			actions[6] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveLicenseType(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.RelatedItemIdType licenseClassId_p3, InputTypes.StringType name_p4, InputTypes.XmlType xml_p5)");
			
			actions[7] = manager.GetMetadata("ReturnTypes.ExceptionType Adapter.ICatalogWebServiceAdapter.SaveOffer(InputTypes.ChangeType change_p1, InputTypes.IdType id_p2, InputTypes.RelatedItemIdType mediaId_p3, InputTypes.StringType name_p4, InputTypes.OfferType offerMode_p5)");
			
	        #endregion
	}//InitializeBeforeAllTests
		
		/// <summary>
		/// Override <see cref="TestClassBase.TestInitialize()"/>
		/// </summary>
		protected override void TestInitialize()
		{
		    base.TestInitialize();
		    
		    // add your test initialize code here
		}
		
        /// <summary>
        /// Many objects need to be reset in this method after the first test, since they have been initialized during 
        /// their creation time.
        /// </summary>
        private void InitializeExceptFirstTime()
        {
            OfflineObservation.Initialize();

            // Reset all adapters.
            icatalogwebserviceadapterInstance.Reset();
		}
		
        /// <summary>
        /// Don't intent to use the [TestInitialize] attribute, since multi-test may be run in a same test case method.
        /// </summary>
        private void InitializeBeforeEachTest()
        {
            if (!firstTime)
            {
                InitializeExceptFirstTime();
            }
            else
            {
                // Sets the flag to false after the first time.
                firstTime = false;
            }
         
            #region Initialize variables
 
            #endregion
        }

        /// <summary>
        /// Resets instances before each rerunning tests in a test case method.
        /// </summary>
        private void InitializeBeforeEachRerun()
        {
            // Reset the test manager except the first time.
            if (needResetManager)
            {
                Manager = NewManager(testSite);
            }
            needResetManager = true;          
        }
        
        #endregion

		
		[ClassCleanup()]
		public static new void Cleanup()
		{
            // Invoke base class Cleanup
            TestClassBase.Cleanup();
		}
		
		public void CheckAndResetObservation()
		{
			bool isError = OfflineObservation.CheckForErrors();
			if(isError)
			{
				string errorMessage = OfflineObservation.DumpQueues(false);
				testSite.Assert.Fail("Error observations have been found in queue:\r\n{0}", errorMessage);
			}
			OfflineObservation.Initialize();
		}		

		[TestMethod]
		public void TestCase0()
		{
			//initial state = S0

			int runs = 0;
			do
			{
				testSite.Log.Add(LogEntryKind.Debug, "Rerunning: {0} time(s).", runs + 1);
				InitializeBeforeEachRerun();
				do
				{	
					InitializeBeforeEachTest();
					Test(0);
				} while (!Manager.BoundReached && Manager.KeepRunning());
				CheckAndResetObservation();
				runs++;
			} while (runs < Manager.ReRuns);
		}
		
		public void Test(int initial)
		{
			currentState = initial;

			finished = false;
			failed = false;
			nonAcceptingEnd = false;
			
			while (!finished)
			{
				switch (currentState)
				{
					case 0: StateS0();   
						break;    
					case 1: StateS1();   
						break;    
					case 2: StateS3();   
						break;    
					case 3: StateS5();   
						break;    
					case 4: StateS7();   
						break;    
					case 5: StateS9();   
						break;    
					case 6: StateS11();   
						break;    
					case 7: StateS13();   
						break;    
					case 8: StateS15();   
						break;    
					case 9: StateS17();   
						break;    
					case 10: StateS19();   
						break;    
					case 11: StateS21();   
						break;    
					case 12: StateS23();   
						break;    
					case 13: StateS25();   
						break;    
					case 14: StateS27();   
						break;    
					case 15: StateS29();   
						break;    
					case 16: StateS31();   
						break;    
					case 17: StateS33();   
						break;    
					case 18: StateS35();   
						break;    
					case 19: StateS37();   
						break;    
					case 20: StateS39();   
						break;    
					case 21: StateS41();   
						break;    
					case 22: StateS43();   
						break;    
					case 23: StateS45();   
						break;    
					case 24: StateS47();   
						break;    
					case 25: StateS49();   
						break;    
					case 26: StateS51();   
						break;    
					case 27: StateS53();   
						break;    
					case 28: StateS55();   
						break;    
					case 29: StateS57();   
						break;    
					case 30: StateS59();   
						break;    
					case 31: StateS61();   
						break;    
					case 32: StateS63();   
						break;    
					case 33: StateS65();   
						break;    
					case 34: StateS67();   
						break;    
					case 35: StateS69();   
						break;    
					case 36: StateS71();   
						break;    
					case 37: StateS73();   
						break;    
					case 38: StateS75();   
						break;    
					case 39: StateS77();   
						break;    
					case 40: StateS79();   
						break;    
					case 41: StateS81();   
						break;    
					case 42: StateS83();   
						break;    
					case 43: StateS85();   
						break;    
					case 44: StateS87();   
						break;    
					case 45: StateS89();   
						break;    
					case 46: StateS91();   
						break;    
					case 47: StateS93();   
						break;    
					case 48: StateS95();   
						break;    
					case 49: StateS97();   
						break;    
					case 50: StateS99();   
						break;    
					case 51: StateS2();   
						break;    
					case 52: StateS4();   
						break;    
					case 53: StateS6();   
						break;    
					case 54: StateS8();   
						break;    
					case 55: StateS10();   
						break;    
					case 56: StateS12();   
						break;    
					case 57: StateS14();   
						break;    
					case 58: StateS16();   
						break;    
					case 59: StateS18();   
						break;    
					case 60: StateS20();   
						break;    
					case 61: StateS22();   
						break;    
					case 62: StateS24();   
						break;    
					case 63: StateS26();   
						break;    
					case 64: StateS28();   
						break;    
					case 65: StateS30();   
						break;    
					case 66: StateS32();   
						break;    
					case 67: StateS34();   
						break;    
					case 68: StateS36();   
						break;    
					case 69: StateS38();   
						break;    
					case 70: StateS40();   
						break;    
					case 71: StateS42();   
						break;    
					case 72: StateS44();   
						break;    
					case 73: StateS46();   
						break;    
					case 74: StateS48();   
						break;    
					case 75: StateS50();   
						break;    
					case 76: StateS52();   
						break;    
					case 77: StateS54();   
						break;    
					case 78: StateS56();   
						break;    
					case 79: StateS58();   
						break;    
					case 80: StateS60();   
						break;    
					case 81: StateS62();   
						break;    
					case 82: StateS64();   
						break;    
					case 83: StateS66();   
						break;    
					case 84: StateS68();   
						break;    
					case 85: StateS70();   
						break;    
					case 86: StateS72();   
						break;    
					case 87: StateS74();   
						break;    
					case 88: StateS76();   
						break;    
					case 89: StateS78();   
						break;    
					case 90: StateS80();   
						break;    
					case 91: StateS82();   
						break;    
					case 92: StateS84();   
						break;    
					case 93: StateS86();   
						break;    
					case 94: StateS88();   
						break;    
					case 95: StateS90();   
						break;    
					case 96: StateS92();   
						break;    
					case 97: StateS94();   
						break;    
					case 98: StateS96();   
						break;    
					case 99: StateS98();   
						break;    
					case 100: StateS100();   
						break;    
				}
			}                               

			if(failed)
			{
			    StringBuilder errMsg = new StringBuilder();
			    
			    errMsg.AppendFormat("Conformance error in state {0}. ", states[currentState]);

                if (nonAcceptingEnd)
                {
                    errMsg.AppendFormat("Non-accepting end state.");
                }
                else if (Manager.BoundReached)
                {
                    errMsg.AppendFormat("Exploration bound reached in non-accepting state.");
                }
                else
                {
                    errMsg.AppendFormat("Observed action queue is incorrect. ");
                    errMsg.AppendFormat("Actual action: {0}. ", OfflineObservation.DumpQueues());
                    errMsg.AppendFormat("Expected action: {0}", OfflineObservation.DumpPatterns());
                    
                    Manager.DumpFailedTransitions();
                }
                Manager.LogConformanceError(errMsg.ToString());
			}
            else
	        {
                testSite.Assert.Pass("The test passed.");
	        }
        }    

		#region StateS0
		
		void StateS0()
		{		
			Manager.LogState("S0");

			ControllablesS0();
		}	


		#region ControllableTransitions
		
		void StateS0Controllable0()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Past) -> S1");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 1;
				Manager.LogTransition("S0", "S1", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable1()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Today) -> S3");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 2;
				Manager.LogTransition("S0", "S3", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable2()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Future) -> S5");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 3;
				Manager.LogTransition("S0", "S5", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Negative,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable3()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Past) -> S7");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 4;
				Manager.LogTransition("S0", "S7", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable4()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Today) -> S9");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 5;
				Manager.LogTransition("S0", "S9", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable5()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Future) -> S11");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 6;
				Manager.LogTransition("S0", "S11", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MinValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable6()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Past) -> S13");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 7;
				Manager.LogTransition("S0", "S13", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable7()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Today) -> S15");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 8;
				Manager.LogTransition("S0", "S15", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable8()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Future) -> S17");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 9;
				Manager.LogTransition("S0", "S17", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,MaxValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable9()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Past) -> S19");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 10;
				Manager.LogTransition("S0", "S19", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable10()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Today) -> S21");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 11;
				Manager.LogTransition("S0", "S21", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable11()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Future) -> S23");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 12;
				Manager.LogTransition("S0", "S23", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Negative,Existing,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable12()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Past) -> S25");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 13;
				Manager.LogTransition("S0", "S25", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable13()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Today) -> S27");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 14;
				Manager.LogTransition("S0", "S27", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable14()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Future) -> S29");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 15;
				Manager.LogTransition("S0", "S29", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Negative,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable15()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Past) -> S31");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 16;
				Manager.LogTransition("S0", "S31", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable16()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Today) -> S33");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 17;
				Manager.LogTransition("S0", "S33", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable17()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Future) -> S35");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 18;
				Manager.LogTransition("S0", "S35", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MinValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable18()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Past) -> S37");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 19;
				Manager.LogTransition("S0", "S37", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable19()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Today) -> S39");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 20;
				Manager.LogTransition("S0", "S39", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable20()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Future) -> S41");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 21;
				Manager.LogTransition("S0", "S41", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,MaxValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable21()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Past) -> S43");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 22;
				Manager.LogTransition("S0", "S43", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable22()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Today) -> S45");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 23;
				Manager.LogTransition("S0", "S45", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable23()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Future) -> S47");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MinValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 24;
				Manager.LogTransition("S0", "S47", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MinValue,Existing,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable24()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Past) -> S49");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 25;
				Manager.LogTransition("S0", "S49", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable25()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Today) -> S51");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 26;
				Manager.LogTransition("S0", "S51", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable26()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Future) -> S53");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 27;
				Manager.LogTransition("S0", "S53", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Negative,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable27()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Past) -> S55");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 28;
				Manager.LogTransition("S0", "S55", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable28()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Today) -> S57");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 29;
				Manager.LogTransition("S0", "S57", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable29()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Future) -> S59");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 30;
				Manager.LogTransition("S0", "S59", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MinValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable30()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Past) -> S61");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 31;
				Manager.LogTransition("S0", "S61", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable31()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Today) -> S63");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 32;
				Manager.LogTransition("S0", "S63", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable32()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Future) -> S65");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 33;
				Manager.LogTransition("S0", "S65", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,MaxValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable33()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Past) -> S67");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 34;
				Manager.LogTransition("S0", "S67", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable34()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Today) -> S69");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 35;
				Manager.LogTransition("S0", "S69", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable35()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Future) -> S71");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.MaxValue, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 36;
				Manager.LogTransition("S0", "S71", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,MaxValue,Existing,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable36()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Past) -> S73");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 37;
				Manager.LogTransition("S0", "S73", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable37()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Today) -> S75");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 38;
				Manager.LogTransition("S0", "S75", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable38()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Future) -> S77");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 39;
				Manager.LogTransition("S0", "S77", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Negative,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable39()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Past) -> S79");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 40;
				Manager.LogTransition("S0", "S79", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable40()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Today) -> S81");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 41;
				Manager.LogTransition("S0", "S81", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable41()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Future) -> S83");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MinValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 42;
				Manager.LogTransition("S0", "S83", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MinValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable42()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Past) -> S85");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 43;
				Manager.LogTransition("S0", "S85", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable43()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Today) -> S87");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 44;
				Manager.LogTransition("S0", "S87", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable44()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Future) -> S89");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.MaxValue, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 45;
				Manager.LogTransition("S0", "S89", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,MaxValue,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable45()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Past) -> S91");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 46;
				Manager.LogTransition("S0", "S91", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable46()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Today) -> S93");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 47;
				Manager.LogTransition("S0", "S93", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Today)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable47()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Future) -> S95");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.DecimalType.Existing, InputTypes.DecimalType.Existing, InputTypes.DateTimeType.Future);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 48;
				Manager.LogTransition("S0", "S95", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,NotSpecified,Existing,Existing,Future)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable48()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,Existing,Negative,Negative,Past) -> S97");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.Existing, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Past);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 49;
				Manager.LogTransition("S0", "S97", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,Existing,Negative,Negative,Past)");
			}
			else
				finished = failed = true;
		}
		
		void StateS0Controllable49()
		{
			object[] outputs = null;
			
			Manager.BeginTransaction("S0 -> call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,Existing,Negative,Negative,Today) -> S99");


			try
			{
				ReturnTypes.ExceptionType arg0 =
							
					icatalogwebserviceadapterInstance.SavePricingRule(InputTypes.ChangeType.Add, InputTypes.IdType.Existing, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.RelatedItemIdType.NotSpecified, InputTypes.StringType.Null, InputTypes.RelatedItemIdType.Existing, InputTypes.DecimalType.Negative, InputTypes.DecimalType.Negative, InputTypes.DateTimeType.Today);
					
				outputs = new object[] {arg0};
				Manager.ObservationHandler.LogReturn(actions[0] as MethodBase, outputs);
			}
			catch(Exception e)
			{
				Manager.ObservationHandler.LogThrow(actions[0] as MethodBase, e);
			}

			if(Manager.EndTransaction())
			{
				currentState = 50;
				Manager.LogTransition("S0", "S99", "call SavePricingRule(Add,Existing,NotSpecified,NotSpecified,NotSpecified,Null,Existing,Negative,Negative,Today)");
			}
			else
				finished = failed = true;
		}
		

		void ControllablesS0()
		{
			int choice = Manager.ChooseStep(50);
			if (Manager.BoundReached)
			{
				finished = true;
				failed = false;							
				return;
			}
			switch (choice)
			{
				case 0: StateS0Controllable0();
					break;
				case 1: StateS0Controllable1();
					break;
				case 2: StateS0Controllable2();
					break;
				case 3: StateS0Controllable3();
					break;
				case 4: StateS0Controllable4();
					break;
				case 5: StateS0Controllable5();
					break;
				case 6: StateS0Controllable6();
					break;
				case 7: StateS0Controllable7();
					break;
				case 8: StateS0Controllable8();
					break;
				case 9: StateS0Controllable9();
					break;
				case 10: StateS0Controllable10();
					break;
				case 11: StateS0Controllable11();
					break;
				case 12: StateS0Controllable12();
					break;
				case 13: StateS0Controllable13();
					break;
				case 14: StateS0Controllable14();
					break;
				case 15: StateS0Controllable15();
					break;
				case 16: StateS0Controllable16();
					break;
				case 17: StateS0Controllable17();
					break;
				case 18: StateS0Controllable18();
					break;
				case 19: StateS0Controllable19();
					break;
				case 20: StateS0Controllable20();
					break;
				case 21: StateS0Controllable21();
					break;
				case 22: StateS0Controllable22();
					break;
				case 23: StateS0Controllable23();
					break;
				case 24: StateS0Controllable24();
					break;
				case 25: StateS0Controllable25();
					break;
				case 26: StateS0Controllable26();
					break;
				case 27: StateS0Controllable27();
					break;
				case 28: StateS0Controllable28();
					break;
				case 29: StateS0Controllable29();
					break;
				case 30: StateS0Controllable30();
					break;
				case 31: StateS0Controllable31();
					break;
				case 32: StateS0Controllable32();
					break;
				case 33: StateS0Controllable33();
					break;
				case 34: StateS0Controllable34();
					break;
				case 35: StateS0Controllable35();
					break;
				case 36: StateS0Controllable36();
					break;
				case 37: StateS0Controllable37();
					break;
				case 38: StateS0Controllable38();
					break;
				case 39: StateS0Controllable39();
					break;
				case 40: StateS0Controllable40();
					break;
				case 41: StateS0Controllable41();
					break;
				case 42: StateS0Controllable42();
					break;
				case 43: StateS0Controllable43();
					break;
				case 44: StateS0Controllable44();
					break;
				case 45: StateS0Controllable45();
					break;
				case 46: StateS0Controllable46();
					break;
				case 47: StateS0Controllable47();
					break;
				case 48: StateS0Controllable48();
					break;
				case 49: StateS0Controllable49();
					break;
			}
		}
		
		#endregion


		#endregion

		#region StateS1
		
		void StateS1()
		{		
			Manager.LogState("S1");

			bool observed = ObservablesS1();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS1Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S1 -> return SavePricingRule/ArgumentException -> S2");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 51;
	
				Manager.LogTransition("S1", "S2", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS1()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS1Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS1Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS3
		
		void StateS3()
		{		
			Manager.LogState("S3");

			bool observed = ObservablesS3();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS3Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S3 -> return SavePricingRule/ArgumentException -> S4");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 52;
	
				Manager.LogTransition("S3", "S4", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS3()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS3Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS3Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS5
		
		void StateS5()
		{		
			Manager.LogState("S5");

			bool observed = ObservablesS5();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS5Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S5 -> return SavePricingRule/ArgumentException -> S6");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 53;
	
				Manager.LogTransition("S5", "S6", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS5()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS5Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS5Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS7
		
		void StateS7()
		{		
			Manager.LogState("S7");

			bool observed = ObservablesS7();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS7Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S7 -> return SavePricingRule/ArgumentException -> S8");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 54;
	
				Manager.LogTransition("S7", "S8", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS7()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS7Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS7Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS9
		
		void StateS9()
		{		
			Manager.LogState("S9");

			bool observed = ObservablesS9();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS9Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S9 -> return SavePricingRule/ArgumentException -> S10");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 55;
	
				Manager.LogTransition("S9", "S10", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS9()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS9Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS9Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS11
		
		void StateS11()
		{		
			Manager.LogState("S11");

			bool observed = ObservablesS11();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS11Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S11 -> return SavePricingRule/ArgumentException -> S12");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 56;
	
				Manager.LogTransition("S11", "S12", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS11()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS11Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS11Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS13
		
		void StateS13()
		{		
			Manager.LogState("S13");

			bool observed = ObservablesS13();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS13Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S13 -> return SavePricingRule/ArgumentException -> S14");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 57;
	
				Manager.LogTransition("S13", "S14", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS13()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS13Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS13Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS15
		
		void StateS15()
		{		
			Manager.LogState("S15");

			bool observed = ObservablesS15();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS15Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S15 -> return SavePricingRule/ArgumentException -> S16");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 58;
	
				Manager.LogTransition("S15", "S16", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS15()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS15Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS15Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS17
		
		void StateS17()
		{		
			Manager.LogState("S17");

			bool observed = ObservablesS17();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS17Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S17 -> return SavePricingRule/ArgumentException -> S18");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 59;
	
				Manager.LogTransition("S17", "S18", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS17()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS17Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS17Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS19
		
		void StateS19()
		{		
			Manager.LogState("S19");

			bool observed = ObservablesS19();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS19Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S19 -> return SavePricingRule/ArgumentException -> S20");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 60;
	
				Manager.LogTransition("S19", "S20", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS19()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS19Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS19Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS21
		
		void StateS21()
		{		
			Manager.LogState("S21");

			bool observed = ObservablesS21();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS21Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S21 -> return SavePricingRule/ArgumentException -> S22");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 61;
	
				Manager.LogTransition("S21", "S22", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS21()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS21Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS21Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS23
		
		void StateS23()
		{		
			Manager.LogState("S23");

			bool observed = ObservablesS23();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS23Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S23 -> return SavePricingRule/ArgumentException -> S24");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 62;
	
				Manager.LogTransition("S23", "S24", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS23()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS23Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS23Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS25
		
		void StateS25()
		{		
			Manager.LogState("S25");

			bool observed = ObservablesS25();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS25Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S25 -> return SavePricingRule/ArgumentException -> S26");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 63;
	
				Manager.LogTransition("S25", "S26", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS25()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS25Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS25Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS27
		
		void StateS27()
		{		
			Manager.LogState("S27");

			bool observed = ObservablesS27();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS27Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S27 -> return SavePricingRule/ArgumentException -> S28");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 64;
	
				Manager.LogTransition("S27", "S28", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS27()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS27Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS27Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS29
		
		void StateS29()
		{		
			Manager.LogState("S29");

			bool observed = ObservablesS29();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS29Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S29 -> return SavePricingRule/ArgumentException -> S30");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 65;
	
				Manager.LogTransition("S29", "S30", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS29()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS29Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS29Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS31
		
		void StateS31()
		{		
			Manager.LogState("S31");

			bool observed = ObservablesS31();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS31Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S31 -> return SavePricingRule/ArgumentException -> S32");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 66;
	
				Manager.LogTransition("S31", "S32", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS31()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS31Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS31Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS33
		
		void StateS33()
		{		
			Manager.LogState("S33");

			bool observed = ObservablesS33();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS33Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S33 -> return SavePricingRule/ArgumentException -> S34");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 67;
	
				Manager.LogTransition("S33", "S34", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS33()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS33Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS33Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS35
		
		void StateS35()
		{		
			Manager.LogState("S35");

			bool observed = ObservablesS35();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS35Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S35 -> return SavePricingRule/ArgumentException -> S36");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 68;
	
				Manager.LogTransition("S35", "S36", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS35()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS35Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS35Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS37
		
		void StateS37()
		{		
			Manager.LogState("S37");

			bool observed = ObservablesS37();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS37Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S37 -> return SavePricingRule/ArgumentException -> S38");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 69;
	
				Manager.LogTransition("S37", "S38", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS37()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS37Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS37Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS39
		
		void StateS39()
		{		
			Manager.LogState("S39");

			bool observed = ObservablesS39();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS39Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S39 -> return SavePricingRule/ArgumentException -> S40");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 70;
	
				Manager.LogTransition("S39", "S40", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS39()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS39Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS39Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS41
		
		void StateS41()
		{		
			Manager.LogState("S41");

			bool observed = ObservablesS41();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS41Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S41 -> return SavePricingRule/ArgumentException -> S42");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 71;
	
				Manager.LogTransition("S41", "S42", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS41()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS41Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS41Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS43
		
		void StateS43()
		{		
			Manager.LogState("S43");

			bool observed = ObservablesS43();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS43Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S43 -> return SavePricingRule/ArgumentException -> S44");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 72;
	
				Manager.LogTransition("S43", "S44", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS43()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS43Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS43Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS45
		
		void StateS45()
		{		
			Manager.LogState("S45");

			bool observed = ObservablesS45();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS45Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S45 -> return SavePricingRule/ArgumentException -> S46");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 73;
	
				Manager.LogTransition("S45", "S46", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS45()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS45Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS45Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS47
		
		void StateS47()
		{		
			Manager.LogState("S47");

			bool observed = ObservablesS47();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS47Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S47 -> return SavePricingRule/ArgumentException -> S48");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 74;
	
				Manager.LogTransition("S47", "S48", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS47()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS47Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS47Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS49
		
		void StateS49()
		{		
			Manager.LogState("S49");

			bool observed = ObservablesS49();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS49Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S49 -> return SavePricingRule/ArgumentException -> S50");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 75;
	
				Manager.LogTransition("S49", "S50", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS49()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS49Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS49Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS51
		
		void StateS51()
		{		
			Manager.LogState("S51");

			bool observed = ObservablesS51();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS51Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S51 -> return SavePricingRule/ArgumentException -> S52");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 76;
	
				Manager.LogTransition("S51", "S52", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS51()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS51Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS51Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS53
		
		void StateS53()
		{		
			Manager.LogState("S53");

			bool observed = ObservablesS53();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS53Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S53 -> return SavePricingRule/ArgumentException -> S54");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 77;
	
				Manager.LogTransition("S53", "S54", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS53()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS53Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS53Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS55
		
		void StateS55()
		{		
			Manager.LogState("S55");

			bool observed = ObservablesS55();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS55Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S55 -> return SavePricingRule/ArgumentException -> S56");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 78;
	
				Manager.LogTransition("S55", "S56", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS55()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS55Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS55Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS57
		
		void StateS57()
		{		
			Manager.LogState("S57");

			bool observed = ObservablesS57();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS57Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S57 -> return SavePricingRule/ArgumentException -> S58");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 79;
	
				Manager.LogTransition("S57", "S58", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS57()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS57Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS57Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS59
		
		void StateS59()
		{		
			Manager.LogState("S59");

			bool observed = ObservablesS59();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS59Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S59 -> return SavePricingRule/ArgumentException -> S60");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 80;
	
				Manager.LogTransition("S59", "S60", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS59()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS59Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS59Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS61
		
		void StateS61()
		{		
			Manager.LogState("S61");

			bool observed = ObservablesS61();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS61Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S61 -> return SavePricingRule/ArgumentException -> S62");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 81;
	
				Manager.LogTransition("S61", "S62", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS61()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS61Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS61Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS63
		
		void StateS63()
		{		
			Manager.LogState("S63");

			bool observed = ObservablesS63();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS63Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S63 -> return SavePricingRule/ArgumentException -> S64");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 82;
	
				Manager.LogTransition("S63", "S64", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS63()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS63Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS63Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS65
		
		void StateS65()
		{		
			Manager.LogState("S65");

			bool observed = ObservablesS65();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS65Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S65 -> return SavePricingRule/ArgumentException -> S66");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 83;
	
				Manager.LogTransition("S65", "S66", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS65()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS65Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS65Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS67
		
		void StateS67()
		{		
			Manager.LogState("S67");

			bool observed = ObservablesS67();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS67Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S67 -> return SavePricingRule/ArgumentException -> S68");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 84;
	
				Manager.LogTransition("S67", "S68", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS67()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS67Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS67Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS69
		
		void StateS69()
		{		
			Manager.LogState("S69");

			bool observed = ObservablesS69();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS69Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S69 -> return SavePricingRule/ArgumentException -> S70");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 85;
	
				Manager.LogTransition("S69", "S70", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS69()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS69Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS69Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS71
		
		void StateS71()
		{		
			Manager.LogState("S71");

			bool observed = ObservablesS71();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS71Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S71 -> return SavePricingRule/ArgumentException -> S72");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 86;
	
				Manager.LogTransition("S71", "S72", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS71()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS71Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS71Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS73
		
		void StateS73()
		{		
			Manager.LogState("S73");

			bool observed = ObservablesS73();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS73Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S73 -> return SavePricingRule/ArgumentException -> S74");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 87;
	
				Manager.LogTransition("S73", "S74", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS73()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS73Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS73Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS75
		
		void StateS75()
		{		
			Manager.LogState("S75");

			bool observed = ObservablesS75();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS75Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S75 -> return SavePricingRule/ArgumentException -> S76");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 88;
	
				Manager.LogTransition("S75", "S76", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS75()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS75Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS75Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS77
		
		void StateS77()
		{		
			Manager.LogState("S77");

			bool observed = ObservablesS77();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS77Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S77 -> return SavePricingRule/ArgumentException -> S78");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 89;
	
				Manager.LogTransition("S77", "S78", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS77()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS77Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS77Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS79
		
		void StateS79()
		{		
			Manager.LogState("S79");

			bool observed = ObservablesS79();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS79Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S79 -> return SavePricingRule/ArgumentException -> S80");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 90;
	
				Manager.LogTransition("S79", "S80", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS79()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS79Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS79Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS81
		
		void StateS81()
		{		
			Manager.LogState("S81");

			bool observed = ObservablesS81();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS81Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S81 -> return SavePricingRule/ArgumentException -> S82");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 91;
	
				Manager.LogTransition("S81", "S82", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS81()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS81Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS81Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS83
		
		void StateS83()
		{		
			Manager.LogState("S83");

			bool observed = ObservablesS83();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS83Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S83 -> return SavePricingRule/ArgumentException -> S84");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 92;
	
				Manager.LogTransition("S83", "S84", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS83()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(ObservationKind.Return, 
				    actions[0] as MethodBase, 
					StateS83Pattern0, 
					"return SavePricingRule/ArgumentException")					
                :
                new ObservationPattern(actions[0] as EventInfo, 
					StateS83Pattern0, 
					"return SavePricingRule/ArgumentException")
			);
		}			
		
		#endregion



		#endregion

		#region StateS85
		
		void StateS85()
		{		
			Manager.LogState("S85");

			bool observed = ObservablesS85();
			
			finished = failed = !observed;
		}	

		#region ObservableTransition
		
		bool StateS85Pattern0(OfflineObservation observation)
		{
			Manager.BeginTransaction("S85 -> return SavePricingRule/ArgumentException -> S86");

			UntypedObservation uObs = (UntypedObservation) observation;                                    
			Manager.Assert((ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException), "(ReturnTypes.ExceptionType)uObs.Arguments[0] == (ReturnTypes.ExceptionType)(ReturnTypes.ExceptionType.ArgumentException)");


			if(Manager.EndTransaction())
			{
				currentState = 93;
	
				Manager.LogTransition("S85", "S86", "return SavePricingRule/ArgumentException");
				
				return true;
			}
			else
				return false;
		}
	
		bool ObservablesS85()
		{
						
			
			return OfflineObservation.Observe(QuiescenceTimeout,
	
				actions[0] is MethodBase?				
				new ObservationPattern(Observation