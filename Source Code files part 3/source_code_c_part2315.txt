            while (index < NV_MAX_OVERLAY_SURFACES) {
                       if ((DWORD)psurf == pDriverData->dwOverlaySurfaceLCL[index]) {
                           pDriverData->dwOverlaySurfaceLCL[index] = 0;
                           if (pDriverData->dwOverlaySurfaces > 0)
                               pDriverData->dwOverlaySurfaces--;
                           if (pDriverData->dwOverlaySurfaces == 0) {
                               pDriverData->dwOverlayOwner = 0;
                               pDriverData->extra422OverlayOffset[0] = 0;
                               pDriverData->extra422OverlayOffset[1] = 0;
                           }
                       }
                       index++;
                   }
               }

               if ((psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                   ((psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0)) {
                   if (psurf_gbl->fpVidMem > 0) {
                       if (psurf_gbl->fpVidMem + psurf_gbl->dwReserved1 - pDriverData->BaseAddress ==
                           pDriverData->extra422OverlayOffset[0]) {
                           pDriverData->extra422OverlayOffset[0] = 0;
                           pDriverData->extra422OverlayOffset[1] = 0;
                       }
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   if ((pDriverData->fNvActiveFloatingContexts) &&
                       ((psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) ||
                        (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUNV))) {

                       if (npDev == NULL) {  /* Mode switches might occur without warning */
                           lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       DestroyFloating422Context32(psurf);
                   }

                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
               }
               psurf_gbl->dwReserved1 = 0;
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;
            case FOURCC_YV12:
            case FOURCC_420i:
               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                   while (index < NV_MAX_OVERLAY_SURFACES) {
                       if ((DWORD)psurf == pDriverData->dwOverlaySurfaceLCL[index]) {
                           pDriverData->dwOverlaySurfaceLCL[index] = 0;
                           if (pDriverData->dwOverlaySurfaces > 0)
                               pDriverData->dwOverlaySurfaces--;
                           if (pDriverData->dwOverlaySurfaces == 0) {
                               pDriverData->dwOverlayOwner = 0;
                           }
                       }
                       index++;
                   }
               }

               if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                   (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                   if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]) {

                       if (pDriverData->NvYUY2Surface0Mem > 0) {
                           NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                           //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                           pDriverData->NvYUY2Surface0Mem = 0;
                           if (pDriverData->DDrawVideoSurfaceCount > 0)
                               pDriverData->DDrawVideoSurfaceCount--;
                       }

                       NV_DD_DMA_PUSHER_SYNC();

                       if (npDev == NULL) {  /* Mode switches might occur without warning */
                           lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                           return DDHAL_DRIVER_HANDLED;
                       }

                       /* If AGP memory then send a sync rectangle to make sure we are done with it */
                       if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                           NvNotification *pDmaSyncNotifier =
                               (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                           unsigned long *dmaPusherPutAddress =
                               (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                           unsigned long *dmaPusherBufferBase =
                               (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                           long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                           NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                           long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                           /* Let D3D code know that we have touched NV */
                           pDriverData->TwoDRenderingOccurred = 1;

                           // MUST wait for any pending notification to prevent possible loss of notification serialization
                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                           while (freeCount < 4)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
                           freeCount -= 4;

                           pDmaSyncNotifier->status = NV_IN_PROGRESS;

                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                           dmaPusherPutAddress[1] = 0;
                           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                           dmaPusherPutAddress[3] = 0;

                           dmaPusherPutAddress += 4;

                           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
                       }

                       if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                            pDriverData->BaseAddress) || /* If system memory */
                           (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                           (unsigned long)pDriverData->VideoHeapEnd)) {
                           NvNotification *pDmaSyncNotifier =
                               (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                           unsigned long *dmaPusherPutAddress =
                               (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                           unsigned long *dmaPusherBufferBase =
                               (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                           long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                           NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                           long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                           /* Let D3D code know that we have touched NV */
                           pDriverData->TwoDRenderingOccurred = 1;

                           // MUST wait for any pending notification to prevent possible loss of notification serialization
                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                           while (freeCount < 28)
                               NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                           freeCount -= 28;

                           pDriverData->dDrawSpareSubchannelObject = 0;

                           pDmaSyncNotifier->status = NV_IN_PROGRESS;

                           /* Trash spare subchannel */
                           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                           dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                           dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                           dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                               MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                           dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                           dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                           dmaPusherPutAddress[25] = 0;
                           dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                               RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                           dmaPusherPutAddress[27] = 0;

                           dmaPusherPutAddress += 28;

                           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                           /* Force write combine buffer to flush */
                           pDriverData->NvDmaPusherBufferEnd[0] = 0;
                           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                           _outp (0x3d0,0);

                           pDriverData->dwDmaPusherFreeCount = freeCount;

                           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                           while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                           NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                    NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                       }

                        /* If in AGP memory then deallocate it from there */
                       if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                           DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem);
                       } else {
                           if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                pDriverData->BaseAddress) || /* If system memory */
                               (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                               (unsigned long)pDriverData->VideoHeapEnd)) {
                               GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                               GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                           } else {
                               NVHEAP_FREE (psurf_gbl->fpVidMem);
                               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       }

                       pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                       pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;

                   } else {
                       if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1]) {
                           pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                           if (pDriverData->NvYUY2Surface1Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface1Mem);
                               pDriverData->NvYUY2Surface1Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       } else if (psurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2]) {
                           pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                           if (pDriverData->NvYUY2Surface2Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface2Mem);
                               pDriverData->NvYUY2Surface2Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       } else {
                           if (pDriverData->NvYUY2Surface3Mem > 0) {
                               NVHEAP_FREE (pDriverData->NvYUY2Surface3Mem);
                               //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface3Mem);
                               pDriverData->NvYUY2Surface3Mem = 0;
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                           }
                       }
                   }
                   psurf_gbl->fpVidMem = 0;
               } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                   if (psurf_gbl->fpVidMem > 0) {
                       NVHEAP_FREE (psurf_gbl->fpVidMem);
                       //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
                       psurf_gbl->fpVidMem = 0;
                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                           pDriverData->DDrawVideoSurfaceCount--;
                   }
               } else {
                   hMem = (HGLOBAL)psurf_gbl->dwReserved1;
                   GlobalUnlock(hMem);
                   GlobalFree(hMem);
               }
               psurf_gbl->dwReserved1 = 0;
               lpDestroySurface->ddRVal = DD_OK;
               return DDHAL_DRIVER_HANDLED;
               break;
        }
    } else if ((psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) &&
        (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
#ifndef WINNT
        if (psurf_gbl->fpVidMem > 0) {
#endif
            if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
               (pDriverData->GARTLinearBase > 0)) {

               DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem); // AGP memory
                } else {
               NVHEAP_FREE (psurf_gbl->fpVidMem);
               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
               if (pDriverData->DDrawVideoSurfaceCount > 0)
                   pDriverData->DDrawVideoSurfaceCount--;
            }
            psurf_gbl->fpVidMem = 0;
#ifdef WINNT
            psurf_gbl->lPitch = 0;
#else
        }
#endif
        DPF( "    Offscreen deallocated" );
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
        /*
         * Call the D3D driver to destroy the texture surface.
         */
        nvDestroyTextureSurface(lpDestroySurface, psurf, psurf_gbl);
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
#ifndef WINNT
        if (psurf_gbl->fpVidMem > 0) {
#endif
            if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
               (pDriverData->GARTLinearBase > 0))
               {
               DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem); // AGP memory
                } else {
               NVHEAP_FREE (psurf_gbl->fpVidMem);
               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->fpVidMem);
               if (pDriverData->DDrawVideoSurfaceCount > 0)
                   pDriverData->DDrawVideoSurfaceCount--;
            }
            psurf_gbl->fpVidMem = 0;
#ifdef WINNT
            psurf_gbl->lPitch = 0;
#else
        } else {
            DPF( "    Unspecified Video Memory deallocation not handled");
            return DDHAL_DRIVER_NOTHANDLED;
        }
#endif
        DPF( "    Offscreen deallocated" );
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    } else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DPF( "    System memory deallocated" );
        hMem = (HGLOBAL)psurf_gbl->dwReserved1;
        GlobalUnlock(hMem);
        GlobalFree(hMem);
        psurf_gbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;
}



/*
 * CreateSurface32
 */
DWORD __stdcall CreateSurface32( LPDDHAL_CREATESURFACEDATA lpCreateSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        handled;
    int                         i;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_LCL   *powner;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LONG                        pitch;
    LONG                        adjustedHeight;
    HGLOBAL                     hMem;
    DWORD                       dwBlockSize;
    DWORD                       *fpVidMem;
    HRESULT                     ddrval;
    DWORD                       memType;
    DWORD                       index;
#ifdef DEBUG
    char                        fourCCStr[5];
#endif // DEBUG

    NvSetDriverDataPtr(lpCreateSurface->lpDD);

#if 0 //def WINNT
    /*
     * Under NT, if this is the "first" ddraw surface allocation, move all
     * offscreen DFBs into sys memory to make room for ddraw surfaces.
     */
     if (pDriverData->DDrawVideoSurfaceCount == 0) {
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);
        }
#endif

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        getDisplayDuration();
        if (!ResetNV()) {
            lpCreateSurface->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    /*
     * is a flip in progress?
     */
    {
        HRESULT ddrval = updateFlipStatus(0);
        while (ddrval == DDERR_WASSTILLDRAWING)
        {
            NV_SLEEPFLIP;
            ddrval = updateFlipStatus(0);
        }
    }

    /*
     * NOTES:
     *
     * This callback is invoked once the surface objects have been created.
     * You can:
     *   - compute the size of the block, by returning
     *     DDHAL_PLEASEALLOC_BLOCKSIZE in fpVidMem, and putting the size
     *     in dwBlockSizeX and dwBlockSizeY
     *   - override some fields in the surface structure, like the pitch.
     *     (you must specifiy the pitch if you are computing the size)
     */

    pdrv = lpCreateSurface->lpDD;
    DPF( "in CreateSurface, lpCreateSurface->lpDD=%08lx, lpCreateSurface->lpDDSurfaceDesc = %08lx",
                pdrv, lpCreateSurface->lpDDSurfaceDesc );
    DPF( "lpCreateSurface->lplpSList=%08lx, lpCreateSurface->dwSCnt = %d", lpCreateSurface->lplpSList, lpCreateSurface->dwSCnt );

    /*
     * see if any of these surfaces are FOURCC codes...
     */
    handled = FALSE;

    powner = lpCreateSurface->lplpSList;

    for( i=0;i<(int)lpCreateSurface->dwSCnt;i++ ) {
        psurf = lpCreateSurface->lplpSList[i];
        psurf_gbl = psurf->lpGbl;

        DPF( "psurf=%08lx, psurf->lpGbl=%08lx", psurf, psurf_gbl );
        if (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) {

            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {
                DPF( "  ALPHA_PREMULT surface requested" );

                pitch = psurf_gbl->wWidth *
                        (pDriverData->bi.biBitCount >> 3);
                pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = (pitch * ((DWORD)psurf_gbl->wHeight));
                psurf_gbl->ddpfSurface.dwRGBBitCount = pDriverData->bi.biBitCount;
                psurf_gbl->ddpfSurface.dwRGBAlphaBitMask = 0xFF000000;
                psurf_gbl->ddpfSurface.dwRBitMask = 0x00FF0000;
                psurf_gbl->ddpfSurface.dwGBitMask = 0x0000FF00;
                psurf_gbl->ddpfSurface.dwBBitMask = 0x000000FF;
                psurf_gbl->lPitch = pitch;
                psurf_gbl->fpVidMem = 0;
                psurf_gbl->dwReserved1 = 0;
                handled = TRUE;

                if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                    /*
                     * Notify 16 bit display driver code that Direct Draw is beginning
                     * to use local video memory.
                     */
#ifndef WINNT
                    if (pDriverData->DDrawVideoSurfaceCount == 0) {
                        HDC hdc = GetDC(0);
                        ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                    }
#endif // #ifndef WINNT

                    NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                    //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                    if (psurf_gbl->fpVidMem != 0) {
                        pDriverData->DDrawVideoSurfaceCount++;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                        break;
                    }
                }

                hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                if (!hMem) {
                    DPF( "    System memory ALPHA_PREMULT surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    DPF( "    System memory ALPHA_PREMULT surface allocation succeeded" );
                    psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                    psurf_gbl->dwReserved1 = (DWORD)hMem;
                    psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                }
            }

            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                 DPF( "  FOURCC surface requested" );
                /*
                 * we know the FOURCC code is OK, because we validated it
                 * during CanCreateSurface.   Compute a block size based
                 * on the code, and allocate system memory for it.
                 */
                switch( psurf->lpGbl->ddpfSurface.dwFourCC ) {
                    case FOURCC_RGB0:
                    case FOURCC_RAW8:
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8)
                           pitch = psurf_gbl->wWidth;
                       else
                           pitch = psurf_gbl->wWidth *
                               (pDriverData->bi.biBitCount >> 3);
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       dwBlockSize = (pitch * ((DWORD)psurf_gbl->wHeight));
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_RAW8) {
                           psurf_gbl->ddpfSurface.dwRGBBitCount = 8;
                           psurf_gbl->ddpfSurface.dwRBitMask = 0;
                           psurf_gbl->ddpfSurface.dwGBitMask = 0;
                           psurf_gbl->ddpfSurface.dwBBitMask = 0;
                       } else {
                           psurf_gbl->ddpfSurface.dwRGBBitCount = pDriverData->bi.biBitCount;
                           if (pDriverData->bi.biBitCount == 8) {
                               psurf_gbl->ddpfSurface.dwRBitMask = 0;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0;
                               psurf_gbl->ddpfSurface.dwFlags |= DDPF_PALETTEINDEXED8;
                           } else if (pDriverData->bi.biBitCount == 16) {

                               psurf_gbl->ddpfSurface.dwRBitMask = 0x0000F800;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0x000007E0;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0x0000001F;

                           } else if (pDriverData->bi.biBitCount == 32) {
                               psurf_gbl->ddpfSurface.dwRBitMask = 0x00FF0000;
                               psurf_gbl->ddpfSurface.dwGBitMask = 0x0000FF00;
                               psurf_gbl->ddpfSurface.dwBBitMask = 0x000000FF;
                           }
                       }
                       psurf_gbl->ddpfSurface.dwRGBAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->fpVidMem = 0;
                       psurf_gbl->dwReserved1 = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                           //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (psurf_gbl->fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                               break;
                           }
                       }

                       hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                       if (!hMem) {
                           DPF( "    System memory FOURCC surface allocation failed" );
                           lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                           return DDHAL_DRIVER_HANDLED;
                       } else {
                           DPF( "    System memory FOURCC surface allocation succeeded" );
                           psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                           psurf_gbl->dwReserved1 = (DWORD)hMem;
                           psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                       }
                    break;

                    case FOURCC_IF09:
                    case FOURCC_YVU9:
                    case FOURCC_IV32:
                    case FOURCC_IV31:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /* First allocate enough video memory for YUY2 overlay pixel area */
                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       /* pad with an extra scanline */
                       dwBlockSize = (pitch * (DWORD)psurf_gbl->wHeight);
                       /* now allocate enough video memory for the Indeo part of the surface */
                       pitch = psurf_gbl->wWidth;
                       /* allow extra room for block skip bits between Indeo portion of surface and YUY2 portion */
                       dwBlockSize += ((pitch * ((DWORD)psurf_gbl->wHeight * 10L)) >> 3);
                       /* Force block to be properly aligned */
                       dwBlockSize = (dwBlockSize + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half YUY2 portion of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Double actual amount of YUY2 video memory allocated for this surface */
                           pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                           pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           /* pad with an extra scanline */
                           dwBlockSize += (pitch * (DWORD)psurf_gbl->wHeight);
                           /* reset pitch to actual Indeo surface pitch */
                           pitch = psurf_gbl->wWidth;
                       } else
                           psurf_gbl->dwReserved1 = 0;

                       psurf_gbl->ddpfSurface.dwYUVBitCount = 9;
                       psurf_gbl->ddpfSurface.dwYBitMask = 0;
                       psurf_gbl->ddpfSurface.dwUBitMask = 0;
                       psurf_gbl->ddpfSurface.dwVBitMask = 0;
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->fpVidMem = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
                           //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (psurf_gbl->fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   index = 0;
                                   while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                          (index < NV_MAX_OVERLAY_SURFACES))
                                          index++;
                                   pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                                   pDriverData->dwOverlayOwner = (DWORD)powner;
                                   pDriverData->dwOverlaySurfaces++;
                               }

                               break;
                           } else {
                               /* We can't support overlay surfaces in system memory */
                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       }

                       hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                       if (!hMem) {
                           DPF( "    System memory FOURCC surface allocation failed" );
                           lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                           return DDHAL_DRIVER_HANDLED;
                       } else {
                           DPF( "    System memory FOURCC surface allocation succeeded" );
                           psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                           psurf_gbl->dwReserved1 = (DWORD)hMem;
                           psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;

                    case FOURCC_YUY2:
                    case FOURCC_YUNV:
                    case FOURCC_UYVY:
                    case FOURCC_UYNV:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /* First try video memory */
                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                       /* pad with an extra scanline */
                       dwBlockSize = (pitch * (DWORD)psurf_gbl->wHeight);
                       psurf_gbl->ddpfSurface.dwYUVBitCount = 16;
                       if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2) {
                           psurf_gbl->ddpfSurface.dwYBitMask = 0x00FF00FF;
                           psurf_gbl->ddpfSurface.dwUBitMask = 0x0000FF00;
                           psurf_gbl->ddpfSurface.dwVBitMask = 0xFF000000;
                       } else {
                           psurf_gbl->ddpfSurface.dwYBitMask = 0xFF00FF00;
                           psurf_gbl->ddpfSurface.dwUBitMask = 0x000000FF;
                           psurf_gbl->ddpfSurface.dwVBitMask = 0x00FF0000;
                       }
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       psurf_gbl->lPitch = pitch;
                       psurf_gbl->dwReserved1 = 0;
                       psurf_gbl->fpVidMem = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       /*
                        * Notify 16 bit display driver code that Direct Draw is beginning
                        * to use local video memory.
                        */
#ifndef WINNT
                       if (pDriverData->DDrawVideoSurfaceCount == 0) {
                           HDC hdc = GetDC(0);
                           ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                       }
#endif // #ifndef WINNT

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Tripple actual amount of video memory allocated for this surface only */
                           if (pDriverData->extra422OverlayOffset[0] == 0)
                               dwBlockSize *= 3;
                       }

                       NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_OVERLAY);
                       //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                       if (psurf_gbl->fpVidMem != 0) {
                           pDriverData->DDrawVideoSurfaceCount++;
                           psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                           psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                           if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                               (pDriverData->TotalVRAM >> 20 > 4) &&
                               (pDriverData->extra422OverlayOffset[0] == 0)) {
                               pDriverData->extra422OverlayOffset[0] =
                                   psurf_gbl->fpVidMem - pDriverData->BaseAddress;
                               pDriverData->extra422OverlayOffset[0] += psurf_gbl->dwReserved1;
                               pDriverData->extra422OverlayOffset[1] =
                                   pDriverData->extra422OverlayOffset[0] + psurf_gbl->dwReserved1;
                           }
                       } else {
                           /* We can't support overlay surfaces in system memory */
                           if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           }

                           hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);

                           if (!hMem) {
                               DPF( "    System memory FOURCC surface allocation failed" );
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           } else {

                               DPF( "    System memory FOURCC surface allocation succeeded" );
                               psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                               psurf_gbl->dwReserved1 = (DWORD)hMem;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

                               CreateFloating422Context32(psurf, dwBlockSize);
                           }
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;

                    case FOURCC_YV12:
                    case FOURCC_420i:

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                           (pDriverData->dwOverlaySurfaces > 0)) {
                           if (pDriverData->OverlayRelaxOwnerCheck)
                                pDriverData->dwOverlayOwner = (DWORD)powner;
                           if ((pDriverData->dwOverlayOwner != (DWORD)powner) ||
                               (pDriverData->dwOverlaySurfaces + 1 >= NV_MAX_OVERLAY_SURFACES)) {
                               lpCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }

                       /*
                        * Always split allocation of YV12/420i overlay surfaces.
                        *   Allocate the YV12/420i portion in AGP memory on AGP systems, local video memory on PCI systems.
                        *   Fall back to system memory only if preferred allocation fails.
                        *   Allocate additional YUY2 surfaces in local video memory for the video scaler to use
                        */
                       psurf_gbl->ddpfSurface.dwYUVBitCount = 12;
                       psurf_gbl->ddpfSurface.dwYBitMask = 0;
                       psurf_gbl->ddpfSurface.dwUBitMask = 0;
                       psurf_gbl->ddpfSurface.dwVBitMask = 0;
                       psurf_gbl->ddpfSurface.dwYUVAlphaBitMask = 0;

                       psurf_gbl->fpVidMem = 0;
                       psurf_gbl->dwReserved1 = 0;
                       psurf->ddsCaps.dwCaps |= DDSCAPS_HWCODEC;
                       handled = TRUE;

                       pitch = ((psurf_gbl->wWidth + 1) & 0xFFFE) << 1;
                       pitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       adjustedHeight = (DWORD)((psurf_gbl->wHeight + 1) & ~1);

                       dwBlockSize = pitch * adjustedHeight;

                       if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) && (pDriverData->TotalVRAM >> 20 > 4)) {
                           /* Remember offset to 2nd half of surface */
                           psurf_gbl->dwReserved1 = dwBlockSize;
                           /* Double actual amount of video memory allocated for this surface */
                           dwBlockSize <<= 1;
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

                           /*
                            * Notify 16 bit display driver code that Direct Draw is beginning
                            * to use local video memory.
                            */
#ifndef WINNT
                           if (pDriverData->DDrawVideoSurfaceCount == 0) {
                               HDC hdc = GetDC(0);
                               ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                           }
#endif // #ifndef WINNT

                           NVHEAP_ALLOC((unsigned long)fpVidMem, dwBlockSize, TYPE_OVERLAY);
                           //fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                           if (fpVidMem != 0) {
                               pDriverData->DDrawVideoSurfaceCount++;
                               psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
                               if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] == 0)
                                   pDriverData->NvYUY2Surface0Mem = (DWORD)fpVidMem; /* save pointer to YUY2 overlay surface */
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] == 0)
                                   pDriverData->NvYUY2Surface1Mem = (DWORD)fpVidMem;
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] == 0)
                                   pDriverData->NvYUY2Surface2Mem = (DWORD)fpVidMem;
                               else if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] == 0)
                                   pDriverData->NvYUY2Surface3Mem = (DWORD)fpVidMem;
                           } else {
                               /* one or more overlay surfaces could not be allocated, clean up already allocated memory */
                               if (pDriverData->NvYUY2Surface2Mem > 0) {
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface2Mem);
                                   pDriverData->NvYUY2Surface2Mem = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;
                               }

                               if (pDriverData->NvYUY2Surface1Mem > 0) {
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface1Mem);
                                   pDriverData->NvYUY2Surface1Mem = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;
                               }

                               if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] != 0) {
                                   if (pDriverData->NvYUY2Surface0Mem > 0) {
                                       NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                                       //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                                       pDriverData->NvYUY2Surface0Mem = 0;
                                       if (pDriverData->DDrawVideoSurfaceCount > 0)
                                           pDriverData->DDrawVideoSurfaceCount--;
                                   }

                                   if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                        pDriverData->BaseAddress) || /* If system memory */
                                       (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                        (unsigned long)pDriverData->VideoHeapEnd)) {
                                       NvNotification *pDmaSyncNotifier =
                                           (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                                       Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
                                       unsigned long *dmaPusherPutAddress =
                                           (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                                       unsigned long *dmaPusherBufferBase =
                                           (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
                                       long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                                       NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                                       long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

                                       NV_DD_DMA_PUSHER_SYNC();

                                       /* Let D3D code know that we have touched NV */
                                       pDriverData->TwoDRenderingOccurred = 1;

                                       // MUST wait for any pending notification to prevent possible loss of notification serialization
                                       while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                       while (freeCount < 28)
                                           NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                                       freeCount -= 28;

                                       pDriverData->dDrawSpareSubchannelObject = 0;

                                       pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                       /* Trash spare subchannel */
                                       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                       dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                       dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                       dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                           MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                       dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                                       dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                           RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                                       dmaPusherPutAddress[25] = 0;
                                       dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                           RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                                       dmaPusherPutAddress[27] = 0;

                                       dmaPusherPutAddress += 28;

                                       pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                       /* Force write combine buffer to flush */
                                       pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                       _outp (0x3d0,0);

                                       pDriverData->dwDmaPusherFreeCount = freeCount;

                                       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                       while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                                       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                                NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                                   }

                                   /* If in AGP memory then deallocate it from there */
                                   if ((pDriverData->GARTLinearBase > 0) &&
                                       ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >= pDriverData->GARTLinearBase) &&
                                        (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] < (pDriverData->GARTLinearBase + NV_MAX_AGP_MEMORY_LIMIT)))) {
                                             DDHAL32_VidMemFree(pdrv, AGP_HEAP, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                   } else {
                                       if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                            pDriverData->BaseAddress) || /* If system memory */
                                           (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                           (unsigned long)pDriverData->VideoHeapEnd)) {
                                           GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                           GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                       } else {
                                           NVHEAP_FREE (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                           //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
                                           if (pDriverData->DDrawVideoSurfaceCount > 0)
                                               pDriverData->DDrawVideoSurfaceCount--;
                                       }
                                   }

                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                               }

                               pDriverData->dwOverlayOwner = 0;
                               pDriverData->dwOverlaySurfaces = 0;

                               /* We can't support overlay surfaces in system memory */
                               if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       }
#ifdef DEBUG
                       fourCCStr[0] = (char)psurf_gbl->ddpfSurface.dwFourCC & 0xFF;
                       fourCCStr[1] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 8) & 0xFF;
                       fourCCStr[2] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 16) & 0xFF;
                       fourCCStr[3] = (char)(psurf_gbl->ddpfSurface.dwFourCC >> 24) & 0xFF;
                       fourCCStr[4] = 0;
                       DPF( "FOURCC %s allocation: size=%lu bytes", &fourCCStr, dwBlockSize );
#endif // DEBUG
                       /* now allocate enough AGP memory or local video memory for the YV12 part of the surface */
                       pitch = psurf_gbl->wWidth;
                       psurf_gbl->lPitch = pitch;

                       dwBlockSize = ((pitch * (adjustedHeight * 12L)) >> 3);
                       /* Force block to be properly aligned */
                       dwBlockSize = (dwBlockSize + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                       if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] == 0) { /* If this is the first of a complex overlay surface */

                           /*
                            * Allocate enough AGP, video, or system memory for ALL of the surfaces in the
                            * complex surface in a single block
                            */

                           if (lpCreateSurface->dwSCnt > 2)
                               dwBlockSize *= (DWORD)lpCreateSurface->dwSCnt;
                           else /* Assume that 2 of these surfaces will be created */
                               dwBlockSize <<= 1;

                           fpVidMem = 0;

                           memType = 0;

                           if (pDriverData->GARTLinearBase > 0) { /* First attempt to allocate in AGP memory */
                               fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, AGP_HEAP, dwBlockSize, 1);
                               if (fpVidMem != 0) {
                                   memType = DDSCAPS_NONLOCALVIDMEM;
                                   psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                               }
                           } else { /* else try to allocate the surfaces in framebuffer video memory */
                               /*
                                * Notify 16 bit display driver code that Direct Draw is beginning
                                * to use local video memory.
                                */
#ifndef WINNT
                               if (pDriverData->DDrawVideoSurfaceCount == 0) {
                                   HDC hdc = GetDC(0);
                                   ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                               }
#endif // #ifndef WINNT

                               NVHEAP_ALLOC((unsigned long)fpVidMem, dwBlockSize, TYPE_OVERLAY);
                               //fpVidMem = (DWORD *)DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                               if (fpVidMem != 0) {
                                   memType = DDSCAPS_LOCALVIDMEM;
                                   pDriverData->DDrawVideoSurfaceCount++;
                               }
                           }

                           if (!fpVidMem) { /* Finally try system memory */
                               hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                               if (!hMem)
                                   memType = DDSCAPS_SYSTEMMEMORY;
                           }

                           if ((!hMem) && (!fpVidMem)) {
                               DPF( "    System memory FOURCC surface allocation failed" );
                               /* Free video memory just allocated above */
                               NVHEAP_FREE (psurf_gbl->dwReserved1);
                               //DDHAL32_VidMemFree(pdrv, 0, psurf_gbl->dwReserved1);
                               if (pDriverData->DDrawVideoSurfaceCount > 0)
                                   pDriverData->DDrawVideoSurfaceCount--;
                               psurf_gbl->dwReserved1 = 0;
                               lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                               return DDHAL_DRIVER_HANDLED;
                           } else {
                               Nv10ControlDma *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
                               NvNotification *pDmaDmaToMemNotifier =
                                   (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;

                               DPF( "    System memory FOURCC surface allocation succeeded" );

                               if (fpVidMem) {
                                   pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;
                                   psurf_gbl->fpVidMem = (FLATPTR)fpVidMem;
                               } else {
                                   pDriverData->NvFloatingMem2MemFormatMemoryHandle = (DWORD)hMem;
                                   psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                               }

                               NV_DD_DMA_PUSHER_SYNC();

                               /* Let D3D code know that we have touched NV */
                               pDriverData->TwoDRenderingOccurred = 1;

                               if ((memType == DDSCAPS_NONLOCALVIDMEM) || (memType == DDSCAPS_SYSTEMMEMORY)) { /* If system memory */
                                   NvNotification *pDmaSyncNotifier =
                                       (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
                                   unsigned long *dmaPusherPutAddress =
                                       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
                                   unsigned long *dmaPusherBufferBase =
                                       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
                                   unsigned long status;
#ifdef  CACHE_FREECOUNT
                                   long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
                                   NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
                                   long freeCount = 0;
#endif  /* CACHE_FREECOUNT */
                                   /* First disconnect everything */

                                   // MUST wait for any pending notification to prevent possible loss of notification serialization
                                   while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                   while (freeCount < 28)
                                       NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                                   freeCount -= 28;

                                   pDriverData->dDrawSpareSubchannelObject = 0;

                                   pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                   /* Trash spare subchannel */
                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                                   dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                                   dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                                   dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                       RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                                   dmaPusherPutAddress[25] = 0;
                                   dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                       RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                                   dmaPusherPutAddress[27] = 0;

                                   dmaPusherPutAddress += 28;

                                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                   /* Force write combine buffer to flush */
                                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                   _outp (0x3d0,0);

                                   pDriverData->dwDmaPusherFreeCount = freeCount;

                                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                   while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                                   NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                            NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);

                                   /* Now reconnect everything */

                                   pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

                                   status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                                       NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                                                       NV01_CONTEXT_DMA,
                                                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                                       ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                                       (PVOID)psurf_gbl->fpVidMem,
                                                       (dwBlockSize - 1));

                                   if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {
                                       pDmaDmaToMemNotifier->status = NV_STATUS_DONE_OK;
                                   }

                                   while (freeCount < 20)
                                       NvGetDmaBufferFreeCount(npDev, freeCount, 20, dmaPusherPutAddress);
                                   freeCount -= 20;

                                   /* Both buffers must be reconnected due to an bug in NV4 */
                                   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[6] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[8] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[9] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[11] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[13] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[14] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
                                   dmaPusherPutAddress[15] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                                   dmaPusherPutAddress[16] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                                   dmaPusherPutAddress[17] = dDrawSubchannelOffset(NV_DD_SPARE) +
                                       MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000;
                                   dmaPusherPutAddress[18] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                   dmaPusherPutAddress[19] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

                                   dmaPusherPutAddress += 20;

                                   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                                   /* Force write combine buffer to flush */
                                   pDriverData->NvDmaPusherBufferEnd[0] = 0;
                                   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                                   _outp (0x3d0,0);

                                   pDriverData->dwDmaPusherFreeCount = freeCount;

                                   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                                   while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                               } else { /* If video memory */
                                   pDmaDmaToMemNotifier->status = NV_STATUS_DONE_OK;
                               }

                               if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] =
                                       (DWORD)psurf_gbl->fpVidMem;
                               } else {
                                   /* Can't lock down system memory, forget using this technique */
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                                   /* Free video memory just allocated above */
                                   NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                                   //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvYUY2Surface0Mem);
                                   if (pDriverData->DDrawVideoSurfaceCount > 0)
                                       pDriverData->DDrawVideoSurfaceCount--;

                                   if (pDriverData->NvFloatingMem2MemFormatMemoryHandle) {
                                       GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                       GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                                   } else {
                                       /* Free AGP memory just allocated above */
                                       DDHAL32_VidMemFree(pdrv, AGP_HEAP, psurf_gbl->fpVidMem);

                                   }
                                   psurf_gbl->fpVidMem = 0;
                                   lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                                   return DDHAL_DRIVER_HANDLED;
                               }
                           }
                       } else {
                           /* Assign surface address within preallocated and locked video or AGP/system memory block */
                           if (i > 0) {
                               psurf_gbl->fpVidMem =
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] +
                                       (i * dwBlockSize);
                               if (i == 1)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = psurf_gbl->fpVidMem;
                               else if (i == 2)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = psurf_gbl->fpVidMem;
                               else if (i == 3)
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = psurf_gbl->fpVidMem;
                           } else {
                               psurf_gbl->fpVidMem =
                                   pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] +
                                       dwBlockSize;
                               pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = psurf_gbl->fpVidMem;
                           }

                           /* If in AGP memory then set capability flag */
                           if (pDriverData->GARTLinearBase > 0) {
                               if ((psurf_gbl->fpVidMem >= pDriverData->GARTLinearBase) &&
                                   (psurf_gbl->fpVidMem < (pDriverData->GARTLinearBase + NV_MAX_AGP_MEMORY_LIMIT)))
                                   psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                           }
                       }

                       if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                           index = 0;
                           while ((pDriverData->dwOverlaySurfaceLCL[index] != 0) &&
                                  (index < NV_MAX_OVERLAY_SURFACES))
                                  index++;
                           pDriverData->dwOverlaySurfaceLCL[index] = (DWORD) psurf;
                           pDriverData->dwOverlayOwner = (DWORD)powner;
                           pDriverData->dwOverlaySurfaces++;
                       }

                    break;
                }
#ifdef NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                /*
                 * Call the texture surface allocation code in the D3D driver. (D3dtex.c)
                 * If the routine returns FALSE, then the surface creation failed and the
                 * error should be returned immediately.
                 */
                if (!(handled = nvCreateTextureSurface(lpCreateSurface, psurf, psurf_gbl)))
                   return DDHAL_DRIVER_HANDLED;
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {

                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    /*
                     * Allocate z-buffer memory exactly as the surface specifies.
                     * Z-Buffer must match render depth or D3D context creation will fail.
                     */
                    if ( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                         (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) ) {
                       /*
                        * I need to check this here and reject it because a lot of times
                        * CanCreateSurface will be called and the format will not have been
                        * set and then CreateSurface will be called and the format will be
                        * set to something other than the current primary surface bit depth,
                        * which we can't support.
                        */
                       if (psurf_gbl->ddpfSurface.dwZBufferBitDepth != pDriverData->bi.biBitCount) {
                           lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                       pitch = ((psurf_gbl->wWidth <<
                                (psurf_gbl->ddpfSurface.dwZBufferBitDepth >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                    }
                    else
                       pitch = ((psurf_gbl->wWidth <<
                                (pDriverData->bi.biBitCount >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                }
                else {
                    /*
                     * Pad the z-buffer if neccessary to match z-buffer depth to the D3D rendering depth.
                     */
                    if ( (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                         (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) ) {
                       /*
                        * When allocating the z-buffer, we have to make sure that it matches
                        * the rendering surface.  I'm saying that I support 16, 24 and 32 bits
                        * of z-buffer, because applications seem to only understand 16 and 24.
                        * So here's what I'm going to do (this is subject to change).  If the
                        * application is running in 16bpp mode and it requests a 24 or 32 bit
                        * z buffer, they will only get 16 bpp of precision (because that's what
                        * the hardware supports) but we'll go ahead and waste as much memory
                        * as they request (for now anyway).  If the application requests a 16 or 24
                        * bit z-buffer when we are rendering in 32 bpp mode, then they will get
                        * 24 bit z-precision, but we will have to waste the full 32bpp to give
                        * it to them.
                        */
                       if (pDriverData->bi.biBitCount == 16) {
                           if (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 16) {
                               pitch = ((psurf_gbl->wWidth << 1) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else if ((psurf_gbl->ddpfSurface.dwZBufferBitDepth == 24)
                                 || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 32)) {
                               pitch = ((psurf_gbl->wWidth << 2) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else {
                               /* Anything else just won't do. */
                               lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }
                       else if (pDriverData->bi.biBitCount == 32) {
                           if ((psurf_gbl->ddpfSurface.dwZBufferBitDepth == 16)
                            || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 24)
                            || (psurf_gbl->ddpfSurface.dwZBufferBitDepth == 32)) {
                               pitch = ((psurf_gbl->wWidth << 2) +
                                         pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                           }
                           else {
                               /* Anything else just won't do. */
                               lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                               return DDHAL_DRIVER_HANDLED;
                           }
                       }
                       else {
                           /* Anything else just won't do. */
                           lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                           return DDHAL_DRIVER_HANDLED;
                       }
                    }
                    else
                       pitch = ((psurf_gbl->wWidth <<
                                (pDriverData->bi.biBitCount >> 4)) +
                                 pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                }

                psurf_gbl->lPitch = pitch;
                dwBlockSize = pitch * psurf_gbl->wHeight;
                psurf_gbl->dwReserved1 = 0;

                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                NVHEAP_ALLOC_TILED(psurf_gbl->fpVidMem, psurf_gbl->lPitch, psurf_gbl->wHeight, TYPE_DEPTH);
                //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                if (psurf_gbl->fpVidMem != 0) {
                    pDriverData->DDrawVideoSurfaceCount++;
                    DPF( "    Video memory Z buffer surface allocation succeeded" );
                    psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    handled = TRUE;
                } else {
                   DPF( "    Video memory Z buffer surface allocation failed" );
                   lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                   return DDHAL_DRIVER_HANDLED;
                }
#endif // NVD3D
            }
        } else {
            if (psurf->ddsCaps.dwCaps &
               (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

                /* Must allow primary surface access even if not correct pixel depth for 3D */
                /* Fixes Jedi Knight bug */
                if ((psurf->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) &&
                    (!(psurf->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))) {
                    if (pDriverData->bi.biBitCount == 8) {
                        lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_HANDLED;
                    }
                }

                DPF( "    Front buffer granted" );
                pitch = pDriverData->bi.biWidth *
                        (pDriverData->bi.biBitCount >> 3);
                /* Force primary surface alignment to be correct */
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

                /* Must wait for any pending flip to finish so that CurrentVisibleSurface will be valid */
                ddrval = updateFlipStatus(0);
                if (ddrval != DD_OK) {
                    while (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                        ddrval = updateFlipStatus(0);
                    }
                }

                psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                psurf_gbl->fpVidMem = pDriverData->CurrentVisibleSurfaceAddress;
                psurf_gbl->dwReserved1 = 0;
                psurf->dwReserved1 = 0;
                handled = TRUE;
            } else if (psurf->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP)) {
                DPF( "    Back buffer or flip surface granted" );
                pitch = pDriverData->bi.biWidth *
                        (pDriverData->bi.biBitCount >> 3);
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = psurf_gbl->lPitch * pDriverData->bi.biHeight;
                psurf_gbl->dwReserved1 = 0;
                psurf->dwReserved1 = 0;

                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                NVHEAP_ALLOC_TILED(psurf_gbl->fpVidMem, psurf_gbl->lPitch, pDriverData->bi.biHeight, MEM_TYPE_IMAGE_TILED);
                //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                if (psurf_gbl->fpVidMem != 0) {
                    pDriverData->DDrawVideoSurfaceCount++;
                    DPF( "    Backbuffer or flipable video memory surface allocation succeeded" );
                    psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                    handled = TRUE;

#ifdef FORCED_TRIPLE_BUFFER
                    // a flippable double buffered scenario has been granted,
                    // let's try and make it triple buffered
                    if (lpCreateSurface->dwSCnt == 2) {
                        IDirectDraw2 *lpDD_int = (IDirectDraw2 *) psurf->lpSurfMore->lpDD_int;
                        DDSURFACEDESC surfDesc;
                        HRESULT result;

                        if (lpDD_int) {
                            surfDesc = *(lpCreateSurface->lpDDSurfaceDesc);
                            surfDesc.dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;
                            surfDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
                            surfDesc.dwWidth = psurf_gbl->wWidth;
                            surfDesc.dwHeight = psurf_gbl->wHeight;
                            surfDesc.dwBackBufferCount = 0;
                            surfDesc.ddsCaps.dwCaps &= ~(DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_COMPLEX | DDSCAPS_FLIP);
                            result = IDirectDraw2_CreateSurface(lpDD_int, &surfDesc, &(pDriverData->lpBuffer3), NULL);
                            if (result == DD_OK) {
                                LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDriverData->lpBuffer3)->lpLcl;
                                pDriverData->bNeedToAttachBuffer = TRUE;
//                                lpSurfLcl->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
//                                lpSurfLcl->dwFlags |= 0x22; // private flags IMPLICITCREATE and PARTOFPRIMARYCHAIN
                                psurf->dwFlags &= ~0x2;
                            } else {
                                pDriverData->lpBuffer3 = NULL;
                                pDriverData->bNeedToAttachBuffer = FALSE;
                            }
                        }
                    }
#endif // FORCED_TRIPLE_BUFFER
                } else {
                    DPF( "    Backbuffer or flipable video memory surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                }
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {
putInOffscreen:     DPF( "    Offscreen surface granted" );
                pitch = psurf_gbl->wWidth *
                        (pDriverData->bi.biBitCount >> 3);
                psurf_gbl->lPitch = (pitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
                dwBlockSize = psurf_gbl->lPitch * psurf_gbl->wHeight;
                psurf_gbl->dwReserved1 = 0;

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)  &&
                    (pDriverData->GARTLinearBase > 0))  { /* First attempt to allocate in AGP memory */
#ifndef WINNT
                        psurf_gbl->fpVidMem =  (FLATPTR)DDHAL32_VidMemAlloc(pdrv, AGP_HEAP, dwBlockSize, 1);
#else
                        psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
                        psurf_gbl->dwBlockSizeX = dwBlockSize;
                        psurf_gbl->dwBlockSizeY = 1;
                        lpCreateSurface->lpDDSurfaceDesc->lPitch = psurf_gbl->lPitch;
                        lpCreateSurface->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
#endif // WINNT
                    if (psurf_gbl->fpVidMem != 0) {
                        DPF( "    Offscreen AGP memory surface allocation succeeded" );
                        psurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
#ifndef WINNT
                        handled = TRUE;
#else
                        handled = FALSE;
#endif // WINNT

                    } else {
                        DPF( "    Offscreen AGP memory surface allocation failed" );
                        psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                        lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                        return DDHAL_DRIVER_HANDLED;
                    }
                } else {
                    /*
                     * Notify 16 bit display driver code that Direct Draw is beginning
                     * to use local video memory.
                     */
#ifndef WINNT
                    if (pDriverData->DDrawVideoSurfaceCount == 0) {
                        HDC hdc = GetDC(0);
                        ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                    }
#endif // #ifndef WINNT

                    NVHEAP_ALLOC(psurf_gbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
                    //psurf_gbl->fpVidMem = DDHAL32_VidMemAlloc(pdrv, 0, dwBlockSize, 1);

                    if (psurf_gbl->fpVidMem != 0) {
                        pDriverData->DDrawVideoSurfaceCount++;
                        DPF( "    Offscreen video memory surface allocation succeeded" );
                        psurf->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                        handled = TRUE;
                    } else {
                        if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                            DPF( "    Offscreen video memory surface allocation failed" );
                            psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        DPF( "    Offscreen surface allocation failed, trying system memory" );
                        pitch = (pitch * 3) & ~3L;
                        dwBlockSize = pitch * psurf_gbl->wHeight;
                        hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
                        if (!hMem) {
                            DPF( "    System memory surface allocation failed" );
                            psurf_gbl->dwReserved1 = 0; /* Make sure we don't try to deallocate it if DestroySurface is called */
                            lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                            return DDHAL_DRIVER_HANDLED;
                        } else {
                            DPF( "    System memory surface allocation succeeded" );
                        }
                        psurf_gbl->lPitch = pitch;
                        psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                        psurf_gbl->dwReserved1 = (DWORD)hMem;
                        psurf->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
                        psurf->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                        handled = TRUE;
                    }
                }
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
                DPF( "    System memory surface requested" );
                pitch = psurf_gbl->wWidth *
                       (pDriverData->bi.biBitCount >> 3);
                pitch = (pitch + 3) & ~3L;  // pad to DWORD alignment
                hMem = GlobalAlloc(GHND | GMEM_SHARE, (pitch * psurf_gbl->wHeight));
                if (!hMem) {
                    DPF( "    System memory surface allocation failed" );
                    lpCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    DPF( "    System memory surface allocation succeeded" );
                }
                psurf_gbl->lPitch = pitch;
                psurf_gbl->fpVidMem = (FLATPTR)GlobalLock(hMem);
                psurf_gbl->dwReserved1 = (DWORD)hMem;
                handled = TRUE;
#ifdef NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
                /*
                 * Notify 16 bit display driver code that Direct Draw is beginning
                 * to use local video memory.
                 */
#ifndef WINNT
                if (pDriverData->DDrawVideoSurfaceCount == 0) {
                    HDC hdc = GetDC(0);
                    ExtEscape(hdc, RECONFIGNVOFFSCREEN, 0, 0, 0, 0);
                }
#endif // #ifndef WINNT
                /*
                 * Call the texture surface allocation code in the D3D driver. (D3dtex.c)
                 * If the routine returns FALSE, then the surface creation failed and the
                 * error should be returned immediately.
                 */
                if (!(handled = nvCreateTextureSurface(lpCreateSurface, psurf, psurf_gbl)))
                   return DDHAL_DRIVER_HANDLED;
#endif  // NVD3D
            } else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                goto putInOffscreen;
            }
        }
    }

    if( handled ) {
        lpCreateSurface->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * if we return handled, then it is assumed that we did SOMETHING
     * with the surface structures to indicate either what size of block
     * or a new pitch or some modification; or we are returning an error.
     */
    return DDHAL_DRIVER_NOTHANDLED;

} /* CreateSurface32 */


/*
 * CanCreateSurface32
 */
DWORD __stdcall CanCreateSurface32( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface ) {
    DWORD               caps;
    LPDDSURFACEDESC     lpDDSurface;
    int                 i;

    NvSetDriverDataPtr(lpCanCreateSurface->lpDD);

    /*
     * Reset NV and get the monitor frequency after a mode reset
     */
    if( pDriverData->fReset ) {
        getDisplayDuration();
        if (!ResetNV()) {
            lpCanCreateSurface->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }
        pDriverData->fReset = FALSE;
    }

    /*
     * NOTES:
     *
     * This entry point is called after parameter validation but before
     * any object creation.   You can decide here if it is possible for
     * you to create this surface.  For example, if the person is trying
     * to create an overlay, and you already have the maximum number of
     * overlays created, this is the place to fail the call.
     *
     * You also need to check if the pixel format specified can be supported.
     *
     * lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
     * surface being created matches that of the primary surface.  It can be
     * true for Z buffer and alpha buffers, so don't just reject it out of
     * hand...
     */
    DPF( "CanCreateSurface, lpCanCreateSurface->lpDD=%08lx", lpCanCreateSurface->lpDD );
    DPF( "    lpCanCreateSurface->lpDDSurfaceDesc=%08lx", lpCanCreateSurface->lpDDSurfaceDesc );

    lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;

    caps = lpDDSurface->ddsCaps.dwCaps;

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE))
        return DDHAL_DRIVER_NOTHANDLED;

    if (pDriverData->bi.biBitCount == 8) {
        if (caps & DDSCAPS_ALPHA)
            return DDHAL_DRIVER_NOTHANDLED;
    }

    /*
     * check pixel format.   Don't allow pixel formats that aren't
     * the same, unless we have a valid fourcc code, an overlay,
     * an alpha surface, or z buffer.
     */
    if ( lpCanCreateSurface->bIsDifferentPixelFormat ) {
        DPF( "    different pixel format!" );

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPREMULT ) {
            if ((pDriverData->bi.biBitCount == 8) || (pDriverData->bi.biBitCount == 16)) {
                /* We don't support alpha surfaces in 8bpp mode */
                DPF("NVDD32: CanCreateSurface32 - no alpha surf in 8bpp");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return DDHAL_DRIVER_HANDLED;
            }

            if (pDriverData->bi.biBitCount == 32) {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBAlphaBitMask != 0xFF000000) ||
                    (lpDDSurface->ddpfPixelFormat.dwRBitMask != 0x00FF0000) ||
                    (lpDDSurface->ddpfPixelFormat.dwGBitMask != 0x0000FF00) ||
                    (lpDDSurface->ddpfPixelFormat.dwBBitMask != 0x000000FF)) {
                    DPF("NVDD32: CanCreateSurface32 - unsupported format 10");
                    lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC ) {
            if (pDriverData->bi.biBitCount == 8) {
                /* We don't support RGB FOURCCs in 8bpp mode */
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 10");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            DPF( "    FourCC requested (%4.4hs, 0x%08lx)",
                (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                lpDDSurface->ddpfPixelFormat.dwFourCC );

            for( i=0; i < NV_MAX_FOURCC; i++ ) {
                if( lpDDSurface->ddpfPixelFormat.dwFourCC == pDriverData->fourCC[i] ) {
                    DPF( "    FOURCC=%4.4hs", (LPSTR) &pDriverData->fourCC[i] );
                    if (caps & DDSCAPS_OVERLAY) {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31)) {
                            DPF("NVDD32: CanCreateSurface32 - unsupported format 20");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if ((caps & (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) == (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) {
                            // Surface is for overlay with flip associated with video port
                            // check number of buffers, can't have more than 5 surfaces
                            // This will probably change when we have kernel mode flipping support
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 4)) {
                                DPF("NVDD32: CanCreateSurface32 - invalid parameters 10");
                                lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        } else {
                            // Workaround for Microsoft DirectVideo Cinepak decoding bug
                            // The reason for the existence of FOURCC_UYNV and FOURCC_YUNV
//                          if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
//                                (lpDDSurface->dwBackBufferCount > 1) &&
//                                ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
//                                 (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2))) {
//                              lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
//                                return DDHAL_DRIVER_HANDLED;
//                          }

                            // We must limit number of YV12 overlay surfaces to the maximum number we can manage reformatting
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 3) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12)) {
                                DPF("NVDD32: CanCreateSurface32 - out of caps 10");
                                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        }

                        if (pDriverData->dwOverlaySurfaces > 0) {
                            DPF("NVDD32: CanCreateSurface32 - out of caps 20");
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if (GetVideoScalerBandwidthStatus32(caps) == FALSE) {
                            DPF("NVDD32: CanCreateSurface32 - no overlay hardware 10");
                            lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                            return DDHAL_DRIVER_HANDLED;
                        }
                    } else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN)) {
                        /* Front end YUV support cannot reformat data so Indeo is not supported */
                        /* Currently also disallowing front end YUV420 since YUYV or UYVY
                           should do ok when not enough backend bandwidth is available */
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IF09) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YVU9) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV32) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_IV31) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_420i)) {
                            DPF("NVDD32: CanCreateSurface32 - unsupported format 30");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }

                        if (caps & DDSCAPS_VIDEOPORT) {
                            /* Nonoverlay FOURCC video surfaces are only supported for YUV422
                               formats and only when associated with the video port */
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                                          (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8)
                                          ) {
                                DPF("NVDD32: CanCreateSurface32 - unsupported format 40");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        /* Front end YUV support not available in 8bit indexed mode */
                        } else if (pDriverData->bi.biBitCount == 8) {
                            if (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8) {
                                DPF("NVDD32: CanCreateSurface32 - unsupported format 50");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                return DDHAL_DRIVER_HANDLED;
                            }
                        }
                    }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                        if (((pDriverData->bi.biBitCount == 16) &&
                            (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((pDriverData->bi.biBitCount == 32) &&
                            (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32))) {
                            DPF("NVDD32: CanCreateSurface32 - invalid pixel format 20");
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            return DDHAL_DRIVER_HANDLED;
                        }
                    }

                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

        } else if( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB ) {

            /* Don't allow 3D devices in 8bpp */
            if (caps & DDSCAPS_3DDEVICE) {
                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 30");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            if (caps & DDSCAPS_TEXTURE) {
                /* Don't allow textures in 8bpp. */
                if (pDriverData->bi.biBitCount == 8)
                {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 40");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                }
                /* accept 8 bpp texture formats if conversion is enabled */
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) &&
                    (pDriverData->regPal8TextureConvert != REG_P8TC_NONE))
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
                /* accept all 16 and 32 bpp texture formats */
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32))
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_HANDLED;
                }
            }

            if (caps & DDSCAPS_ZBUFFER) {
                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    /* For now, support z buffers in video memory only when our primary rendering depth is 16 bpp */

                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                     && (pDriverData->bi.biBitCount == 16))
                    {
                        /* accept all 16 bpp z buffer formats when in 16 bpp disply mode */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)
                     && (pDriverData->bi.biBitCount == 32))
                    {
                        /* accept all 32 bpp z buffer formats when in 32 bpp disply mode */
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * Any other z buffer depth or combination of z/display surface depths
                     * are invalid.
                     */
                    return DDHAL_DRIVER_NOTHANDLED;
                }
                else {
                    /* Allocate the z-buffer with the proper padding based on the bit depth of the primary surface */
                    /* accept all 16, 24, 32 bpp z buffer formats when in 16 bpp disply mode */
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                     || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 24)
                     || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                        lpCanCreateSurface->ddRVal = DD_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * Any other z buffer depth or combination of z/display surface depths
                     * are invalid.
                     */
                    return DDHAL_DRIVER_NOTHANDLED;
               }
            }

            /* We don't support any other RGB surfaces not in our native format */
            DPF("NVDD32: CanCreateSurface32 - invalid pixel format 50");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return DDHAL_DRIVER_HANDLED;

        } else if( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER ) {

            /* Don't allow z-buffer surfaces in 8bpp */
            if (caps & DDSCAPS_ZBUFFER) {
                if (pDriverData->bi.biBitCount == 8) {
                    DPF("NVDD32: CanCreateSurface32 - invalid pixel format 60");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                if (pDriverData->regValidateZMethod == REG_VZM_STRICT) {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != pDriverData->bi.biBitCount)) {
                        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 70");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_NOTHANDLED;
                    }
                }
                else {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 16)
                     && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 24)
                     && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 32)) {
                        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 80");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return DDHAL_DRIVER_NOTHANDLED;
                    }
                }
            }

            DPF( "Z BUFFER OK!" );
            lpCanCreateSurface->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        /*
         * can't handle any other kinds of different fourcc or RGB overlays
         */
        DPF("NVDD32: CanCreateSurface32 - invalid pixel format 90");
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
   }

   if (caps & DDSCAPS_MODEX) {
       DPF( "    Mode X requested" );
       lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
       return DDHAL_DRIVER_HANDLED;
   }

   /* Don't allow 3D devices in 8bpp (except for primary surface access, fixes Jedi Knight) */
   if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE))) {
       if (pDriverData->bi.biBitCount == 8) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 100");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }
   }

   if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))  {
       DPF( "    Frontbuffer requested" );

       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 110");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_FLIP) {
           if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biHeight) {
               if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                   DPF("NVDD32: CanCreateSurface32 - height too big 10");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
               }

           }
           if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                   DPF("NVDD32: CanCreateSurface32 - width too big 10");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_BACKBUFFER) {
       DPF( "    Backbuffer requested" );
#ifndef NVHEAPMGR
       if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
           DPF("NVDD32: CanCreateSurface32 - out of video memory 10");
           lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
           return DDHAL_DRIVER_HANDLED;
       }
#endif
       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 120");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_FLIP) {
           if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                   DPF("NVDD32: CanCreateSurface32 - height too big 20");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
               }

           }
           if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
               if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                   DPF("NVDD32: CanCreateSurface32 - width too big 20");
                   lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                   return DDHAL_DRIVER_HANDLED;
               } else {
                   lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_TEXTURE) {

       /* Don't allow textures in 8bpp */
       if (pDriverData->bi.biBitCount == 8) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 130");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
       lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & DDSCAPS_OFFSCREENPLAIN) {
       DPF( "    Can create offscreen requested" );

       if (caps & DDSCAPS_VIDEOMEMORY) {
#ifndef NVHEAPMGR
           if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
               DPF("NVDD32: CanCreateSurface32 - out of video memory 20");
               lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
               return DDHAL_DRIVER_HANDLED;
           }
#endif
           if (caps & DDSCAPS_OVERLAY) {
               DPF("NVDD32: CanCreateSurface32 - invalid pixel format 140");
               lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
               return DDHAL_DRIVER_HANDLED;
           }

           if (caps & DDSCAPS_FLIP) {
               if (lpDDSurface->dwHeight > (unsigned long)pDriverData->bi.biHeight) {
                   if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                       DPF("NVDD32: CanCreateSurface32 - height too big 30");
                       lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                       return DDHAL_DRIVER_HANDLED;
                   } else {
                       lpDDSurface->dwHeight = (unsigned long)pDriverData->bi.biHeight;
                   }
               }
               if (lpDDSurface->dwWidth > (unsigned long)pDriverData->bi.biWidth) {
                   if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                       DPF("NVDD32: CanCreateSurface32 - width too big 30");
                       lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                       return DDHAL_DRIVER_HANDLED;
                   } else {
                       lpDDSurface->dwWidth = (unsigned long)pDriverData->bi.biWidth;
                   }

               }
           }
       }
       lpCanCreateSurface->ddRVal = DD_OK;
       DPF( "    Can create offscreen granted" );
       return DDHAL_DRIVER_HANDLED;

   } else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER)) {
       DPF( "    Can create flipping surface requested" );

       if (caps & DDSCAPS_OVERLAY) {
           DPF("NVDD32: CanCreateSurface32 - invalid pixel format 150");
           lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
       }

       if (caps & DDSCAPS_ZBUFFER) {
           if ((pDriverData->bi.biBitCount != 16) &&
               (pDriverData->bi.biBitCount != 32)) {
               DPF("NVDD32: CanCreateSurface32 - invalid pixel format 160");
               lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
               return DDHAL_DRIVER_HANDLED;
           }
       }

#ifndef NVHEAPMGR
       if (pDriverData->HALInfo.vmiData.dwNumHeaps == 0) {
           DPF("NVDD32: CanCreateSurface32 - out of video memory 30");
           lpCanCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
           return DDHAL_DRIVER_HANDLED;
       }
       else
#endif
       {
           DPF( "    Can create flipping surface available" );
           lpCanCreateSurface->ddRVal = DD_OK;
           return DDHAL_DRIVER_HANDLED;
       }

   } else if (caps & DDSCAPS_SYSTEMMEMORY) {
       lpCanCreateSurface->ddRVal = DD_OK;
       DPF( "    Can create system memory requested" );
       return DDHAL_DRIVER_HANDLED;
   }


#ifdef NVD3D
   if (caps & DDSCAPS_TEXTURE) {
       lpCanCreateSurface->ddRVal = DD_OK;
       return DDHAL_DRIVER_HANDLED;
   }
#endif

   return DDHAL_DRIVER_NOTHANDLED;

} /* CanCreateSurface32 */

/***************************************************************************
 * DestroyDriver32
 ***************************************************************************/

#ifndef WINNT
HRESULT __stdcall DestroyDriver32(LPDDHAL_DESTROYDRIVERDATA pDestroyDriverData)
#else
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pGlobalData)
#endif // #ifdef WINNT
{
    FAST Nv10ControlDma         *npDev;
    FAST Nv3ChannelPio          *npDevVideo;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DWORD                       index = 0;

    DPF("DestroyDriver32");
#ifndef WINNT
    pdrv = pDestroyDriverData->lpDD;
#else
    /*
     * Load global ptr variable to "global" data
     */
    pDriverData = pGlobalData;

#endif

    npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

    /* If an overlay is currently active then shut it down */
    if ((npDevVideo != NULL) && (pDriverData->dwOverlaySurfaces > 0)) {
        FAST long videoFreeCount = pDriverData->NvVideoFreeCount;

        NV_DD_DMA_PUSHER_SYNC();

        /* Trash spare subchannel */
        pDriverData->dwRingZeroMutex = TRUE;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 12)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 12;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[0] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

            npDevVideo->dDrawSpare.Nv10VideoOverlay.StopOverlay[1] =
                NV07A_STOP_OVERLAY_BETWEEN_BUFFERS;

        } else { // pre NV10

            while (videoFreeCount < 20)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 20;

            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0; // hide overlay

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].size = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[0].notify = 0;
        }

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->dwOverlayOwner = 0;

        pDriverData->dwOverlaySurfaces = 0;

        while (index < NV_MAX_OVERLAY_SURFACES)
            pDriverData->dwOverlaySurfaceLCL[index++] = 0;

        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        pDriverData->NvVideoFreeCount = (short)videoFreeCount;
    }

    /* Unlock and free any remaining locked down system memory */
    if (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] > 0) {
        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                 pDriverData->BaseAddress) || /* If system memory */
            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                 (unsigned long)pDriverData->VideoHeapEnd)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
            unsigned long *dmaPusherPutAddress =
                (unsigned long *)pDriverData->NvDmaPusherPutAddress;
            unsigned long *dmaPusherBufferBase =
                (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
            long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
            long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

            if (npDev != NULL) {

                NV_DD_DMA_PUSHER_SYNC();

                // MUST wait for any pending notification to prevent possible loss of notification serialization
                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                while (freeCount < 28)
                    NvGetDmaBufferFreeCount(npDev, freeCount, 28, dmaPusherPutAddress);
                freeCount -= 28;

                pDriverData->dDrawSpareSubchannelObject = 0;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                /* Trash spare subchannel */
                dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[5] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[8] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[9] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[10] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[11] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[12] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[14] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[15] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[17] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
                dmaPusherPutAddress[19] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
                dmaPusherPutAddress[20] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000;
                dmaPusherPutAddress[21] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[22] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000;
                dmaPusherPutAddress[23] = NV1_NULL_OBJECT;
                dmaPusherPutAddress[24] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
                dmaPusherPutAddress[25] = 0;
                dmaPusherPutAddress[26] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                    RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
                dmaPusherPutAddress[27] = 0;

                dmaPusherPutAddress += 28;

                pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

                /* Force write combine buffer to flush */
                pDriverData->NvDmaPusherBufferEnd[0] = 0;
                /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
                _outp (0x3d0,0);

                pDriverData->dwDmaPusherFreeCount = freeCount;

                npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                         NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
            }

            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;

            GlobalUnlock((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
            GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);

            pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

        } else { /* If video memory */
            NVHEAP_FREE (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);
            //DDHAL32_VidMemFree(pdrv, 0, pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]);

            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;
        }
    }

    /* Unlock and free any remaining locked down system memory */

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif

    if (pDriverData->NvDevFlatDma != 0) {
        NvNotification *npDmaSyncNotifier =
            (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
        long freeCount = 0;
        unsigned long *dmaPusherPutAddress =
            (unsigned long *)pDriverData->NvDmaPusherPutAddress;
        unsigned long *dmaPusherBufferBase =
            (unsigned long *)pDriverData->NvDmaPusherBufferBase;
        /*
         * Ensure the push buffer has completed prior to deleting objects
         * which it might reference.
         */
        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        while (freeCount < 4)
            NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
        freeCount -= 4;

        npDmaSyncNotifier->status = NV_IN_PROGRESS;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
            RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
        dmaPusherPutAddress[3] = 0;

        dmaPusherPutAddress += 4;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        NV_DD_DMA_PUSHER_SYNC();
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
        pDriverData->NvDmaPusherPutAddress = dmaPusherPutAddress;
        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        /* Unlock and free any remaining locked down system memory */

        /*
        * This routine will insure that any allocated texture heap is destroyed.
        */
        D3DDestroyTextureContexts();
        if (pDriverData->DDrawVideoSurfaceCount > 0)
            if (!NvDDDisable32())
                return(FALSE);
        if (NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                 NV_DD_DEV_DMA) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);
        pDriverData->NvDevFlatDma = 0;
    }

    /*
     * This routine will insure that any allocated texture heap is destroyed.
     */

    if (pDriverData->dwDmaPusherCtxDmaSize) {

        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = 0;
    }

    if (pDriverData->NvAGPDmaPusherBufferBase != 0) {
        /* Make sure we destroy the AGP push buffer context DMA */
#ifndef WINNT
        DDHAL32_VidMemFree(pdrv, AGP_HEAP, pDriverData->NvAGPDmaPusherBufferBase);
#endif // WINNT
        pDriverData->NvAGPDmaPusherBufferBase = 0;
    }

    if ((pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) &&
        (pDriverData->NvDevVideoFlatPio != 0)) {
        if (NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                 NV_DD_DEV_VIDEO) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);
        pDriverData->NvDevVideoFlatPio = 0;
    }

    pDriverData->extra422OverlayOffset[0] = 0;
    pDriverData->extra422OverlayOffset[1] = 0;

    // Let 16 bit Display Driver code know that Direct Draw is no longer active
    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->fNvActiveFloatingContexts = 0;

    // Reset AGP GART addresses
    pDriverData->GARTLinearBase = 0;
    pDriverData->GARTPhysicalBase = 0;

    pDriverData->wDDrawActive = (WORD)FALSE; // let everyone know DDraw is no longer active
    pDriverData->dwRingZeroMutex = FALSE;
#ifdef WINNT
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
    if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
             NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(FALSE);
#endif // #ifdef WINNT

#ifndef WINNT
    pDestroyDriverData->ddRVal = DD_OK;
#endif // #ifndef WINNT
    return DDHAL_DRIVER_HANDLED;

} /* DestroyDriver32 */

#ifndef WINNT
/*
 * GetHeapAlignment32
 *
 * Returns more specific heap alignment requirements to DDRAW than
 * those described in the heap structure.
 */

DWORD __stdcall GetHeapAlignment32(LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData) {

    lpGhaData->ddRVal= DD_OK;

    if (lpGhaData->dwHeap == 0) {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                              DDSCAPS_EXECUTEBUFFER |
                                              DDSCAPS_OVERLAY |
                                              DDSCAPS_TEXTURE |
                                              DDSCAPS_ZBUFFER |
                                              DDSCAPS_ALPHA |
                                              DDSCAPS_FLIP;

        /* Alignments in bytes */

        lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
        lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

        lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT; /* Texture surfaces, not our optimized texture alignment */
        lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = NV_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

        lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = NV_SCAN_OUT_BYTE_ALIGNMENT;
        lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT;

    } else {
        DPF("D3D: GetHeapAlignment32 - invalid parameters 10");
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    return DDHAL_DRIVER_HANDLED;

} /* GetHeapAlignment32 */


/*
 * UpdateNonLocalHeap32
 *
 * Records actual AGP memory linear and physical addresses.
 */

DWORD __stdcall UpdateNonLocalHeap32( LPDDHAL_UPDATENONLOCALHEAPDATA lpd )
{
    unsigned long oldDmaPusherBufferBase;

    NvSetDriverDataPtr(lpd->lpDD);

    oldDmaPusherBufferBase = pDriverData->NvAGPDmaPusherBufferBase;

    if( lpd->dwHeap == AGP_HEAP ) { /* AGP heap */
        /* This it the linear non-local heap we use for DMA push buffers, textures and YV12 surfaces... */
        pDriverData->GARTLinearBase = lpd->fpGARTLin;
        pDriverData->GARTPhysicalBase = lpd->fpGARTDev;

        /* Let the resource manager know this information */
        NvConfigSet(NV_CFG_AGP_PHYS_BASE, pDriverData->GARTPhysicalBase, pDriverData->dwDeviceIDNum);
        NvConfigSet(NV_CFG_AGP_LINEAR_BASE, pDriverData->GARTLinearBase, pDriverData->dwDeviceIDNum);
        /* currently limit AGP memory to 32 MB */
        NvConfigSet(NV_CFG_AGP_LIMIT, NV_MAX_AGP_MEMORY_LIMIT, pDriverData->dwDeviceIDNum);

        pDriverData->NvAGPDmaPusherBufferBase =
            (DWORD) DDHAL32_VidMemAlloc(lpd->lpDD, AGP_HEAP, pDriverData->NvDmaPusherBufferSize, 1);

        /* Handle case where AGP DMA push buffer gets moved */
        if ((oldDmaPusherBufferBase) &&
            (oldDmaPusherBufferBase != pDriverData->NvAGPDmaPusherBufferBase) &&
            (pDriverData->dwDmaPusherCtxDmaSize)) {

            if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS) {
                lpd->ddRVal = DDERR_GENERIC;
                return DDHAL_DRIVER_HANDLED;
            }
            pDriverData->dwDmaPusherCtxDmaSize = 0;
        }
    }

    lpd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* UpdateNonLocalHeap32 */
#endif // #ifndef WINNT

/*
 * GetAvailDriverMemory32
 *
 * Reports amount of memory that the driver is managing itself.
 */
DWORD __stdcall GetAvailDriverMemory32( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpd )
{
    NvSetDriverDataPtr(lpd->lpDD);

#ifdef NVHEAPMGR
    /*
     * The driver is using the RM to manage video memory.
     */
    lpd->dwTotal = pDriverData->VideoHeapTotal;
    lpd->dwFree  = pDriverData->VideoHeapFree;
#else
    /*
     * The driver is only managing private memory on PCI systems for textures.
     */
    lpd->dwTotal = 0;
    lpd->dwFree  = 0;
#endif
    /*
     * The driver is only managing private memory on PCI systems for textures.
     */
    if ((lpd->DDSCaps.dwCaps & DDSCAPS_TEXTURE) && (pDriverData->GARTLinearBase == 0))
    {
        /* Check to see if D3D has been fired up yet. */
        if (pDriverData->dwTextureHeapSizeMax == 0)
        {
            /*
             * If the current texture heap size is not initialized yet, then this means
             * D3D has not be fired up yet to actually allocate the texture heap.  In this
             * case return the amount that is being requested.  Once D3D is up and running,
             * the memory sizes will be based on what the heap size really is.
             */
            lpd->dwTotal += pDriverData->regTexHeap;
            lpd->dwFree  += pDriverData->regTexHeap;
        }
        else
        {
            /*
             * Return the maximum and available size of the internal PCI
             * system meory texture heap
             */
            lpd->dwTotal += pDriverData->dwTextureHeapSizeMax;
            lpd->dwFree  += pDriverData->dwFreeSize;
        }
    }
    else
    {
        /*
         * For non-texture surface requests or AGP systems, there is no internal memory.
         */
        lpd->dwTotal += 0;
        lpd->dwFree  += 0;
    }
    lpd->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}


/* Safe procedures, basically if they are called nothing happens */
DWORD FAR PASCAL SafeSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    lpInput->ddRVal= DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

DWORD FAR PASCAL SafeSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    lpInput->ddRVal= DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Sets the colour control for the hardware overlay.  This is a private
//      interface for codec vendors.  The colour controls will be applied to
//      any flippable overlay to the target surface.  Only YUY2 and UYVY surfaces
//      are supported.  If the lpDDCC is NULL, then capabilities are returned,
//      otherwise returns TRUE if succeeded.
//      NOTE to codec vendors: if you are applying this to an anchor frame that
//      needs to be used again, blit it somewhere else first because the frame
//      data is modified in place to the flip target.
DWORD __stdcall nvSetOverlayColorControl(LPDDCOLORCONTROL lpDDCC)
{
    if (lpDDCC) {
#ifdef OVLCCTL
        if (lpDDCC->dwSize != sizeof(DDCOLORCONTROL)) return FALSE;
        pDriverData->OverlayColourControl.lContrast = lpDDCC->lContrast;
        if ((lpDDCC->dwFlags & ~DDCOLOR_CONTRAST) != 0) return FALSE;
        return TRUE;
#else
        return FALSE;
#endif
    } else {
#ifdef OVLCCTL
        return DDCOLOR_CONTRAST;
#else
        return 0;
#endif
    }
}

#ifdef OVLCCTL
/*
 * GetTranslatedOffset(DWORD lBrightness )
 *
 * Converts linear brightness into an offset to program into
 * CSC registers, this algorithm is non-linear and
 * includes two ranges.
 */
DWORD GetTranslatedOffset( unsigned long lBrightness)
{
    DWORD dwOffset;

    if (lBrightness>10000)
        lBrightness = 10,000;

    if (lBrightness<=750)
        {
        dwOffset = 1+ ( 0x3D * (lBrightness/749) );
        }
    else
        {
        dwOffset = (0x69 * (lBrightness/(10,000-750)));
        }

    return dwOffset;
}

#define NV_PVIDEO_RED_CSC 0x680280
#define NV_PVIDEO_GREEN_CSC 0x680284
#define NV_PVIDEO_BLUE_CSC 0x680288

DWORD GetOffsetTranslated()
{
    U032 * nvBase;
    U032 dwRedCsc;

    // all of this is based of the red csc value
    nvBase = (U032 *) (pDriverData->NvBaseFlat);

    dwRedCsc = nvBase[NV_PVIDEO_RED_CSC/4];

    if (dwRedCsc>=0x69)
        {// 750 to 0 range
        return (750 * ((dwRedCsc-0x69)/0x3E));
        }
    else
        {// 750-10,000 range
        return (750 + ((10000-750)* ((0x69-dwRedCsc)/0x69)) );
        }
}


/*
 * Colour Control
 * Extended functionality of DirectDraw/VPE
 */
DWORD FAR PASCAL ColourControl( LPDDHAL_COLORCONTROLDATA pvpcd )
{
    U032 *nvBase;

    if (pvpcd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {

        NvSetDriverDataPtr(pvpcd->lpDD);

        if (pvpcd->dwFlags & DDRAWI_GETCOLOR ) {

            pvpcd->lpColorData->dwSize = sizeof(DDCOLORCONTROL);

            // time being can only do brightness and contrast
            pvpcd->lpColorData->dwFlags = DDCOLOR_BRIGHTNESS; // DDCOLOR_HUE
            pvpcd->lpColorData->dwFlags = DDCOLOR_CONTRAST;

            // is in units of 1, maximum is 10,000
            pvpcd->lpColorData->lBrightness = GetOffsetTranslated();

            // contrast ranges from 0 to 20,000 (intended to be 0 to 200%)
            // since we can't do overcontrasting, make 20,000 equal to 100% (technically not illegal)
            pvpcd->lpColorData->lContrast = min(pDriverData->OverlayColourControl.lContrast * 20000 / 255, 20000);

            pvpcd->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pvpcd->dwFlags & DDRAWI_SETCOLOR ) {
            // can only do brightness and contrast, any other request is denied
            if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                DWORD dwCscOffset;
                DWORD dwCscRed, dwCscGreen, dwCscBlue;

                dwCscOffset = GetTranslatedOffset( pvpcd->lpColorData->lBrightness );

                dwCscRed = 0x69     + dwCscOffset;
                dwCscGreen = 0x3E   - dwCscOffset;
                dwCscBlue  = 0x89   + dwCscOffset;

                nvBase = (U032 *) (pDriverData->NvBaseFlat);

                nvBase[NV_PVIDEO_RED_CSC/4] = dwCscRed;
                nvBase[NV_PVIDEO_GREEN_CSC/4] = dwCscGreen;
                nvBase[NV_PVIDEO_BLUE_CSC/4] = dwCscBlue;
            }
            if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                pDriverData->OverlayColourControl.lContrast = min(pvpcd->lpColorData->lContrast * 256 / 20000, 255);
            }
            if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST)) {
                pvpcd->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    return DDHAL_DRIVER_NOTHANDLED;
}
#endif

#ifndef WINNT
/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */

DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData)
{
    pDriverData = (GLOBALDATA *)lpData->dwContext;

    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    if (IsEqualIID(&(lpData->guidInfo), &GUID_MiscellaneousCallbacks) ) {
        DDHAL_DDMISCELLANEOUSCALLBACKS miscCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

        miscCB.dwFlags =
#ifndef WINNT
                         DDHAL_MISCCB32_GETHEAPALIGNMENT |
                         DDHAL_MISCCB32_UPDATENONLOCALHEAP |
#endif
                         DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;

#ifndef WINNT
        miscCB.GetHeapAlignment = GetHeapAlignment32;
        miscCB.UpdateNonLocalHeap = UpdateNonLocalHeap32;
#endif
        miscCB.GetAvailDriverMemory = GetAvailDriverMemory32;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef  DX7
    if (IsEqualIID(&(lpData->guidInfo), &GUID_Miscellaneous2Callbacks) ) {
        DDHAL_DDMISCELLANEOUS2CALLBACKS misc2CB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(misc2CB) < dwSize )
            dwSize = sizeof(misc2CB);
        lpData->dwActualSize = sizeof(misc2CB);
        memset(&misc2CB, 0, dwSize);
        misc2CB.dwSize = dwSize;

        misc2CB.dwFlags = DDHAL_MISC2CB32_ALPHABLT;

        misc2CB.AlphaBlt = Blit32;  /* Use common callback with Blit32 calls */

        memcpy(lpData->lpvData, &misc2CB, dwSize );
        lpData->ddRVal = DD_OK;
    }
#endif  /* DX7 */

    if( IsEqualGUID( &lpData->guidInfo, &GUID_NonLocalVidMemCaps ) ) {
        DWORD dwSize;
        LPDDNONLOCALVIDMEMCAPS lpCaps;
        int i;

        /* Size validation code omitted for clarity */
        dwSize = min(lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpCaps = (LPDDNONLOCALVIDMEMCAPS)(lpData->lpvData);
        lpCaps->dwSize = dwSize;

        lpCaps->dwNLVBCaps = ddHALInfo.ddCaps.dwCaps;
        lpCaps->dwNLVBCaps2 = ddHALInfo.ddCaps.dwCaps2;
        lpCaps->dwNLVBCKeyCaps = ddHALInfo.ddCaps.dwCKeyCaps;
        lpCaps->dwNLVBFXCaps = ddHALInfo.ddCaps.dwFXCaps;

        for( i=0; i < DD_ROP_SPACE; i++ )
            lpCaps->dwNLVBRops[i] = ropList[i];

        lpData->dwActualSize = dwSize;
        lpData->ddRVal = DD_OK;
    }


    if (IsEqualIID(&(lpData->guidInfo), &GUID_VideoPortCallbacks) ) {
        DDHAL_DDVIDEOPORTCALLBACKS vpCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(vpCB) < dwSize )
            dwSize = sizeof(vpCB);
        lpData->dwActualSize = sizeof(vpCB);
        memset(&vpCB, 0, dwSize);
        vpCB.dwSize = dwSize;

        vpCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                       DDHAL_VPORT32_CREATEVIDEOPORT    |
                       DDHAL_VPORT32_DESTROY            |
                       DDHAL_VPORT32_FLIP               |
                       DDHAL_VPORT32_GETBANDWIDTH       |
                       DDHAL_VPORT32_GETINPUTFORMATS    |
                       DDHAL_VPORT32_GETOUTPUTFORMATS   |
                       DDHAL_VPORT32_GETFIELD           |
                       DDHAL_VPORT32_GETCONNECT         |
                       DDHAL_VPORT32_GETFLIPSTATUS      |
                       DDHAL_VPORT32_UPDATE             |
                       DDHAL_VPORT32_WAITFORSYNC        |
                       DDHAL_VPORT32_GETSIGNALSTATUS;


        vpCB.CanCreateVideoPort         = CanCreateVideoPort32;
        vpCB.CreateVideoPort            = CreateVideoPort32;
        vpCB.DestroyVideoPort           = DestroyVideoPort32;
        vpCB.FlipVideoPort              = FlipVideoPort32;

        vpCB.GetVideoPortBandwidth      = GetVideoPortBandwidth32;
        vpCB.GetVideoPortInputFormats   = GetVideoPortInputFormat32;
        vpCB.GetVideoPortOutputFormats  = GetVideoPortOutputFormat32;
        vpCB.GetVideoPortField          = GetVideoPortField32;
        vpCB.GetVideoPortConnectInfo    = GetVideoPortConnectInfo;

        vpCB.GetVideoPortFlipStatus     = GetVideoPortFlipStatus32;
        vpCB.UpdateVideoPort            = UpdateVideoPort32;
        vpCB.WaitForVideoPortSync       = WaitForVideoPortSync32;
        vpCB.GetVideoSignalStatus       = GetVideoSignalStatus32;

        memcpy(lpData->lpvData, &vpCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#ifdef OVLCCTL
    if (IsEqualIID(&(lpData->guidInfo),&GUID_ColorControlCallbacks) ) {
        DDHAL_DDCOLORCONTROLCALLBACKS ccCB;
        DWORD dwSize = lpData->dwExpectedSize;

        lpData->dwActualSize = sizeof( DDHAL_DDCOLORCONTROLCALLBACKS );

        ccCB.dwSize = (dwSize<lpData->dwActualSize)?
                        dwSize:lpData->dwActualSize;


        ccCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ccCB.ColorControl = ColourControl;

        memcpy(lpData->lpvData, &ccCB, ccCB.dwSize );

        lpData->ddRVal = DD_OK;
    }
#endif

    if (IsEqualIID(&(lpData->guidInfo), &GUID_VideoPortCaps) ) {
        DDVIDEOPORTCAPS VideoPortCaps;
        DDVIDEOPORTCAPS *pVideoPortCapsDest = lpData->lpvData;
        DWORD dwIndex;

        // expecting query for 1 video port
        if (lpData->dwExpectedSize != (sizeof(VideoPortCaps)) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = (sizeof(VideoPortCaps) );

    // index changed to allow only 1 report resolution, for time being only NTSC
    // until class structure is changed to test PAL etc
        for (dwIndex = 0; dwIndex < 1; dwIndex++) {

        memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

        VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

        VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                DDVPD_HEIGHT            |
                                DDVPD_ID                |
                                DDVPD_CAPS              |
                                DDVPD_FX                |
                                DDVPD_AUTOFLIP          |
                                DDVPD_ALIGN             |
                                DDVPD_PREFERREDAUTOFLIP |
                                DDVPD_FILTERQUALITY;

        VideoPortCaps.dwVideoPortID = dwIndex;
        // for more supported video modes, place the resolutions here
//        VideoPortCaps.dwMaxWidth  = ST_VPE_MAX_INPUT_X;
//       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
//      VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
        VideoPortCaps.dwMaxWidth    = 4096;     // must talk to joe and get the details on this..
        VideoPortCaps.dwMaxVBIWidth = 4096;
        VideoPortCaps.dwMaxHeight   = 640;      // just arbitarily larger than PAL field *2 for progressive

// could have share even/odd, but for now keep things simple

        VideoPortCaps.dwCaps =
                                DDVPCAPS_AUTOFLIP       |
                                DDVPCAPS_INTERLACED     |
                                DDVPCAPS_NONINTERLACED  |
//                              DDVPCAPS_SHAREABLE      |
                                DDVPCAPS_SKIPEVENFIELDS |
                                DDVPCAPS_SKIPODDFIELDS  |
                                DDVPCAPS_VBISURFACE     |
                                DDVPCAPS_OVERSAMPLEDVBI;

        VideoPortCaps.dwFX =
                                DDVPFX_CROPTOPDATA      |
                                DDVPFX_INTERLEAVE       |
                                DDVPFX_PRESHRINKXB      |
                                DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                                DDVPFX_VBICONVERT       |
                                DDVPFX_VBINOSCALE       |
                                DDVPFX_VBINOINTERLEAVE  |
                                DDVPFX_IGNOREVBIXCROP;


       VideoPortCaps.dwNumAutoFlipSurfaces = 5;


        VideoPortCaps.dwAlignVideoPortBoundary      = NV_BYTE_ALIGNMENT;
        VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

// can't crop to an arbitary rectangle!!
        VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
        VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

// not valid for PRESHRINKX/YB flag as set above
        VideoPortCaps.dwPreshrinkXStep = 24;
        VideoPortCaps.dwPreshrinkYStep = 0x400;


        VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

        VideoPortCaps.dwNumPreferredAutoflip =3;
        VideoPortCaps.wNumFilterTapsX = 2;
        VideoPortCaps.wNumFilterTapsY = 1;

        memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );
        }
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCallbacks) ) {
        DDHAL_DDKERNELCALLBACKS kCB;
        DWORD dwSize = lpData->dwExpectedSize;

        if ( sizeof(kCB) < dwSize )
            dwSize = sizeof(kCB);
        lpData->dwActualSize = sizeof(kCB);

        kCB.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        kCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        kCB.SyncSurfaceData = SafeSyncSurfaceData;          // we're not doing anything on EITHER of these yet
        kCB.SyncVideoPortData = SafeSyncVideoPortData;

        memcpy(lpData->lpvData, &kCB, dwSize );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&(lpData->guidInfo), &GUID_KernelCaps) ) {
        DDKERNELCAPS KernelCaps;

        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        KernelCaps.dwSize = sizeof(DDKERNELCAPS);
        KernelCaps.dwCaps =
            DDKERNELCAPS_SKIPFIELDS         |
            DDKERNELCAPS_AUTOFLIP           |
            DDKERNELCAPS_SETSTATE           |
            DDKERNELCAPS_LOCK                   |
//          DDKERNELCAPS_FLIPVIDEOPORT      |
            DDKERNELCAPS_FLIPOVERLAY        |
//          DDKERNELCAPS_CAPTURE_SYSMEM |
//          DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
            DDKERNELCAPS_FIELDPOLARITY      ;
//          DDKERNELCAPS_CAPTURE_INVERTED   ;

        KernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
//                                      DDIRQ_BUSMASTER;
//                                      #define DDIRQ_BUSMASTER             0x00000002l
                                        0x00000002;

//          DDIRQ_DISPLAY_VSYNC |
//          DDIRQ_RESERVED1     |
//          DDIRQ_VPORT0_VSYNC          // this is the only IRQ we'll be supporting
//          DDIRQ_VPORT0_LINE       |
//          DDIRQ_VPORT1_VSYNC  |
//          DDIRQ_VPORT1_LINE   |

        memcpy(lpData->lpvData, &KernelCaps, sizeof(DDKERNELCAPS) );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

#ifdef  DX7
    if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreCaps) ) {
        DDMORECAPS ddMoreCaps;

        if (lpData->dwExpectedSize != sizeof(DDMORECAPS) )
            return DDHAL_DRIVER_HANDLED;

        lpData->dwActualSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwAlphaCaps = DDALPHACAPS_BLTALPHAPIXELS |
                                 DDALPHACAPS_BLTSATURATE |
                                 DDALPHACAPS_BLTPREMULT |
//                                 DDALPHACAPS_BLTNONPREMULT |
                                 DDALPHACAPS_BLTRGBASCALE1F |
                                 DDALPHACAPS_BLTRGBASCALE4F |
                                 DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwSVBAlphaCaps = DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT |
//                                    DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTRGBASCALE1F |
                                    DDALPHACAPS_BLTRGBASCALE4F |
                                    DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwFilterCaps = DDFILTCAPS_BLTBILINEARFILTER |
                                  DDFILTCAPS_BLTFLATFILTER |
                                  DDFILTCAPS_OVERLAYBILINEARFILTER;

        ddMoreCaps.dwSVBFilterCaps = DDFILTCAPS_BLTBILINEARFILTER |
                                     DDFILTCAPS_BLTFLATFILTER;

        memcpy(lpData->lpvData, &ddMoreCaps,
            sizeof(DDMORECAPS) );
        lpData->ddRVal = DD_OK;
    }
#endif  /* DX7 */


#ifdef NVD3D
    /*
     * Call D3D HAL to see if there's any GUIDs it wants to handle.
     */
    D3DGetDriverInfo(lpData);
#endif

    return DDHAL_DRIVER_HANDLED;

} /* GetDriverInfo32 */
#endif // #ifndef WINNT

/*
 * buildDDHALInfo32
 *
 * build DDHALInfo structure
 */
BOOL buildDDHALInfo32()
{
   int i;

    /*
     * modify the structures inour shared window with the 16bit driver
     */
    #define cbDDCallbacks        pDriverData->DDCallbacks
    #define cbDDSurfaceCallbacks pDriverData->DDSurfaceCallbacks
    #define cbDDPaletteCallbacks pDriverData->DDPaletteCallbacks

    /*
     * fill out the main driver callbacks
     */
    memset(&cbDDCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    cbDDCallbacks.dwSize                = sizeof(DDHAL_DDCALLBACKS);
//    cbDDCallbacks.SetMode               = SetMode32;   Never called by DDRAW
    cbDDCallbacks.WaitForVerticalBlank  = WaitForVerticalBlank32;
    cbDDCallbacks.GetScanLine           = GetScanLine32;
    cbDDCallbacks.CreateSurface         = CreateSurface32;
    cbDDCallbacks.CanCreateSurface      = CanCreateSurface32;
#ifndef WINNT       // this is called from DrvDisableDirectDraw
    cbDDCallbacks.DestroyDriver         = DestroyDriver32;
#endif              // WINNT

    cbDDCallbacks.dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK |
//                                          DDHAL_CB32_SETMODE |
                                          DDHAL_CB32_GETSCANLINE |
                                          DDHAL_CB32_CANCREATESURFACE |
                                          DDHAL_CB32_CREATESURFACE |
                                          DDHAL_CB32_DESTROYDRIVER;

    /*
     * fill out the palette callbacks
     */
    memset(&cbDDPaletteCallbacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));
    cbDDPaletteCallbacks.dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
    cbDDPaletteCallbacks.dwFlags = 0;

    /*
     * fill out the HALINFO
     */
    memset(&ddHALInfo, 0, sizeof(DDHALINFO));
    ddHALInfo.dwSize = sizeof(DDHALINFO);

    /*
     * callback functions
     */
#ifndef WINNT
    ddHALInfo.lpDDCallbacks        = &cbDDCallbacks;
    ddHALInfo.lpDDSurfaceCallbacks = &cbDDSurfaceCallbacks;
    ddHALInfo.lpDDPaletteCallbacks = &cbDDPaletteCallbacks;

    /*
     * return our HINSTANCE
     */
    ddHALInfo.hInstance = (DWORD)hInstance;

    /*
     * pdevice
     */
    ddHALInfo.lpPDevice = (LPVOID)pDriverData->lpPDevice;
#else
    ddHALInfo.lpD3DHALCallbacks        = &cbDDCallbacks;
#endif // #ifdef WINNT

    /*
     * ROPS supported
     */

    for( i=0; i < DD_ROP_SPACE; i++ )
        ddHALInfo.ddCaps.dwRops[i] = ropList[i];

    for( i=0; i < DD_ROP_SPACE; i++ )
        ddHALInfo.ddCaps.dwSVBRops[i] = ropList[i];


   /*
    * fill out the surface callbacks
    */
    memset(&cbDDSurfaceCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    cbDDSurfaceCallbacks.dwSize             = sizeof(DDHAL_DDSURFACECALLBACKS);
    cbDDSurfaceCallbacks.DestroySurface     = DestroySurface32;
    cbDDSurfaceCallbacks.Blt                = Blit32;
    cbDDSurfaceCallbacks.Flip               = Flip32;
    cbDDSurfaceCallbacks.Lock               = Lock32;
    cbDDSurfaceCallbacks.Unlock             = Unlock32;
    cbDDSurfaceCallbacks.GetBltStatus       = GetBltStatus32;
    cbDDSurfaceCallbacks.GetFlipStatus      = GetFlipStatus32;
    cbDDSurfaceCallbacks.UpdateOverlay      = UpdateOverlay32;
    cbDDSurfaceCallbacks.SetOverlayPosition = SetOverlayPosition32;
    cbDDSurfaceCallbacks.SetColorKey        = SetSurfaceColorKey32;
    cbDDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                              DDHAL_SURFCB32_FLIP |
                                              DDHAL_SURFCB32_LOCK |
                                              DDHAL_SURFCB32_UNLOCK |
                                              DDHAL_SURFCB32_SETCOLORKEY |
                                              DDHAL_SURFCB32_GETBLTSTATUS |
                                              DDHAL_SURFCB32_GETFLIPSTATUS |
                                              DDHAL_SURFCB32_UPDATEOVERLAY |
                                              DDHAL_SURFCB32_SETOVERLAYPOSITION |
                                              DDHAL_SURFCB32_DESTROYSURFACE;

    /*
     * capabilities supported
     */

    ddHALInfo.ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                              DDCAPS_ALIGNBOUNDARYDEST |
                              DDCAPS_GDI |
                              DDCAPS_BLT |
                              DDCAPS_BLTFOURCC |
                              DDCAPS_BLTSTRETCH |
                              DDCAPS_BLTQUEUE |
                              DDCAPS_BLTCOLORFILL |
                              DDCAPS_CANBLTSYSMEM |
#ifdef  DX7
                              DDCAPS_ALPHA |
#endif  /* DX7 */
                              DDCAPS_COLORKEY |
                              DDCAPS_OVERLAY |
                              DDCAPS_OVERLAYCANTCLIP  |
                              DDCAPS_OVERLAYFOURCC |
                              DDCAPS_OVERLAYSTRETCH |
                              DDCAPS_READSCANLINE |
                              DDCAPS_BLTDEPTHFILL |
                              DDCAPS_3D;

    ddHALInfo.ddCaps.dwCaps2 |= DDCAPS2_NOPAGELOCKREQUIRED |
                                DDCAPS2_WIDESURFACES |
                                DDCAPS2_FLIPNOVSYNC |
#ifndef WINNT
                                DDCAPS2_PRIMARYGAMMA |
#endif // #ifndef WINNT
                                DDCAPS2_CANRENDERWINDOWED |
                                DDCAPS2_CANBOBHARDWARE |
                                DDCAPS2_CANBOBINTERLEAVED |
                                DDCAPS2_CANFLIPODDEVEN |
#ifdef OVLCCTL
                                DDCAPS2_COLORCONTROLOVERLAY |
#endif
                                DDCAPS2_NONLOCALVIDMEMCAPS;

    ddHALInfo.ddCaps.dwSVBCaps = ddHALInfo.ddCaps.dwCaps;

    ddHALInfo.ddCaps.dwSVBCaps2 = ddHALInfo.ddCaps.dwCaps2;


    ddHALInfo.ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                      DDSCAPS_SYSTEMMEMORY |
                                      DDSCAPS_PRIMARYSURFACE |
                                      DDSCAPS_HWCODEC |
                                      DDSCAPS_OFFSCREENPLAIN |
                                      DDSCAPS_VISIBLE |
                                      DDSCAPS_FLIP |
                                      DDSCAPS_FRONTBUFFER |
                                      DDSCAPS_BACKBUFFER |
                                      DDSCAPS_OVERLAY |
                                      DDSCAPS_ZBUFFER |
                                      DDSCAPS_3DDEVICE |
#ifdef  DX7
                                      DDSCAPS_ALPHA |
#endif  /* DX7 */
                                      DDSCAPS_TEXTURE |
                                      DDSCAPS_MIPMAP;

    ddHALInfo.ddCaps.dwFXAlphaCaps  = 0;

    ddHALInfo.ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT |
                                  DDCKEYCAPS_DESTOVERLAY |
                                  DDCKEYCAPS_DESTOVERLAYONEACTIVE;

    ddHALInfo.ddCaps.dwSVBCKeyCaps = ddHALInfo.ddCaps.dwCKeyCaps;

    ddHALInfo.ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
//                              DDFXCAPS_BLTMIRRORLEFTRIGHT |
                              DDFXCAPS_BLTMIRRORUPDOWN |
                              DDFXCAPS_BLTSHRINKX |
                              DDFXCAPS_BLTSHRINKY |
                              DDFXCAPS_BLTSTRETCHX |
                              DDFXCAPS_BLTSTRETCHY |
#ifdef  DX7
                              DDFXCAPS_BLTALPHA |
                              DDFXCAPS_BLTFILTER |
                              DDFXCAPS_OVERLAYFILTER |
                              DDFXCAPS_OVERLAYMIRRORLEFTRIGHT |
#endif  /* DX7 */
                              DDFXCAPS_OVERLAYMIRRORUPDOWN |
                              DDFXCAPS_OVERLAYSHRINKX |
                              DDFXCAPS_OVERLAYSHRINKY |
                              DDFXCAPS_OVERLAYSTRETCHX |
                              DDFXCAPS_OVERLAYARITHSTRETCHY |
                              DDFXCAPS_OVERLAYSTRETCHY;

    ddHALInfo.ddCaps.dwSVBFXCaps = ddHALInfo.ddCaps.dwFXCaps;



    /*
     * Z buffer bit depths supported
     */

    ddHALInfo.ddCaps.dwZBufferBitDepths = DDBD_16 | DDBD_24;

    /*
     * NV3 Required alignments
     */

    ddHALInfo.ddCaps.dwAlignBoundaryDest = 1;
    /* All video memory surfaces must be aligned with aligned strides */
    ddHALInfo.ddCaps.dwAlignStrideAlign = NV_BYTE_ALIGNMENT;

    /*
     * NV3 stretching capabilities
     */

    ddHALInfo.ddCaps.dwMinOverlayStretch = 100;
    ddHALInfo.ddCaps.dwMaxOverlayStretch = 20000;

    ddHALInfo.ddCaps.dwMinLiveVideoStretch = 100;
    ddHALInfo.ddCaps.dwMaxLiveVideoStretch = 20000;

    ddHALInfo.ddCaps.dwMinHwCodecStretch = 1;
    ddHALInfo.ddCaps.dwMaxHwCodecStretch = 4095000;

    /*
     *  FOURCCs supported
     *
     *  Table address MUST be set in 16 bit portion of Direct Draw Driver but
     *  can add more FOURCC codes to table here if needed.
     */

    ddHALInfo.ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;

    /*
     *  Maximum number of overlays supported
     */

    ddHALInfo.ddCaps.dwMaxVisibleOverlays = 1;

#ifndef WINNT
    /*
     * current video mode, the 16bit driver will fill this out for real.
     */

    ddHALInfo.dwModeIndex = DDUNSUPPORTEDMODE;
#endif // #ifndef WINNT

    /*
     * required byte alignments of the scan lines for each kind of memory
     * (default is 4, NV3 needs 16, NV4 needs 32, NV10 wants 64
     */
    ddHALInfo.vmiData.dwOffscreenAlign = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwOverlayAlign   = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwTextureAlign   = NV_BYTE_ALIGNMENT; /* Texture surface, not our optimized texture */
    ddHALInfo.vmiData.dwAlphaAlign     = NV_BYTE_ALIGNMENT;
    ddHALInfo.vmiData.dwZBufferAlign   = NV_BYTE_ALIGNMENT;

#ifdef NVD3D
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->ThreeDRenderingOccurred = FALSE;

    /*
     * fill out the D3D callbacks
     */
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA*)&ddHALInfo.lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&ddHALInfo.lpD3DHALCallbacks);
#endif


    /*
     * Video Port Capabilities
     */


   ddHALInfo.ddCaps.dwCaps2 |=  DDCAPS2_VIDEOPORT               |
                                DDCAPS2_CANBOBINTERLEAVED       |
                                DDCAPS2_CANBOBNONINTERLEAVED    |
                                DDCAPS2_AUTOFLIPOVERLAY;

    ddHALInfo.ddCaps.dwMaxVideoPorts = ST_MAX_VIDEOPORTS;
    ddHALInfo.ddCaps.dwCurrVideoPorts = 0;
#ifndef WINNT
    ddHALInfo.GetDriverInfo = GetDriverInfo32;
    ddHALInfo.dwFlags |= DDHALINFO_GETDRIVERINFOSET | DDHALINFO_MODEXILLEGAL;
    DPF("Display: Filling in ddHALInfo.GetDriverInfo: %lx", GetDriverInfo32);
#endif // #ifndef WINNT

    return TRUE;

} /* buildDDHALInfo */

/*
 * DriverInit
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver.
 *
 */
DWORD __stdcall DriverInit( DWORD dwDriverData)
{
    DWORD index = 0;

    pDriverData = (GLOBALDATA *)dwDriverData;

    /* Make sure we match the GLOBALDATA structure size of the current display driver */
    if (pDriverData->dwGlobalStructSize < sizeof(GLOBALDATA))
        return(0);

    pDriverData->dwCurrentFrame = 0;
    pDriverData->dwRenderedFrame = 0;
    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->blitCalled = FALSE;

    pDriverData->NvFirstCall = 1;    // let ddEnable32 know this is the first call

#ifdef WINNT
    pDriverData->dwSurfaceAlignPad = pDriverData->ppdev->ulSurfaceAlign;
    pDriverData->dwSurfaceAlign = pDriverData->ppdev->ulSurfaceAlign + 1;
    pDriverData->dwSurfaceBitAlign = pDriverData->ppdev->ulSurfaceBitAlign;
#else
    pDriverData->dwSurfaceAlignPad = NV_BYTE_ALIGNMENT_PAD;
    pDriverData->dwSurfaceAlign =    NV_BYTE_ALIGNMENT;
    pDriverData->dwSurfaceBitAlign = NV_BIT_ALIGNMENT;
#endif    

    /* Some apps call DriverInit during mode switches */
    if (pDriverData->dwDmaPusherCtxDmaSize) {

        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(FALSE);

        pDriverData->dwDmaPusherCtxDmaSize = 0;
    }

    pDriverData->NvAGPDmaPusherBufferBase = 0;
#ifndef WINNT
    // dynamically assign pusher space
    //
    //  >= 60Mb memory gets a 4 meg push buffer
    //          else a 2 meg opush buffer
    //      note - the GlobalMemoryStatus function does not return exact
    //             amounts thus we give it some head room
    {
        MEMORYSTATUS ms;
        ms.dwLength = sizeof(ms);
        GlobalMemoryStatus (&ms);
        if (ms.dwTotalPhys >= 60*1024*1024)
            pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE_LRG;
        else
            pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE;
    }
    #else
        pDriverData->NvDmaPusherBufferSize = NV_DD_DMA_PUSH_BUFFER_SIZE;
    #endif        // #ifdef WINNT
    // Reset in case of a mode switch which unloaded the driver
    pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

    pDriverData->extra422OverlayOffset[0] = 0;
    pDriverData->extra422OverlayOffset[1] = 0;

    pDriverData->dwOverlayOwner = 0;

    pDriverData->dwOverlaySurfaces = 0;

    while (index < NV_MAX_OVERLAY_SURFACES)
        pDriverData->dwOverlaySurfaceLCL[index++] = 0;

    pDriverData->dwVideoPortsAvailable = 1;

    pDriverData->OverlayColourControl.dwSize = sizeof(DDCOLORCONTROL);
    pDriverData->OverlayColourControl.dwFlags = DDCOLOR_CONTRAST;
    pDriverData->OverlayColourControl.lBrightness = 0;
    pDriverData->OverlayColourControl.lContrast = 0xFF;
    pDriverData->OverlayColourControl.lHue = 0;
    pDriverData->OverlayColourControl.lSaturation = 0xFF;
    pDriverData->OverlayColourControl.lGamma = 0xFF;
    pDriverData->OverlayColourControl.lColorEnable = 1;

#ifdef FORCED_TRIPLE_BUFFER
    pDriverData->bNeedToAttachBuffer = FALSE;
    pDriverData->lpBuffer3 = NULL;
#endif

    buildDDHALInfo32();

    DPF( "    Successfully built 32 bit HAL Info" );

    pDriverData->DDrawVideoSurfaceCount = 0;

    // Set the reset flag here for a future call to ResetNV
    // Don't do the call here because we don't neccessarily now about AGP memory yet.
    pDriverData->fReset = TRUE;
//    if (pDriverData->fReset == FALSE) {
//        ResetNV();
//    }

    // Can't reinitialize NV here because mode change may not have happened yet.

#ifndef WINNT // BUGBUG -- no vpe for nt right now.
    // this call is for VPE/KMVT stuff, to hook up with and initialize their storage
        HookUpVxdStorage();
#else
#if _WIN32_WINNT >= 0x0500
        if (pDriverData->ppdev->AgpHeapBase)
            {
            LPDDRAWI_DIRECTDRAW_GBL     pdrv = NULL;
            //*******************************************************
            // Initialize GLOBALDATA's copy of AGP base address.
            //*******************************************************
            pDriverData->GARTLinearBase = pDriverData->ppdev->AgpHeapBase;

            //********************************************************
            // Alloc AGP DMA Push Buffer
            //********************************************************
            pDriverData->NvAGPDmaPusherBufferBase =
                (ULONG) pDriverData->GARTLinearBase +
                (ULONG) pDriverData->ppdev->DmaPushBufTotalSize;
                    //pDriverData->NvDmaPusherBufferSize;
            }
#endif // #if _WIN32_WINNT >= 0x0500
#endif  // !WINNT


    return dwDriverData;

} /* DriverInit */


#ifndef WINNT
/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpvReserved)
{
    hInstance = hModule;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH:
#ifndef WINNT
        DisableThreadLibraryCalls( hModule );
#endif // #ifndef WINNT
#ifdef  NVD3D
        init_globals();
#endif  // NVD3D
        break;

    case DLL_PROCESS_DETACH:
#ifdef  NVD3D
        // Destroy Item Arrays
        DestroyItemArrays ();
        DestroyIPM();
#endif  // NVD3D
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */

/*
 * D3D DX5 Draw Primitive entry points
 */
DWORD __stdcall DrawOnePrimitive32(LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdopd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawOnePrimitive32 - Bad Context");
        pdopd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);
#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdopd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return (nvDrawOnePrimitive(pdopd));
}

DWORD __stdcall DrawOneIndexedPrimitive32(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdoipd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawOneIndexedPrimitive32 - Bad Context");
        pdoipd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdoipd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif
    return (nvDrawOneIndexedPrimitive(pdoipd));
}

DWORD __stdcall DrawPrimitives32(LPD3DHAL_DRAWPRIMITIVESDATA pdpd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdpd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:DrawPrimitives32 - Bad Context");
        pdpd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdpd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return (nvDrawPrimitives(pdpd));
}
DWORD __stdcall Clear32(LPD3DHAL_CLEARDATA pcd)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pcd->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:Clear32 - Bad Context");
        pcd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#if 0 // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */

//    if ((pcd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
//        return (DDHAL_DRIVER_HANDLED);
    /*
     * Wait until the flip has occurred, otherwise we will start clearing the buffer while
     * it is still visible.
     */
    while ((pcd->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK);
#endif

    return (nvClear(pcd));
}
#endif
#ifdef  NVD3D_DX6
DWORD FAR PASCAL DrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pdp2d->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:nvDrawPrimitives2 - Bad Context");
        pdp2d->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pCurrentContext->lpLcl)
    {
        pdp2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pDriverData->NvDevFlatDma)
    {
        pdp2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#ifdef  WINNT // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */
    if ((pdp2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
        return (DDHAL_DRIVER_HANDLED);
#endif

    return(nvDrawPrimitives2(pdp2d));
}
DWORD FAR PASCAL Clear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    /*
     * Get the pointer to the D3D context data.
     */
    pCurrentContext = (PNVD3DCONTEXT)pc2d->dwhContext;
    if (!pCurrentContext)
    {
        DPF("D3D:Clear2 - Bad Context");
        pc2d->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pCurrentContext->lpLcl)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (!pDriverData->NvDevFlatDma)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    NvSetDriverDataPtrFromContext(pCurrentContext);

#ifdef  WINNT // D3D will take care of waiting for flip by itself
    /*
     * Check if this surface is waiting to be flipped.  If it is, then
     * return to D3D and let it do the right thing.
     */

//    if ((pc2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK)
//        return (DDHAL_DRIVER_HANDLED);

    /*
     * Wait until the flip has occurred, otherwise we will start clearing the buffer while
     * it is still visible.
     */
    while ((pc2d->ddrval = updateFlipStatus(pCurrentContext->lpLcl->lpGbl->fpVidMem)) != DD_OK);
#endif
    return(nvClear2(pc2d));
}

/*
 * WaitForVSync
 */
void WaitForVSync (void)
{
    HRESULT ddrval;

    /*
     * wait until flip has occurred
     */
    for (;;)
    {
        ddrval = updateFlipStatus(0);
        if (ddrval == DD_OK) break;
    }
}

#endif

/*
 * DPF debug stuff
 */
#ifdef DEBUG

#define START_STR       "NVDD32: "
#define END_STR         "\r\n"

/*
 * Msg
 */
#ifndef WINNT
void __cdecl DPF(LPSTR szFormat, ...)
{
    char str[256];

    lstrcpy(str, START_STR);
    wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, END_STR);
    OutputDebugString(str);
}
#else
void __cdecl DPF(LPSTR szFormat, ...)
{
    va_list ap;

    va_start(ap, szFormat);
    EngDebugPrint(START_STR, szFormat, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}
#endif // #ifdef WINNT

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\disablec.c ===
/*
 ***************************************************************************
 *                                                                         *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.     *
 *                                                                         *
 ***************************************************************************
 */

/* NvDDDisable32() */

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"

#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  /* MULTI_MON */

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR


/*
 * NvDDDisable32()
 *
 */

int
NvDDDisable32()
{
   FAST Nv4ControlDma *npDev = (Nv4ControlDma *)pDriverData->NvDevFlatDma;
   Nv3ChannelPio *npDevVideo;
   long videoFreeCount;
   unsigned long *dmaPusherPutAddress =
       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long *dmaPusherBufferBase =
       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
   NvNotification *npDmaSyncNotifier =
       (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
#ifdef  CACHE_FREECOUNT
   long freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   long freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   /*
    * Ensure the push buffer has completed prior to deleting objects
    * which it might reference.
    */

   while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   npDmaSyncNotifier->status = NV_IN_PROGRESS;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
   dmaPusherPutAddress[1] = 0;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = 0;

   dmaPusherPutAddress += 4;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifndef MULTI_MON
   while (freeCount < 14)
       NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
   freeCount -= 14;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 14;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_IN_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_DESTROY_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

   dmaPusherPutAddress += 4;

#endif  /* MULTI_MON */

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_ROP) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_PATTERN) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_IMAGE_BLACK_RECTANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_BETA_SOLID) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_CONTEXT_BETA4) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ROP_GDI_RECT_AND_TEXT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_RECT_AND_TEXT) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ALT_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SRCCOPY_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_STRETCHED_UV_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU) != NVOS00_STATUS_SUCCESS)
            return(0);

   if (pDriverData->bi.biBitCount > 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                return(0);

       if (pDriverData->bi.biBitCount > 16) {

        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
        if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(0);
       }
   }
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_IMAGE_BLIT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SRCCOPY_IMAGE_BLIT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SURFACES_2D) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (pDriverData->bi.biBitCount == 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
            return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
            return(0);
   }

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
           NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT) != NVOS00_STATUS_SUCCESS)
               return(0);

   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   pDriverData->dwDmaPusherFreeCount = freeCount;

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   /* Wait for destruction to complete */
   while (npDev->Get != (unsigned long)((dmaPusherPutAddress - dmaPusherBufferBase) << 2));

   /* Destroy the D3D objects */
   nvD3DDestroyObjects();

   /*
    * Now destroy objects in video channel
    */

   npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

   videoFreeCount = pDriverData->NvVideoFreeCount;

#ifndef MULTI_MON
   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 24;

   npDevVideo->subchannel[0].SetObject = NV_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Destroy = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Destroy = NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   npDevVideo->subchannel[1].SetObject = NV_CONTEXT_DMA_FROM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Destroy = NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Destroy = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
#endif  /* MULTI_MON */

   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_YUV422_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_SINK) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_VIDEO_SCALER) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_VIDEO_SCALER) != NVOS00_STATUS_SUCCESS)
               return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
           NV_DD_P_V_VIDEO_COLOR_KEY) != NVOS00_STATUS_SUCCESS)
               return(0);

#ifdef WINNT
   /*
    * Destroy NV4 DVD subpicture object in both DMA Push and PIO
    * channels. Don't know why the destruction of these objects was
    * not in the common code.
    */
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_DVD_SUBPICTURE) != NVOS00_STATUS_SUCCESS)
        return(0);
   if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_DVD_SUBPICTURE) != NVOS00_STATUS_SUCCESS)
        return(0);
#endif // WINNT

   if (pDriverData->bi.biBitCount == 8) {
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
            NV_DD_P_V_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
                    return(0);
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
            NV_DD_SHARED_VIDEO_COLORMAP) != NVOS00_STATUS_SUCCESS)
                    return(0);
   }

   pDriverData->NvVideoFreeCount = (unsigned short)videoFreeCount;

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4clear.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4CLEAR.C                                                        *
*   NV4 Buffer Clear routines.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

void nvSetClearSurface
(
    DWORD   dwDstOffset,
    DWORD   dwDstPitch,
    DWORD   dwDstFormat,
    DWORD   dwRectFormat,
    DWORD   dwFillValue
)
{
#ifdef  DDPUSH_0
    /*
     * Set the destination surface to be cleared.
     */
    while (nvFreeCount < (sizeSetRop5 + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeDrawRopRectAndTextColor1A))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, (sizeSetRop5 + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeDrawRopRectAndTextColor1A));
    nvglSetRop5(nvFifo, nvFreeCount, NV_DD_ROP, SRCCOPYINDEX);
    nvglSet2DSurfacesDestination(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstOffset);
    nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstFormat);
    nvglSet2DSurfacesPitch(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstPitch, dwDstPitch);
    nvglDrawRopRectAndTextColor1A(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, dwFillValue);
#else   // D3D Channel
    /*
     * Set the destination surface to be cleared.
     */
    while (nvFreeCount < (sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor));
    nvglSet2DSurfacesDestination(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstOffset);
    nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstFormat);
    nvglSet2DSurfacesPitch(nvFifo, nvFreeCount, NV_DD_SURFACES, dwDstPitch, dwDstPitch);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleColorFormat(nvFifo, nvFreeCount, NV_DD_SPARE, dwRectFormat);
    nvglNv4SolidRectangleColor(nvFifo, nvFreeCount, NV_DD_SPARE, dwFillValue);
    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;
#endif
    return;
}
void nvReset2DSurfaceFormat
(
    void
)
{
    while (nvFreeCount < sizeSet2DSurfacesColorFormat)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSet2DSurfacesColorFormat);

    if (pDriverData->bi.biBitCount == 8)
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y8);
    }
    else if (pDriverData->bi.biBitCount == 16)
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
    }
    else
    {
        nvglSet2DSurfacesColorFormat(nvFifo, nvFreeCount, NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    }
    return;
}
void nvClearSurfaceRect
(
    DWORD   startx,
    DWORD   starty,
    DWORD   width,
    DWORD   height
)
{
#ifdef  DDPUSH_0
    /*
     * Clear the specified rectangle.
     */
    while (nvFreeCount < sizeDrawRopRectAndTextPointSize)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, sizeDrawRopRectAndTextPointSize);
    nvglDrawRopRectAndTextPointSize(nvFifo, nvFreeCount, NV_DD_ROP_RECT_AND_TEXT, startx, starty, width, height);
#else   // D3D Channel
    /*
     * Clear the specified rectangle.
     */
    while (nvFreeCount < sizeNv4SolidRectanglePointSize)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeNv4SolidRectanglePointSize);
    nvglNv4SolidRectanglePointSize(nvFifo, nvFreeCount, NV_DD_SPARE, startx, starty, width, height);
#endif  // D3D Channel
    return;
}

BOOL nvD3DClearZBuffer
(
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl,
    DWORD                       dwFillDepth
)
{
    DWORD                       dwDstOffset;
    DWORD                       dwDstPitch;
    DWORD                       startx = 0;
    DWORD                       starty = 0;
    DWORD                       width, height;
    DWORD                       dwBitCount;
    DWORD                       dwRectColorFormat;
    DWORD                       dwSurfColorFormat;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvD3DClearZBuffer");

    if (!lpLcl)
        return(FALSE);

#if D3D_PUSH
#ifdef  D3D_HARDWARE
    if (!pDriverData->NvDevFlatDma)
        return (FALSE);
#endif  // D3D_HARDWARE
#endif  // D3DPUSH

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();


    dst         = lpLcl->lpGbl;
    dwDstOffset = dst->fpVidMem - pDriverData->BaseAddress;
    dwDstPitch  = dst->lPitch;
    width       = (DWORD)dst->wWidth;
    height      = (DWORD)dst->wHeight;

    /*
     * Anti-Aliasing
     */
    if (pCurrentContext
     && pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        pCurrentContext->dwAntiAliasFlags    |= AA_CLEAR_SCREEN;
        pCurrentContext->pAAContext->dwZFill  = dwFillDepth;
        return TRUE;
    }

    if (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        dwBitCount = lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
    else
        dwBitCount = pDriverData->bi.biBitCount;
    switch (dwBitCount)
    {
        case 16:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
            break;
        case 24:
        case 32:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
            break;
    }
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
    nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillDepth);
    nvClearSurfaceRect(startx, starty, width, height);
    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    //nvStartDmaBuffer();
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    return (TRUE);
}

/*
 * Clear render target and zeta-buffer in single call.
 */
DWORD nvClear
(
    LPD3DHAL_CLEARDATA  pcd
)
{
    DWORD dwDstOffset;
    DWORD dwDstPitch;
    DWORD dwRectColorFormat;
    DWORD dwSurfColorFormat;

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvClear - hContext = %08lx", pcd->dwhContext);
    if (!pCurrentContext->lpLcl)
    {
        pcd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pcd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pcd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Get the format of the surface being cleared.
     */
    switch (DRF_VAL(053, _SET_FORMAT, _COLOR, pCurrentContext->dwSurfaceFormat))
    {
        case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5:
        case NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5:
        case NV053_SET_FORMAT_COLOR_LE_R5G6B5:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
            break;
        case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8:
        case NV053_SET_FORMAT_COLOR_LE_A8R8G8B8:
            dwRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
            break;
    }

    /*
     * Anti-Aliasing
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        if (pcd->dwFlags & D3DCLEAR_TARGET)
        {
            if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                pCurrentContext->pAAContext->dwCFill = ((pcd->dwFillColor & 0x00F80000) >> 8)
                                                     | ((pcd->dwFillColor & 0x0000F800) >> 5)
                                                     | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                pCurrentContext->pAAContext->dwCFill = pcd->dwFillColor;
        }
        if (pcd->dwFlags & D3DCLEAR_ZBUFFER) pCurrentContext->pAAContext->dwZFill = pcd->dwFillDepth;

        if (!(pCurrentContext->dwAntiAliasFlags & AA_COPY_SCREEN))
        {
            pCurrentContext->dwAntiAliasFlags |= AA_CLEAR_SCREEN;
            pcd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef NV_CONTROLTRAFFIC
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_CONTROLTRAFFIC)
    {
        if ((pcd->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET)) == D3DCLEAR_ZBUFFER)
        {
            DWORD f = pCurrentContext->dwCTFlags;
            BOOL  x;

            if (f & NV_CT_ENABLED)
            {
                if (f & NV_CT_DRAWPRIM) f ^= NV_CT_FRONT | NV_CT_DRAWPRIM;
                x = TRUE;
            }
            else
            {
                if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                {
                    f |= (pcd->dwFillDepth & 0x8000) ? (NV_CT_FRONT | NV_CT_ENABLED)
                                                     : (              NV_CT_ENABLED);
                }
                else
                {
                    f |= (pcd->dwFillDepth & 0x80000000) ? (NV_CT_FRONT | NV_CT_ENABLED)
                                                         : (              NV_CT_ENABLED);
                }
                f &= ~NV_CT_DRAWPRIM;
                x  = FALSE;
            }
            pCurrentContext->dwCTFlags = f;

            NV_FORCE_TRI_SETUP (pCurrentContext);
            if (x)
            {
                pcd->ddrval = DD_OK;
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        else
        {
            pCurrentContext->dwCTFlags = NV_CT_DISABLED;
            NV_FORCE_TRI_SETUP (pCurrentContext);
        }
    }
    else
    {
        pCurrentContext->dwCTFlags = NV_CT_DISABLED;
    }
#endif //NV_CONTROLTRAFFIC

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

    /*
     * Make sure the context has the correct suface information in it.
     */
    pCurrentContext->dwSurfaceAddr = 0;
    if (dbgFrontRender)
    {
#ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
        pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
        pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
    }
    else
    {
#ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
        pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
        pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem - pDriverData->BaseAddress);
        pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
    }

    pCurrentContext->ZBufferAddr = 0;
    if (pCurrentContext->lpLclZ)
    {
        /*
         * I've seen it happen where the location of the z-buffer will actually
         * change without without the context being destroyed or the set render
         * target call happening. So it's neccessary to make sure that we have the
         * correct z-buffer address and offset here.
         */
    #ifdef WINNT
        if (pCurrentContext->lpLcl->lpGbl->lPitch)
    #endif
        pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
        pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
        pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
    }

    if ((pcd->dwFlags & D3DCLEAR_ZBUFFER)
     && (pCurrentContext->lpLclZ && pCurrentContext->lpLclZ->lpGbl)
     && (pCurrentContext->ZBufferAddr))
    {
        DWORD dwFillDepth = pcd->dwFillDepth;

        /*
         * Normal (not AA)
         */
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            dwDstOffset = pCurrentContext->ZBufferOffset;
            dwDstPitch  = (DWORD)pCurrentContext->surfacePitch.wZetaPitch;

            if (dwNumRects)
            {
                /*
                 * Set the destination surface to be cleared.
                 */
                nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillDepth);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = lpRects->x1;
                    starty = lpRects->y1;
                    width  = lpRects->x2 - startx;
                    height = lpRects->y2 - starty;

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }
    }

    if ((pcd->dwFlags & D3DCLEAR_TARGET)
     && (pCurrentContext->lpLcl && pCurrentContext->lpLcl->lpGbl)
     && (pCurrentContext->dwSurfaceAddr))
    {
        DWORD       dwFillColor;
        DWORD       dwNumRects  = pcd->dwNumRects;
        LPD3DRECT   lpRects     = pcd->lpRects;

        if (dwSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
            /*
             * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
             */
            dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                        | ((pcd->dwFillColor & 0x0000F800) >> 5)
                        | ((pcd->dwFillColor & 0x000000F8) >> 3);
        else
            dwFillColor = pcd->dwFillColor;

        dwDstOffset = pCurrentContext->dwSurfaceOffset;
        dwDstPitch  = (DWORD)pCurrentContext->surfacePitch.wColorPitch;

        /*
         * Clear the rendering target.
         * Send the correct default objects for all the subchannels
         * just to be safe.
         */
        if (dwNumRects)
        {
            /*
             * Set the destination surface to be cleared.
             */
            nvSetClearSurface(dwDstOffset, dwDstPitch, dwSurfColorFormat, dwRectColorFormat, dwFillColor);
            while (dwNumRects)
            {
                DWORD startx, starty;
                DWORD width, height;

                /*
                 * Get the next rectangle to clear.
                 */
                startx = lpRects->x1;
                starty = lpRects->y1;
                width  = lpRects->x2 - startx;
                height = lpRects->y2 - starty;

                /*
                 * Use the hardware to do the clear.
                 */
                nvClearSurfaceRect(startx, starty, width, height);

                /*
                 * Move to the next rectangle.
                 */
                lpRects++;
                dwNumRects--;
            }
        }
    }
    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    //nvStartDmaBuffer();
    dbgFlushDDI(pCurrentContext);
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#endif  // CACHE_FREECOUNT

    pcd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

#ifdef  NVD3D_DX6
/*
 * DX6 callback for clearing render target, z-buffer and stencil buffer.
 */
DWORD nvClear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    DWORD       dwFlags;
    DWORD       dwFillColor;
    DWORD       dwFillStencil;
    DWORD       dwNumRects;
    DWORD       dwTextureOffset, dwTextureFormat, dwTextureFilter;
    DWORD       dwCombine0Alpha, dwCombine0Color;
    DWORD       dwCombine1Alpha, dwCombine1Color;
    DWORD       dwCombineFactor, dwBlend, dwFogColor;
    DWORD       dwControl0, dwControl1, dwControl2;
    D3DVALUE    dvFillDepth;
    D3DVALUE    dvX1, dvY1, dvX2, dvY2;
    LPD3DRECT   lpRects;
    D3DTLVERTEX tlvVertex;

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvClear2 - hContext = %08lx", pc2d->dwhContext);

    if (!pDriverData->NvDevFlatDma)
    {
        pc2d->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pc2d->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    // this is to fix some stupid WHQL bug. basically, they care what's stored in fields
    // that technically don't even exist. we have to make sure that alpha gets cleared to
    // zero when there isn't one.
    dwFillColor = pc2d->dwFillColor;
    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8)))) {
        dwFillColor &= 0x00ffffff;
    }

    /*
     * if we do not have stencil, use faster clears
     */
    if (!(pc2d->dwFlags & D3DCLEAR_STENCIL))
    {
        /*
         * 16-bit
         */
        if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
         || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        {
            D3DHAL_CLEARDATA cd;

            cd.dwhContext  = pc2d->dwhContext;
            cd.dwFlags     = pc2d->dwFlags & ~D3DCLEAR_STENCIL;
            cd.dwFillColor = dwFillColor;
            cd.dwFillDepth = (DWORD)(pc2d->dvFillDepth * 65535.0f); // convert to 16-bit number
            cd.lpRects     = pc2d->lpRects;
            cd.dwNumRects  = pc2d->dwNumRects;

            nvClear (&cd);

            pc2d->ddrval = cd.ddrval;
            return DDHAL_DRIVER_HANDLED;
        }
        else
        /*
         * 32-bit (assumed if not 16-bit)
         */
        {
            D3DHAL_CLEARDATA cd;
            __int64          fd;

            /*
             * Can only do a fast clear of zbuffer if this is not a not a stencil buffer.
             */
            if ((pc2d->dwFlags & D3DCLEAR_ZBUFFER)
             && ((pCurrentContext->lpLclZ)
              && (pCurrentContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT)
              && (pCurrentContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER)))
                goto labelSlowClear;

            /*
             * It's ok to do a fast clear of the z-buffer.
             */
            fd = (__int64)((double)pc2d->dvFillDepth * (double)4294967295.0); // convert to 32-bit number
            if (fd > 0xffffffff) fd = 0xffffffff;
            if (fd < 0)          fd = 0;

            cd.dwhContext  = pc2d->dwhContext;
            cd.dwFlags     = pc2d->dwFlags & ~D3DCLEAR_STENCIL;
            cd.dwFillColor = dwFillColor;
            cd.dwFillDepth = (DWORD)fd;
            cd.lpRects     = pc2d->lpRects;
            cd.dwNumRects  = pc2d->dwNumRects;

            nvClear (&cd);

            pc2d->ddrval = cd.ddrval;
            return DDHAL_DRIVER_HANDLED;
        }
    }

labelSlowClear:
    dwFlags       = pc2d->dwFlags;
    dvFillDepth   = pc2d->dvFillDepth;
    dwFillStencil = pc2d->dwFillStencil;
    lpRects       = pc2d->lpRects;
    dwNumRects    = pc2d->dwNumRects;

    if (dwNumRects)
    {
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#else  // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * Make sure the surface is set up correctly.
         */
        pCurrentContext->dwSurfaceAddr = 0;
        if (dbgFrontRender)
        {
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
            pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
            pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
        }
        else
        {
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
            pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem);
            pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
        }
        pCurrentContext->ZBufferAddr = 0;
        if (pCurrentContext->lpLclZ)
        {
            /*
             * I've seen it happen where the location of the z-buffer will actually
             * change without without the context being destroyed or the set render
             * target call happening. So it's neccessary to make sure that we have the
             * correct z-buffer address and offset here.
             */
#ifdef WINNT
            if (pCurrentContext->lpLcl->lpGbl->lPitch)
#endif
            pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
            pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
            pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
        }

        /*
         * Call the routine to set the surface if neccessary.
         */
        pDriverData->lpLast3DSurfaceRendered = 0; // force setting of surface.
        nvSetD3DSurfaceState(pCurrentContext);

        /*
         * Determine the triangle setup for the fill being done.
         */
        dwTextureOffset = pCurrentContext->dwDefaultTextureOffset;
        dwTextureFormat = DRF_NUM(055, _FORMAT,          _CONTEXT_DMA,          pCurrentContext->dwDefaultTextureContextDma)
                        | DRF_NUM(055, _FORMAT,          _COLOR,                pCurrentContext->dwDefaultTextureColorFormat)
                        | DRF_NUM(055, _FORMAT,          _MIPMAP_LEVELS,        1)
                        | DRF_DEF(055, _FORMAT,          _BASE_SIZE_U,          _1)
                        | DRF_DEF(055, _FORMAT,          _BASE_SIZE_V,          _1)
                        | DRF_DEF(055, _FORMAT,          _TEXTUREADDRESSU,      _CLAMP)
                        | DRF_DEF(055, _FORMAT,          _WRAPU,                _FALSE)
                        | DRF_DEF(055, _FORMAT,          _TEXTUREADDRESSV,      _CLAMP)
                        | DRF_DEF(055, _FORMAT,          _WRAPV,                _FALSE)
                        | DRF_DEF(055, _FORMAT,          _ORIGIN_ZOH,           _CENTER)
                        | DRF_DEF(055, _FORMAT,          _ORIGIN_FOH,           _CENTER);
        dwTextureFilter = DRF_DEF(055, _FILTER,          _MIPMAP_DITHER_ENABLE, _TRUE)
                        | DRF_NUM(055, _FILTER,          _MIPMAPLODBIAS,        1)
                        | DRF_DEF(055, _FILTER,          _TEXTUREMIN,           _NEAREST)
                        | DRF_DEF(055, _FILTER,          _TEXTUREMAG,           _NEAREST);
        dwCombine0Alpha = DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,            _ADD);
        dwCombine0Color = DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1,           _DIFFUSE)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,              _COLOR)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,            _ADD);
        dwCombine1Alpha = DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1,           _INPUT)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,            _ADD);
        dwCombine1Color = DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0,           _INPUT)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,            _INVERSE)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,            _NORMAL)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,              _COLOR)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3,           _ZERO)
                        | DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,            _ADD);
        dwCombineFactor = 0;
        dwBlend         = DRF_DEF(055, _BLEND,           _MASK_BIT,             _MSB)
                        | DRF_DEF(055, _BLEND,           _SHADEMODE,            _FLAT)
                        | DRF_DEF(055, _BLEND,           _TEXTUREPERSPECTIVE,   _TRUE)
                        | DRF_DEF(055, _BLEND,           _SPECULARENABLE,       _FALSE)
                        | DRF_DEF(055, _BLEND,           _FOGENABLE,            _FALSE)
                        | DRF_DEF(055, _BLEND,           _ALPHABLENDENABLE,     _TRUE);
        dwControl0      = DRF_NUM(055, _CONTROL0,        _ALPHAREF,             0)
                        | DRF_DEF(055, _CONTROL0,        _ALPHAFUNC,            _ALWAYS)
                        | DRF_DEF(055, _CONTROL0,        _ALPHATESTENABLE,      _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _ORIGIN,               _CENTER)
                        | DRF_DEF(055, _CONTROL0,        _CULLMODE,             _NONE)
                        | DRF_DEF(055, _CONTROL0,        _DITHERENABLE,         _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _ALPHA_WRITE_ENABLE,   _FALSE)
                        | DRF_DEF(055, _CONTROL0,        _RED_WRITE_ENABLE,     _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _GREEN_WRITE_ENABLE,   _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _BLUE_WRITE_ENABLE,    _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _ZENABLE,              _TRUE)
                        | DRF_DEF(055, _CONTROL0,        _ZFUNC,                _ALWAYS);
        dwFogColor      = 0;

        /*
         * Fill in the static fields of the TLVertex data structure.
         */
        tlvVertex.sz       = dvFillDepth;
        tlvVertex.rhw      = 1.0f;
        tlvVertex.color    = dwFillColor;
        tlvVertex.specular = 0xFF000000;
        tlvVertex.tu       = 0.0f;
        tlvVertex.tv       = 0.0f;

        /*
         * Enable the buffers that are being cleared.
         */
        if ((dwFlags & D3DCLEAR_TARGET)
         && (pCurrentContext->dwSurfaceAddr))
        {
            dwBlend |= DRF_DEF(055, _BLEND,    _SRCBLEND,  _ONE)
                    |  DRF_DEF(055, _BLEND,    _DESTBLEND, _ZERO);
        }
        else
        {
            dwBlend |= DRF_DEF(055, _BLEND,    _SRCBLEND,  _ZERO)
                    |  DRF_DEF(055, _BLEND,    _DESTBLEND, _ONE);
        }

        if ((dwFlags & D3DCLEAR_ZBUFFER)
         && (pCurrentContext->ZBufferAddr))
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _TRUE);
            /*
             * Scale the fill value if this is a w-buffer.
             */
            if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
            {
                dwControl0 |= DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                           |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
            }
            else
            {
#ifdef  FLOAT_W
                // floating point w-buffer.
                dwControl0 |= DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                           |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FLOAT);
                tlvVertex.sz  *= pCurrentContext->dvWFar;
#else
                // fixed point w-buffer.
                dwControl0 |= DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                           |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
#endif
            }
        }
        else
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                       |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                       |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }

        if ((dwFlags & D3DCLEAR_STENCIL)
         && (pCurrentContext->ZBufferAddr))
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);

            dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE,  _TRUE)
                       | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,         _ALWAYS)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_REF,          dwFillStencil)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,    0xFF)
                       | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,   0xFF);
            dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,      _REPLACE)
                       | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL,     _REPLACE)
                       | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS,     _REPLACE);
        }
        else
        {
            dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
            dwControl1  = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE,  _FALSE)
                        | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,         _NEVER)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_REF,          0)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,    0)
                        | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,   0);
            dwControl2  = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,      _KEEP)
                        | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL,     _KEEP)
                        | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS,     _KEEP);
        }

        /*
         * Send the triangle rendering state to the hardware.
         */
        while (nvFreeCount < (sizeSetObject + sizeDX6TriangleState))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, (sizeSetObject + sizeDX6TriangleState));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureOffset, 0);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureOffset, 1);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFormat, 0);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFormat, 1);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFilter, 0);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, dwTextureFilter, 1);
        nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR,
                                  dwCombine0Alpha, dwCombine0Color,
                                  dwCombine1Alpha, dwCombine1Color,
                                  dwCombineFactor, dwBlend,
                                  dwControl0,      dwControl1,
                                  dwControl2,      dwFogColor);

        /*
         * Now clear the buffers.
         */
        while (dwNumRects)
        {
            /*
             * Get the Upper Left and Lower Right fill coordinates as D3DVALUEs.
             */
            dvX1 = (D3DVALUE)lpRects->x1;
            dvY1 = (D3DVALUE)lpRects->y1;
            dvX2 = (D3DVALUE)lpRects->x2;
            dvY2 = (D3DVALUE)lpRects->y2;

            while (nvFreeCount < ((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive))
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, ((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive));


            /*
             * Send the fill rectangle down as two triangles and double kickoff.
             * Upper Left Vertex = i0
             */
            tlvVertex.sx = dvX1;
            tlvVertex.sy = dvY1;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 0, tlvVertex);

            /*
             * Upper Right Vertex = i1
             */
            tlvVertex.sx = dvX2;
            tlvVertex.sy = dvY1;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 1, tlvVertex);

            /*
             * Lower Right Vertex = i2
             */
            tlvVertex.sx = dvX2;
            tlvVertex.sy = dvY2;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 2, tlvVertex);

            /*
             * Lower Left Vertex = i3
             */
            tlvVertex.sx = dvX1;
            tlvVertex.sy = dvY2;
            nvglDx6TriangleTLVertex(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 3, tlvVertex);

            /*
             * Kick off two triangles (i0, i1, i2) and (i0, i2, i3)
             */
            nvglDx6TriangleDrawPrimitive(nvFifo, nvFreeCount, NV_DD_TRANSCOLOR, 3, 0x00320210);

            /*
             * Move to the next rectangle.
             */
            lpRects++;
            dwNumRects--;
        }
        /*
         * Kick off the fills.
         */
        //nvStartDmaBuffer();
        dbgFlushDDI(pCurrentContext);

        /*
         * Clear the dDrawSpareSubchannel6Object.  This will force the channel to
         * be reloaded or the next use of the DX6_MULTI_TEXTURE_TRIANGLE to reload
         * the state.
         */
        pDriverData->dDrawSpareSubchannel6Object = 0;
        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }
    pc2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  NVD3D_DX6

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\ENABLEC.C ===
/*
 ***************************************************************************
 *                                                                         *
 *  Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.     *
 *                                                                         *
 ***************************************************************************
 */

/* NvDDEnable32() */

#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "ddrvmem.h"
#include "d3dinc.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#else   /* MULTI_MON */
#define NV_ERROR_NOTIFIER          0x0FF5
#endif  /* MULTI_MON */

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR

/*
 * NvDDEnable32()
 *
 */

int
NvDDEnable32()
{
   NvNotification *npPioDmaToMemNotifier;
   NvNotification *npPioFlipOverlayNotifier;
   NvNotification *npDmaDmaToMemNotifier;
   NvNotification *npDmaDmaFromMemNotifier;
   NvNotification *npDmaFlipPrimaryNotifier;
   NvNotification *npDmaPusherSyncNotifier;
   NvNotification *npDmaSyncNotifier;
   FAST Nv4ControlDma *npDev;
   Nv3ChannelPio *npDevVideo;
   unsigned long temp;
   FAST long videoFreeCount;
   int pxlDepth;
   unsigned long *dmaPusherPutAddress =
       (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long *dmaPusherBufferBase =
       (unsigned long *)pDriverData->NvDmaPusherBufferBase;
   long freeCount;
   DWORD tmpIndex;

   npDev = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

   pxlDepth = pDriverData->bi.biBitCount;

   /*
    * Allocate DMA notifiers and pixel/texel buffers
    *
    * Request 8 pages (NV_DD_COMMON_DMA_BUFFER_SIZE bytes) of memory.
    * Allows 2 buffers where 1 buffer can use
    * (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 4))/2 bytes
    * with up to 16 separate notifiers at the beginning of the buffer.
    *
    * Actual memory allocation done it 16 bit portion of driver.
    */

   pDriverData->NvDmaDmaToMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvDmaBufferNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvDmaDmaFromMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 1);

   pDriverData->NvDmaPusherSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 1) + sizeof(NvNotification);

   pDriverData->NvDmaSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 2);

   /* Notifier array offsets 5, 6, 7, 8, and 9 */
   pDriverData->NvDmaFlipPrimaryNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 2) + sizeof(NvNotification);

//   /* Notifier array offsets A, B, C, D, and E */
//   pDriverData->NvPioFlipOverlayNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 1);

   /* Notifier array offset (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 2) + (sizeof(NvNotification) << 1) + sizeof(NvNotification) currently unused */

   pDriverData->NvScanlineBufferFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 4);

   npDmaDmaToMemNotifier = (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;
   npDmaDmaFromMemNotifier = (NvNotification *)pDriverData->NvDmaDmaFromMemNotifierFlat;
   npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;
   npDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;
   npDmaFlipPrimaryNotifier = (NvNotification *)pDriverData->NvDmaFlipPrimaryNotifierFlat;

   /* Deal with possible mode change during pending flip */
   if (npDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
   }

   /* MUST MAKE SURE STATUS FLAG IS CLEAR BEFORE INITIAL USE */

   npDmaDmaToMemNotifier->status = 0;

   npDmaDmaFromMemNotifier->status = 0;

   npDmaSyncNotifier->status = 0;

   npDmaFlipPrimaryNotifier[1].status = 0;
   npDmaFlipPrimaryNotifier[2].status = 0;


   /* First create some objects */

   freeCount = 0;

#ifndef MULTI_MON
   while (freeCount < 14)
       NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
   freeCount -= 14;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 14;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_IN_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

   dmaPusherPutAddress += 4;

#endif  /* MULTI_MON */
   /*
    * Create ddraw objects.
    */
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_ROP, NV3_CONTEXT_ROP) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_PATTERN, NV4_CONTEXT_PATTERN) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_BLACK_RECTANGLE, NV1_IMAGE_BLACK_RECTANGLE) != NVOS05_STATUS_SUCCESS)
    return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_COLOR_KEY, NV4_CONTEXT_COLOR_KEY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_BETA_SOLID, NV1_BETA_SOLID) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_CONTEXT_BETA4, NV4_CONTEXT_BETA) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ROP_GDI_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ALT_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_STRETCHED_UV_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

  if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU, NV4_STRETCHED_IMAGE_FROM_CPU) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth > 8) {

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                return(0);

        if (pxlDepth > 16) {
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY, NV4_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
                    return(0);
       }
   }

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_IMAGE_BLIT, NV4_IMAGE_BLIT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SRCCOPY_IMAGE_BLIT, NV4_IMAGE_BLIT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SURFACES_2D, NV4_CONTEXT_SURFACES_2D) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_PRIMARY_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
            return(0);
    }

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_VIDEO_SINK, NV_VIDEO_SINK) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {

      if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP) != NVOS05_STATUS_SUCCESS)
            return(0);
   }
#ifdef WINNT
   /*
    * Create NV4 DVD subpicture object in both DMA Push and PIO
    * channels. Don't know why the creation of these objects was
    * not in the common code.
    */
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
    NV_DD_DVD_SUBPICTURE, NV04_DVD_SUBPICTURE) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_DVD_SUBPICTURE, NV04_DVD_SUBPICTURE) != NVOS05_STATUS_SUCCESS)
        return(0);
#endif // WINNT

    /*
     * Create D3D objects.
     */

    /*
     * Create the DX5 Textured Triangle.
     */
    if (pDriverData->ppdev->flCaps & (CAPS_NV10_IS_PRESENT | CAPS_NV10ULTRA_IS_PRESENT | CAPS_NV10GL_IS_PRESENT))
        {
        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            D3D_DX5_TEXTURED_TRIANGLE, NV10_DX5_TEXTURED_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                return(0);
        }
    else
        if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
            D3D_DX5_TEXTURED_TRIANGLE, NV04_DX5_TEXTURED_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                return(0);

    /*
     * Create the DX6 Textured Triangle.
     */
        if (pDriverData->ppdev->flCaps & (CAPS_NV10_IS_PRESENT | CAPS_NV10ULTRA_IS_PRESENT | CAPS_NV10GL_IS_PRESENT))
            {
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV10_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                    return(0);
            }
        else
            if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
                D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV04_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS05_STATUS_SUCCESS)
                    return(0);

    /*
     * Create the ARGB_ZS surface context.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACES_ARGB_ZS, NV04_CONTEXT_SURFACES_ARGB_ZS) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create the swizzled surface context.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACE_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED) != NVOS05_STATUS_SUCCESS)
            return(0);


    /*
     * Create Scaled Image From Memory object for texture swizzling.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create Render Solid Rectangle for clearing the z-buffer and rendering surfaces.
     */
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE, NV4_RENDER_SOLID_RECTANGLE) != NVOS05_STATUS_SUCCESS)
            return(0);
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE_2, NV4_RENDER_SOLID_RECTANGLE) != NVOS05_STATUS_SUCCESS)
            return(0);

    /*
     * Create Video objects.
     */

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_PRIMARY_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_YUV422_VIDEO_FROM_MEMORY, NV_VIDEO_FROM_MEMORY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_VIDEO_COLOR_KEY, NV_VIDEO_COLOR_KEY) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_VIDEO_SCALER, NV_VIDEO_SCALER) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_VIDEO_SCALER, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);
   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
    NV_DD_P_V_VIDEO_COLOR_KEY, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
        return(0);

   if (pxlDepth == 8) {
    if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO) != NVOS05_STATUS_SUCCESS)
            return(0);

       if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP) != NVOS05_STATUS_SUCCESS)
            return(0);
   }


#ifdef MULTI_MON

   if (NvRmAllocObject(pDriverData->dwRootHandle, NV_DD_DEV_VIDEO,
        NV_DD_VIDEO_SINK, NV_VIDEO_SINK) != NVOS05_STATUS_SUCCESS)
            return(0);




   /*
    * Start patching things together (from bottom to top of patch)
    *    and otherwise initializing objects
    */

#ifdef MULTI_MON

   /* Free any existing dynamic context dma objects */
   if (pDriverData->dwVidMemCtxDmaSize != 0) {

       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
       NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

       pDriverData->dwVidMemCtxDmaSize = 0;
   }

   /* Allocate our video memory context dmas */

   pDriverData->dwVidMemCtxDmaSize =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);
   pDriverData->dwVidMemCtxDmaSize += 4096; /* Make sure to include permanently allocated video memory page */
#ifndef WINNT
   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->BaseAddress,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#else
   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);

   if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                       NV01_CONTEXT_DMA,
                       (ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY |
                        ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                       (PVOID)pDriverData->ppdev->pjScreen,
                       pDriverData->dwVidMemCtxDmaSize) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#endif // #ifdef WINNT

   if (pxlDepth == 8) {

       while (freeCount < 5)
           NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
       freeCount -= 5;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) + NVFF9_SET_VIDEO_OUTPUT | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[4] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

       dmaPusherPutAddress += 5;
   }

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) + NVFFA_SET_VIDEO_INPUT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   dmaPusherPutAddress += 4;

   while (freeCount < 16)
       NvGetDmaBufferFreeCount(npDev, freeCount, 16, dmaPusherPutAddress);
   freeCount -= 16;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(6) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(7) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress += 16;

#else   /* MULTI_MON */

   while (freeCount < 30)
       NvGetDmaBufferFreeCount(npDev, freeCount, 30, dmaPusherPutAddress);
   freeCount -= 30;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] = ((2 * sizeof(NvNotification)) - 1);

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[15] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 1));
   dmaPusherPutAddress[16] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[17] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[18] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[20] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[21] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 2));
   dmaPusherPutAddress[22] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[23] = (sizeof(NvNotification) - 1);

   dmaPusherPutAddress[24] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[25] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[26] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[27] =
       ((unsigned long)npDmaDmaToMemNotifier + (sizeof(NvNotification) << 2) +
       sizeof(NvNotification));
   dmaPusherPutAddress[28] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[29] = ((5 * sizeof(NvNotification)) - 1);

   dmaPusherPutAddress += 30;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] = (NV_DD_COMMON_DMA_BUFFER_SIZE - 1);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)npDmaDmaToMemNotifier;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] = (NV_DD_COMMON_DMA_BUFFER_SIZE - 1);

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_VIDEO_SINK;

   dmaPusherPutAddress += 4;

   if (pxlDepth == 8) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
       dmaPusherPutAddress[1] = NV_VIDEO_COLORMAP;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) + NVFFF_CREATE_OFFSET | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[5] = NV_DD_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) + NVFF9_SET_VIDEO_OUTPUT | 0x80000;
       dmaPusherPutAddress[7] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       dmaPusherPutAddress[8] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

       dmaPusherPutAddress += 9;
   }

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[9] = NV_CONTEXT_DMA_FROM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) + NVFFF_CREATE_OFFSET | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 12;


   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[7] = NV_ERROR_NOTIFIER;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(4) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)pDriverData->NvDmaBufferNotifierFlat;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] =
       (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 2) -
       (sizeof(NvNotification) << 1) - 1);

   dmaPusherPutAddress += 12;

   while (freeCount < 4)
       NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
   freeCount -= 4;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_SINK;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) + NVFFA_SET_VIDEO_INPUT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   dmaPusherPutAddress += 4;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[3] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[4] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[5] =
       (unsigned long)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) + NVFFD_SET_DMA_SPECIFIER | 0xC0000;
   dmaPusherPutAddress[9] = (unsigned long)pDriverData->BaseAddress;
   dmaPusherPutAddress[10] = (unsigned long)pDriverData->flatSelector;
   dmaPusherPutAddress[11] =
       (unsigned long)pDriverData->VideoHeapEnd - pDriverData->BaseAddress;

   dmaPusherPutAddress += 12;

   while (freeCount < 20)
       NvGetDmaBufferFreeCount(npDev, freeCount, 20, dmaPusherPutAddress);
   freeCount -= 20;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[9] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(3) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress[16] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[17] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[18] = dDrawSubchannelOffset(4) + NVFFD_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   dmaPusherPutAddress += 20;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(5) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 12;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 12;

#endif  /* MULTI_MON */

   while (freeCount < 24)
       NvGetDmaBufferFreeCount(npDev, freeCount, 24, dmaPusherPutAddress);
   freeCount -= 24;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[7] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[9] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[10] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[11] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[12] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(2) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[15] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[16] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[17] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress[18] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[19] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
   dmaPusherPutAddress[20] = dDrawSubchannelOffset(3) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[21] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[22] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[23] = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;

   dmaPusherPutAddress += 24;

   while (freeCount < 19)
       NvGetDmaBufferFreeCount(npDev, freeCount, 19, dmaPusherPutAddress);
   freeCount -= 19;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
       NVFF8_SET_VIDEO_OUTPUT | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(7) +
       NVFF8_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[5] = NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[6] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[7] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
       NVFF8_IMAGE_SCAN_OFFSET | 0x280000;
   dmaPusherPutAddress[9] = 0;
   dmaPusherPutAddress[10] = pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[11] =
       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);

   if (pxlDepth == 8)
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       dmaPusherPutAddress[12] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;

   dmaPusherPutAddress[13] = 0;

   dmaPusherPutAddress[14] = 0;
   dmaPusherPutAddress[15] = pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[16] =
       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);

   if (pxlDepth == 8)
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       dmaPusherPutAddress[17] = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;

   dmaPusherPutAddress[18] = 0;

   dmaPusherPutAddress += 19;

   /*
    * Connect buffer patch objects
    */


   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV042_SET_COLOR_FORMAT | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
   else
       dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

   dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
       NV042_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[6] = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV042_SET_PITCH | 0xC0000;
   dmaPusherPutAddress[8] =
       (pDriverData->HALInfo.vmiData.lDisplayPitch << 16) |
        pDriverData->HALInfo.vmiData.lDisplayPitch;
   dmaPusherPutAddress[9] = 0;
   dmaPusherPutAddress[10] = 0;

   dmaPusherPutAddress += 11;

   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_BLIT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
//       NV_DD_IMAGE_BLACK_RECTANGLE;  // messes up D3D surface clip
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
       NV05F_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[8] = NV05F_SET_OPERATION_ROP_AND;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_SURFACES | 0x40000;
   dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;

   dmaPusherPutAddress += 11;

   while (freeCount < 6)
       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
   freeCount -= 6;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_BLIT;
//   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
//       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000;   // destination alpha not supported if context color key set
//   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
//       NV_DD_IMAGE_BLACK_RECTANGLE;  // messes up D3D surface clip
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV05F_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[3] = NV05F_SET_OPERATION_SRCCOPY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
       NV05F_SET_CONTEXT_SURFACES | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;

   dmaPusherPutAddress += 6;

   while (freeCount < 11)
       NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
   freeCount -= 11;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
       NV076_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[4] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
       NV076_SET_OPERATION | 0x40000;
   dmaPusherPutAddress[6] = NV076_SET_OPERATION_ROP_AND;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
       NV076_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
       NV076_SET_COLOR_FORMAT | 0x40000;
   /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
   /* Must be set to a legal value but hardware ignores it otherwise */
   dmaPusherPutAddress[10] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress += 11;

   if (pxlDepth == 8) {

       while (freeCount < 13)
           NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
       freeCount -= 13;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
           NV076_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[8] = NV076_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[11] = dDrawSubchannelOffset(0) +
           NV076_SET_COLOR_FORMAT | 0x40000;
       /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 13;

   } else {

       while (freeCount < 13)
           NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
       freeCount -= 13;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(0) +
           NV076_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[8] = NV076_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(0) +
           NV076_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[11] = dDrawSubchannelOffset(0) +
           NV076_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[12] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 13;


       if (pxlDepth > 16) {

           while (freeCount < 10)
               NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
           freeCount -= 10;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_SRCCOPY_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(1) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[9] = NV076_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 10;

           while (freeCount < 12)
               NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
           freeCount -= 12;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_ABLEND_NOSRCALPHA_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(2) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[11] = NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 12;

           while (freeCount < 12)
               NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
           freeCount -= 12;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_ABLEND_STRETCHED_IMAGE_FROM_CPU;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_COLOR_KEY | 0x40000;
           dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
           dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) +
               NV076_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[5] = NV076_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[7] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[8] = dDrawSubchannelOffset(3) +
               NV076_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[9] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[10] = dDrawSubchannelOffset(3) +
               NV076_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[11] = NV076_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 12;
       }


       while (freeCount < 14)
           NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
       freeCount -= 14;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[7] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[11] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 14;


       if (pxlDepth > 16) {

           while (freeCount < 11)
               NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
           freeCount -= 11;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 11;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 13;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 13;
       }


       while (freeCount < 14)
           NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
       freeCount -= 14;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_PATTERN | 0x80000;
       dmaPusherPutAddress[6] = NV_DD_CONTEXT_PATTERN;
       dmaPusherPutAddress[7] = NV_DD_CONTEXT_ROP;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(0) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_OPERATION_ROP_AND;
       dmaPusherPutAddress[10] = dDrawSubchannelOffset(0) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[11] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[12] = dDrawSubchannelOffset(0) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       if (pxlDepth == 16)
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
       else
           dmaPusherPutAddress[13] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 14;


       if (pxlDepth > 16) {

           while (freeCount < 11)
               NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
           freeCount -= 11;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(1) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(1) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(1) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(1) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 11;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;

           dmaPusherPutAddress += 13;

           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
           dmaPusherPutAddress[1] =
               NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
           dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
           dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(2) +
               NV077_SET_OPERATION | 0x40000;
           dmaPusherPutAddress[6] = NV077_SET_OPERATION_BLEND_PREMULT;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_BETA4 | 0x40000;
           dmaPusherPutAddress[8] = NV_DD_CONTEXT_BETA4;
           dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
               NV077_SET_CONTEXT_SURFACE | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_SURFACES_2D;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(2) +
               NV077_SET_COLOR_FORMAT | 0x40000;
           dmaPusherPutAddress[12] = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;

           dmaPusherPutAddress += 13;
       }


       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

#ifdef  MULTI_MON

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[5] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[7] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[8] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[9] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 10;

#else   /* MULTI_MON */

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(4) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(4) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(5) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(5) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(6) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(6) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

       while (freeCount < 11)
           NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
       freeCount -= 11;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(7) | 0x40000;
       dmaPusherPutAddress[1] =
           NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_DMA_NOTIFIES | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
       dmaPusherPutAddress[4] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(7) +
           NV077_SET_OPERATION | 0x40000;
       dmaPusherPutAddress[6] = NV077_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(7) +
           NV077_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[9] = dDrawSubchannelOffset(7) +
           NV077_SET_COLOR_FORMAT | 0x40000;
       dmaPusherPutAddress[10] = NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;

       dmaPusherPutAddress += 11;

#endif  /* MULTI_MON */
   }


   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_ALT_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_COLOR_KEY | 0x100000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV061_SET_OPERATION | 0x80000;
   dmaPusherPutAddress[10] = NV061_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_R5G6B5;

   dmaPusherPutAddress += 12;

   while (freeCount < 12)
       NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
   freeCount -= 12;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_FROM_CPU;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_COLOR_KEY | 0x100000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV061_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV061_SET_OPERATION | 0x80000;
   dmaPusherPutAddress[10] = NV061_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress += 12;


   if (pxlDepth > 16) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 12, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_SRCCOPY_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(3) +
           NV061_SET_CONTEXT_SURFACE | 0x40000;
       dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[6] = dDrawSubchannelOffset(3) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[7] = NV061_SET_OPERATION_SRCCOPY;
       dmaPusherPutAddress[8] = NV061_SET_COLOR_FORMAT_LE_A8R8G8B8;

       dmaPusherPutAddress += 9;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_NOSRCALPHA_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(4) +
           NV061_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(4) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[8] = NV061_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[9] = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;

       dmaPusherPutAddress += 10;

       while (freeCount < 10)
           NvGetDmaBufferFreeCount(npDev, freeCount, 10, dmaPusherPutAddress);
       freeCount -= 10;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_IMAGE_FROM_CPU;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
           NV061_SET_CONTEXT_COLOR_KEY | 0x40000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
       dmaPusherPutAddress[4] = dDrawSubchannelOffset(5) +
           NV061_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[5] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[6] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[7] = dDrawSubchannelOffset(5) +
           NV061_SET_OPERATION | 0x80000;
       dmaPusherPutAddress[8] = NV061_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[9] = NV061_SET_COLOR_FORMAT_LE_A8R8G8B8;

       dmaPusherPutAddress += 10;
   }


   while (freeCount < 13)
       NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
   freeCount -= 13;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_ROP_GDI_RECT_AND_TEXT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_DMA_NOTIFIES | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_PATTERN | 0x80000;
   dmaPusherPutAddress[5] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[6] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[7] = dDrawSubchannelOffset(2) +
       NV04A_SET_CONTEXT_SURFACE | 0x40000;
   dmaPusherPutAddress[8] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[9] = dDrawSubchannelOffset(2) +
       NV04A_SET_OPERATION | 0xC0000;
   dmaPusherPutAddress[10] = NV04A_SET_OPERATION_ROP_AND;

   if (pxlDepth == 8)
       /* Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[11] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;

   dmaPusherPutAddress[12] = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

   dmaPusherPutAddress += 13;


   if (pxlDepth > 16) {

       while (freeCount < 9)
           NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
       freeCount -= 9;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(3) | 0x40000;
       dmaPusherPutAddress[1] = NV_DD_ABLEND_RECT_AND_TEXT;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(3) +
           NV04A_SET_CONTEXT_BETA4 | 0x80000;
       dmaPusherPutAddress[3] = NV_DD_CONTEXT_BETA4;
       dmaPusherPutAddress[4] = NV_DD_SURFACES_2D;
       dmaPusherPutAddress[5] = dDrawSubchannelOffset(3) +
           NV04A_SET_OPERATION | 0xC0000;
       dmaPusherPutAddress[6] = NV04A_SET_OPERATION_BLEND_PREMULT;
       dmaPusherPutAddress[7] = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
       dmaPusherPutAddress[8] = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

       dmaPusherPutAddress += 9;
   }


   while (freeCount < 6)
       NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
   freeCount -= 6;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(4) +
       NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000;
   dmaPusherPutAddress[3] = NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   dmaPusherPutAddress[4] = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   dmaPusherPutAddress[5] = NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY;

   dmaPusherPutAddress += 6;

   while (freeCount < 5)
       NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
   freeCount -= 5;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(5) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(5) +
       NV057_SET_COLOR_FORMAT | 0x80000;

   if (pxlDepth == 8)
       /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
       /* Must be set to a legal value but hardware ignores it otherwise */
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
   else if (pxlDepth == 16)
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
   else if (pxlDepth == 32)
       dmaPusherPutAddress[3] = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;

   dmaPusherPutAddress[4] = 0;

   dmaPusherPutAddress += 5;

   /*
    * Pattern is currently only used for overlay video UV masking so
    * always set it's color format to 8 bit indexed.
    */

   while (freeCount < 9)
       NvGetDmaBufferFreeCount(npDev, freeCount, 9, dmaPusherPutAddress);
   freeCount -= 9;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_PATTERN;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) +
       NV044_SET_COLOR_FORMAT | 0x80000;
   /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
   /* Must be set to a legal value but hardware ignores it otherwise */
   dmaPusherPutAddress[3] = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
   dmaPusherPutAddress[4] = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
   dmaPusherPutAddress[5] = dDrawSubchannelOffset(6) +
       NV044_SET_PATTERN_SELECT | 0xC0000;
   dmaPusherPutAddress[6] = NV044_SET_PATTERN_SELECT_MONOCHROME;

   if (pxlDepth == 8) {
       dmaPusherPutAddress[7] = NV_ALPHA_1_008;
       dmaPusherPutAddress[8] = NV_ALPHA_1_008;
   } else if (pxlDepth == 16) {
       dmaPusherPutAddress[7] = NV_ALPHA_1_016;
       dmaPusherPutAddress[8] = NV_ALPHA_1_016;
   } else {
       dmaPusherPutAddress[7] = NV_ALPHA_1_032;
       dmaPusherPutAddress[8] = NV_ALPHA_1_032;
   }

   dmaPusherPutAddress += 9;

   /* Create the D3D objects */
   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   pDriverData->dwDmaPusherFreeCount = freeCount;

   nvD3DCreateObjects();

   dmaPusherPutAddress = (unsigned long *)pDriverData->NvDmaPusherPutAddress;

#ifdef  CACHE_FREECOUNT
   freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   /* Make final subchannel assignments */

   while (freeCount < 5)
       NvGetDmaBufferFreeCount(npDev, freeCount, 5, dmaPusherPutAddress);
   freeCount -= 5;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_IMAGE_BLACK_RECTANGLE;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(0) +
       NV019_SET_POINT | 0x80000;
   dmaPusherPutAddress[3] = 0;
   dmaPusherPutAddress[4] = asmMergeCoords(pDriverData->bi.biWidth,
                                           pDriverData->maxOffScreenY);

   dmaPusherPutAddress += 5;

   while (freeCount < 18)
       NvGetDmaBufferFreeCount(npDev, freeCount, 18, dmaPusherPutAddress);
   freeCount -= 18;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(0) | 0x40000;
   dmaPusherPutAddress[1] = NV_DD_CONTEXT_ROP;
   dmaPusherPutAddress[2] = dDrawSubchannelOffset(6) | 0x40000;
   dmaPusherPutAddress[3] = NV_DD_CONTEXT_COLOR_KEY;
   dmaPusherPutAddress[4] = dDrawSubchannelOffset(1) | 0x40000;
   dmaPusherPutAddress[5] = NV_DD_SURFACES_2D;
   dmaPusherPutAddress[6] = dDrawSubchannelOffset(1) +
       NV042_SET_PITCH | 0xC0000;

   dmaPusherPutAddress[7] = (pDriverData->HALInfo.vmiData.lDisplayPitch << 16) |
    pDriverData->HALInfo.vmiData.lDisplayPitch;

   dmaPusherPutAddress[8] = 0;
   dmaPusherPutAddress[9] = 0;

   dmaPusherPutAddress[10] = dDrawSubchannelOffset(2) | 0x40000;
   dmaPusherPutAddress[11] = NV_DD_ROP_GDI_RECT_AND_TEXT;
   dmaPusherPutAddress[12] = dDrawSubchannelOffset(3) | 0x40000;
   dmaPusherPutAddress[13] = NV_DD_IMAGE_BLIT;
   dmaPusherPutAddress[14] = dDrawSubchannelOffset(4) | 0x40000;
   dmaPusherPutAddress[15] = NV_DD_IMAGE_FROM_CPU;
   dmaPusherPutAddress[16] = dDrawSubchannelOffset(5) | 0x40000;

   if (pxlDepth == 8)
       dmaPusherPutAddress[17] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
   else
       dmaPusherPutAddress[17] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

   dmaPusherPutAddress += 18;

   while (freeCount < 8)
       NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
   freeCount -= 8;

   dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
       NV043_SET_ROP5 | 0x40000;
   dmaPusherPutAddress[1] = 0x00000000;

   /* Force rectangle portion of patch to be validated (assures no RM interrupts on Lock calls) */

   dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
       NV04A_COLOR1_A | 0xC0000;
   dmaPusherPutAddress[3] = 0;
   dmaPusherPutAddress[4] = 0;
   dmaPusherPutAddress[5] = 0;

   /* Force Blit to be instantiated */

   dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_BLIT) +
       NV05F_CONTROL_POINT_IN | 0x40000;
   dmaPusherPutAddress[7] = 0;

   dmaPusherPutAddress += 8;

   /* Force write combine buffer to flush */
   pDriverData->NvDmaPusherBufferEnd[0] = 0;
   /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
   _outp (0x3d0,0);

   npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

   /* Wait for initialization to complete */
   while (npDev->Get != (unsigned long)((dmaPusherPutAddress - dmaPusherBufferBase) << 2));

   pDriverData->dwDDDmaPusherChannelIndex = 1;
   pDriverData->dwDDDmaPusherChannelMask = 0;

   /* Make sure ALL NV DMA channels are idle */
   NV_DD_DMA_PUSHER_SYNC();

   tmpIndex = -1;

   while (tmpIndex != pDriverData->dwDDDmaPusherChannelIndex) {

       pDriverData->dwDDDmaPusherChannelIndex = tmpIndex;

       while (freeCount < 4)
           NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
       freeCount -= 4;

       npDmaSyncNotifier->status = NV_IN_PROGRESS;

       dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
           RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
       dmaPusherPutAddress[1] = 0;
       dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
           RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
       dmaPusherPutAddress[3] = 0;

       dmaPusherPutAddress += 4;

       /* Force write combine buffer to flush */
       pDriverData->NvDmaPusherBufferEnd[0] = 0;
       /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
       _outp (0x3d0,0);

       npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

       while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

       NV_DD_GET_DMA_CHANNEL_INDEX(tmpIndex);
   }

   pDriverData->dwDDDmaPusherChannelMask = 1 << pDriverData->dwDDDmaPusherChannelIndex;

   pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

   pDriverData->dwDmaPusherFreeCount = freeCount;

   /*
    * Perform any re-enabling of D3D.
    * After a mode switch, it is necessary to make sure that the proper
    * setup is done on the push buffer and texture contexts.
    */
   nvD3DReenable();

   pDriverData->dDrawSpareSubchannel6Object = 0;
   pDriverData->dDrawSpareSubchannelObject = 0; // subchannel 7


   /*
    * Now initialize video channel
    *
    * NOTE:
    *
    *  Video channel should contain NO graphics rendering objects.  This should
    *  prevent frequent context switches when switching between graphics and video channels.
    *
    */

   npDevVideo = (Nv3ChannelPio *)pDriverData->NvDevVideoFlatPio;

   videoFreeCount = 0;

   /* Initialize for PIO notifiers */

   pDriverData->NvPioDmaToMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

   pDriverData->NvPioBufferNotifierFlat = pDriverData->NvCommonDmaBufferFlat;

//   pDriverData->NvPioDmaFromMemNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 1);

//   pDriverData->NvDmaPusherSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 1) + sizeof(NvNotification);

//   pDriverData->NvPioSyncNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 2);

//   /* Notifier array offsets 5, 6, 7, 8, and 9 */
//   pDriverData->NvPioFlipPrimaryNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
//       (sizeof(NvNotification) << 2) + sizeof(NvNotification);

   /* Notifier array offsets A, B, C, D, and E */
   pDriverData->NvPioFlipOverlayNotifierFlat = pDriverData->NvCommonDmaBufferFlat +
       (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 1);

   /* Notifier array offset (sizeof(NvNotification) << 3) + (sizeof(NvNotification) << 2) + (sizeof(NvNotification) << 1) + sizeof(NvNotification) currently unused */

   npPioDmaToMemNotifier = (NvNotification *)pDriverData->NvPioDmaToMemNotifierFlat;
   npPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

   /* Deal with possible mode change during pending flip */
   if (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npDmaPusherSyncNotifier->status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
   }
   /* Deal with possible mode change during pending flip */
   if (npPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) {
       long countDown = 0x200000;
       while ((npPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
   }

   /* MUST MAKE SURE STATUS FLAG IS CLEAR BEFORE INITIAL USE */

   npDmaPusherSyncNotifier->status = 0;

   npPioDmaToMemNotifier->status = 0;

   npPioFlipOverlayNotifier[1].status = 0;
   npPioFlipOverlayNotifier[2].status = 0;


#ifndef MULTI_MON
   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 24;

   npDevVideo->subchannel[0].SetObject = NV_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Create = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nvClass.Create = NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

   npDevVideo->subchannel[1].SetObject = NV_CONTEXT_DMA_FROM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
#endif  /* MULTI_MON */

   if (pxlDepth == 8) {

       while (videoFreeCount < 12)
           videoFreeCount = NvGetFreeCount(npDevVideo, 2);
       videoFreeCount -= 12;

       npDevVideo->subchannel[3].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoOutput =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoInput =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   }

   while (videoFreeCount < 8)
       videoFreeCount = NvGetFreeCount(npDevVideo, 5);
   videoFreeCount -= 8;

   npDevVideo->subchannel[5].SetObject = NV_DD_VIDEO_SINK;
   npDevVideo->subchannel[5].videoSink.SetVideoInput[0] =
       NV_DD_P_V_VIDEO_COLOR_KEY;

#else   /* MULTI_MON */

   while (videoFreeCount < 40)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 40;

   npDevVideo->subchannel[0].SetObject =
       NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[0] =
       (unsigned long)npPioDmaToMemNotifier;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.limit =
       (sizeof(NvNotification) - 1);

   npDevVideo->subchannel[0].SetObject =
       NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[0] =
       ((unsigned long)npPioDmaToMemNotifier + (sizeof(NvNotification) << 3) +
        (sizeof(NvNotification) << 1));
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[0].contextDmaToMemory.SetDmaSpecifier.limit =
       ((5 * sizeof(NvNotification)) - 1);

   npDevVideo->subchannel[1].SetObject = NV_VIDEO_SINK;
   npDevVideo->subchannel[1].nvClass.Create = NV_DD_VIDEO_SINK;

   if (pxlDepth == 8) {

       while (videoFreeCount < 20)
           videoFreeCount = NvGetFreeCount(npDevVideo, 2);
       videoFreeCount -= 20;

       npDevVideo->subchannel[2].SetObject = NV_VIDEO_COLORMAP;
       npDevVideo->subchannel[2].nvClass.Create = NV_DD_SHARED_VIDEO_COLORMAP;

       npDevVideo->subchannel[3].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoOutput =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
       npDevVideo->subchannel[3].videoColormap.SetVideoInput =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   }

   while (videoFreeCount < 40)
       videoFreeCount = NvGetFreeCount(npDevVideo, 4);
   videoFreeCount -= 40;

   npDevVideo->subchannel[4].SetObject = NV_ERROR_NOTIFIER;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.address[0] =
       (unsigned long)pDriverData->NvPioBufferNotifierFlat;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[4].contextDmaToMemory.SetDmaSpecifier.limit =
       (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 2) -
       (sizeof(NvNotification) << 1) - 1);

   npDevVideo->subchannel[5].SetObject = NV_DD_VIDEO_SINK;
   npDevVideo->subchannel[5].videoSink.SetVideoInput[0] =
       NV_DD_P_V_VIDEO_COLOR_KEY;

   npDevVideo->subchannel[6].SetObject = NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.address[0] =
       (unsigned long)pDriverData->BaseAddress;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.address[1] =
       (unsigned long)pDriverData->flatSelector;
   npDevVideo->subchannel[6].contextDmaFromMemory.SetDmaSpecifier.limit =
       (unsigned long)pDriverData->VideoHeapEnd - pDriverData->BaseAddress;

#endif  /* MULTI_MON */

   while (videoFreeCount < 60)
       videoFreeCount = NvGetFreeCount(npDevVideo, 2);
   videoFreeCount -= 60;

   npDevVideo->subchannel[2].SetObject = NV_DD_VIDEO_COLOR_KEY;
   npDevVideo->subchannel[2].videoColorKey.SetVideoOutput =
       NV_DD_P_V_VIDEO_COLOR_KEY;
   npDevVideo->subchannel[2].videoColorKey.SetVideoInput[0] =
       NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   if (pxlDepth == 8)
       npDevVideo->subchannel[2].videoColorKey.SetVideoInput[1] =
           NV_DD_P_V_SHARED_VIDEO_COLORMAP;
   else
       npDevVideo->subchannel[2].videoColorKey.SetVideoInput[1] =
           NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;

   npDevVideo->subchannel[2].videoColorKey.SetVideoInput[2] =
       NV_DD_P_V_VIDEO_SCALER;

   if (pxlDepth == 8)
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5;
   else
       npDevVideo->subchannel[2].videoColorKey.SetColorFormat =
           NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8;

   npDevVideo->subchannel[2].videoColorKey.SetColorKey = 0;
   npDevVideo->subchannel[2].videoColorKey.SetPoint = 0;
   npDevVideo->subchannel[2].videoColorKey.SetSize = 0;

   npDevVideo->subchannel[3].SetObject = NV_DD_VIDEO_SCALER;
   npDevVideo->subchannel[3].videoScaler.SetVideoOutput =
       NV_DD_P_V_VIDEO_SCALER;
   npDevVideo->subchannel[3].videoScaler.SetVideoInput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoScaler.SetDeltaDuDx = 0x100000;
   npDevVideo->subchannel[3].videoScaler.SetDeltaDvDy = 0x100000;
   npDevVideo->subchannel[3].videoScaler.SetPoint = 0;

   while (videoFreeCount < 60)
       videoFreeCount = NvGetFreeCount(npDevVideo, 3);
   videoFreeCount -= 60;

   npDevVideo->subchannel[3].SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetVideoOutput =
       NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageCtxDma[0] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageCtxDma[1] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.SetImageNotifyCtxDma =
       NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].offset = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].pitch = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].size = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].format =
       NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[0].notify = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].offset = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].pitch = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].size = 0;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].format =
       NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
   npDevVideo->subchannel[3].videoFromMemory.ImageScan[1].notify = 0;


   while (videoFreeCount < 24)
       videoFreeCount = NvGetFreeCount(npDevVideo, 7);
   videoFreeCount -= 24;

   npDevVideo->subchannel[7].SetObject = NV_DD_PRIMARY_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetVideoOutput =
       NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetImageCtxDma[0] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[7].videoFromMemory.SetImageCtxDma[1] =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
//   npDevVideo->subchannel[7].videoFromMemory.SetImageNotifyCtxDma =
//       NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].offset = 0;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].pitch =
//       pDriverData->HALInfo.vmiData.lDisplayPitch;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].size =
//       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);
   if (pxlDepth == 8)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].format =
           NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[0].notify = 0;

//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].offset = 0;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].pitch =
//       pDriverData->HALInfo.vmiData.lDisplayPitch;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].size =
//       asmMergeCoords(pDriverData->bi.biWidth, pDriverData->bi.biHeight);
   if (pxlDepth == 8)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_Y8_P4;
   else if (pxlDepth == 16)
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
   else
       npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].format =
           NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
//   npDevVideo->subchannel[7].videoFromMemory.ImageScan[1].notify = 0;

   while (videoFreeCount < 20)
       videoFreeCount = NvGetFreeCount(npDevVideo, 0);
   videoFreeCount -= 20;

   npDevVideo->subchannel[0].SetObject = NV_DD_DVD_SUBPICTURE;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaNotifies =
       NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaOverlay =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaImageIn =
       NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY;
   npDevVideo->subchannel[0].nv4DvdSubpicture.SetContextDmaImageOut =
       NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY;


   pDriverData->NvVideoFreeCount = (unsigned short)videoFreeCount;


    /*
     * Allocate psuedo-notifier memory
     *  we use <size> bytes starting at the highest 512 byte boundary inside of
     *  the 4k of persistent memory of the disp driver. This is so that we
     *  can set up a proper surface because of alignment restrictions.
     *  the caluclation is done in <addr>
     * Modify <size> only if you modify it in nv4ctxt.c also (I need some #defines)
     */
    {
        DWORD size =  16;
        DWORD addr = (pDriverData->VideoHeapEnd + 4096) & ~511;

#ifndef WINNT
        pDriverData->dwTMPseudoNotifierMem    = addr;
        pDriverData->dwTMPseudoNotifierOffset = pDriverData->dwTMPseudoNotifierMem - pDriverData->BaseAddress;
        memset ((void*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress),0,size);
#else
        pDriverData->dwTMPseudoNotifierOffset    = addr;
        pDriverData->dwTMPseudoNotifierMem = pDriverData->ppdev->pjScreen + pDriverData->dwTMPseudoNotifierOffset;
        memset ((void*)(pDriverData->dwTMPseudoNotifierMem),0,size);
#endif

        //DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Initial notifier = %08x",dwTMStageAddr);
        pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
        pDriverData->dwTMTail = pDriverData->dwTMStageAddr;
        pDriverData->dwRenderedFrame = pDriverData->dwCurrentFrame = 0;
    }

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\global.c ===
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"

#ifdef NV_TEX2
#ifdef NV_FASTLOOPS
#include "..\x86\x86.h"
void ILCCompile_move (DWORD,DWORD,DWORD);
#endif
#endif

#ifdef NV_FASTLOOPS
void ILCWarmCache (void);
#endif

//#pragma data_seg("GLOBAL")
#pragma pack(push,1) // we control alignment
global_struc global={{0}};
#pragma pack(pop)

void init_globals (void) {
    memset (&global,0,sizeof(global));

#ifdef NV_FASTLOOPS
    global.fFogC1     = 2.0f;
    global.fFogC2     = -1.44269504f * (float)0x800000;

    global.fCTC1      = 0.5f;

    global.dwILCData  = NULL;
    global.dwILCCount = 0;
    global.dwILCMax   = 0;

#else  //!NV_FASTLOOPS
    dwVertexSN  = 1;
#endif //!NV_FASTLOOPS

#ifndef WINNT
// setup processor speed
    global.dwProcessorSpeed = nvGetCPUSpeed();

// detect MMX
    {
        BOOL isMMX = nvDetectMMX();
        global.dwCPUFeatureSet |= isMMX ? FS_MMX : 0;
    }

// detect KATMAI
    {
        BOOL isKATMAI = nvDetectKATMAI();
        global.dwCPUFeatureSet |= isKATMAI ? FS_KATMAI : 0;
    }
#endif // #ifndef WINNT

// generate some commonly used inner loops
#ifdef NV_FASTLOOPS
    ILCWarmCache();
#endif //NV_FASTLOOPS

// setup automipmap table
    {
        extern BYTE nvAutoMipPush[256];
        int i;

        for (i=0; i<256; i++)
        {
            float x = ((float)i - 127.5f) / 127.5f;
            if (x > 0)
            {
                x = 2.0f*x - x*x;
            }
            else
            {
                x = 2.0f*x + x*x;
            }
            nvAutoMipPush[i] = (BYTE)((x * 127.5f)+127.5f);
        }
    }

    /*
     * texture sync
     */
#ifdef NV_TEX2
    global.dwHWTextureDate = 10;
    global.dwSWTextureDate = 10;
#if 0
    {
        extern DWORD dbgLevel;
        dbgLevel = 0xffffffff;
    }
#endif
#if 0
    {
        extern DWORD dbgPreviewTexture;
        extern DWORD dbgPreviewTexturePitch;

        dbgPreviewTexture      = 0xffffffff;
        dbgPreviewTexturePitch = 640*2;
    }
#endif

#endif // NV_TEX2
    //*********************************************************
    // Set default surface alignment for AGP push buf heap. There
    // are no alignment restrictions, but we need to pass the
    // SURFACEALIGMENT struct to the ddraw surface allocation
    // routines.
    //*********************************************************
    AgpHeapAlignment.Linear.dwStartAlignment = 4;
    AgpHeapAlignment.Linear.dwPitchAlignment = 0;
}

//////////////////////////////////////////////////////////////////////////////
// InterProcessMemory code
//
static HANDLE hIPM=0;

#ifndef OLDSTUFF
void* AllocIPM (unsigned size) {
    if (!hIPM) hIPM=HEAPCREATE (size);
    return HEAPALLOC (hIPM,size);
}

void FreeIPM (void* ptr) {
    HEAPFREE (hIPM,ptr);
}

void DestroyIPM (void) {
    if (hIPM) HEAPDESTROY (hIPM);
}

void* ReallocIPM (void* ptr,unsigned size) {
    if (!hIPM) hIPM=HEAPCREATE (size);
    if (!ptr) return HEAPALLOC (hIPM,size);
    HEAPREALLOC (hIPM,ptr,size);
    return ptr;
}
#else
void* AllocIPM (unsigned size) {
    if (!hIPM) hIPM=HeapCreate (HEAP_SHARED,size,0);
    return HeapAlloc (hIPM,0,size);
}

void FreeIPM (void* ptr) {
    HeapFree (hIPM,0,ptr);
}

void DestroyIPM (void) {
    if (hIPM) HeapDestroy (hIPM);
}

void* ReallocIPM (void* ptr,unsigned size) {
    if (!hIPM) hIPM=HeapCreate (HEAP_SHARED,size,0);
    if (!ptr) return HeapAlloc (hIPM,0,size);
    return HeapReAlloc (hIPM,0,ptr,size);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4comp.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4COMP.C                                                         *
*   NV4 Triangle Inner Loop Compiler                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 08/27/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_FASTLOOPS

#ifdef NV_DUMPLOOPS
#include <stdio.h>
#endif

#include "..\x86\x86.h"

/*
 * switches
 */
//#define PRINT_NAME              // force inner loop name at creation (even for retail builds)
//#define CHECK_VALID_PUSHER      // int3 when edi goes below zero (which indicates a push error)
//#define PIX1

/*
 * constants
 */
#define LUIFLAG_FOGMODE         0x00000003
#define LUIFLAG_STRIDES         0x0000000c
#define LUIFLAG_INDEXED         0x00000010
#define LUIFLAG_FVF             0x00000020
#define LUIFLAG_DX6             0x00000040
#define LUIFLAG_FIXEDWBUF       0x00000080 // ff = 256 inner loops
#ifdef NV_CONTROLTRAFFIC
#define LUIFLAG_ZFRONT          0x00000100
#define LUIFLAG_ZBACK           0x00000200 // 3ff = 1024 inner loops
#endif //NV_CONTROLTRAFFIC

#define LUIFLAG_BASIC           0x00000000
#define LUIFLAG_MMX             0x00010000
#define LUIFLAG_KATMAI          0x00020000
#define LUIFLAG_AMD             0x00040000

#define LUIMASK_BRANCH          0x0000ffff

#ifdef PIX1
#define VC_DX5_AND              7
#define VC_DX5_ADD              3
#define VC_DX6_AND              3
#define VC_DX6_ADD              1
#else
#define VC_DX5_AND              15
#define VC_DX5_ADD              7
#define VC_DX6_AND              7
#define VC_DX6_ADD              3
#endif

/*
 * types
 */
typedef (__stdcall *PFNINNERLOOP)(void);

/*
 * structures
 */

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

/*
 * short-lived globals
 */
DWORD  ilcFlags;

/*
 * prototypes
 */
DWORD ILCCompileCode (DWORD);

/*
 * helper debug code
 */
#ifdef DEBUG
void __stdcall nvDebugFlush (DWORD dwType)
{
    dbgFlushType(pCurrentContext,dwType);
}
void __stdcall nvDebugShowVertex (DWORD *pdwAddr)
{
    dbgDisplayVertexData (pdwAddr[1],pdwAddr[2],pdwAddr[3],pdwAddr[4],
                          pdwAddr[5],pdwAddr[6],pdwAddr[7],pdwAddr[8]);
}
#endif // DEBUG

#ifdef NV_PROFILE
DWORD nvpTriCount;
DWORD nvpTriToGo;
float nvpTriArea;

void nvProfileLog (void)
{
    if (nvpTriCount > 40)
    {
        /*
         * flush HW
         */
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();

        /*
         * stop stopwatch
         */
        NVP_STOP (NVP_C_PIXPERSEC);

        /*
         * log update event
         */
        nvpLogEvent (NVP_E_TRIDISP);

        /*
         * log count
         */
        if (nvpTriCount)
        {
            nvpLogCount (NVP_C_TRICOUNT,nvpTriCount);
        }

        /*
         * log average area
         */
        nvpTriArea *= 0.5f;
        if (nvpTriCount)
        {
            nvpLogCount (NVP_C_TRIAREA,(DWORD)(nvpTriArea / (float)nvpTriCount));
        }

        /*
         * log tri per second
         */
        if (nvpTriCount) {
            double a;

            a  = 1.0e6 * (double)global.dwProcessorSpeed / (double)nvpTime[NVP_C_PIXPERSEC];
            a *= (double)nvpTriArea;
            nvpLogCount (NVP_C_PIXPERSEC,(DWORD)a);
        }
    }

    /*
     * start next
     */
    nvpTriArea  = 0.0f;
    nvpTriCount = 0;
    nvpTriToGo  = nvpTriPerSecWindow;
    NVP_START (NVP_C_PIXPERSEC);
}

void __stdcall nvProfileArea (float fArea)
{
    /*
     * total area
     */
    global.fTriangleArea += fArea;

    /*
     * pix per sec
     */
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        /*
         * add up area
         */
        nvpTriCount ++;
        nvpTriArea  += fArea;

        /*
         * time yet
         */
        if (!(--nvpTriToGo))
        {
            nvProfileLog();
        }
    }
}
#endif //NV_PROFILE

/****************************************************************************
 * inner loop generator helpers                                             *
 ****************************************************************************/

#ifdef DEBUG
/*
 * ILCExecute_dbgFlushTriangle
 *
 * vertex data helper
 */
void __stdcall ILCExecute_dbgFlushTriangle
(
    void
)
{
    dbgFlushTriangle (pCurrentContext);
}

/*
 * ILCCompile_dbgFlushTriangle
 *
 * flushes the triangle whe the right bits are set
 */
void ILCCompile_dbgFlushTriangle
(
    void
)
{
    xMOV_i32_r  ((DWORD)&nvFifo,rESI)
    xMOV_i32_r  ((DWORD)&nvFreeCount,rEDI)
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),ILCExecute_dbgFlushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
    xMOV_r_i32  (rESI,(DWORD)&nvFifo)
    xMOV_r_i32  (rEDI,(DWORD)&nvFreeCount)
}

/*
 * ILCExecute_dbgDisplayVertexData
 *
 * vertex data helper
 */
void __stdcall ILCExecute_dbgDisplayVertexData
(
    DWORD* p
)
{
    dbgDisplayVertexData (p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);
}

/*
 * ILCCompile_dbgDisplayVertexData
 *
 * Shows vertex data when right bits are set
 */
void ILCCompile_dbgDisplayVertexData
(
    DWORD disp
)
{
    xPUSHAD
    xSUB_rm_imm8 (rmREG(rESI),disp*4 - 4)
    xPUSH_r      (rESI)
    xMOV_rm_imm  (rmREG(rEBX),ILCExecute_dbgDisplayVertexData)
    xCALL_rm     (rmREG(rEBX))
    xPOPAD
}

#endif //DEBUG

/*
 * ILCCompile_mulvertexstride
 *
 * reg = reg * fvfData.dwVertexStride
 */
__inline void ILCCompile_mulvertexstride
(
    DWORD reg
)
{
    if (ilcFlags & LUIFLAG_FVF)
    {
        xIMUL_r_i32 (reg,(DWORD)&fvfData.dwVertexStride);
    }
    else
    {
        xSHL_rm_imm (rmREG(reg),5)
    }
}

/*
 * ILCCompile_reserve
 *
 * check and wait for enough space in fifo
 */
void ILCCompile_reserve
(
    DWORD dwCount
)
{
    DWORD label1;
    DWORD label2;

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

    xCMP_rm_imm  (rmREG(rEDI),dwCount)
    label1 = ilcCount;
    xJA          (0)
    xMOV_i32_r   ((DWORD)&nvFifo,rESI)
    xMOV_i32_r   ((DWORD)&nvFreeCount,rEDI)
    xMOV_rm_imm  (rmREG(rEBX),(DWORD)nvGetDmaFreeCount)
    label2 = ilcCount;
    xPUSH_imm    (dwCount)
    xCALL_rm     (rmREG(rEBX))
    xCMP_rm_imm  (rmREG(rEAX),dwCount)
    xJL          (label2)
    xMOV_r_rm    (rEDI,rmREG(rEAX))
    xMOV_r_i32   (rESI,(DWORD)&nvFifo)

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

    *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));
}

/*
 * ILCCompile_cullcheck
 *
 * do a cull check on the triangle loaded in dwVertex0..2
 * code ends with the z flag set to indicate culled (do not draw)
 *
 * for dx5 this routine will also attempt to minimize specular
 */
__inline void ILCCompile_cullcheck
(
    void
)
{
    /*
     * specular check
     */
    if (!(ilcFlags & LUIFLAG_DX6))
    {
        DWORD label0;
        DWORD label1;
        DWORD label2;
        DWORD label3;
        DWORD label4;

        /*
         * check for specular enable
         */
        xMOV_r_i32 (rEAX,(DWORD)&global.dwSpecularState)
        xTEST_rm_r (rmREG(rEAX),rEAX)
        label0 = ilcCount;
        xJZ32      (0)

        /*
         * fetch specular into ebx,ecx and edx
         */
        xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex0)
        xMOV_r_i32 (rECX,(DWORD)&global.dwVertex1)
        xMOV_r_i32 (rEDX,(DWORD)&global.dwVertex2)
        if (ilcFlags & LUIFLAG_FVF)
        {
            xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwSpecularMask)
            xMOV_r_i32 (rEBP,(DWORD)&fvfData.dwSpecularOffset)

            xAND_r_rm  (rEBX,rmREG(rEAX))
                xAND_r_rm  (rECX,rmREG(rEAX))
                    xAND_r_rm  (rEDX,rmREG(rEAX))

            xADD_r_rm  (rEBX,rmREG(rEBP))
                xADD_r_rm  (rECX,rmREG(rEBP))
                    xADD_r_rm  (rEDX,rmREG(rEBP))
        }
        else
        {
            xMOV_r_rm (rEBX,rmIND8(rEBX)) xOFS8 (20) // spec
            xMOV_r_rm (rECX,rmIND8(rECX)) xOFS8 (20) // spec
            xMOV_r_rm (rEDX,rmIND8(rEDX)) xOFS8 (20) // spec
        }
        /*
         * combine and check if tri needs specular
         */
        xOR_r_rm     (rEBX,rmREG(rECX))
        xOR_r_rm     (rEBX,rmREG(rEDX))
        xTEST_rm_imm (rmREG(rEBX),0x00fcfcfc)
        label1 = ilcCount;
        xJZ32        (0)
        /*
         * check if we have to change the state
         */
        xMOV_r_i32  (rEAX,(DWORD)&global.dwSpecCurr)
        xTEST_rm_r  (rmREG(rEAX),rEAX)
        label2 = ilcCount;
        xJNZ32      (0)
        /*
         * enable
         *  eax is zero when we get here
         */
        xMOV_i32_r  ((DWORD)&global.dwSpecCount,rEAX)

        xINC_rm     (rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwSpecCurr,rEAX)

        xMOV_r_i32  (rEAX,(DWORD)&global.dwBlend)
        xOR_rm_imm  (rmREG(rEAX),DRF_DEF(054,_BLEND,_SPECULARENABLE,_TRUE))

        label3 = ilcCount;
        xJMP        (0)
        /*
         * disable
         */
        *(DWORD*)(ilcData + label1 + 2) = (ilcCount - (label1 + 6));

        xMOV_r_i32   (rEAX,(DWORD)&global.dwSpecCount)
        xINC_rm      (rmREG(rEAX))
        xMOV_i32_r   ((DWORD)&global.dwSpecCount,rEAX)
        xCMP_rm_imm  (rmREG(rEAX),5)
        label4 = ilcCount;
        xJNZ32       (0)

        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwSpecCurr,rEAX)

        xMOV_r_i32  (rEAX,(DWORD)&global.dwBlend)
        xAND_rm_imm (rmREG(rEAX),0xffff0fff)

        *(DWORD*)(ilcData + label3 + 1) = ilcCount - (label3 + 5);

        xPUSH_r      (rEAX)
        ILCCompile_reserve (2);
        xMOV_rm_imm  (rmREG(rEBX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xPOP_r       (rEAX)
        xMOV_rm_r    (rmIND(rESI),rEBX)
        xMOV_rm_r    (rmIND8(rESI),rEAX) xOFS8(4)
        xADD_rm_imm8 (rmREG(rESI),2*4)
        xSUB_rm_imm8 (rmREG(rEDI),2)

        /*
         * done
         */
        *(DWORD*)(ilcData + label0 + 2) = (ilcCount - (label0 + 6));
        *(DWORD*)(ilcData + label2 + 2) = (ilcCount - (label2 + 6));
        *(DWORD*)(ilcData + label4 + 2) = (ilcCount - (label4 + 6));
    }

    /*
     * cull
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex0)
    xFLD_rm32  (rmIND(rEAX))
    xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex1)
    xFLD_rm32  (rmIND(rEBX))
    xFXCH_st   (rST1)
    xFSUBP_st  (rST1)
    xMOV_r_i32 (rECX,(DWORD)&global.dwVertex2)
    xFLD_rm32  (rmIND8(rECX)) xOFS8(4)
    xFXCH_st   (rST1)
    xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)
    xFXCH_st   (rST1)
    xFLD_rm32  (rmIND(rECX))
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND(rEAX))
    xFXCH_st   (rST3)
    xFSUBP_st  (rST1)
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)
    xFXCH_st   (rST3)
    xFSUBP_st  (rST1)
    xFXCH_st   (rST3)
    xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)
    xFXCH_st   (rST2)
    xFMULP_st  (rST1)
    xFXCH_st   (rST1)
    xFSUBP_st  (rST2)
    xFXCH_st   (rST2)
    xFMULP_st  (rST1)
    xFSUBP_st  (rST1)
    xFSTP_i32  ((DWORD)&global.dwTemp)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwTemp)
    xXOR_r_i32 (rEAX,(DWORD)&global.dwCullMask1)
    xTEST_r_i32(rEAX,(DWORD)&global.dwCullMask2)
}

/*
 * ILCCompile_move
 *
 * moves memory from src to dest
 *  use best algorithm depoending on architecture
 *  will thrash eax,ebp,ebx,edx,ecx and mmx/xmmx
 *
 */
void ILCCompile_move
(
    DWORD dwDst,        // NULL means to ebx
    DWORD dwSrc,        // NULL means from edx
    DWORD dwCount       // 0 means ecx has the number of bytes
)
{
    BOOL  isKNI = ilcFlags & LUIFLAG_KATMAI;
    BOOL  isMMX = ilcFlags & LUIFLAG_MMX;
    BOOL  isS16 = dwSrc && !(dwSrc & 15); // true when source is guaranteed 16 byte aligned
    BOOL  isD16 = dwDst && !(dwDst & 15); // true when dest is guaranteed 16 byte aligned
    DWORD dwMax = isKNI ? (4*16) : (isMMX ? (4*8) : (4*2)); // cannot be > 128
    DWORD label1,label2;
    BOOL  mmx = FALSE;

    /*
     * load src and dest
     */
    if (dwSrc)
    {
        xMOV_rm_imm (rmREG(rEDX),dwSrc)
    }
    if (dwDst)
    {
        xMOV_rm_imm (rmREG(rEBX),dwDst)
    }

    /*
     * constant count
     */
    if ((dwCount) && (dwCount <= dwMax))
    {
        DWORD ofs = 0;
        if (isKNI)
        {
            DWORD count = dwCount >> 4;
            DWORD index;
            for (index = 0; index < count; index++)
            {
                if (isS16) { xMOVAPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16) }
                      else { xMOVLPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16) xMOVHPS_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*16+8) }
            }
            for (index = 0; index < count; index++)
            {
                if (isD16) { xMOVAPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16) }
                      else { xMOVLPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16) xMOVHPS_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*16+8) }
            }
            dwCount -= count * 16;
            ofs     += count * 16;
        }
        if (isMMX)
        {
            DWORD count = dwCount >> 3;
            DWORD index;
            for (index = 0; index < count; index++)
            {
                xMOVQ_r_rm (index,rmIND8(rEDX)) xOFS8(ofs+index*8)
            }
            for (index = 0; index < count; index++)
            {
                xMOVQ_rm_r (rmIND8(rEBX),index) xOFS8(ofs+index*8)
                mmx = 1;
            }
            dwCount -= count * 8;
            ofs     += count * 8;
        }
        {
            while (dwCount >= 8)
            {
                xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(ofs+0)
                xMOV_r_rm (rECX,rmIND8(rEDX)) xOFS8(ofs+4)
                xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(ofs+0)
                xMOV_rm_r (rmIND8(rEBX),rECX) xOFS8(ofs+4)
                dwCount -= 8;
                ofs     += 8;
            }
            while (dwCount >= 4)
            {
                xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(ofs)
                xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(ofs)
                dwCount -= 4;
                ofs     += 4;
            }
            while (dwCount)
            {
                xMOV_r_rm8 (rAL,rmIND8(rEDX)) xOFS8(ofs)
                xMOV_rm8_r (rmIND8(rEBX),rAL) xOFS8(ofs)
                dwCount -= 1;
                ofs     += 1;
            }
        }

        if (mmx) { xEMMS }

        return;
    }

    /*
     * variable count - or long constant
     */
    if (dwCount)
    {
        xMOV_rm_imm (rmREG(rECX),dwCount)
    }
    else
    {
        dwCount = 0x7fffffff; // force all code paths
    }

    /*
     * 64 byte chunks
     */
    if (isKNI && (dwCount >= 64))
    {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),64)
        label1 = ilcCount;
        xJL          (0)
        if (isS16)
        {
            xMOVAPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVAPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x10)
            xMOVAPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x20)
            xMOVAPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x30)
        }
        else
        {
            xMOVLPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8 (0x08)
            xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x10)
            xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8 (0x18)
            xMOVLPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x20)
            xMOVHPS_r_rm (rXMM2,rmIND8(rEDX)) xOFS8 (0x28)
            xMOVLPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x30)
            xMOVHPS_r_rm (rXMM3,rmIND8(rEDX)) xOFS8 (0x38)
        }
        if (isD16)
        {
            xMOVAPS_rm_r (rmIND(rEBX),rXMM0)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x10)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x20)
            xMOVAPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x30)
        }
        else
        {
            xMOVLPS_rm_r (rmIND(rEBX),rXMM0)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM0) xOFS8 (0x08)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x10)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM1) xOFS8 (0x18)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x20)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM2) xOFS8 (0x28)
            xMOVLPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x30)
            xMOVHPS_rm_r (rmIND8(rEBX),rXMM3) xOFS8 (0x38)
        }
        xADD_rm_imm8 (rmREG(rEBX),64)
        xADD_rm_imm8 (rmREG(rEDX),64)
        xSUB_rm_imm8 (rmREG(rECX),64)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~63;
    }

    /*
     * 16-byte chunks
     */
    if (dwCount >= 16) {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),16)
        label1 = ilcCount;
        xJL          (0)
        if (isKNI)
        {
            if (isS16) { xMOVAPS_r_rm (rXMM0,rmIND(rEDX)) }
                  else { xMOVLPS_r_rm (rXMM0,rmIND(rEDX)) xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8 (8) }
            if (isD16) { xMOVAPS_rm_r (rmIND(rEBX),rXMM0) }
                  else { xMOVLPS_rm_r (rmIND(rEBX),rXMM0) xMOVHPS_rm_r (rmIND8(rEBX),rXMM0) xOFS8 (8) }
        } else if (isMMX)
        {
            xMOVQ_r_rm (rMM0,rmIND(rEDX))
            xMOVQ_r_rm (rMM1,rmIND8(rEDX)) xOFS8(8)
            xMOVQ_rm_r (rmIND(rEBX),rMM0)
            xMOVQ_rm_r (rmIND8(rEBX),rMM1) xOFS8(8)
            mmx = 1;
        } else
        {
            xMOV_r_rm (rEAX,rmIND(rEDX))
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8(4)
            xMOV_rm_r (rmIND(rEBX),rEAX)
            xMOV_rm_r (rmIND8(rEBX),rEBP) xOFS8(4)
            xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8(8)
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8(12)
            xMOV_rm_r (rmIND8(rEBX),rEAX) xOFS8(8)
            xMOV_rm_r (rmIND8(rEBX),rEBP) xOFS8(12)
        }
        xADD_rm_imm8 (rmREG(rEBX),16)
        xADD_rm_imm8 (rmREG(rEDX),16)
        xSUB_rm_imm8 (rmREG(rECX),16)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~15;
    }

    /*
     * 4-bytes
     */
    if (dwCount >= 4) {
        label2 = ilcCount;
        xCMP_rm_imm  (rmREG(rECX),4)
        label1 = ilcCount;
        xJL          (0)
        xMOV_r_rm (rEAX,rmIND(rEDX))
        xADD_rm_imm8 (rmREG(rEDX),4)
        xMOV_rm_r (rmIND(rEBX),rEAX)
        xADD_rm_imm8 (rmREG(rEBX),4)
        xSUB_rm_imm8 (rmREG(rECX),4)
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));

        dwCount &= ~3;
    }

    /*
     * 1-bytes
     */
    if (dwCount) {
        xTEST_rm_r   (rmREG(rECX),rECX)
        label1 = ilcCount;
        xJZ          (0)
        label2 = ilcCount;
        xMOV_r_rm8   (rAL,rmIND(rEDX))
        xINC_rm      (rmREG(rEDX))
        xMOV_rm8_r   (rmIND(rEBX),rAL)
        xINC_rm      (rmREG(rEBX))
        xDEC_rm      (rmREG(rECX))
        xJNZ         (label2)
        *(BYTE*)(ilcData + label1 + 1) = (BYTE)(ilcCount - (label1 + 2));
    }

    if (mmx) { xEMMS }
}

/*
 * ILCCompile_vertex
 *
 * send vertex to hardware
 *  edx = vertex start addr
 *  ebx = hw vertex position
 */
void ILCCompile_vertex
(
    DWORD dwPosition //= 0xffffffff for register ebx
)
{
    DWORD dwHWSize = (ilcFlags & LUIFLAG_DX6) ? 11 : 9;

    /*
     * select vertex type
     */
    if (dwPosition != 0xffffffff)
    {
        xMOV_rm_imm (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6)
                                 ?(0x0028e400 | dwPosition*40)
                                 :(0x0020e400 | dwPosition*32)))
    }
    else
    {
        if (ilcFlags & LUIFLAG_DX6)
        {
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEBX,x4)
            xSHL_rm_imm (rmREG(rEBX),3)
            xOR_rm_imm  (rmREG(rEBX),0x0028e400) // dx6 class specific
        }
        else
        {
            xSHL_rm_imm (rmREG(rEBX),5)
            xOR_rm_imm  (rmREG(rEBX),0x0020e400) // dx5 class specific
        }
    }

    /*
     * individual vertex overrides
     *  non-pipelined code for special cases (i.e need no gathering)
     *  ebx still has vertex type
     */
#ifdef NV_CONTROLTRAFFIC
    if (!(ilcFlags & (LUIFLAG_DX6 | LUIFLAG_FOGMODE | LUIFLAG_FVF | LUIFLAG_FIXEDWBUF | LUIFLAG_ZFRONT | LUIFLAG_ZBACK)))
#else
    if (!(ilcFlags & (LUIFLAG_DX6 | LUIFLAG_FOGMODE | LUIFLAG_FVF | LUIFLAG_FIXEDWBUF)))
#endif
    {
        /*
         * DX5 TL vertex
         */
        if (ilcFlags & LUIFLAG_KATMAI) // katmai version
        {
            xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOVLPS_r_rm (rXMM0,rmIND(rEDX))
            xMOVHPS_r_rm (rXMM0,rmIND8(rEDX)) xOFS8(8)
            xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(16)
            xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(24)
            xMOVLPS_rm_r (rmIND8(rESI),rXMM0) xOFS8(4)
            xMOVHPS_rm_r (rmIND8(rESI),rXMM0) xOFS8(12)
            xMOVLPS_rm_r (rmIND8(rESI),rXMM1) xOFS8(20)
            xMOVHPS_rm_r (rmIND8(rESI),rXMM1) xOFS8(28)
            xADD_rm_imm8 (rmREG(rESI),9*4)
            xSUB_rm_imm8 (rmREG(rEDI),9)
        }
        else if (ilcFlags & LUIFLAG_MMX) // mmx version
        {
                xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOVQ_r_rm (rMM0,rmIND(rEDX))
            xMOVQ_r_rm (rMM1,rmIND8(rEDX)) xOFS8(8)
            xMOVQ_r_rm (rMM2,rmIND8(rEDX)) xOFS8(16)
            xMOVQ_r_rm (rMM3,rmIND8(rEDX)) xOFS8(24)
                xMOVQ_rm_r (rmIND8(rESI),rMM0) xOFS8(4)
                xMOVQ_rm_r (rmIND8(rESI),rMM1) xOFS8(12)
                xMOVQ_rm_r (rmIND8(rESI),rMM2) xOFS8(20)
                xMOVQ_rm_r (rmIND8(rESI),rMM3) xOFS8(28)
            xEMMS
            xADD_rm_imm8   (rmREG(rESI),9*4)
            xSUB_rm_imm8   (rmREG(rEDI),9)
        }
        else // basic version
        {
                xMOV_rm_r  (rmIND(rESI),rEBX)
            xMOV_r_rm  (rEAX,rmIND(rEDX))
            xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(4)
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(8)
            xMOV_r_rm  (rEBP,rmIND8(rEDX)) xOFS8(12)
                xMOV_rm_r  (rmIND8(rESI),rEAX) xOFS8(4)
                xMOV_rm_r  (rmIND8(rESI),rEBX) xOFS8(8)
                xMOV_rm_r  (rmIND8(rESI),rECX) xOFS8(12)
                xMOV_rm_r  (rmIND8(rESI),rEBP) xOFS8(16)
            xMOV_r_rm  (rEAX,rmIND8(rEDX)) xOFS8(16)
            xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(20)
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(24)
            xMOV_r_rm  (rEBP,rmIND8(rEDX)) xOFS8(28)
                xMOV_rm_r  (rmIND8(rESI),rEAX) xOFS8(20)
                xMOV_rm_r  (rmIND8(rESI),rEBX) xOFS8(24)
                xMOV_rm_r  (rmIND8(rESI),rECX) xOFS8(28)
                xMOV_rm_r  (rmIND8(rESI),rEBP) xOFS8(32)
            xADD_rm_imm8   (rmREG(rESI),9*4)
            xSUB_rm_imm8   (rmREG(rEDI),9)
        }

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

#ifdef DEBUG
        /*
         * debug code
         */
        ILCCompile_dbgDisplayVertexData(9);
#endif // DEBUG

        /*
         * done
         */
        return;
    }


    /*
     * gather stage
     *  mostly does fvf decode and/or prepare for fog
     *  ebx still has vertex type
     *
     * gather buffer layout - (dx5 ? 36 : 44) bytes total
     *  +0  +4  +8  +12 +16 +20 +24 +28 +32 +36 +40
     *  vtx sx  sy  sz  rhw col spc u0  v0  u1  v1
     */
    if (ilcFlags & LUIFLAG_FVF)
    {
            xMOV_i32_r ( 0+(DWORD)&global.dwVertexGatherBuf,rEBX);
        // x,y,z
        xMOV_r_rm  (rEAX,rmIND(rEDX))
        xMOV_r_rm  (rEBX,rmIND8(rEDX)) xOFS8(4)
        xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8(8)
            xMOV_i32_r ( 4+(DWORD)&global.dwVertexGatherBuf,rEAX);
            xMOV_i32_r ( 8+(DWORD)&global.dwVertexGatherBuf,rEBX);
            xMOV_i32_r (12+(DWORD)&global.dwVertexGatherBuf,rECX);
        // color,specular,u0,v0
        xMOV_r_rm  (rEAX,rmREG(rEDX))
            xMOV_r_rm  (rEBX,rmREG(rEDX))
                xMOV_r_rm  (rECX,rmREG(rEDX))
                    xMOV_r_rm  (rEBP,rmREG(rEDX))
        xAND_r_i32 (rEAX,(DWORD)&fvfData.dwRHWMask)
            xAND_r_i32 (rEBX,(DWORD)&fvfData.dwARGBMask)
                xAND_r_i32 (rECX,(DWORD)&fvfData.dwSpecularMask)
                    xAND_r_i32 (rEBP,(DWORD)&fvfData.dwUVMask)
        xADD_r_i32 (rEAX,(DWORD)&fvfData.dwRHWOffset)
            xADD_r_i32 (rEBX,(DWORD)&fvfData.dwARGBOffset)
                xADD_r_i32 (rECX,(DWORD)&fvfData.dwSpecularOffset)
                    xADD_r_i32 (rEBP,(DWORD)&fvfData.dwUVOffset)
        xMOV_r_rm (rEAX,rmIND(rEAX))
            xMOV_r_rm (rEBX,rmIND(rEBX))
                xMOV_r_rm (rECX,rmIND(rECX))
                    xMOV_r_i32 (rEDX,(DWORD)&global.pdwUVOffset)
        xMOV_i32_r (16+(DWORD)&global.dwVertexGatherBuf,rEAX);
                    xMOV_r_rm  (rEAX,rmIND(rEDX))
            xMOV_i32_r (20+(DWORD)&global.dwVertexGatherBuf,rEBX);
                    xDS xMOV_r_rm (rEBX,rmSIB) xSIB(rEAX,rEBP,x1)
                xMOV_i32_r (24+(DWORD)&global.dwVertexGatherBuf,rECX);
                        xDS xMOV_r_rm (rECX,rmSIB8) xSIB(rEAX,rEBP,x1) xOFS8 (4)
                    xMOV_i32_r (28+(DWORD)&global.dwVertexGatherBuf,rEBX);
                        xMOV_i32_r (32+(DWORD)&global.dwVertexGatherBuf,rECX);
        // u1,v1
        if (ilcFlags & LUIFLAG_DX6)
        {
                    xMOV_r_rm  (rEAX,rmIND8(rEDX)) xOFS8(4)
                    xDS xMOV_r_rm (rEBX,rmSIB) xSIB(rEAX,rEBP,x1)
                        xDS xMOV_r_rm (rECX,rmSIB8) xSIB(rEAX,rEBP,x1) xOFS8 (4)
                    xMOV_i32_r (36+(DWORD)&global.dwVertexGatherBuf,rEBX);
                        xMOV_i32_r (40+(DWORD)&global.dwVertexGatherBuf,rECX);
        }
    }
    else
    {
        xMOV_i32_r (0+(DWORD)&global.dwVertexGatherBuf,rEBX);
        ILCCompile_move (4+(DWORD)&global.dwVertexGatherBuf,0/*edx*/,32); // always TL when not FVF
    }

    /*
     * apply fog
     */
    if (ilcFlags & LUIFLAG_FOGMODE)
    {
        BOOL isExp2 = (ilcFlags & LUIFLAG_FOGMODE) == 2;
        BOOL isLin  = (ilcFlags & LUIFLAG_FOGMODE) == 3;

        /*
         * st(0) = (global.dvWNear == 1.0f) ? z : approx(1.0 / rhw)
         */
        xMOV_rm_imm  (rmREG(rEBX),0x3f800000*2)
        xSUB_r_i32   (rEBX,16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xMOV_i32_r   ((DWORD)&global.dwTemp,rEBX)
        xFLD_i32     ((DWORD)&global.dwTemp)
        xFLD_st      (rST0)
        xFMUL_i32    (16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xFLD_i32     ((DWORD)&global.fFogC1)
        xFSUBRP_st   (rST1)
        xFMULP_st    (rST1)

        xFSTP_i32    ((DWORD)&global.dwTemp)
        xMOV_r_i32   (rEDX,12+(DWORD)&global.dwVertexGatherBuf) // z
        xAND_r_i32   (rEDX,(DWORD)&global.dwWMask1)

        xMOV_r_i32   (rEBX,(DWORD)&global.dwTemp)
        xAND_r_i32   (rEBX,(DWORD)&global.dwWMask2)

        xOR_r_rm     (rEBX,rmREG(rEDX))
        xMOV_i32_r   ((DWORD)&global.dwTemp,rEBX)

        xFLD_i32     ((DWORD)&global.dwTemp)

        if (isLin)
        {
            /*
             * st(0) = (fFogTableEnd - st(0)) * fFogTableLinearScale
             */
            xFLD_i32   ((DWORD)&global.fFogTableEnd)
            xFSUBRP_st (rST1)
            xFMUL_i32  ((DWORD)&global.fFogTableLinearScale)
        }
        else
        {
            /*
             * st(0) *= fFogTableDensity
             */
            xFMUL_i32  ((DWORD)&global.fFogTableDensity)

            if (isExp2)
            {
                /*
                 * st(0) *= st(0)
                 */
                xFMUL_st (rST0)
            }

            /*
             * st(0) = exp( st(0) )
             */
            xFMUL_i32   ((DWORD)&global.fFogC2)
            xFISTP_i32  ((DWORD)&global.dwTemp)
            xMOV_rm_imm (rmREG(rEAX),0x3f800000)
            xADD_i32_r  ((DWORD)&global.dwTemp,rEAX)
            xFLD_i32    ((DWORD)&global.dwTemp)
        }

        /*
         * eax = int8bits ( st(0) ) << 24
         */
        xFLD1
        xFADDP_st    (rST1)
        xFSTP_i32    ((DWORD)&global.dwTemp)
        xMOV_r_i32   (rEAX,(DWORD)&global.dwTemp)

        xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
        xSETG_rm8    (rmREG(rBL))
        xSHR_rm_imm  (rmREG(rEBX),1)
        xSBB_r_rm    (rEBP,rmREG(rEBP))

        xCMP_rm_imm  (rmREG(rEAX),0x40000000)
        xSETGE_rm8   (rmREG(rBL))
        xSHR_rm_imm  (rmREG(rEBX),1)
        xSBB_r_rm    (rEBX,rmREG(rEBX))

        xSHL_rm_imm  (rmREG(rEAX),9)
        xOR_r_rm     (rEAX,rmREG(rEBX))
        xAND_r_rm    (rEAX,rmREG(rEBP))
        xAND_rm_imm  (rmREG(rEAX),0xff000000)

        /*
         * update specular
         */
        xMOV_r_i32   (rEBX,24+(DWORD)&global.dwVertexGatherBuf) // spec
        xAND_rm_imm  (rmREG(rEBX),0x00ffffff)
        xOR_r_rm     (rEBX,rmREG(rEAX))
        xMOV_i32_r   (24+(DWORD)&global.dwVertexGatherBuf,rEBX) // spec
    }

    /*
     * apply fixed w-buffer scale
     */
    if (ilcFlags & LUIFLAG_FIXEDWBUF)
    {
        xFLD_i32  (16+(DWORD)&global.dwVertexGatherBuf) // rhw
        xFMUL_i32 ((DWORD)&global.fRWFar)
        xFSTP_i32 (16+(DWORD)&global.dwVertexGatherBuf) // rhw
    }

    /*
     * optimized z
     */
#ifdef NV_CONTROLTRAFFIC
    if (ilcFlags & (LUIFLAG_ZFRONT | LUIFLAG_ZBACK))
    {
        xMOV_r_i32   (rEAX,12+(DWORD)&global.dwVertexGatherBuf) // z

        if (ilcFlags & LUIFLAG_ZFRONT)
        {
            /*
             * clamp z to 1.0f
             */
            xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
            xSETG_rm8    (rmREG(rBL))
            xSHR_rm_imm  (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax > 1.0f) ? -1 : 0

            xMOV_r_rm    (rECX,rmREG(rEBX))
            xNOT_rm      (rmREG(rECX))          // ecx = (eax > 1.0f) ? 0 : -1

            xAND_rm_imm  (rmREG(rEBX),0x3f800000)
            xAND_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm     (rEAX,rmREG(rEBX))
        }

        if (ilcFlags & LUIFLAG_ZBACK)
        {
            /*
             * clamp z to 0.0f
             */
            xMOV_r_rm    (rEBX,rmREG(rEAX))
            xSHL_rm_imm  (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax <= -0.0f) ? -1 : 0
            xNOT_rm      (rmREG(rEBX))          // ebx = (eax <= -0.0f) ? 0 : -1
            xAND_r_rm    (rEAX,rmREG(rEBX))
        }

        xMOV_i32_r   ((DWORD)&global.dwTemp,rEAX)

        /*
         * optimize
         */
        xFLD_i32  ((DWORD)&global.dwTemp)
        xFMUL_i32 ((DWORD)&global.fCTC1);
        if (ilcFlags & LUIFLAG_ZBACK)
        {
            xFLD1
            xFSUBRP_st (rST1);
        }
        xFSTP_i32  (12+(DWORD)&global.dwVertexGatherBuf) // z
    }
#endif //NV_CONTROLTRAFFIC

    /*
     * copy to push buffer
     */
    xMOV_r_rm (rEBX,rmREG(rESI))
    ILCCompile_move (0/*ebx*/,(DWORD)&global.dwVertexGatherBuf,dwHWSize*4);
    xADD_rm_imm8   (rmREG(rESI),dwHWSize*4)
    xSUB_rm_imm8   (rmREG(rEDI),dwHWSize)

#ifdef CHECK_VALID_PUSHER
    {
        DWORD l;
        xTEST_rm_imm (rmREG(rEDI),0x80000000)
        l = ilcCount;
        xJZ          (0)
        xINT3
        *(BYTE*)(ilcData + l + 1) = (BYTE)(ilcCount - (l + 2));
    }
#endif

#ifdef DEBUG
    /*
     * debug code
     */
    ILCCompile_dbgDisplayVertexData (dwHWSize);
#endif // DEBUG

}

/*
 * ILCCompile_launch
 *
 * send vertex to hardware
 *  eax,ebx,ecx will be used if dwCode == -1
 *  eax         will be used if dwCode == -2
 */
void ILCCompile_launch
(
    DWORD dwCode // == -1 for launch out of eax,ebx and ecx, -2 for launch from packed eax
)
{
#ifdef PIX1
    dwCode = (ilcFlags & LUIFLAG_DX6) ? 0x765 : 0xfed;
#endif //PIX1

    xMOV_rm_imm  (rmREG(rEDX),((ilcFlags & LUIFLAG_DX6) ? 0x0004e540 : 0x0004e600))
    switch (dwCode)
    {
        case 0xffffffff:
        {
            xSHL_rm_imm (rmREG(rECX),8)
            xSHL_rm_imm (rmREG(rEBX),4)
            xOR_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm    (rEAX,rmREG(rEBX))
            break;
        }
        case 0xfffffffe:
        {
            break;
        }
        default:
        {
            xMOV_rm_imm (rmREG(rEAX),dwCode)
            break;
        }
    }
    xMOV_rm_r    (rmIND(rESI),rEDX)
    xMOV_rm_r    (rmIND8(rESI),rEAX) xOFS8(4)
    xADD_rm_imm8 (rmREG(rESI),2*4)
    xSUB_rm_imm8 (rmREG(rEDI),2)
}

/****************************************************************************
 * inner loop generator                                                     *
 ****************************************************************************/

/*
 * ILCCompileCode
 *
 * Returns the entry point of a loop that will emit triangles in the format
 * specified. fvfData is implicitly passed
 */
DWORD ILCCompileCode
(
    DWORD dwFlags
)
{
    DWORD label_entry;
    DWORD label_loop;
    DWORD label_warmup;
    DWORD label_draw;
    DWORD label_cullbranch;
    DWORD label_arb11;
    DWORD label_arb12;
    DWORD label_arb21;
    DWORD label_arb22;
    DWORD ilcVertexSize;

    /*
     * setup
     */
    ilcFlags      = dwFlags;
    ilcVertexSize = (ilcFlags & LUIFLAG_DX6) ? 11 : 9;

    /*
     * begin code generation
     */
    while (ilcCount & 31) { xINT3 } // branch prediction helper


    /*
     * pocket of subroutines
     * ---------------------
     */

    /*
     * arbitration code (indexed lists)
     */
    label_arb11 = ilcCount;
    xADD_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_ADD : VC_DX5_ADD))
    xAND_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
    //xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
    //xJZ          (label_arb11)
    label_arb12 = ilcCount;
    xJMP         (0)
    while (ilcCount & 31) { xINT3 } // branch prediction helper

    label_arb21 = ilcCount;
    xADD_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_ADD : VC_DX5_ADD))
    xAND_rm_imm8 (rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
    xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
    xJZ          (label_arb21)
    xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex1)
    xJZ          (label_arb21)
    label_arb22 = ilcCount;
    xJMP         (0)
    while (ilcCount & 31) { xINT3 } // branch prediction helper


    /*
     * function entry code
     * -------------------
     */
    label_entry = ilcCount;
    xPUSH_r     (rEBP)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)
    xMOV_r_i32  (rESI,(DWORD)&nvFifo);
    xMOV_r_i32  (rEDI,(DWORD)&nvFreeCount);


/*
    if (ilcFlags == 0x10010)
    {
        xINT3
        //__asm int 3
    }
//*/

    /*
     * warm cache
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex0)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwTemp)
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexCache)
    if ((ilcFlags & LUIFLAG_FOGMODE) || (ilcFlags & LUIFLAG_FVF))
    {
        // gather buffer
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexGatherBuf)
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexGatherBuf2)
    }
    xMOV_r_rm (rEAX,rmREG(rEBP)) // kill eax so we wont stall

    /*
     * setup loop
     * ----------
     */
    if (ilcFlags & LUIFLAG_INDEXED)
    {
        /*
         * setup indices
         */
        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xMOV_i32_r  ((DWORD)&global.dwIndex0,rEAX)
        xINC_r      (rEAX)
        xMOV_i32_r  ((DWORD)&global.dwIndex1,rEAX)
        xINC_r      (rEAX)
        xMOV_i32_r  ((DWORD)&global.dwIndex2,rEAX)
        switch (ilcFlags & LUIFLAG_STRIDES)
        {
            case 0x04: // strip
            case 0x08: // fan
            {
                /*
                 * cull state
                 */
                xMOV_rm_imm (rmREG(rEBX),0x210)
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEBX)

                /*
                 * basic translation
                 */
                xMOV_r_i32   (rEAX,(DWORD)&global.pIndices)
                xMOV_r_i32   (rEDX,(DWORD)&global.pVertices)
                xMOV_r_rm    (rEBX,rmIND(rEAX))
                        xMOV_r_rm    (rECX,rmREG(rEBX))
                xADD_rm_imm8 (rmREG(rEAX),4)
                    xAND_rm_imm  (rmREG(rEBX),0xffff)
                        xSHR_rm_imm  (rmREG(rECX),16)
                xMOV_i32_r   ((DWORD)&global.pIndices,rEAX)
                    ILCCompile_mulvertexstride (rEBX);
                        ILCCompile_mulvertexstride (rECX);
                    xADD_r_rm    (rEBX,rmREG(rEDX))
                        xADD_r_rm    (rECX,rmREG(rEDX))
                    xMOV_i32_r   ((DWORD)&global.dwVertex0,rEBX)
                        xMOV_i32_r   ((DWORD)&global.dwVertex1,rECX)
                break;
            }
        }

        /*
         * vertex cache serial number update
         */
        xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexSN)
        xADD_rm_imm(rmREG(rEAX),0x10000)
        xMOV_i32_r ((DWORD)&global.dwVertexSN,rEAX)
    }
    else
    {
        xMOV_r_i32  (rEAX,(DWORD)&global.pVertices)
        xMOV_i32_r ((DWORD)&global.dwVertex0,rEAX)
        xADD_r_i32  (rEAX,(DWORD)&fvfData.dwVertexStride)
        xMOV_i32_r ((DWORD)&global.dwVertex1,rEAX)
        xADD_r_i32  (rEAX,(DWORD)&fvfData.dwVertexStride)
        xMOV_i32_r ((DWORD)&global.dwVertex2,rEAX)

        switch (ilcFlags & LUIFLAG_STRIDES)
        {
            case 0x04: // strip
            case 0x08: // fan
            {
                xMOV_i32_r  ((DWORD)&global.pVertices,rEAX)
                /*
                 * cull state
                 */
                xMOV_rm_imm (rmREG(rEBX),0x210)
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEBX)
                break;
            }
        }
    }

    /*
     * inner loop setup
     * ----------------
     */
    label_loop = ilcCount;

    /*
     * cache warm-up
     * -------------
     *
     * pIndices must be kept up to date for the warm-up phase. So does pVertices for
     *  ordered primitives
     */

    /*
     * leave the number of primitives in ebx, number of verts in dwVertSubCount
     */
    switch (ilcFlags & LUIFLAG_STRIDES)
    {
        case 0x00: // list
        case 0x0c: // legacy
        {
            // prim = 3*vert, 32 triangles per batch (96 verts)
            xMOV_r_i32  (rEAX,(DWORD)&global.dwPrimCount)
            xMOV_r_rm   (rEBX,rmREG(rEAX))
            xSUB_rm_imm (rmREG(rEBX),32)
            xSBB_r_rm   (rECX,rmREG(rECX))
            xMOV_r_rm   (rEBX,rmREG(rECX))
            xNOT_rm     (rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),32)
            xAND_r_rm   (rECX,rmREG(rEAX))
            xOR_r_rm    (rEBX,rmREG(rECX))
            xMOV_i32_r  ((DWORD)&global.dwPrimSubCount,rEBX)
            xSUB_i32_r  ((DWORD)&global.dwPrimCount,rEBX);
            xLEA_r_rm   (rEBX,rmSIB); xSIB(rEBX,rEBX,x2);
            // result in ebx
            break;
        }
        case 0x04: // strip
        case 0x08: // fan
        {
            // prim = vert, 96 triangles per batch
            xMOV_r_i32  (rEAX,(DWORD)&global.dwPrimCount)
            xMOV_r_rm   (rEBX,rmREG(rEAX))
            xSUB_rm_imm (rmREG(rEBX),96)
            xSBB_r_rm   (rECX,rmREG(rECX))
            xMOV_r_rm   (rEBX,rmREG(rECX))
            xNOT_rm     (rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),96)
            xAND_r_rm   (rECX,rmREG(rEAX))
            xOR_r_rm    (rEBX,rmREG(rECX))
            xMOV_i32_r  ((DWORD)&global.dwPrimSubCount,rEBX)
            xSUB_i32_r  ((DWORD)&global.dwPrimCount,rEBX);
            // result in ebx
            break;
        }
    }

    /*
     * step through ebx vertices and just fetch them
     */
    xMOV_r_rm (rECX,rmREG(rEBX));
    if (ilcFlags & LUIFLAG_INDEXED)
    {
        xMOV_r_i32 (rEBX,(DWORD)&global.pIndices)
        if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
        {
            xMOV_rm_imm (rmREG(rEBP),3);
        }
        label_warmup = ilcCount;

        xXOR_r_rm    (rEAX,rmREG(rEAX));
   x16r xMOV_r_rm    (rAX,rmIND(rEBX));
        xADD_rm_imm8 (rmREG(rEBX),2);
        ILCCompile_mulvertexstride (rEAX);
        xADD_r_i32 (rEAX,(DWORD)&global.pVertices)
        xMOV_r_rm  (rEAX,rmIND(rEAX))
        if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
        {
            xMOV_rm_imm (rmREG(rEAX),0) // explicit move so we don't wait for eax to do xor eax,eax
            xDEC_rm     (rmREG(rEBP))
            xSETZ_rm8   (rmREG(rAL))
            xLEA_r_rm   (rEAX,rmSIB); xSIB(rEAX,rEAX,x2);
            xOR_r_rm    (rEBP,rmREG(rEAX))
            xAND_rm_imm8(rmREG(rEAX),2)
            xADD_r_rm   (rEBX,rmREG(rEAX))
        }
        else
        {
            xMOV_r_rm   (rEAX,rmREG(rEBP)) // kill eax so uproc do not try to wait for it to come in
        }
    }
    else
    {
        xMOV_r_i32   (rEBX,(DWORD)&global.pVertices)
        xMOV_r_i32   (rEDX,(DWORD)&fvfData.dwVertexStride)
        label_warmup = ilcCount;

        xMOV_r_rm (rEAX,rmIND(rEBX))
        xMOV_r_rm (rEAX,rmREG(rEBP)) // kill eax so uproc do not try to wait for it to come in
        xADD_r_rm (rEBX,rmREG(rEDX))
    }

    xDEC_r     (rECX)
    xJNZ       (label_warmup)

    /*
     * dispatch triangles
     * ------------------
     */
    label_draw = ilcCount;

    /*
     * we have a couple of different inner loop styles
     * each are treated special (don't say I don't work for my money... although anybody
     * that has to debug this would probably want to shoot me!  ;) )
     *
     */
    switch (ilcFlags & LUIFLAG_STRIDES)
    {
        case 0x00: // list
        case 0x0c: // legacy
        {
            /*
             * translate indices to vertices
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                xMOV_r_i32 (rECX,(DWORD)&global.pIndices)
                xMOV_r_i32 (rEDX,(DWORD)&global.pVertices)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex0,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex0,rEBX)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex1,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)

                xXOR_r_rm  (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm  (rBX,rmIND(rECX))
                xADD_rm_imm8(rmREG(rECX),2)
                xMOV_i32_r ((DWORD)&global.dwIndex2,rEBX)
                ILCCompile_mulvertexstride (rEBX);
                xADD_r_rm  (rEBX,rmREG(rEDX))
                xMOV_i32_r ((DWORD)&global.dwVertex2,rEBX)

                if ((ilcFlags & LUIFLAG_STRIDES) == 0x0c)
                {
                    xADD_rm_imm8(rmREG(rECX),2)
                }

                xMOV_i32_r ((DWORD)&global.pIndices,rECX)
            }

            /*
             * perform cull check
             */
            ILCCompile_cullcheck();
            label_cullbranch = ilcCount;
            xJZ32 (0); // to be patched up later

#ifdef NV_PROFILE // add result to triangle area - only if enabled
            if (nvpEnableBits & ((1 << NVP_C_TRIAREA) | (3 << NVP_C_1PIXCLK) | (1 << NVP_C_PIXPERSEC)))
            {
                xPUSH_i32   ((DWORD)&global.dwTemp)
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvProfileArea)
                xCALL_rm    (rmREG(rEAX))
            }
#endif

            /*
             * check push buffer space
             */
            ILCCompile_reserve (ilcVertexSize*3 + 2);

            /*
             * send geometry
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                DWORD label;

                /*
                 * vertex 0
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex0)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex0,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * vertex 1
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex1)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate (ebx != dwIndex0)
                xCMP_r_i32   (rEBX,(DWORD)&global.dwIndex0)
                xJZ32       (label_arb11)
                *(DWORD*)(ilcData + label_arb12 + 1) = ilcCount - (label_arb12 + 5);
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex1,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * vertex 2
                 */
                // setup
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex2)
                xMOV_r_rm   (rEBX,rmREG(rEAX))
                xOR_r_i32   (rEAX,(DWORD)&global.dwVertexSN)
                xAND_rm_imm8(rmREG(rEBX),((ilcFlags & LUIFLAG_DX6) ? VC_DX6_AND : VC_DX5_AND))
                // arbitrate (ebx != dwIndex0)
                xCMP_r_i32  (rEBX,(DWORD)&global.dwIndex0)
                xJZ32       (label_arb21)
                xCMP_r_i32  (rEBX,(DWORD)&global.dwIndex1)
                xJZ32       (label_arb21)
                *(DWORD*)(ilcData + label_arb22 + 1) = ilcCount - (label_arb22 + 5);
                // test
                xCMP_r_rm   (rEAX,rmSIB) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // cmp eax,[vc+ebx*4]
                xMOV_i32_r  ((DWORD)&global.dwIndex2,rEBX)
                label = ilcCount;
                xJZ32       (0)
                // send
                xMOV_rm_r   (rmSIB,rEAX) xSIB(rEBP,rEBX,x4) xOFS32((DWORD)&global.dwVertexCache) // mov [vc+ebx*4],eax
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
                ILCCompile_vertex (0xffffffff);
                *(DWORD*)(ilcData + label + 2) = ilcCount - (label + 6);
                /*
                 * launch triangle
                 */
                xMOV_r_i32  (rEAX,(DWORD)&global.dwIndex0)
                xMOV_r_i32  (rEBX,(DWORD)&global.dwIndex1)
                xMOV_r_i32  (rECX,(DWORD)&global.dwIndex2)
                ILCCompile_launch (0xffffffff);
            }
            else
            {
                /*
                 * vertices
                 */
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
                ILCCompile_vertex (0);
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
                ILCCompile_vertex (1);
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
                ILCCompile_vertex (2);
                /*
                 * launch triangle
                 */
                ILCCompile_launch (0x00000210);
            }

            /*
             * patch up cull
             */
            *(DWORD*)(ilcData + label_cullbranch + 2) = ilcCount - (label_cullbranch + 6);

#ifdef DEBUG
            /*
             * debug code
             */
            ILCCompile_dbgFlushTriangle();
#endif

            /*
             * next
             */
            if (!(ilcFlags & LUIFLAG_INDEXED))
            {
                xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                xLEA_r_rm  (rEAX,rmSIB) xSIB(rEAX,rEAX,x2)
                xADD_i32_r ((DWORD)&global.dwVertex0,rEAX)
                xADD_i32_r ((DWORD)&global.dwVertex1,rEAX)
                xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                xADD_i32_r ((DWORD)&global.pVertices,rEAX)
            }
            break;
        }
        case 0x04: // strip
        case 0x08: // fan
        {
            BOOL  isFan = (ilcFlags & LUIFLAG_STRIDES) == 0x08;
            DWORD label_vx0;
            DWORD label_vx1;

            /*
             * translate index into vertex
             */
            if (ilcFlags & LUIFLAG_INDEXED)
            {
                xMOV_r_i32   (rECX,(DWORD)&global.pIndices)
                xMOV_r_i32   (rEDX,(DWORD)&global.pVertices)
                xXOR_r_rm    (rEBX,rmREG(rEBX))
           x16r xMOV_r_rm    (rBX,rmIND(rECX))
                xADD_rm_imm8 (rmREG(rECX),2)
                ILCCompile_mulvertexstride (rEBX);
                xMOV_i32_r   ((DWORD)&global.pIndices,rECX)
                xADD_r_rm    (rEBX,rmREG(rEDX))
                xMOV_i32_r   ((DWORD)&global.dwVertex2,rEBX)
            }

            /*
             * perform cull check
             */
            ILCCompile_cullcheck();
            label_cullbranch = ilcCount;
            xJZ32 (0) // to be patched up later

#ifdef NV_PROFILE // add result to triangle area - only if enabled
            if (nvpEnableBits & ((1 << NVP_C_TRIAREA) | (3 << NVP_C_1PIXCLK) | (1 << NVP_C_PIXPERSEC)))
            {
                xPUSH_i32   ((DWORD)&global.dwTemp)
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvProfileArea)
                xCALL_rm    (rmREG(rEAX))
            }
#endif

            /*
             * check push buffer space
             */
            ILCCompile_reserve (ilcVertexSize*3 + 2);

            /*
             * vertex 0
             */
            xMOV_r_i32    (rEBX,(DWORD)&global.dwStripFanData)
            xTEST_rm_imm  (rmREG(rEBX),0x40000)
            label_vx0 = ilcCount;
            xJNZ32        (0)

            xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex0)
            xAND_rm_imm (rmREG(rEBX),0x00f)
            ILCCompile_vertex (0xffffffff);

            *(DWORD*)(ilcData + label_vx0 + 2) = ilcCount - (label_vx0 + 6);

            /*
             * vertex 1
             */
            xMOV_r_i32    (rEBX,(DWORD)&global.dwStripFanData)
            xTEST_rm_imm  (rmREG(rEBX),0x20000)
            label_vx1 = ilcCount;
            xJNZ32        (0)

            xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex1)
            xAND_rm_imm (rmREG(rEBX),0x0f0)
            xSHR_rm_imm (rmREG(rEBX),4)
            ILCCompile_vertex (0xffffffff);

            *(DWORD*)(ilcData + label_vx1 + 2) = ilcCount - (label_vx1 + 6);

            /*
             * vertex 2
             */
            xMOV_r_i32  (rEBX,(DWORD)&global.dwStripFanData)
                xMOV_r_i32  (rEDX,(DWORD)&global.dwVertex2)
            xAND_rm_imm (rmREG(rEBX),0xf00)
            xSHR_rm_imm (rmREG(rEBX),8)
            ILCCompile_vertex (0xffffffff);

            /*
             * launch
             */
            xMOV_r_i32    (rEAX,(DWORD)&global.dwStripFanData)
                xMOV_r_rm     (rECX,rmREG(rEAX))
            xAND_rm_imm   (rmREG(rEAX),0xfff)
                xOR_rm_imm    (rmREG(rECX),0x70000)
                xMOV_i32_r    ((DWORD)&global.dwStripFanData,rECX)
            ILCCompile_launch (0xfffffffe);

            /*
             * patch up cull
             */
            *(DWORD*)(ilcData + label_cullbranch + 2) = ilcCount - (label_cullbranch + 6);

#ifdef DEBUG
            /*
             * debug code
             */
            ILCCompile_dbgFlushTriangle();
#endif

            /*
             * fan next tri
             */
            if (isFan)
            {
                xMOV_r_i32  (rEAX,(DWORD)&global.dwStripFanData)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                xXOR_rm_imm (rmREG(rEAX),0x330)
                    xSHL_rm_imm (rmREG(rEBX),1)
                xAND_rm_imm (rmREG(rEAX),0x40fff)
                    xAND_rm_imm (rmREG(rEBX),0x30000)
                xOR_r_rm (rEAX,rmREG(rEBX))
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEAX)

                xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex2)
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)
                if (!(ilcFlags & LUIFLAG_INDEXED))
                {
                    xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                    xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                    xADD_i32_r ((DWORD)&global.pVertices,rEAX)
                }
            }
            /*
             * strip next tri
             */
            else
            {
                xMOV_rm_imm (rmREG(rEAX),0x80000000)
                xXOR_i32_r  ((DWORD)&global.dwCullMask1,rEAX)

                xMOV_r_i32  (rEAX,(DWORD)&global.dwStripFanData)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                        xMOV_r_rm   (rECX,rmREG(rEAX))
                xSHR_rm_imm (rmREG(rEAX),4)
                    xSHL_rm_imm (rmREG(rEBX),1)
                        xSHL_rm_imm (rmREG(rECX),8)
                xAND_rm_imm (rmREG(rEAX),0x0ff)
                    xAND_rm_imm (rmREG(rEBX),0x70000)
                        xAND_rm_imm (rmREG(rECX),0xf00)
                xOR_r_rm (rEAX,rmREG(rEBX))
                xOR_r_rm (rEAX,rmREG(rECX))
                xMOV_i32_r  ((DWORD)&global.dwStripFanData,rEAX)

                xMOV_r_i32 (rEAX,(DWORD)&global.dwVertex1)
                xMOV_r_i32 (rEBX,(DWORD)&global.dwVertex2)
                xMOV_i32_r ((DWORD)&global.dwVertex0,rEAX)
                xMOV_i32_r ((DWORD)&global.dwVertex1,rEBX)
                if (!(ilcFlags & LUIFLAG_INDEXED))
                {
                    xMOV_r_i32 (rEAX,(DWORD)&fvfData.dwVertexStride)
                    xADD_i32_r ((DWORD)&global.dwVertex2,rEAX)
                    xADD_i32_r ((DWORD)&global.pVertices,rEAX)
                }
            }

            break;
        }
    }
    /*
     * prepare next primitive and loop
     * -------------------------------
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwPrimSubCount)
    xDEC_rm    (rmREG(rEAX))
    xMOV_i32_r ((DWORD)&global.dwPrimSubCount,rEAX)
    xJNZ32     (label_draw)

    /*
     * prepare next batch and loop
     * ---------------------------
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwPrimCount)
    xTEST_rm_r (rmREG(rEAX),rEAX)
    xJNZ32     (label_loop)

    /*
     * function exit code
     * ------------------
     */
    xMOV_i32_r ((DWORD)&nvFifo,rESI);
    xMOV_i32_r ((DWORD)&nvFreeCount,rEDI);
    xPOP_r     (rEDI)
    xPOP_r     (rESI)
    xPOP_r     (rEBP)
    xRET

    /*
     * done
     *  label_entry may never be 0
     */
    return label_entry;
}

/*
 * ILCGrowTo
 *
 * grows ilcData to asked for (or larger) size
 */
void ILCGrowTo
(
    DWORD dwNeed
)
{
    /*
     * determine how much memory we need
     */
    if (dwNeed > ilcMax)
    {
        /*
         * grow
         */
#ifdef DEBUG
        DWORD ilcOld = ilcMax;
#endif
        ilcMax  = (dwNeed + 4095) & ~4095;
        ilcData = (BYTE*)ReallocIPM(ilcData,ilcMax);
        // if this fails we are truly screwed
#ifdef DEBUG
        if (!ilcData)
        {
            DPF ("Memory allocation failed - things are going to go terribly wrong now");
            _asm int 3
        }

        memset (ilcData+ilcOld,0xcc,ilcMax-ilcOld);
#endif
    }
}

/****************************************************************************
 * C helper code                                                            *
 ****************************************************************************/

/*
 * TriangleSetup only choose the major things like:
 *      dx5 or dx6
 *      fog
 *      basic, mmx or katmai
 *      fixed wbuffer
 *
 * TriangleDispatch deal with:
 *      indexed vs non-indexed
 *      fvf vs non fvf
 *      list,strip,fan
 */


/*
 * nvDX5TriangleSetup
 *
 * DX5 triangle setup
 */
void __stdcall nvDX5TriangleSetup
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * override for aa
     * aa must be enabled and we must not be capturing the push buffer
     */
    if ( (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
     && !(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        pCurrentContext->dwFunctionLookup = NV_AA_FUNCTION_INDEX;
        nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
        return;
    }
    /*
     * calc appropriate render function
     */
    pCurrentContext->dwFunctionLookup = (pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)
#ifndef FLOAT_W
                                      | ((pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? LUIFLAG_FIXEDWBUF : 0)
#endif
                                      | ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                                      | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0);

#ifdef NV_CONTROLTRAFFIC
    if (pCurrentContext->dwCTFlags & NV_CT_ENABLED)
    {
        pCurrentContext->dwFunctionLookup |= (pCurrentContext->dwCTFlags & NV_CT_FRONT)
                                           ? LUIFLAG_ZFRONT
                                           : LUIFLAG_ZBACK;
    }
#endif //NV_CONTROLTRAFFIC

    return;
}

/*
 * nvDX6TriangleSetup
 *
 * DX6 triangle setup
 */
void __stdcall nvDX6TriangleSetup
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    /*
     * setup HW if needed
     */
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5TriangleSetup(dwPrimCount,pIndices,dwStrides,pVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);

    /*
     * override for aa
     * aa must be enabled and we must not be capturing the push buffer
     */
    if ( (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
     && !(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        pCurrentContext->dwFunctionLookup = NV_AA_FUNCTION_INDEX;
        nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
        return;
    }

    /*
     * calc appropriate render function
     */
    pCurrentContext->dwFunctionLookup = (pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)
#ifndef FLOAT_W
                                      | ((pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? LUIFLAG_FIXEDWBUF : 0)
#endif
                                      | ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                                      | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0)
                                      | LUIFLAG_DX6
                                      | LUIFLAG_FVF;

#ifdef NV_CONTROLTRAFFIC
    if (pCurrentContext->dwCTFlags & NV_CT_ENABLED)
    {
        pCurrentContext->dwFunctionLookup |= (pCurrentContext->dwCTFlags & NV_CT_FRONT)
                                           ? LUIFLAG_ZFRONT
                                           : LUIFLAG_ZBACK;
    }
#endif //NV_CONTROLTRAFFIC

    return;
}


/*
 * nvTriangleDispatch(dwPrimCount,NULL,LEGACY_STRIDES,(LPBYTE)lpVertices);
 *
 * calls the triangle inner loop code
 *  - if it does not exist yet, build it
 */
void __stdcall nvTriangleDispatch
(
    DWORD  dwPrimCount,
    LPWORD pIndices,
    DWORD  dwStrides,
    LPBYTE pVertices
)
{
    DWORD dwFLUI;
    DWORD dwDrawPrim;

    if (!dwPrimCount) return; // do not waste time (or crash code that assume real work to be done)

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        nvPusherDisassemblerEnable = 1;
    }
    */

    /*
     * get function pointer
     */
    dwFLUI = pCurrentContext->dwFunctionLookup;

    /*
     * if we have to call a fixed function, do it now
     *  current fixed functions are
     *      nvTriangleSetup
     *      nvAACapturePrimitive
     */
    if ((dwFLUI & LUIMASK_BRANCH) >= NV_FIXED_FUNCTION_INDEX)
    {
        switch (dwFLUI)
        {
            case NV_AA_FUNCTION_INDEX:
            {
                nvAACapturePrimitive (dwPrimCount,pIndices,dwStrides,pVertices);
                return;
            }
            case NV_SETUP_FUNCTION_INDEX:
            {
                (pCurrentContext->bUseDX6Class ? nvDX6TriangleSetup
                                               : nvDX5TriangleSetup)(dwPrimCount,pIndices,dwStrides,pVertices);

                /*
                 * reset dwFLUI
                 */
                dwFLUI = pCurrentContext->dwFunctionLookup;

                /*
                 * fall through so we can draw the primitives except for AA
                 */
                if ((dwFLUI & LUIMASK_BRANCH) >= NV_FIXED_FUNCTION_INDEX) return;


                break;
            }
        }
    }

#ifdef NV_TEX2
    /*
     * tell texture manager that we are now going to use textures
     * the calls may modify state so that we have to redo HW
     */
    if (pCurrentContext->pTexture0 || pCurrentContext->pTexture1)
    {
        if (pCurrentContext->pTexture0)
            nvTextureRef (pCurrentContext->pTexture0);
        if (pCurrentContext->pTexture1)
            nvTextureRef (pCurrentContext->pTexture1);
        /*
         * if the above changed state - update now
         * yes, it is possible to call setup twice but this happens very infrequently
         */
        (pCurrentContext->bUseDX6Class ? nvDX6TriangleSetup
                                       : nvDX5TriangleSetup)(dwPrimCount,pIndices,dwStrides,pVertices);

        /*
         * reset dwFLUI
         */
        dwFLUI = pCurrentContext->dwFunctionLookup;
    }
#endif

    /*
     * compute proper Lookup Index (LUI).
     *  nvTriangleSetup can only choose the major things like:
     *      dx5 or dx6
     *      fog
     *      (basic, mmx or katmai - determined at startup)
     *
     *  here we have to modify the pointer to deal with:
     *      indexed vs non-indexed
     *      fvf vs non fvf
     *      list,strip,fan
     */
    dwFLUI |= ( pIndices                                 ? LUIFLAG_INDEXED : 0)
           |  ((fvfData.dwVertexType != D3DFVF_TLVERTEX) ? LUIFLAG_FVF     : 0)
           |  ((dwStrides >> 24) << 2);

    /*
     * (dbgLevel & NVDBG_LEVEL_FASTLOOPS) will tell the world what we did here
     */
#if defined(DEBUG) || defined(PRINT_NAME)
    {
        static char *szFog[] = {"","ExpFog","Exp2Fog","LinFog"};
        static char *szPMT[] = {"List","Strip","Fan","Legacy"};
        static char *szIdx[] = {"Ordered","Indexed"};
        static char *szFVF[] = {"","FVF"};
        static char *szDX6[] = {"DX5","DX6"};
        static char *szFWB[] = {"","FixedWB"};
        static char *szMMX[] = {"","_MMX"};
        static char *szKTM[] = {"","_KATMAI"};
        char sz[512];
        strcpy (sz,"nvTriangleDispatch: ");
        strcat (sz,szDX6[(dwFLUI & LUIFLAG_DX6)       ? 1 : 0]);
        strcat (sz,szFVF[(dwFLUI & LUIFLAG_FVF)       ? 1 : 0]);
        strcat (sz,szFog[dwFLUI & LUIFLAG_FOGMODE]);
        strcat (sz,szIdx[(dwFLUI & LUIFLAG_INDEXED)   ? 1 : 0]);
        strcat (sz,"Triangle");
        strcat (sz,szPMT[(dwFLUI & LUIFLAG_STRIDES)>>2]);
        strcat (sz,szFWB[(dwFLUI & LUIFLAG_FIXEDWBUF) ? 1 : 0]);
        strcat (sz,szMMX[(dwFLUI & LUIFLAG_MMX)       ? 1 : 0]);
        strcat (sz,szKTM[(dwFLUI & LUIFLAG_KATMAI)    ? 1 : 0]);
        strcat (sz," (dwFLUI = %02x)");
#ifdef PRINT_NAME
        {
            char sz2[256];
            wsprintf (sz2,sz,dwFLUI);
            strcat (sz2,"\n");
            OutputDebugString (sz2);
        }
#else
        DPF_LEVEL (NVDBG_LEVEL_FASTLOOPS,sz,dwFLUI);
#endif
    }
#endif // DEBUG

    /*
     * get fptr
     */
    dwDrawPrim = dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH];

    /*
     * compile it if it does not exist
     */
    if (!dwDrawPrim)
    {
#ifdef NV_PROFILE
        NVP_START (NVP_T_BUILDLOOP);
#endif
        dwDrawPrim                                    = ILCCompileCode(dwFLUI);
        dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = dwDrawPrim;
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_BUILDLOOP);
        nvpLogTime (NVP_T_BUILDLOOP,nvpTime[NVP_T_BUILDLOOP]);
#endif
    }

#ifdef NV_PROFILE
    global.fTriangleArea = 0.0f;
    NVP_START (NVP_T_INNERLOOP);
#endif
    /*
     * setup inner loop variables
     */
    global.dwPrimCount = dwPrimCount;
    global.dwStrides   = dwStrides;
    global.pVertices   = (DWORD)pVertices;
    global.pIndices    = (DWORD)pIndices;
    global.dwCullMask1 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    global.dwCullMask2 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
    if (dwFLUI & LUIFLAG_FVF)
    {
        PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pCurrentContext->mtsState;
        global.pdwUVOffset = pTriangleState->dwUVOffset;
    }
    if (dwFLUI & LUIFLAG_FOGMODE)
    {
        global.fFogTableDensity     = pCurrentContext->fFogTableDensity;
        global.fFogTableLinearScale = pCurrentContext->fFogTableLinearScale;
        global.fFogTableEnd         = pCurrentContext->fFogTableEnd;
    }
    if (dwFLUI & LUIFLAG_FIXEDWBUF)
    {
        global.fRWFar               = pCurrentContext->dvRWFar;
    }
    if (dwFLUI & LUIFLAG_DX6)
    {
    }
    else
    {
        global.dwSpecularState = pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE];
        global.dwSpecCurr      = pCurrentContext->ctxInnerLoop.dwCurrentSpecularState;
        global.dwBlend         = pCurrentContext->ctxInnerLoop.dwCurrentBlend;
        global.dwSpecCount     = pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount;
    }

    global.dwWMask1 = ((pCurrentContext->dvWNear == 1.0f) && (pCurrentContext->dvWFar  == 1.0f)) ? 0xffffffff : 0;
    global.dwWMask2 = ~global.dwWMask1;

#ifdef NV_PROFILE
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpTriArea  = 0.0f;
        nvpTriCount = 0;
        nvpTriToGo  = nvpTriPerSecWindow;
        NVP_START (NVP_C_PIXPERSEC);
    }
#endif

#ifdef PIX1
    {
        typedef struct
        {
            float x,y,z,rhw;
            DWORD c,s;
            float u0,v0,u1,v1;
        } SPECIAL;

        static SPECIAL vx0 = {0.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx1 = {1.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx2 = {0.0f,1.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };

        DWORD dwCount = (dwFLUI & LUIFLAG_DX6) ? (sizeDx5TriangleTLVertex * 3)
                                               : (sizeDx6TriangleTLVertex * 3);
        DWORD dwSize  = (dwFLUI & LUIFLAG_DX6) ? 40 : 32;
        DWORD dwCode  = (dwFLUI & LUIFLAG_DX6) ? 0x0028e400 : 0x0020e400;
        DWORD dwBase  = (dwFLUI & LUIFLAG_DX6) ? 5 : 13;


        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx0,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;

        dwBase ++;

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx1,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;

        dwBase ++;

        ((DWORD*)nvFifo)[0] = dwCode + dwBase * dwSize;
        memcpy ((void*)(nvFifo + 4),&vx2,dwSize);
        nvFifo      += (dwSize + 4);
        nvFreeCount -= (dwSize + 4) / 4;
    }
#endif //PIX1

    /*
     * draw it
     */
    ((PFNINNERLOOP)(ilcData + dwDrawPrim))();

#ifdef NV_PROFILE
    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpTriToGo = 1;
        nvProfileLog(); // force tri/sec dump here
    }
#endif

    /*
     * finish loop variables
     */
    if (dwFLUI & LUIFLAG_DX6)
    {
    }
    else
    {
         pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = global.dwSpecCount;
         pCurrentContext->ctxInnerLoop.dwCurrentSpecularState    = global.dwSpecCurr;
         pCurrentContext->ctxInnerLoop.dwCurrentBlend            = global.dwBlend;
    }

    /*
     * update CT bits
     */
#ifdef NV_CONTROLTRAFFIC
    pCurrentContext->dwCTFlags |= NV_CT_DRAWPRIM;
#endif //NV_CONTROLTRAFFIC

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_INNERLOOP);
    nvpLogTime (NVP_T_INNERLOOP,nvpTime[NVP_T_INNERLOOP]);
#endif

#ifdef NV_PROFILE
    /*
     * pixel per clock calculations
     */
    if (nvpEnableBits & (2 << NVP_C_1PIXCLK))
    {
        DWORD dwPixelsPerClock;

        if (dwFLUI & LUIFLAG_DX6)
        {
            dwPixelsPerClock = 1;
        }
        else
        {

            DWORD drfValueFilter;
            DWORD drfValueSpec;
            DWORD drfValueAlpha;
            DWORD drfValueFog;
            drfValueFilter = DRF_VAL(054, _FILTER, _TEXTUREMIN, pCurrentContext->ctxInnerLoop.dwFilter);
            drfValueSpec = DRF_VAL(054, _BLEND, _SPECULARENABLE, pCurrentContext->ctxInnerLoop.dwBlend);
            drfValueAlpha = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pCurrentContext->ctxInnerLoop.dwBlend);
            drfValueFog = DRF_VAL(054, _BLEND, _FOGENABLE, pCurrentContext->ctxInnerLoop.dwBlend);

            if ((drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST) ||
                (drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
                dwPixelsPerClock = 1;

            } else if (drfValueSpec == NV054_BLEND_SPECULARENABLE_TRUE) {
                dwPixelsPerClock = 1;

            } else if (drfValueAlpha == NV054_BLEND_ALPHABLENDENABLE_TRUE &&
                       drfValueFog == NV054_BLEND_FOGENABLE_TRUE) {
                dwPixelsPerClock = 1;
            } else {
                dwPixelsPerClock = 2;
            }
        }

        nvpLogEvent (NVP_E_TRIDISP);
        switch (dwPixelsPerClock)
        {
            case 1:
            {
                nvpLogCount (NVP_C_1PIXCLK,(DWORD)(0.5f * global.fTriangleArea + 0.5f));
                break;
            }
            case 2:
            {
                nvpLogCount (NVP_C_2PIXCLK,(DWORD)(0.5f * global.fTriangleArea + 0.5f));
                break;
            }
        }
    }
#endif // NV_PROFILE

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        nvPusherDisassemblerEnable = 0;
    }
    */

}

#ifdef NV_DUMPLOOPS
void __cdecl print (HANDLE f,char *sz,...)
{
    char buf[512];
    DWORD dw;
    vsprintf (buf,sz,(char*)(((DWORD)&sz)+4));
    WriteFile (f,buf,strlen(buf),&dw,0);
}
#endif

#ifdef NV_EMBEDLOOPS   // -DNV_EMBEDLOOPS -Zm999
#include "\loops.c"
#endif

/*
 * ILCWarmCache
 *
 * loads the most common inner loops
 */
void ILCWarmCache
(
    void
)
{
    DWORD dwDefault = ((global.dwCPUFeatureSet & FS_MMX)    ? LUIFLAG_MMX    : 0)
                    | ((global.dwCPUFeatureSet & FS_KATMAI) ? LUIFLAG_KATMAI : 0);

#ifndef NV_EMBEDLOOPS
#ifndef NV_DUMPLOOPS
#ifndef NV_PROFILE // we do not prebuild code for the profiler since we read the enable bits too late
    DWORD dwFLUI;

    /*
     * dx5 TL verts
     */
    dwFLUI = dwDefault | 0x0000; // list
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0004; // strip
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0008; // fan
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x000c; // legacy
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);

    /*
     * dx6 fvf verts
     */
    dwFLUI = dwDefault | 0x0000 | LUIFLAG_FVF | LUIFLAG_DX6; // list
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0004 | LUIFLAG_FVF | LUIFLAG_DX6; // strip
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x0008 | LUIFLAG_FVF | LUIFLAG_DX6; // fan
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
    dwFLUI = dwDefault | 0x000c | LUIFLAG_FVF | LUIFLAG_DX6; // legacy
    dwDrawPrimitiveTable[dwFLUI & LUIMASK_BRANCH] = ILCCompileCode(dwFLUI);
#endif
#endif
#endif

#ifdef NV_DUMPLOOPS
    {
        DWORD  i;
        HANDLE f;

        /*
         * build all possible inner loops
         */
        for (i=0; i<256; i++)
        {
            dwDrawPrimitiveTable[i] = ILCCompileCode(i | dwDefault);
        }

        /*
         * save them to disk
         */
        f = CreateFile("\\loops.c",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (f != INVALID_HANDLE_VALUE)
        {
            // max
            print (f,"DWORD embedMax = %d;",ilcMax);
            print (f,"\r\n\r\n");
            // data
            print (f,"void embedData (void) {\r\n");
            for (i = 0; i < ilcCount; i++)
            {
                if ((i & 31) ==  0) print (f,"    ");
                print (f,"__asm _emit 0x%02x ",ilcData[i]);
                if ((i & 31) == 31) print (f,"\r\n");
            }
            print (f,"}\r\n\r\n");
            CloseHandle (f);
        }
        else
        {
            OutputDebugString ("File creation failure\n");
            __asm int 3;
        }
    }
#endif

#ifdef NV_EMBEDLOOPS
    {
        DWORD i;

        ilcData  = (BYTE*)embedData;
        ilcMax   = embedMax;
        ilcCount = 0;

        for (i=0; i<256; i++)
        {
            dwDrawPrimitiveTable[i] = ILCCompileCode(i | dwDefault);
        }
    }
#endif
}

#endif //NV_FASTLOOPS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\dvideo32.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997, 1998 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       dvideo32.c
 *  Content:    NVidia Direct Video/Active Movie Direct Draw support
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#include "windows.h"
#include <conio.h>
#include "nvd3ddrv.h"
#include "nvcm.h"
#include "nv32.h"
#include "nvddobj.h"
#include "wingdi.h"
#include "arb_fifo.h" /* video bandwidth related stuff */
#include "nvrmapi.h"
#include "nvrmarch.inc"

/*
 * Make fixups for NV3->NV4 style includes.
 */
#undef NvChannel
#define NvChannel Nv3ChannelPio
#define nvContextDmaToMemory contextDmaToMemory

#if 0
DWORD __stdcall HandleVideoPortOverlayUpdate(LPDDHAL_UPDATEOVERLAYDATA lpUOData);
#endif

#ifdef NVPE
///// H.AZAR: (03/01/1999): this function is defined in nvpkrnl.c (nvpe.lib)
extern DWORD NVPUpdateOverlay();
#endif

/*
 * ConvertOverlay32
 *
 */

DWORD __stdcall
ConvertOverlay32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, BOOL waitForCompletion )
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwSrcYOffset;
    DWORD                       dwSrcVOffset;
    DWORD                       dwSrcUOffset;
    long                        dwSrcYPitch;
    long                        dwSrcUVPitch;
    long                        dwSrcUVHeight;
    DWORD                       dwDstYOffset;
    long                        dwDstYPitch;
    unsigned char               *fpSrcYMem;
    unsigned char               *fpSrcUMem;
    unsigned char               *fpSrcVMem;
    long                        dwSrcPitch;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    pSurf_gbl = lpDDSurface->lpGbl;

    caps = lpDDSurface->ddsCaps.dwCaps;

    NV_DD_DMA_PUSHER_SYNC();

    /* If surface is IF09 format then must reformat data before
       video scaler can be used to display it */
    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {

        dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;
        dwDstYOffset = dwSrcYOffset + ((dwSrcYPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        dwDstYOffset = (dwDstYOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        fpSrcYMem = (unsigned char *)pSurf_gbl->fpVidMem;
        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 3) & ~3L;
        fpSrcVMem = fpSrcYMem + (dwSrcYPitch * dwSrcHeight);
        dwSrcHeight >>= 2;
        fpSrcUMem = fpSrcVMem + ((dwSrcYPitch >> 2) * dwSrcHeight);

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 3) & ~3L;
        dwSrcUVHeight >>= 2;

        dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
        dwSrcUVPitch >>= 2;

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        while (freeCount < 25)
            NvGetDmaBufferFreeCount(npDev, freeCount, 25, dmaPusherPutAddress);
        freeCount -= 25;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000;
        dmaPusherPutAddress[1] = 0x000000C0; /* MERGECOPY PSa */

        /* Temporarily change destination surface color format */
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x80000;
        dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
        dmaPusherPutAddress[4] = (dwDstYPitch << 16) | dwDstYPitch;
        dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SURFACES) +
            SURFACES_2D_DEST_OFFSET | 0x40000;
        dmaPusherPutAddress[6] = dwDstYOffset;

        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[8] = NV_DD_CONTEXT_PATTERN;
        dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHROME_SHAPE | 0x40000;
        dmaPusherPutAddress[10] = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHORME_COLOR0 | 0x100000;
        dmaPusherPutAddress[12] = 0;
        dmaPusherPutAddress[13] = 0xFFFFFFFF;

        /* First enable only V values to be written */
        dmaPusherPutAddress[14] = 0x11111111;
        dmaPusherPutAddress[15] = 0x11111111;

        dmaPusherPutAddress[16] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
        dmaPusherPutAddress[17] = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
        dmaPusherPutAddress[18] = dDrawSubchannelOffset(NV_DD_STRETCH) +
            STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

        dmaPusherPutAddress[19] = asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);
        dmaPusherPutAddress[20] = 8 << 20;
        dmaPusherPutAddress[21] = 4 << 20;
        dmaPusherPutAddress[22] = 0;
        dmaPusherPutAddress[23] =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);
        dmaPusherPutAddress[24] = 0;

        dmaPusherPutAddress += 25;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0) {
            FAST DWORD vPxls0;
            FAST DWORD vPxls1;

            dwSrcPitch = dwSrcUVPitch;

            /* Source scanlines may not be exact multiples of 4 */
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            // Get enough room for this scanline
            while (freeCount < (1 + (dwSrcPitch >> 2)))
                NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (dwSrcPitch >> 2)), dmaPusherPutAddress);
            freeCount -= (1 + (dwSrcPitch >> 2));

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                STRETCHED_IMAGE_COLOR_OFFSET | (dwSrcPitch << 16);

            dmaPusherPutAddress += 1;

            while (dwSrcPitch >= 16) {
                dwSrcPitch -= 16;

                vPxls0 = *(unsigned long *)fpSrcVMem;
                vPxls1 = *(unsigned long *)&fpSrcVMem[4];

                dmaPusherPutAddress[0] = vPxls0;

                vPxls0 = *(unsigned long *)&fpSrcVMem[8];
                dmaPusherPutAddress[1] = vPxls1;
                vPxls1 = *(unsigned long *)&fpSrcVMem[12];
                dmaPusherPutAddress[2] = vPxls0;
                fpSrcVMem += 16;
                dmaPusherPutAddress[3] = vPxls1;

                dmaPusherPutAddress += 4;
            }

            while (dwSrcPitch >= 4) {
                dwSrcPitch -= 4;
                vPxls0 = *(unsigned long *)fpSrcVMem;
                fpSrcVMem += 4;
                dmaPusherPutAddress[0] = vPxls0;

                dmaPusherPutAddress += 1;
            }
        }

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on reading the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        while (freeCount < 14)
            NvGetDmaBufferFreeCount(npDev, freeCount, 14, dmaPusherPutAddress);
        freeCount -= 14;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHROME_SHAPE | 0x40000;
        dmaPusherPutAddress[1] = NV044_SET_MONOCHROME_SHAPE_64X_1Y;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV044_SET_MONOCHORME_COLOR0 | 0x100000;
        dmaPusherPutAddress[3] = 0;
        dmaPusherPutAddress[4] = 0xFFFFFFFF;

        /* Now enable only U values to be written */
        dmaPusherPutAddress[5] = 0x44444444;
        dmaPusherPutAddress[6] = 0x44444444;

        dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_STRETCH) +
            STRETCHED_IMAGE_SIZE_IN_OFFSET | 0x180000;

        dmaPusherPutAddress[8] = asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);
        dmaPusherPutAddress[9] = 8 << 20;
        dmaPusherPutAddress[10] = 4 << 20;
        dmaPusherPutAddress[11] = 0;
        dmaPusherPutAddress[12] =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);
        dmaPusherPutAddress[13] = 0;

        dmaPusherPutAddress += 14;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0) {
            FAST DWORD uPxls0;
            FAST DWORD uPxls1;

            dwSrcPitch = dwSrcUVPitch;

            /* Source scanlines may not be exact multiples of 4 */
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            // Get enough room for this scanline
            while (freeCount < (1 + (dwSrcPitch >> 2)))
                NvGetDmaBufferFreeCount(npDev, freeCount, (1 + (dwSrcPitch >> 2)), dmaPusherPutAddress);
            freeCount -= (1 + (dwSrcPitch >> 2));

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) +
                STRETCHED_IMAGE_COLOR_OFFSET | (dwSrcPitch << 16);

            dmaPusherPutAddress += 1;

            while (dwSrcPitch >= 16) {
                dwSrcPitch -= 16;

                uPxls0 = *(unsigned long *)fpSrcUMem;
                uPxls1 = *(unsigned long *)&fpSrcUMem[4];

                dmaPusherPutAddress[0] = uPxls0;
                uPxls0 = *(unsigned long *)&fpSrcUMem[8];
                dmaPusherPutAddress[1] = uPxls1;
                uPxls1 = *(unsigned long *)&fpSrcUMem[12];
                dmaPusherPutAddress[2] = uPxls0;
                fpSrcUMem += 16;
                dmaPusherPutAddress[3] = uPxls1;

                dmaPusherPutAddress += 4;
            }

            while (dwSrcPitch >= 4) {
                dwSrcPitch -= 4;
                uPxls0 = *(unsigned long *)fpSrcUMem;
                fpSrcUMem += 4;
                dmaPusherPutAddress[0] = uPxls0;

                dmaPusherPutAddress += 1;
            }
        }

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on reading the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        /* restore default stretch subchannel object */
        while (freeCount < 6)
            NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
        freeCount -= 6;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000;
        if (pDriverData->bi.biBitCount == 8)
            dmaPusherPutAddress[1] = NV_DD_STRETCHED_IMAGE_FROM_CPU;
        else
            dmaPusherPutAddress[1] = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

        /* restore destination surface color format and reenable pattern object alpha */
        if (pDriverData->bi.biBitCount == 8) {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_Y8;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_008;

        } else if (pDriverData->bi.biBitCount == 16) {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_016;

        } else {

            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SURFACES) +
                NV042_SET_COLOR_FORMAT | 0x40000;
            dmaPusherPutAddress[3] = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_SPARE) +
                NV044_SET_MONOCHORME_COLOR0 | 0x40000;
            dmaPusherPutAddress[5] = NV_ALPHA_1_032;
        }

        dmaPusherPutAddress += 6;


        /* Update all Y values */
        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcYOffset;
        dmaPusherPutAddress[4] = dwDstYOffset;
        dmaPusherPutAddress[5] = dwSrcYPitch;
        dmaPusherPutAddress[6] = dwDstYPitch;
        dmaPusherPutAddress[7] = dwSrcYPitch;
        dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight;
        dmaPusherPutAddress[9] = (2 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

     /* YV12/420i surfaces also need reformated before the video scaler can display them */
    } else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
               (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
        DWORD srcMemType = 0;
        DWORD interleaveUVFields = 0;

        /* First determine which source buffer is being used */
        dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0];

        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;

        dwSrcWidth = dwSrcYPitch;

        if (dwSrcYOffset == 0)
            dwDstYOffset = pDriverData->NvYUY2Surface0Mem -
                               pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
            dwDstYOffset = pDriverData->NvYUY2Surface1Mem -
                               pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
            dwDstYOffset = pDriverData->NvYUY2Surface2Mem -
                               pDriverData->BaseAddress;
        else
            dwDstYOffset = pDriverData->NvYUY2Surface3Mem -
                               pDriverData->BaseAddress;

        /* Now correct source offset if it is really in video memory */
        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >= pDriverData->BaseAddress) && /* If video memory */
            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] < pDriverData->BaseAddress + 0x1000000)) {
            dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
            srcMemType = DDSCAPS_LOCALVIDMEM;
        }

        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 1) & ~1L;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) {
            dwSrcVOffset = dwSrcYOffset + (dwSrcYPitch * dwSrcHeight);
            dwSrcUOffset = dwSrcVOffset + ((dwSrcYPitch * dwSrcHeight) >> 2);

            dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
            dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
            dwSrcUVPitch >>= 1;

        } else { /* FOURCC_420i */
            dwSrcVOffset = dwSrcYOffset + dwSrcYPitch;
            dwSrcYPitch += (dwSrcYPitch >> 1);
            dwSrcUOffset = dwSrcVOffset + dwSrcYPitch;

            dwSrcUVPitch = dwSrcYPitch << 1;
        }

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 1) & ~1L;
        dwSrcUVHeight >>= 1;

        /*
         * NOTE:
         *
         * NV3 MemToMemFormat does not double buffer it's methods.
         * Therefore, if a MemToMemFormat operation is started within
         * a channel, sending an additional MemToMemFormat request down the
         * FIFO will corrupt the state of the first MemToMemFormat operation if
         * it had not yet finished.  However, loading a new object
         * into a subchannel will ALWAYS be blocked until the object
         * previously in that subchannel has completed it's operation.
         * Since we can't afford to wait around in this algorithm, we
         * take advantage of the fact that this object blocking will occur
         * by loading several different MemToMemFormat object instances
         * to accomplish our format conversion.
         */

        /* Let D3D code know that we have touched NV */
        pDriverData->TwoDRenderingOccurred = 1;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcVOffset;
        dmaPusherPutAddress[4] = (dwDstYOffset + 3);
        dmaPusherPutAddress[5] = dwSrcUVPitch;
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
        dmaPusherPutAddress[8] = dwSrcUVHeight;
        dmaPusherPutAddress[9] = (4 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcUOffset;
        dmaPusherPutAddress[4] = (dwDstYOffset + 1);
        dmaPusherPutAddress[5] = dwSrcUVPitch;
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
        dmaPusherPutAddress[8] = dwSrcUVHeight;
        dmaPusherPutAddress[9] = (4 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (interleaveUVFields) { /* repeat for odd field */

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            if (srcMemType == 0) /* If system memory */
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
            else
                dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwSrcVOffset + (dwSrcPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 3);
            dmaPusherPutAddress[5] = dwSrcUVPitch;
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
            dmaPusherPutAddress[8] = dwSrcUVHeight;
            dmaPusherPutAddress[9] = (4 << 8) | 1;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            if (srcMemType == 0) /* If system memory */
                dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
            else
                dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwSrcUOffset + (dwSrcPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 1);
            dmaPusherPutAddress[5] = dwSrcUVPitch;
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwSrcWidth >> 1);
            dmaPusherPutAddress[8] = dwSrcUVHeight;
            dmaPusherPutAddress[9] = (4 << 8) | 1;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            while (freeCount < 11)
                NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
            freeCount -= 11;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
            dmaPusherPutAddress[3] = (dwDstYOffset + 1 + (dwDstYPitch >> 1));
            dmaPusherPutAddress[4] = (dwDstYOffset + 1 + (dwDstYPitch >> 1) + dwDstYPitch);
            dmaPusherPutAddress[5] = (dwDstYPitch << 1);
            dmaPusherPutAddress[6] = (dwDstYPitch << 1);
            dmaPusherPutAddress[7] = (dwDstYPitch >> 2);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 2;
            dmaPusherPutAddress[9] = (2 << 8) | 2;
            dmaPusherPutAddress[10] = 0;

            dmaPusherPutAddress += 11;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            // Get NV started on processing the image data
            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            /* restore Y pitch while processing interleaved Y values for full frame */
            dwDstYPitch >>= 1;
        }

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        if (srcMemType == 0) /* If system memory */
            dmaPusherPutAddress[1] = NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        else
            dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = dwSrcYOffset;
        dmaPusherPutAddress[4] = dwDstYOffset;
        dmaPusherPutAddress[5] = dwSrcYPitch;
        dmaPusherPutAddress[6] = dwDstYPitch;
        dmaPusherPutAddress[7] = dwSrcWidth;
        dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight;
        dmaPusherPutAddress[9] = (2 << 8) | 1;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (interleaveUVFields)
            dwDstYPitch <<= 1;

        while (freeCount < 11)
            NvGetDmaBufferFreeCount(npDev, freeCount, 11, dmaPusherPutAddress);
        freeCount -= 11;

        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000;
        dmaPusherPutAddress[3] = (dwDstYOffset + 1);
        dmaPusherPutAddress[4] = (dwDstYOffset + 1 + dwDstYPitch);
        dmaPusherPutAddress[5] = (dwDstYPitch << 1);
        dmaPusherPutAddress[6] = (dwDstYPitch << 1);
        if (interleaveUVFields) {
            dmaPusherPutAddress[7] = (dwDstYPitch >> 2);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 2;
        } else {
            dmaPusherPutAddress[7] = (dwDstYPitch >> 1);
            dmaPusherPutAddress[8] = (DWORD)pSurf_gbl->wHeight >> 1;
        }
        dmaPusherPutAddress[9] = (2 << 8) | 2;
        dmaPusherPutAddress[10] = 0;

        dmaPusherPutAddress += 11;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        // Get NV started on processing the image data
        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

        if (waitForCompletion) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 4)
                NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
            freeCount -= 4;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[1] = 0;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = 0;

            dmaPusherPutAddress += 4;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
        }

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->dwDmaPusherFreeCount = freeCount;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;
    }

    return DDHAL_DRIVER_HANDLED;

} /* ConvertOverlay32 */


/*
 * PreScaleOverlay32
 *
 * This function does not support interleaved overlay surfaces.
 *
 */

DWORD __stdcall
PreScaleOverlay32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface )
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwOffset;
    DWORD                       dwPitch;
    DWORD                       preScaleOverlay = 0;
    DWORD                       srcPreShrinkDeltaX;
    DWORD                       srcPreShrinkDeltaY;
    BOOL                        surfaceIs422 = FALSE;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    if (npDev == NULL) {
        return DDHAL_DRIVER_HANDLED;
    }

    pSurf_gbl = lpDDSurface->lpGbl;

    caps = lpDDSurface->ddsCaps.dwCaps;

    NV_DD_DMA_PUSHER_SYNC();

    /* Make sure we flip to the correct starting offset in new overlay surface */
    dwOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;

    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31)) {
        /* Skip over Indeo portion of surface */
        dwPitch = (DWORD)pSurf_gbl->wWidth;
        dwOffset += ((dwPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        /* Force block to be properly aligned */
        dwOffset = (dwOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
    } else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
               (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i)) {
        /* Assumes a separate overlay YUY2 surface in video memory */
        if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
            dwOffset = pDriverData->NvYUY2Surface0Mem -
                           pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
            dwOffset = pDriverData->NvYUY2Surface1Mem -
                           pDriverData->BaseAddress;
        else if (pSurf_gbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
            dwOffset = pDriverData->NvYUY2Surface2Mem -
                           pDriverData->BaseAddress;
        else
            dwOffset = pDriverData->NvYUY2Surface3Mem -
                           pDriverData->BaseAddress;

        dwPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
    } else {
        dwPitch = (DWORD)pSurf_gbl->lPitch;
        surfaceIs422 = TRUE;
    }

    srcPreShrinkDeltaX = 0x100000;
    srcPreShrinkDeltaY = 0x100000;

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

        if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
               pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
            srcPreShrinkDeltaX =
                (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
        }

        if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
               pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
            srcPreShrinkDeltaY =
                (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
        }
    } else {

        if ((pDriverData->dwOverlaySrcWidth >
               pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
            srcPreShrinkDeltaX =
                (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
        }

        if ((pDriverData->dwOverlaySrcHeight >
               pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
            srcPreShrinkDeltaY =
                (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
        }
    }

    if ((surfaceIs422) && (preScaleOverlay == 0) &&
        (pDriverData->dwOverlaySurfaces == 1) &&
        (pSurf_gbl->wHeight >= 480) &&
        (pDriverData->lockCount > 2))
        preScaleOverlay = NV_PRESCALE_OVERLAY_QUADRANT;

    /* Preshrink overlay surface if necessary */
    if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay)) {

        while (freeCount < 19)
            NvGetDmaBufferFreeCount(npDev, freeCount, 19, dmaPusherPutAddress);
        freeCount -= 19;

        /* Trash spare subchannel */
        dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
        dmaPusherPutAddress[1] = NV_DD_DVD_SUBPICTURE;
        dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
            NV038_IMAGE_OUT_POINT | 0x400000;
        dmaPusherPutAddress[3] = 0;

        /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
        if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                               pSurf_gbl->wHeight);
        } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pSurf_gbl->wWidth + 2) & ~1),
                               pDriverData->dwOverlayDstHeight);
        } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                               pDriverData->dwOverlayDstHeight);
        } else {
            dmaPusherPutAddress[4] =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                               pDriverData->dwOverlaySrcHeight);
        }

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
            dmaPusherPutAddress[5] =
                (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
        else
            dmaPusherPutAddress[5] =
                (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

        /* Output to extra overlay surface memory area */
        if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[pDriverData->OverlayBufferIndex] != 0))
            dmaPusherPutAddress[6] =
                pDriverData->extra422OverlayOffset[pDriverData->OverlayBufferIndex];
        else
            dmaPusherPutAddress[6] = (dwOffset + pSurf_gbl->dwReserved1);

        dmaPusherPutAddress[7] = srcPreShrinkDeltaX;
        dmaPusherPutAddress[8] = srcPreShrinkDeltaY;

        dmaPusherPutAddress[9] = pDriverData->OverlaySrcSize;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
            dmaPusherPutAddress[10] =
                (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwPitch;
        else
            dmaPusherPutAddress[10] =
                (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwPitch;

        /* Temporarily offset to the beginning of the visible portion of source surface */
        dwOffset += (pDriverData->OverlaySrcY * dwPitch);
        dwOffset += (pDriverData->OverlaySrcX << 1);

        dmaPusherPutAddress[11] = dwOffset;

        dmaPusherPutAddress[12] = 0;

        dmaPusherPutAddress[13] = srcPreShrinkDeltaX;
        dmaPusherPutAddress[14] = srcPreShrinkDeltaY;

        dmaPusherPutAddress[15] = pDriverData->OverlaySrcSize;

        dmaPusherPutAddress[16] =
            (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwPitch;

        dmaPusherPutAddress[17] = dwOffset;

        dmaPusherPutAddress[18] = 0;

        dmaPusherPutAddress += 19;

        pDriverData->dDrawSpareSubchannelObject = 0;

        pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

        /* Force write combine buffer to flush */
        pDriverData->NvDmaPusherBufferEnd[0] = 0;
        /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
        _outp (0x3d0,0);

        pDriverData->dwDmaPusherFreeCount = freeCount;

        npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
    }

    pDriverData->dwDmaPusherFreeCount = freeCount;

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    return DDHAL_DRIVER_HANDLED;
}



/*
 * UpdateOverlay32
 *
 *
 * NOTES:
 *
 * This callback is invoked to update an overlay surface.
 * This is where the src/destination is specified, any effects, and
 * it is shown or hidden
 *
 * For overlay surfaces NOT associated with a video port the surface will
 * be shown (DDOVER_SHOW) according to the following criteria.
 *
 *     DDOVER_INTERLEAVED   DDOVER_BOB      DISPLAYED
 *
 *             1                1           Even field
 *             1                0           Full surface (no special processing)
 *             0                X           Full surface (no special processing)
 *
 */

DWORD __stdcall
UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA lpUOData )
{
    FAST Nv3ChannelPio          *npDevVideo;
    FAST long                   videoFreeCount;
    NvNotification              *pPioFlipOverlayNotifier;
    long                        srcDeltaX;
    long                        srcDeltaY;
    long                        srcPreShrinkDeltaX;
    long                        srcPreShrinkDeltaY;
    long                        dwSrcOffset;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    long                        dwDstWidth;
    long                        dwDstHeight;
    long                        dwSrcPitch;
    DWORD                       index = 0;
    DWORD                       match = 0;
    DWORD                       showInterleavedFields = 0;
    DWORD                       preScaleOverlay = 0;
    U032                        bMediaPortControl = FALSE;
    BOOL                        surfaceIs422 = FALSE;

    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpUOData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;

    NvSetDriverDataPtr(lpUOData->lpDD);

    npDevVideo = (NvChannel *)pDriverData->NvDevVideoFlatPio;
    videoFreeCount = pDriverData->NvVideoFreeCount;
    pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayUpdate( lpUOData);
    return DDHAL_DRIVER_HANDLED;

    }
#endif //
    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_UYNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31)) {
            lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
            return DDHAL_DRIVER_HANDLED;
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        lpUOData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
    }

    NV_DD_DMA_PUSHER_SYNC();

    if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
        lpUOData->ddRVal = DDERR_SURFACELOST;
        pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;
        pDriverData->dwOverlaySurfaces = 0;         /* should clean up AGP surface memory here if used */
        pDriverData->dwOverlayOwner = 0;
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
        return DDHAL_DRIVER_HANDLED;
    }
    pDriverData->dwRingZeroMutex = TRUE;

    if (pDriverData->fDDrawFullScreenDosOccurred) {
        pDriverData->OverlayRelaxOwnerCheck = 1;        /* relax owner check when we come back from DOS mode */
        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;
    }

    /* Alternate buffer indexes to keep the hardware happy */
    pDriverData->OverlayBufferIndex ^= 1;

    index = pDriverData->OverlayBufferIndex;
        
    if (lpUOData->dwFlags & DDOVER_HIDE ) {
        DPF("UPDATE OVERLAY - DDOVER_HIDE");

        pDriverData->dwOverlaySrcWidth = 0;
        pDriverData->dwOverlayDstWidth = 0;
        pDriverData->dwOverlaySrcHeight = 0;
        pDriverData->dwOverlayDstHeight = 0;

#ifdef NVPE
		// tell miniport to stop autoflip !
        if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
			NVPUpdateOverlay();
#endif	// #ifdef NVPE

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            while (videoFreeCount < 32)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 32;

            npDevVideo->dDrawSpare.SetObject = NV_VIDEO_OVERLAY;

       } else {

            while (videoFreeCount < 32)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 32;

            /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;

            npDevVideo->dDrawSpare.videoColorKey.SetSize = 0;

            npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch = 0;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size = 0;

            if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                (src->ddpfSurface.dwFourCC == FOURCC_UYNV))
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;
            else
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;
        }
        
          //pDriverData->dwRingZeroMutex = FALSE;

        pDriverData->dDrawSpareSubchannelObject = 0;
        pDriverData->OverlayFormat = 0;     // This should hide things, since we'll stop flipping
            
        /* Let DDraw know how many visible overlays are active */
        pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            if (pDriverData->fDDrawFullScreenDosOccurred != 2) {  /* still in DOS mode ? */
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

    } else {
        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0)) {
            pDriverData->dwRingZeroMutex = FALSE;
            
                lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            return DDHAL_DRIVER_HANDLED;
        }

        if (pDriverData->fDDrawFullScreenDosOccurred) {
            if (pDriverData->fDDrawFullScreenDosOccurred == 2) {  /* still in DOS mode ? */
                pDriverData->dwRingZeroMutex = FALSE;
                 lpUOData->ddRVal = DDERR_SURFACEBUSY;
                return DDHAL_DRIVER_HANDLED;
            } else {                                        /* back to hires mode */
                pDriverData->fDDrawFullScreenDosOccurred = 0;    /* reset flag */
            }
        }

        /* This surface may need converted */
        if (pDriverData->dwOverlaySurfaces > 2)
            ConvertOverlay32(srcx, TRUE);

        dwSrcWidth = lpUOData->rSrc.right - lpUOData->rSrc.left;
        dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
        dwDstWidth = lpUOData->rDest.right - lpUOData->rDest.left;
        dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;
            
        if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
            if (lpUOData->dwFlags & DDOVER_AUTOFLIP) {
                bMediaPortControl = TRUE;
            }
        }       
            
        /* Remember sizes so Flip32 knows what to do */
        pDriverData->dwOverlaySrcWidth = dwSrcWidth;
        pDriverData->dwOverlayDstWidth = dwDstWidth;
        pDriverData->dwOverlaySrcHeight = dwSrcHeight;
        pDriverData->dwOverlayDstHeight = dwDstHeight;

        /* Align to 2 pixel boundary + 1 for video scaler */
        dwDstWidth = (dwDstWidth + 2) & ~1L;
        dwDstHeight = (dwDstHeight + 1) & ~1L;

        srcDeltaX = (dwSrcWidth - 1) << 16;
        srcDeltaX /= dwDstWidth - 1;
        srcDeltaX <<= 4;

        srcDeltaY = (dwSrcHeight - 1) << 16;
        srcDeltaY /= dwDstHeight - 1;
        srcDeltaY <<= 4;

        pDriverData->dwOverlayDeltaY = (DWORD)srcDeltaY;

        if( !(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) ) {
            if ((lpUOData->dwFlags & DDOVER_INTERLEAVED) &&
                (lpUOData->dwFlags & DDOVER_BOB)) {

                showInterleavedFields = 1;
                dwSrcHeight >>= 1;
#ifdef  NOPRESTRETCH
                srcDeltaY = (dwSrcHeight - 1) << 16;
                srcDeltaY /= dwDstHeight - 1;
                srcDeltaY <<= 4;
#endif  // NOPRESTRETCH
            }
        }

        srcPreShrinkDeltaX = 0x100000;
        srcPreShrinkDeltaY = 0x100000;

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

            if ((((pDriverData->dwOverlaySrcWidth + 7) >> 3) >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
                srcDeltaX = 0x100000;
            }

            if ((((pDriverData->dwOverlaySrcHeight + 7) >> 3) >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
#ifdef  NOPRESTRETCH
                if (showInterleavedFields) {
                    srcDeltaY = 0x80000;
                    pDriverData->dwOverlayDeltaY = 0x80000;
                } else {
#endif  // NOPRESTRETCH
                    srcDeltaY = 0x100000;
                    pDriverData->dwOverlayDeltaY = 0x100000;
#ifdef  NOPRESTRETCH
                }
#endif  // NOPRESTRETCH
            }
        } else {

            if ((pDriverData->dwOverlaySrcWidth >
                   pDriverData->dwOverlayDstWidth) && (pDriverData->dwOverlayDstWidth > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
                srcPreShrinkDeltaX =
                    (pDriverData->dwOverlaySrcWidth << 20) / pDriverData->dwOverlayDstWidth;
                srcDeltaX = 0x100000;
            }

            if ((pDriverData->dwOverlaySrcHeight >
                   pDriverData->dwOverlayDstHeight) && (pDriverData->dwOverlayDstHeight > 0)) {
                preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
                srcPreShrinkDeltaY =
                    (pDriverData->dwOverlaySrcHeight << 20) / pDriverData->dwOverlayDstHeight;
#ifdef  NOPRESTRETCH
                if (showInterleavedFields) {
                    srcDeltaY = 0x80000;
                    pDriverData->dwOverlayDeltaY = 0x80000;
                } else {
#endif  // NOPRESTRETCH
                    srcDeltaY = 0x100000;
                    pDriverData->dwOverlayDeltaY = 0x100000;
#ifdef  NOPRESTRETCH
                }
#endif  // NOPRESTRETCH
            }
        }

#ifndef NOPRESTRETCH
        if ((showInterleavedFields) && (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            srcPreShrinkDeltaY >>= 1;
        }
#endif  // NOPRESTRETCH

        /* Check for Quadrant MCI DVD decoder */
        if ((preScaleOverlay == 0) && (surfaceIs422) &&
            (pDriverData->dwOverlaySurfaces == 1) &&
            (showInterleavedFields == 0) &&
            (src->wHeight >= 480) &&  // cannot make this larger due to widescreen problems
            (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)))
            preScaleOverlay = NV_PRESCALE_OVERLAY_QUADRANT;


        /* Must wait for any pending overlay flip to finish */
        /* if it is an autoflip then do not wait */
        if (!(lpUOData->dwFlags & DDOVER_AUTOFLIP)) {
            while (((volatile)pPioFlipOverlayNotifier[index + 1].status == NV_IN_PROGRESS))
                NV_SLEEP;
        }

        pPioFlipOverlayNotifier[index + 1].status = NV_IN_PROGRESS;

        dwSrcOffset = src->fpVidMem - pDriverData->BaseAddress;

        if ((src->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (src->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (src->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (src->ddpfSurface.dwFourCC == FOURCC_IV31)) {
            /* Skip over Indeo portion of surface */
            dwSrcPitch = (DWORD)src->wWidth;
            dwSrcOffset += ((dwSrcPitch * ((DWORD)src->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwSrcOffset = (dwSrcOffset + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            dwSrcPitch = ((src->wWidth + 1) & 0xFFFE) << 1;
            dwSrcPitch = (dwSrcPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else if ((src->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                   (src->ddpfSurface.dwFourCC == FOURCC_420i)) {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0])
                dwSrcOffset = pDriverData->NvYUY2Surface0Mem -
                                  pDriverData->BaseAddress;
            else if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1])
                dwSrcOffset = pDriverData->NvYUY2Surface1Mem -
                                  pDriverData->BaseAddress;
            else if (src->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2])
                dwSrcOffset = pDriverData->NvYUY2Surface2Mem -
                                  pDriverData->BaseAddress;
            else
                dwSrcOffset = pDriverData->NvYUY2Surface3Mem -
                                  pDriverData->BaseAddress;

            dwSrcPitch = ((src->wWidth + 1) & 0xFFFE) << 1;
            dwSrcPitch = (dwSrcPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        } else {
            dwSrcPitch = (DWORD)src->lPitch;
            surfaceIs422 = TRUE;
        }

        if (showInterleavedFields)
            dwSrcPitch <<= 1;

        /* Let the world know what the current overlay src offset is */
        pDriverData->OverlaySrcX = (short)(lpUOData->rSrc.left & ~1);
        pDriverData->OverlaySrcY = (short)lpUOData->rSrc.top;

        /* Preshrink overlay surface if necessary */
        if ((pDriverData->TotalVRAM >> 20 > 4) && (preScaleOverlay) &&
            (!(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))) {

            /* needed for Quadrant MCI DVD decoder fix only */
            pDriverData->lockCount = 0;

            while (videoFreeCount < 76)
                videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
            videoFreeCount -= 76;

            //pDriverData->dwRingZeroMutex = TRUE;
            
                /* Trash spare subchannel */
            npDevVideo->dDrawSpare.SetObject = NV_DD_DVD_SUBPICTURE;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutPoint = 0;

            /* Widths below are increased by 2 instead of 1 to remain hardware compatible */
            if (preScaleOverlay == NV_PRESCALE_OVERLAY_X) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   dwSrcHeight);
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_Y) {
                if (showInterleavedFields) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y)) {
                if (showInterleavedFields) {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       (pDriverData->dwOverlayDstHeight >> 1));
                } else {
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                        asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                       pDriverData->dwOverlayDstHeight);
                }
            } else if (preScaleOverlay == NV_PRESCALE_OVERLAY_FIELD) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((dwSrcWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else if (preScaleOverlay == (NV_PRESCALE_OVERLAY_X + NV_PRESCALE_OVERLAY_Y + NV_PRESCALE_OVERLAY_FIELD)) {
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlayDstWidth + 2) & ~1),
                                   pDriverData->dwOverlayDstHeight);
            } else { // NV_PRESCALE_OVERLAY_QUADRANT
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutSize =
                    asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 2) & ~1),
                                   pDriverData->dwOverlaySrcHeight);
            }

            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | (dwSrcPitch >> 1);
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | (dwSrcPitch >> 1);
            } else {
                if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwSrcPitch;
                else
                    npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutFormat =
                        (NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwSrcPitch;
            }

            /* Output to extra overlay surface memory area */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    pDriverData->extra422OverlayOffset[index];
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageOutOffset =
                    (dwSrcOffset + src->dwReserved1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInSize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwSrcHeight);

            if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8 << 16) | dwSrcPitch;
            else
                npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInFormat =
                    (NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8 << 16) | dwSrcPitch;

            /* Temporarily offset to the beginning of the visible portion of source surface */
            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += ((lpUOData->rSrc.left & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInOffset =
                dwSrcOffset;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.ImageInPoint = 0;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDuDx = srcPreShrinkDeltaX;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayDeltaDvDy = srcPreShrinkDeltaY;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlaySize =
                asmMergeCoords(((pDriverData->dwOverlaySrcWidth + 1) & ~1), dwSrcHeight);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayFormat =
                (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwSrcPitch;

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayOffset =
                dwSrcOffset;

            /* Restore offset */
            dwSrcOffset -= (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset -= ((lpUOData->rSrc.left & ~1) << 1);

            npDevVideo->dDrawSpare.nv4DvdSubpicture.OverlayPoint = 0;

            pDriverData->dDrawSpareSubchannelObject = 0;

            /* Change offset to point to shrunken overlay surface memory */
            if ((surfaceIs422) && (pDriverData->extra422OverlayOffset[index] != 0))
                dwSrcOffset = pDriverData->extra422OverlayOffset[index];
            else
                dwSrcOffset += src->dwReserved1;

            /* Restore overlay source pitch and height to normal since we prescaled it */
            if (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD) {
                dwSrcPitch >>= 1;
                dwSrcHeight <<= 1;
            }

            /* Force fifo to stall until shrink operation finishes */
            npDevVideo->dDrawSpare.nv4DvdSubpicture.Notify = 0;
            npDevVideo->dDrawSpare.nv4DvdSubpicture.NoOperation = 0;
                
                //pDriverData->dwRingZeroMutex = FALSE;
            
        } else {
            /* Offset to visible portion of source surface */
            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += ((lpUOData->rSrc.left & ~1) << 1);
        }

        while (videoFreeCount <56)
            videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
        videoFreeCount -= 56;

        //pDriverData->dwRingZeroMutex = TRUE;
            
        /* Trash spare subchannel */
        npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;
        npDevVideo->dDrawSpare.videoColorKey.SetPoint =
            asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
        npDevVideo->dDrawSpare.videoColorKey.SetSize =
            asmMergeCoords((dwDstWidth & ~1), (dwDstHeight & ~1));

        /*
         * color key?
         */
        if( lpUOData->dwFlags & (DDOVER_KEYDESTOVERRIDE) ) {
            DPF( "Dest ColorKey = %08lx,%08lx",
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue,
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceHighValue );

            if (pDriverData->bi.biBitCount == 8)
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_008;
            else if (pDriverData->bi.biBitCount == 16)
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_016;
            else
                npDevVideo->dDrawSpare.videoColorKey.SetColorKey =
                    lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue |
                        NV_ALPHA_1_032;

        } else // disable color key
            npDevVideo->dDrawSpare.videoColorKey.SetColorKey = 0;


        npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_SCALER;
        npDevVideo->dDrawSpare.videoScaler.SetPoint =
            asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
        npDevVideo->dDrawSpare.videoScaler.SetDeltaDuDx = srcDeltaX;

        if( ! bMediaPortControl )
            npDevVideo->dDrawSpare.videoScaler.SetDeltaDvDy = srcDeltaY;

        npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

// temp defines b4 becoming a class standard
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

        if (lpUOData->dwFlags & DDOVER_AUTOFLIP)
            index = 0; // overide index for mediaport/overlay autoflip

        if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
            (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
            U032 dwFormat = NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;

            // we need to know if we're bobbing
            if((lpUOData->dwFlags & DDOVER_BOB) && (lpUOData->dwFlags & DDOVER_INTERLEAVED) ){
                dwFormat = dwFormat | NV_VFM_FORMAT_BOBFROMINTERLEAVE;
                DPF( "Video Port - Interleaved - BOB");
            }

            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {

                if (lpUOData->dwFlags & DDOVER_AUTOFLIP) {
                    dwFormat |= (index ? NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 :
                                         NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0);
                }

                if ((lpUOData->dwFlags & DDOVER_BOB) && (index == 1)) {
                    // improves quality on BOB for low resolution images
                    // only do a BOB if srcY >= 120
                    if ((lpUOData->rSrc.bottom - lpUOData->rSrc.top) >=120)
                        dwSrcPitch |= 2; // tell overlay to do a halfline offset
                }
            }

            if( ! bMediaPortControl )
                npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                    dwFormat;
            /* Let the world know what the overlay src info is */
            pDriverData->OverlayFormat = dwFormat;
        } else
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].format =
                NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8;

        /* Let the world know what the overlay src info is */
        pDriverData->OverlaySrcOffset = dwSrcOffset;

        pDriverData->OverlaySrcPitch = dwSrcPitch;

        pDriverData->OverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

        if( ! bMediaPortControl ) {
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset =
                dwSrcOffset;
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch =
                dwSrcPitch;
            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size =
                asmMergeCoords(dwSrcWidth, dwSrcHeight);

            npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;
        }
      //pDriverData->dwRingZeroMutex = FALSE;
            
        pDriverData->dDrawSpareSubchannelObject = 0;

        /* Quadrant DVD decoder hack should NOT go here because DVD subpicture slows things down enough */

        /* Let DDraw know how many visible overlays are active */
        if (pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays == 0) {
            pDriverData->HALInfo.ddCaps.dwCurrVisibleOverlays = 1;
        }
    }

    pDriverData->NvVideoFreeCount = (short)videoFreeCount;
    
    pDriverData->dwRingZeroMutex = FALSE;

#ifdef NVPE
	///// H.AZAR: (03/01/1999): notify miniport of overlay changes !
	if (bMediaPortControl)
		NVPUpdateOverlay();
#endif	// #ifdef NVPE

    lpUOData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* UpdateOverlay32 */


/*
 * SetOverlayPosition32
 */
DWORD __stdcall
SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA lpSOPData )
{
    FAST Nv3ChannelPio          *npDevVideo;
    FAST long                   videoFreeCount;
    DWORD                       index = 0;
    DWORD                       match = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpSOPData->lpDDSrcSurface;

    NvSetDriverDataPtr(lpSOPData->lpDD);

    npDevVideo = (NvChannel *)pDriverData->NvDevVideoFlatPio;
    videoFreeCount = pDriverData->NvVideoFreeCount;

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            return DDHAL_DRIVER_HANDLED;
    }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0)) {
            lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        lpSOPData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
    }

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayPosition( lpSOPData);
    return DDHAL_DRIVER_HANDLED;

    }
#endif //

    NV_DD_DMA_PUSHER_SYNC();

    if (npDevVideo == NULL) {  /* Mode switches might occur without warning */
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    while (videoFreeCount < 28)
        videoFreeCount = NvGetFreeCount(npDevVideo, NV_DD_SPARE);
    videoFreeCount -= 28;

    /*
     * NOTES:
     *
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08lx", lpSOPData->lpDDSrcSurface );
    DPF( "(%ld,%ld)", lpSOPData->lXPos, lpSOPData->lYPos );

    pDriverData->dwRingZeroMutex = TRUE;
     /* Trash spare subchannel */
    npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_COLOR_KEY;
    npDevVideo->dDrawSpare.videoColorKey.SetPoint =
        asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);

    npDevVideo->dDrawSpare.SetObject = NV_DD_VIDEO_SCALER;
    npDevVideo->dDrawSpare.videoScaler.SetPoint =
        asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);

    /* Our new mechanism requires that we use the VFM notifier to make this happen */
    npDevVideo->dDrawSpare.SetObject = NV_DD_YUV422_VIDEO_FROM_MEMORY;

    /* Alternate buffer indexes to keep the hardware happy */
    pDriverData->OverlayBufferIndex ^= 1;

    index = pDriverData->OverlayBufferIndex;

    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].offset =
        pDriverData->OverlaySrcOffset;
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].pitch =
        pDriverData->OverlaySrcPitch;
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].size =
        pDriverData->OverlaySrcSize;
    /* We won't wait for this notifier so status won't be initialized */
    npDevVideo->dDrawSpare.videoFromMemory.ImageScan[index].notify = 0;

    pDriverData->dwRingZeroMutex = FALSE;
    pDriverData->dDrawSpareSubchannelObject = 0;

    pDriverData->NvVideoFreeCount = (short)videoFreeCount;

    lpSOPData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} /* SetOverlayPosition32 */



/*
 * DestroyFloating422Context32
 *
 */

DWORD __stdcall
DestroyFloating422Context32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface)
{
    FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    unsigned long               *dmaPusherPutAddress =
                                    (unsigned long *)pDriverData->NvDmaPusherPutAddress;
    unsigned long               *dmaPusherBufferBase =
                                    (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  CACHE_FREECOUNT
    long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
    long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

    NV_DD_DMA_PUSHER_SYNC();

    /* Let D3D code know that we have touched NV */
    pDriverData->TwoDRenderingOccurred = 1;

    psurf = lpDDSurface;
    psurf_gbl = psurf->lpGbl;

   if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
       (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
        if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating0UYVYSurfaceMem == psurf_gbl->fpVidMem)) {
                long countDown;
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            countDown = 0x200000;
                while (((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) && (--countDown > 0)) NV_SLEEP;


            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            countDown = 0x200000;
                while (((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS)&& (--countDown > 0)) NV_SLEEP; // wait for notification


#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        } else if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating1UYVYSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }
    } else { /* YUYV */
        if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating0YUYVSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        } else if ((pDriverData->fNvActiveFloatingContexts &
            NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
           (pDriverData->NvFloating1YUYVSurfaceMem == psurf_gbl->fpVidMem)) {
            NvNotification *pDmaSyncNotifier =
                (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

            // MUST wait for any pending notification to prevent possible loss of notification serialization
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

            while (freeCount < 8)
                NvGetDmaBufferFreeCount(npDev, freeCount, 8, dmaPusherPutAddress);
            freeCount -= 8;

            pDriverData->dDrawSpareSubchannelObject = 0;

            pDmaSyncNotifier->status = NV_IN_PROGRESS;

            /* Trash spare subchannel */
            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
            dmaPusherPutAddress[3] = NV1_NULL_OBJECT;
            dmaPusherPutAddress[4] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000;
            dmaPusherPutAddress[5] = 0;
            dmaPusherPutAddress[6] = dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000;
            dmaPusherPutAddress[7] = 0;

            dmaPusherPutAddress += 8;

            pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

            /* Force write combine buffer to flush */
            pDriverData->NvDmaPusherBufferEnd[0] = 0;
            /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
            _outp (0x3d0,0);

            npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

#ifdef  MULTI_MON
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
#else   /* MULTI_MON */
            while (freeCount < 6)
                NvGetDmaBufferFreeCount(npDev, freeCount, 6, dmaPusherPutAddress);
            freeCount -= 6;

            dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
            dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
            dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0xC0000;
            dmaPusherPutAddress[3] = 0; // unlock system memory
            dmaPusherPutAddress[4] = 0;
            dmaPusherPutAddress[5] = 0;

            dmaPusherPutAddress += 6;
#endif  /* MULTI_MON */

            pDriverData->fNvActiveFloatingContexts &=
                ~NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
        }
    }

    pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

    /* Force write combine buffer to flush */
    pDriverData->NvDmaPusherBufferEnd[0] = 0;
    /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
    _outp (0x3d0,0);

    pDriverData->dwDmaPusherFreeCount = freeCount;

    npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

    return DDHAL_DRIVER_HANDLED;
}



/*
 * CreateFloating422Context32
 *
 */

DWORD __stdcall
CreateFloating422Context32(LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, DWORD dwBlockSize)
{
   FAST Nv10ControlDma         *npDev = (Nv10ControlDma *)pDriverData->NvDevFlatDma;
   NvNotification              *pDmaDmaToMemNotifier =
                                   (NvNotification *)pDriverData->NvDmaDmaToMemNotifierFlat;
   LPDDRAWI_DDRAWSURFACE_LCL   psurf;
   LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
   unsigned long               *dmaPusherPutAddress =
                                   (unsigned long *)pDriverData->NvDmaPusherPutAddress;
   unsigned long               *dmaPusherBufferBase =
                                   (unsigned long *)pDriverData->NvDmaPusherBufferBase;
#ifdef  MULTI_MON
   unsigned long               status;
#endif  /* MULTI_MON */
#ifdef  CACHE_FREECOUNT
   long                        freeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(freeCount, dmaPusherPutAddress);
#endif  /* DEBUG */
#else   /* CACHE_FREECOUNT */
   long                        freeCount = 0;
#endif  /* CACHE_FREECOUNT */

   NV_DD_DMA_PUSHER_SYNC();

   /* Let D3D code know that we have touched NV */
   pDriverData->TwoDRenderingOccurred = 1;

   psurf = lpDDSurface;
   psurf_gbl = psurf->lpGbl;

   if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
       (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_UYNV)) {
       if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0UYVYSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0UYVYSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       } else if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1UYVYSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1UYVYSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       }
   } else if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_YUY2) ||
              (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_YUNV)) {
       if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       } else if ((pDriverData->fNvActiveFloatingContexts &
           NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) == 0) {

#ifdef MULTI_MON
           status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                               NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                               NV01_CONTEXT_DMA,
                               (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                               (PVOID)psurf_gbl->fpVidMem,
                               (dwBlockSize - 1));

           if (status == ALLOC_CTX_DMA_STATUS_SUCCESS) {

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating0YUYVSurfaceMem = psurf_gbl->fpVidMem;

               while (freeCount < 4)
                   NvGetDmaBufferFreeCount(npDev, freeCount, 4, dmaPusherPutAddress);
               freeCount -= 4;

               pDriverData->dDrawSpareSubchannelObject = 0;

               /* Trash spare subchannel */
               dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
               dmaPusherPutAddress[1] = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
               dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                        SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
               dmaPusherPutAddress[3] = NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               dmaPusherPutAddress += 4;

               pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

               /* Force write combine buffer to flush */
               pDriverData->NvDmaPusherBufferEnd[0] = 0;
               /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
               _outp (0x3d0,0);

               pDriverData->dwDmaPusherFreeCount = freeCount;

               npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;
           }

#else   /* MULTI_MON */

           pDmaDmaToMemNotifier->status = NV_IN_PROGRESS;

           /* Trash spare subchannel */
           while (freeCount < 13)
               NvGetDmaBufferFreeCount(npDev, freeCount, 13, dmaPusherPutAddress);
           freeCount -= 13;

           dmaPusherPutAddress[0] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[1] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[2] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET | 0x80000;
           dmaPusherPutAddress[3] = (unsigned long)psurf_gbl->fpVidMem;
           dmaPusherPutAddress[4] = (unsigned long)NvGetFlatDataSelector();
           dmaPusherPutAddress[5] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET | 0x40000;
           dmaPusherPutAddress[6] = 0;
           dmaPusherPutAddress[7] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET | 0x40000;
           dmaPusherPutAddress[8] = dwBlockSize - 1;

           dmaPusherPutAddress[9] = dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000;
           dmaPusherPutAddress[10] = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
           dmaPusherPutAddress[11] = dDrawSubchannelOffset(NV_DD_SPARE) +
                    SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000;
           dmaPusherPutAddress[12] = NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

           dmaPusherPutAddress += 13;

           pDriverData->NvDmaPusherPutAddress = (unsigned long)dmaPusherPutAddress;

           /* Force write combine buffer to flush */
           pDriverData->NvDmaPusherBufferEnd[0] = 0;
           /* Don't want this, but it's currently the only known way to guarantee a write combine flush. */
           _outp (0x3d0,0);

           pDriverData->dwDmaPusherFreeCount = freeCount;

           npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2;

           while ((volatile)pDmaDmaToMemNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

           if (pDmaDmaToMemNotifier->status == NV_STATUS_DONE_OK) {

               pDriverData->dDrawSpareSubchannelObject =
                   NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->fNvActiveFloatingContexts |=
                   NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

               pDriverData->NvFloating1YUYVSurfaceMem = psurf_gbl->fpVidMem;
           }
#endif  /* MULTI_MON */
       }
   }

   return DDHAL_DRIVER_HANDLED;
}



/*
 * Video scaler arbitration routines
 */


//
// Calculate the closest arbitration values for a given system configuration
//
// NOTE: Please excuse this code.  In comes from the hardware group...
//
VOID dacCalculateArbitration
(
           fifo_info *fifo,
           sim_state  *arb
)
{
  int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;
      if(vlwm > 146) vbs = 64;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}


#ifndef WINNT // For WINNT, this is a macro which checks the PDEV flag
              // to determine if overlay is supported in this mode.
/*
 * GetVideoScalerBandwidthStatus
 */
BOOL __stdcall GetVideoScalerBandwidthStatus32(unsigned long surfaceFlags)
{
    fifo_info fifo_data;
    sim_state sim_data;
    U032 M, N, O, P, crystal, NVclk, Mclk, Vclk;

    // Get the crystal (F in Hz)
#ifdef  MULTI_MON
    crystal = NvConfigGet(NV_CFG_CRYSTAL_FREQ, pDriverData->dwDeviceIDNum);
    Mclk = NvConfigGet(NV_CFG_DAC_MEMORY_CLOCK, pDriverData->dwDeviceIDNum);
    NVclk = NvConfigGet(NV_CFG_DAC_GRAPHICS_CLOCK, pDriverData->dwDeviceIDNum);
#else   /* MULTI_MON */
    crystal = NvConfigGet(NV_CFG_CRYSTAL_FREQ);
    Mclk = NvConfigGet(NV_CFG_DAC_MEMORY_CLOCK);
    NVclk = NvConfigGet(NV_CFG_DAC_GRAPHICS_CLOCK);
#endif  /* MULTI_MON */

    //
    // Recalculate the current PCLK setting.  We might have changed modes
    // recently.
    //

#ifdef  MULTI_MON
    M = NvConfigGet(NV_CFG_DAC_VPLL_M, pDriverData->dwDeviceIDNum);
    N = NvConfigGet(NV_CFG_DAC_VPLL_N, pDriverData->dwDeviceIDNum);
    O = 1;
    P = NvConfigGet(NV_CFG_DAC_VPLL_P, pDriverData->dwDeviceIDNum);

    Vclk = (N * crystal / (1 << P) / M);  // MHz

#else   /* MULTI_MON */
    M = NvConfigGet(NV_CFG_DAC_VPLL_M);
    N = NvConfigGet(NV_CFG_DAC_VPLL_N);
    O = 1;
    P = NvConfigGet(NV_CFG_DAC_VPLL_P);

    Vclk = (N * crystal / (1 << P) / M);  // MHz

#endif  /* MULTI_MON */

    //
    // Last minute kludge to work around the fact that new NV4 arbitration
    // algorithm NEVER rejects overlay requests.
    //

    if (((pDriverData->bi.biBitCount < 16) && (Vclk > 180000000)) ||
        ((pDriverData->bi.biBitCount == 16) && (Vclk > 130000000)) ||
        ((pDriverData->bi.biBitCount > 16) && (Vclk > 80000000)))
       return (FALSE);

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (char)pDriverData->bi.biBitCount;
    sim_data.enable_video   = 1; // Video (monitor scan out) enabled
    sim_data.enable_mp      = (surfaceFlags & DDSCAPS_VIDEOPORT) ? 1 : 0;
#ifdef  MULTI_MON
    sim_data.memory_width   = NvConfigGet(NV_CFG_DAC_INPUT_WIDTH, pDriverData->dwDeviceIDNum);
#else   /* MULTI_MON */
    sim_data.memory_width   = NvConfigGet(NV_CFG_DAC_INPUT_WIDTH);
#endif  /* MULTI_MON */
    sim_data.mem_latency    = 3;
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = 10;
    sim_data.gr_during_vid  = 1; // Color key enabled ??? (TONG says there is negligible bandwidth difference here)
    sim_data.pclk_khz       = Vclk / 1000;  // in kHz, not MHz
    sim_data.mclk_khz       = Mclk / 1000;  // in kHz, not MHz
    sim_data.nvclk_khz      = NVclk / 1000; // in kHz, not MHz
    //
    // Get those new numbers
    //
    dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, then video scaler can be used
    //
    if (fifo_data.valid)
        return(TRUE);
    else
        return(FALSE);
}
#endif // #ifndef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4ctxt.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4CTXT.C                                                         *
*   Hardware specific context management routines.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - reorganzied.                 *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "nv32.h"
#include "ddrvmem.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv4dreg.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  // MULTI_MON

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
extern Nv4ControlDma * __stdcall NvOpenDma(char *, int, int, int);
#endif // #ifndef WINNT

/*
 * Setup the context surface.
 */
BOOL nvSetContextSurface
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   dwRenderAlphaMask;
    DWORD   dwRenderRedMask;
    DWORD   dwRenderGreenMask;
    DWORD   dwRenderBlueMask;

    DWORD   dwRenderFormat;
    DWORD   dwRenderBitCount;
    DWORD   dwZetaBitCount;
    DWORD   dwAdjustedZetaBitCount;
    DWORD  *pdwZetaBitCount;

    if (pContext->lpLcl)
    {
        /*
         * Store the width and height of the surface in the context.
         */
        pContext->surfaceViewport.clipHorizontal.wX      = 0;
        pContext->surfaceViewport.clipHorizontal.wWidth  = pContext->lpLcl->lpGbl->wWidth;
        pContext->surfaceViewport.clipVertical.wY        = 0;
        pContext->surfaceViewport.clipVertical.wHeight   = pContext->lpLcl->lpGbl->wHeight;

        /*
         * Initialize current surface addresses.
         */
        pContext->dwSurfaceAddr            = VIDMEM_ADDR(pContext->lpLcl->lpGbl->fpVidMem);
        pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pContext->lpLcl->lpGbl->fpVidMem);
        pContext->surfacePitch.wColorPitch = (WORD)pContext->lpLcl->lpGbl->lPitch;

        /*
         * Get the Render Target color format.
         */
        if (pContext->lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvSetContextSurface: Render Target Pixel Format");
            dwRenderBitCount  = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            dwRenderAlphaMask = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask;
            dwRenderRedMask   = pContext->lpLcl->lpGbl->ddpfSurface.dwRBitMask;
            dwRenderGreenMask = pContext->lpLcl->lpGbl->ddpfSurface.dwGBitMask;
            dwRenderBlueMask  = pContext->lpLcl->lpGbl->ddpfSurface.dwBBitMask;
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvSetContextSurface: Render Format same as desktop!");
            dwRenderBitCount = pDriverData->bi.biBitCount;
            if (dwRenderBitCount == 16)
            {
                dwRenderAlphaMask = 0x00000000;
                dwRenderRedMask   = 0x0000F800;
                dwRenderGreenMask = 0x000007E0;
                dwRenderBlueMask  = 0X0000001F;
            }
            else if ((dwRenderBitCount == 24) || (dwRenderBitCount == 32))
            {
                dwRenderAlphaMask = 0x00000000;
                dwRenderRedMask   = 0x00FF0000;
                dwRenderGreenMask = 0x0000FF00;
                dwRenderBlueMask  = 0X000000FF;
            }
            else
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid 3D rendering format!!");
                dbgD3DError();
                return (FALSE);
            }
        }
        DPF_LEVEL(NVDBG_LEVEL_INFO, "    BitCount = %02ld", dwRenderBitCount);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "    RMask=%08lx, GMask=%08lx, BMask=%08lx, AMask=%08lx",
             dwRenderRedMask, dwRenderGreenMask, dwRenderBlueMask, dwRenderAlphaMask);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "\r\n");
        if (dwRenderBitCount == 16)
        {
            switch (dwRenderAlphaMask)
            {
                case 0x00000000:
                    if (dwRenderRedMask == 0x7C00)
                        dwRenderFormat = 0x00007FFF;
                    else
                        dwRenderFormat = 0x0000FFFF;
                    break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid 16 bpp Render Target Format!!");
                    break;
            }
        }
        else if ((dwRenderBitCount == 24)
              || (dwRenderBitCount == 32))
        {
            switch (dwRenderAlphaMask)
            {
                case 0x00000000:
                    dwRenderFormat = 0x00FFFFFF;
                    break;
                case 0x7F000000:
                    dwRenderFormat = 0x7FFFFFFF;
                    break;
                case 0xFF000000:
                    dwRenderFormat = 0xFFFFFFFF;
                    break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid %02ld Bpp Render Target Format!!", dwRenderBitCount);
            }
        }
        else
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid %02ld Bpp Render Target Format!!", dwRenderBitCount);
    }
    else
    {
        pContext->surfaceViewport.clipHorizontal.wX     = 0;
        pContext->surfaceViewport.clipHorizontal.wWidth = 0;
        pContext->surfaceViewport.clipVertical.wY       = 0;
        pContext->surfaceViewport.clipVertical.wHeight  = 0;
        pContext->dwSurfaceAddr                         = 0;
        pContext->dwSurfaceOffset                       = 0;
        pContext->surfacePitch.wColorPitch              = 0;

        /*
         * No Render Target color format.
         */
        dwRenderFormat   = 0x00000000;
        dwRenderBitCount = 0;
    }

    /*
     * Enable/Disable the Z-Buffer based on whether one is supplied.
     */
    if (pContext->lpLclZ)
    {
        /*
         * Initialize Z-Buffer location.
         */
        pContext->ZBufferAddr             = pContext->lpLclZ->lpGbl->fpVidMem;
#ifdef WINNT
        pContext->ZBufferAddr += (ULONG) pDriverData->ppdev->pjScreen;
#endif // #ifndef WINNT
        pContext->ZBufferOffset           = pContext->lpLclZ->lpGbl->fpVidMem - pDriverData->BaseAddress;
        pContext->surfacePitch.wZetaPitch = (WORD)pContext->lpLclZ->lpGbl->lPitch;

        /*
         * Get the Zeta Buffer bit depth.
         * The bit depth of the render target and the zeta buffer MUST match.
         */
        if (pContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvSetContext Surface: Zeta Buffer Format");
            DPF_LEVEL(NVDBG_LEVEL_INFO, "    BitCount = %02ld", pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount);
            DPF_LEVEL(NVDBG_LEVEL_INFO, "    RMask=%08lx, GMask=%08lx, BMask=%08lx, AMask=%08lx",
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwRBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwGBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwBBitMask,
                      pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBAlphaBitMask);
            DPF_LEVEL(NVDBG_LEVEL_INFO, "\r\n");
            dwZetaBitCount = pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount;
            pdwZetaBitCount = (DWORD *)&pContext->lpLclZ->lpGbl->ddpfSurface.dwRGBBitCount;
            /*
             * Can't do stencil buffer in 16bpp rendering modes.
             */
            if ((pContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER)
             && (dwRenderBitCount == 16))
                pContext->dwContextFlags |= NV_CONTEXT_ZETA_BUFFER_MISMATCH;
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "No Zeta Format specified.  Make it same as render surface.");
            dwZetaBitCount = pContext->lpLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            pdwZetaBitCount = NULL;
        }
    }
    else
    {
        /*
         * Disable the Z buffer.
         */
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;

        /*
         * There's no Z-Buffer addresses.
         */
        pContext->ZBufferAddr             = 0;
        pContext->ZBufferOffset           = 0;

        /*
         * When there is no z-buffer, the pitch still has to be non-zero. (I hate that!)
         */
        pContext->surfacePitch.wZetaPitch = 32;

        /*
         * No Zeta Buffer color format.
         */
        dwZetaBitCount  = 0;
        pdwZetaBitCount = NULL;
    }

    /*
     * Set the surface format.
     */
    pContext->dwSurfaceFormat = DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

    if ((pDriverData->regValidateZMethod == REG_VZM_FLEXIBLE)
     || ((pDriverData->regValidateZMethod == REG_VZM_MIXED) && (pContext->dwDXVersionLevel < APP_VERSION_DX6)))
    {
        /*
         * Match Z-Buffer Depth to Render Depth if the VALIDATEZMETHOD registry setting is:
         * REG_VZM_FLEXIBLE
         * OR
         * REG_VZM_MIXED and this is a legacy (DX5 or earlier) application.
         */
        switch (dwRenderFormat)
        {
            case 0x00007FFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5);
                dwAdjustedZetaBitCount = 16;
                break;
            case 0x0000FFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5);
                dwAdjustedZetaBitCount = 16;
                break;
            case 0x00FFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
            case 0x7FFFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1A7R8G8B8_Z1A7R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
            case 0xFFFFFFFF:
                pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_A8R8G8B8);
                dwAdjustedZetaBitCount = 24;
                break;
        }
        if (pdwZetaBitCount)
            *pdwZetaBitCount = dwAdjustedZetaBitCount;

        /*
         * Keep track of whether or not the z-buffer depth matches the rendering depth.  This information
         * will be used by SetRenderTarget.
         */
        if (((dwZetaBitCount == 16) && (dwRenderBitCount != 16))
         || ((dwZetaBitCount == 24) && (dwRenderBitCount == 16))
         || ((dwZetaBitCount == 32) && (dwRenderBitCount == 16)))
        {
            pContext->dwContextFlags |= NV_CONTEXT_ZETA_BUFFER_MISMATCH;
        }

    }
    else
    {
        /*
         * Make sure Z-Buffer Depth matches the Rendering Depth if the VALIDATEZMETHOD registry setting is:
         * REG_VZM_STRICT
         * OR
         * REG_VZM_MIXED and this is a DX6 or later application.
         */
        if (((dwZetaBitCount == 0) && (dwRenderBitCount != 0))
         || ((dwZetaBitCount == dwRenderBitCount)
         ||  ((dwZetaBitCount == 24) && (dwRenderBitCount == 32))
         ||  ((dwZetaBitCount == 32) && (dwRenderBitCount == 24))))
        {
            switch (dwRenderFormat)
            {
                case 0x00007FFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5);
                    break;
                case 0x0000FFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5);
                    break;
                case 0x00FFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X8R8G8B8_Z8R8G8B8);
                    break;
                case 0x7FFFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1A7R8G8B8_Z1A7R8G8B8);
                    break;
                case 0xFFFFFFFF:
                    pContext->dwSurfaceFormat |= DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_A8R8G8B8);
                    break;
            }
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Render Target Bit Depth and Zeta Bit Depth Don't match");
            return (FALSE);
        }
    }
    /*
     * If the WFar value is 0.0, then set a default based on the z-buffer precision.
     */
    if (pCurrentContext->dvWFar == 0.0f)
    {
        pCurrentContext->dvWNear = 0.0f;
        if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
         || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        {
            pCurrentContext->dvWFar  = (D3DVALUE)(1 << 16);
        }
        else
        {
            pCurrentContext->dvWFar  = (D3DVALUE)(1 << 24);
        }
        pCurrentContext->dvRWFar = pCurrentContext->dvWFar;
    }
    return (TRUE);
}
BOOL nvSetupContext
(
    PNVD3DCONTEXT   pContext
)
{
#ifdef  NVD3D_DX6
    DWORD   i;
#endif  // NVD3D_DX6

    /*
     * Clear all context flags to start out.
     */
    pContext->dwContextFlags = 0;

    /*
     * First setup the context surface.
     */
    if (!nvSetContextSurface(pContext))
        return (FALSE);

    /*
     * Set the default rendering state for the context.
     * The defaults come from the final DX5 D3D DDK Documentation.
     */
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]     = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPU]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPV]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]           = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]          = D3DSHADE_GOURAUD;
    pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ROP2]               = R2_COPYPEN;
    pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]          = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]    = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]          = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]    = D3DTBLEND_MODULATE;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]           = D3DCULL_CCW;
    pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]              = D3DCMP_LESSEQUAL;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]       = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]       = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]      = 1;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]        = 100;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]    = 1;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]              = 0;
    pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]         = FALSE;

    /*
     * Enable the Z-Buffer if there is one attached.
     */
    if (pContext->lpLclZ)
    {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = TRUE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = TRUE;
    }
    else
    {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;
    }

    /*
     * Initialize the hardware LOD bias as the value specified in the registry.
     */
    pContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
#ifdef  NVD3D_DX6
    pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]               = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]                = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]                 = 0;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]                = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]           = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]              = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP0]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP1]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP2]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP3]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP4]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP5]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP6]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP7]                      = 0;


    /*
     * Initialize the texture stages.  Stage 1-7 are all defaulted to disabled.
     * Stage 0 is defaulted for no texturing.
     */
    pContext->tssState[0].dwTextureMap      = 0;
    pContext->tssState[0].dwAddressU        = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwAddressV        = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwMagFilter       = D3DTFG_POINT;
    pContext->tssState[0].dwMinFilter       = D3DTFN_POINT;
    pContext->tssState[0].dwMipFilter       = D3DTFP_POINT;
    pContext->tssState[0].dwColorOp         = D3DTOP_MODULATE;
    pContext->tssState[0].dwColorArg1       = D3DTA_TEXTURE;
    pContext->tssState[0].dwColorArg2       = D3DTA_CURRENT;
    pContext->tssState[0].dwAlphaOp         = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwAlphaArg1       = D3DTA_TEXTURE;
    pContext->tssState[0].dwAlphaArg2       = D3DTA_CURRENT;
    pContext->tssState[0].dwBumpEnvMat00    = 0;
    pContext->tssState[0].dwBumpEnvMat01    = 0;
    pContext->tssState[0].dwBumpEnvMat10    = 0;
    pContext->tssState[0].dwBumpEnvMat11    = 0;
    pContext->tssState[0].dwTexCoordIndex   = 0;
    pContext->tssState[0].dwBorderColor     = 0x00000000;
    pContext->tssState[0].dwMipMapLODBias   = 0;
    pContext->tssState[0].dwMaxMipLevel     = 0;
    pContext->tssState[0].dwMaxAnisotropy   = 1;
    pContext->tssState[0].dwBumpEnvlScale   = 0;
    pContext->tssState[0].dwBumpEnvlOffset  = 0;
    pContext->tssState[0].bStageNumber      = 0;
    pContext->tssState[0].bWrapU            = 0;
    pContext->tssState[0].bWrapV            = 0;
    pContext->tssState[0].bLODBias          = (BYTE)(pDriverData->regLODBiasAdjust & 0x000000FF);

    for (i = 1; i < 8; i++)
    {
        pContext->tssState[i].dwTextureMap      = 0;
        pContext->tssState[i].dwAddressU        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwAddressV        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwMagFilter       = D3DTFG_POINT;
        pContext->tssState[i].dwMinFilter       = D3DTFN_POINT;
        pContext->tssState[i].dwMipFilter       = D3DTFP_POINT;
        pContext->tssState[i].dwColorOp         = D3DTOP_DISABLE;
        pContext->tssState[i].dwColorArg1       = D3DTA_TEXTURE;
        pContext->tssState[i].dwColorArg2       = D3DTA_CURRENT;
        pContext->tssState[i].dwAlphaOp         = D3DTOP_DISABLE;
        pContext->tssState[i].dwAlphaArg1       = D3DTA_TEXTURE;
        pContext->tssState[i].dwAlphaArg2       = D3DTA_CURRENT;
        pContext->tssState[i].dwBumpEnvMat00    = 0;
        pContext->tssState[i].dwBumpEnvMat01    = 0;
        pContext->tssState[i].dwBumpEnvMat10    = 0;
        pContext->tssState[i].dwBumpEnvMat11    = 0;
        pContext->tssState[i].dwTexCoordIndex   = 0;
        pContext->tssState[i].dwBorderColor     = 0x00000000;
        pContext->tssState[i].dwMipMapLODBias   = 0;
        pContext->tssState[i].dwMaxMipLevel     = 0;
        pContext->tssState[i].dwMaxAnisotropy   = 1;
        pContext->tssState[i].dwBumpEnvlScale   = 0;
        pContext->tssState[i].dwBumpEnvlOffset  = 0;
        pContext->tssState[i].bStageNumber      = (BYTE)i;
        pContext->tssState[i].bWrapU            = 0;
        pContext->tssState[i].bWrapV            = 0;
        pContext->tssState[i].bLODBias          = (BYTE)(pDriverData->regLODBiasAdjust & 0x000000FF);
    }
    pContext->dwStageCount = 1;
    pContext->bUseDX6Class = FALSE;
    pContext->dwContextFlags |= NV_CONTEXT_TBLEND_UNINITIALIZED;
    pContext->bUseTBlendSettings = FALSE;
#endif  // NVD3D_DX6

    /*
     * Allocate a default 1x1 texture.
     */
    nvAllocDefaultTexture(pContext);

    /*
     * Set the hardware state.
     */
    pCurrentContext = pContext;

    /*
     * Force an initial state load.
     */
    pCurrentContext->dwStateChange = TRUE;
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return(TRUE);
}
BOOL nvFinalContextCleanup
(
    void
)
{
    return (TRUE);
}
void nvAllocDefaultTexture
(
    PNVD3DCONTEXT   pContext
)
{
    unsigned char  *pData = 0;
#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->lpDD;
#endif

    pContext->dwDefaultTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
#ifndef WINNT
    NVHEAP_ALLOC(((DWORD)pData), 2 + NV_TEXTURE_PAD, TYPE_TEXTURE);
#else
    NVHEAP_ALLOC(((DWORD)pData), ((2 + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~pDriverData->dwSurfaceAlignPad), TYPE_TEXTURE);
#endif // #ifdef WINNT
    //pData = (unsigned char *)DDHAL32_VidMemAlloc(pContext->lpLcl->lpGbl->lpDD, 0, ((2 + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~pDriverData->dwSurfaceAlignPad), 1);
    if (pData)
    {
        pContext->dwDefaultTextureBase   = (DWORD)pData;
        pContext->dwDefaultTextureOffset = VIDMEM_OFFSET((((DWORD)pData + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress);
        pData = (unsigned char *)VIDMEM_ADDR((pContext->dwDefaultTextureOffset));

        pData[0] = 0xFF;
        pData[1] = 0xFF;

        /*
         * Increment count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount++;
    }
    else
    {
        pContext->dwDefaultTextureBase   = (DWORD)0;
        pContext->dwDefaultTextureOffset = 0;
    }
    pContext->dwDefaultTextureColorFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;


    /*
     * init psuedo-notifier memory
     */
    {
        DWORD size = 16;
#ifndef WINNT
        memset ((void*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress),0,size);
        *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + pDriverData->BaseAddress) = pDriverData->dwTMStageAddr;
#else
        memset ((void*)(pDriverData->dwTMPseudoNotifierMem),0,size);
        *(DWORD*)(pDriverData->dwTMPseudoNotifierMem) = pDriverData->dwTMStageAddr;
#endif
        pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
        pDriverData->dwTMTail = pDriverData->dwTMStageAddr;
        pDriverData->dwRenderedFrame = pDriverData->dwCurrentFrame = 0;
        global.dwHWTextureDate = global.dwSWTextureDate;
    }

    /*
     * invalidate fvfData cache
     */
    fvfData.dwVertexType = 0;

    return;
}
void nvFreeDefaultTexture
(
    PNVD3DCONTEXT   pContext
)
{
#ifndef NVHEAPMGR
#ifndef WINNT // BUGBUG where do we get this from under NT?
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->lpDD;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pContext->lpLcl->lpGbl->dwReserved1;
#endif // #ifndef WINNT
#endif
    if (!pContext) return;
    if ((pContext->lpLcl) &&
#ifndef WINNT
    (pContext->lpLcl->lpGbl) &&
    (pContext->lpLcl->lpGbl->lpDD) &&
#else
    (pContext->lpDD) &&
#endif // #ifndef WINNT
            (pContext->dwDefaultTextureBase))

    {
        NVHEAP_FREE (pContext->dwDefaultTextureBase);

        //DDHAL32_VidMemFree(pContext->lpLcl->lpGbl->lpDD, 0, pContext->dwDefaultTextureBase);
        pContext->dwDefaultTextureBase   = 0;
        pContext->dwDefaultTextureOffset = 0;

        /*
         * Increment count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;
    }

    return;
}
#define NV4_PUSH_BUFFER_PAD     64

void nvD3DReenable()
{
    PNVD3DCONTEXT   pContext = 0;

    NV_D3D_GLOBAL_SETUP();

    /*
     * Run through all valid contexts and update push buffer information.
     */
    pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        pContext->dwDefaultTextureBase = 0;
        pContext->dwContextReset       = TRUE;
        pContext = pContext->pContextNext;
    }

    /*
     * Force reset of D3D rendering target and z-buffer.
     */
    pDriverData->fFullScreenDosOccurred  = 0;
    pDriverData->lpLast3DSurfaceRendered = 0;
    pDriverData->dwCurrentContextHandle  = 0;
    NV_D3D_GLOBAL_SAVE();
}

void nvResetContext
(
    PNVD3DTEXTURE   pTexture
)
{
    if (!pCurrentContext->dwDefaultTextureBase)
        nvAllocDefaultTexture(pCurrentContext);
    return;
}

/*
 * I'm just going to create my own objects for now....
 */
void nvD3DCreateObjects
(
    void
)
{
#ifdef HW_PAL8
    DWORD dwCount;
#endif

    if (!pDriverData->NvDevFlatDma)
        return;

    nvDmaPushOffsetMax        = pDriverData->dwDmaPushOffsetMax = pDriverData->NvDmaPusherBufferSize - NV4_PUSH_BUFFER_PAD;
    nvDmaPushBase             = pDriverData->NvDmaPusherBufferBase;
    nvFifo                    = pDriverData->NvDmaPusherPutAddress;
    nvFreeCount               = 0;
    pCurrentContext           = NULL; // no contexes created yet

    if (!nvFifo)
        return;

    /*
     * Get fifo address and the current free count.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                     (sizeSetObject + sizeCreateObject));
#endif  // CACHE_FREECOUNT

    /*
     * Make sure there aren't any dangling DMA context object.
     */
#ifdef MULTI_MON
    D3DDestroyTextureContexts();
#endif

#if 0 // BUGBUG -- Object creation needs to be moved and converted
#ifdef HW_PAL8
    /*
     * Create Indexed Image From CPU object for
     * palettized texture swizzling.                    NV 0x060
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV04_INDEXED_IMAGE_FROM_CPU);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);

    /*
     * Create an Image From CPU object for moving
     * palettes into video memory                       NV 0x061
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV04_IMAGE_FROM_CPU);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
#endif // HW_PAL8
#endif // BUGBUG

#ifndef MULTI_MON
    /*
     * Create Context Dma To Memory for notifiers.      NV 0xFFD
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeCreateObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_TO_MEMORY);
    nvglCreateObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    /*
     * Hook up DMA contexts.
     */
    while (nvFreeCount < (sizeSetObject + sizeCreateObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaToMemory));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
    nvglSetDmaToMemory(nvFifo, nvFreeCount, NV_DD_SPARE, pDriverData->NvDmaPusherSyncNotifierFlat, NvGetFlatDataSelector(), (sizeof(NvNotification) - 1));
#endif  // !MULTI_MON

    nvStartDmaBuffer (FALSE);
    if (nvTMCreate())
    {
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
        /*
         * Creation failed
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "Texture Manager Creation failed");
        return;
    }

    /*
     * Point system memory texture context at video memory for now.  This will get changed later.
     * This is just to make sure that it is pointing at memory of some sort.
     */
#ifdef  MULTI_MON
    nvStartDmaBuffer (FALSE);
#ifndef WINNT
    if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                        D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                        NV01_CONTEXT_DMA,
                        (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                         ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        (PVOID)pDriverData->BaseAddress,
                        0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#else
    if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                        D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                        NV01_CONTEXT_DMA,
                        (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                         ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        pDriverData->ppdev->pjScreen,
                        0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                            return(FALSE);
#endif // #ifdef WINNT

    pDriverData->dwTextureContextValid = TRUE;
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemory(nvFifo, nvFreeCount, NV_DD_SPARE,
                         pDriverData->BaseAddress, pDriverData->flatSelector, 0xFF);

    /*
     * Set the notify context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryContextNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryContextNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemoryContextNotify(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryContextNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryContextNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    nvglSetDmaFromMemoryContextNotify(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the ARGB_ZS surface context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
    nvglSetRenderTargetContexts(nvFifo, nvFreeCount, NV_DD_SPARE,
                                NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    /*
     * Hook up the Render Solid Rectangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);

    /*
     * Hook up Render Solid Rectangle 2.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleSurface + 2*sizeSetStartMethod + 2*sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleSurface + 2*sizeSetStartMethod + 2*sizeSetData));
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
    nvglSetNv4SolidRectangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_SET_OPERATION,1);
    nvglSetData        (nvFifo,nvFreeCount,             NV05E_SET_OPERATION_SRCCOPY);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_SET_COLOR_FORMAT,1);
    nvglSetData        (nvFifo,nvFreeCount,             NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8);

    /*
     * Hook up the Dx5 Textured Triangle.
     * System/AGP goes to context A, Video Memory goes to context B.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts + sizeSetDx5TriangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx5TriangleContexts + sizeSetDx5TriangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);

    /*
     * Both A and B must be valid.
     */
    nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetDx5TriangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);


    /*
     * Plug in the notify context.
     */
#ifdef  MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the Dx6 Multi Textured Triangle.
     * System/AGP goes to context A, Video Memory goes to context B.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts + sizeSetDx6TriangleSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts + sizeSetDx6TriangleSurface));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

    /*
     * Both A and B must be valid.
     */
    nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetDx6TriangleSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);

    /*
     * Plug in the notify context.
     */
#ifdef  MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
#else   // !MULTI_MON
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetStartMethod + sizeSetData))
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
    nvglSetData(nvFifo, nvFreeCount, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);
#endif  // !MULTI_MON

    /*
     * Hook up the swizzled surface context.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurfaceContextImage))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurfaceContextImage));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurfaceContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    /*
     * Hook up the scaled image from memory object.
     * - Set the source image context.
     * - Set the destination surface context.
     * - Set operation
     */
    while (nvFreeCount < sizeSetObject)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);

    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);

    while (nvFreeCount < sizeSetScaledImageContextSurface)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextSurface);
#ifdef DIRECTSWIZZLE
    nvglSetScaledImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
#else
    nvglSetScaledImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
#endif

    while (nvFreeCount < (sizeSetScaledImageOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetScaledImageOperation));
    nvglSetScaledImageOperation (nvFifo,nvFreeCount,NV_DD_SPARE, NV077_SET_OPERATION_SRCCOPY);

#ifdef HW_PAL8
    /*
     * Initialize Indexed Image from CPU object:
     * - set destination surface
     * - set LUT color format
     * - set index format: 8-bit (256-color palette) or 4-bit (16-color palette))
     * - set operation
     * - set point
     */
    while (nvFreeCount < sizeSetObject)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);

    // nv05 will be able to write to a swizzled surface. alas nv04 cannot
    //    while (nvFreeCount < sizeSetIndexedImageContextSurface)
    //        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageContextSurface);
    //    nvglSetIndexedImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    while (nvFreeCount < sizeSetIndexedImageContextSurface)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageContextSurface);
    nvglSetIndexedImageContextSurface(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);

    while (nvFreeCount < sizeSetIndexedImageColorFormat)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageColorFormat);
    nvglSetIndexedImageColorFormat(nvFifo,nvFreeCount,NV_DD_SPARE, NV060_SET_COLOR_FORMAT_LE_A8R8G8B8);

    // we only support 8-bit indices for now, so the default is OK here...
    //    while (nvFreeCount < sizeSetIndexedImageIndexFormat)
    //        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetIndexedImageIndexFormat);
    //    nvglSetIndexedImageIndexFormat(nvFifo,nvFreeCount,NV_DD_SPARE, NV_060_blahblahblah);

    while (nvFreeCount < (sizeSetIndexedImageOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetIndexedImageOperation));
    nvglSetIndexedImageOperation (nvFifo, nvFreeCount, NV_DD_SPARE, NV060_SET_OPERATION_SRCCOPY);

    while (nvFreeCount < (sizeSetIndexedImagePoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetIndexedImagePoint));
    nvglSetIndexedImagePoint (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0);

    /*
     * Initialize Image from CPU object for moving palettes to video memory:
     * - set destination surface
     * - set opertion
     * - set format
     * - set point
     * - set sizes
     */
    dwCount = sizeSetObject + sizeSetStartMethod + 1*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_SET_CONTEXT_SURFACE, 1);
    nvglSetData        (nvFifo, nvFreeCount, NV_DD_SURFACES_2D);  // context surface

    dwCount = sizeSetStartMethod + 2*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_SET_OPERATION, 2);
    nvglSetData        (nvFifo, nvFreeCount, NV061_SET_OPERATION_SRCCOPY);  // operation
    nvglSetData        (nvFifo, nvFreeCount, NV061_SET_COLOR_FORMAT_LE_A8R8G8B8);  // format

#endif

    /*
     * Only need to set the operation once. This is only used for clears and those are always srccopy.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetNv4SolidRectangleOperation))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetNv4SolidRectangleOperation));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
    nvglSetNv4SolidRectangleOperation(nvFifo, nvFreeCount, NV_DD_SPARE, NV05E_SET_OPERATION_SRCCOPY);

    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#endif  // CACHE_FREECOUNT
}

void nvD3DDestroyObjects
(
    void
)
{
    /*
     * Destroy Render Solid Rectangle for clearing the z-buffer and rendering surfaces.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy Render Solid Rectangle 2
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_RENDER_SOLID_RECTANGLE_2) != NVOS00_STATUS_SUCCESS)
            return(0);

#ifndef MULTI_MON
    /*
     * Destroy Context Dma To Memory for notifiers.
     */
    while (nvFreeCount < (sizeSetObject + sizeDestroyObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDestroyObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_TO_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_NOTIFY_CONTEXT_DMA_TO_MEMORY);

    /*
     * Destroy Context Dma From Memory for the source linear texture.
     * Destroy Context Dma From Memory for swizzled texture heap (PCI/AGP).
     */
    while (nvFreeCount < (sizeSetObject + (sizeDestroyObject * 3)))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDestroyObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, NV_CONTEXT_DMA_FROM_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
    nvglDestroyObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
#endif  // !MULTI_MON

    /*
     * Destroy Scaled Image From Memory object for texture swizzling.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_SCALED_IMAGE_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the swizzled surface context.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACE_SWIZZLED) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the ARGB_ZS surface context.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_CONTEXT_SURFACES_ARGB_ZS) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the DX6 Multi Textured Triangle.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_DX6_MULTI_TEXTURE_TRIANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    /*
     * Destroy the DX5 Textured Triangle.
     */
    if (NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA,
        D3D_DX5_TEXTURED_TRIANGLE) != NVOS00_STATUS_SUCCESS)
            return(0);

    nvTMDestroy();
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4index.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4INDX.C                                                         *
*   NV4 DX5 DrawOneIndexedPrimitive DDI routines.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifndef NV_FASTLOOPS
/*
 * DirectX 5.0 DrawOneIndexedPrimitive entry point.
 */
void nvDX5IndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

#ifndef WINNT
DWORD nvDrawOneIndexedPrimitive
(
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA    pdoipd
)
{
    DWORD   dwPrimCount;

#ifdef NV_NULL_DRIVER
    pdoipd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawOneIndexedPrimitive - PrimitiveType = %08lx, Index Count = %08lx", pdoipd->PrimitiveType, pdoipd->dwNumIndices);

    if (!pCurrentContext->lpLcl)
    {
        pdoipd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdoipd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }


    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdoipd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    if (pdoipd->dwNumVertices && pdoipd->dwNumIndices)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
        NV_AA_SEMANTICS_CHECK(pCurrentContext);
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Always read the current free count on entry.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * Send down the surface information if neccessary.
         */
        nvSetD3DSurfaceState(pCurrentContext);
        switch (pdoipd->PrimitiveType)
        {
            case D3DPT_TRIANGLELIST:
                dwPrimCount =  pdoipd->dwNumIndices / 3;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, LIST_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_TRIANGLESTRIP:
                dwPrimCount = pdoipd->dwNumIndices - 2;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, STRIP_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_TRIANGLEFAN:
                dwPrimCount = pdoipd->dwNumIndices - 2;
                switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPBYTE)pdoipd->lpvVertices);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
#endif
                        break;
                    case D3DFILL_WIREFRAME:
                        nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                    case D3DFILL_POINT:
                        nvIndexedPointTriangle(dwPrimCount, (LPWORD)pdoipd->lpwIndices, FAN_STRIDES, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                        break;
                }
                break;
            case D3DPT_LINELIST:
                /*
                 * Calculate the number of lines to draw.
                 */
                dwPrimCount = pdoipd->dwNumIndices / 2;
                nvIndexedLine(dwPrimCount, (LPWORD)pdoipd->lpwIndices, 2, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                break;
            case D3DPT_LINESTRIP:
                dwPrimCount = pdoipd->dwNumIndices - 1;
                nvIndexedLine(dwPrimCount, (LPWORD)pdoipd->lpwIndices, 1, (LPD3DTLVERTEX)pdoipd->lpvVertices);
                break;
            case D3DPT_POINTLIST:
                /*
                 * Indexed points kind of suck under the current scheme.
                 */


                break;
        }

        /*
         * Tell DDRAW that thee global clip state has changed.
         * Probably don't need this, but I'd rather be safe.
         */
        pDriverData->ddClipUpdate = TRUE;
    }

    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

    pdoipd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}
#endif // #ifndef WINNT
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4line.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4LINE.C                                                         *
*   The Direct 3d Line Rendereing routines.                                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4vxmac.h"

static WORD EdgeLine[6*3] =
{
    0,1,3,
    1,3,4,
    1,2,5,
    2,5,6,
    0,2,7,
    0,7,8
};

#define LINE_WIDTH  1.0f

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * Non-Indexed TLVertex Format Line Lists.
 */
void nvDrawLine
(
    DWORD           dwPrimCount,
    DWORD           dwVertexInc,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             */
            LineVerts[0] = lpVertices[0];
            LineVerts[2] = lpVertices[0];
            LineVerts[1] = lpVertices[1];
            LineVerts[3] = lpVertices[1];
            lpVertices += dwVertexInc;
            if (fabs(LineVerts[2].sx - LineVerts[3].sx) < fabs(LineVerts[2].sy - LineVerts[3].sy))
            {
                LineVerts[2].sx += LINE_WIDTH;
                LineVerts[3].sx += LINE_WIDTH;
            }
            else
            {
                LineVerts[2].sy += LINE_WIDTH;
                LineVerts[3].sy += LINE_WIDTH;
            }
            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            fnDX5Table[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

/*
 * Indexed TLVertex Format Line Lists.
 */
void nvIndexedLine
(
    DWORD           dwPrimCount,
    LPWORD          lpIndices,
    DWORD           dwIndexInc,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             */
            LineVerts[0] = lpVertices[lpIndices[0]];
            LineVerts[2] = lpVertices[lpIndices[0]];
            LineVerts[1] = lpVertices[lpIndices[1]];
            LineVerts[3] = lpVertices[lpIndices[1]];
            lpIndices += dwIndexInc;
            if (fabs(LineVerts[2].sx - LineVerts[3].sx) < fabs(LineVerts[2].sy - LineVerts[3].sy))
            {
                LineVerts[2].sx += LINE_WIDTH;
                LineVerts[3].sx += LINE_WIDTH;
            }
            else
            {
                LineVerts[2].sy += LINE_WIDTH;
                LineVerts[3].sy += LINE_WIDTH;
            }
            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            fnDX5Table[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

DWORD nvRenderLine
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    nvIndexedLine(dwPrimCount, (LPWORD)lpPrim, 2, lpVertices);
    return (DD_OK);
}
void nvDrawWireframeTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    D3DTLVERTEX LineVerts[9];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v0],(DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],dwCullValue)
                /*
                 * Each edge line is rendered as a one pixel wide rectangle.
                 */
                LineVerts[0] = lpVertices[v0];
                LineVerts[3] = lpVertices[v0];
                LineVerts[8] = lpVertices[v0];
                LineVerts[1] = lpVertices[v1];
                LineVerts[4] = lpVertices[v1];
                LineVerts[5] = lpVertices[v1];
                LineVerts[2] = lpVertices[v2];
                LineVerts[6] = lpVertices[v2];
                LineVerts[7] = lpVertices[v2];
                if (fabs(LineVerts[3].sx - LineVerts[4].sx) < fabs(LineVerts[3].sy - LineVerts[4].sy))
                {
                    LineVerts[3].sx += LINE_WIDTH;
                    LineVerts[4].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[3].sy += LINE_WIDTH;
                    LineVerts[4].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[5].sx - LineVerts[6].sx) < fabs(LineVerts[5].sy - LineVerts[6].sy))
                {
                    LineVerts[5].sx += LINE_WIDTH;
                    LineVerts[6].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[5].sy += LINE_WIDTH;
                    LineVerts[6].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[7].sx - LineVerts[8].sx) < fabs(LineVerts[7].sy - LineVerts[8].sy))
                {
                    LineVerts[7].sx += LINE_WIDTH;
                    LineVerts[8].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[7].sy += LINE_WIDTH;
                    LineVerts[8].sy += LINE_WIDTH;
                }

                /*
                 * Draw the triangle edges.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvIndexedWireframeTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    D3DTLVERTEX LineVerts[9];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v0],(DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],dwCullValue)
                /*
                 * Each edge line is rendered as a one pixel wide rectangle.
                 */
                LineVerts[0] = lpVertices[v0];
                LineVerts[3] = lpVertices[v0];
                LineVerts[8] = lpVertices[v0];
                LineVerts[1] = lpVertices[v1];
                LineVerts[4] = lpVertices[v1];
                LineVerts[5] = lpVertices[v1];
                LineVerts[2] = lpVertices[v2];
                LineVerts[6] = lpVertices[v2];
                LineVerts[7] = lpVertices[v2];
                if (fabs(LineVerts[3].sx - LineVerts[4].sx) < fabs(LineVerts[3].sy - LineVerts[4].sy))
                {
                    LineVerts[3].sx += LINE_WIDTH;
                    LineVerts[4].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[3].sy += LINE_WIDTH;
                    LineVerts[4].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[5].sx - LineVerts[6].sx) < fabs(LineVerts[5].sy - LineVerts[6].sy))
                {
                    LineVerts[5].sx += LINE_WIDTH;
                    LineVerts[6].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[5].sy += LINE_WIDTH;
                    LineVerts[6].sy += LINE_WIDTH;
                }
                if (fabs(LineVerts[7].sx - LineVerts[8].sx) < fabs(LineVerts[7].sy - LineVerts[8].sy))
                {
                    LineVerts[7].sx += LINE_WIDTH;
                    LineVerts[8].sx += LINE_WIDTH;
                }
                else
                {
                    LineVerts[7].sy += LINE_WIDTH;
                    LineVerts[8].sy += LINE_WIDTH;
                }
                /*
                 * If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                 */
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    ((  ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    /*
                     * Draw the triangle edges.
                     */
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                    fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
                }
                else
                {
                    DWORD tri;
                    WORD  triLine[6*3];

                    tri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        triLine[0*3+0]   = EdgeLine[0*3+0];
                        triLine[0*3+1]   = EdgeLine[0*3+1];
                        triLine[0*3+2]   = EdgeLine[0*3+2];
                        tri++;
                        triLine[1*3+0] = EdgeLine[1*3+0];
                        triLine[1*3+1] = EdgeLine[1*3+1];
                        triLine[1*3+2] = EdgeLine[1*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        triLine[tri*3+0] = EdgeLine[2*3+0];
                        triLine[tri*3+1] = EdgeLine[2*3+1];
                        triLine[tri*3+2] = EdgeLine[2*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[3*3+0];
                        triLine[tri*3+1] = EdgeLine[3*3+1];
                        triLine[tri*3+2] = EdgeLine[3*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        triLine[tri*3+0] = EdgeLine[4*3+0];
                        triLine[tri*3+1] = EdgeLine[4*3+1];
                        triLine[tri*3+2] = EdgeLine[4*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[5*3+0];
                        triLine[tri*3+1] = EdgeLine[5*3+1];
                        triLine[tri*3+2] = EdgeLine[5*3+2];
                        tri++;
                    }
                    if (tri)
                    {
                        /*
                         * Draw the specified triangle edges.
                         */
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(tri, triLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                        fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
#endif
                    }
                }
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#ifdef  NVD3D_DX6
/*
 * Non-Indexed Flexible Vertex Format Lines.
 */
void nvFVFDrawLine
(
    DWORD           dwPrimCount,
    DWORD           dwVertexInc,
    LPBYTE          lpVertices
)
{
    BYTE            LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr, dwLineVert3Ptr;
    DWORD           dwVert0Ptr, dwVert1Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;
    DWORD           dwVertexStride;
    DWORD           dwNextLine;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Calculate number of vertex bytes to increment after each line.
         */
        dwVertexStride  = fvfData.dwVertexStride;
        dwNextLine      = dwVertexInc * dwVertexStride;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 4 FVF line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             * Since we're contstructing new TLVERTEX structures anyway,
             * Construct full TLVERTEX structures up front from the FVF data
             * structures and then just call the TLVERTEX rendering loop.
             *
             * Get pointers to each vertex of current line.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
            lpVertices += dwNextLine;

            /*
             * Copy the vertices.
             */
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)dwVert0Ptr)[i];
                ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                dwValue = ((DWORD *)dwVert1Ptr)[i];
                ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
            }
            if (fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy))
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sx += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sy += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
            }

            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            if (!pCurrentContext->bUseDX6Class)
                fnDX5FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
            else
                fnDX6FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

/*
 * Indexed Flexible Vertex Format Lines.
 */
void nvFVFIndexedLine
(
    DWORD           dwPrimCount,
    LPWORD          lpIndices,
    DWORD           dwIndexInc,
    LPBYTE          lpVertices
)
{
    BYTE            LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr, dwLineVert3Ptr;
    DWORD           dwVert0Ptr, dwVert1Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable culling.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);

        /*
         * Draw the lines.
         */
        while (dwPrimCount--)
        {
            /*
             * Each line is rendered as a one pixel wide rectangle.
             * Since we're contstructing new TLVERTEX structures anyway,
             * Construct full TLVERTEX structures up front from the FVF data
             * structures and then just call the TLVERTEX rendering loop.
             *
             * Get pointers to each vertex of current line.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, lpIndices[0], fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, lpIndices[1], fvfData.dwVertexStride);
            lpIndices += dwIndexInc;

            /*
             * Copy the vertices.
             */
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)dwVert0Ptr)[i];
                ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                dwValue = ((DWORD *)dwVert1Ptr)[i];
                ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
            }
            if (fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert2Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy))
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sx += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)dwLineVert2Ptr)->sy += LINE_WIDTH;
                ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
            }

            /*
             * Call the low level rendering routine to draw the "line".
             */
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(2, NULL, STRIP_STRIDES, (LPBYTE)LineVerts);
#else
            if (!pCurrentContext->bUseDX6Class)
                fnDX5FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
            else
                fnDX6FlexTable[pCurrentContext->dwFunctionLookup](2, STRIP_STRIDES, (LPBYTE)LineVerts);
#endif
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

void nvFVFDrawWireframeTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    BYTE        LineVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr;
    DWORD       dwLineVert3Ptr, dwLineVert4Ptr, dwLineVert5Ptr;
    DWORD       dwLineVert6Ptr, dwLineVert7Ptr, dwLineVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert4Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert5Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert6Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert7Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert8Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            /*
             * Each edge line is rendered as a one pixel wide rectangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert8Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert7Ptr)[i] = dwValue;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy += LINE_WIDTH;
                }

                /*
                 * Draw the triangle edges.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFIndexedWireframeTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    BYTE        LineVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwLineVert0Ptr, dwLineVert1Ptr, dwLineVert2Ptr;
    DWORD       dwLineVert3Ptr, dwLineVert4Ptr, dwLineVert5Ptr;
    DWORD       dwLineVert6Ptr, dwLineVert7Ptr, dwLineVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF wireframe line vertices.
         */
        GET_FVF_POINTER(dwLineVert0Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert1Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert2Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert3Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert4Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert5Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert6Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert7Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwLineVert8Ptr, LineVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Draw all triangles as a wireframe.
         */
        while (dwPrimCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each edge line is rendered as a one pixel wide rectangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v0, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwLineVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert8Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwLineVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwLineVert2Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwLineVert7Ptr)[i] = dwValue;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert3Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert3Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert4Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert5Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert5Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert6Ptr)->sy += LINE_WIDTH;
                }
                if (fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sx - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx) < fabs(((LPD3DTLVERTEX)dwLineVert7Ptr)->sy - ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy))
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sx += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sx += LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)dwLineVert7Ptr)->sy += LINE_WIDTH;
                    ((LPD3DTLVERTEX)dwLineVert8Ptr)->sy += LINE_WIDTH;
                }

                /*
                 * If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                 */
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    ((  ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    /*
                     * Draw the triangle edges.
                     */
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(6, EdgeLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                    if (!pCurrentContext->bUseDX6Class)
                        fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
                    else
                        fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](6, EdgeLine, LIST_STRIDES, LineVerts);
#endif
                }
                else
                {
                    DWORD tri;
                    WORD  triLine[6*3];

                    tri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        triLine[0*3+0]   = EdgeLine[0*3+0];
                        triLine[0*3+1]   = EdgeLine[0*3+1];
                        triLine[0*3+2]   = EdgeLine[0*3+2];
                        tri++;
                        triLine[1*3+0] = EdgeLine[1*3+0];
                        triLine[1*3+1] = EdgeLine[1*3+1];
                        triLine[1*3+2] = EdgeLine[1*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        triLine[tri*3+0] = EdgeLine[2*3+0];
                        triLine[tri*3+1] = EdgeLine[2*3+1];
                        triLine[tri*3+2] = EdgeLine[2*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[3*3+0];
                        triLine[tri*3+1] = EdgeLine[3*3+1];
                        triLine[tri*3+2] = EdgeLine[3*3+2];
                        tri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        triLine[tri*3+0] = EdgeLine[4*3+0];
                        triLine[tri*3+1] = EdgeLine[4*3+1];
                        triLine[tri*3+2] = EdgeLine[4*3+2];
                        tri++;
                        triLine[tri*3+0] = EdgeLine[5*3+0];
                        triLine[tri*3+1] = EdgeLine[5*3+1];
                        triLine[tri*3+2] = EdgeLine[5*3+2];
                        tri++;
                    }
                    if (tri)
                    {
                        /*
                         * Draw the specified triangle edges.
                         */
#ifdef NV_FASTLOOPS
                        nvTriangleDispatch(tri, triLine, LIST_STRIDES, (LPBYTE)LineVerts);
#else
                        if (!pCurrentContext->bUseDX6Class)
                            fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
                        else
                            fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](tri, triLine, LIST_STRIDES, LineVerts);
#endif
                    }
                }
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mem.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MEM.C                                                          *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "ddrvmem.h"
#include "nvd3ddrv.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"
#include "..\x86\x86.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (global.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                }
            }
        }
    }
#ifndef WINNT  // BUGBUG - WHY NO WORKY IN NT5 BUILD?
    else if (global.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
        }
    }
#endif  // !WINNT
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (global.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                }
            }
            else
            {
                __asm
                {
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_14
                }
            }
        }
    }
#ifndef WINNT  // BUGBUG - WHY NO WORKY IN NT5 BUILD?
    else if (global.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
        }
    }
#endif  // !WINNT
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount,
    DWORD dwFlags
)
{
    /*
     * small block optimizations
     *  less than 32 bytes gets unaligned dword accesses followed by some bytes (normal memcpy)
     *  less than 128 bytes and caller does not care for alignment
     */
    if ( (dwCount < 32)
     || ((dwCount < 128) && (dwFlags == NV_MEMCOPY_DONTCARE)))
    {
        memcpy ((void*)dwDest,(void*)dwSrc,dwCount);
        return;
    }

    /*
     * align source or dest depending on flags
     */
    {
        DWORD dwNum = (dwFlags & NV_MEMCOPY_WANTSRCALIGNED)
                    ? (dwSrc  & 15)
                    : (dwDest & 15);

        if (dwCount >= 4)
        {
            /*
             * align to 4
             */
            if (dwNum & 3)
            {
                DWORD dwTemp = 4 - (dwNum & 3);
                nvMemCopy1 (dwDest,dwSrc,dwTemp);
                dwSrc   += dwTemp;
                dwDest  += dwTemp;
                dwCount -= dwTemp;
            }

            if (dwCount >= 16)
            {
                /*
                 * align to 16
                 */
                if (dwNum & 12)
                {
                    DWORD dwTemp = 16 - (dwNum & 12);
                    nvMemCopy4 (dwDest,dwSrc,dwTemp / 4);
                    dwSrc   += dwTemp;
                    dwDest  += dwTemp;
                    dwCount -= dwTemp;
                }
            }
        }
    }

    /*
     * copy remaining data
     */
    {
        DWORD dw64 = dwCount & 0xffffffc0;
        DWORD dw16 = dwCount & 0x00000030;
        DWORD dw4  = dwCount & 0x0000000c;
        DWORD dw1  = dwCount & 0x00000003;

        if (dw64)
        {
            nvMemCopy64 (dwDest,dwSrc,dw64 / 64);
            dwDest += dw64;
            dwSrc  += dw64;
        }
        if (dw16)
        {
            nvMemCopy16 (dwDest,dwSrc,dw16 / 16);
            dwDest += dw16;
            dwSrc  += dw16;
        }
        if (dw4)
        {
            nvMemCopy4 (dwDest,dwSrc,dw4 / 4);
            dwDest += dw4;
            dwSrc  += dw4;
        }
        if (dw1)
        {
            nvMemCopy1 (dwDest,dwSrc,dw1 / 1);
            dwDest += dw1;
            dwSrc  += dw1;
        }
    }
}

/*
 * nvMemTouch
 *
 * moves given data block to L1 cache if it fits - else is wastes time
 */
void nvMemTouch
(
    DWORD dwSrc,
    DWORD dwCount
)
{
    __asm
    {
        mov ecx,[dwCount]
        shr ecx,5
         jz mts

        mov ebx,[dwSrc]

    mtl: mov eax,[ebx]
         add ebx,32
         dec ecx
        jnz mtl

    mts:
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mip.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MIP.C                                                          *
*   Mipmapping routines.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 04/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

static int nvMipMapTable[64] = {
// make, copy idx for 1, copy idx for 0
    0, 0, 2, -1, // 0 = 00 00  ....
    0, 0, 1, -1, // 1 = 10 00  0...
    0, 1, 0, -1, // 2 = 01 00  .0..
    1, 0, 2, -1, // 3 = 11 00  1...   bottom
    0, 2, 3, -1, // 4 = 00 10  ..0.
    0, 2, 1, -1, // 5 = 10 10  ..1.   left
    1, 1, 3, -1, // 6 = 01 10  .1..   equal - look at error
    1, 0, 3, -1, // 7 = 11 10  2...
    0, 3, 0, -1, // 8 = 00 01  ...0
    1, 3, 1, -1, // 9 = 10 01  ...1   equal - look at error
    1, 1, 2, -1, // a = 01 01  .2..   right
    1, 3, 2, -1, // b = 11 01  ...2
    0, 2, 0, -1, // c = 00 11  ..2.   top
    1, 0, 1, -1, // d = 10 11  3...
    1, 1, 0, -1, // e = 01 11  .3..
    1, 2, 0, -1, // f = 11 11  ..3.
};

BYTE  nvAutoMipPush[256];

#ifdef NV_TEX2

extern BYTE nvTexelScratchBuffer[8192];
DWORD nvTextureCalcMipMapSize (DWORD dwLogU,DWORD dwLogV,DWORD dwMipMapLevels);
DWORD _key;

typedef void (*NVCOMBINETEXELFPTR)(DWORD);

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = nvAutoMipPush[A>>2] << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * nvTextureAutoMipMap
 *
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    PNVD3DTEXTURE pTexture
)
{
    NVCOMBINETEXELFPTR fncCombineTexels;

#ifdef DEBUG
    /*
     * sanity checks
     */
    if (!pTexture)
    {
        DPF ("nvTextureAutoMipMap: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
    {
        DPF ("nvTextureAutoMipMap: pTexture->dwSwizzleAddr[current] == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
#endif //DEBUG

    /*
     * get proper reduction function
     */
    {
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
        }
        else
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                     break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                     break;
            }
        }
    }

    /*
     * sync
     */
    nvTextureBlock (pTexture->dwRetireDate[TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags)]);

    {
        int   i,s,c;
        DWORD dwAddr[12];
        DWORD dwOffset[12];
        DWORD dwCount[12];
        DWORD dwMipMapLevel;

        DWORD dwLogU         = pTexture->dwMipMapBaseU;
        DWORD dwLogV         = pTexture->dwMipMapBaseV;
        DWORD dwMipMapLevels = pTexture->dwMipMapLevels;
        DWORD dwBPP          = (pTexture->dwBPP == 4) ? 2 : 1; // shift amount

        /*
         * setup mipmap base tables
         */
        s = TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
        c  = 1 << (dwLogU + dwLogV);
        for (i = dwMipMapLevels-1; i >= 0; i--)
        {
            dwAddr[i]   = s;
            dwOffset[i] = 0;
            dwCount[i]  = c;

            s  += c << dwBPP;
            c >>= 2;
        }

        /*
         * for all pending work
         */
        for (dwMipMapLevel = dwMipMapLevels - 1; dwMipMapLevel; )
        {
            /*
             * setup
             */
            DWORD dwMip  = dwMipMapLevel;
            DWORD dwToGo = min(dwCount[dwMip],1024);

            /*
             * read a line
             */
            nvMemCopy ((DWORD)nvTexelScratchBuffer,
                       dwAddr[dwMip] + (dwOffset[dwMip] << dwBPP),
                       dwToGo << dwBPP,
                       NV_MEMCOPY_WANTSRCALIGNED);

            /*
             * for as many mipmaps we can possibly do
             */
            for (; dwMip && (dwToGo >= 4); )
            {
                /*
                 * mipmap cached block of data
                 */
                (fncCombineTexels)(dwToGo);

                /*
                 * write dest
                 */
                nvMemCopy (dwAddr[dwMip-1] + ((dwOffset[dwMip] >> 2) << dwBPP),
                           (DWORD)nvTexelScratchBuffer,
                           (dwToGo >> 2) << dwBPP,
                           NV_MEMCOPY_WANTDESTALIGNED);

                /*
                 * advance to next mip level
                 */
                dwCount[dwMip]  -= dwToGo;
                dwOffset[dwMip] += dwToGo;
                dwToGo >>= 2;
                dwMip--;
            }

            /*
             * advance to next level
             */
            while (dwMipMapLevel && !dwCount[dwMipMapLevel])  dwMipMapLevel--;
        }
    }
}

#else

typedef void (*NVCOMBINETEXELFPTR)(DWORD,DWORD,DWORD);

DWORD _key;

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count --;
    }
}

#if 0
/*
 * y16
 */
void nvCombineTexelsY16
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD roll = 0;
    while (count)
    {
        *(WORD*)dst = *(WORD*)(src+roll);
        roll   = (roll + 2) & 6;
        src   += 8;
        dst   += 2;
        count --;
    }
}
#endif

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count --;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count --;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = nvAutoMipPush[A>>2] << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count --;
    }
/*
    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD ALPGRN = 0xff00ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) >> 2) + ((b & ALPGRN) >> 2) + ((c & ALPGRN) >> 2) + ((d & ALPGRN) >> 2)) & ALPGRN;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count --;
    }
*/
}

#if 0
/*
 * y32
 */
void nvCombineTexelsY32
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD roll = 0;

    while (count)
    {
        *(DWORD*)dst = *(DWORD*)(src+roll);
        roll   = (roll + 4) & 12;
        src   += 16;
        dst   += 4;
        count --;
    }
}
#endif

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD src,
    DWORD dst,
    DWORD count
)
{
    DWORD err = 0;
    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count --;
    }
}

/*
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwBaseAddress;
    DWORD dwLogWidth;
    DWORD dwLogHeight;
    DWORD dwBPP;
    DWORD dwMip0;
    DWORD dwMip1;
    DWORD dwCount;
    NVCOMBINETEXELFPTR fncCombineTexels;

    /*
     * Update update statistics
     */
    if ((++pTexture->dwUpdateCount) > 3)
    {
        /*
         * texture updated more than 3 times - we will disable automips
         */
        DPF_LEVEL(NVDBG_LEVEL_INFO, "AUTOMIP: Texture updated too many times - automips killed");
        pTexture->dwTextureFlags &= ~NV4_TEXTURE_AUTOMIPMAPPED;
        pTexture->dwMipMapLevels  = 1;
        /*
         * force hw reprogram
         */
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }

    DPF_LEVEL(NVDBG_LEVEL_INFO, "AUTOMIP: Auto Mipmapping texture");

    /*
     * extract basic texture info into locals
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
    {
        dwBaseAddress = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#ifdef WINNT
        dwBaseAddress += (ULONG) pDriverData->ppdev->pjScreen;
#endif // #ifdef WINNT
    }
    else
    {
        if (pDriverData->GARTLinearBase > 0)
            dwBaseAddress = pTexture->dwTexturePointer;
        else
            dwBaseAddress = GetPointerTextureHeap(pTexture->dwTextureOffset);
    }
    dwLogWidth    = pTexture->dwMipMapBaseU;
    dwLogHeight   = pTexture->dwMipMapBaseV;

    /*
     * bilinear filtering options
     */
    //if (1) (we do bilinear filtering)
    {
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->dwTextureColorFormat)
            {

                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    dwBPP = 2;
                    break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    dwBPP = 4;
                    break;
            }
        }
        else
        {
            switch (pTexture->dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                     dwBPP = 2;
                                                     break;
                case NV054_FORMAT_COLOR_LE_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                     dwBPP = 4;
                                                     break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                     dwBPP = 4;
                                                     break;
            }
        }
    }
#if 0
    else
    {
        /*
         * simple downsampling
         */
        switch (pTexture->dwTextureColorFormat)
        {
            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
            case NV054_FORMAT_COLOR_LE_R5G6B5:
            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
            case NV054_FORMAT_COLOR_LE_A4R4G4B4: fncCombineTexels = nvCombineTexelsY16;
                                                 dwBPP = 2;
                                                 break;
            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
            case NV054_FORMAT_COLOR_LE_A8R8G8B8: fncCombineTexels = nvCombineTexelsY32;
                                                 dwBPP = 4;
                                                 break;
        }
    }
#endif

    /*
     * calc mip values
     */
    dwCount = (1 << (dwLogWidth + dwLogHeight)) * dwBPP; // # bytes in first mip level
    dwMip0  = dwBaseAddress;
    dwMip1  = dwBaseAddress + dwCount;
    dwCount = (pTexture->dwMipMapSizeBytes - dwCount) / dwBPP; // # texels in other levels

    /*
     * flush hardware if needed
     *  todo - check if texture is used by HW
     */
    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();

    /*
     * compute
     */
    (*fncCombineTexels)(dwMip0,dwMip1,dwCount);
}

#endif // NV_TEX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4mini.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MINI.H                                                         *
* Hardware specific driver setup routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv4dreg.h"
#include "nvd3dcap.h"
#include "nv3ddbg.h"
#include "nvtexfmt.h"

#ifdef  NVD3D_DX6
/*
 * Define the Z-Buffer/Stencil Buffer Formats supported.
 */
#define NV_NUM_ZBUFFER_FORMATS      3
typedef struct _def_zpixel_formats
{
    DWORD           dwNumZFormats;
    DDPIXELFORMAT   NvZBufferFormats[NV_NUM_ZBUFFER_FORMATS];
} ZPIXELFORMATS;
static  ZPIXELFORMATS   NvZPixelFormats =
{
    NV_NUM_ZBUFFER_FORMATS,
    {
        /*
         * 16 bit z buffer
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            16,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0x0000FFFF,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, no stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            24,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, 8 bit stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,      // dwFlags
            0,                                      // dwFourCC (Not used)
            32,                                     // dwZBufferBitDepth - This is so brain dead.  MS needs to learn consistency.
            8,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x000000FF,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        }
    }
};
#endif  // NVD3D_DX6

/*
 * Read the current driver settings from the registry.
 */
void D3DReadRegistry
(
    void
)
{
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;
    HKEY    hKey;

    /*
     * Set the defaults first.
     */
    pDriverData->regD3DEnableBits1       = DEFAULT_FOG_TABLE
                                         | DEFAULT_ANTI_ALIAS_ENABLE
                                         | DEFAULT_USER_MIPMAPS
                                         | DEFAULT_VIDEO_TEXTURE
                                         | DEFAULT_NO_WAIT_4_VSYNC
                                         | DEFAULT_MIPMAP_DITHER_ENABLE
                                         | DEFAULT_CKCOMPATABILITY_ENABLE
                                         | DEFAULT_CONTROLTRAFFIC;
    pDriverData->regMipMapLevels         = DEFAULT_MIPMAP_LEVELS;
    pDriverData->regTexHeap              = DEFAULT_TEX_HEAP;
    pDriverData->regMinVideoTextureSize  = DEFAULT_MIN_VIDEO_TEX_SIZE;
    pDriverData->regD3DContextMax        = DEFAULT_D3D_CONTEXT_MAX;
    pDriverData->regD3DTextureMax        = DEFAULT_D3D_TEXTURE_MAX;
    pDriverData->regDmaPushBufferSizeMax = DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI;
    pDriverData->regDmaMinPushCount      = DEFAULT_DMA_MIN_PUSH_COUNT_PCI;
    pDriverData->regTexelAlignment       = DEFAULT_TEXEL_ALIGNMENT;
    pDriverData->regLODBiasAdjust        = DEFAULT_LOD_BIAS_ADJUST;
    pDriverData->regAutoMipMapMethod     = DEFAULT_AUTO_MIPMAP_METHOD;
    pDriverData->regPal8TextureConvert   = DEFAULT_PAL8_TEXTURE_CONVERT;

    pDriverData->regD3DDx6Enable         = DEFAULT_DX6_ENABLE;

    pDriverData->regPreRenderLimit       = DEFAULT_PRERENDER_LIMIT;

#if 1
    pDriverData->regZPerspectiveEnable = NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE;
    pDriverData->regZFormat            = NV054_CONTROL_Z_FORMAT_FIXED;
#else
    pDriverData->regZPerspectiveEnable = NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE;
    pDriverData->regZFormat            = NV054_CONTROL_Z_FORMAT_FLOAT;
#endif

    pDriverData->regAAMethod           = DEFAULT_AAMETHOD;
    pDriverData->regValidateZMethod    = DEFAULT_VALIDATE_Z_METHOD;

    pDriverData->regColorkeyRef        = DEFAULT_CKREF;

    pDriverData->regAGPTexCutOff       = DEFAULT_AGPTEX_CUTOFF;


#ifndef WINNT // BUGBUG need to seperate Registry routines into seperate lib

    /*
     * Next try reading the overrides from the registry.
     */
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;

    /*
     * Try and open the Direct3D Registry Key.
     */
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NV4D3D_APP_STRING, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)
        hKey = 0;

    if (hKey)
    {

        if (RegQueryValueEx(hKey,
                            NVD3D_AGPTEXTURE_CUTOFF,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regAGPTexCutOff = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_ANTI_ALIAS_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_ANTI_ALIAS_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_ANTI_ALIAS_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_AAMETHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue < REG_AAMETHOD_MIN) dwValue = REG_AAMETHOD_MIN;
            if (dwValue > REG_AAMETHOD_MAX) dwValue = REG_AAMETHOD_MAX;
            pDriverData->regAAMethod = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIPMAP_LEVELS_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regMipMapLevels = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_USER_MIPMAPS_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_USER_MIPMAPS_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_USER_MIPMAPS_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEX_HEAP_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if ((dwValue) && (dwValue >= NV_MIN_TEXTURE_HEAP_SIZE))
                pDriverData->regTexHeap = dwValue;
            else
                pDriverData->regTexHeap = NV_MIN_TEXTURE_HEAP_SIZE;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_VIDEO_TEXTURE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_VIDEO_TEXTURE_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_VIDEO_TEXTURE_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_NO_WAIT_4_VSYNC_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_NO_WAIT_4_VSYNC;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_NO_WAIT_4_VSYNC : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIN_VIDEO_TEX_SIZE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regMinVideoTextureSize = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DMA_PUSH_BUFFER_SIZE_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue)
            {
                pDriverData->regDmaPushBufferSizeMax  = dwValue;
                pDriverData->regD3DEnableBits1       |= REG_BIT1_DMA_PUSH_SIZE_OVERRIDE;

            }
            else
            {
                pDriverData->regDmaPushBufferSizeMax  = DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI;
                pDriverData->regD3DEnableBits1       &= ~REG_BIT1_DMA_PUSH_SIZE_OVERRIDE;
            }
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DMA_MIN_PUSH_COUNT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue)
            {
                pDriverData->regDmaMinPushCount  = dwValue;
                pDriverData->regD3DEnableBits1  |= REG_BIT1_DMA_PUSH_COUNT_OVERRIDE;
            }
            else
            {
                pDriverData->regDmaMinPushCount  = DEFAULT_DMA_MIN_PUSH_COUNT_PCI;
                pDriverData->regD3DEnableBits1  &= ~REG_BIT1_DMA_PUSH_COUNT_OVERRIDE;
            }

        }

        if (RegQueryValueEx(hKey,
                            NVD3D_FOG_TABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_FOG_TABLE_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_FOG_TABLE_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CONTEXT_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DContextMax = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEXTURE_MAX_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DTextureMax = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_TEXEL_ALIGNMENT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_TA_MAX)
                dwValue = DEFAULT_TEXEL_ALIGNMENT;
            pDriverData->regTexelAlignment = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_LOD_BIAS_ADJUST_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue & 0xFFFFFF00)
                dwValue = DEFAULT_LOD_BIAS_ADJUST;
            pDriverData->regLODBiasAdjust = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_AUTO_MIPMAP_METHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_AMMM_MAX)
                dwValue = DEFAULT_AUTO_MIPMAP_METHOD;
            pDriverData->regAutoMipMapMethod = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_MIPMAP_DITHER_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_MIPMAP_DITHER_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_MIPMAP_DITHER_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_PAL8_TEXTURE_CONVERT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_P8TC_MAX)
                dwValue = DEFAULT_PAL8_TEXTURE_CONVERT;
            pDriverData->regPal8TextureConvert = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_DX6_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_DX6E_MAX)
                dwValue = DEFAULT_DX6_ENABLE;
            pDriverData->regD3DDx6Enable = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CKCOMPATABILITY_ENABLE_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_CKCE_MAX)
                dwValue = DEFAULT_CKCOMPATABILITY_ENABLE;
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_CKCOMPATABILITY_ENABLE;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_CKCOMPATABILITY_ENABLE : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CONTROLTRAFFIC_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            pDriverData->regD3DEnableBits1 &= ~REG_BIT1_CONTROLTRAFFIC;
            pDriverData->regD3DEnableBits1 |= (dwValue) ? REG_BIT1_CONTROLTRAFFIC : 0;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_CKREF_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_CKREF_MAX)
                dwValue = DEFAULT_CKREF;
            pDriverData->regColorkeyRef = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_PRERENDER_LIMIT_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_PRERENDER_MAX)
                dwValue = REG_PRERENDER_MAX;
            if (dwValue < REG_PRERENDER_MIN)
                dwValue = REG_PRERENDER_MIN;
            pDriverData->regPreRenderLimit = dwValue;
        }

        if (RegQueryValueEx(hKey,
                            NVD3D_VALIDATE_Z_METHOD_STRING,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwValue > REG_VZM_MAX)
                dwValue = DEFAULT_VALIDATE_Z_METHOD;
            pDriverData->regValidateZMethod = dwValue;
        }

        RegCloseKey(hKey);
    }
#endif // #ifndef WINNT
    if (pDriverData->regMipMapLevels == REG_MML_RESTRICTED)
    {
        pDriverData->regMipMapLevels = REG_MML_ENABLE;
        pDriverData->regD3DEnableBits1 |= REG_BIT1_RESTRICT_AUTO_MIPMAPS;
    }

    return;
}
/*
 * Read the current driver settings from the registry.
 */
void D3DModifyCapabilities
(
    D3DHAL_GLOBALDRIVERDATA  *pNvGlobal
)
{
    /*
     * Set the Fog Table Caps bit based on the registry setting.
     */
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_FOGTABLE;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_FOGTABLE;
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_FOG_TABLE_ENABLE)
    {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_FOGTABLE;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_FOGTABLE;
    }

    /*
     * Set anti-aliasing capabilities based on the registry setting.
     */
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    if (pDriverData->regD3DEnableBits1 & REG_BIT1_ANTI_ALIAS_ENABLE)
    {
        /* for now we only support scene aa
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        */
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
    }

    /*
     * Remove 8bit texture format if the registry says so.
     */
    if (pDriverData->regPal8TextureConvert == REG_P8TC_NONE)

        pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_TEXTURE_FORMATS;
    else if (pDriverData->regPal8TextureConvert == REG_P8TC_Y8ONLY)
        pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_Y8ONLY_TEXTURE_FORMATS;

    /*
     * Set the DRAWPRIMITVES2 capability bit when driver is exporting DX6 capabilities.
     */
#ifdef  NVD3D_DX6
    pNvGlobal->hwCaps.dwDevCaps &= ~D3DDEVCAPS_DRAWPRIMITIVES2;
    if (pDriverData->regD3DDx6Enable)
        pNvGlobal->hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2;
#endif  // NVD3D_DX6

    return;
}
/*
 * Return D3D Driver Information.
 */
BOOL __stdcall D3DGetDriverInfo
(
    LPDDHAL_GETDRIVERINFODATA lpData
)
{
    DWORD               dwSize;

    /*
     * Is this an extended D3D Callback GUID?
     */
#ifdef  NVD3D_DX6
    /*
     * Is this an extended D3D Callback3 GUID?
     */
    if ((IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks3))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        D3DHAL_CALLBACKS3   D3DCallbacks3;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks3");
        memset(&D3DCallbacks3, 0, sizeof(D3DHAL_CALLBACKS3));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCallbacks3.dwSize = dwSize;

        /*
         * Export DX6 DrawPrimitives2 DDI callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_DRAWPRIMITIVES2;
        D3DCallbacks3.DrawPrimitives2 = DrawPrimitives2;

        /*
         * Export DX6 Mult-Texture state validation callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE;
        D3DCallbacks3.ValidateTextureStageState = nvValidateTextureStageState;

        /*
         * Export DX6 callback for clear Render target, Z-Buffer and Stencil Buffer.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_CLEAR2;
        D3DCallbacks3.Clear2 = Clear2;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
    if ((IsEqualIID(&lpData->guidInfo, &GUID_D3DParseUnknownCommandCallback))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DParseUnknownCommandCallback");

        /*
         * Get address of callback function.
         */
        fnD3DParseUnknownCommandCallback = lpData->lpvData;

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
    if ((IsEqualIID(&lpData->guidInfo, &GUID_ZPixelFormats))
     && (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_ZPixelFormats");

        /*
         * Return a pointer to the z-buffer format data.
         */
        dwSize = min(lpData->dwExpectedSize, sizeof(NvZPixelFormats));
        memcpy(lpData->lpvData, &NvZPixelFormats, dwSize);
        lpData->dwActualSize = dwSize;

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
#endif  // NVD3D_DX6

    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks2))
    {
        D3DHAL_CALLBACKS2   D3DCallbacks2;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks2");
        memset(&D3DCallbacks2, 0, sizeof(D3DHAL_CALLBACKS2));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS2));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS2);
        D3DCallbacks2.dwSize = dwSize;

        /*
         * Always export the SetRenderTarget callback.
         */
        D3DCallbacks2.dwFlags = D3DHAL2_CB32_SETRENDERTARGET;
        D3DCallbacks2.SetRenderTarget = nvSetRenderTarget;

        /*
         * Always export the D3D Clear callback.
         */
#ifndef WINNT
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_CLEAR;
        D3DCallbacks2.Clear    = Clear32;

        /*
         * Always export the DrawPrimitive callbacks.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_DRAWONEPRIMITIVE
                              |  D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE
                              |  D3DHAL2_CB32_DRAWPRIMITIVES;
        D3DCallbacks2.DrawOnePrimitive        = DrawOnePrimitive32;
        D3DCallbacks2.DrawOneIndexedPrimitive = DrawOneIndexedPrimitive32;
        D3DCallbacks2.DrawPrimitives          = DrawPrimitives32;
#endif // #ifdef WINNT

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks2, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DExtendedCaps))
    {
        D3DHAL_D3DEXTENDEDCAPS  D3DExtendedCaps;

        memset(&D3DExtendedCaps, 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        dwSize                 = min(lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        lpData->dwActualSize   = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

        /*
         * Fill in the extended capabilities.
         *
         * Set supported texture min/max dimensions.
         */
        D3DExtendedCaps.dwMinTextureWidth  = 1;
        D3DExtendedCaps.dwMaxTextureWidth  = 2048;
        D3DExtendedCaps.dwMinTextureHeight = 1;
        D3DExtendedCaps.dwMaxTextureHeight = 2048;

        /*
         * Set supported stipple min/max dimensions.
         */
//        D3DExtendedCaps.dwMinStippleWidth  = 0;
//        D3DExtendedCaps.dwMaxStippleWidth  = 0;
//        D3DExtendedCaps.dwMinStippleHeight = 0;
//        D3DExtendedCaps.dwMaxStippleHeight = 0;

#ifdef  NVD3D_DX6
        if (pDriverData->regD3DDx6Enable != REG_DX6E_DISABLE)
        {
            D3DExtendedCaps.dwMaxTextureRepeat       = NV_CAPS_MAX_TEXTURE_REPEAT;
            D3DExtendedCaps.dwMaxTextureAspectRatio  = NV_CAPS_MAX_TEXTURE_ASPECT_RATIO;
            D3DExtendedCaps.dwMaxAnisotropy          = NV_CAPS_MAX_ANISOTROPY;
            D3DExtendedCaps.dvGuardBandLeft          = NV_CAPS_GUARD_BAND_LEFT;
            D3DExtendedCaps.dvGuardBandTop           = NV_CAPS_GUARD_BAND_TOP;
            D3DExtendedCaps.dvGuardBandRight         = NV_CAPS_GUARD_BAND_RIGHT;
            D3DExtendedCaps.dvGuardBandBottom        = NV_CAPS_GUARD_BAND_BOTTOM;
            D3DExtendedCaps.dvExtentsAdjust          = NV_CAPS_EXTENTS_ADJUST;
            D3DExtendedCaps.dwStencilCaps            = D3DSTENCILCAPS_KEEP
                                                     | D3DSTENCILCAPS_ZERO
                                                     | D3DSTENCILCAPS_REPLACE
                                                     | D3DSTENCILCAPS_INCRSAT
                                                     | D3DSTENCILCAPS_DECRSAT
                                                     | D3DSTENCILCAPS_INVERT
                                                     | D3DSTENCILCAPS_INCR
                                                     | D3DSTENCILCAPS_DECR;
            D3DExtendedCaps.dwFVFCaps                = NV_CAPS_FVF_CAPS
                                                     | D3DFVFCAPS_DONOTSTRIPELEMENTS;
            D3DExtendedCaps.dwTextureOpCaps          = D3DTEXOPCAPS_DISABLE
                                                     | D3DTEXOPCAPS_SELECTARG1
                                                     | D3DTEXOPCAPS_SELECTARG2
                                                     | D3DTEXOPCAPS_MODULATE
                                                     | D3DTEXOPCAPS_MODULATE2X
                                                     | D3DTEXOPCAPS_MODULATE4X
                                                     | D3DTEXOPCAPS_ADD
                                                     | D3DTEXOPCAPS_ADDSIGNED
                                                     | D3DTEXOPCAPS_ADDSIGNED2X
                                                     | D3DTEXOPCAPS_ADDSMOOTH
                                                     | D3DTEXOPCAPS_SUBTRACT
                                                     | D3DTEXOPCAPS_BLENDDIFFUSEALPHA
                                                     | D3DTEXOPCAPS_BLENDTEXTUREALPHA
                                                     | D3DTEXOPCAPS_BLENDFACTORALPHA
                                                     | D3DTEXOPCAPS_BLENDTEXTUREALPHAPM
                                                     | D3DTEXOPCAPS_BLENDCURRENTALPHA
                                                     | D3DTEXOPCAPS_PREMODULATE
                                                     | D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR
                                                     | D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA
                                                     | D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR
                                                     | D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA;
            D3DExtendedCaps.wMaxTextureBlendStages   = NV_CAPS_MAX_TEXTURE_BLEND_STATES;
            D3DExtendedCaps.wMaxSimultaneousTextures = NV_CAPS_MAX_SIMULTANEOUS_TEXTURES;
        }
#endif  // NVD3D_DX6

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    /*
     * Return successfully.
     */
    return (TRUE);
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4point.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4POINT.C                                                        *
*   The Direct 3d Point Rendereing routines.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4vxmac.h"

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * Non-Indexed TLVertex Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvDrawPointList
(
    DWORD           dwPrimCount,
    LPD3DTLVERTEX   lpVertices
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     PointVerts[3];

    /*
     * Calculate the new hardware state if neccessary.
     */
    if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
    }

    /*
     * Disable lower level culling while drawing lines.
     */
    dwControl = pCurrentContext->ctxInnerLoop.dwControl;
    pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
    pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * Draw all points.
     */
    while (dwPrimCount--)
    {
        /*
         * Render each point as a one pixel size triangle.
         */
        PointVerts[0] = lpVertices[0];

        PointVerts[0].sx += 0.5f;
        PointVerts[0].sy += 0.5f;
        nvFloor(PointVerts[0].sx, PointVerts[0].sx);
        nvFloor(PointVerts[0].sy, PointVerts[0].sy);

        PointVerts[1] = PointVerts[0];
        PointVerts[2] = PointVerts[0];
        PointVerts[1].sx += 1.0f;
        PointVerts[2].sy += 1.0f;

#ifdef NV_FASTLOOPS
        nvTriangleDispatch(1, NULL, STRIP_STRIDES, (LPBYTE)PointVerts);
#else
        fnDX5Table[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, PointVerts);
#endif
        lpVertices++;
    }
    /*
     * Restore cull mode.
     */
    pCurrentContext->ctxInnerLoop.dwControl = dwControl;
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}

DWORD nvRenderPoint
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    nvDrawPointList(dwPrimCount, lpVertices);
    return (DD_OK);
}

void nvDrawPointTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    WORD        Point[9];
    D3DTLVERTEX PointVerts[9];
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = dwIndex1;
            v2 = dwIndex2 + (dwIndexStrides >> 24);
            v3 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],(DWORD)&lpVertices[v3],dwCullValue)
                /*
                 * Each vertex is rendered as a one pixel size triangle.
                 */
                PointVerts[0] = lpVertices[v1];
                PointVerts[0].sx += 0.5f;
                PointVerts[0].sy += 0.5f;
                nvFloor(PointVerts[0].sx, PointVerts[0].sx);
                nvFloor(PointVerts[0].sy, PointVerts[0].sy);
                PointVerts[1] = lpVertices[v1];
                PointVerts[2] = lpVertices[v1];
                PointVerts[1].sx += 1.0f;
                PointVerts[2].sy += 1.0f;


                PointVerts[3] = lpVertices[v2];
                PointVerts[3].sx += 0.5f;
                PointVerts[3].sy += 0.5f;
                nvFloor(PointVerts[3].sx, PointVerts[3].sx);
                nvFloor(PointVerts[3].sy, PointVerts[3].sy);
                PointVerts[4] = lpVertices[v2];
                PointVerts[5] = lpVertices[v2];
                PointVerts[4].sx += 1.0f;
                PointVerts[5].sy += 1.0f;

                PointVerts[6] = lpVertices[v3];
                PointVerts[6].sx += 0.5f;
                PointVerts[6].sy += 0.5f;
                nvFloor(PointVerts[6].sx, PointVerts[6].sx);
                nvFloor(PointVerts[6].sy, PointVerts[6].sy);
                PointVerts[7] = lpVertices[v3];
                PointVerts[8] = lpVertices[v3];
                PointVerts[7].sx += 1.0f;
                PointVerts[8].sy += 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvIndexedPointTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPD3DTLVERTEX lpVertices
)
{
    WORD        Point[9];
    D3DTLVERTEX PointVerts[9];
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
#ifdef  NVD3D_DX6
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
#endif  // NVD3D_DX6
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = *(WORD*) dwIndex1;
            v2 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v3 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN((DWORD)&lpVertices[v1],(DWORD)&lpVertices[v2],(DWORD)&lpVertices[v3],dwCullValue)
                /*
                 * Each vertex is rendered as a one pixel size triangle.
                 */
                PointVerts[0] = lpVertices[v1];
                PointVerts[0].sx += 0.5f;
                PointVerts[0].sy += 0.5f;
                nvFloor(PointVerts[0].sx, PointVerts[0].sx);
                nvFloor(PointVerts[0].sy, PointVerts[0].sy);
                PointVerts[1] = lpVertices[v1];
                PointVerts[2] = lpVertices[v1];
                PointVerts[1].sx += 1.0f;
                PointVerts[2].sy += 1.0f;

                PointVerts[3] = lpVertices[v2];
                PointVerts[3].sx += 0.5f;
                PointVerts[3].sy += 0.5f;
                nvFloor(PointVerts[3].sx, PointVerts[3].sx);
                nvFloor(PointVerts[3].sy, PointVerts[3].sy);
                PointVerts[4] = lpVertices[v2];
                PointVerts[5] = lpVertices[v2];
                PointVerts[4].sx += 1.0f;
                PointVerts[5].sy += 1.0f;

                PointVerts[6] = lpVertices[v3];
                PointVerts[6].sx += 0.5f;
                PointVerts[6].sy += 0.5f;
                nvFloor(PointVerts[6].sx, PointVerts[6].sx);
                nvFloor(PointVerts[6].sy, PointVerts[6].sy);
                PointVerts[7] = lpVertices[v3];
                PointVerts[8] = lpVertices[v3];
                PointVerts[7].sx += 1.0f;
                PointVerts[8].sy += 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#ifdef  NVD3D_DX6
/*
 * Non-Indexed Flexible Vertex Format Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvFVFDrawPointList
(
    DWORD           dwPrimCount,
    LPBYTE          lpVertices
)
{
    BYTE            PointVerts[3 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD           dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD           dwVert0Ptr;
    DWORD           i, dwDwordsPerVert;
    DWORD           dwControl;
    DWORD           dwOldCull;
    DWORD           dwVertexStride;

    /*
     * Calculate the new hardware state if neccessary.
     */
    if (pCurrentContext->dwStateChange)
    {
        if (pCurrentContext->bUseDX6Class)
        {
            nvSetMultiTextureHardwareState();
            if (pCurrentContext->bUseDX6Class)
                nvSetHardwareState();
        }
        else
            nvSetHardwareState();
    }

    /*
     * Disable lower level culling while drawing lines.
     */
    if (!pCurrentContext->bUseDX6Class)
    {
        dwControl = pCurrentContext->ctxInnerLoop.dwControl;
        pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    }
    else
    {
        dwControl = pCurrentContext->mtsState.dwControl0;
        pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
        pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
    }
    dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;


    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * Draw all points.
     */
    dwVertexStride  = fvfData.dwVertexStride;
    dwDwordsPerVert = fvfData.dwVertexStride >> 2;

    /*
     * Get pointers to each of the 3 FVF point vertices.
     */
    GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
    GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
    GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
    while (dwPrimCount--)
    {
        /*
         * Render each point as a one pixel size triangle.
         *
         * Get pointers to the vertex of current point.
         */
        GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        lpVertices += dwVertexStride;

        /*
         * Copy the vertex data.
         */
        for (i = 0; i < dwDwordsPerVert; i++)
        {
            DWORD   dwValue;
            dwValue = ((DWORD *)dwVert0Ptr)[i];
            ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
            ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
            ((DWORD *)dwPointVert2Ptr)[i] = dwValue;
        }

        /*
         * Adjust vertex 0.
         */
        ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
        ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
        nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
        nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);

        /*
         * Adjust vertex 1.
         */
        ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
        ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;

        /*
         * Adjust vertex 2.
         */
        ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
        ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

#ifdef NV_FASTLOOPS
        nvTriangleDispatch(1, NULL, STRIP_STRIDES, (LPBYTE)PointVerts);
#else
        if (!pCurrentContext->bUseDX6Class)
            fnDX5FlexTable[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, (LPBYTE)PointVerts);
        else
            fnDX6FlexTable[pCurrentContext->dwFunctionLookup](1, STRIP_STRIDES, (LPBYTE)PointVerts);
#endif
    }
    /*
     * Restore cull mode.
     */
    if (!pCurrentContext->bUseDX6Class)
        pCurrentContext->ctxInnerLoop.dwControl = dwControl;
    else
        pCurrentContext->mtsState.dwControl0 = dwControl;
    pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    /*
     * Force next render call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFDrawPointTriangle
(
    DWORD         dwPrimCount,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    WORD        Point[9];
    BYTE        PointVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD       dwPointVert3Ptr, dwPointVert4Ptr, dwPointVert5Ptr;
    DWORD       dwPointVert6Ptr, dwPointVert7Ptr, dwPointVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF point triangle vertices.
         */
        GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert3Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert4Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert5Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert6Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert7Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert8Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = dwIndex1;
            v2 = dwIndex2 + (dwIndexStrides >> 24);
            v3 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each vertex is rendered as a one pixel size triangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v3, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert2Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwPointVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwPointVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert7Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert8Ptr)[i] = dwValue;
                }

                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy + 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvFVFIndexedPointTriangle
(
    DWORD         dwPrimCount,
    LPWORD        lpIndices,
    DWORD         dwStrides,
    LPBYTE        lpVertices
)
{
    WORD        Point[9];
    BYTE        PointVerts[9 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    DWORD       dwPointVert0Ptr, dwPointVert1Ptr, dwPointVert2Ptr;
    DWORD       dwPointVert3Ptr, dwPointVert4Ptr, dwPointVert5Ptr;
    DWORD       dwPointVert6Ptr, dwPointVert7Ptr, dwPointVert8Ptr;
    DWORD       dwVert0Ptr, dwVert1Ptr, dwVert2Ptr;
    DWORD       i, dwDwordsPerVert;
    DWORD       v1,v2,v3;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    if (dwPrimCount)
    {
        /*
         * Calculate the new hardware state if neccessary.
         */
        if (pCurrentContext->dwStateChange)
        {
            if (pCurrentContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState();
                if (pCurrentContext->bUseDX6Class)
                    nvSetHardwareState();
            }
            else
                nvSetHardwareState();
        }

        /*
         * Disable lower level culling while drawing lines.
         */
        if (!pCurrentContext->bUseDX6Class)
        {
            dwControl = pCurrentContext->ctxInnerLoop.dwControl;
            pCurrentContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pCurrentContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pCurrentContext->mtsState.dwControl0;
            pCurrentContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pCurrentContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        /*
         * Calculate the culling masks.
         */
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        /*
         * Force first call to be to the triangle state setup routine.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)lpIndices;
        dwIndex2       = (DWORD)lpIndices + 2;
        dwIndexStrides = dwStrides * 2;
        dwDwordsPerVert = fvfData.dwVertexStride >> 2;

        /*
         * Get pointers to each of the 9 FVF point triangle vertices.
         */
        GET_FVF_POINTER(dwPointVert0Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 0, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert1Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 1, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert2Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 2, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert3Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 3, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert4Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 4, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert5Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 5, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert6Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 6, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert7Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 7, fvfData.dwVertexStride);
        GET_FVF_POINTER(dwPointVert8Ptr, PointVerts, fvfData.dwXYZMask, fvfData.dwXYZOffset, 8, fvfData.dwVertexStride);

        /*
         * Make these a static array someday to improve performance.
         */
        Point[0] = 0;
        Point[1] = 1;
        Point[2] = 2;
        Point[3] = 3;
        Point[4] = 4;
        Point[5] = 5;
        Point[6] = 6;
        Point[7] = 7;
        Point[8] = 8;
        /*
         * Draw all triangles as vertex points.
         */
        while (dwPrimCount--)
        {
            v1 = *(WORD*) dwIndex1;
            v2 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v3 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            /*
             * Move on to the next triangle.
             */
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            /*
             * Each vertex is rendered as a one pixel size triangle.
             *
             * Get pointers to each vertex of current triangle.
             */
            GET_FVF_POINTER(dwVert0Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v1, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert1Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v2, fvfData.dwVertexStride);
            GET_FVF_POINTER(dwVert2Ptr, lpVertices, fvfData.dwXYZMask, fvfData.dwXYZOffset, v3, fvfData.dwVertexStride);

            /*
             * Since culling needs to be disabled to insure that the triangle edges get drawn properly,
             * back face culling of the triangle needs to be performed up front by software.
             */
            IF_NOT_CULLED_BEGIN(dwVert0Ptr,dwVert1Ptr,dwVert2Ptr,dwCullValue)
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD   dwValue;
                    dwValue = ((DWORD *)dwVert0Ptr)[i];
                    ((DWORD *)dwPointVert0Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert1Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert2Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert1Ptr)[i];
                    ((DWORD *)dwPointVert3Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert4Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert5Ptr)[i] = dwValue;

                    dwValue = ((DWORD *)dwVert2Ptr)[i];
                    ((DWORD *)dwPointVert6Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert7Ptr)[i] = dwValue;
                    ((DWORD *)dwPointVert8Ptr)[i] = dwValue;
                }
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert0Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert1Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert2Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert0Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert3Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert4Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert5Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert3Ptr)->sy + 1.0f;

                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx += 0.5f;
                ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy += 0.5f;
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sx, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx);
                nvFloor(((LPD3DTLVERTEX)dwPointVert6Ptr)->sy, ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy);
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx + 1.0f;
                ((LPD3DTLVERTEX)dwPointVert7Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sx = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sx;
                ((LPD3DTLVERTEX)dwPointVert8Ptr)->sy = ((LPD3DTLVERTEX)dwPointVert6Ptr)->sy + 1.0f;

                /*
                 * Draw the triangle vertices.
                 */
#ifdef NV_FASTLOOPS
                nvTriangleDispatch(3, Point, LIST_STRIDES, (LPBYTE)PointVerts);
#else
                if (!pCurrentContext->bUseDX6Class)
                    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
                else
                    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](3, Point, LIST_STRIDES, PointVerts);
#endif
            IF_NOT_CULLED_END
        }
        /*
         * Restore the culling mode.
         */
        if (!pCurrentContext->bUseDX6Class)
            pCurrentContext->ctxInnerLoop.dwControl = dwControl;
        else
            pCurrentContext->mtsState.dwControl0 = dwControl;

        pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    /*
     * Force first call to be to the triangle state setup routine.
     */
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4loop.c ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4LOOP.C                                                         *
*   NV4 Inner loop include file. This file is referenced in nv4vx.c         *
*   ...it is also one mother of an #ifdef hell...                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/23/98 - created                      *
*                                                                           *
\***************************************************************************/

// macro        desc
// PROC_        Name of inner loop as string
// PROC         Name of inner loop
// VERTEX       Name of vertex macro
// DX6          defined for DX6 class triangles
// VXSIZE       size of a vertex in push buffer
// FOG          when defined it is either 1-ExpFog, 2-Exp2Fog or 3-LinearFog
// INDEXED      defined for indexed primitives
// FVF          defined for Flex vertices
// ANTIALIAS    defined when we want to capture geometry for antialiasing

//#define DPF_ON_ENTRY        // print entry point name
//#define BREAK_ON_ENTRY      // int3 on entry

/*
 * switches
 */

/*
 * constants & general macros
 */
#ifdef DX6
#define DRAW        nvglDx6TriangleDrawPrimitive
#define COUNT1      ((DWORD)((sizeDx6TriangleTLVertex * 1) + sizeDx6TriangleDrawPrimitive))
#define COUNT2      ((DWORD)((sizeDx6TriangleTLVertex * 2) + sizeDx6TriangleDrawPrimitive))
#define COUNT3      ((DWORD)((sizeDx6TriangleTLVertex * 3) + sizeDx6TriangleDrawPrimitive))
#define COUNT4      ((DWORD)((sizeDx6TriangleTLVertex * 4) + sizeDx6TriangleDrawPrimitive))
#define VC_MASK     7
#define VC_ADD      3
#else //!DX6
#define DRAW        nvglDx5TriangleDrawPrimitive
#define COUNT1      ((DWORD)((sizeDx5TriangleTLVertex * 1) + sizeDx5TriangleDrawPrimitive))
#define COUNT2      ((DWORD)((sizeDx5TriangleTLVertex * 2) + sizeDx5TriangleDrawPrimitive))
#define COUNT3      ((DWORD)((sizeDx5TriangleTLVertex * 3) + sizeDx5TriangleDrawPrimitive))
#define COUNT4      ((DWORD)((sizeDx5TriangleTLVertex * 4) + sizeDx5TriangleDrawPrimitive))
#define VC_MASK     15
#define VC_ADD      7
#endif //!DX6

#ifdef FVF
#define IF_FVF(x,y)  (x)
#define EMIT_VX(x,y) VERTEX (nvFifo, nvFreeCount, NV_DD_SPARE, (y), (x), fvfData, pTriangleState->dwUVOffset)
#else //!FVF
#define IF_FVF(x,y)  (y)
#define EMIT_VX(x,y) VERTEX (nvFifo, nvFreeCount, NV_DD_SPARE, (y), (x))
#endif //!FVF

/*
 * cull macro
 */
#define IF_NOT_CULLED_BEGIN(v0,v1,v2,cv) {             \
    DWORD _sx0  = v0 + 0;                              \
    DWORD _sy0  = v0 + 4;                              \
    DWORD _sx1  = v1 + 0;                              \
    DWORD _sy1  = v1 + 4;                              \
    DWORD _sx2  = v2 + 0;                              \
    DWORD _sy2  = v2 + 4;                              \
    float _dx10 = *(float*)_sx1 - *(float*)_sx0;       \
    float _dy10 = *(float*)_sy1 - *(float*)_sy0;       \
    float _dx20 = *(float*)_sx2 - *(float*)_sx0;       \
    float _dy20 = *(float*)_sy2 - *(float*)_sy0;       \
           cv   = _dx10*_dy20  - _dx20*_dy10;          \
    if (((*(DWORD*)&cv) ^ dwCullMask1) & dwCullMask2) {
#define IF_NOT_CULLED_END } }

/*
 * statistics macro
 */
#ifdef NV_STATS
#define UPDATE_STATS                                                    \
{                                                                       \
    extern DWORD dwPrimCount;                                           \
    extern DWORD dwPrimLegacyCount;                                     \
    extern DWORD dwPrimListCount;                                       \
    extern DWORD dwPrimStripCount;                                      \
    extern DWORD dwPrimFanCount;                                        \
                                                                        \
    dwPrimCount += nPrimCount;                                          \
    switch (dwStrides)                                                  \
    {                                                                   \
        case LEGACY_STRIDES: dwPrimLegacyCount += nPrimCount;           \
                             break;                                     \
        case LIST_STRIDES:   dwPrimListCount   += nPrimCount;           \
                             break;                                     \
        case STRIP_STRIDES:  dwPrimStripCount  += nPrimCount;           \
                             break;                                     \
        case FAN_STRIDES:    dwPrimFanCount    += nPrimCount;           \
                             break;                                     \
    }                                                                   \
}
#else
#define UPDATE_STATS
#endif


//////////////////////////////////////////////////////////////////////////////
// Entry Point
#ifdef INDEXED
#ifdef FVF
void PROC (DWORD nPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE        pVertices ) {
#else //!FVF
void PROC (DWORD nPrimCount,LPWORD pIndices,DWORD dwStrides,LPD3DTLVERTEX pVertices) {
#endif //!FVF
#else //!INDEXED
#ifdef FVF
void PROC ( WORD nPrimCount,                DWORD dwStrides,LPBYTE        pVertices ) {
#else //!FVF
void PROC ( WORD nPrimCount,                DWORD dwStrides,LPD3DTLVERTEX pVertices) {
#endif //!FVF
#endif //!INDEXED

#ifdef ANTIALIAS
    UPDATE_STATS
#ifdef INDEXED
    nvAACapturePrimitive (nPrimCount,pIndices,dwStrides,(LPBYTE)pVertices);
    //aatodo - render edge
#else //!INDEXED
    nvAACapturePrimitive (nPrimCount,NULL    ,dwStrides,(LPBYTE)pVertices);
    //aatodo - render edge
#endif
#else //!ANTIALIAS

//////////////////////////////////////////////////////////////////////////////
// Common code
    DWORD v0,v1,v2;         // vertices
    DWORD dwCullMask1;
    DWORD dwCullMask2;
    float dwCullValue;

#ifdef FVF
    DWORD dwVertexStride = fvfData.dwVertexStride;
    PNVD3DMULTITEXTURESTATE pTriangleState
        = (PNVD3DMULTITEXTURESTATE)&pCurrentContext->mtsState;
#endif //FVF

#ifdef  SPEC_HACK
#ifndef DX6
    DWORD   dwSpec0, dwSpec1, dwSpec2;
    DWORD   dwNoSpecCount     = pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount;
    DWORD   dwSpecularState   = pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE];
    DWORD   dwSpecularCurrent = pCurrentContext->ctxInnerLoop.dwCurrentSpecularState;
    DWORD   dwBlend           = pCurrentContext->ctxInnerLoop.dwCurrentBlend;
#endif  // !DX6
#endif  // SPEC_HACK

    UPDATE_STATS

#ifdef DPF_ON_ENTRY
    DPF (PROC_);
    DPF ("  dwStrides = %08x",dwStrides);
#endif
#ifdef BREAK_ON_ENTRY
    __asm int 3;
#endif

    dwCullMask1 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    dwCullMask2 = (pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

    switch (dwStrides)
    {
//////////////////////////////////////////////////////////////////////////////
// List
//////////////////////////////////////////////////////////////////////////////
        case LIST_STRIDES:
        case LEGACY_STRIDES:
        {
#ifdef INDEXED
            DWORD dwVertexSNBits = (dwVertexSN++) << 16;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v2 = ((DWORD)pVertices) + 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#ifdef FVF
            dwVertexStride *= 3;
#endif //!FVF
#endif //!INDEXED

            dwStrides &= 255; // strip off uninteresting strip info

            while (nPrimCount) 
            {
#ifdef INDEXED
                DWORD i0,i1,i2;
                /*
                 * fetch indices
                 */
                i0  = ((DWORD*)pIndices)[0];
                i1  = i0 >> 16;
                i0 &= 0xffff;
                i2  = (( WORD*)pIndices)[2];
#endif //INDEXED

#ifdef INDEXED
                /*
                 * fetch vertices
                 */
                v0 = ((DWORD)pVertices) + i0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                v1 = ((DWORD)pVertices) + i1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                v2 = ((DWORD)pVertices) + i2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //INDEXED

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
#ifdef INDEXED
                    DWORD x0,x1,x2,tmp;
#endif //INDEXED

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                    dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
                    dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
                    dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                    dwSpec0 = (*(DWORD*)(v0 + 20));
                    dwSpec1 = (*(DWORD*)(v1 + 20));
                    dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    while (nvFreeCount < COUNT3) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT3);
#ifdef INDEXED
                // vertex 0
                    tmp = i0 | dwVertexSNBits;
                    x0  = i0 & VC_MASK;
                    if (tmp != dwVertexCache[x0]) { // cache miss
                        dwVertexCache[x0] = tmp;
                        EMIT_VX (v0,x0);
                    }
                // vertex 1
                    tmp = i1 | dwVertexSNBits;
                    x1  = i1 & VC_MASK;
                    while (x1 == x0) x1 = (x1+VC_ADD) & VC_MASK;
                    if (tmp != dwVertexCache[x1]) { // cache miss
                        dwVertexCache[x1] = tmp;
                        EMIT_VX (v1,x1);
                    }
                // vertex 2
                    tmp = i2 | dwVertexSNBits;
                    x2  = i2 & VC_MASK;
                    while ((x2 == x1)||(x2 == x0)) x2 = (x2+VC_ADD) & VC_MASK;
                    if (tmp != dwVertexCache[x2]) { // cache miss
                        dwVertexCache[x2] = tmp;
                        EMIT_VX (v2,x2);
                    }
                    DRAW    (nvFifo, nvFreeCount, NV_DD_SPARE, 0, ((x2<<8)|(x1<<4)|x0));
#else //!INDEXED
                    EMIT_VX (v0,0);
                    EMIT_VX (v1,1);
                    EMIT_VX (v2,2);
                    DRAW    (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0x210);
#endif //!INDEXED
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                nPrimCount--;

#ifdef INDEXED
                pIndices += dwStrides;
#else //!INDEXED
                v0 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
                v1 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
                v2 += IF_FVF(dwVertexStride,3 * sizeof(D3DTLVERTEX));
#endif //!INDEXED
                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }
            break;
        }
//////////////////////////////////////////////////////////////////////////////
// Strip
//////////////////////////////////////////////////////////////////////////////
        case STRIP_STRIDES:
        {
            static DWORD table[6] = { 0x210,0x201,0x102,0x120,0x021,0x012 };
            DWORD funky  = 0;
            DWORD launch = 0x210;
            DWORD place  = 0x808182;

#ifdef INDEXED
            v0 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + ((WORD*)pIndices)[1] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            pIndices += 2;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            ((DWORD)pVertices) += 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
            dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
            dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
            dwSpec0 = (*(DWORD*)(v0 + 20));
            dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

            while (nPrimCount) 
            {
#ifdef INDEXED
                v2 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                pIndices++;
#else //!INDEXED
                v2 = ((DWORD)pVertices);
                ((DWORD)pVertices) += IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                    dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                    dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
                    DWORD p;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    if ((place & 0x800000) == 0x800000) {
                        p      = (place >> 16) & 127;
                        place &= ~0x800000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v0,p);
                    }
                    if ((place & 0x008000) == 0x008000) {
                        p      = (place >> 8) & 127;
                        place &= ~0x008000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v1,p);
                    }
                    p      = place & 127;
                    place &= ~0x000080;
                    while (nvFreeCount < COUNT1) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                    EMIT_VX (v2,p);
                    DRAW (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                v0      = v1; 
                v1      = v2;
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                dwSpec0 = dwSpec1;
                dwSpec1 = dwSpec2;
#endif  // !DX6
#endif  // SPEC_HACK
                {
                    DWORD x = place & 0x7f;
                    if (x == 2) x = 0x80; else x+=0x81;
                    place = (place<<8) | x;
                }
                funky        = (funky == 5) ? 0 : (funky + 1);
                launch       = table[funky];
                dwCullMask1 ^= 0x80000000;
                nPrimCount--;

                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }
            break;
        }
//////////////////////////////////////////////////////////////////////////////
// Fan
//////////////////////////////////////////////////////////////////////////////
        case FAN_STRIDES:
        {
            DWORD place  = 0x8182;
            DWORD launch = 0x210;

#ifdef INDEXED
            v0 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + ((WORD*)pIndices)[1] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            pIndices += 2;
#else //!INDEXED
            /*
             * setup vertices (non-indexed)
             */
            v0 = ((DWORD)pVertices) + 0 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            v1 = ((DWORD)pVertices) + 1 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
            ((DWORD)pVertices) += 2 * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
            dwSpec0 = *(DWORD*)((v0 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
            dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
            dwSpec0 = (*(DWORD*)(v0 + 20));
            dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

            while (nvFreeCount < COUNT1)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
            EMIT_VX (v0,0);

            while (nPrimCount) 
            {
#ifdef INDEXED
                v2 = ((DWORD)pVertices) + ((WORD*)pIndices)[0] * IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
                pIndices++;
#else //!INDEXED
                v2 = ((DWORD)pVertices);
                ((DWORD)pVertices) += IF_FVF(dwVertexStride,sizeof(D3DTLVERTEX));
#endif //!INDEXED
#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                dwSpec2 = *(DWORD*)((v2 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                dwSpec2 = (*(DWORD*)(v2 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK

                /*
                 * cull triangle
                 */
                IF_NOT_CULLED_BEGIN(v0,v1,v2,dwCullValue)
                    DWORD p;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
                    SPEC_CHECK(dwSpecularState, dwSpecularCurrent, dwSpec0, dwSpec1, dwSpec2, dwNoSpecCount, dwBlend);
#endif  // !DX6
#endif  // SPEC_HACK

                    /*
                     * Send tri
                     */
                    if ((place & 0x008000) == 0x008000) {
                        p      = (place >> 8) & 127;
                        place &= ~0x008000;
                        while (nvFreeCount < COUNT1) 
                            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                        EMIT_VX (v1,p);
                    }
                    p      = place & 127;
                    place &= ~0x000080;
                    while (nvFreeCount < COUNT1) 
                        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, COUNT1);
                    EMIT_VX (v2,p);
                    DRAW (nvFifo, nvFreeCount, NV_DD_SPARE, 0, launch);
                IF_NOT_CULLED_END

                /*
                 * next triangle
                 */
                v1 ^= v2;
                v2 ^= v1;
                v1 ^= v2;

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
#ifdef  FVF
                dwSpec1 = *(DWORD*)((v1 & fvfData.dwSpecularMask) + fvfData.dwSpecularOffset);
#else   !FVF
                dwSpec1 = (*(DWORD*)(v1 + 20));
#endif  // !FVF
#endif  // !DX6
#endif  // SPEC_HACK
                {
                    DWORD x = place & 0x7f;
                    x      ^= 0x81 ^ 2; // toggle 1 <-> 2 & or 0x80
                    place   = (place<<8) | x;
                }
                launch ^= 0x210 ^ 0x120;
                nPrimCount--;

                /*
                 * The following code is only enabled for the DEBUG driver build.
                 * Flush each triangle.
                 */            
                dbgFlushTriangle(pCurrentContext);
            }

            break;
        }
    }

#ifdef  SPEC_HACK   // check for contributing specular highlight
#ifndef DX6         // when using the DX5 class only.
     pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = dwNoSpecCount;
     pCurrentContext->ctxInnerLoop.dwCurrentSpecularState    = dwSpecularCurrent;
     pCurrentContext->ctxInnerLoop.dwCurrentBlend            = dwBlend;
#endif  // !DX6
#endif  // SPEC_HACK

#endif //!ANTIALIAS
}

#undef IF_NOT_CULLED_BEGIN
#undef IF_NOT_CULLED_END
#undef VC_ADD
#undef VC_MASK
#undef IF_FVF
#undef EMIT_VX
#undef COUNT4
#undef COUNT3
#undef COUNT2
#undef COUNT1
#undef DRAW
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4multi.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4MULTI.C                                                        *
*   NV4 DX6 Multi-texture routines.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/24/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef  NVD3D_DX6

#ifndef NV_FASTLOOPS
void nvDX6FlexTriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5FlexTriangleSetup(wPrimCount, dwStrides, lpVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);
    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX6FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}

void nvDX6FlexIndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (pCurrentContext->dwStateChange)
    {
        nvSetMultiTextureHardwareState();
        if (!pCurrentContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5FlexIndexedTriangleSetup(dwPrimCount, lpwIndices, dwStrides, lpVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pCurrentContext);
    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}

#endif //!NV_FASTLOOPS

#endif  // NVD3D_DX6

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prim.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PRIM.C                                                         *
*   NV4 DX5 DrawPrimitives and DrawOnePrimitive DDI routines.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifndef NV_FASTLOOPS
void nvDX5TriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

#ifndef WINNT
void nvDrawPrimitive
(
    WORD            wPrimType,
    WORD            wNumVertices,
    LPBYTE          lpVertexData

)
{
    WORD            wPrimCount;
    LPD3DTLVERTEX   lpVertices;

    lpVertices = (LPD3DTLVERTEX)lpVertexData;
    switch (wPrimType)
    {
        case D3DPT_TRIANGLELIST:
            wPrimCount = wNumVertices / 3;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, LIST_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, LIST_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, LIST_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawPointTriangle(wPrimCount, LIST_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            wPrimCount = wNumVertices - 2;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, STRIP_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, STRIP_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, STRIP_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawWireframeTriangle(wPrimCount, STRIP_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_TRIANGLEFAN:
            if ((wPrimCount = wNumVertices - 2) == 0)
                break;
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
            {
                case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
                    nvTriangleDispatch(wPrimCount, NULL, FAN_STRIDES, (LPBYTE)lpVertices);
#else
                    fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, FAN_STRIDES, lpVertices);
#endif
                    break;
                case D3DFILL_WIREFRAME:
                    nvDrawWireframeTriangle(wPrimCount, FAN_STRIDES, lpVertices);
                    break;
                case D3DFILL_POINT:
                    nvDrawWireframeTriangle(wPrimCount, FAN_STRIDES, lpVertices);
                    break;
            }
            break;
        case D3DPT_LINELIST:
            wPrimCount = wNumVertices / 2;
            nvDrawLine((DWORD)wPrimCount, 2, lpVertices);
            break;
        case D3DPT_LINESTRIP:
            wPrimCount = wNumVertices - 1;
            nvDrawLine((DWORD)wPrimCount, 1, lpVertices);
            break;
        case D3DPT_POINTLIST:
//            nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
            break;
    }
    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    return;
}

/*
 * DirectX 5.0 DrawOnePrimitive entry point.
 */
DWORD nvDrawOnePrimitive
(
    LPD3DHAL_DRAWONEPRIMITIVEDATA   pdopd
)
{
#ifdef NV_NULL_DRIVER
    pdopd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawOnePrimitive - PrimitiveType = %08lx, Vertex Count = %08lx", pdopd->PrimitiveType, pdopd->dwNumVertices);

    if (!pCurrentContext->lpLcl)
    {
        pdopd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdopd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdopd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Just pass off this call to the DrawPrimitive helper routine.
     */
    if (pdopd->dwNumVertices)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
        NV_AA_SEMANTICS_CHECK(pCurrentContext);
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);

        /*
         * Always read the current free count on entry.
         */
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

        /*
         * If the surface has changed since the last render call, switch it now.
         */
        nvSetD3DSurfaceState(pCurrentContext);

        nvDrawPrimitive((WORD)pdopd->PrimitiveType,
                        (WORD)pdopd->dwNumVertices,
                        (LPBYTE)pdopd->lpvVertices);
        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    }

    /*
     * Return successfully.
     */
    pdopd->ddrval = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * DirectX 5.0 DrawPrimitives entry point.
 */
DWORD nvDrawPrimitives
(
    LPD3DHAL_DRAWPRIMITIVESDATA pdpd
)
{
    WORD                        wStateCount;
    LPBYTE                      lpData;
    LPDWORD                     lpStateChanges;
    LPD3DHAL_DRAWPRIMCOUNTS     lpDrawPrimCounts;

#ifdef NV_NULL_DRIVER
    pdpd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawPrimitives - hContext = %08lx", pdpd->dwhContext);

    /*
     * assert valid
     */
    if (!pCurrentContext->lpLcl)
    {
        pdpd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (!pDriverData->NvDevFlatDma)
    {
        pdpd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pdpd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
    if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

    /*
     * If the surface has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * Get the pointer to the primitive data.
     */
    lpData            = (LPBYTE)pdpd->lpvData;
    lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;

    /*
     * Step through callback data until there are no more vertices left
     * in the structure.
     */
    do
    {
        /*
         * Get the next draw primitive data structure.
         */
        lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;
        lpData           += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        if (!lpDrawPrimCounts)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }

        /*
         * Get the pointer to the first set of state change data.
         * If the wNumStateChanges value is 0, then there are no
         * state changes for this set of vertices.  This can happen
         * at any time, including for the first set of vertices, which
         * means that the current state should be used, or even for
         * two or more blocks of vertices in a row.
         */
        lpStateChanges    = (LPDWORD)lpData;
        if (!lpStateChanges)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }
        if (wStateCount = lpDrawPrimCounts->wNumStateChanges)
        {
            while (wStateCount--)
            {
                /*
                 * Process the state changes for the next set of vertices.
                 */
                nvSetContextState(lpStateChanges[0], lpStateChanges[1], &pdpd->ddrval);
                if (pdpd->ddrval != DD_OK)
                    return (DDHAL_DRIVER_HANDLED);
                lpStateChanges += 2;
            }
            /*
             * If the state has changed force a hardware state load.
             */
            if (pCurrentContext->dwStateChange)
                NV_FORCE_TRI_SETUP(pCurrentContext);
        }

        /*
         * Move the pointer to the first block of vertices to be rendered.
         */
        lpData += ((lpDrawPrimCounts->wNumStateChanges * sizeof(DWORD) * 2) + 31);
        lpData = (LPBYTE)((DWORD)lpData & ~31);

        /*
         * Render the vertices.
         */
        if (lpDrawPrimCounts->wNumVertices)
        {
            WORD wPrimitiveType = lpDrawPrimCounts->wPrimitiveType;

            nvDrawPrimitive(wPrimitiveType,
                            lpDrawPrimCounts->wNumVertices,
                            lpData);

            lpData += (lpDrawPrimCounts->wNumVertices * sizeof(D3DTLVERTEX));
        }
    } while (lpDrawPrimCounts->wNumVertices);

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    pdpd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4rendr.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4RENDR.C                                                        *
*   HW Specivic D3D Rendereing routines.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include <conio.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"

#define PUSH_THRESHOLD (DWORD)(1024)

/*
 * DMA kickoff routines.
 */
#define sizeDmaBufferPad 0

DWORD   dbgLastGetAddr;

DWORD __stdcall nvGetDmaFreeCount
(
    long sizeRequired
)
{
    Nv4ControlDma *dmaChannel         = (Nv4ControlDma *)pDriverData->NvDevFlatDma;
    DWORD          getOffset;
    DWORD          putOffset;
    long           freeCount;
    BOOL           bWait;

    /*
     * aa capture override - allocate more space
     */
    if ((pCurrentContext)
     && (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
    {
        PNVAACONTEXT pCtx = pCurrentContext->pAAContext;
        DWORD        dif  = ((sizeRequired << 2) + 16383) & ~16383;
        pCtx->dwCapIndex  = nvFifo - pCtx->dwCapAddr;
        pCtx->dwCapSize  += dif;
        pCtx->dwCapAddr   = (DWORD)ReallocIPM((void*)pCtx->dwCapAddr,pCtx->dwCapSize);
        nvFifo            = pCtx->dwCapAddr + pCtx->dwCapIndex;
        return (pCtx->dwCapSize - pCtx->dwCapIndex) >> 2;
    }

#ifdef NV_PROFILE
    /*
     * FreeCount Wait Log
     */
    NVP_START(NVP_T_FREECOUNT);
#endif

    bWait = FALSE;
    for (;;) {
        getOffset   = (DWORD)(volatile)dmaChannel->Get;
#ifdef DEBUG
        if (getOffset > nvDmaPushOffsetMax)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid Get Offset!!");
            dbgD3DError();
        }
        dbgLastGetAddr = getOffset;
#endif
        putOffset = (DWORD)nvFifo - (DWORD)nvDmaPushBase;

        if (putOffset >= getOffset)
        /*
         * |       G......P     |
         */
        {
            freeCount = (long)(nvDmaPushOffsetMax - putOffset) >> 2;
        // deal with wrapping around
            if ((freeCount <= sizeRequired) && getOffset)
            {
                *((volatile DWORD *)nvFifo) = (0x20000000 | (0));
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

#ifdef NV_NULL_HW_DRIVER
                if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | 0;
#endif //NV_NULL_HW_DRIVER

                *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = 0;

                /*
                 * Multiple push buffer sync up.
                 */
                WAIT_FOR_VSYNC(pCurrentContext);
                NV_DD_DMA_PUSHER_SYNC();

                /*
                 * push buffer disassembler
                 */
#ifdef NV_DISASM
                {
                    extern HANDLE nvPusherFile;
                    extern BOOL   nvPusherDisassemblerEnable;
                    if (nvPusherFile && nvPusherDisassemblerEnable)
                    {
                        DWORD dw;
                        WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr+4,&dw,0);
                        FlushFileBuffers (nvPusherFile);
                    }
                }
#endif
                (volatile)dmaChannel->Put = putOffset = 0;
                nvDmaLastPutAddr = nvFifo = (DWORD)nvDmaPushBase;
                DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);

                bWait = FALSE;
            }
        }
        else
        /*
         * |.......P      G.....|
         */
        {
            freeCount = ((getOffset - putOffset) >> 2) - 1;
        }

        /*
         * Maximize freeCount
         */
        if (((DWORD)nvFifo - (DWORD)nvDmaLastPutAddr) >= PUSH_THRESHOLD)
        {
            *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = putOffset;
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

            /*
             * Multiple push buffer sync up.
             */
            WAIT_FOR_VSYNC(pCurrentContext);
            NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_NULL_HW_DRIVER
            if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | putOffset;
#endif //NV_NULL_HW_DRIVER

            /*
             * push buffer disassembler
             */
#ifdef NV_DISASM
            {
                extern HANDLE nvPusherFile;
                extern BOOL   nvPusherDisassemblerEnable;
                if (nvPusherFile && nvPusherDisassemblerEnable)
                {
                    DWORD dw;
                    WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr,&dw,0);
                    FlushFileBuffers (nvPusherFile);
                }
            }
#endif
            (volatile)dmaChannel->Put = putOffset;
            nvDmaLastPutAddr = nvFifo;
            DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);
        }

        if (freeCount > sizeRequired) break;

        if (bWait)
        {
            NV_DELAY;
        }
        bWait = TRUE;
    }

#ifdef NV_PROFILE
    /*
     * FreeCount Wait Log
     */
    NVP_STOP(NVP_T_FREECOUNT);
    nvpLogTime (NVP_T_FREECOUNT,nvpTime[NVP_T_FREECOUNT]);
#endif

    return freeCount;
}

void nvStartDmaBuffer
(
    BOOL bOptional
)
{
    DWORD           dwCurrentOffset;
    Nv4ControlDma  *nvDmaControl;

    /*
     * aa capture override - ignore kickoff
     */
    if (pCurrentContext)
        if (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER)
            return;

    /*
     * Is it worth sending stuff now?
     */
    if (bOptional)
    {
        if (((DWORD)nvFifo-(DWORD)nvDmaLastPutAddr) < PUSH_THRESHOLD) return;
    }
//    if (nvDmaLastPutAddr == nvFifo)
//        return;

    /*
     * Update the ending dma offset.
     */
    if ((!pDriverData->NvDevFlatDma)
     || (pDriverData->fFullScreenDosOccurred))
        return;

    nvDmaControl = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

    dwCurrentOffset = nvFifo - nvDmaPushBase;

#ifdef NV_NULL_HW_DRIVER
    if (nvDmaLastPutAddr) ((DWORD*)nvDmaLastPutAddr)[0] = 0x20000000 | dwCurrentOffset;
#endif //NV_NULL_HW_DRIVER

    dwCurrentOffset = nvFifo - nvDmaPushBase;
    *((volatile DWORD *)&pDriverData->NvDmaPusherBufferEnd[0]) = dwCurrentOffset;
#if 1
                /*
                 * Don't want this, but it's currently the only known way to
                 * guarantee a write combine flush.
                 */
                _outp (0x3d0,0);
#endif

    /*
     * Multiple push buffer sync up.
     */
    WAIT_FOR_VSYNC(pCurrentContext);
    NV_DD_DMA_PUSHER_SYNC();

#ifdef NV_PROFILE
    nvpLogEvent (NVP_E_PUT);
    {
        DWORD put = nvDmaLastPutAddr - nvDmaPushBase;
        DWORD get = (volatile)nvDmaControl->Get;

        if (put >= get)
        {
            nvpLogCount (NVP_C_PENDING,put-get);
        }
        else
        {
            get = (nvDmaPushOffsetMax - get) + put;
            nvpLogCount (NVP_C_PENDING,get);
        }
    }
#endif

    /*
     * push buffer disassembler
     */
#ifdef NV_DISASM
    {
        extern HANDLE nvPusherFile;
        extern BOOL   nvPusherDisassemblerEnable;
        if (nvPusherFile && nvPusherDisassemblerEnable)
        {
            DWORD dw;
            WriteFile (nvPusherFile,(void*)nvDmaLastPutAddr,(DWORD)nvFifo-(DWORD)nvDmaLastPutAddr,&dw,0);
            FlushFileBuffers (nvPusherFile);
        }
    }
#endif

    (volatile)nvDmaControl->Put = dwCurrentOffset;

    nvDmaLastPutAddr = nvFifo; // important - used by TexMan
    DPF_LEVEL(NVDBG_LEVEL_INFO2, "Last Put = 0x%08lx",nvDmaLastPutAddr);
    return;
}

void nvFlushDmaBuffers
(
    void
)
{
    DWORD           dwDmaLastPutOffset;
    Nv4ControlDma  *nvDmaControl;

    if ((!pDriverData->NvDevFlatDma)
     || (pDriverData->fFullScreenDosOccurred))
        return;

    /*
     * aa capture override - ignore kickoff
     */
    if (pCurrentContext)
        if (pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER)
            return;

    nvDmaControl = (Nv4ControlDma *)pDriverData->NvDevFlatDma;

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    DPF_LEVEL(NVDBG_LEVEL_INFO2, "nvFlushDmaBuffers - Kick off outstanding data.");
    nvStartDmaBuffer (FALSE);

    /*
     * Wait for the buffer to finish.
     * This is done by waiting for the (Get == LastPut)
     */
    dwDmaLastPutOffset = nvFifo - nvDmaPushBase;
    while (nvDmaControl->Get != dwDmaLastPutOffset)
    {
        NV_DELAY;
    }

#if 1   // TEMPORARY_HACK
    DPF_LEVEL(NVDBG_LEVEL_INFO2, "nvFlushDmaBuffers - Wait for Graphics Engine Idle!!!");
    while (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700));
#endif

    NV_D3D_GLOBAL_SAVE();
    return;
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4scene.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4SCENE.C                                                        *
*   The direct 3d HAL scene capture routines is implemented in this module. *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       03/24/97 - wrote and cleaned up.        *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "d3dinc.h"
#include "nv4dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_MARKER
DWORD dwMarkerCount = 0;
#endif

#ifdef NV_STATS
DWORD dwSceneCount;
DWORD dwSceneTime;
DWORD dwDP2CallCount;
DWORD dwPrimCount;
DWORD dwPrimLegacyCount;
DWORD dwPrimListCount;
DWORD dwPrimStripCount;
DWORD dwPrimFanCount;
DWORD dwHWPCount;
#endif

/*
 * Scene Capture start and end points
 */
DWORD __stdcall nvSceneCapture
(
    LPD3DHAL_SCENECAPTUREDATA   pscd
)
{
    NvNotification *pPusherSyncNotifier;

    /*
     * Get the pointer to the context.
     */
    pCurrentContext = (PNVD3DCONTEXT)pscd->dwhContext;
    if (!pCurrentContext)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvSceneCapture: - Bad Context");
        pscd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            pscd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    pPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;
    switch (pscd->dwFlag)
    {
//////////////////////////////////////////////////////////////////////////////
        case D3DHAL_SCENE_CAPTURE_START:
#ifdef NV_PROFILE
            /*
             * Scene Timer Start & log
             */
            //nvpLogEvent (NVP_T_CLOCK);
            nvpLogEvent (NVP_E_BEGINSCENE);
            NVP_START(NVP_T_SCENE);
#endif
#ifdef NV_MARKER
            if (1)
            {
                extern DWORD dwMarkerCount;
                dwMarkerCount ++;
                *(DWORD*)(pDriverData->BaseAddress) = (dwMarkerCount << 16) | dwMarkerCount;
            }
            else
                *(DWORD*)(pDriverData->BaseAddress) = 0xaaaaaaaa;
#endif
#ifdef NV_STATS
            dwSceneTime       = (DWORD)-(int)GetTickCount();
            dwDP2CallCount    = 0;
            dwPrimCount       = 0;
            dwPrimLegacyCount = 0;
            dwPrimListCount   = 0;
            dwPrimStripCount  = 0;
            dwPrimFanCount    = 0;
            dwHWPCount        = 0;
#endif

            DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvSceneCapture - Begin Scene");

            /*
             * bump # of frames render
             */
            pCurrentContext->dwSceneCount ++;
            pCurrentContext->dwMipMapsInThisScene = 0;

            /*
             * Make sure the context has the correct suface information in it.
             */
            if (dbgFrontRender)
            {
                pCurrentContext->dwSurfaceAddr            = pDriverData->CurrentVisibleSurfaceAddress;
                pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
                pCurrentContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
                pDriverData->lpLast3DSurfaceRendered      = 0;
            }
            else
            {
                pCurrentContext->dwSurfaceAddr            = VIDMEM_ADDR(pCurrentContext->lpLcl->lpGbl->fpVidMem);
                pCurrentContext->dwSurfaceOffset          = VIDMEM_OFFSET(pCurrentContext->lpLcl->lpGbl->fpVidMem);
                pCurrentContext->surfacePitch.wColorPitch = (WORD)pCurrentContext->lpLcl->lpGbl->lPitch;
            }
            if (pCurrentContext->lpLclZ)
            {
                /*
                 * I've seen it happen where the location of the z-buffer will actually
                 * change without without the context being destroyed or the set render
                 * target call happening. So it's neccessary to make sure that we have the
                 * correct z-buffer address and offset here.
                 */
                pCurrentContext->ZBufferAddr             = VIDMEM_ADDR(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
                pCurrentContext->ZBufferOffset           = VIDMEM_OFFSET(pCurrentContext->lpLclZ->lpGbl->fpVidMem);
                pCurrentContext->surfacePitch.wZetaPitch = (WORD)pCurrentContext->lpLclZ->lpGbl->lPitch;
            }

            /*
             * anti-aliasing semantics check
             */
            pCurrentContext->dwAntiAliasFlags |= AA_IN_SCENE;
            NV_AA_SEMANTICS_SETUP (pCurrentContext);

            /*
             * Get the current freecount and try kicking off any outstanding data in the buffer
             * if the hardware is idle.
             */
            nvglIdleKickoff(sizeSetHeaderDmaPush);
            break;

//////////////////////////////////////////////////////////////////////////////
        case D3DHAL_SCENE_CAPTURE_END:
//            if ((!(pCurrentContext->lpLcl->dwReserved1 & NV_D3D_HAS_FLIPPED))
//             && (!nvglDmaFifoIdle()))
//            {
//                NV_D3D_GLOBAL_SAVE();
//                pscd->ddrval = DD_OK;
//                return (DDHAL_DRIVER_HANDLED);
//            }

            DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvSceneCapture - End Scene");

            /*
             * Anti-Alias post processing
             */
            if (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK)
            {
                /*
                 * AA will use the push buffer. Get proper freecount here.
                 */
#ifdef  CACHE_FREECOUNT
                nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#else   // CACHE_FREECOUNT
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

                /*
                 * aa post-processing
                 */
                nvAARenderPrimitive();
            }

            /*
             * aa - check for bad semantics
             */
            if ((pCurrentContext->dwAntiAliasFlags & AA_MIX_MASK) == AA_MIX_MASK)
            {
                DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    Invalid Semantics Tagged");
                pCurrentContext->dwAntiAliasFlags &= ~AA_ENABLED_MASK;
                pCurrentContext->dwAntiAliasFlags |=  AA_INVALID_SEMANTICS;
                NV_FORCE_TRI_SETUP(pCurrentContext);
                NV_D3D_GLOBAL_SAVE();
                nvFlushDmaBuffers();
                NV_D3D_GLOBAL_SETUP();
                pDriverData->lpLast3DSurfaceRendered = 0;
                nvSetD3DSurfaceState (pCurrentContext);
            }

            pCurrentContext->dwAntiAliasFlags &= ~AA_IN_SCENE;

#ifdef NV_TEX2
            /*
             * set block point for textures
             */
            nvTextureSetBlockPoint();
#endif // NV_TEX2

            /*
             * Start pushing buffer.
             */
            nvStartDmaBuffer (FALSE);

#ifdef NV_STATS
            dwSceneTime  += GetTickCount();
            dwSceneCount ++;
            {
                char sz[512];
                wsprintf (sz,"Scene %d ********************************************\n",dwSceneCount);
                OutputDebugString (sz);
                wsprintf (sz,"Scene Time                = %dms\n",dwSceneTime);
                OutputDebugString (sz);
                wsprintf (sz,"DP2 Call Count            = %d\n",dwDP2CallCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Count           = %d\n",dwPrimCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Legacy Count    = %d\n",dwPrimLegacyCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive List Count      = %d\n",dwPrimListCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Strip Count     = %d\n",dwPrimStripCount);
                OutputDebugString (sz);
                wsprintf (sz,"Primitive Fan Count       = %d\n",dwPrimFanCount);
                OutputDebugString (sz);
                wsprintf (sz,"HW Program Count          = %d\n",dwHWPCount);
                OutputDebugString (sz);
                if (dwSceneTime)
                {
                    wsprintf (sz,"Primitives/second  = %d\n",(dwPrimCount*1000)/dwSceneTime);
                    OutputDebugString (sz);
                }
            }
#endif
#ifdef NV_MARKER
            *(DWORD*)(pDriverData->BaseAddress) = 0xbbbbbbbb;
#endif
#ifdef NV_PROFILE
            /*
             * Scene Timer Stop and log
             */
            NVP_STOP(NVP_T_SCENE);
            nvpLogTime (NVP_T_SCENE,nvpTime[NVP_T_SCENE]);
#endif
            break;
        default:
            break;
    }
    /*
     * Return driver not handled since we want D3D to call our RenderPrimitive
     * routine.
     */
    NV_D3D_GLOBAL_SAVE();
    pscd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4swiz.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4SWIZ.C                                                         *
*   Texture swizzling routines (some HW dependence).                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include <assert.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"

#ifdef NV_TEX2

/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                          \
{                                                   \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);     \
    /*else if ((bpp) == 1) *(BYTE*)(d)  = *(BYTE*)(s);*/\
    else *(DWORD*)(d) = *(DWORD*)(s);               \
}

/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

#ifdef HW_PAL8
DWORD nvTextureBase_meta; // != NULL for palettized textures
WORD  nvPalette[256];
#endif

/*
 * helpers
 * -------
 */

/*
 * nvSwizzleCalcSwizInfo
 *
 * converts an x,y position to a swizzled blt
 * up to 2048x2048 textures supported
 */
void nvSwizzleCalcSwizzleInfo
(
    DWORD  dwX,
    DWORD  dwY,
    DWORD  dwLogW,
    DWORD  dwLogH,
    DWORD  dwBPP,
    DWORD *pdwOffset,
    DWORD *pdwDUDXor,
    DWORD *pdwDUDXand,
    DWORD *pdwDVDYor,
    DWORD *pdwDVDYand
)
{
    DWORD dwLog       = min(dwLogW,dwLogH);
    DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
    DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
    DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

    /*
     * calc offset
     */
    DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
    DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

    DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                      | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                      | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                      | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                      | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                      | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                      | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                      | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                      | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                      | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                      | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                      | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

    *pdwOffset = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

    /*
     * calc masks
     */
    *pdwDUDXor  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
    *pdwDUDXand = (0x55555555 | dwUpperMask) * dwBPP;
    *pdwDVDYor  = (0x55555555 & dwLowerMask) * dwBPP;
    *pdwDVDYand = (0xaaaaaaaa | dwUpperMask) * dwBPP;
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    DWORD dwOffset;
    DWORD dwDUDXor;
    DWORD dwDUDXand;
    DWORD dwDVDYor;
    DWORD dwDVDYand;
    DWORD dwCount,dwSize,dwLine;
    DWORD dwScratch0,dwScratch1;
    DWORD u,v,x,y;
    void *pMemory;

    /*
     * optimize for really thin textures (swizzle bits do not work with width==1)
     */
    if (!dwLogW)
    {
        if (dwSrcPitch != (dwBPP << dwLogH))
        {
            switch (dwBPP)
            {
                case 1:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(BYTE*)u = *(BYTE*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 1;
                    }
                    break;
                }
                case 2:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(WORD*)u = *(WORD*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 2;
                    }
                    break;
                }
                case 4:
                {
                    u = (DWORD)nvTexelScratchBuffer;
                    for (y = (1 << dwLogH); y; y--)
                    {
                        *(DWORD*)u = *(DWORD*)dwSrcBase;
                        dwSrcBase += dwSrcPitch;
                        u += 4;
                    }
                    break;
                }
            }
            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,dwBPP << dwLogH,NV_MEMCOPY_WANTDESTALIGNED);
            return;
        }
        else
        {
            /*
             * pitch == width, treat as thin horz texture
             */
            dwLogW = dwLogH;
            dwLogH = 0;
        }
    }
    if (!dwLogH)
    {
        nvMemCopy ((DWORD)nvTexelScratchBuffer,dwSrcBase,dwBPP << dwLogW,NV_MEMCOPY_WANTSRCALIGNED);
        nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,dwBPP << dwLogW,NV_MEMCOPY_WANTDESTALIGNED);
        return;
    }

    /*
     * figure out bits
     */
    nvSwizzleCalcSwizzleInfo (0,0,dwLogW,dwLogH,dwBPP,
                              &dwOffset,
                              &dwDUDXor,&dwDUDXand,
                              &dwDVDYor,&dwDVDYand);

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = AllocIPM(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        u = dwSrcBase;
        v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine,NV_MEMCOPY_WANTSRCALIGNED);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH,NV_MEMCOPY_WANTSRCALIGNED);
    }

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)(dwScratch1 + (u | v)) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    u           = ((u | dwDUDXor) + 1) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (1*2)) & dwDVDYand;
            }
            break;
        }
        case 2:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)(dwScratch1 + (u | v)) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    u           = ((u | dwDUDXor) + 2) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (2*2)) & dwDVDYand;
            }
            break;
        }
        case 4:
        {
            v = 0;
            for (y = (1 << dwLogH); y; y--)
            {
                u = 0;
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)(dwScratch1 + (u | v)) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    u           = ((u | dwDUDXor) + 4) & dwDUDXand;
                }
                v = ((v | dwDVDYor) + (4*2)) & dwDVDYand;
            }
            break;
        }
    }

    /*
     * write texels
     */
#ifdef HW_PAL8
    if (nvTextureBase_meta)
    {
        DWORD i = dwSize;

        u = dwScratch1;
        v = dwScratch0;
        while (i)
        {
            BYTE bIndex = *(BYTE*)u;
            WORD wColor = nvPalette[bIndex];
            *(WORD*)v = wColor;
            u ++;
            v += 2;
            i --;
        }
        u = dwScratch0;
        v = dwDestBase;
        nvMemCopy (v,u,dwSize*2,NV_MEMCOPY_WANTDESTALIGNED);
    }
    else
    {
        u = dwScratch1;
        v = dwDestBase;
        nvMemCopy (v,u,dwSize,NV_MEMCOPY_WANTDESTALIGNED);
    }
#else
    u = dwScratch1;
    v = dwDestBase;
    nvMemCopy (v,u,dwSize,NV_MEMCOPY_WANTDESTALIGNED);
#endif

    /*
     * free memory
     */
    if (pMemory) FreeIPM (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    DWORD src,dst,cnt;
    DWORD x,y,u,v;

    /*
     * read texels
     */
    src = dwSrcBase;
    dst = (DWORD)(nvTexelScratchBuffer + 0);
    cnt = dwBPP << L2MB;
    for (y=MB; y; y--)
    {
        nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTSRCALIGNED);
        dst += cnt;
        src += dwSrcPitch;
    }

    /*
     * swizzle texels
     */
    src = (DWORD)(nvTexelScratchBuffer + 0);
    dst = (DWORD)(nvTexelScratchBuffer + 4096);
    u   = 0;
    v   = 0;
    switch (dwBPP)
    {
        case 1:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(BYTE*)(dst + (u | v)) = *(BYTE*)src;
                    src += 1;
                    u = ((u | (MB_VMASK*1)) + 1*1) & (MB_UMASK*1);
                }
                v = ((v | (MB_UMASK*1)) + 2*1) & (MB_VMASK*1);
            }
            break;
        }
        case 2:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(WORD*)(dst + (u | v)) = *(WORD*)src;
                    src += 2;
                    u = ((u | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2);
                }
                v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
            }
            break;
        }
        case 4:
        {
            for (y=MB; y; y--)
            {
                u = 0;
                for (x=MB; x; x--)
                {
                    *(DWORD*)(dst + (u | v)) = *(DWORD*)src;
                    src += 4;
                    u = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                }
                v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
            }
            break;
        }
    }

    /*
     * write out
     */
#ifdef HW_PAL8
    if (nvTextureBase_meta)
    {
        DWORD i;
        src   = (DWORD)(nvTexelScratchBuffer + 4096);
        dst   = (DWORD)(nvTexelScratchBuffer + 0);
        cnt <<= L2MB;

        i = cnt;
        while (i)
        {
            BYTE bIndex = *(BYTE*)src;
            WORD wColor = nvPalette[bIndex];
            *(WORD*)dst = wColor;
            src ++;
            dst += 2;
            i   --;
        }

        src = (DWORD)(nvTexelScratchBuffer + 0);
        dst = (dwDestBase - nvTextureBase_meta) * 2 + nvTextureBase_meta; // fixup dest (all code currently assume src & dst bpp the same)
        nvMemCopy (dst,src,cnt*2,NV_MEMCOPY_WANTDESTALIGNED);
    }
    else
    {
        src   = (DWORD)(nvTexelScratchBuffer + 4096);
        dst   = dwDestBase;
        cnt <<= L2MB;
        nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTDESTALIGNED);
    }
#else
    src   = (DWORD)(nvTexelScratchBuffer + 4096);
    dst   = dwDestBase;
    cnt <<= L2MB;
    nvMemCopy (dst,src,cnt,NV_MEMCOPY_WANTDESTALIGNED);
#endif
}

/*
 * nvSwizzleBlt_LS_FT
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_LS_FT
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    DWORD dwOffset;
    DWORD dwDUDXor;
    DWORD dwDUDXand;
    DWORD dwDVDYor;
    DWORD dwDVDYand;
    DWORD dwMBPP,dwMBPP2;
    DWORD u,v,x,y;

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);

    /*
     * optimize for thin vertival case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        return;
    }

    /*
     * figure out bits for macro blocks
     */
    nvSwizzleCalcSwizzleInfo (0,0,dwLogW,dwLogH,dwMBPP2,
                              &dwOffset,
                              &dwDUDXor,&dwDUDXand,
                              &dwDVDYor,&dwDVDYand);

    /*
     * do macroblock swizzle
     */
    v = 0;
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        u = 0;
        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    dwDestBase + (u | v),
                                    dwBPP);

            u = ((u | dwDUDXor) + dwMBPP2) & dwDUDXand;
            dwSrc += dwBPP << L2MB;
        }
        v = ((v | dwDVDYor) + dwMBPP2*2) & dwDVDYand;

        dwSrcBase += dwSrcPitch << L2MB;
    }
}

/*
 * nvSwizzleBlt_aa_bb_cc
 *
 *  aa E (LL, SL, LS, SS)
 *  bb E (XX, ST)
 *  cc E (XX, LR, LW)
 *
 * swizzle blts we can build - other indices are undefined
 *
 *  lin -> lin, subtexture, machine dep  linear r/w        nvSwizzleBlt_LL_ST_RW
 *  swz -> lin, subtexture, machine dep, linear write      nvSwizzleBlt_SL_ST_LW
 *  lin -> swz, subtexture, machine dep, linear read       nvSwizzleBlt_LS_ST_LR
 *  swz -> swz, subtexture, machine dep                    nvSwizzleBlt_SS_ST_XX
 *  swz -> swz,             machine dep  linear r/w        nvSwizzleBlt_SS_XX_RW
 */
void nvSwizzleBlt_LL_ST_RW
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SL_ST_LW
(
    DWORD dwSrcBase,
    DWORD dwSrcOffset,
    DWORD dwSrcDUDXor,
    DWORD dwSrcDUDXand,
    DWORD dwSrcDVDYor,
    DWORD dwSrcDVDYand,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwSrcOffset & dwSrcDVDYand;
            b = dwSrcOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,dwSrcBase + b,dwBPP);
                a += dwBPP;
                u = ((b | dwSrcDUDXor) + dwBPP) & dwSrcDUDXand;
                b = u | v;
            }
            u = dwSrcOffset & dwSrcDUDXand;
            v = ((dwSrcOffset | dwSrcDVDYor) + (dwBPP*2)) & dwSrcDVDYand;
            dwSrcOffset = u | v;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes,NV_MEMCOPY_WANTDESTALIGNED);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }
}

void nvSwizzleBlt_LS_ST_LR
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestBase,
    DWORD dwDestOffset,
    DWORD dwDestDUDXor,
    DWORD dwDestDUDXand,
    DWORD dwDestDVDYor,
    DWORD dwDestDVDYand,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes,NV_MEMCOPY_WANTSRCALIGNED);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwDestOffset & dwDestDVDYand;
            b = dwDestOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (dwDestBase + b,a,dwBPP);
                a += dwBPP;
                u = ((b | dwDestDUDXor) + dwBPP) & dwDestDUDXand;
                b = u | v;
            }
            u = dwDestOffset & dwDestDUDXand;
            v = ((dwDestOffset | dwDestDVDYor) + (dwBPP*2)) & dwDestDVDYand;
            dwDestOffset = u | v;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SS_ST_XX
(
    DWORD dwSrcBase,
    DWORD dwSrcOffset,
    DWORD dwSrcDUDXor,
    DWORD dwSrcDUDXand,
    DWORD dwSrcDVDYor,
    DWORD dwSrcDVDYand,

    DWORD dwDestBase,
    DWORD dwDestOffset,
    DWORD dwDestDUDXor,
    DWORD dwDestDUDXand,
    DWORD dwDestDVDYor,
    DWORD dwDestDVDYand,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwSrcOffset & dwSrcDVDYand;
            b = dwSrcOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,dwSrcBase + b,dwBPP);
                a += dwBPP;
                u = ((b | dwSrcDUDXor) + dwBPP) & dwSrcDUDXand;
                b = u | v;
            }
            u = dwSrcOffset & dwSrcDUDXand;
            v = ((dwSrcOffset | dwSrcDVDYor) + (dwBPP*2)) & dwSrcDVDYand;
            dwSrcOffset = u | v;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD u;
            DWORD v;
            DWORD b;
            DWORD x;

            v = dwDestOffset & dwSrcDVDYand;
            b = dwDestOffset;
            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (dwDestBase + b,a,dwBPP);
                a += dwBPP;
                u = ((b | dwDestDUDXor) + dwBPP) & dwDestDUDXand;
                b = u | v;
            }
            u = dwDestOffset & dwDestDUDXand;
            v = ((dwDestOffset | dwDestDVDYor) + (dwBPP*2)) & dwDestDVDYand;
            dwDestOffset = u | v;
        }

        y -= f;
    }
}

void nvSwizzleBlt_SS_XX_RW
(
    DWORD dwSrcAddr,

    DWORD dwDestAddr,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD f = min(dwSubHeight,y);
        DWORD c = f * dwBytes;

        /*
         * read linear (swizzled texels)
         */
        nvMemCopy ((DWORD)&nvTexelScratchBuffer,dwSrcAddr,c,NV_MEMCOPY_WANTSRCALIGNED);
        dwSrcAddr += c;

        /*
         * write linear (swizzled texels)
         */
        nvMemCopy (dwDestAddr,(DWORD)&nvTexelScratchBuffer,c,NV_MEMCOPY_WANTDESTALIGNED);
        dwDestAddr += c;

        y -= f;
    }
}

/*
 * HARDWARE SWIZZLE
 * ----------------
 */

/*
 * nvHWSwizzleBlt
 *
 * perform a HW swizzle blt
 */
void nvHWSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcAlloc,

    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight

#ifdef DIRECTSWIZZLE
    ,DWORD dwBPP
#endif
)
{
#ifdef DIRECTSWIZZLE
    {
        /*
         * target surface
         */
        DWORD dwCount = sizeSetObject * 1 + sizeSetStartMethod * 1 + sizeSetData * 4;
        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);

        nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT,4);
        nvglSetData        (nvFifo, nvFreeCount,              dwSurfaceColorFormat);
        nvglSetData        (nvFifo, nvFreeCount,              (dwBPP << (16 + dwMipMapBaseU)) | dwSrcPitch);
        nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset); // not used
        nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);
    }
#else //!DIRECTSWIZZLE
    /*
     * target surface
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwMipMapBaseU)
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwMipMapBaseV)),
                                         dwDstSwizzleOffset);
#endif //!DIRECTSWIZZLE

    /*
     * format
     */
    while (nvFreeCount < (sizeSetObject + sizeSetScaledImageFormat))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetScaledImageFormat));
    nvglSetObject               (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (nvFifo,nvFreeCount,NV_DD_SPARE, dwImageColorFormat);

    /*
     * source memory context
     */
    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
    if (dwSrcAlloc & NV4_TEXLOC_AGP)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    } else if (dwSrcAlloc & NV4_TEXLOC_VID)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    } else if (dwSrcAlloc & NV4_TEXLOC_PCI)
    {
        nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
    }

    /*
     * clip
     */
    while (nvFreeCount < (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy));
    nvglScaledImageClip          (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (nvFifo,nvFreeCount,NV_DD_SPARE, (1<<20), (1<<20));

    /*
     * src & go
     */
    while (nvFreeCount < (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint));
    nvglScaledImageInSize   (nvFifo, nvFreeCount, NV_DD_SPARE, dwBlitWidth, dwBlitHeight);
    nvglScaledImageInFormat (nvFifo, nvFreeCount, NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcX0, dwSrcY0);

    pDriverData->dDrawSpareSubchannelObject = D3D_SCALED_IMAGE_FROM_MEMORY;
}

#ifdef HW_PAL8
/*
 * nvHWSwizzleBltPal8
 *
 * perform a HW swizzle blt from an 8-bit palettized texture
 */
void nvHWSwizzleBltPal8
(
    // LUT parameters
    DWORD dwLUTOffset,

    // indexed (source) image parameters
    DWORD dwSrcImageAddr,

    // destination surface parameters
    DWORD dwDstSwizzleOffset,
    DWORD dwDstLogU,
    DWORD dwDstLogV,
    DWORD dwDstColorFormat,
    DWORD dwDstBPP,

    // general parameters
    DWORD dwWidth,
    DWORD dwHeight
)
{
    DWORD dwMaxScanLinesPerIteration, dwScanLinesLeftToWrite, dwScanLinesToWrite;
    DWORD dwCount, x0, y0;
    DWORD dwSrcSizeWords;

    if (dwWidth*dwHeight < 4) {
        // this is going to be an annoying special case because it
        // means the stupid thing is less than one DWORD. just bail for now.
        dbgD3DError();
        return;
    }

    // we can put at most 0x1c00 bytes into the buffer at a time
    assert(dwWidth < 0x1c00);
    dwMaxScanLinesPerIteration = 0x1c00 / dwWidth;
    dwScanLinesLeftToWrite = dwHeight;

    //
    // set stuff that doesn't change from one iteration to the next
    //

    // target surface parameters
    // nv05 will be able to write to a swizzled surface. alas nv04 cannot
    /*
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwDstColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwDstLogU))
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwDstLogV)),
                                         dwDstSwizzleOffset);  */
    dwCount = sizeSetObject + sizeSetStartMethod + 4*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT, 4);
    nvglSetData        (nvFifo, nvFreeCount,              dwDstColorFormat);
    nvglSetData        (nvFifo, nvFreeCount,              ((dwDstBPP << dwDstLogU) << 16) |
                                                           (dwDstBPP << dwDstLogU));  // not used
    nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);  // not used
    nvglSetData        (nvFifo, nvFreeCount,              dwDstSwizzleOffset);

    // source parameters
    dwCount = sizeSetObject + sizeSetIndexedImageContextDmaLUT + sizeSetIndexedImageLUTOffset;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_INDEXED_IMAGE_FROM_CPU);
    nvglSetIndexedImageContextDmaLUT(nvFifo, nvFreeCount, NV_DD_SPARE,
                                     NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetIndexedImageLUTOffset(nvFifo,nvFreeCount,NV_DD_SPARE, dwLUTOffset);

    //
    // now iterate as many times as necessary to feed the whole thing into the buffer
    //
    x0 = y0 = 0;

    while (dwScanLinesLeftToWrite > 0) {

        dwScanLinesToWrite = (dwScanLinesLeftToWrite > dwMaxScanLinesPerIteration) ?
            dwMaxScanLinesPerIteration : dwScanLinesLeftToWrite;

        // set point and image sizes
        dwCount = sizeSetIndexedImagePoint + sizeSetIndexedImageSizes;
        while (nvFreeCount < dwCount)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
        nvglSetIndexedImagePoint(nvFifo,nvFreeCount,NV_DD_SPARE, x0,y0);
        nvglSetIndexedImageSizes(nvFifo,nvFreeCount,NV_DD_SPARE,
                                 dwWidth, dwScanLinesToWrite,
                                 dwWidth, dwScanLinesToWrite);

        // put the indices into the push buffer
        assert((dwScanLinesToWrite*dwWidth & 0x3) == 0);
        dwSrcSizeWords = (dwScanLinesToWrite*dwWidth) >> 2;
        while (nvFreeCount < (1+dwSrcSizeWords))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (1+dwSrcSizeWords));
        nvglSetIndexedImageIndices(nvFifo,nvFreeCount,NV_DD_SPARE,
                                   dwSrcSizeWords, (DWORD *)dwSrcImageAddr);

        // increment / decrement counters and pointers
        y0 += dwScanLinesToWrite;
        dwScanLinesLeftToWrite -= dwScanLinesToWrite;
        (DWORD *)dwSrcImageAddr += dwSrcSizeWords;
    }

    pDriverData->dDrawSpareSubchannelObject = D3D_INDEXED_IMAGE_FROM_CPU;
}

// munge the palette from Microsoft form into X8R8G8B8 form
// and move it into video memory where the HW can use it

BOOL nvPreparePalette(PNVD3DTEXTURE pSrcTexture)
{
    LPPALETTEENTRY pPaletteSrc;
    DWORD pPaletteDst, dwCount;

    // make sure we have a palette
    if ((!pSrcTexture) ||
        (!pSrcTexture->lpLcl) ||
        (!pSrcTexture->lpLcl->lpDDPalette) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl) ||
        (!pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable)) {
        dbgD3DError();
        return FALSE;
    }

    pPaletteSrc = pSrcTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable;
    pPaletteDst = pCurrentContext->dwTexturePaletteAddr;

    // feed the palette through the push buffer via
    // an NV04_IMAGE_FROM_CPU object so as to keep palettes
    // synchronized with the textures that use them.

    // set up the destination surface
    dwCount = sizeSetObject + sizeSetStartMethod + 4*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, NV_DD_SURFACES_2D);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV042_SET_COLOR_FORMAT, 4);
    nvglSetData        (nvFifo, nvFreeCount,              NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);
    nvglSetData        (nvFifo, nvFreeCount,              ((256*4) << 16) |
                                                           (256*4));        // not used
    nvglSetData        (nvFifo, nvFreeCount,              pPaletteDst);     // not used
    nvglSetData        (nvFifo, nvFreeCount,              pPaletteDst);

    // set image_from_cpu object and feed the palette into the push buffer
    dwCount = sizeSetObject + sizeSetStartMethod + 3*sizeSetData;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetObject      (nvFifo, nvFreeCount, NV_DD_SPARE, D3D_IMAGE_FROM_CPU);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_POINT, 3);
    nvglSetData        (nvFifo, nvFreeCount, 0);                  // point
    nvglSetData        (nvFifo, nvFreeCount, (0x1<<16) | 0x100);  // sizeout = 1H x 256W
    nvglSetData        (nvFifo, nvFreeCount, (0x1<<16) | 0x100);  // sizein = sizeout

    dwCount = sizeSetStartMethod + 256;
    while (nvFreeCount < dwCount)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, dwCount);
    nvglSetStartMethod (nvFifo, nvFreeCount, NV_DD_SPARE, NV061_COLOR(0), 256);

    for (dwCount=0; dwCount<256; dwCount++) {
        *(DWORD *)nvFifo = (((DWORD)(0xff000000))                |  // A
                            ((DWORD)(pPaletteSrc->peRed) << 16)  |  // R
                            ((DWORD)(pPaletteSrc->peGreen) << 8) |  // G
                            ((DWORD)(pPaletteSrc->peBlue) << 0));   // B
        (DWORD *)pPaletteSrc += 1;
        (DWORD *)nvFifo += 1;
    }
    nvFreeCount -= 256;

    //NV_D3D_GLOBAL_SAVE();
    //nvFlushDmaBuffers();

    return TRUE;
}

#endif  // HW_PAL8

/*
 * exported
 * --------
 */

/*
 * nvSwizzleBlt
 *
 * performs swizzle or deswizzle in the most optimal fashion depending
 * on surface location and specified flags
 *
 * if pTexture != NULL we will block CPU before writing (if needed)
 * & also update retirement date for proper syncronization.
 */
BOOL nvSwizzleBlt
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcAlloc,
    DWORD         dwSrcLogW,
    DWORD         dwSrcLogH,
    DWORD         dwSrcX0,
    DWORD         dwSrcY0,
    DWORD         dwSrcX1,
    DWORD         dwSrcY1,
    DWORD         dwSrcPitch,
    PNVD3DTEXTURE pSrcTexture,

    DWORD         dwDestAddr,
    DWORD         dwDestAlloc,
    DWORD         dwDestLogW,
    DWORD         dwDestLogH,
    DWORD         dwDestX,
    DWORD         dwDestY,
    DWORD         dwDestPitch,
    PNVD3DTEXTURE pDestTexture,

    DWORD         dwBPP,
    DWORD         dwFlags
)
{
    /*
     * prepare common variables
     */
    DWORD dwW         = dwSrcX1 - dwSrcX0;
    DWORD dwH         = dwSrcY1 - dwSrcY0;
    BOOL  bWholeSrc   = ((1U << dwSrcLogW)  == dwW) && ((1U << dwSrcLogH)  == dwH);
    BOOL  bWholeDest  = ((1U << dwDestLogW) == dwW) && ((1U << dwDestLogH) == dwH);
    BOOL  bFullTex    = bWholeSrc && bWholeDest && (dwSrcLogW == dwDestLogW) && (dwSrcLogH == dwDestLogH);
    DWORD dwMemory;

    /*
     * sanity check
     */
    if (!dwH || !dwW || !dwSrcAddr || !dwDestAddr) return FALSE;

    /*
     * can we perform this operation using HW?
     */
    if (dwFlags & NV_SWIZFLAG_ALLOWHW)
    {
        /*
         * break into different swizzle cases
         */
        switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
        {
            case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
            {
                /*
                 * is the source and dest in HW reachable locations?
                 */
                if ((dwSrcAlloc & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID | NV4_TEXLOC_PCI))
                 && (dwDestAlloc & NV4_TEXLOC_VID)
                 && pSrcTexture
                 && pDestTexture)
                {
                    DWORD dwIndex = TEX_SWIZZLE_INDEX(pDestTexture->dwTextureFlags);
                    DWORD dwImageColorFormat;
                    DWORD dwSurfaceColorFormat;

                    /*
                     * program HW
                     */
#ifdef HW_PAL8
                    if (dwFlags & NV_SWIZFLAG_PALETTIZED)
                    {
                        // setup
                        switch (pDestTexture->dwTextureColorFormat) {
                            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_R5G6B5:
                            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
                                break;
                            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                            case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
                                break;
                        }

                        // prepare the palette
                        if (!nvPreparePalette(pSrcTexture)) return FALSE;

                        // swizzle the palettized texture
                        nvSwizzleBlt(dwSrcAddr, dwSrcAlloc,
                                     dwSrcLogW, dwSrcLogH,
                                     dwSrcX0, dwSrcY0,
                                     dwSrcX1, dwSrcY1,
                                     dwW,   // pitch == width for 8 bpp
                                     pSrcTexture,
                                     dwDestAddr, dwDestAlloc,
                                     dwDestLogW, dwDestLogH,
                                     dwDestX, dwDestY,
                                     dwW,   // pitch == width for 8 bpp
                                     pDestTexture,
                                     1,     // 1 BPP
                                     dwFlags & ~(NV_SWIZFLAG_PALETTIZED |
                                                 NV_SWIZFLAG_ALLOWHW));

                        // de-palettize the texture
                        nvHWSwizzleBltPal8 (pCurrentContext->dwTexturePaletteOffset,
                                            pSrcTexture->dwLinearAddr,
                                            pDestTexture->dwSwizzleOffset,
                                            pDestTexture->dwMipMapBaseU,
                                            pDestTexture->dwMipMapBaseV,
                                            dwSurfaceColorFormat,
                                            pDestTexture->dwBPP,
                                            dwW,dwH);
                    }
                    else
#endif  // HW_PAL8
                    {
                        /*
                         * prepare for blt
                         */
                        switch (pDestTexture->dwTextureColorFormat) {
                            case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_R5G6B5:
                            case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                            case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                                dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
#ifdef DIRECTSWIZZLE
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
#else
                                dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
#endif
                                break;
                            case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                            case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                                dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
#ifdef DIRECTSWIZZLE
                                dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
#else
                                dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
#endif
                                break;
                        }

                        nvHWSwizzleBlt (pSrcTexture->dwLinearOffset,
                                        pSrcTexture->dwPitch,
                                        dwImageColorFormat,
                                        dwSrcX0,dwSrcY0,
                                        dwSrcAlloc,
                                        pDestTexture->dwSwizzleOffset[dwIndex],
                                        pDestTexture->dwMipMapBaseU,pDestTexture->dwMipMapBaseV,
                                        dwSurfaceColorFormat,
                                        dwDestX,dwDestY,
                                        dwW,dwH
#ifdef DIRECTSWIZZLE
                                        ,pDestTexture->dwBPP
#endif
                                        );
#if 0
NV_D3D_GLOBAL_SAVE();
nvFlushDmaBuffers();
NV_D3D_GLOBAL_SETUP();
#endif
                    }

                    /*
                     * block other processes from reading or writing until we have finished
                     */
                    pDestTexture->dwRetireDate[dwIndex] = global.dwSWTextureDate;
                    nvTextureSetBlockPoint();

                    /*
                     * done
                     */
                    return TRUE;
                }
            }
        }
    }

    /*
     * quicky memory configuration bit field
     *  1 == src  is uncached,
     *  2 == dest is uncached
     */
    dwMemory    = ((dwSrcAlloc  & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID)) ? 1 : 0)
                | ((dwDestAlloc & (NV4_TEXLOC_AGP | NV4_TEXLOC_VID)) ? 2 : 0);

    /*
     * CPU has to do the work...
     *
     * sync HW & CPU for the given textures
     */
#ifdef NV_PROFILE // remove texture wait from these timings
    NVP_STOP (NVP_T_TEXSWBLT);
    NVP_STOP (NVP_T_TEXHWBLT);
    //NVP_START (NVP_X_FLOAT0);
#endif
    if (pSrcTexture)  nvTextureBlock (pSrcTexture ->dwRetireDate[(dwFlags & NV_SWIZFLAG_SRCSWIZZLED)  ? (TEX_SWIZZLE_INDEX(pSrcTexture-> dwTextureFlags)) : NV4_TEXCOUNT_SWIZZLE]);
    if (pDestTexture) nvTextureBlock (pDestTexture->dwRetireDate[(dwFlags & NV_SWIZFLAG_DESTSWIZZLED) ? (TEX_SWIZZLE_INDEX(pDestTexture->dwTextureFlags)) : NV4_TEXCOUNT_SWIZZLE]);
#ifdef NV_PROFILE
    //NVP_STOP (NVP_X_FLOAT0);
    //nvpLogTime (NVP_X_FLOAT0,nvpTime[NVP_X_FLOAT0]);
    NVP_RESTART (NVP_T_TEXSWBLT);
    NVP_RESTART (NVP_T_TEXHWBLT);
#endif

    /*
     * break into different swizzle cases
     */
    switch (dwFlags & (NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED))
    {
        case 0:                         // lin -> lin
        {
            DWORD dwSubHeight = 4096 / (dwW * dwBPP);
            if (!dwSubHeight) dwSubHeight = 1;
                         else dwSubHeight = min(dwSubHeight,dwH);

            //OutputDebugString ("nvSwizzleBlt_LL_ST_RW\n");
            nvSwizzleBlt_LL_ST_RW (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                   dwSrcPitch,
                                   dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                   dwDestPitch,
                                   dwW,dwH,dwSubHeight,dwBPP);
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED:   // swz -> lin
        {
            if (/*!bFullTex*/1) // txtodo - fast fulltexture deswizzle needed
            {
                DWORD dwSrcOffset;
                DWORD dwSrcDUDXor;
                DWORD dwSrcDUDXand;
                DWORD dwSrcDVDYor;
                DWORD dwSrcDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP,
                                          &dwSrcOffset,
                                          &dwSrcDUDXor,&dwSrcDUDXand,
                                          &dwSrcDVDYor,&dwSrcDVDYand);

                //OutputDebugString ("nvSwizzleBlt_SL_ST_LW\n");
                nvSwizzleBlt_SL_ST_LW (dwSrcAddr,dwSrcOffset,
                                       dwSrcDUDXor,dwSrcDUDXand,
                                       dwSrcDVDYor,dwSrcDVDYand,
                                       dwDestAddr + dwDestY * dwDestPitch + dwDestX * dwBPP,
                                       dwDestPitch,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
            }
        }
        case NV_SWIZFLAG_DESTSWIZZLED:  // lin -> swz
        {
            if (!bFullTex)
            {
                DWORD dwDestOffset;
                DWORD dwDestDUDXor;
                DWORD dwDestDUDXand;
                DWORD dwDestDVDYor;
                DWORD dwDestDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP,
                                          &dwDestOffset,
                                          &dwDestDUDXor,&dwDestDUDXand,
                                          &dwDestDVDYor,&dwDestDVDYand);

                //OutputDebugString ("nvSwizzleBlt_LS_ST_LR\n");
                nvSwizzleBlt_LS_ST_LR (dwSrcAddr + dwSrcY0 * dwSrcPitch + dwSrcX0 * dwBPP,
                                       dwSrcPitch,
                                       dwDestAddr,dwDestOffset,
                                       dwDestDUDXor,dwDestDUDXand,
                                       dwDestDVDYor,dwDestDVDYand,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
#ifdef HW_PAL8
                if (pDestTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)
                {
                    LPPALETTEENTRY pPalette;
                    DWORD          i;

                    nvTextureBase_meta = dwDestAddr;

                    if (pDestTexture->lpLcl->lpDDPalette)
                    {
                        pPalette = pDestTexture->lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable;
                        for (i=0; i<256; i++)
                        {
                            extern WORD nvPalette[256];

                            nvPalette[i] = ((WORD)(pPalette[i].peRed   & 0xF8) << 8)
                                         | ((WORD)(pPalette[i].peGreen & 0xFC) << 3)
                                         | ((WORD)(pPalette[i].peBlue  & 0xF8) >> 3);
                        }
                    }
                    else
                    {
                        // no palette - what now?
                        // we just do the work anyway withou the correct palette
                    }

                    nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                        dwDestAddr,
                                        dwSrcLogW,dwSrcLogH,1);
                }
                else
                {
                    nvTextureBase_meta = 0;
                    nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                        dwDestAddr,
                                        dwSrcLogW,dwSrcLogH,dwBPP);
                }
#else
                nvSwizzleBlt_LS_FT (dwSrcAddr,dwSrcPitch,
                                    dwDestAddr,
                                    dwSrcLogW,dwSrcLogH,dwBPP);
#endif
            }
            break;
        }
        case NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTSWIZZLED: // swz -> swz
        {
            if (!bFullTex)
            {
                DWORD dwSrcOffset;
                DWORD dwSrcDUDXor;
                DWORD dwSrcDUDXand;
                DWORD dwSrcDVDYor;
                DWORD dwSrcDVDYand;

                DWORD dwDestOffset;
                DWORD dwDestDUDXor;
                DWORD dwDestDUDXand;
                DWORD dwDestDVDYor;
                DWORD dwDestDVDYand;

                DWORD dwSubHeight = 4096 / (dwW * dwBPP);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,dwH);

                nvSwizzleCalcSwizzleInfo (dwSrcX0,dwSrcY0,dwSrcLogW,dwSrcLogH,dwBPP,
                                          &dwSrcOffset,
                                          &dwSrcDUDXor,&dwSrcDUDXand,
                                          &dwSrcDVDYor,&dwSrcDVDYand);

                nvSwizzleCalcSwizzleInfo (dwDestX,dwDestY,dwDestLogW,dwDestLogH,dwBPP,
                                          &dwDestOffset,
                                          &dwDestDUDXor,&dwDestDUDXand,
                                          &dwDestDVDYor,&dwDestDVDYand);

                //OutputDebugString ("nvSwizzleBlt_SS_ST_XX\n");
                nvSwizzleBlt_SS_ST_XX (dwSrcAddr,dwSrcOffset,
                                       dwSrcDUDXor,dwSrcDUDXand,
                                       dwSrcDVDYor,dwSrcDVDYand,
                                       dwDestAddr,dwDestOffset,
                                       dwDestDUDXor,dwDestDUDXand,
                                       dwDestDVDYor,dwDestDVDYand,
                                       dwW,dwH,dwSubHeight,dwBPP);
            }
            else
            {
                DWORD dwSubHeight = 4096 / (dwBPP << dwSrcLogW);
                if (!dwSubHeight) dwSubHeight = 1;
                             else dwSubHeight = min(dwSubHeight,(DWORD)(1 << dwSrcLogH));

                //OutputDebugString ("nvSwizzleBlt_SS_XX_RW\n");
                nvSwizzleBlt_SS_XX_RW (dwSrcAddr,
                                       dwDestAddr,
                                       1 << dwSrcLogW,1 << dwSrcLogH,dwSubHeight,dwBPP);
            }
            break;
        }
    }

#if 0
    /*
     * fill dest with solid color
     */
    {
        DWORD dl = dwDestAddr;
        DWORD x,y;

        for (y=0; y<dwH; y++)
        {
            DWORD da = dl;

            for (x=0; x<dwW; x++)
            {
                *(WORD*)da = 0xaa55;
                da += 2;
            }

            dl += dwDestPitch;
        }
    }
#endif

#if 0
    /*
     * show what we have done
     */
    /*if (dwFlags & NV_SWIZFLAG_DESTSWIZZLED)*/ {
        DWORD sl = dwSrcAddr;
        DWORD dl = dwDestAddr;
        DWORD vl = pDriverData->CurrentVisibleSurfaceAddress;

        DWORD x,y;

        for (y=0; y<dwH; y++)
        {
            DWORD sa = sl;
            DWORD da = dl;
            DWORD va = vl;

            for (x=0; x<dwW; x++)
            {
                *(WORD*)va            = *(WORD*)sa;
                *(WORD*)(va + dwW* 2) = *(WORD*)da;

                sa += 2;
                da += 2;
                va += 2;
            }

            sl += dwSrcPitch;
            dl += dwDestPitch;
            vl += 1024 * 2;
        }

        DPF("nvSwizzleBlt - dwFlags    = %08x",dwFlags);
        DPF("               dwSrcAddr  = %08x",dwSrcAddr);
        DPF("               dwDestAddr = %08x",dwDestAddr);
        DPF("               dwW        = %d",dwW);
        DPF("               dwH        = %d",dwH);
        __asm int 3;
    }
#endif

    /*
     * done
     */
    return TRUE;
}

#endif //NV_TEX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prim2.c ===
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PRIM2.C                                                        *
*   NV4 DX6 DrawPrimitives2 routines.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef  NVD3D_DX6

#ifdef  WINNT
#define CHECK_CMDBUF_LIMITS(pDP2Data, pBuf)                                                 \
{                                                                                           \
    LPBYTE pBase,pEnd;                                                                      \
    pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem + pDP2Data->dwCommandOffset);  \
    pEnd  = pBase + pDP2Data->dwCommandLength;                                              \
    if (! ((LPBYTE)pBuf < pEnd) && ( pBase <= (LPBYTE)pBuf))                                \
    {                                                                                       \
        pDP2Data->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;                 \
        pDP2Data->ddrval = D3DERR_COMMAND_UNPARSED;                                         \
        return DDHAL_DRIVER_HANDLED;                                                        \
    }                                                                                       \
}

#define CHECK_DATABUF_LIMITS(pDP2Data, iIndex)                                              \
{                                                                                           \
    if (!(((LONG)iIndex >= 0)                                                               \
     &&   ((LONG)iIndex < (LONG)pDP2Data->dwVertexLength)))                                 \
    {                                                                                       \
        pDP2Data->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;                 \
        pDP2Data->ddrval = D3DERR_COMMAND_UNPARSED;                                         \
        return DDHAL_DRIVER_HANDLED;                                                        \
    }                                                                                       \
}
#else   // !WINNT
#define CHECK_CMDBUF_LIMITS(pDP2Data, pBuf)
#define CHECK_DATABUF_LIMITS(pDP2Data, iIndex)
#endif  // !WINNT

D3DTLVERTEX tlvDefault =
{
    0.0f,           // sx
    0.0f,           // sy
    0.0f,           // sz
    1.0f,           // rhw
    0xFFFFFFFF,     // argb
    0xFF000000,     // specular
    0.0f,           // tu
    0.0f            // tv
};

/*
 * TL Vertex in Flex Format
 */
NVD3DFVFDATA constFVFData =
{
    D3DFVF_TLVERTEX,
    32,
    0xffffffff,0,
    0xffffffff,12,
    0xffffffff,16,
    0xffffffff,20,
    0xffffffff,24,
    1,
    0,0,0
};

PFND3DPARSEUNKNOWNCOMMAND   fnD3DParseUnknownCommandCallback;

#ifndef NV_FASTLOOPS
/*
 * DirectX 6.0 DrawPrimitives2 entry point.
 */
void nvDX5FlexTriangleSetup
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    return;
}

void nvDX5FlexIndexedTriangleSetup
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    /*
     * Send the context state down to the hardware.
     */
    if (pCurrentContext->dwStateChange)
        nvSetHardwareState();
    nvSetDx5TriangleState(pCurrentContext);

    /*
     * Now calculate the appropriate rendering routine and call it.
     *
     * Determine the fog table mode based on if fog is enabled and the
     * selected fog table mode.  A computed value of 0 = vertex or no fog,
     * non-zero values indicate the fog table mode.
     */
    CALC_FUNCTION_INDEX (pCurrentContext);

    fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
#endif //!NV_FASTLOOPS

void nvSolidIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
#ifdef NV_FASTLOOPS
    nvTriangleDispatch(dwPrimCount, lpwIndices, dwStrides, lpVertices);
#else
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            fnDX5FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
    {
        /*
         * Call an inner loop that uses the DX6_MULTI_TEXTURE_TRIANGLE class.
         */
        fnDX6FlexIndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    return;
#endif //!NV_FASTLOOPS
}

void nvWireframeIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
        nvFVFIndexedWireframeTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}
void nvPointIndexedTriangle
(
    DWORD           dwPrimCount,
    LPWORD          lpwIndices,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    }
    else
        nvFVFIndexedPointTriangle(dwPrimCount, lpwIndices, dwStrides, lpVertices);
    return;
}

void nvSolidNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
#ifdef NV_FASTLOOPS
    nvTriangleDispatch(wPrimCount, NULL, dwStrides, lpVertices);
#else
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            fnDX5Table[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            fnDX5FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    }
    else
    {
        /*
         * Call an inner loop that uses the DX6_MULTI_TEXTURE_TRIANGLE class.
         */
        fnDX6FlexTable[pCurrentContext->dwFunctionLookup](wPrimCount, dwStrides, lpVertices);
    }
    return;
#endif //!NV_FASTLOOPS
}
void nvWireframeNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvDrawWireframeTriangle(wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFDrawWireframeTriangle(wPrimCount, dwStrides, lpVertices);
    }
    else
        nvFVFDrawWireframeTriangle(wPrimCount, dwStrides, lpVertices);
    return;
}
void nvPointNonIndexedTriangle
(
    WORD            wPrimCount,
    DWORD           dwStrides,
    LPBYTE          lpVertices
)
{
    if (!pCurrentContext->bUseDX6Class)
    {
        if (fvfData.dwVertexType == D3DFVF_TLVERTEX)
            nvDrawPointTriangle(wPrimCount, dwStrides, (LPD3DTLVERTEX)lpVertices);
        else
            nvFVFDrawPointTriangle(wPrimCount, dwStrides, lpVertices);
    }
    else
        nvFVFDrawPointTriangle(wPrimCount, dwStrides, lpVertices);
    return;
}

LPNVFVFINDEXEDPRIM fnFillModeIndexedTriangle[] =
{
    0,
    nvPointIndexedTriangle,
    nvWireframeIndexedTriangle,
    nvSolidIndexedTriangle
};

LPNVFVFDRAWPRIM fnFillModeNonIndexedTriangle[] =
{
    0,
    nvPointNonIndexedTriangle,
    nvWireframeNonIndexedTriangle,
    nvSolidNonIndexedTriangle
};

DWORD nvDrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    WORD                i;
    WORD                wCommandCount;
    WORD                wIndex, wCount;
    BOOL                bFilterChanged;
    BOOL                bTSSChanged;
    BOOL                bLoadFVFVertex;
    DWORD               dwMagFilter;
    DWORD               dwMinFilter;
    DWORD               dwStage;
    DWORD               dwState;
    DWORD               dwValue;
    DWORD               dwVertexType;
    DWORD               dwVertexStride;
    DWORD               dwUVCount;
    DWORD               dwCommandBufferStart;
    DWORD               dwCommandBufferEnd;
    DWORD               dwCommandBufferOffset;
    DWORD               dwCommandBufferLength;
    DWORD               dwVertexBufferStart;
    DWORD               dwVertexBufferOffset;
    DWORD               dwVertexBufferLength;
    HRESULT             ddrval;
    LPBYTE              lpPrim, lpFVFVertices;
    LPD3DHAL_DP2COMMAND lpCommands, lpResumeCommands;
    LPD3DTLVERTEX       lpVertices;

#ifdef NV_NULL_DRIVER
    pdp2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER
#ifdef NV_PROFILE
    NVP_START (NVP_T_DP2);
#endif
#ifdef NV_STATS
    {
        extern DWORD dwDP2CallCount;
        dwDP2CallCount ++;
    }
#endif

    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvDrawPrimitives2 - hContext = %08lx", pdp2d->dwhContext);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();

    /*
     * check aa semantics
     */
    NV_AA_SEMANTICS_CHECK(pCurrentContext);

    /*
     * Get address of command buffer.
     */
    if (!(dwCommandBufferStart = (DWORD)pdp2d->lpDDCommands->lpGbl->fpVidMem))
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        pdp2d->ddrval = DDERR_CANTLOCKSURFACE;
        return (DDHAL_DRIVER_HANDLED);
    }
    dwCommandBufferOffset = pdp2d->dwCommandOffset;
    dwCommandBufferLength = pdp2d->dwCommandLength;
    dwCommandBufferEnd    = dwCommandBufferStart + dwCommandBufferOffset + dwCommandBufferLength;

    /*
     * Calculate pointer to the first command to be processed.
     */
    lpCommands = (LPD3DHAL_DP2COMMAND)(dwCommandBufferStart + dwCommandBufferOffset);

    /*
     * Get address of vertex buffer.
     */
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
        dwVertexBufferStart = (DWORD)pdp2d->lpVertices;
    else
        dwVertexBufferStart = (DWORD)pdp2d->lpDDVertex->lpGbl->fpVidMem;
    if (!dwVertexBufferStart)
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        pdp2d->ddrval = DDERR_CANTLOCKSURFACE;
        return (DDHAL_DRIVER_HANDLED);
    }
    dwVertexBufferOffset = pdp2d->dwVertexOffset;
    dwVertexBufferLength = pdp2d->dwVertexLength;
    lpVertices = (LPD3DTLVERTEX)(dwVertexBufferStart + dwVertexBufferOffset);

    /*
     * Get local copy of vertex flags
     */
    dwVertexType = pdp2d->dwVertexType;
    if (dwVertexType == D3DFVF_TLVERTEX)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Type = TLVERTEX");
    else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Type = %08lx", dwVertexType);

    /*
     * check if cached & short circuit fvfData calculation
     *  bLoadFVFVertex becomes TRUE when we need to recalc
     *  it will not go TRUE for TL verts - instead we just copy from a preset table
     */
    CHECK_FVF_DATA_AND_LOAD_TL (fvfData,dwVertexType,dwVertexStride,bLoadFVFVertex);

    /*
     * Calculate fvf data only if needed
     */
    if (bLoadFVFVertex)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - Re-Calculate FVF Data.");

        /*
         * Make sure there aren't any totally invalid FVF bits set.
         */
        if (dwVertexType & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 | D3DFVF_NORMAL))
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * Calculate the number of texture coordinates present.
         * On NV4 we can accept 2 sets of UV coordinates
         * bdw: this is a usage restriction - the flex vertex is allowed to contain more
         */
        dwUVCount = (dwVertexType & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        /*
        if (dwUVCount > NV_UV_COORDINATE_COUNT_MAX)
        {
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }
        */

        /*
         * Vertex always has to have XYZ components.
         */
        if ((dwVertexType & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0)
        {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
            pdp2d->dwErrorOffset = dwCommandBufferOffset;
            return (DDHAL_DRIVER_HANDLED);
        }
        dwVertexStride = sizeof(D3DVALUE) * 3;

        /*
         * Set up masks and offsets for each component of the FVF.
         * The location to get the vertex component data from will be calculated as follows:
         *      (lpVertices & ComponentMask) + ComponentOffset;
         * When ComponentMask == 0xFFFFFFFF, ComponentOffset will be an offset from the start
         * of the vertex data to the specific component.
         * When ComponentMask == 0x00000000, ComponentOffset will be a pointer to the default vertex data.
         *
         * FVF's must always have XYZ components.
         */
        fvfData.dwXYZMask   = 0xFFFFFFFF;
        fvfData.dwXYZOffset = 0;

        /*
         * Run down the variable vertex component list in the order they
         * will appear in the vertex data.
         */
        if (dwVertexType & D3DFVF_XYZRHW)
        {
            fvfData.dwRHWMask    = 0xFFFFFFFF;
            fvfData.dwRHWOffset  = dwVertexStride;
            dwVertexStride      += sizeof(D3DVALUE);
        }
        else
        {
            /*
             * No RHW specified, get it from the default vertex structure.
             */
            fvfData.dwRHWMask    = 0x00000000;
            fvfData.dwRHWOffset  = (DWORD)&tlvDefault.rhw;
        }
        if (dwVertexType & D3DFVF_DIFFUSE)
        {
            fvfData.dwARGBMask    = 0xFFFFFFFF;
            fvfData.dwARGBOffset  = dwVertexStride;
            dwVertexStride += sizeof(D3DCOLOR);
        }
        else
        {
            /*
             * No Diffuse Color specified, get it from the default vertex structure.
             */
            fvfData.dwARGBMask    = 0x00000000;
            fvfData.dwARGBOffset  = (DWORD)&tlvDefault.color;
        }
        if (dwVertexType & D3DFVF_SPECULAR)
        {
            fvfData.dwSpecularMask    = 0xFFFFFFFF;
            fvfData.dwSpecularOffset  = dwVertexStride;
            dwVertexStride           += sizeof(D3DCOLOR);
        }
        else
        {
            /*
             * No Specular component specified, get it from the default vertex structure.
             */
            fvfData.dwSpecularMask    = 0x00000000;
            fvfData.dwSpecularOffset  = (DWORD)&tlvDefault.specular;
        }
        if (dwUVCount)
        {
            fvfData.dwUVMask    = 0xFFFFFFFF;
            fvfData.dwUVOffset  = dwVertexStride;
            dwVertexStride     += (sizeof(D3DVALUE) * 2) * dwUVCount;
        }
        else
        {
            /*
             * No UV components specified, get it from the default vertex structure.
             */
            fvfData.dwUVMask    = 0x00000000;
            fvfData.dwUVOffset  = (DWORD)&tlvDefault.tu;
        }

        /*
         * Fill in rest of FVF data structure.
         */
        fvfData.dwVertexType   = dwVertexType;
        fvfData.dwVertexStride = dwVertexStride;
        fvfData.dwUVCount      = dwUVCount;
    }
    else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:nvDrawPrimitives2 - FVF Data already loaded.");

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetRenderTargetContexts + sizeSetRenderTarget));
#endif  // CACHE_FREECOUNT

    /*
     * If the surface has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * If the spare subchannel does not contain the correct triangle
     * object, force an object state load.
     */
    if (!pCurrentContext->bUseDX6Class)
    {
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);
    }
    else
    {
        if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
         || (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE))
            NV_FORCE_TRI_SETUP(pCurrentContext);
    }

    /*
     * Parse the command buffer.
     */
    while ((DWORD)lpCommands < dwCommandBufferEnd)
    {
        wCommandCount = lpCommands->wPrimitiveCount;
        lpPrim        = (LPBYTE)lpCommands + sizeof(D3DHAL_DP2COMMAND);
        dbgDisplayDrawPrimitives2Info(lpCommands->bCommand, wCommandCount);
        switch (lpCommands->bCommand)
        {
            /*
             * Point Lists.
             */
            case D3DDP2OP_POINTS:
#ifdef  WINNT
                {
                    DWORD               i;
                    D3DHAL_DP2POINTS   *lpPrimCheck;

                    lpPrimCheck = (D3DHAL_DP2POINTS *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex = lpPrimCheck->wVStart;
                        wCount = lpPrimCheck->wCount;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                        CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + wCount - 1);
                        lpPrimCheck++;
                    }
                }
#endif
                for (i = 0; i < wCommandCount; i++)
                {
                    if (!pCurrentContext->bUseDX6Class)
                    {
                        if (dwVertexType == D3DFVF_TLVERTEX)
                            nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
                        else
                        {
                            lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * dwVertexStride);
                            nvFVFDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, lpFVFVertices);
                        }
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, lpFVFVertices);
                    }
                    lpPrim += sizeof(D3DHAL_DP2POINTS);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2POINTS, wCommandCount, 0);
                break;
            /*
             * Line Lists.
             *
             *
             * Old Execute Buffer RenderPrimitive style indexed line list.
             */
            case D3DDP2OP_INDEXEDLINELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2INDEXEDLINELIST  *lpPrimCheck;
                    DWORD                       i;

                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINELIST *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV1);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV2);
                        lpPrimCheck++;
                    }
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, lpVertices);
                    else
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, (LPBYTE)lpVertices);
                }
                else
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)lpPrim, 2, (LPBYTE)lpVertices);
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDLINELIST, wCommandCount, 0);
                break;
            /*
             * Triangle lists.
             *
             *
             * Old style RenderPrimitive Execute Buffer entry.
             */
            case D3DDP2OP_INDEXEDTRIANGLELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2INDEXEDTRIANGLELIST  *lpPrimCheck;
                    DWORD                           i;

                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLELIST *)lpPrim;
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV1);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV2);
                        CHECK_DATABUF_LIMITS(pdp2d, lpPrimCheck->wV3);
                        lpPrimCheck++;
                    }
                }
#endif
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)lpPrim, LEGACY_STRIDES, (LPBYTE)lpVertices);
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);
                break;
            /*
             * Render State change.
             */
            case D3DDP2OP_RENDERSTATE:
                /*
                 * Run through the render state list.
                 */
                for (i = 0; i < wCommandCount; i++)
                {
                    DWORD   dwStateType, dwStateValue;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);

                    dwStateType  = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
                    dwStateValue = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState;
                    lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);

                    if (IS_OVERRIDE(dwStateType))
                    {
                        DWORD override = GET_OVERRIDE(dwStateType);
                        if (dwStateValue)
                        {
                            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2 - setting override for state %08lx", override);
                            STATESET_SET(pCurrentContext->overrides, override);
                        }
                        else
                        {
                            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2, clearing override for state %08lx", override);
                            STATESET_CLEAR(pCurrentContext->overrides, override);
                        }
                        continue;
                    }
                    if (STATESET_ISSET(pCurrentContext->overrides, dwStateType))
                    {
                        DPF_LEVEL (NVDBG_LEVEL_INFO, "nvDrawPrimitives2, state %08lx is overridden, ignoring", dwStateType);
                        continue;
                    }
                    if (pdp2d->lpdwRStates)
                        pdp2d->lpdwRStates[dwStateType] = dwStateValue;
                    nvSetContextState(dwStateType, dwStateValue, &ddrval);

                    /*
                     * Want to show that the application has set texturemapblend renderstate even if
                     * it's the same as the last time.
                     */
                    if (dwStateType == D3DRENDERSTATE_TEXTUREMAPBLEND)
                    {
                        /*
                         * If this is the first call to set TBLEND, then we want to set bUseTBlendSettings to FALSE since
                         * it is just an initialization call and doesn't count as an application usage.
                         * All subsequent calls should set bUseTBlendSettings to TRUE.
                         * Upon the first entry, NV_CONTEXT_TBLEND_UNINITIALIZED will be set.  All subseqent calls it will be
                         * cleared.
                         */
                        pCurrentContext->dwContextFlags &= ~NV_CONTEXT_TBLEND_UNINITIALIZED;
                        pCurrentContext->bUseTBlendSettings = !(pCurrentContext->dwContextFlags & NV_CONTEXT_TBLEND_UNINITIALIZED);
                    }

                }
                /*
                 * If the state has changed force a hardware state load.
                 */
                if (pCurrentContext->dwStateChange)
                {
                    /*
                     * If this is a DX6 application, then force hardware steup through
                     * the DX6 hardware setup routine, even if there is only one stage.
                     */
                    pCurrentContext->bUseDX6Class     = (pCurrentContext->dwDXVersionLevel >= APP_VERSION_DX6);
                    NV_FORCE_TRI_SETUP(pCurrentContext);
                }
                /*
                 * Determine the fog table mode based on if fog is enabled and the
                 * selected fog table mode.  A computed value of 0 = vertex or no fog,
                 * non-zero values indicate the fog table mode.
                 */
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2RENDERSTATE, wCommandCount, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed line list.
             */
            case D3DDP2OP_LINELIST:
#ifdef  WINNT
                {
                    D3DHAL_DP2LINELIST  *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2LINELIST *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + (2 * wCommandCount) - 1);
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                    {
                        lpPrim = (LPBYTE)&lpVertices[((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart];
                        nvDrawLine((DWORD)wCommandCount, 2, (LPD3DTLVERTEX)lpPrim);
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawLine((DWORD)wCommandCount, 2, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart * dwVertexStride);
                    nvFVFDrawLine((DWORD)wCommandCount, 2, lpFVFVertices);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2LINELIST, 1, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed line strip.
             */
            case D3DDP2OP_LINESTRIP:
#ifdef  WINNT
                {
                    D3DHAL_DP2LINESTRIP *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2LINESTRIP *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount);
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                    {
                        lpPrim = (LPBYTE)&lpVertices[((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart];
                        nvDrawLine((DWORD)wCommandCount, 1, (LPD3DTLVERTEX)lpPrim);
                    }
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart * dwVertexStride);
                        nvFVFDrawLine((DWORD)wCommandCount, 1, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2LINESTRIP)lpPrim)->wVStart * dwVertexStride);
                    nvFVFDrawLine((DWORD)wCommandCount, 1, lpFVFVertices);
                }
                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2LINESTRIP, 1, 0);
                break;
            /*
             * Line Strips.
             *
             *
             * DX5 DrawOneIndexedPrimitive style indexed line strip.
             */
            case D3DDP2OP_INDEXEDLINESTRIP:
#ifdef  WINNT
                {
                    DWORD                       i;
                    WORD                        wIndexBase, wIndex1, wIndex2;
                    D3DHAL_DP2INDEXEDLINESTRIP *lpPrimCheck;
                    LPBYTE                      lpV1, lpV2;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((D3DHAL_DP2STARTVERTEX *)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINESTRIP *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex1 = lpPrimCheck->wV[0];
                    wIndex2 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        if (i % 2)
                            wIndex2 = lpPrimCheck->wV[1];
                        else
                        {
                            lpPrimCheck++;
                            CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                            wIndex2 = lpPrimCheck->wV[0];
                        }
                    }
                }
#endif

                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart]);
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 1, lpFVFVertices);
                }

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 1, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed triangle list.
             */
            case D3DDP2OP_TRIANGLELIST:
#ifdef  WINNT
                {
                    DWORD                   i;
                    D3DHAL_DP2TRIANGLELIST *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    lpPrimCheck = (D3DHAL_DP2TRIANGLELIST *)lpPrim;
                    wIndex = lpPrimCheck->wVStart;

                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, (LONG)wIndex + 3 * wCommandCount - 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLELIST)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, LIST_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLELIST, 1, 0);
                break;
            /*
             * DX5 DrawOnePrimitive style non-indexed triangle strip.
             */
            case D3DDP2OP_TRIANGLESTRIP:
#ifdef  WINNT
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndex = ((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount + 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, STRIP_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
                break;
            /*
             * Triangle strips.
             *
             *
             * DX5 DrawOneIndexedPrimitive style indexed triangle strip.
             */
            case D3DDP2OP_INDEXEDTRIANGLESTRIP:
#ifdef  WINNT
                {
                    WORD                            wIndexBase, wIndex0, wIndex1, wIndex2;
                    DWORD                           i;
                    D3DHAL_DP2INDEXEDTRIANGLESTRIP *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLESTRIP *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex0 = lpPrimCheck->wV[0];
                    wIndex1 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex0);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex2 = lpPrimCheck->wV[2];
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck = (LPBYTE)lpPrimCheck + sizeof(WORD);
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), STRIP_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * Triangle fans.
             *
             * DX5 DrawOnePrimitive style non-indexed triangle fan.
             */
            case D3DDP2OP_TRIANGLEFAN:
#ifdef  WINNT
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndex = ((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart;
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndex + wCommandCount + 1);
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart * dwVertexStride);
                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, FAN_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TRIANGLEFAN, 1, 0);
                break;
            /*
             * DX5 DrawOneIndexedPrimitive style indexed triangle fan.
             */
            case D3DDP2OP_INDEXEDTRIANGLEFAN:
#ifdef  WINNT
                {
                    WORD                            wIndexBase, wIndex0, wIndex1, wIndex2;
                    DWORD                           i;
                    D3DHAL_DP2INDEXEDTRIANGLEFAN   *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLEFAN *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                    wIndex0 = lpPrimCheck->wV[0];
                    wIndex1 = lpPrimCheck->wV[1];
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex0);
                    CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex2 = lpPrimCheck->wV[2];
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck = (LPBYTE)lpPrimCheck + sizeof(WORD);
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), FAN_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * Inline command buffer non-indexed triangle fans.
             * Similar to DX5 style DrawOnePrimitive.
             */
            case D3DDP2OP_TRIANGLEFAN_IMM:
                /*
                 * Skip over edge flags to get pointer to start of vertex list.
                 * Also, vertices are DWORD aligned, so just make sure that the
                 * alignment is correct.
                 */
                lpPrim += sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
                lpPrim = (LPBYTE)(((DWORD)lpPrim + 3) & ~3);

#ifdef  WINNT
                {
                    LPBYTE  lpV0, lpV1, lpV2;
                    lpV0 = lpPrim;
                    lpV1 = lpV0 + dwVertexStride;
                    lpV2 = lpV1 + dwVertexStride;
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV0);
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV1);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpV2);
                        lpV1 = lpV2;
                        lpV2 += dwVertexStride;
                    }
                }
#endif

                fnFillModeNonIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]](wCommandCount, FAN_STRIDES, lpPrim);

                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, BYTE, ((wCommandCount + 2) * dwVertexStride), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
                /*
                 * Realign next command since vertices are dword aligned
                 * and store # of primitives before affecting the pointer
                 */
                lpCommands = (LPD3DHAL_DP2COMMAND)(( ((DWORD)lpCommands) + 3 ) & ~ 3);
                break;
            /*
             * DX5 DrawOnePrimitive style in-line command buffer non-indexed line list.
             */
            case D3DDP2OP_LINELIST_IMM:
                /*
                 * Make sure command buffer is DWORD aligned for immediate line list vertices.
                 */
                lpPrim = (LPBYTE)(((DWORD)lpPrim + 3) & ~3);
#ifdef  WINNT
                {
                    LPBYTE  lpV0, lpV1;

                    lpV0 = lpPrim;
                    lpV1 = lpV0 + dwVertexStride;
                    CHECK_CMDBUF_LIMITS(pdp2d, lpV0);
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpV1);
                        lpV0 = lpV1;
                        lpV1 += dwVertexStride;
                    }
                }
#endif

                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvDrawLine((DWORD)wCommandCount, 2, (LPD3DTLVERTEX)lpPrim);
                    else
                        nvFVFDrawLine((DWORD)wCommandCount, 2, lpPrim);
                }
                else
                    nvFVFDrawLine((DWORD)wCommandCount, 2, lpPrim);

                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, BYTE, ((wCommandCount + 1) * dwVertexStride), 0);
                /*
                 * Realign next command since vertices are dword aligned
                 */
                lpCommands = (LPD3DHAL_DP2COMMAND)(( ((DWORD)lpCommands) + 3 ) & ~ 3);
                break;
            /*
             * Change the texture stage state.
             */
            case D3DDP2OP_TEXTURESTAGESTATE:
                bFilterChanged = FALSE;
                bTSSChanged = FALSE;

                /*
                 * Display the texture stage state changes.
                 */
                for (i = 0; i < wCommandCount; i++)
                {
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);

                    dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
                    dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
                    dwValue = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue;
                    if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
                        DPF("Texture Stage State Change - Stage: %ld, Type: %ld, State: %ld", dwStage, dwState, dwValue);
                    switch (dwState)
                    {
                        // D3DTSS_TEXTUREMAP
                        case 0:
                            /*
                             * Turn the texture handle into a texture pointer.
                             */
                            // test with default texture -paul

                            if (dwValue)
                            {
                                dwValue |= 0x80000000;
                                if (pCurrentContext->tssState[dwStage].dwTextureMap != dwValue)
                                {
                                    pCurrentContext->tssState[dwStage].dwTextureMap = dwValue;
                                    bTSSChanged = TRUE;
                                }
                            }
                            else
                            {
                                if (pCurrentContext->tssState[dwStage].dwTextureMap)
                                {
                                    pCurrentContext->tssState[dwStage].dwTextureMap = dwValue;
                                    bTSSChanged = TRUE;
                                }
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREHANDLE, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESS:
                            if ((pCurrentContext->tssState[dwStage].dwAddressU != dwValue)
                             || (pCurrentContext->tssState[dwStage].dwAddressV != dwValue))
                            {
                                pCurrentContext->tssState[dwStage].dwAddressU = dwValue;
                                pCurrentContext->tssState[dwStage].dwAddressV = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESS, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESSU:
                            if (pCurrentContext->tssState[dwStage].dwAddressU != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAddressU = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue, &ddrval);
                            break;
                        case D3DTSS_ADDRESSV:
                            if (pCurrentContext->tssState[dwStage].dwAddressV != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAddressV = dwValue;
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_TEXTUREADDRESSV, ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue, &ddrval);
                            break;
                        case D3DTSS_MAGFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMagFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMagFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_MINFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMinFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMinFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_MIPFILTER:
                            if (pCurrentContext->tssState[dwStage].dwMipFilter != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMipFilter = dwValue;
                                bTSSChanged = TRUE;
                            }
                            if (dwStage == 0)
                                bFilterChanged = TRUE;
                            break;
                        case D3DTSS_COLOROP:
                            if (pCurrentContext->tssState[dwStage].dwColorOp != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorOp = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_COLORARG1:
                            if (pCurrentContext->tssState[dwStage].dwColorArg1 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorArg1 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_COLORARG2:
                            if (pCurrentContext->tssState[dwStage].dwColorArg2 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwColorArg2 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAOP:
                            if (pCurrentContext->tssState[dwStage].dwAlphaOp != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaOp = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAARG1:
                            if (pCurrentContext->tssState[dwStage].dwAlphaArg1 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaArg1 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_ALPHAARG2:
                            if (pCurrentContext->tssState[dwStage].dwAlphaArg2 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwAlphaArg2 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            pCurrentContext->bUseTBlendSettings = FALSE;
                            break;
                        case D3DTSS_BUMPENVMAT00:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat00 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat00 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT01:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat01 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat01 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT10:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat10 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat10 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVMAT11:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvMat11 != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvMat11 = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_TEXCOORDINDEX:
                            if (pCurrentContext->tssState[dwStage].dwTexCoordIndex != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwTexCoordIndex = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BORDERCOLOR:
                            if (pCurrentContext->tssState[dwStage].dwBorderColor != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBorderColor = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_MIPMAPLODBIAS:
                            if (pCurrentContext->tssState[dwStage].dwMipMapLODBias != dwValue)
                            {
                                /*
                                 * Convert LODBIAS value to NV hardware value.
                                 * Here is the true meaning of this value as implemented by the reference rasterizer:
                                 *    Floating-point D3DVALUE value used to change the level of detail (LOD) bias.
                                 *    This value offsets the value of the mipmap level that is computed by trilinear
                                 *    texturing. It is usually in the range  -1.0 to 1.0; the default value is 0.0.
                                 *    Each unit bias (+/-1.0) biases the selection by exactly one mipmap level.
                                 *    A negative bias will cause the use of larger mipmap levels, resulting in a
                                 *    sharper but more aliased image.
                                 *    A positive bias will cause the use of smaller mipmap levels, resulting in a
                                 *    blurrier image.
                                 *    Applying a positive bias also results in the referencing of a smaller amount
                                 *    of texture data, which can boost performance on some systems.
                                 */
                                pCurrentContext->tssState[dwStage].dwMipMapLODBias = dwValue;
                                if (!dwValue)
                                    pCurrentContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
                                else
                                {
                                    D3DVALUE dvLODBias;
                                    dvLODBias = *((D3DVALUE *)&dwValue);
                                    if (dvLODBias > 15.0f)
                                        dvLODBias = 15.0f;
                                    else if (dvLODBias < -15.0f)
                                        dvLODBias = -15.0f;
                                    /*
                                     * Convert the floating point value from D3D into a 5.3 NV value.
                                     * 0x08 == 1.0f
                                     */
                                    dvLODBias *= 8.0;
                                    pCurrentContext->tssState[dwStage].bLODBias = (BYTE)((long)dvLODBias & 0x000000FF);
                                }
                                bTSSChanged = TRUE;
                            }
                            /*
                             * For texture stage 0, propogate the change to DX5 class renderstate.
                             */
                            if (dwStage == 0)
                                nvSetContextState(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue, &ddrval);
                            break;
                        case D3DTSS_MAXMIPLEVEL:
                            if (pCurrentContext->tssState[dwStage].dwMaxMipLevel != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMaxMipLevel = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_MAXANISOTROPY:
                            if (pCurrentContext->tssState[dwStage].dwMaxAnisotropy != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwMaxAnisotropy = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVLSCALE:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvlScale != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvlScale = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        case D3DTSS_BUMPENVLOFFSET:
                            if (pCurrentContext->tssState[dwStage].dwBumpEnvlOffset != dwValue)
                            {
                                pCurrentContext->tssState[dwStage].dwBumpEnvlOffset = dwValue;
                                bTSSChanged = TRUE;
                            }
                            break;
                        default:
                            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unimplemented Texture Stage State!!!  Stage: %ld, Type: %ld, State: %ld",
                                      dwStage, dwState, dwValue);
                            dbgD3DError();
                            break;
                    }
                    lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
                }
                if (bFilterChanged)
                {
                    /*
                     * Calculate equivalent TEXTUREMIN and TEXTUREMAG bits from MINFILTER, MAGFILTER and MIPFILTER.
                     */
                    switch (pCurrentContext->tssState[0].dwMagFilter)
                    {
                        case D3DTFG_POINT:
                            dwMagFilter = D3DFILTER_NEAREST;
                            break;
                        case D3DTFG_LINEAR:
                            dwMagFilter = D3DFILTER_LINEAR;
                            break;
                        default:
                            dwMagFilter = D3DFILTER_LINEAR;
                            break;
                    }

                    if (pCurrentContext->tssState[0].dwMipFilter == D3DTFP_NONE)
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_NEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_LINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_LINEAR;
                                break;
                        }
                    }
                    else if (pCurrentContext->tssState[0].dwMipFilter == D3DTFP_POINT)
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_MIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_MIPLINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_MIPLINEAR;
                                break;
                        }
                    }
                    else
                    {
                        switch (pCurrentContext->tssState[0].dwMinFilter)
                        {
                            case D3DTFN_POINT:
                                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                                break;
                            default:
                                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                                break;
                        }
                    }
                    nvSetContextState(D3DRENDERSTATE_TEXTUREMAG, dwMagFilter, &ddrval);
                    nvSetContextState(D3DRENDERSTATE_TEXTUREMIN, dwMinFilter, &ddrval);
                }
                /*
                 * If the state has changed force a hardware state load.
                 */
                if (bTSSChanged)
                {
                    /*
                     * If this is a DX6 application, then force hardware steup through
                     * the DX6 hardware setup routine, even if there is only one stage.
                     */
                    pCurrentContext->bUseDX6Class     = (pCurrentContext->dwDXVersionLevel >= APP_VERSION_DX6);
                    pCurrentContext->dwStateChange    = TRUE;
                    NV_FORCE_TRI_SETUP(pCurrentContext);
                }
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2TEXTURESTAGESTATE, wCommandCount, 0);
                break;
            /*
             * DX5 style DrawOneIndexedPrimitive indexed triangle strip.
             */
            case D3DDP2OP_INDEXEDTRIANGLELIST2:
#ifdef  WINNT
                {
                    WORD    wIndexBase, wIndex1, wIndex2, wIndex3;
                    DWORD   i;
                    D3DHAL_DP2INDEXEDTRIANGLELIST2 *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDTRIANGLELIST2 *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex1 = lpPrimCheck->wV1;
                        wIndex2 = lpPrimCheck->wV2;
                        wIndex3 = lpPrimCheck->wV3;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex3);
                        lpPrimCheck++;
                    }
                }
#endif
                lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                fnFillModeIndexedTriangle[pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), LIST_STRIDES, lpFVFVertices);

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             * DX5 DrawOneIndexedPrimitive style indexed line list.
             */
            case D3DDP2OP_INDEXEDLINELIST2:
#ifdef  WINNT
                {
                    WORD    wIndexBase, wIndex1, wIndex2;
                    DWORD   i;
                    D3DHAL_DP2INDEXEDLINELIST *lpPrimCheck;

                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim);
                    wIndexBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
                    lpPrimCheck = (D3DHAL_DP2INDEXEDLINELIST *)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX));
                    for (i = 0; i < wCommandCount; i++)
                    {
                        CHECK_CMDBUF_LIMITS(pdp2d, lpPrimCheck);
                        wIndex1 = lpPrimCheck->wV1;
                        wIndex2 = lpPrimCheck->wV2;
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex1);
                        CHECK_DATABUF_LIMITS(pdp2d, wIndexBase + wIndex2);
                        lpPrimCheck++;
                    }
                }
#endif
                if (!pCurrentContext->bUseDX6Class)
                {
                    if (dwVertexType == D3DFVF_TLVERTEX)
                        nvIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, (LPD3DTLVERTEX)&lpVertices[((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart]);
                    else
                    {
                        lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                        nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, lpFVFVertices);
                    }
                }
                else
                {
                    lpFVFVertices = (LPBYTE)lpVertices + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * dwVertexStride);
                    nvFVFIndexedLine((DWORD)wCommandCount, (LPWORD)(lpPrim + sizeof(D3DHAL_DP2STARTVERTEX)), 2, lpFVFVertices);
                }

                /*
                 * Update the put offset.
                 */
                //nvStartDmaBuffer(); // For some reason, taking these lines out caused dropped triangles, especially in 3D winbench!  Why???
                dbgFlushDmaBuffers(pCurrentContext);
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2INDEXEDLINELIST, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
                break;
            /*
             *
             */
            case D3DDP2OP_VIEWPORTINFO:
            {
                WORD    wX      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX & 0x0000FFFF);
                WORD    wY      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY & 0x0000FFFF);
                WORD    wWidth  = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth & 0x0000FFFF);
                WORD    wHeight = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight & 0x0000FFFF);
                if ((pCurrentContext->surfaceViewport.clipHorizontal.wX != wX)
                 || (pCurrentContext->surfaceViewport.clipVertical.wY != wY)
                 || (pCurrentContext->surfaceViewport.clipHorizontal.wWidth != wWidth)
                 || (pCurrentContext->surfaceViewport.clipVertical.wHeight != wHeight))
                {
                    pCurrentContext->surfaceViewport.clipHorizontal.wX     = wX;
                    pCurrentContext->surfaceViewport.clipVertical.wY       = wY;
                    pCurrentContext->surfaceViewport.clipHorizontal.wWidth = wWidth;
                    pCurrentContext->surfaceViewport.clipVertical.wHeight  = wHeight;
                    nvSetD3DSurfaceViewport(pCurrentContext);
                }
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2VIEWPORTINFO, 1, 0);
                break;
            }
            /*
             *
             */
            case D3DDP2OP_WINFO:
                pCurrentContext->dvWNear = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear;
                pCurrentContext->dvWFar  = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                /*
                 * If the WFar value is 0.0, then set a default based on the z-buffer precision.
                 */
                if (pCurrentContext->dvWFar == 0.0f)
                {
                    pCurrentContext->dvWNear = 0.0f;
                    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
                     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) | DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
                    {
                        pCurrentContext->dvWFar  = (D3DVALUE)(1 << 16);
                    }
                    else
                    {
                        pCurrentContext->dvWFar  = (D3DVALUE)(1 << 24);
                    }
                }
//                pCurrentContext->dvRWFar = 1.0f / ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                pCurrentContext->dvRWFar = ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar;
                NEXTINSTRUCTION(lpCommands, D3DHAL_DP2WINFO, 1, 0);
                break;

            /*
             * Unknown command.  Pass it to the Unknown Command Callback for handling.
             */
            default:
                if (fnD3DParseUnknownCommandCallback)
                {
                    ddrval=fnD3DParseUnknownCommandCallback(lpCommands, &lpResumeCommands);
                    if (ddrval != DD_OK)
                    {
                        nvStartDmaBuffer (TRUE);
                        pdp2d->ddrval = ddrval;
                        pdp2d->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;
                        NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
                        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
                        NVP_STOP (NVP_T_DP2);
                        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    /*
                     * Set the resume address.
                     */
                    lpCommands = lpResumeCommands;
                }
                else
                {
                    nvStartDmaBuffer (TRUE);
                    pdp2d->ddrval = D3DERR_COMMAND_UNPARSED;
                    pdp2d->dwErrorOffset = (DWORD)lpCommands - dwCommandBufferStart;
                    NV_D3D_GLOBAL_SAVE();
#ifdef  CACHE_FREECOUNT
                    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
                    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
                    NVP_STOP (NVP_T_DP2);
                    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                    return (DDHAL_DRIVER_HANDLED);
                }
                break;
        }
    }
    nvStartDmaBuffer (TRUE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    NV_D3D_GLOBAL_SAVE();
    dbgFlushDDI(pCurrentContext);

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_DP2);
    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif

    pdp2d->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // NVD3D_DX6
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4state.c ===
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4STATE.C                                                        *
*   NV4 state management routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               04/18/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3d.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dblnd.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nv4dreg.h"

#ifdef NV_CONTROLTRAFFIC
DWORD dwCTTable[] =
{
    0,
    D3DCMP_NEVER,
    D3DCMP_GREATER,
    D3DCMP_EQUAL,
    D3DCMP_GREATEREQUAL,
    D3DCMP_LESS,
    D3DCMP_NOTEQUAL,
    D3DCMP_LESSEQUAL,
    D3DCMP_ALWAYS,
};

__inline DWORD CTFunc
(
    DWORD dw
)
{
    if ((pCurrentContext->dwCTFlags & (NV_CT_ENABLED | NV_CT_FRONT)) == NV_CT_ENABLED)
    {
        return dwCTTable[dw];
    }
    else
    {
        return dw;
    }
}

#endif //NV_CONTROLTRAFFIC

/*
 * Send suface setup to the hardware.
 */
void nvSetD3DSurfaceState
(
    PNVD3DCONTEXT   pContext
)
{
    /*
     * Only need to update the surface if it has changed since the last render call
     * or the global clip state has changed.
     */
    if ((pDriverData->lpLast3DSurfaceRendered != pContext->lpLcl->lpGbl->fpVidMem)
     || (pDriverData->TwoDRenderingOccurred))
    {
        /*
         * Make sure the context has the correct suface information in it.
         */
        if (dbgFrontRender)
        {
            pContext->dwSurfaceAddr            = pDriverData->CurrentVisibleSurfaceAddress;
            pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pDriverData->CurrentVisibleSurfaceAddress);
            pContext->surfacePitch.wColorPitch = (WORD)dbgFrontRenderPitch;
        }
        else
        {
            pContext->dwSurfaceAddr            = VIDMEM_ADDR(pContext->lpLcl->lpGbl->fpVidMem);
            pContext->dwSurfaceOffset          = VIDMEM_OFFSET(pContext->lpLcl->lpGbl->fpVidMem);
            pContext->surfacePitch.wColorPitch = (WORD)pContext->lpLcl->lpGbl->lPitch;
        }
        if (pContext->lpLclZ)
        {
            /*
             * I've seen it happen where the location of the z-buffer will actually
             * change without without the context being destroyed or the set render
             * target call happening. So it's neccessary to make sure that we have the
             * correct z-buffer address and offset here.
             */
            pContext->ZBufferAddr             = VIDMEM_ADDR(pContext->lpLclZ->lpGbl->fpVidMem);
            pContext->ZBufferOffset           = VIDMEM_OFFSET(pContext->lpLclZ->lpGbl->fpVidMem);
            pContext->surfacePitch.wZetaPitch = (WORD)pContext->lpLclZ->lpGbl->lPitch;
        }
        /*
         * Send to hardware
         */
        while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetRenderTargetContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        /*
         * AA overrides (AA is disabled when dwAntiAliasFlags == 0)
         */
        if (pContext->dwAntiAliasFlags & AA_MODE_SINGLECHUNK)
        {
            /*
             * single chunk super sampled aa
             */
            PNVAACONTEXT pCtx = pContext->pAAContext;
            DWORD clip  = (pCtx->dwSuperHeight << 16)
                        |  pCtx->dwSuperWidth;
            DWORD pitch = (pCtx->dwSuperZPitch << 16)
                        |  pCtx->dwSuperPitch;
            while (nvFreeCount < sizeSetRenderTarget2)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
            nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                 pContext->dwSurfaceFormat, clip,
                                 pitch,  pCtx->dwSuperOffset,
                                 pCtx->dwSuperZOffset);
        }
        else
        if (pContext->dwAntiAliasFlags & AA_RENDER)
        {
            /*
             * multi chunk super sampled aa
             */
            PNVAACONTEXT pCtx = pContext->pAAContext;
            DWORD clip  = (pCtx->dwSuperHeight << 16)
                        |  pCtx->dwSuperWidth;
            DWORD pitch = (pContext->surfacePitch.wZetaPitch << 16)
                        |  pCtx->dwSuperPitch;
            while (nvFreeCount < sizeSetRenderTarget2)
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
            nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                 pContext->dwSurfaceFormat, clip,
                                 pitch,  pCtx->dwSuperOffset,
                                 pContext->ZBufferOffset);
        }
        else
        /*
         * Normal case
         */
        {
            if (!(pContext->surfaceViewport.clipHorizontal.wX)
             && !(pContext->surfaceViewport.clipVertical.wY))
            {
                DWORD clip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16)
                           | pContext->surfaceViewport.clipHorizontal.wWidth;
                while (nvFreeCount < sizeSetRenderTarget2)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget2);
                nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                     pContext->dwSurfaceFormat, clip,
                                     pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                     pContext->ZBufferOffset);
            }
            else
            {
#if 0
                /*
                 * If this didn't cause an exception to the RM, this is how I'd program this.
                 */
                while (nvFreeCount < sizeSetRenderTarget)
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetRenderTarget);
                nvglSetRenderTarget(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                    pContext->surfaceViewport.dwClipHorizontal, pContext->surfaceViewport.dwClipVertical,
                                    pContext->dwSurfaceFormat,
                                    pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                    pContext->ZBufferOffset);
#else
                /*
                 * Until programming the clipped viewport doesn't cause an RM exception,
                 * program it this way.
                 */
                DWORD clip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16)
                           | pContext->surfaceViewport.clipHorizontal.wWidth;
                while (nvFreeCount < (sizeSetRenderTarget2 + sizeSetObject + sizeSetClip))
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetRenderTarget2 + sizeSetObject + sizeSetClip));
                nvglSetRenderTarget2(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                     pContext->dwSurfaceFormat, clip,
                                     pContext->dwSurfacePitch,  pContext->dwSurfaceOffset,
                                     pContext->ZBufferOffset);

                /*
                 * Set the image black rectangle to the clip region.
                 */
                nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
                nvglSetClip(nvFifo, nvFreeCount, NV_DD_SURFACES,
                            pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                            pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
#endif
            }
        }
        while (nvFreeCount < sizeSetObject)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, sizeSetObject);
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
        pDriverData->TwoDRenderingOccurred = 0;
        pDriverData->ThreeDRenderingOccurred = TRUE;
        pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    }
    pDriverData->lpLast3DSurfaceRendered = pContext->lpLcl->lpGbl->fpVidMem;
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pCurrentContext);
    return;
}
void nvSetD3DSurfaceViewport
(
    PNVD3DCONTEXT   pContext
)
{
    /*
     * AA does not need to tell the HW about the viewport at this point
     *  early exit
     */
    if (pContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return;
    }

    /*
     * Send to hardware
     */
#if 0
    /*
     * If this didn't cause an exception to the RM, this is how I'd program this.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetRenderTargetViewport + sizeSetObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetRenderTargetViewport + sizeSetObject));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
    nvglSetRenderTargetViewport(nvFifo, nvFreeCount, NV_DD_SURFACES,
                                pContext->surfaceViewport.dwClipHorizontal, pContext->surfaceViewport.dwClipVertical);
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
#else
    /*
     * Until programming the clipped viewport doesn't cause an RM exception,
     * program it this way.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetClip + sizeSetObject))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SURFACES, (sizeSetObject + sizeSetClip + sizeSetObject));

    /*
     * Set the image black rectangle to the clip region.
     */
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
    nvglSetClip(nvFifo, nvFreeCount, NV_DD_SURFACES,
                pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);

    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SURFACES, NV_DD_SURFACES_2D);
#endif
    pDriverData->TwoDRenderingOccurred      = 0;
    pDriverData->ThreeDRenderingOccurred    = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->lpLast3DSurfaceRendered    = pContext->lpLcl->lpGbl->fpVidMem;
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pContext);
}

/*
 * Send DX5 Triangle class state to the hardware.
 */
void nvSetDx5TriangleState
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD  *pTriangleState;
    DWORD  *pTriangleStateShadow;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * AA semantics check - I hate these
     */
    if (pContext->dwAntiAliasFlags & AA_ENABLED_MASK)
        pContext->dwAntiAliasFlags |= AA_MIX_DP_NOAA;
    else
        pContext->dwAntiAliasFlags |= AA_MIX_DP_AA;

    /*
     * we do not send state when we capture geometry for super sampled AA
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SUPER)
    {
        if (!(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
        {
            return;
        }
    }

#if 0
    /*
     * Send down the triangle state.
     */
    while (nvFreeCount < (sizeSetObject + sizeDx5TriangleState))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDx5TriangleState));
    pTriangleState = (DWORD *)&pContext->ctxInnerLoop;
    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    }
    nvglDx5TriangleState(nvFifo, nvFreeCount, NV_DD_SPARE,
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState));
    pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;
#else
    /*
     * prep variables
     */
    pTriangleState       = (DWORD*)&pContext->ctxInnerLoop;
    PREFETCH (pTriangleState);
    pTriangleStateShadow = (DWORD*)&pContext->ctxInnerLoopShadow;
    PREFETCH (pTriangleStateShadow);

    /*
     * set object if needed
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        while (nvFreeCount < sizeSetObject)
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;

        /*
         * force state load
         */
        pTriangleStateShadow[0] = ~pTriangleState[0];
        pTriangleStateShadow[1] = ~pTriangleState[1];
    }

    /*
     * wait-for-fe-idle methods
     */
    if ((pTriangleState[1] != pTriangleStateShadow[1])  // offset
     || (pTriangleState[2] != pTriangleStateShadow[2])) // format
    {
        while (nvFreeCount < (sizeSetData * 2 + sizeSetStartMethod * 1))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetData * 2 + sizeSetStartMethod * 1));
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_OFFSET,2);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[1]);
        pTriangleStateShadow[1] = pTriangleState[1];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[2]);
        pTriangleStateShadow[2] = pTriangleState[2];
    }

    /*
     * wait-for-idle methods
     */
    if ((pTriangleState[0] != pTriangleStateShadow[0])  // colorKey
     || (pTriangleState[3] != pTriangleStateShadow[3])  // filter
     || (pTriangleState[4] != pTriangleStateShadow[4])  // blend
     || (pTriangleState[5] != pTriangleStateShadow[5])  // control
     || (pTriangleState[6] != pTriangleStateShadow[6])) // fogColor
    {
        while (nvFreeCount < (sizeSetData * 5 + sizeSetStartMethod * 2))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetData * 5 + sizeSetStartMethod * 2));
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_COLOR_KEY,1);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[0]);
        pTriangleStateShadow[0] = pTriangleState[0];
        nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE,NV054_FILTER,4);
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[3]);
        pTriangleStateShadow[3] = pTriangleState[3];
#ifdef  SPEC_HACK
        /*
         * Send the current blend state. This is an attempt to maximize the ability to
         * get 2 pixels per clock out of the DX5 class when specular highlighting is
         * enabled.
         */
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[8]);
#else   // SPEC_HACK
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[4]);
#endif
        pTriangleStateShadow[4] = pTriangleState[4];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[5]);
        pTriangleStateShadow[5] = pTriangleState[5];
        nvglSetData        (nvFifo,nvFreeCount,            pTriangleState[6]);
        pTriangleStateShadow[6] = pTriangleState[6];
    }
#endif

    return;
}

/*
 * Context and hardware state set routines.
 */
DWORD nvSetContextState
(
    DWORD           dwStateType,
    DWORD           dwStateValue,
    HRESULT        *pddrval
)
{
    /*
     * Make sure the state being set is within the range the driver is handling.
     */
    if (dwStateType <= D3D_RENDERSTATE_MAX)
    {
        /*
         * Only update the state if it's different.
         */
        if (pCurrentContext->dwRenderState[dwStateType] != dwStateValue)
        {
            if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
            {
                DPF("nvSetContextState:Change Render State");
                DPF("State = %08ld", dwStateType);
                DPF("Data  = 0x%08lx", dwStateValue);
            }
            pCurrentContext->dwRenderState[dwStateType] = dwStateValue;
            pCurrentContext->dwStateChange = TRUE;

            /*
             * Handle some special case render states now.
             */
            switch (dwStateType)
            {
                case D3DRENDERSTATE_TEXTUREHANDLE:
                    if (dwStateValue)
                    {
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] |= 0x80000000;
#ifdef  NVD3D_DX6
                        pCurrentContext->tssState[0].dwTextureMap = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];
#endif  // NVD3D_DX6
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREADDRESS:
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU] = dwStateValue;
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV] = dwStateValue;
                    break;
                case D3DRENDERSTATE_MIPMAPLODBIAS:
                    /*
                     * Convert LODBIAS value to NV hardware value.
                     * Here is the true meaning of this value as implemented by the reference rasterizer:
                     *    Floating-point D3DVALUE value used to change the level of detail (LOD) bias.
                     *    This value offsets the value of the mipmap level that is computed by trilinear
                     *    texturing. It is usually in the range  -1.0 to 1.0; the default value is 0.0.
                     *    Each unit bias (+/-1.0) biases the selection by exactly one mipmap level.
                     *    A negative bias will cause the use of larger mipmap levels, resulting in a
                     *    sharper but more aliased image.
                     *    A positive bias will cause the use of smaller mipmap levels, resulting in a
                     *    blurrier image.
                     *    Applying a positive bias also results in the referencing of a smaller amount
                     *    of texture data, which can boost performance on some systems.
                     */
                    if (!pCurrentContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS])
                        pCurrentContext->dwMipMapLODBias = pDriverData->regLODBiasAdjust;
                    else
                    {
                        D3DVALUE dvLODBias;

                        dvLODBias = *((D3DVALUE *)&(pCurrentContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]));
                        if (dvLODBias > 15.0f)
                            dvLODBias = 15.0f;
                        else if (dvLODBias < -15.0f)
                            dvLODBias = -15.0f;
                        /*
                         * Convert the floating point value from D3D into a 5.3 NV value.
                         * 0x08 == 1.0f
                         */
                        dvLODBias *= 8.0;
                        pCurrentContext->dwMipMapLODBias = (DWORD)((long)dvLODBias & 0x000000FF);
                    }
                    break;

                /*
                 * Stupid DX will occasionally send a WrapU/WrapV other than TRUE(1) or FALSE(0)
                 * which can cause problems when the value is or'd directly into the hareware
                 * register.  Make sure that our value is only 0 or 1.
                 */
                case D3DRENDERSTATE_WRAPU:
                    if (dwStateValue)
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] = TRUE;
                    else
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] = FALSE;
                    break;
                case D3DRENDERSTATE_WRAPV:
                    if (dwStateValue)
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] = TRUE;
                    else
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] = FALSE;
                    break;
                case D3DRENDERSTATE_FILLMODE:
                    if (!(dwStateValue)
                     || (dwStateValue > D3DFILL_SOLID))
                    {
                        pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                    }
                    break;
#ifdef  NVD3D_DX6
                case D3DRENDERSTATE_TEXTUREMIN:
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                        case D3DFILTER_LINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                        case D3DFILTER_MIPNEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_POINT;
                            break;
                        case D3DFILTER_MIPLINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_POINT;
                            break;
                        case D3DFILTER_LINEARMIPNEAREST:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_LINEAR;
                            break;
                        case D3DFILTER_LINEARMIPLINEAR:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_LINEAR;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_LINEAR;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwMinFilter = D3DTFN_POINT;
                            pCurrentContext->tssState[0].dwMipFilter = D3DTFP_NONE;
                            break;
                    }
                    break;
                case D3DRENDERSTATE_TEXTUREMAG:
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_POINT;
                            break;
                        case D3DFILTER_LINEAR:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_LINEAR;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwMagFilter = D3DTFG_POINT;
                            break;
                    }
                    break;
#if 0
                case D3DRENDERSTATE_TEXTUREMAPBLEND:
                {
                    DWORD   i;
                    /*
                     * When we get a texturemapblend renderstate, we will also modify the texture stage
                     * state to reflect this change. An application should not be using both TEXTUREMAPBLEND
                     * as well as texture stages so this should be a safe thing to do.  But, as the docs say:
                     *
                     *      Legacy Blending Modes and Texture Stages
                     *
                     *      Although Direct3D still supports the texture blending render state,
                     *      D3DRENDERSTATE_TEXTUREMAPBLEND, the blending modes it offers should not be
                     *      used in combination with texture stage based texture blending, as the
                     *      results can be unpredictable.
                     */
                    switch (dwStateValue)
                    {
                        case D3DTBLEND_DECAL:
                        case D3DTBLEND_COPY:
                        case D3DTBLEND_DECALMASK:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_MODULATE:
                        case D3DTBLEND_MODULATEMASK:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_DECALALPHA:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_MODULATEALPHA:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        case D3DTBLEND_ADD:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_ADD;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_SELECTARG1;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                        default:
                            pCurrentContext->tssState[0].dwColorOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwColorArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwColorArg2 = D3DTA_DIFFUSE;
                            pCurrentContext->tssState[0].dwAlphaOp   = D3DTOP_MODULATE;
                            pCurrentContext->tssState[0].dwAlphaArg1 = D3DTA_TEXTURE;
                            pCurrentContext->tssState[0].dwAlphaArg2 = D3DTA_DIFFUSE;
                            break;
                    }
                    /*
                     * Disable all but stage 0.
                     */
                    for (i = 1; i < 8; i++)
                    {
                        pCurrentContext->tssState[i].dwColorOp = D3DTOP_DISABLE;
                        pCurrentContext->tssState[i].dwAlphaOp = D3DTOP_DISABLE;
                    }
                    break;
                }
#endif
                case D3DRENDERSTATE_WRAP0:
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPU] =
                    pCurrentContext->tssState[0].bWrapU                  = ((dwStateValue & D3DWRAP_U) == D3DWRAP_U);
                    pCurrentContext->dwRenderState[D3DRENDERSTATE_WRAPV] =
                    pCurrentContext->tssState[0].bWrapV                  = ((dwStateValue & D3DWRAP_V) == D3DWRAP_V);
                    break;
                case D3DRENDERSTATE_WRAP1:
                case D3DRENDERSTATE_WRAP2:
                case D3DRENDERSTATE_WRAP3:
                case D3DRENDERSTATE_WRAP4:
                case D3DRENDERSTATE_WRAP5:
                case D3DRENDERSTATE_WRAP6:
                case D3DRENDERSTATE_WRAP7:
                    pCurrentContext->tssState[dwStateType - D3DRENDERSTATE_WRAP0].bWrapU = ((dwStateValue & D3DWRAP_U) == D3DWRAP_U);
                    pCurrentContext->tssState[dwStateType - D3DRENDERSTATE_WRAP0].bWrapV = ((dwStateValue & D3DWRAP_V) == D3DWRAP_V);
                    break;
#endif  // NVD3D_DX6
                case D3DRENDERSTATE_ANTIALIAS:
                    {
                        BOOL bWasEnabled;
                        BOOL bWillEnable;

                        /*
                         * prep for toggle counts
                         */
                        bWasEnabled = (pCurrentContext->dwAntiAliasFlags & AA_ENABLED_MASK) ? 1 : 0;
                        bWillEnable =  dwStateValue != D3DANTIALIAS_NONE;

                        /*
                         * assume disabled
                         */
                        pCurrentContext->dwAntiAliasFlags &= ~(AA_ENABLED_MASK | AA_2D_COUNT_MASK | AA_MIX_MASK);

                        /*
                         * check master switch
                         */
                        if (pDriverData->regD3DEnableBits1 & REG_BIT1_ANTI_ALIAS_ENABLE)
                        {
                            /*
                             * enable aa only if app request aa and is behaving well
                             */
                            if ((dwStateValue != D3DANTIALIAS_NONE)
                             && !(pCurrentContext->dwAntiAliasFlags & AA_INVALID_SEMANTICS))
                            {
                                /*
                                 * decide which AA strategy to use depending on registry
                                 */
                                // aatodo - check aamethod in registry
                                if (1)
                                {
                                    /*
                                     * enable super sampled AA
                                     */
                                    if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_MASK)
                                    {
                                        /*
                                         * enable correct aa mode depending on buffers that where allocated
                                         */
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_SUPER)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_SUPER;
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_SINGLECHUNK)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_SINGLECHUNK;
                                        if (pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_EDGE)
                                            pCurrentContext->dwAntiAliasFlags |= AA_MODE_EDGE;
                                    }
                                    else
                                    {
                                        pCurrentContext->dwAntiAliasFlags |= AA_MODE_SUPER;
                                    }
                                }
                                else
                                {
                                    /*
                                     * enable edge AA
                                     */
                                    pCurrentContext->dwAntiAliasFlags |= AA_MODE_EDGE;
                                }

                                /*
                                 * allocate proper buffers if needed
                                 */
                                if (!(pCurrentContext->dwAntiAliasFlags & AA_BUFALLOC_MASK))
                                {
                                    if (!nvAACreateBuffers())
                                    {
                                        /*
                                         * fail to create buffers - punt
                                         */
                                        pCurrentContext->dwAntiAliasFlags &= ~(AA_ENABLED_MASK | AA_BUFALLOC_MASK);
                                        *pddrval = DDERR_OUTOFVIDEOMEMORY;
                                        return (DDHAL_DRIVER_HANDLED);
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }

    /*
     * Force a reload of the global context state.
     */
    pDriverData->dwCurrentContextHandle = 0;
    *pddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}
/*
 * Calculate the hardware state register based on the D3D context state settings.
 */
void nvCalculateHardwareStateDX5
(
    DWORD   dwTBlendState,
    DWORD   dwMinFilter,
    DWORD   dwMagFilter,
    BOOL    bDx6ToDx5Conversion
)
{
    BOOL            bAlphaTexture = FALSE;
    DWORD           dwMMDE;
    DWORD           dwAlphaRef;
    DWORD           dwAlphaFunc       = 0;  // Will get initialized before being used.
    DWORD           dwTextureColorFormat;
    DWORD           dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD           dwTexturePerspective;
    DWORD           dwSrcBlend;
    DWORD           dwDstBlend;
    DWORD           dwAlphaBlendEnable;
    DWORD           dwColorKey        = 0;
    DWORD           dwOffset          = 0;
    DWORD           dwFormat          = 0;
    DWORD           dwFilter          = 0;
    DWORD           dwBlend           = 0;
    DWORD           dwControl         = 0;
    DWORD           dwFogColor        = 0;
    DWORD          *pdwRenderState    = 0;
    PNVD3DTEXTURE   pTexture;

    pdwRenderState = (DWORD *)pCurrentContext->dwRenderState;

    // txtodo - validate swizzled texture copy


    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Maximize 2 pixels per clock.
     */
    dwMMDE = ((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE) && (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE)) || ((pDriverData->regD3DEnableBits1 & REG_BIT1_MIPMAP_DITHER_ENABLE) == REG_BIT1_MIPMAP_DITHER_ENABLE);

    /*
     * Set up the texture format register.
     */
    if (pTexture = (PNVD3DTEXTURE)pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE])
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    if ((pTexture)
     && (pTexture->lpLcl))
    {
        /*
         * DEBUG only.
         * Display the new texture to the current visible buffer.
         */
        dbgDisplayTexture(pCurrentContext, pTexture);

#ifdef NV_TEX2
        /*
         * setup current texture(s)
         */
        pCurrentContext->pTexture0 = pTexture;
        pCurrentContext->pTexture1 = NULL;
#endif

        /*
         * Grab the color key from the texture.
         */
        dwTextureColorFormat = pTexture->dwTextureColorFormat;
        if (pTexture->lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
        {
#ifndef NV_TEX2
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_RESTRICT_AUTO_MIPMAPS)
                pTexture->dwTextureFlags &= ~NV4_TEXTURE_CAN_AUTO_MIPMAP;
#endif
            switch (dwTextureColorFormat)
            {
                case NV054_FORMAT_COLOR_LE_Y8:
                    break;
                /*
                 * Must assume the application does the right thing here and passes in the
                 * exact color key value as is in the texture map.  If the alpha bits are masked
                 * here, WHQL will fail.
                 */
                case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                case NV054_FORMAT_COLOR_LE_A4R4G4B4:
//                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                case NV054_FORMAT_COLOR_LE_R5G6B5:
                    dwColorKey = (pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x0000FFFF);
                    break;
                case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    dwColorKey = (pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF);
                    break;
                case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    dwColorKey = pTexture->lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
            dwFormat |= DRF_NUM(054, _FORMAT, _COLORKEYENABLE,  pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE]);
        }
        else
            dwFormat |= DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE);

        /*
         * Get the texture format and offset.
         */
#ifdef NV_TEX2
        dwOffset  = TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#else
        dwOffset  = pTexture->dwTextureOffset;
#endif
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,      pTexture->dwTextureContextDma)
                 |  DRF_NUM(054, _FORMAT, _COLOR,            dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_U,      pTexture->dwMipMapBaseU)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_V,      pTexture->dwMipMapBaseV)
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSU,  pdwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU])
                 |  DRF_NUM(054, _FORMAT, _WRAPU,            pdwRenderState[D3DRENDERSTATE_WRAPU])
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSV,  pdwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV])
                 |  DRF_NUM(054, _FORMAT, _WRAPV,            pdwRenderState[D3DRENDERSTATE_WRAPV]);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,       dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,       dwFOHMode);

        /*
         * When there is a texture, use the texture map blend set by the user.
         * One exception.  For textures that do not have an alpha component, set MODULATEALPHA
         * instead of MODULATE.
         *
         * NOTE: For some reason, this does not work when SRCBLEND == DESTBLEND == D3DBLEND_ONE
         *       WHY? (Incoming)
         *
         * NOTE: I'm going to use the fact that the hardware doesn't implement MODULATE exactly
         *       as specified in order to get two pixels per clock out of the following DX6
         *       single texture stage 0 setup: COLOROP = MODULATE, COLORARG1 = TEXTURE,
         *       COLORARG2 = CURRENT/DIFFUSE ALPHAOP = SELECTARG1, ALPHAARG1 = TEXTURE.
         *       When useing TBLEND=MODULATE and a non-alpha texture, the alpha should come from the
         *       Diffuse color component, however when using texture stages, we should not do this.
         *       On entry, if we are converting from a texture stage setup, the bUseDX6Class flag will
         *       still be set, and under this condition, we should not modify the passed in TBLEND value.
         */
        if ((!bDx6ToDx5Conversion)
         && (dwTBlendState == D3DTBLEND_MODULATE)
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && !((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE)
          &&  (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE))
         && ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X1R5G5B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_R5G6B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X8R8G8B8)))
        {
            dwTBlendState = D3DTBLEND_MODULATEALPHA;
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        }
        else
            dwBlend  |= DRF_NUM(054, _BLEND, _TEXTUREMAPBLEND, dwTBlendState);

        if ((pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         || (pTexture->dwMipMapLevels == 1))
        {
            /*
             * When this is a user supplied mipmap chain
             * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
             * set the MIN/MAG filters as specified by the render states.
             */
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                     |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                     |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);

            /*
             * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
             * In cases where there are the user has supplied mipmaps but the minification filter is
             * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
             */
            if ((dwMinFilter == D3DFILTER_NEAREST)
             || (dwMinFilter == D3DFILTER_LINEAR))
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
            else
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);
        }
        else
        {
#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
#else
            if (pTexture->dwTextureFlags & NV4_TEXTURE_CAN_AUTO_MIPMAP)
#endif
            {
                /*
                 * This is the auto-generated mipmap case. In order to get the some sort of mipmapping
                 * to happen, the MIN/MAG filters must be modified if they are NEAREST or LINEAR.
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE);
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,  pTexture->dwMipMapLevels);

                /*
                 * Set the MINIFICATION filter.
                 */
                if (pDriverData->regAutoMipMapMethod == REG_AMMM_BILINEAR)
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _MIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _MIPLINEAR);
                    else
                        dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMIN, dwMinFilter);
                }
                else
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _LINEARMIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        dwFilter |= DRF_DEF(054, _FILTER, _TEXTUREMIN, _LINEARMIPLINEAR);
                    else
                        dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMIN, dwMinFilter);
                }

                /*
                 * Set the MAGNIFICATION filter.
                 * Can only validly be set to NEAREST or LINEAR
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);
            }
            else
            {
                /*
                 * This texture is flagged as not a auto-generated mipmapable texture.
                 */
                dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                         |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                         |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);
                dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
            }
        }

        /*
         * When texturing, always select the proper TexturePerspective render state value.
         */
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        dwTextureColorFormat = pCurrentContext->dwDefaultTextureColorFormat;
        dwOffset  = pCurrentContext->dwDefaultTextureOffset;
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,      pCurrentContext->dwDefaultTextureContextDma)
                 |  DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE)
                 |  DRF_NUM(054, _FORMAT, _COLOR,            dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,    1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_U,     _1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_V,     _1)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPU,           _FALSE)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPV,           _FALSE);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is no texture, always set texture map blend to be MODULATEALPHA
         */
        if (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        else
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);

        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        dwFilter |= DRF_DEF(054, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMIN,    _NEAREST)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMAG,    _NEAREST);

        /*
         * When there is no texture, set texture perspective to false to insure that no 0 RHW values
         * screw up the hardware.
         * But this isn't a good hack.  So it's gone.
         */
//        dwTexturePerspective = FALSE;
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
    }

    /*
     * Set the Mipmap LOD BIAS based on registery setting and render state setting.
     */
    dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pCurrentContext->dwMipMapLODBias);

    /*
     * D3DRENDERSTATE_ANISOTROPY defines 1 as no anisotropy.
     * The following if statement is based on the reference rasterizer.
     */
    if (pdwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1)
    {
        dwFilter |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                 |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
    }
    else
    {
        dwFilter |= DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _FALSE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);
    }

    /*
     * Set up the control register.
     */
    dwControl |= DRF_NUM(054, _CONTROL, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                CTFunc(pdwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                pdwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             D3DCULL_NONE)
#else
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
              |  DRF_NUM(054, _CONTROL, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Get the Src/Dest blending state
     */
    dwAlphaBlendEnable = pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE];
    dwSrcBlend         = pdwRenderState[D3DRENDERSTATE_SRCBLEND];
    dwDstBlend         = pdwRenderState[D3DRENDERSTATE_DESTBLEND];

    /*
     * Colorkey setup.
     */
    if ((pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE])
     && ((dwFormat >> DRF_SHIFT(NV054_FORMAT_COLORKEYENABLE)) & DRF_MASK(NV054_FORMAT_COLORKEYENABLE)))
    {
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "D3D:nvCalculateHardwareStateDX5 - ColorKey Enabled");
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    ColorKey Color     = %08lx", dwColorKey);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaTestEnable    = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaRef           = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaFunc          = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHAFUNC]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaBlendEnable   = %08lx", pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    SrcBlend           = %08lx", pdwRenderState[D3DRENDERSTATE_SRCBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    DstBlend           = %08lx", pdwRenderState[D3DRENDERSTATE_DESTBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureMapBlend    = %08lx", dwTBlendState);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureColorFormat = %08lx", dwTextureColorFormat);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MagFliter          = %08lx", dwMagFilter);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MinFliter          = %08lx", dwMinFilter);

        bAlphaTexture = ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));

        if (!(pDriverData->regD3DEnableBits1 & REG_BIT1_CKCOMPATABILITY_ENABLE))
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey Compatability Disabled");
            goto    labelColorKeySetupNoAlphaTest;
        }

        /*
         * Check the texture format and alpha blending operation.
         * for 8888 and 1555 textures, if (alpha blending is disabled) OR
         * (alpha blending is enabled and neither srcblend and destblend use the source
         * alpha) then change the format sent to hardware to be the complimentery non-alpha
         * texture format.
         */
        if ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            DWORD dwNewFormat;
            dwNewFormat = (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5) ? NV054_FORMAT_COLOR_LE_X1R5G5B5 : NV054_FORMAT_COLOR_LE_X8R8G8B8;

            if (!dwAlphaBlendEnable)
            {
                /*
                 * When alpha blending is disabled, force 1555 and 8888 textures to be x555 and x888
                 * repectively so that non-colorkey 0 alpha texels don't get alpha tested away.
                 */
                dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                dwFormat |= DRF_NUM(054, _FORMAT, _COLOR, dwNewFormat);
            }
            else
            {
                if ((dwSrcBlend != D3DBLEND_SRCALPHA)
                 && (dwSrcBlend != D3DBLEND_INVSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_SRCALPHASAT)
                 && (dwSrcBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_BOTHINVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHA)
                 && (dwDstBlend != D3DBLEND_INVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHASAT)
                 && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA))
                {
                    /*
                     * When alpha blending is enabled but the srcalpha is not being used, force 1555
                     * and 8888 textures to be x555 and x888 repectively so that non-colorkey 0 alpha
                     * texels don't get alpha tested away.
                     */
                    dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                    dwFormat |= DRF_NUM(054, _FORMAT, _COLOR,            dwNewFormat);
                }
            }
        }

        /*
         * Change color key implementation to always use alpha test
         */
        if (!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with registry alphatest");

            /*
             * Special case for non-alpha textures when blending is enabled and the source blend
             * is set to D3DBLEND_ONE and the texturemap blend is set to modulate alpha.  Switch
             * the TBLEND to be modulate since the vertex alpha doesn't matter.
             * But one other requirement is that the SRCALPHA cannot be involved in the destblend either.
             * This will prevent vertices with alphas set to all zero to not get keyed away.
             */
            if ((dwAlphaBlendEnable) //&& (!bAlphaTexture)
             && (dwTBlendState == D3DTBLEND_MODULATEALPHA)
             && (dwSrcBlend == D3DBLEND_ONE)
             && ((dwDstBlend != D3DBLEND_SRCALPHA)
              && (dwDstBlend != D3DBLEND_INVSRCALPHA)
              && (dwDstBlend != D3DBLEND_SRCALPHASAT)
              && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
              && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA)))
            {
                dwBlend &= ~DRF_MASK(NV054_BLEND_TEXTUREMAPBLEND);
                dwBlend |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);
            }

            /*
             * Set the colorkey alphatest mode.
             */
            dwAlphaRef = pDriverData->regColorkeyRef;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_DEF(054, _CONTROL, _ALPHAFUNC,       _GREATER)
                      |  DRF_DEF(054, _CONTROL, _ALPHATESTENABLE, _TRUE);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with app alphatest");

            /*
             * Calculate the hardware alpha test reference value.
             */
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;

            /*
             * Get the application specified alpha test comparison function.
             */
            dwAlphaFunc = pdwRenderState[D3DRENDERSTATE_ALPHAFUNC];

            /*
             * There is a very specialized case where we want to actually modify the alphatest setup
             * from what is passed in by the application.  This is for Motoracer2 which does something
             * very strange...but not all the time.  This is most likely an application bug, but I'm
             * working around it here...yuck.
             *
             * The situation is this, occasionally, Motoracer2 will set the following alphatest state:
             * AlphaTestEnable = 1
             * AlphaRef = 0x00
             * AlphaFunc = 7 (GREATEREQUAL)
             * AlphaBlendEnable = 1
             * SrcBlend = 5 (SRCALPHA)
             * DstBlend = 2 (ONE)
             * TextureMapBlend = 4 (MODULATEALPHA)
             * TextureColorFormat = 5 (R5G6B5)
             * However, in this situation, with the alpharef of 0 and the alphafunc set to GREATEREQUAL,
             * the colorkey (which has it's alpha forced to 0) will still show up since the alphatest
             * comparison will always be TRUE.
             * So, I'll make a general case where if the I see this combination when colorkeying is enabled,
             * I'll just change the alphafunc to be GREATER.
             */
            if ((dwAlphaRef == 0x00)
             && (dwAlphaFunc == D3DCMP_GREATEREQUAL ||
                 dwAlphaFunc == D3DCMP_ALWAYS))
            {
                DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "Modify application alphafunc");
                dwAlphaFunc = D3DCMP_GREATER;
            }

            /*
             * Set the hardware alpha test state.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       dwAlphaFunc)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }
    else
    {
#if 0   // VR POWERBOAT RACING HACK - NEED SOMETHING EXTREMELY SPECIFIC TO VR POWERBOAT RACING HERE.
        if ((!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && (dwSrcBlend != D3DBLEND_ONE))
        {
            /*
             * Alpha test away zero alpha pixels to repress z-writes when alpha test
             * is not enabled and alpha blending is enabled.  This is a HACK to work
             * around an application bug in VR Powerboat Racing.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        0x00)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       D3DCMP_GREATER)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, TRUE);
        }
        else
#endif  // VR POWERBOAT RACING HACK
        {
labelColorKeySetupNoAlphaTest:
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }

    /*
     * Set up the texture map blending control register.
     * Not sure about the MASK_BIT.
     */
    dwBlend |= DRF_DEF(054, _BLEND, _MASK_BIT,           _MSB)
            |  DRF_NUM(054, _BLEND, _SHADEMODE,          pdwRenderState[D3DRENDERSTATE_SHADEMODE])
            |  DRF_NUM(054, _BLEND, _TEXTUREPERSPECTIVE, dwTexturePerspective)
            |  DRF_NUM(054, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
            |  DRF_NUM(054, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
            |  DRF_NUM(054, _BLEND, _ALPHABLENDENABLE,   dwAlphaBlendEnable);
    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        dwBlend |= DRF_NUM(054, _BLEND, _SRCBLEND,  dwSrcBlend)
                |  DRF_NUM(054, _BLEND, _DESTBLEND, dwDstBlend);

    if ((pCurrentContext->lpLclZ)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_NUM(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                      |  DRF_NUM(054, _CONTROL, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
            dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                      |  DRF_DEF(054, _CONTROL,  _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,      _FALSE)
                  |  DRF_DEF(054, _CONTROL, _ZWRITEENABLE, _FALSE)
                  |  DRF_NUM(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                  |  DRF_NUM(054, _CONTROL, _Z_FORMAT,             pDriverData->regZFormat);

    }

    /*
     * Set the fog color.
     */
    dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }

    /*
     * Store the register values.
     */
    pCurrentContext->ctxInnerLoop.dwColorKey      = dwColorKey;
    pCurrentContext->ctxInnerLoop.dwTextureOffset = dwOffset;
    pCurrentContext->ctxInnerLoop.dwFormat        = dwFormat;
    pCurrentContext->ctxInnerLoop.dwFilter        = dwFilter;
    pCurrentContext->ctxInnerLoop.dwBlend         = dwBlend;
    pCurrentContext->ctxInnerLoop.dwControl       = dwControl;
    pCurrentContext->ctxInnerLoop.dwFogColor      = dwFogColor;
    pCurrentContext->dwStateChange                = FALSE;

#ifdef  SPEC_HACK
    /*
     * Update the current blend mode but set the specular enable bit the way it was left.
     * If specular is disabled in the render state, then it should be disabled in the current state.
     * Otherwise just use the last know state of specular highlighting.  It will get enabled when it is
     * needed if it was previously disabled.
     */
    if (!pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        pCurrentContext->ctxInnerLoop.dwCurrentSpecularState = FALSE;

    pCurrentContext->ctxInnerLoop.dwCurrentBlend = (dwBlend & 0xFFFF0FFF)
                                                 |  DRF_NUM(054, _BLEND, _SPECULARENABLE, pCurrentContext->ctxInnerLoop.dwCurrentSpecularState);
    pCurrentContext->ctxInnerLoop.dwNoSpecularTriangleCount = 0;
#endif  // SPEC_HACK

    return;
}
BOOL nvSetHardwareState
(
    void
)
{
    DWORD   dwTBlend;
    DWORD   dwMinFilter, dwMagFilter;

#ifdef NV_STATS
    {
        extern DWORD dwHWPCount;
        dwHWPCount ++;
    }
#endif

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5 render state to be calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_RENDER_STATE, pCurrentContext);

    /*
     * Get state to be passed to the hardware setup routine.
     */
    dwTBlend = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];
    dwMinFilter = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN];
    dwMagFilter = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG];

    /*
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5(dwTBlend, dwMinFilter, dwMagFilter, FALSE);

    /*
     * This code is only enabled in the DEBUG build.
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pCurrentContext);
    return (TRUE);
}

//-------------------------------------------------------------------------------------

/*
 * Format of the cobine data is:
 * Bits 31-24  23-16  15-8  7 - 0
 *       00     op    arg2  arg1
 */

/*
 * DX5 D3DTBLEND_DECAL equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSCOLOR_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSCOLOR_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSALPHA_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSALPHA_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_DECALALPHA equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECALALPHA_MASK    0x00FFFFFF
#define DX5_TSSCOLOR_DECALALPHA_1       ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_2       ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_3       ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_4       ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))

#define DX5_TSSALPHA_DECALALPHA_MASK_12 0x00FF00FF
#define DX5_TSSALPHA_DECALALPHA_1       ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_2       ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_MASK_34 0x00FFFF00
#define DX5_TSSALPHA_DECALALPHA_3       ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_DECALALPHA_4       ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state.
 */
#define DX5_TSSCOLOR_MODULATE_MASK      0x00FFFFFF
#define DX5_TSSCOLOR_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_2         ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_3         ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_4         ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))


#define DX5_TSSALPHA_MODULATE_MASK_1    0x00FF00FF
#define DX5_TSSALPHA_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_MASK_2    0x00FFFF00
#define DX5_TSSALPHA_MODULATE_2         ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_34   0x00FFFF00
#define DX5_TSSALPHA_MODULATE_3         ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_MODULATE_4         ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_56   0x00FF00FF
#define DX5_TSSALPHA_MODULATE_5         ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_6         ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))

/*
 * DX5 D3DTBLEND_MODULATEALPHA equivalent texture stage state.
 */
#define DX5_TSSALPHA_MODULATEALPHA_MASK 0x00FFFFFF
#define DX5_TSSALPHA_MODULATEALPHA_1    ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_2    ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_3    ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_4    ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))

/*
 * DX5 D3DTBLEND_ADD equivalent texture stage state.
 */
#define DX5_TSSCOLOR_ADD_MASK           0x00FFFFFF
#define DX5_TSSCOLOR_ADD_1              ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_2              ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_3              ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_4              ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))

#define DX5_TSSALPHA_ADD_MASK_12        0x00FF00FF
#define DX5_TSSALPHA_ADD_1              ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_2              ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_MASK_34        0x00FFFF00
#define DX5_TSSALPHA_ADD_3              ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_ADD_4              ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

//-------------------------------------------------------------------------------------

BOOL nvConvertTextureStageToDX5Class
(
)
{
    BOOL                    bAlphaTexture;
    DWORD                   tssAlphaBlend, tssColorBlend;
    DWORD                   dwMinFilter, dwMagFilter;
    DWORD                   dwTBlend;
    DWORD                   dwTexture;
    PNVD3DTEXTURE           pTexture;
    PNVD3DTEXSTAGESTATE     ptssState0;
    PNVD3DMULTITEXTURESTATE pmtsState;


    ptssState0 = &pCurrentContext->tssState[0];
    pmtsState  = &pCurrentContext->mtsState;

    tssAlphaBlend = ((ptssState0->dwAlphaArg1 & 0x000000FF) << 0)
                  | ((ptssState0->dwAlphaArg2 & 0x000000FF) << 8)
                  | ((ptssState0->dwAlphaOp & 0x000000FF) << 16);
    tssColorBlend = ((ptssState0->dwColorArg1 & 0x000000FF) << 0)
                  | ((ptssState0->dwColorArg2 & 0x000000FF) << 8)
                  | ((ptssState0->dwColorOp & 0x000000FF) << 16);

    /*
     * Save off the current texture handle.  This may be changed under some circumstances.
     * MUST BE RESTORED BEFORE EXITING ROUTINE.
     */
    dwTexture = pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];

    /*
     * Determine if the single texture stage can be converted to a DX5 TEXTUREMAPBLEND state.
     */
    if (ptssState0->dwColorOp != D3DTOP_DISABLE)
    {
        if ((((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_1) == DX5_TSSCOLOR_DECAL_1) ||
             ((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_2) == DX5_TSSCOLOR_DECAL_2))
         && (((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_1) == DX5_TSSALPHA_DECAL_1) ||
             ((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_2) == DX5_TSSALPHA_DECAL_2)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECAL.
             */
            dwTBlend = D3DTBLEND_DECAL;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECALALPHA.
             */
            dwTBlend = D3DTBLEND_DECALALPHA;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is ADD.
             */
            dwTBlend = D3DTBLEND_ADD;
        }
        else if (((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_1) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_2) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_3) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_4))
        {
            bAlphaTexture = FALSE;
            if (pTexture = (PNVD3DTEXTURE)dwTexture)
            {
                bAlphaTexture = ((pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                              || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                              || (pTexture->dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));
            }
            if (((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_1) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_2) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_3) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_4))
            {
                /*
                 * TEXTUREMAPBLEND equivalent is MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_1) == DX5_TSSALPHA_MODULATE_1) ||
                     ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_2) == DX5_TSSALPHA_MODULATE_2))
            {
                /*
                 * TEXTUREMAPBLEND equqivalent is MODULATE and the texture has an alpha component,
                 * so program the DX5 class with MODULATE.
                 * However, if there is no texture selected, the DX5 class should be programmed as
                 * MODULATEALPHA to use the vertex alpha values.
                 */
                if (!pTexture)
                    dwTBlend = D3DTBLEND_MODULATEALPHA;
                else
                    dwTBlend = D3DTBLEND_MODULATE;
            }
            else if (((!bAlphaTexture) || (!pTexture))
                  && (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_3) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_4) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_5) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_6)))
            {
                /*
                 * When the TEXTUREMAPBLEND equivalent is MODULATE but the texture format does
                 * not have an alpha component, need to program the DX5 class as MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else
                return (FALSE);
        }
        else
            return (FALSE);
    }
    else
    {
        /*
         * When stage 0 is disabled, force DX5 setup with no texture.
         */
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        nvCalculateHardwareStateDX5(D3DTBLEND_MODULATEALPHA, D3DFILTER_NEAREST, D3DFILTER_NEAREST, TRUE);
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = dwTexture;
        return (TRUE);
    }

    /*
     * Calculate the MIN and MAG filters from the texture stage state.
     */
    /*
     * Need to calculate the MIN and MAG filters.
     */
    switch (ptssState0->dwMagFilter)
    {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }
    if (ptssState0->dwMipFilter == D3DTFP_NONE)
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (ptssState0->dwMipFilter == D3DTFP_POINT)
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else
    {
        switch (ptssState0->dwMinFilter)
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    /*
     * Need to track down the mipmap level that the application wants to start from.
     */
    if (pTexture = (PNVD3DTEXTURE)dwTexture)
        NV_LOCK_TEXTURE_SURFACE(pTexture);

    if ((pTexture) && (pTexture->lpLcl)
     && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (ptssState0->dwMaxMipLevel)
     && (ptssState0->dwMaxMipLevel < pTexture->dwMipMapLevels))
    {
        DWORD   i;

        for (i = 0; i < ptssState0->dwMaxMipLevel; i++)
            pTexture = (PNVD3DTEXTURE)pTexture->lpLcl->lpAttachList->lpAttached->dwReserved1;

        /*
         * Update the render state handle for the starting mipmap level.
         */
        pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = (DWORD)pTexture;
        NV_UNLOCK_TEXTURE_SURFACE(pTexture);
    }

    /*
     * All other state comes directly from the renderstate.
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5(dwTBlend, dwMinFilter, dwMagFilter, TRUE);

    /*
     * Restore the original texture handle.
     */
    pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = dwTexture;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pCurrentContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pCurrentContext);

    /*
     * Determine the UV coordinate offset for the first stage.
     */
    pmtsState->dwUVOffset[0] = (2 * sizeof(D3DVALUE)) * ptssState0->dwTexCoordIndex;

    return (TRUE);
}

//-------------------------------------------------------------------------------------

void nvSetDx6MultiTextureState
(
    PNVD3DCONTEXT   pContext
)
{
    NVD3DMULTITEXTURESTATE *pState;
    NVD3DMULTITEXTURESTATE *pShadowState;

    /*
     * AA semantics check - I hate these
     */
    if (pContext->dwAntiAliasFlags & AA_ENABLED_MASK)
        pContext->dwAntiAliasFlags |= AA_MIX_DP_NOAA;
    else
        pContext->dwAntiAliasFlags |= AA_MIX_DP_AA;

    /*
     * we do not send state when we capture geometry for super sampled AA
     */
    if (pCurrentContext->dwAntiAliasFlags & AA_MODE_SUPER)
    {
        if (!(pCurrentContext->dwAntiAliasFlags & AA_CAPTURE_PUSHBUFFER))
        {
            return;
        }
    }

    while (nvFreeCount < (sizeSetObject + sizeDX6TriangleState))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeDX6TriangleState));

    /*
     * setup locals
     */
    pState       = &pCurrentContext->mtsState;
    pShadowState = &pCurrentContext->mtsShadowState;

    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE)
    {
        /*
         * select object
         */
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

        /*
         * program everything
         */
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureOffset[0], 0);
        nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureOffset[1], 1);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFormat[0], 0);
        nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFormat[1], 1);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFilter[0], 0);
        nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                              pState->dwTextureFilter[1], 1);
        nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwCombine0Alpha, pState->dwCombine0Color,
                                  pState->dwCombine1Alpha, pState->dwCombine1Color,
                                  pState->dwCombineFactor, pState->dwBlend,
                                  pState->dwControl0,      pState->dwControl1,
                                  pState->dwControl2,      pState->dwFogColor);

        pDriverData->dDrawSpareSubchannelObject = D3D_DX6_MULTI_TEXTURE_TRIANGLE;

        /*
         * cache everything
         */
        *pShadowState = *pState;
    }
    else
    {
        if (pShadowState->dwTextureOffset[0] != pState->dwTextureOffset[0])
        {
            nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureOffset[0], 0);

            pShadowState->dwTextureOffset[0] = pState->dwTextureOffset[0];
        }

        if (pShadowState->dwTextureOffset[1] != pState->dwTextureOffset[1])
        {
            nvglDx6TriangleOffset(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureOffset[1], 1);

            pShadowState->dwTextureOffset[1] = pState->dwTextureOffset[1];
        }

        if (pShadowState->dwTextureFormat[0] != pState->dwTextureFormat[0])
        {
            nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFormat[0], 0);

            pShadowState->dwTextureFormat[0] = pState->dwTextureFormat[0];
        }

        if (pShadowState->dwTextureFormat[1] != pState->dwTextureFormat[1])
        {
            nvglDx6TriangleFormat(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFormat[1], 1);

            pShadowState->dwTextureFormat[1] = pState->dwTextureFormat[1];
        }

        if (pShadowState->dwTextureFilter[0] != pState->dwTextureFilter[0])
        {
            nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFilter[0], 0);

            pShadowState->dwTextureFilter[0] = pState->dwTextureFilter[0];
        }

        if (pShadowState->dwTextureFilter[1] != pState->dwTextureFilter[1])
        {
            nvglDx6TriangleFilter(nvFifo, nvFreeCount, NV_DD_SPARE,
                                  pState->dwTextureFilter[1], 1);

            pShadowState->dwTextureFilter[1] = pState->dwTextureFilter[1];
        }

        /*
         * must be evaluated last
         */
        if ((pShadowState->dwCombine0Alpha != pState->dwCombine0Alpha)
         || (pShadowState->dwCombine0Color != pState->dwCombine0Color)
         || (pShadowState->dwCombine1Alpha != pState->dwCombine1Alpha)
         || (pShadowState->dwCombine1Color != pState->dwCombine1Color)
         || (pShadowState->dwCombineFactor != pState->dwCombineFactor)
         || (pShadowState->dwBlend         != pState->dwBlend        )
         || (pShadowState->dwControl0      != pState->dwControl0     )
         || (pShadowState->dwControl1      != pState->dwControl1     )
         || (pShadowState->dwControl2      != pState->dwControl2     )
         || (pShadowState->dwFogColor      != pState->dwFogColor     ))
        {
            nvglDx6TriangleStageState(nvFifo, nvFreeCount, NV_DD_SPARE,
                                      pState->dwCombine0Alpha, pState->dwCombine0Color,
                                      pState->dwCombine1Alpha, pState->dwCombine1Color,
                                      pState->dwCombineFactor, pState->dwBlend,
                                      pState->dwControl0,      pState->dwControl1,
                                      pState->dwControl2,      pState->dwFogColor);

            /*
             * cache everything - this is why this part is last
             */
            *pShadowState = *pState;
        }
    }

    return;
}

//-------------------------------------------------------------------------------------

/*
 * Validate the multi-texture rendering state.
 */
DWORD FAR PASCAL nvValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA  pvtssd
)
{
    DWORD   i;

    pCurrentContext = (PNVD3DCONTEXT)pvtssd->dwhContext;
    if (!pCurrentContext)
    {
        return (DDHAL_DRIVER_HANDLED);
    }
    nvSetMultiTextureHardwareState();
    pvtssd->ddrval = pCurrentContext->mtsState.ddrval;

    /*
     * If returning DD_OK, then we can do this operation in 1 pass.
     * If returning an error, then who the heck knows.  Return an obnoxious number.
     */
    if (pvtssd->ddrval == DD_OK)
    {
        /*
         * Hardware setup didn't catch any problems, but there may be some things that we don't support that
         * hardware setup doesn't catch.  Check for them now.
         */
        for (i = 0; i < pCurrentContext->dwStageCount; i++)
        {
            if ((pCurrentContext->tssState[i].dwColorOp != D3DTOP_DISABLE)
             && ((pCurrentContext->tssState[i].dwAddressU == D3DTADDRESS_BORDER)
              || (pCurrentContext->tssState[i].dwAddressV == D3DTADDRESS_BORDER)))
            {
                pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }
#ifdef DX7
            if ((pCurrentContext->tssState[i].dwColorArg1 == D3DTA_SPECULAR) ||
                (pCurrentContext->tssState[i].dwColorArg2 == D3DTA_SPECULAR))
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDCOLORARG;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }

            if ((pCurrentContext->tssState[i].dwAlphaArg1 == D3DTA_SPECULAR) ||
                (pCurrentContext->tssState[i].dwAlphaArg2 == D3DTA_SPECULAR))
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDALPHAARG;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                return (DDHAL_DRIVER_HANDLED);
            }
#endif
        }
        /*
         * If the DX6 class is being used and colorkey is enabled, return an error.
         */
        if ((pCurrentContext->bUseDX6Class)
         && (pCurrentContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]))
        {
            pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
            pvtssd->dwNumPasses = 0xFFFFFFFF;
            return (DDHAL_DRIVER_HANDLED);
        }
        pvtssd->dwNumPasses = 1;
    }
    else
        pvtssd->dwNumPasses = 0xFFFFFFFF;
    return (DDHAL_DRIVER_HANDLED);
}

/**************************** DX6 Multi Texture Setup************************\
*
* In all cases we can use one combiner for each TSS (when they map).
* So we can advertise that we handle 2 textures and 2 stages.
*
* At some point we may want to consider setup of the hardware to support
* 3 stages and sometimes even 4 stages into our 2 combiners.
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   diffuse
* D3DTA_TEXTURE   Texture 0
*
* DX6 arg in stage 1 & ~(D3DTA_ALPHA | D3DTA_INV) NV4 arg for combiner 1
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   input
* D3DTA_TEXTURE   Texture 1
*
* If (DX6arg & D3DTA_ALPHA) NV4arg |= alpha
* If (DX6arg & D3DTA_INV) NV4arg |= inv
*
* Map the DX6 Arguments and operations as follows:
*
* DX6op                     | NV4op         | NV4arg1            | NV4arg2          | NV4arg3      | NV4arg4
* ==========================+===============+====================+==================+==============+===============
* Selectarg1                | Add           | Arg1               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Selectarg2                | Add           | Arg2               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate                  | Add           | Arg1               | Arg2             | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate2x                | Add           | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate4x                | Add2          | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Add                       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned                 | Addsigned     | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned2x               | Addsigned2    | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsmoth                  | Add           | Arg1               | Inv | zero       | Inv | Arg1   | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Subtract                  | addcomplement | Arg1 | inv         | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* blenddiffusealpha         | Add           | Arg1               | Alpha | diffuse  | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealpha         | Add           | Arg1               | Alpha | tex<0|1> | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | tex<0|1>
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendfactoralpha          | Add           | Arg1               | Alpha | factor   | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | factor
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealphapm       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | texture
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendcurrentalpha         | Add           | Arg1               | Alpha | input    | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* premodulate               | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEALPHA_ADDCOLOR    | Add           | Arg1 | alpha       | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATECOLOR_ADDALPHA    | Add           | Arg1               | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVALPHA_ADDCOLOR | Add           | Arg1 | alpha | inv | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVCOLOR_ADDALPHA | Add           | Arg1 | inv         | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAP                | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAPLUMINANCE       | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPMAPLIGHT              | ** error **   |                    |                  |              |
* ==========================+===============+====================+==================+==============+===============
*
\****************************************************************************/

BOOL nvCheckStencilBuffer
(
    void
)
{
    /*
     * If the rendering surface is 16bpp, then there can't be a stencil buffer.
     */
    if ((pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) |
                                              DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_X1R5G5B5_Z1R5G5B5)))
     || (pCurrentContext->dwSurfaceFormat == (DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH) |
                                              DRF_DEF(053, _SET_FORMAT, _COLOR, _LE_R5G6B5))))
        return (FALSE);

    /*
     * If there is no Z-Buffer, then there can't be a stencil buffer.
     */
    if (!pCurrentContext->lpLclZ)
        return (FALSE);

    /*
     * Make sure Surface pixel format is specified.  If it's not, there can't
     * be a stencil buffer.
     */
    if (!(pCurrentContext->lpLclZ->dwFlags & DDRAWISURF_HASPIXELFORMAT))
        return (FALSE);

    /*
     * If the z-buffer pixel format does not specify a stencil buffer,
     * then there is no stencil buffer.
     */
    if (!(pCurrentContext->lpLclZ->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER))
        return (FALSE);

    /*
     * There is a stencil buffer and the rendering surface is 32bpp,
     * return whether the stencil buffer is enabled or not.
     */
    return (pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
}

//-------------------------------------------------------------------------------------

void nvSetDX6TextureState
(
    DWORD                   dwTextureNum,
    PNVD3DTEXSTAGESTATE     ptssState,
    PNVD3DMULTITEXTURESTATE pmtsState
)
{
    DWORD           dwMagFilter;
    DWORD           dwMinFilter;
    DWORD           dwZOHMode, dwFOHMode;
    PNVD3DTEXTURE   pTexture;

    /*
     * setup state
     */
    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

    if (pTexture = (PNVD3DTEXTURE)ptssState->dwTextureMap)
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    if ((pTexture)
     && (pTexture->lpLcl))
    {
        if ((ptssState->dwMaxMipLevel)
         && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
        {
            if (ptssState->dwMaxMipLevel < pTexture->dwMipMapLevels)
            {
                DWORD   i;
                /*
                 * Need to track down the mipmap level that the application wants to start from.
                 */
                for (i = 0; i < ptssState->dwMaxMipLevel; i++)
                    pTexture = (PNVD3DTEXTURE)pTexture->lpLcl->lpAttachList->lpAttached->dwReserved1;
            }
        }
#ifdef NV_TEX2
        pmtsState->dwTextureOffset[dwTextureNum] = TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#else
        pmtsState->dwTextureOffset[dwTextureNum] = pTexture->dwTextureOffset;
#endif
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pTexture->dwTextureContextDma)
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           pTexture->dwTextureColorFormat)
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     pTexture->dwMipMapBaseU)
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     pTexture->dwMipMapBaseV)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSU, ptssState->dwAddressU)
                                                 | DRF_NUM(055, _FORMAT, _WRAPU,           (DWORD)ptssState->bWrapU)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSV, ptssState->dwAddressV)
                                                 | DRF_NUM(055, _FORMAT, _WRAPV,           (DWORD)ptssState->bWrapU);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Need to calculate the MIN and MAG filters.
         */
        switch (ptssState->dwMagFilter)
        {
            case D3DTFG_POINT:
                dwMagFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFG_LINEAR:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
            case D3DTFG_ANISOTROPIC:
                dwMagFilter = D3DFILTER_LINEAR;
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                         |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                         |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
                break;
            default:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
        }
        if (ptssState->dwMipFilter == D3DTFP_NONE)
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
            }
        }
        else if (ptssState->dwMipFilter == D3DTFP_POINT)
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_MIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
            }
        }
        else
        {
            switch (ptssState->dwMinFilter)
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
            }
        }

        if ((pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
         || (pTexture->dwMipMapLevels == 1))
        {
            /*
             * When this is a user supplied mipmap chain
             * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
             * set the MIN/MAG filters as specified by the render states.
             */
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter)
                                                     |  DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);

            /*
             * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
             * In cases where there are the user has supplied mipmaps but the minification filter is
             * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
             */
            if ((dwMinFilter == D3DFILTER_NEAREST)
             || (dwMinFilter == D3DFILTER_LINEAR))
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
            else
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);
        }
        else
        {
#ifdef NV_TEX2
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
#else
            if (pTexture->dwTextureFlags & NV4_TEXTURE_CAN_AUTO_MIPMAP)
#endif
            {
                /*
                 * This is the auto-generated mipmap case. In order to get the some sort of mipmapping
                 * to happen, the MIN/MAG filters must be modified if they are NEAREST or LINEAR.
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->dwMipMapLevels);

                /*
                 * Set the MINIFICATION filter.
                 */
                if (pDriverData->regAutoMipMapMethod == REG_AMMM_BILINEAR)
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _MIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _MIPLINEAR);
                    else
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter);
                }
                else
                {
                    if (dwMinFilter == D3DFILTER_NEAREST)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _LINEARMIPNEAREST);
                    else if (dwMinFilter == D3DFILTER_LINEAR)
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _TEXTUREMIN, _LINEARMIPLINEAR);
                    else
                        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter);
                }

                /*
                 * Set the MAGNIFICATION filter.
                 * Can only validly be set to NEAREST or LINEAR
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);
            }
            else
            {
                /*
                 * This texture is flagged as not a auto-generated mipmapable texture.
                 */
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                                         |  DRF_NUM(055, _FILTER, _TEXTUREMIN,    dwMinFilter)
                                                         |  DRF_NUM(055, _FILTER, _TEXTUREMAG,    dwMagFilter);
                pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
            }
        }
        dbgDisplayTexture(pCurrentContext, pTexture);
        NV_LOCK_TEXTURE_SURFACE(pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[dwTextureNum] = pCurrentContext->dwDefaultTextureOffset;
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                                 | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);



        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                                 |  DRF_DEF(055, _FILTER, _TEXTUREMIN,           _NEAREST)
                                                 |  DRF_DEF(055, _FILTER, _TEXTUREMAG,           _NEAREST);
    }

    /*
     * Setup stage texture filter
     */
    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->bLODBias);

    /*
     * Determine the UV coordinate offset for this texture stage.
     */
    pmtsState->dwUVOffset[dwTextureNum] = (2 * sizeof(D3DVALUE)) * ptssState->dwTexCoordIndex;
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDX6State
(
    DWORD                   *pdwRenderState,
    PNVD3DMULTITEXTURESTATE  pmtsState
)
{
    DWORD   dwAlphaRef;
    DWORD   dwTexelOrigin;

    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Set the Combine Factor.
     */
    pmtsState->dwCombineFactor = pdwRenderState[D3DRENDERSTATE_TEXTUREFACTOR];

    /*
     * Setup Blend control.
     */
    pmtsState->dwBlend = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                       | DRF_NUM(055, _BLEND, _SHADEMODE,          pdwRenderState[D3DRENDERSTATE_SHADEMODE])
                       | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                       | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                       | DRF_NUM(055, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
                       | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pdwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pdwRenderState[D3DRENDERSTATE_DESTBLEND]);

    /*
     * Setup Control0.
     */
    if (pdwRenderState[D3DRENDERSTATE_ALPHAREF] == 0x00010000)
        dwAlphaRef = 0xFF;
    else
        dwAlphaRef = (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x0000FF00)
                   ? (pdwRenderState[D3DRENDERSTATE_ALPHAREF] >> 8)
                   : (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x000000FF);
    pmtsState->dwControl0 = DRF_NUM(055, _CONTROL0, _ALPHAREF,             dwAlphaRef)
                          | DRF_NUM(055, _CONTROL0, _ALPHAFUNC,            pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                          | DRF_NUM(055, _CONTROL0, _ALPHATESTENABLE,      pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
                          | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pdwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                pdwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             D3DCULL_NONE)
#else
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
                          | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Set Control0 z-buffer enable bits.
     */
    if ((pCurrentContext->lpLclZ)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                                  |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                              |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                              |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
    }
    /*
     * Set Control0 stencil buffer enable bits.
     */
    if (nvCheckStencilBuffer())
    {
        pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _STENCIL_WRITE_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    /*
     * Set ARGB write enbles.
     * Always enable RGB only enable Alpha for alpha frame buffers.
     */
//    if
//    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE, _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,  _TRUE);

    /*
     * Set the Fog color.
     */
    pmtsState->dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDefaultMultiTextureHardwareState
(
)
{
    DWORD                   dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD                   dwTextureOffset;
    DWORD                   dwTextureContextDma;
    DWORD                   dwTextureColorFormat;
    DWORD                   dwMipMapLevels;
    DWORD                   dwMipMapBaseU;
    DWORD                   dwMipMapBaseV;
    PNVD3DTEXTURE           pTexture0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    // txtodo - check texture valid for HW program

    dwZOHMode     = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((pDriverData->regTexelAlignment & REG_TA_TEXEL_MASK) == REG_TA_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Grab texture from the render state array.  This is guaranteed to always have the
     * correct texture no matter if it was set using the render state method or the texture
     * stage 0 method.
     */
    pTexture0 = (PNVD3DTEXTURE)pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE];
    if (pTexture0)
    {
#ifdef NV_TEX2
        dwTextureOffset      = TEX_SWIZZLE_OFFSET(pTexture0,pTexture0->dwTextureFlags);
#else
        dwTextureOffset      = pTexture0->dwTextureOffset;
#endif
        dwTextureContextDma  = pTexture0->dwTextureContextDma;
        dwTextureColorFormat = pTexture0->dwTextureColorFormat;
        dwMipMapBaseU        = pTexture0->dwMipMapBaseU;
        dwMipMapBaseV        = pTexture0->dwMipMapBaseV;
        dwMipMapLevels       = pTexture0->dwMipMapLevels;
    }
    else
    {
        /*
         * No texture, setup default.
         */
        dwTextureOffset      = pCurrentContext->dwDefaultTextureOffset;
        dwTextureContextDma  = pCurrentContext->dwDefaultTextureContextDma;
        dwTextureColorFormat = pCurrentContext->dwDefaultTextureColorFormat;
        dwMipMapLevels       = 1;
        dwMipMapBaseU        = NV055_FORMAT_BASE_SIZE_U_1;
        dwMipMapBaseV        = NV055_FORMAT_BASE_SIZE_V_1;
    }

    pmtsState  = &pCurrentContext->mtsState;
    pmtsState->dwTextureOffset[0] =  dwTextureOffset;
    pmtsState->dwTextureFormat[0] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     dwTextureContextDma)
                                  |  DRF_NUM(055, _FORMAT, _COLOR,           dwTextureColorFormat)
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   dwMipMapLevels)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     dwMipMapBaseU)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     dwMipMapBaseV)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[0] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

    pmtsState->dwTextureOffset[1] =  pCurrentContext->dwDefaultTextureOffset;
    pmtsState->dwTextureFormat[1] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,      pCurrentContext->dwDefaultTextureContextDma)
                                  |  DRF_NUM(055, _FORMAT, _COLOR,            pCurrentContext->dwDefaultTextureColorFormat)
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,    1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[1] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DEFAULT;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE0COLOR_DEFAULT;;

    pmtsState->dwCombineFactor = 0;
    pmtsState->dwBlend         = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                               | DRF_NUM(055, _BLEND, _SHADEMODE,          pCurrentContext->dwRenderState[D3DRENDERSTATE_SHADEMODE])
                               | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                               | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pCurrentContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                               | DRF_NUM(055, _BLEND, _FOGENABLE,          pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGENABLE])
                               | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pCurrentContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if (pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if (pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pCurrentContext->dwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pCurrentContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]);

    pmtsState->dwControl0      = DRF_NUM(055, _CONTROL0, _ALPHAREF,             0)
                               | DRF_DEF(055, _CONTROL0, _ALPHAFUNC,            _ALWAYS)
                               | DRF_DEF(055, _CONTROL0, _ALPHATESTENABLE,      _FALSE)
                               | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
#ifdef NV_CONTROLTRAFFIC
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pCurrentContext->dwRenderState[D3DRENDERSTATE_ZFUNC]))
#else
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                pCurrentContext->dwRenderState[D3DRENDERSTATE_ZFUNC])
#endif
#ifdef NV_FASTLOOPS
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             D3DCULL_NONE)
#else
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             pCurrentContext->dwRenderState[D3DRENDERSTATE_CULLMODE])
#endif
                               | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]);
    if ((pCurrentContext->lpLclZ)
     && (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _ZENABLE,              pCurrentContext->dwRenderState[D3DRENDERSTATE_ZENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, pDriverData->regZPerspectiveEnable)
                                  |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             pDriverData->regZFormat);
        }
        else
        {
            /*
             * W-Buffer.
             */
            // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pCurrentContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,      _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE,   _FALSE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,     _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,    _TRUE);
    if (nvCheckStencilBuffer())
    {
        pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _STENCIL_WRITE_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pCurrentContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    pmtsState->dwFogColor = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR];

    /*
     * Store fog table values as floats in the context structure.
     */
    pCurrentContext->dwFogTableMode   = pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE];
    pCurrentContext->fFogTableStart   = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART];
    pCurrentContext->fFogTableEnd     = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND];
    pCurrentContext->fFogTableDensity = *(float *)&pCurrentContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
    if (pCurrentContext->dwFogTableMode == D3DFOG_LINEAR)
    {
        if (pCurrentContext->fFogTableEnd != pCurrentContext->fFogTableStart)
            pCurrentContext->fFogTableLinearScale = 1.0f / (pCurrentContext->fFogTableEnd - pCurrentContext->fFogTableStart);
        else
            pCurrentContext->fFogTableLinearScale = 0.0f;
    }
    return;
}

//-------------------------------------------------------------------------------------

void nvSetMultiTextureHardwareState
(
)
{
#ifdef  DEBUG
    BOOL                    bStage0UsesTexture = FALSE;
    BOOL                    bStage1UsesTexture = FALSE;
#endif  // DEBUG
    DWORD                   dwStageCount;
    DWORD                   dwStageOp;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3;
    PNVD3DMULTITEXTURESTATE pmtsState;
    DWORD                  *pdwRenderState = 0;

#ifdef NV_STATS
    {
        extern DWORD dwHWPCount;
        dwHWPCount ++;
    }
#endif

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5/DX6 render state to be calculated.
     */
    dbgDisplayContextState((NVDBG_SHOW_RENDER_STATE | NVDBG_SHOW_MTS_STATE), pCurrentContext);

    pdwRenderState = (DWORD *)pCurrentContext->dwRenderState;
    dwStageCount   = 0;
    ptssState0     = &pCurrentContext->tssState[0];
    ptssState1     = &pCurrentContext->tssState[1];
    pmtsState      = &pCurrentContext->mtsState;

    /*
     * Our bump mapping algorithm is done in a single pass with four texture
     * stages being specified.
     * This is the only four stage operation that we are supporting. Look
     * for it now and reject any other 4 stage operations.
     */
    if ((pCurrentContext->tssState[0].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[1].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[2].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[3].dwColorOp != D3DTOP_DISABLE)
     && (pCurrentContext->tssState[4].dwColorOp == D3DTOP_DISABLE))
    {
        ptssState2     = &pCurrentContext->tssState[2];
        ptssState3     = &pCurrentContext->tssState[3];

        /*
         * Make specific check for our version of bump mapping.
         *
         * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
         * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
         *
         * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
         * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
         * anything.
         */
        if ((ptssState0->dwAlphaOp != D3DTOP_SELECTARG1)
         || (ptssState0->dwAlphaArg1 != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
         || (ptssState0->dwColorOp == D3DTOP_DISABLE)
         || (ptssState0->dwTexCoordIndex != 0)
         || (ptssState1->dwAlphaOp != D3DTOP_ADDSIGNED)
         || (!((ptssState1->dwAlphaArg1 == D3DTA_TEXTURE)
            && (ptssState1->dwAlphaArg2 == D3DTA_CURRENT))
          && !((ptssState1->dwAlphaArg1 == D3DTA_CURRENT)
            && (ptssState1->dwAlphaArg2 == D3DTA_TEXTURE)))
         || (ptssState1->dwColorOp == D3DTOP_DISABLE)
         || (ptssState1->dwTexCoordIndex != 1)
         || (ptssState2->dwAlphaOp != D3DTOP_DISABLE)
         || (ptssState2->dwColorOp != D3DTOP_ADDSIGNED2X)
         || (ptssState2->dwColorArg1 != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
         || (ptssState2->dwColorArg2 != D3DTA_DIFFUSE)
         || (ptssState3->dwAlphaOp != D3DTOP_DISABLE)
         || (ptssState3->dwColorOp != D3DTOP_MODULATE)
         || (ptssState3->dwColorArg1 != D3DTA_TEXTURE)
         || (ptssState3->dwTexCoordIndex != 0))
        {
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
            pCurrentContext->dwStageCount       = 1;
            pCurrentContext->bUseDX6Class       = FALSE;
            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
        }
        /*
         * Set up Bump Mapping State.
         *
         * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
         * Texture0 is used for stages with TEXCOORDINDEX = 0
         * Texture1 is used for stages with TEXCOORDINDEX = 1
         */
        nvSetDX6TextureState(0, ptssState0, pmtsState);
        nvSetDX6TextureState(1, ptssState1, pmtsState);
        pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_BUMP;
        pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_BUMP;
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_BUMP;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_BUMP;
        nvSetDX6State(pdwRenderState, pmtsState);
        /*
         *
         */
        pCurrentContext->mtsState.bTSSValid = TRUE;
        pCurrentContext->mtsState.ddrval    = DD_OK;
        /*
         * Enable use of multi-texture triangle class if there is more than one texture
         * stage or if the stencil buffer is enabled.
         */
        pCurrentContext->dwStageCount  = 4;
        pCurrentContext->bUseDX6Class  = TRUE;
        pCurrentContext->dwStateChange = FALSE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
        return;
    }

    /*
     * Clear out the current state.
     */
    pmtsState->dwTextureOffset[0] = 0;
    pmtsState->dwTextureOffset[1] = 0;
    pmtsState->dwTextureFormat[0] = 0;
    pmtsState->dwTextureFormat[1] = 0;
    pmtsState->dwTextureFilter[0] = 0;
    pmtsState->dwTextureFilter[1] = 0;
    pmtsState->dwCombine0Alpha    = 0;
    pmtsState->dwCombine0Color    = 0;
    pmtsState->dwCombine1Alpha    = 0;
    pmtsState->dwCombine1Color    = 0;
    pmtsState->dwBlend            = 0;
    pmtsState->dwControl0         = 0;
    pmtsState->dwControl1         = 0;
    pmtsState->dwControl2         = 0;
    pmtsState->dwFogColor         = 0;

    /*
     * If D3DRENDERSTATE_TEXTUREMAPBLEND was invoked more recently than TEXTURESTAGESTATE,
     * then use the current TEXTUREMAPBLEND setting.
     */
    if (pCurrentContext->bUseTBlendSettings)
    {
        if (!nvCheckStencilBuffer())
        {
            /*
             * When using TEXTUREMAPBLEND settings, as long as there is no stencil buffer we
             * can use the faster DX5 class.
             */
            nvSetHardwareState();
            pCurrentContext->bUseDX6Class       = FALSE;
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->dwStateChange      = FALSE;
        }
        else
        {
            DWORD   dwZOHMode, dwFOHMode;
            dwZOHMode = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
            dwFOHMode = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

            /*
             * Setup stage 0 texture offset
             * Setup stage 0 texture format
             */
            nvSetDX6TextureState(0, ptssState0, pmtsState);

            /*
             * Setup combine0 based on the TEXTUREMAPBLEND setting.
             */
            switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND])
            {
                case D3DTBLEND_DECAL:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECAL;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECAL;
                    break;

                case D3DTBLEND_MODULATE:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
                    break;

                case D3DTBLEND_DECALMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK;
                    break;

                case D3DTBLEND_MODULATEMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK;
                    break;

                case D3DTBLEND_COPY:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_COPY;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_COPY;
                    break;

                case D3DTBLEND_ADD:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_ADD;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_ADD;
                    break;
            }

            /*
             * If there is no texture specified, then set to modulatealpha.
             */
            if (!pCurrentContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE])
            {
                pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
            }

            /*
             * Set the default texture format and offset.
             */
            pmtsState->dwTextureOffset[1] = pCurrentContext->dwDefaultTextureOffset;
            pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                          | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                          | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
            pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                          |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

            /*
             * Setup stage texture filter
             */
            pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

            pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

            /*
             * Always set combine1 to pass through.
             */
            pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
            pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

            /*
             * Use the first set of texture coordinates when disabled.
             */
            pmtsState->dwUVOffset[1] = 0;

            /*
             * Setup the rest of the DX6 triangle state.
             */
            nvSetDX6State(pdwRenderState, pmtsState);

            /*
             * Need to use the DX6 triangle class here.
             */
            pCurrentContext->bUseDX6Class       = TRUE;
            pCurrentContext->mtsState.bTSSValid = TRUE;
            pCurrentContext->dwStateChange      = FALSE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
        }

        pCurrentContext->mtsState.ddrval    = DD_OK;
        pCurrentContext->dwStageCount       = 1;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }


    /*
     * Compile the hardware state for each texture stage.
     * Any errors during compile will result in disabling multi-textureing.
     *
     * Stage 0.
     */
    if (ptssState0->dwColorOp == D3DTOP_DISABLE)
    {
        /*
         * No texturing at all!
         */
        if (!nvCheckStencilBuffer())
        {
            nvConvertTextureStageToDX5Class();
            pCurrentContext->bUseDX6Class       = FALSE;
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->dwStateChange      = FALSE;
        }
        else
        {
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->bUseDX6Class       = TRUE;
            pCurrentContext->mtsState.bTSSValid = TRUE;
        }
        pCurrentContext->mtsState.ddrval    = DD_OK;
        pCurrentContext->dwStageCount       = 1;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pCurrentContext);
        return;
    }

    /*
     * Check for a texture stage state that can be handled by the DX5 class.
     */
    if ((ptssState1->dwColorOp == D3DTOP_DISABLE)
     && (!nvCheckStencilBuffer()))
    {
        /*
         * If there's only one texture stage, and no stencil buffer.
         * There's an opportunity to use the DX5 class for this
         * operation and get 2 Pixels per clock.
         */
        if (nvConvertTextureStageToDX5Class())
        {
            /*
             * Single texture stage was converted to DX5 class.
             * Use it instead.
             */
            pCurrentContext->bUseDX6Class  = FALSE;
            pCurrentContext->dwStateChange = FALSE;

            /*
             * Show that the DX6 class state is not calculated.
             */
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = DD_OK;
            return;
        }
        if (ptssState0->dwAlphaOp != D3DTOP_DISABLE)
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Single Texture Stage Using DX6 Class!!!");
    }

    /*
     * Setup stage 0 texture offset
     * Setup stage 0 texture format
     */
    nvSetDX6TextureState(0, ptssState0, pmtsState);

#ifdef NV_TEX2
    /*
     * setup current texture
     */
    pCurrentContext->pTexture0 = (PNVD3DTEXTURE)ptssState0->dwTextureMap;
#endif

    /*
     * Setup stage 0 Alpha Combiner.
     */
    dwStageOp = ptssState0->dwAlphaOp;
    switch (ptssState0->dwAlphaArg1 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwTextureMap)
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
            {
                /*
                 * Disable Arg1 if there is no texture handle selected.
                 */
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;
    }
    arg1Invert = !((ptssState0->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
    switch (ptssState0->dwAlphaArg2 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            /*
             * D3DTA_TEXTURE isn't really a valid argument for Arg2.
             */
            if (ptssState0->dwTextureMap)
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;
    }
    arg2Invert = !((ptssState0->dwAlphaArg2 & D3DTA_COMPLEMENT) == 0);
#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwAlphaOp != D3DTOP_DISABLE)
     && (ptssState0->dwTextureMap))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG
    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwColorOp != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1SelectStage1;

#if 0
                /*
                 * When there is a second texture stage, stage 0 for PREMODULATE is defined as:
                 * Stage 0 arg1 * Stage 1 arg1
                 */
                switch (ptssState1->dwAlphaArg1 & D3DTA_SELECTMASK)
                {
                    case D3DTA_DIFFUSE:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_CURRENT:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT;
                        break;
                    case D3DTA_TEXTURE:
                        if (ptssState1->dwTextureMap)
                            arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                        else
                            arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TFACTOR:
                        arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
                        break;
                }
                arg1InvertStage1 = !((ptssState1->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
#else
                if (ptssState1->dwTextureMap)
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1 = NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL;
#endif
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            break;
        default:
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDALPHAOPERATION;
            pCurrentContext->dwStageCount       = 1;
            if (!nvCheckStencilBuffer())
                pCurrentContext->bUseDX6Class       = FALSE;
            else
                pCurrentContext->bUseDX6Class       = TRUE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
    }


    /*
     * Setup stage 0 Color Combiner.
     */
    dwStageOp = ptssState0->dwColorOp;
    switch (ptssState0->dwColorArg1 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwTextureMap)
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
            {
                /*
                 * Disable Arg1 if there is no texture handle selected.
                 */
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;
    }
    arg1Invert   = !((ptssState0->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState0->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
    switch (ptssState0->dwColorArg2 & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            /*
             * D3DTA_TEXTURE isn't really a valid argument for Arg2.
             */
            if (ptssState0->dwTextureMap)
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;
    }
    arg2Invert   = !((ptssState0->dwColorArg2 & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState0->dwColorArg2 & D3DTA_ALPHAREPLICATE) == 0);
#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwColorOp != D3DTOP_DISABLE)
     && (ptssState0->dwTextureMap))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG
    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwColorOp != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1AlphaRepStage1;
                DWORD   arg1SelectStage1;

#if 0
                /*
                 * When there is a second texture stage, stage 0 for PREMODULATE is defined as:
                 * Stage 0 arg1 * Stage 1 arg1
                 */
                switch (ptssState1->dwColorArg1 & D3DTA_SELECTMASK)
                {
                    case D3DTA_DIFFUSE:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_CURRENT:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TEXTURE:
                        if (ptssState1->dwTextureMap)
                            arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                        else
                            arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                        break;
                    case D3DTA_TFACTOR:
                        arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
                        break;
                }
                arg1InvertStage1   = !((ptssState1->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
                arg1AlphaRepStage1 = !((ptssState1->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
#else
                if (ptssState1->dwTextureMap)
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1   = NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL;
                arg1AlphaRepStage1 = NV055_COMBINE_0_COLOR_ALPHA_1_COLOR;
#endif
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRepStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            break;

        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        default:
            nvSetDefaultMultiTextureHardwareState();
            pCurrentContext->mtsState.bTSSValid = FALSE;
            pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDCOLOROPERATION;
            pCurrentContext->dwStageCount       = 1;
            if (!nvCheckStencilBuffer())
                pCurrentContext->bUseDX6Class       = FALSE;
            else
                pCurrentContext->bUseDX6Class       = TRUE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

            /*
             * Note that the state has changed and needs to be sent to the hardware.
             */
            NV_FORCE_TRI_SETUP(pCurrentContext);
            return;
    }
    dwStageCount++;

    /*
     * Stage 1.
     */
    if (ptssState1->dwColorOp != D3DTOP_DISABLE)
    {
        nvSetDX6TextureState(1, ptssState1, pmtsState);

#ifdef NV_TEX2
        /*
         * setup current texture
         */
        pCurrentContext->pTexture1 = (PNVD3DTEXTURE)ptssState1->dwTextureMap;
#endif
        /*
         * Setup stage 1 Alpha Combiner.
         */
        dwStageOp = ptssState1->dwAlphaOp;
        switch (ptssState1->dwAlphaArg1 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwTextureMap)
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                {
                    /*
                     * Disable Arg1 if there is no texture handle selected.
                     */
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
//                    dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
        }
        arg1Invert = !((ptssState1->dwAlphaArg1 & D3DTA_COMPLEMENT) == 0);
        switch (ptssState1->dwAlphaArg2 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                /*
                 * D3DTA_TEXTURE isn't really a valid argument for Arg2.
                 */
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
        }
        arg2Invert = !((ptssState1->dwAlphaArg2 & D3DTA_COMPLEMENT) == 0);
#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwAlphaOp != D3DTOP_DISABLE)
         && (ptssState1->dwTextureMap))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG
        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;//DX6TRI_COMBINE1ALPHA_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:

                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            default:
                nvSetDefaultMultiTextureHardwareState();
                pCurrentContext->mtsState.bTSSValid = FALSE;
                pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDALPHAOPERATION;
                pCurrentContext->dwStageCount       = 1;
                if (!nvCheckStencilBuffer())
                    pCurrentContext->bUseDX6Class       = FALSE;
                else
                    pCurrentContext->bUseDX6Class       = TRUE;

                /*
                 * This code is only enabled in the DEBUG build.
                 * Display the hardware registers that were calculated.
                 */
                dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

                /*
                 * Note that the state has changed and needs to be sent to the hardware.
                 */
                NV_FORCE_TRI_SETUP(pCurrentContext);
                return;
        }

        /*
         * Setup stage 1 Color Combiner.
         */
        dwStageOp = ptssState1->dwColorOp;
        switch (ptssState1->dwColorArg1 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwTextureMap)
                    arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                else
                {
                    /*
                     * Disable Arg1 if there is no texture handle selected.
                     */
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
//                    dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;
        }
        arg1Invert   = !((ptssState1->dwColorArg1 & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState1->dwColorArg1 & D3DTA_ALPHAREPLICATE) == 0);
        switch (ptssState1->dwColorArg2 & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                /*
                 * D3DTA_TEXTURE isn't really a valid argument for Arg2.
                 */
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;
        }
        arg2Invert   = !((ptssState1->dwColorArg2 & D3DTA_COMPLEMENT) == 0);
        arg2AlphaRep = !((ptssState1->dwColorArg2 & D3DTA_ALPHAREPLICATE) == 0);
#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwColorOp != D3DTOP_DISABLE)
         && (ptssState1->dwTextureMap))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG
        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            default:
                nvSetDefaultMultiTextureHardwareState();
                pCurrentContext->mtsState.bTSSValid = FALSE;
                pCurrentContext->mtsState.ddrval    = D3DERR_UNSUPPORTEDCOLOROPERATION;
                pCurrentContext->dwStageCount       = 1;
                if (!nvCheckStencilBuffer())
                    pCurrentContext->bUseDX6Class       = FALSE;
                else
                    pCurrentContext->bUseDX6Class       = TRUE;

                /*
                 * This code is only enabled in the DEBUG build.
                 * Display the hardware registers that were calculated.
                 */
                dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

                /*
                 * Note that the state has changed and needs to be sent to the hardware.
                 */
                NV_FORCE_TRI_SETUP(pCurrentContext);
                return;
        }
        dwStageCount++;
#ifdef  DEBUG
        if (bStage0UsesTexture && bStage1UsesTexture)
        {
            PNVD3DTEXTURE   pTexture0, pTexture1;
            pTexture0 = (PNVD3DTEXTURE)(ptssState0->dwTextureMap);
            pTexture1 = (PNVD3DTEXTURE)(ptssState1->dwTextureMap);
            if (pTexture0->dwTextureContextDma != pTexture1->dwTextureContextDma)
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08lx,  Context = %08lx", ptssState0->dwTextureMap, pTexture0->dwTextureContextDma);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08lx,  Context = %08lx", ptssState1->dwTextureMap, pTexture1->dwTextureContextDma);
                dbgD3DError();
            }
            else
            {
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - YEAH! Multi-Textures Memory Space OK!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08lx,  Context = %08lx", ptssState0->dwTextureMap, pTexture0->dwTextureContextDma);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08lx,  Context = %08lx", ptssState1->dwTextureMap, pTexture1->dwTextureContextDma);
            }
        }
#endif  // DEBUG
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((pDriverData->regTexelAlignment & REG_TA_ZOH_MASK) == REG_TA_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((pDriverData->regTexelAlignment & REG_TA_FOH_MASK) == REG_TA_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = pCurrentContext->dwDefaultTextureOffset;
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     pCurrentContext->dwDefaultTextureContextDma)
                                      | DRF_NUM(055, _FORMAT, _COLOR,           pCurrentContext->dwDefaultTextureColorFormat)
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, pDriverData->regLODBiasAdjust);

        /*
         * No stage 1 texture blending.
         * Set the stage 1 combiners to something sane.
         */
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;

#ifdef NV_TEX2
        /*
         * setup current texture
         */
        pCurrentContext->pTexture0 = NULL;
#endif
    }
    nvSetDX6State(pdwRenderState, pmtsState);

    /*
     * If stage 3 is not disabled, flag the error but the hardware will still
     * use the first two stages of setup.
     */
    if (pCurrentContext->tssState[2].dwColorOp != D3DTOP_DISABLE)
    {
        pCurrentContext->mtsState.bTSSValid = FALSE;
        pCurrentContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pCurrentContext->bUseDX6Class       = TRUE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);

        return;
    }

    /*
     *
     */
    pCurrentContext->mtsState.bTSSValid = TRUE;
    pCurrentContext->mtsState.ddrval    = DD_OK;

    /*
     * Assume that the DX6 class is going to be used for rendering.
     * stage or if the stencil buffer is enabled.
     */
    pCurrentContext->bUseDX6Class  = TRUE;
    pCurrentContext->dwStateChange = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pCurrentContext);
    return;
}
#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4prof.c ===
#ifdef NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4PROF.C                                                         *
*   NV4 Specific profiling routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/28/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4dinc.h"
#include "..\..\..\..\..\sdk\nvidia\inc\nvcm.h"

#ifdef NV_PROFILE

#if 0

/*
 * ----------
 * Locutus II
 * ----------
 */

/*
 * header files
 * ------------
 */
#include <stdio.h>
#include "..\..\..\..\..\apps\performance\locutus ii\dbase.h"

/*
 * constants
 * ---------
 */
#define L2_REG_VALUE            "Direct3D"

#define NVP_CAPMAX              65536
#define NVP_CAPMARK             65000

/*
 * locals
 * ------
 */
DWORD   nvpContextCount  = 0;
HANDLE  nvpFile          = 0;
DWORD   nvpCount         = 0;
DWORD   nvpEnableBits    = 0;
DWORD   nvpCyclesPerNanoSecond = 0;
__int64 nvpStartTime;
__int64 nvpTime[256];
BYTE    nvpData[NVP_CAPMAX];

L2ALPHABET nvpL2Alphabet[] =
{
    { NVP_T_CLOCK,      "t.clock",              L2_ALPHABETFLAG_TIME},
    { NVP_T_FLUSH,      "t.flush2disk",         L2_ALPHABETFLAG_TIME},
    { NVP_T_SCENE,      "t.scene",              L2_ALPHABETFLAG_TIME},
    { NVP_T_FLIP,       "t.wait4flip",          L2_ALPHABETFLAG_TIME},
    { NVP_T_DP2,        "t.dprim2",             L2_ALPHABETFLAG_TIME},
    { NVP_T_FREECOUNT,  "t.wait4pushbuffer",    L2_ALPHABETFLAG_TIME},
    { NVP_T_SCENE,      "t.scene",              L2_ALPHABETFLAG_TIME},
    { NVP_T_TSTAGE,     "t.wait4texstaging",    L2_ALPHABETFLAG_TIME},

    { NVP_E_PUT,        "e.put",                L2_ALPHABETFLAG_TIME},
    { NVP_E_BEGINSCENE, "e.beginscene",         L2_ALPHABETFLAG_TIME},

    { NVP_C_PENDING,    "c.pending",            L2_ALPHABETFLAG_COUNT},
};

/*
 * public functions
 * ----------------
 */

/*
 * nvpFlush
 *
 * commits data to disk
 */
void nvpFlush
(
    void
)
{
    /*
     * do we have pending data?
     */
    if (nvpCount) {
        DWORD dw;

        /*
         * time the HD access
         */
        NVP_START (NVP_T_FLUSH);

        /*
         * flush data
         */
        WriteFile(nvpFile,nvpData,nvpCount,&dw,0);
        FlushFileBuffers (nvpFile);
        nvpCount = 0;

        /*
         * log HD access time
         */
        NVP_STOP (NVP_T_FLUSH);
        nvpLogTime (NVP_T_FLUSH,nvpTime[NVP_T_FLUSH]);
    }
}

/*
 * nvpCreate
 *
 * creates a profiling session
 */
void nvpCreate
(
    void
)
{
    HKEY  hKey;
    char  szFilename[512];
    DWORD i,j;

    /*
     * setup defaults and read overrides from regisry
     */
    nvpCyclesPerNanoSecond = 1000 / global.dwProcessorSpeed; // works up to 1GHz
    nvpEnableBits          = 7;

    /*
     * open
     */
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L2_REG_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType  = REG_DWORD;
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwValue;

        /*
         * read enable bits
         */
        if (RegQueryValueEx(hKey,
                            L2_REG_VALUE,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpEnableBits = dwValue;
        }

        /*
         * close
         */
        RegCloseKey (hKey);
    }

    /*
     * always force flush2disk and clock ticks on
     * always disable unused bits
     */
    nvpEnableBits &= NVP_EVERYTHING;
    nvpEnableBits |= 3;

    /*
     * create profiling file
     */
    sprintf (szFilename,"\\cap%02d.lc2",++nvpContextCount);
    nvpFile = CreateFile(szFilename,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvpFile == INVALID_HANDLE_VALUE)
    {
        OutputDebugString ("Profiler failed\n");
        __asm int 3;
    }
    nvpCount = 0;

    /*
     * write header
     */
    for (i = nvpEnableBits, j = 0; i;)
    {
        i &= i-1;
        j++;
    }
    {
        L2HEADER nvpL2Header =
        {
            L2_FILEID,
            j
        };
        memcpy (nvpData + nvpCount,&nvpL2Header,sizeof(nvpL2Header));
        nvpCount += sizeof(nvpL2Header);
    }

    /*
     * write alphabet entries
     */
    for (j = 0; j < 32; j++)
    {
        if (nvpEnableBits & (1 << j))
        {
            for (i = 0; i<sizeof(nvpL2Alphabet) / sizeof(nvpL2Alphabet[0]); i++)
            {
                if (j == nvpL2Alphabet[i].bID)
                {
                    memcpy (nvpData + nvpCount,nvpL2Alphabet + i,sizeof(nvpL2Alphabet[0]));
                    nvpCount += sizeof(nvpL2Alphabet[0]);
                    break;
                }
            }
        }
    }

    /*
     * log start time - used for events
     *  spoof my macros to give me negative abs time
     */
    nvpTime[0] = 0;
    NVP_START(0);
    nvpStartTime = nvpTime[0];
}

/*
 * nvpDestroy
 *
 * terminates profiling session
 */
void nvpDestroy
(
    void
)
{
    /*
     * write out pending data
     */
    nvpFlush();

    /*
     * close file
     */
    CloseHandle (nvpFile);

    /*
     * reset values
     */
    nvpFile = 0;
}

/*
 * nvpLogCount
 *
 * logs a count
 */
void nvpLogCount
(
    DWORD   id,
    __int64 count
)
{
    if (nvpEnableBits & (1 << id))
    {
        L2ENTRY *entry = (L2ENTRY*)(nvpData + nvpCount);
        entry->bID     = (BYTE)id;
        entry->qwValue = count;
        nvpCount += sizeof(L2ENTRY);
        if (nvpCount > NVP_CAPMARK) nvpFlush();
    }
}

/*
 * nvpLogTime
 *
 * logs a time in nanoseconds (argument is in clock ticks)
 */
void nvpLogTime
(
    DWORD   id,
    __int64 time
)
{
    if (nvpEnableBits & (1 << id))
    {
        L2ENTRY *entry = (L2ENTRY*)(nvpData + nvpCount);
        entry->bID     = (BYTE)id;
        entry->qwValue = time * nvpCyclesPerNanoSecond;
        nvpCount += sizeof(L2ENTRY);
        if (nvpCount > NVP_CAPMARK) nvpFlush();
    }
}

/*
 * nvpLogEvent
 *
 * logs the time an event took place
 */
void nvpLogEvent
(
    DWORD id
)
{
    if (nvpEnableBits & (1 << id))
    {
        nvpTime[255] = nvpStartTime;
        NVP_STOP(255);
        nvpLogTime (id,nvpTime[255]);
    }
}

#endif // 0

#if 1

/*
 * Locutus profiler section
 */
DWORD nvGetCPUSpeed (void);

//////////////////////////////////////////////////////////////////////////////
// constants
#define LOCUTUS_REG_KEY             "SOFTWARE\\NVIDIA Corporation\\Locutus"
#define LOCUTUS_REG_ENABLEBITS      "D3DEnableBits"
#define LOCUTUS_REG_TRIPERSECWINDOW "D3DTriPerSecWindow"

#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

#define CAP_SIZE            (65536*8)
#define CAP_MARK            (CAP_SIZE - 32)

//////////////////////////////////////////////////////////////////////////////
// structures
#pragma pack(push,1)

typedef __int64 CBTTime;
typedef int     CBTCount;

typedef struct {
    char  m_szName[16];                 // human readable description
    DWORD m_dwRecordSize;               // size of record
    DWORD m_dwAttributes;               // Record description
} CBTAlphabet;

typedef struct {
    DWORD dwFileType;
    DWORD dwClockSpeed;
    DWORD dwAlphabetCount;
} CBTHeader;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// locals
DWORD   nvDeviceBase       = 0;
DWORD   nvpEnableBits      = 0x0000fffb;
DWORD   nvpTriPerSecWindow = 50;

__int64 nvpTime[256];           // stopwatch storage
#define nvp_time nvpTime        // alias
int     nvp_context_count = 1;  // we count contexi to generate unique file names
HANDLE  nvp_file          = 0;  // capture file
BYTE    nvp_buffer[CAP_SIZE];   // local capture buffer
DWORD   nvp_index;              // buffer index

CBTAlphabet nvp_alphabet[] = {                //            mask   default groups
    { "BeginScene",         0,  BTAA_EVENT }, // 0          0x00000001  *
    { "Put",                0,  BTAA_EVENT }, // 1          0x00000002  *
    { "TriDispatch",        0,  BTAA_EVENT }, // 2          0x00000004     abc
    { "SceneTime",          8,  BTAA_TIME  }, // 3          0x00000008  *
    { "FreeCountTime",      8,  BTAA_TIME  }, // 4          0x00000010  *
    { "FlipTime",           8,  BTAA_TIME  }, // 5          0x00000020  *
    { "TStageTime",         8,  BTAA_TIME  }, // 6          0x00000040  *
    { "DP2Time",            8,  BTAA_TIME  }, // 7          0x00000080  *
    { "HDFlushTime",        8,  BTAA_TIME  }, // 8          0x00000100  *
    { "TexWaitTime",        8,  BTAA_TIME  }, // 9          0x00000200  *
    { "TexSWBltTime",       8,  BTAA_TIME  }, // 10         0x00000400  *
    { "TexHWBltTime",       8,  BTAA_TIME  }, // 11         0x00000800  *
    { "InnerLoopTime",      8,  BTAA_TIME  }, // 12         0x00001000  *
    { "BuildLoopTime",      8,  BTAA_TIME  }, // 13         0x00002000  *
    { "PendingSize",        4,  BTAA_COUNT }, // 14         0x00004000  *
    { "BltArea",            4,  BTAA_COUNT }, // 15         0x00008000  *
    { "1pix/clk",           4,  BTAA_COUNT }, // 16         0x00010000    a
    { "2pix/clk",           4,  BTAA_COUNT }, // 17         0x00020000    a
    { "TriArea",            4,  BTAA_COUNT }, // 18         0x00040000      c
    { "PixPerSec",          4,  BTAA_COUNT }, // 19         0x00080000     b
    { "TriCount",           4,  BTAA_COUNT }, // 20         0x00100000     b
};

void nvpCreate (void) {
    HKEY  hKey;
    char  s[256];

    nvDeviceBase = (U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum);

    wsprintf (s,"\\captr%03d.btd",nvp_context_count);
    nvp_file=CreateFile(s,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvp_file==INVALID_HANDLE_VALUE) {
        MessageBeep (0);
        __asm int 3;
    }
    nvp_context_count ++;

// place header
    nvp_index = 0;
    *(DWORD*)(nvp_buffer + nvp_index) = BTFT_1;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = nvGetCPUSpeed();
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = sizeof(nvp_alphabet)/sizeof(nvp_alphabet[0]);
    nvp_index += 4;
    memcpy (nvp_buffer+nvp_index,nvp_alphabet,sizeof(nvp_alphabet));
    nvp_index += sizeof(nvp_alphabet);

// read registry for enabled bits
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, LOCUTUS_REG_KEY, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType  = REG_DWORD;
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwValue;

        /*
         * read enable bits
         */
        if (RegQueryValueEx(hKey,
                            LOCUTUS_REG_ENABLEBITS,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpEnableBits = dwValue;
        }

        /*
         * read the tri per sec window (only used when tripersec is enabled)
         */
        if (RegQueryValueEx(hKey,
                            LOCUTUS_REG_TRIPERSECWINDOW,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize) == ERROR_SUCCESS)
        {
            nvpTriPerSecWindow = dwValue;
        }

        /*
         * close
         */
        RegCloseKey (hKey);
    }

    /*
     * enable compulsory flags
     */
    if (nvpEnableBits & ((1 << NVP_C_1PIXCLK) | (1 << NVP_C_2PIXCLK)))
    {
        nvpEnableBits |= (1 << NVP_C_1PIXCLK) | (1 << NVP_C_2PIXCLK) | (1 << NVP_E_TRIDISP);
    }

    if (nvpEnableBits & (1 << NVP_C_TRIAREA))
    {
        nvpEnableBits |= (1 << NVP_E_TRIDISP);
    }

    if (nvpEnableBits & (1 << NVP_C_PIXPERSEC))
    {
        nvpEnableBits |= (1 << NVP_E_TRIDISP);
    }
}

void nvpDestroy (void) {
    nvp_buffer[nvp_index++] = BTRT_EOF;
    nvpFlush();
    CloseHandle (nvp_file);
}

void nvpFlush (void) {
    NVP_START (NVP_T_HDFLUSH);
    if (nvp_index) {
        DWORD dw;
        if (!WriteFile(nvp_file,nvp_buffer,nvp_index,&dw,0)) {
            DWORD dw=GetLastError();
            __asm {
                mov eax,[dw]
                int 3
            }
        }
        FlushFileBuffers (nvp_file);
        nvp_index = 0;
    }
    NVP_STOP (NVP_T_HDFLUSH);
    nvpLogTime (NVP_T_HDFLUSH,nvpTime[NVP_T_HDFLUSH]);
}

void nvpLogEvent (DWORD id) {
    if (nvpEnableBits & (1<<id))
    {
        nvp_buffer[nvp_index++] = (BYTE)id;
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}

void nvpLogCount (DWORD id,int count) {
    if (nvpEnableBits & (1<<id))
    {
        BYTE *b = nvp_buffer + nvp_index;
        *((BYTE*)b)         = (BYTE)id;
        *((CBTCount*)(b+1)) = count;
        nvp_index += sizeof(BYTE)+sizeof(CBTCount);
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}

void nvpLogTime (DWORD id,__int64 time) {
    if (nvpEnableBits & (1<<id))
    {
        BYTE *b = nvp_buffer + nvp_index;
        *((BYTE*)b)        = (BYTE)id;
        *((CBTTime*)(b+1)) = time;
        nvp_index += sizeof(BYTE)+sizeof(CBTTime);
        if (nvp_index>CAP_MARK) nvpFlush();
    }
}
#endif // 1

#endif // NV_PROFILE

//////////////////////////////////////////////////////////////////////////////
// Processor Speed
//
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)

__int64 _clock_ticks;
DWORD nvGetCPUSpeed (void) {
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;
#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium
#endif // #ifndef WINNT
    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
#ifndef WINNT
    GetTickCount(); // break in cache
#endif // #ifndef WINNT
    {
#ifndef WINNT
        DWORD start,stop;
        start = GetTickCount();
#else
        LONGLONG start,stop;
        EngQueryPerformanceCounter(&start);
#endif // #ifdef WINNT
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
#ifndef WINNT
        stop = GetTickCount();
#else
        EngQueryPerformanceCounter(&stop);
#endif // #ifndef WINNT
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;
#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium
#endif // #ifndef WINNT
    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

BOOL nvDetectKATMAI
(
    void
)
{
    DWORD       dwCaps;
//    DWORD       dwCR4;
    SYSTEM_INFO si;

#ifndef WINNT
    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium
#endif // #ifndef WINNT

    __asm
    {
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
    }

    return ((dwCaps & 0x02000000) /*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}

#endif // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tex.c ===
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TEX.C                                                          *
*   HW Specific Texture routines.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - re-wrote and cleaned up.     *
*       Ben de Waal                 10/12/98 - overhaul                     *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"
#include "nvheap.h"

#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#include "nvos.h"
#endif  /* MULTI_MON */

/***************************************************************************\
  texture manager 2.0 implementation notes:

  * texture has one optional linear surface. Depending on its heap location
    the logic will use it to stage for AGP/PCI -> VID transfers. The linear
    surface is not maintained at all times. For AGP swizzled surfaces the
    linear surface will only be made valid for lock/unlocks and will be
    invalidated on Blts. This saves us from maintaining more than one surface
    with the CPU. If the swizzle surface is in VID the the linear surface
    can be used for staging during blt and it will stay valid.

  * texture has 1 or more swizzled surfaces. Only one surface is current at
    a time but the others retire lazily (and therefore more than one swizzled
    surface can be used at a time). The current surface might have mipmaps
    that is not carriend forward from the previous texture. In order to use
    them one must bring them forward. nvTextureRef takse care of this and is
    called before we render triangles

  * We maintain dirty rects for locks and blts

\***************************************************************************/

#ifndef WINNT
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif // #ifndef WINNT

/*
 * external
 */
void nvTextureAutoMipMap (PNVD3DTEXTURE);

#ifdef NV_TEX2
/*****************************************************************************
 * helpers
 * -------
 *****************************************************************************/

/*
 * nvTextureCalcMipMapSize
 *
 * calculates the amount of bytes needed with a given number of mipmaps
 */
DWORD nvTextureCalcMipMapSize
(
    DWORD dwLogU,
    DWORD dwLogV,
    DWORD dwMipMapLevels
)
{
    DWORD dwBits  = ((dwLogU + dwLogV) & 1) ? 0xaaaaaaaa : 0x55555555;
    DWORD dwTotal =  ((1 << (dwLogU + dwLogV + 1)) - 1) & dwBits;
    DWORD dwMask  = ~((1 << (dwLogU + dwLogV + 2 - dwMipMapLevels * 2)) - 1);
    return dwTotal & dwMask;
}

/*
 * GetTextureAddrFromOffset
 *
 * computes the surface address from a heap ID and an offset
 */
__inline DWORD GetTextureAddrFromOffset
(
    DWORD dwOffset,
    DWORD dwLocation
)
{
#ifndef WINNT
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwOffset + pDriverData->BaseAddress)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwOffset + pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwOffset + pDriverData->pTextureHeapBase)
                    : dwOffset; // base address == 0 for sys memory
#else
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwOffset + pDriverData->ppdev->pjScreen)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwOffset + pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwOffset + pDriverData->pTextureHeapBase)
                    : dwOffset; // base address == 0 for sys memory
#endif  // WINNT
}

/*
 * GetTextureOffsetFromAddr
 *
 * computes the surface address from a heap ID and an offset
 */
__inline DWORD GetTextureOffsetFromAddr
(
    DWORD dwAddr,
    DWORD dwLocation
)
{
#ifndef WINNT
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwAddr - pDriverData->BaseAddress)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwAddr - pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwAddr - pDriverData->pTextureHeapBase)
                    : 0xffffffff; // HW cannot reach sys memory
#else
    return (dwLocation & NV4_TEXLOC_VID)
           ? (dwAddr - (DWORD)pDriverData->ppdev->pjScreen)
           : (dwLocation & NV4_TEXLOC_AGP)
                ? (dwAddr - pDriverData->GARTLinearBase)
                : (dwLocation & NV4_TEXLOC_PCI)
                    ? (dwAddr - pDriverData->pTextureHeapBase)
                    : 0xffffffff; // HW cannot reach sys memory
#endif  // WINNT
}

/*
 * nvTextureGrowDirtyRect
 *
 * grows dirty rect to include the given rectangle
 */
__inline void nvTextureGrowDirtyRect
(
    PNVD3DTEXTURE pTexture,
    DWORD         x0,
    DWORD         y0,
    DWORD         x1,
    DWORD         y1
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureGrowDirtyRect: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return;
    }
#endif //DEBUG

    /*
     * if rect is empty, trivially accept new
     */
    if ((pTexture->dwDirtyX0 == pTexture->dwDirtyX1)
     || (pTexture->dwDirtyY0 == pTexture->dwDirtyY1))
    {
        pTexture->dwDirtyX0 = x0;
        pTexture->dwDirtyY0 = y0;
        pTexture->dwDirtyX1 = x1;
        pTexture->dwDirtyY1 = y1;
        return;
    }

    /*
     * grow
     */
    pTexture->dwDirtyX0 = min(pTexture->dwDirtyX0,x0);
    pTexture->dwDirtyY0 = min(pTexture->dwDirtyY0,y0);
    pTexture->dwDirtyX1 = min(pTexture->dwDirtyX1,x1);
    pTexture->dwDirtyY1 = min(pTexture->dwDirtyY1,y1);

    /*
     * done
     */
    return;
}

/*
 * nvTextureDirtyRectEmpty
 *
 * returns true is dirty rect is empty
 */
__inline BOOL nvTextureDirtyRectEmpty
(
    PNVD3DTEXTURE pTexture
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureGrowDirtyRect: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif //DEBUG

    return (pTexture->dwDirtyX0 == pTexture->dwDirtyX1) || (pTexture->dwDirtyY0 == pTexture->dwDirtyY1);
}

/*
 * nvTextureAllocSurface
 *
 * allocates a surface in any of the given heaps
 */
BOOL nvTextureAllocSurface
(
    LPDDRAWI_DIRECTDRAW_GBL lpDriverObject,
    DWORD  dwAllocFlags,
    DWORD  dwAllocPreference,   // which heap gets preference (1 set bit only)
    DWORD  dwSize,
    DWORD *pdwAddr,
    DWORD *pdwResultFlags
)
{
    DWORD dwAddr;

    // we have to allow for the "legitimate" possibility of a zero-size texture
    // here since some dumb apps seem to set un-created textures from time to time
    // without actually using them to render.
    if (!dwSize)
    {
        DPF ("nvTextureAllocSurface: dwSize == 0");
        return FALSE;
    }

    /*
     * no preference would start with video memory
     */
    dwAllocPreference = (dwAllocPreference) ? (dwAllocPreference & NV4_TEXLOC_ANYWHERE)
                                            : NV4_TEXLOC_VID;

    /*
     * if the video res is 1k or larger
     */
    if (pCurrentContext && (pCurrentContext->lpLcl->lpGbl->wWidth >= pDriverData->regAGPTexCutOff))
    {
        /*
         * if we are allowed agp and video memory to allocate in
         */
        if ((dwAllocFlags & (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)) == (NV4_TEXLOC_VID | NV4_TEXLOC_AGP))
        {
            /*
             * if we want video
             */
            if (dwAllocPreference == NV4_TEXLOC_VID)
            {
                /*
                 * override to agp
                 */
                dwAllocPreference = NV4_TEXLOC_AGP;
            }
        }
    }

    /*
     * try to allocate in all allowed memory heaps
     */
    while (dwAllocFlags)
    {
        /*
         * video
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_VID)
        {
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE)
            {
                /*
                 * Call DDRAW to allocate memory from the video memory heap.
                 */
                NVHEAP_ALLOC(dwAddr, dwSize, TYPE_TEXTURE);
                if (dwAddr)
                {
                    /*
                     * Increment count of video memory surfaces allocated.
                     */
                    pDriverData->DDrawVideoSurfaceCount++;

                    /*
                     * Handy statistics.
                     */
                    statTextureCountVideo++;
                    statTextureSizeVideo += dwSize;
                    //statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                    //statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                    /*
                     * done
                     */
#ifndef WINNT
                    *pdwAddr        = dwAddr;
#else
                    *pdwAddr        = (dwAddr + (DWORD)pDriverData->ppdev->pjScreen);
#endif  // WINNT
                    *pdwResultFlags = NV4_TEXLOC_VID;
                    return TRUE;
                }
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in VID failed");
            dwAllocFlags &= ~NV4_TEXLOC_VID;
        }

        /*
         * agp
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                /*
                 * On AGP, allocate call DDRAW to allocate the AGP memory.
                 */
                dwAddr = (DWORD)AllocAGPHeap(lpDriverObject, dwSize);
                if (dwAddr)
                {
                    /*
                     * Handy statistics.
                     */
                    statTextureCountAgpHeap++;
                    statTextureSizeAgpHeap += dwSize;
                    //statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                    //statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                    /*
                     * done
                     */
                    *pdwAddr        = dwAddr;
                    *pdwResultFlags = NV4_TEXLOC_AGP;
                    return TRUE;
                }
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in AGP failed");
            dwAllocFlags &= ~NV4_TEXLOC_AGP;
        }

        /*
         * pci
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_PCI)
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            dwAddr = AllocTextureHeap(dwSize);
            if (dwAddr)
            {
                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += dwSize;
                //statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                //statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                /*
                 * done
                 */
                *pdwAddr        = dwAddr;
                *pdwResultFlags = NV4_TEXLOC_PCI;
                return TRUE;
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in PCI failed");
            dwAllocFlags &= ~NV4_TEXLOC_PCI;
        }

        /*
         * system memory
         */
        if (dwAllocFlags & dwAllocPreference & NV4_TEXLOC_SYS)
        {
            /*
             * For system meory, allocate from global heap.
             */
            dwAddr = (DWORD)GlobalAlloc(GPTR,dwSize);
            if (dwAddr)
            {
                /*
                 * done
                 */
                *pdwAddr        = dwAddr;
                *pdwResultFlags = NV4_TEXLOC_SYS;
                return TRUE;
            }

            /*
             * fail - don't try again
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface in SYSMEM failed");
            dwAllocFlags &= ~NV4_TEXLOC_SYS;
        }

        /*
         * next
         */
        dwAllocPreference = (dwAllocPreference << 1) & NV4_TEXLOC_ANYWHERE;
        dwAllocPreference = dwAllocPreference ? dwAllocPreference
                                              : NV4_TEXLOC_VID;
    }

    /*
     * not allocated
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO,"nvTextureAllocSurface: Texture Surface Not allocated");
    dbgD3DError();

    *pdwAddr        = 0;
    *pdwResultFlags = NV4_TEXLOC_NOWHERE;
    return FALSE;
}

/*
 * nvTextureFreeSurface
 *
 * frees a surface
 */
BOOL nvTextureFreeSurface
(
    LPDDRAWI_DIRECTDRAW_GBL lpDriverObject,
    DWORD dwAddr,
    DWORD dwSize,
    DWORD dwAllocFlags
)
{
    /*
     * video
     */
    if (dwAllocFlags & NV4_TEXLOC_VID)
    {
        /*
         * Call DDRAW to de-allocate memory from the video memory heap.
         */
        NVHEAP_FREE (dwAddr);

        /*
         * Decrement count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;

        /*
         * Update texture statistics.
         */
        statTextureCountVideo--;
        statTextureSizeVideo -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * agp
     */
    if (dwAllocFlags & NV4_TEXLOC_AGP)
    {
        /*
         * On AGP call DDRAW to de-allocate memory from AGP heap.
         */
        FreeAGPHeap(lpDriverObject, dwAddr);

        /*
         * Update texture statistics.
         */
        statTextureCountAgpHeap--;
        statTextureSizeAgpHeap -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * pci
     */
    if (dwAllocFlags & NV4_TEXLOC_PCI)
    {
        /*
         * On PCI, de-allocate from our internal texture heap.
         */
        FreeTextureHeap(dwAddr);

        /*
         * Update texture statistics.
         */
        statTextureCountPciHeap--;
        statTextureSizePciHeap -= dwSize;

        /*
         * done
         */
        return TRUE;
    }

    /*
     * sys
     */
    if (dwAllocFlags & NV4_TEXLOC_SYS)
    {
        /*
         * free from global heap
         */
        GlobalFree ((HGLOBAL)dwAddr);

        /*
         * done
         */
        return TRUE;
    }

    /*
     * failed
     */
    return FALSE;
}

/*****************************************************************************
 * exported code
 * -------------
 *****************************************************************************/

/*
 * nvTextureRef
 *
 * called whenever the HW is about to use the texture.
 * the swizzle surface MUST be made valid (NV4_TEXFLAG_SWIZZLE_VALID)
 * this is also where we would automipmap if we are allowed to and the proper
 * timeout elapsed
 *
 */
BOOL nvTextureRef
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwFlags;
    DWORD dwIndex;
    DWORD dwSurfaceFlags;
    BOOL  bForceHWUpdate = FALSE;

    /*
     * valid texture?
     */
    if (!pTexture) return FALSE;

    /*
     * extract texture info
     */
    dwFlags        = pTexture->dwTextureFlags;
    dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
    dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];

    /*
     * check if swizzle surface is valid
     */
    if (!(dwSurfaceFlags & NV4_TEXFLAG_VALID))
    {
        /*
         * make valid
         */
        if (!nvUpdateSwizzleSurface(pTexture)) return FALSE;
        /*
         * force hw reprogram
         */
        bForceHWUpdate = TRUE;
        /*
         * re-read texture info
         */
        dwFlags        = pTexture->dwTextureFlags;
        dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
        dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];
    }

#if 0 // obsolete
    /*
     * check if have dirty user mipmaps
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_MIPMAPS_DIRTY)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
        LPDDRAWI_DDRAWSURFACE_LCL lclMip;
        /*
         * run down the chain and make sure the swizzled versions are up to date
         */
        lpLcl = pTexture->lpLcl;
        lclMip = lpLcl->lpAttachList->lpAttached;

        while (lclMip)
        {
            PNVD3DTEXTURE   pMipMap;

            pMipMap = (PNVD3DTEXTURE)lclMip->dwReserved1;
            if (pMipMap)
            {
                if (!(pMipMap->dwTextureFlags & NV4_TEXFLAG_SWIZZLE_VALID))
                {
                    /*
                     * make valid
                     */
                    nvUpdateSwizzleSurface (pMipMap);
                }
            }

            /*
             * next
             */
            lclMip = (lclMip->lpAttachList) ? lclMip->lpAttachList->lpAttached
                                            : NULL;
        }

        /*
         * update flags
         */
        pTexture->dwTextureFlags &= ~NV4_TEXFLAG_MIPMAPS_DIRTY;

        /*
         * force hw reprogram
         */
        bForceHWUpdate = TRUE;
    }
#endif //0

    /*
     * check if we have auto mipmaps enabled for this texture
     */
    if (dwFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        /*
         * check if we still have to create the auto mipmaps this texture
         */
        if (!(dwFlags & NV4_TEXFLAG_AUTOMIPMAP_VALID))
        {
            /*
             * is it time to create them yet?
             */
            if (pTexture->dwAutoMipMapScene < pCurrentContext->dwSceneCount)
            {
                /*
                 * do we have an opportunity to still mipmap stuff in this scene?
                 */
                if (pCurrentContext->dwMipMapsInThisScene < NV3_TEXDEFAULT_MIPSPERSCENE)
                {
                    /*
                     * update flags
                     */
                    pTexture->dwTextureFlags    = dwFlags | NV4_TEXFLAG_AUTOMIPMAP_VALID;
                    pTexture->dwMipMapLevels    = pTexture->dwAutoMipMapCount;
                    pTexture->dwAutoMipMapScene = 0xffffffff; // inhibit further mipmapping (above test always fails)

                    /*
                     * perform mipmap (nv4mip.c)
                     */
                    nvTextureAutoMipMap (pTexture);

                    /*
                     * force hw reprogram
                     */
                    pCurrentContext->dwMipMapsInThisScene ++;
                    bForceHWUpdate = TRUE;

                    /*
                     * re-read texture info
                     */
                    dwFlags        = pTexture->dwTextureFlags;
                    dwIndex        = TEX_SWIZZLE_INDEX(dwFlags);
                    dwSurfaceFlags = pTexture->dwSwizzleFlags[dwIndex];
                }
            }
        }
    }
    else
    {
        /*
         * check is we have to bring user mipmaps forward
         */
        if ((dwSurfaceFlags & NV4_TEXMASK_MIPMASK) != NV4_TEXMASK_MIPMASK)
        {
            // txtodo
            // remember to store & load values
        }
    }

    /*
     * store cached values
     */
    pTexture->dwTextureFlags = dwFlags;

    /*
     * HW update
     */
    if (bForceHWUpdate)
    {
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
    }

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureTestBlock
 *
 * return TRUE if the CPU will have to block for this texture - similar
 *  logic to nvTextureBlock
 */
BOOL nvTextureTestBlock
(
    DWORD dwDate
)
{
    /*
     * aa override
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return FALSE; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * check if we know it has retired
     */
    if (global.dwHWTextureDate > dwDate) return FALSE;

    /*
     * read latest HW date
     */
#ifndef WINNT
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif

    /*
     * test again
     */
    if (global.dwHWTextureDate > dwDate) return FALSE;

    /*
     * we will have to stall
     */
    return TRUE;
}

/*
 * nvTextureBlock
 *
 * block the CPU until HW has finished with the given frame.
 */
void nvTextureBlock
(
    DWORD dwDate
)
{
    /*
     * aa override
     */
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * check if we know it has retired
     */
    if (global.dwHWTextureDate > dwDate) return;

    /*
     * read latest HW date
     */
#ifndef WINNT
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
    global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif  // WINNT

    /*
     * test again
     */
    if (global.dwHWTextureDate > dwDate) return;

    /*
     * check if we can do a partial stall
     *  this can happen when we wait for a date that is not the current SW date
     */
    if (dwDate < global.dwSWTextureDate)
    {
        for (;;)
        {
            /*
             * wait
             */
            NV_DELAY;

            /*
             * get new HW date
             */
#ifndef WINNT
            global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->BaseAddress);
#else
            global.dwHWTextureDate = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEXTURE_RETIRE + pDriverData->ppdev->pjScreen);
#endif  // WINNT

            /*
             * test again
             */
            if (global.dwHWTextureDate > dwDate) return;
        }
    }

    /*
     * date must be this frame so we sync hard. texture renaming tries to
     * avoid this case
     */
#ifdef NV_PROFILE
    NVP_START(NVP_T_TEXWAIT);
#endif
    NV_D3D_GLOBAL_SAVE();
    nvFlushDmaBuffers();
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
   nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
   NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
   nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TEXWAIT);
    nvpLogTime (NVP_T_TEXWAIT,nvpTime[NVP_T_TEXWAIT]);
#endif
}

/*
 * nvTextureSetBlockPoint
 *
 * writes the proper semaphores to block texture accesses
 *  this should be called very infrequently
 */
void nvTextureSetBlockPoint
(
    void
)
{
    if (pCurrentContext->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))
    {
        return; // capturing nature of AA implicitly provides syncronization
    }

    /*
     * update block value
     */
    global.dwSWTextureDate ++;

    /*
     * write into command stream
     */
    nvPlacePsuedoNotifier (NV_PN_TEXTURE_RETIRE,global.dwSWTextureDate);
}

/*
 * nvTextureLock
 *
 * locks a texture so the user can party on the texels
 */
DWORD nvTextureLock
(
    PNVD3DTEXTURE    pTexture,
    LPDDHAL_LOCKDATA lpLockData
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureLock: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return 0;
    }
#endif // DEBUG

    /*
     * enter
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT


    /*
     * make linear valid if we need to
     */
    nvUpdateLinearSurface (pTexture);

    /*
     * update texture flags for this lock - kill mipmaps and tag swizzled surface as invalid
     */
    TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) &= ~NV4_TEXFLAG_VALID;
    pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
    pTexture->dwMipMapLevels    = 1;
    pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

    /*
     * force hw reprogram
     */
    pCurrentContext->dwStateChange = TRUE;
    NV_FORCE_TRI_SETUP(pCurrentContext);

/* - txtodo - decide if this is really needed
    if ((++pTexture->dwUpdateCount) > NV4_TEXDEFAULT_MAXMODIFYCOUNT)
    {
        / *
         * modified too many times
         * /
        pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP;
    }
*/

    /*
     * grow dirty rectangle to lock extents if it exists (else the whole thing)
     */
    if (lpLockData->bHasRect)
    {
        nvTextureGrowDirtyRect (pTexture,
                                lpLockData->rArea.left,
                                lpLockData->rArea.top,
                                lpLockData->rArea.right,
                                lpLockData->rArea.bottom);
    }
    else
    {
        pTexture->dwDirtyX0 = pTexture->dwDirtyY0
                            = 0;
        pTexture->dwDirtyX1 = pTexture->dwWidth;
        pTexture->dwDirtyY1 = pTexture->dwHeight;
    }

    /*
     * setup DDRAW with surface information
     */
    lpLockData->lpDDSurface->lpGbl->fpVidMem = pTexture->dwLinearAddr;
    lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->dwPitch;

    /*
     * sync HW - even when READONLY is specified (due to deswizzle possibly being done by HW)
     */
    nvTextureBlock (pTexture->dwRetireDate[NV4_TEXCOUNT_SWIZZLE]);

    /*
     * leave
     */
    NV_D3D_GLOBAL_SAVE();

    /*
     * done
     *  return that we did not handle the lock although we did - really weird ms semantics...
     */
    lpLockData->ddRVal = DD_OK;
#ifndef WINNT
    return DDHAL_DRIVER_NOTHANDLED/*DDHAL_DRIVER_HANDLED*/;
#else
    return DDHAL_DRIVER_HANDLED;
#endif  // WINNT
}

/*
 * nvTextureUnlock
 *
 * unlocks a texture after the user partied on the texels
 */
DWORD nvTextureUnlock
(
    PNVD3DTEXTURE      pTexture,
    LPDDHAL_UNLOCKDATA lpUnlockData
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureUnlock: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return 0;
    }
#endif // DEBUG

    /*
     * unlock ddraw's view of this texture
     */
    // txtodo - we might want to swizzle here instead of later

    /*
     * done
     */
    lpUnlockData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * nvTextureBlt
 *
 * performs a 16 or 32 bpp blt to a texture
 */
DWORD nvTextureBlt
(
    LPDDHAL_BLTDATA lpBltData
)
{
    /*
     * source surface
     */
    DWORD dwSrcAddr  = lpBltData->lpDDSrcSurface->lpGbl->fpVidMem;
    DWORD dwSrcAlloc = 0;
    DWORD dwSrcX0    = lpBltData->rSrc.left;
    DWORD dwSrcY0    = lpBltData->rSrc.top;
    DWORD dwSrcX1    = lpBltData->rSrc.right;
    DWORD dwSrcY1    = lpBltData->rSrc.bottom;
    DWORD dwSrcPitch = lpBltData->lpDDSrcSurface->lpGbl->lPitch;
    DWORD dwSrcBPP   = ((lpBltData->lpDDSrcSurface->lpGbl->ddpfSurface.dwFlags & DDPF_RGB)
                     ? lpBltData->lpDDSrcSurface->lpGbl->ddpfSurface.dwRGBBitCount
                     : pDriverData->bi.biBitCount) / 8;
    DWORD dwSrcLogW;
    DWORD dwSrcLogH;

    // txtodo - if source is a texture then we can do a swiz to swiz blt
    //PNVD3DTEXTURE pSrcTexture = (PNVD3DTEXTURE)lpBltData->lpDDSrcSurface->dwReserved1;

    /*
     * dest texture surface
     */
    PNVD3DTEXTURE pTexture   = (PNVD3DTEXTURE)lpBltData->lpDDDestSurface->dwReserved1;
    DWORD         dwDestX0   = lpBltData->rDest.left;
    DWORD         dwDestY0   = lpBltData->rDest.top;
    DWORD         dwDestX1   = lpBltData->rDest.right;
    DWORD         dwDestY1   = lpBltData->rDest.bottom;
    DWORD         dwDestLogW;
    DWORD         dwDestLogH;
    DWORD         dwIndex;

#ifdef NV_NULL_DRIVER
    lpBltData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
#endif //NV_NULL_DRIVER

    /*
     * determine source texture allocation heap
     */
    if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
    {
        if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            if (pDriverData->GARTLinearBase)
                dwSrcAlloc = NV4_TEXLOC_AGP;
            else
                dwSrcAlloc = NV4_TEXLOC_PCI;
        }
        else if (lpBltData->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        {
            dwSrcAlloc = NV4_TEXLOC_VID;
        }
        else { // unknown location - assume system (the safe option)
            dwSrcAlloc = NV4_TEXLOC_SYS;
        }
    }
    else
    {
        dwSrcAlloc = NV4_TEXLOC_SYS;
    }

    /*
     * enter
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

    /*
     * sanity checks
     */
    if (!pTexture)
    {
        // no dest texture structure
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlt - pTexture == NULL!!");
        dbgD3DError();
        // fail
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    if (dwSrcBPP != pTexture->dwBPP)
    {
        if ((pDriverData->regPal8TextureConvert == REG_P8TC_NONE) ||
            (!(pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED))) {
            // different bit depths are not allowed
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - Source and destination have different bit depths!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (dwSrcBPP == 1)
    {
        if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)) {
            // 8 bpp non-palettized
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - 8 bpp not supported with unpalettized textures!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }
    else if ((dwSrcBPP != 2) && (dwSrcBPP != 4))
    {
        // not 16 or 32 bpp
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlt - %d bpp not supported!!",dwSrcBPP*8);
        dbgD3DError();
        // fail
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * cache some texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * get log width and height of whole surface - need this for swizzle
     */
    {
        dwSrcLogW  = lpBltData->lpDDSrcSurface->lpGbl->wWidth;
        dwSrcLogH  = lpBltData->lpDDSrcSurface->lpGbl->wHeight;
        dwDestLogW = lpBltData->lpDDDestSurface->lpGbl->wWidth;
        dwDestLogH = lpBltData->lpDDDestSurface->lpGbl->wHeight;
        __asm
        {
            mov eax,[dwSrcLogW]
            mov ebx,[dwSrcLogH]
            bsf ecx,eax
            bsf edx,ebx
            mov [dwSrcLogW],ecx
            mov [dwSrcLogH],edx

            mov eax,[dwDestLogW]
            mov ebx,[dwDestLogH]
            bsf ecx,eax
            bsf edx,ebx
            mov [dwSrcLogW],ecx
            mov [dwSrcLogH],edx
        }
    }

    /*
     * update stats
     */
    pTexture->dwBlitUpdateCount ++;

#ifdef NV_PROFILE
    nvpLogCount (NVP_C_BLTSIZE,(dwSrcX1 - dwSrcX0) * (dwSrcY1 - dwSrcY0) * dwSrcBPP);
#endif

    /*
     * do we have swizzled memory allocated yet?
     */
    if (!(TEX_SWIZZLE_FLAGS(pTexture,pTexture->dwTextureFlags) & NV4_TEXMASK_LOCATION))
    {
        /*
         * do we have enough info to do so now?
         */
        if (pTexture->dwMipMapSizeBytes)
        {
            nvAllocateInternalTexture (pTexture);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR,
                      "nvTextureBlt - internal texture cannot be allocated (createsurface was never called)!!");
            dbgD3DError();
            // fail
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DDERR_UNSUPPORTED;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * if source is in a HW reachable location, do blt directly from there
     *  implied syncronous operation and will not have to idle HW
     */
    if (dwSrcAlloc & (NV4_TEXLOC_PCI | NV4_TEXLOC_AGP | NV4_TEXLOC_VID))
    {
#ifdef NV_PROFILE
            NVP_START(NVP_T_TEXHWBLT);
#endif
        /*
         * make swizzle valid
         * - if it is not valid
         * - we already have dirty swizzled texels
         * - and we do not intend to blt the whole thing
         */
        if (dwDestX0 || dwDestY0 || (dwDestX1 != pTexture->dwWidth) || (dwDestY1 != pTexture->dwHeight))
        {
            if (!(pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
              && (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
            {
                if (!nvTextureDirtyRectEmpty(pTexture))
                {
                    nvUpdateSwizzleSurface (pTexture);
                }
            }
        }

        /*
         * perform lin -> swizzle copy
         */
        nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                           dwSrcLogW,dwSrcLogH,
                           dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                           dwSrcPitch,
                           NULL,
                      pTexture->dwSwizzleAddr[dwIndex],pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXMASK_LOCATION,
                           dwDestLogW,dwDestLogH,
                           dwDestX0,dwDestY0,
                           pTexture->dwPitch,
                           pTexture,
                      dwSrcBPP,
                      NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW);

        /*
         * update flags
         */
        pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
        pTexture->dwSwizzleFlags[dwIndex] |=  NV4_TEXFLAG_VALID;
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
        {
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
        {
            /*
             * tag mipmap as current
             */
            ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
        }

        /*
         * update dirty rect
         */
        nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_TEXHWBLT);
        nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

        /*
         * done
         */
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * if we have a linear copy of the texture try to use a HW swizzle blit
     */
    if (pTexture->dwLinearAddr)
    {
        /*
         * can HW read from linear texture?
         */
        if (pTexture->dwTextureFlags & ((NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_PCI) << NV4_TEXMASK_LINEAR_SHIFT))
        {
#ifdef NV_PROFILE
            NVP_START(NVP_T_TEXHWBLT);
#endif
            /*
             * make linear valid
             * - if it is not valid
             * - we already have dirty swizzled texels
             * - and we do not intend to blt the whole thing
             */
            if (dwDestX0 || dwDestY0 || (dwDestX1 != pTexture->dwWidth) || (dwDestY1 != pTexture->dwHeight))
            {
                if (!(pTexture->dwTextureFlags & (NV4_TEXFLAG_LINEAR_VALID)
                  && (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)))
                {
                    if (!nvTextureDirtyRectEmpty(pTexture))
                    {
                        nvUpdateLinearSurface (pTexture);
                    }
                }
            }

            /*
             * perform linear copy
             */
            nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                               dwSrcLogW,dwSrcLogH,
                               dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                               dwSrcPitch,
                               NULL,
                          pTexture->dwLinearAddr,pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                               dwDestLogW,dwDestLogH,
                               dwDestX0,dwDestY0,
                               pTexture->dwPitch,
                               pTexture,
                          dwSrcBPP,
                          NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTLINEAR | NV_SWIZFLAG_ALLOWHW);
            /*
             * update flags
             */
            pTexture->dwSwizzleFlags[dwIndex] &= ~NV4_TEXFLAG_VALID;
            pTexture->dwTextureFlags          |=  NV4_TEXFLAG_LINEAR_VALID;
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
            {
                pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
                pTexture->dwMipMapLevels    = 1;
                pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0 ) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

                /*
                 * force hw reprogram
                 */
                pCurrentContext->dwStateChange = TRUE;
                NV_FORCE_TRI_SETUP(pCurrentContext);
            }
            if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
            {
                /*
                 * tag mipmap as current
                 */
                ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
            }

            /*
             * update dirty rect
             */
            nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

#ifdef NV_PROFILE
            NVP_STOP(NVP_T_TEXHWBLT);
            nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

            /*
             * done
             */
            NV_D3D_GLOBAL_SAVE();
            lpBltData->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * see if we should do a staged HW swizzle blt
     */
    if ((!pTexture->dwLinearAddr)
     && (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXLOC_VID))
    {
        extern BOOL bTMHadToWaitForStagingSpace;

#if 0
        /*
         * prep call
         */
        bTMHadToWaitForStagingSpace = FALSE;
#endif

#ifdef NV_PROFILE
        NVP_START(NVP_T_TEXHWBLT);
#endif

        /*
         * do it
         */
        nvTMVideoTextureBlt (dwSrcAddr,dwSrcPitch,
                                dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                             0,0, /* fake these parameters - nv_tex2 does not need this */
                                dwDestX0,dwDestY0,
                             pTexture->dwSwizzleOffset[dwIndex],
                                pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                                pTexture->dwTextureColorFormat);

        /*
         * update flags
         */
        pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
        pTexture->dwSwizzleFlags[dwIndex] |= NV4_TEXFLAG_VALID;
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
        {
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
        {
            /*
             * tag mipmap as current
             */
            ((PNVD3DTEXTURE)pTexture->hMipBaseTexture)->dwSwizzleFlags[dwIndex] &= ~(4 << pTexture->dwMipMapLevels);
        }

        /*
         * update dirty rect
         */
        nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

        /*
         * block access to this texture
         */
        nvTextureSetBlockPoint ();

#ifdef NV_PROFILE
        NVP_STOP(NVP_T_TEXHWBLT);
        nvpLogTime (NVP_T_TEXHWBLT,nvpTime[NVP_T_TEXHWBLT]);
#endif

#if 0
        /*
         * check if we can balance staging space by allocating linear copies
         */
        if (bTMHadToWaitForStagingSpace
         && (pTexture->dwBlitUpdateCount >= NV4_TEXDEFAULT_MAXBLTCOUNT))
        {
            __asm int 3;
            goto forceLinearTextureCreation;
        }
#endif

        /*
         * done
         */
        NV_D3D_GLOBAL_SAVE();
        lpBltData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef NV_PROFILE
    NVP_START(NVP_T_TEXSWBLT);
#endif

    /*
     * make swizzled valid if it is not valid and we already have dirty linear texels
     *   not likely but it can happen
     */
    if ((pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID)
    && !(pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID))
    {
        if (!nvTextureDirtyRectEmpty(pTexture))
        {
            nvUpdateSwizzleSurface (pTexture);
        }
    }

#if 0 // txtodo
    /*
     * If the texture is in AGP memory we kick in a dynamic renamings scheme
     *  so the cpu will not wait for HW idle on blts
     */
    if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXLOC_AGP)
    {
        /*
         * are we going to have to wait on this texture in order to blt?
         */
        if (nvTextureTestBlock(pTexture->dwRetireDate[dwIndex]))
        {
            __asm int 3;

            /*
             * check if the blt operation will fill the whole surface
             */
            /*if*/
            {
                /*
                 * do we have a free surface or do we need to quickly allocate one
                 */
                /*if*/
                {
                    /*
                     * quickly allocate new surface
                     */
                }

                /*
                 * switch to new surface
                 */
                // date = old
            }
        }
    }
#endif

    /*
     * move & swizzle texels
     */
    nvSwizzleBlt (dwSrcAddr,dwSrcAlloc,
                       dwSrcLogW,dwSrcLogH,
                       dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                       dwSrcPitch,
                       NULL,
                  pTexture->dwSwizzleAddr[dwIndex],pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXMASK_LOCATION,
                       pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                       dwDestX0,dwDestY0,
                       pTexture->dwPitch,
                       pTexture,
                  dwSrcBPP,
                  NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW);

    /*
     * update flags
     */
    pTexture->dwTextureFlags          &= ~NV4_TEXFLAG_LINEAR_VALID;
    pTexture->dwSwizzleFlags[dwIndex] |=  NV4_TEXFLAG_VALID;

    /*
     * update auto-mipmaps
     *  if we have not rendered anything yet, do it now, else tag for
     *  later completion.
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        if (pCurrentContext->dwSceneCount)
        {
            /*
             * update flags
             */
            pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = 1;
            pTexture->dwAutoMipMapScene = (pCurrentContext ? pCurrentContext->dwSceneCount : 0) + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
        else
        {
            /*
             * update flags
             */
            pTexture->dwTextureFlags   |= NV4_TEXFLAG_AUTOMIPMAP_VALID;
            pTexture->dwMipMapLevels    = pTexture->dwAutoMipMapCount;
            pTexture->dwAutoMipMapScene = 0xffffffff; // inhibit further mipmapping

            /*
             * perform mipmap (nv4mip.c)
             */
            nvTextureAutoMipMap (pTexture);

            /*
             * force hw reprogram
             */
            pCurrentContext->dwStateChange = TRUE;
            NV_FORCE_TRI_SETUP(pCurrentContext);
        }
    }

    /*
     * update dirty rect
     */
    nvTextureGrowDirtyRect (pTexture,dwDestX0,dwDestY0,dwDestX1,dwDestY1);

//NVP_START (NVP_X_FLOAT0);

#if 0 // this does not work fast enough...
    /*
     * keep track of how many times we used the slow swizzle blit
     */
    if (pTexture->dwBlitUpdateCount >= NV4_TEXDEFAULT_MAXBLTCOUNT)
    {
#if 0
forceLinearTextureCreation:
#endif
        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }
    }
#endif //0

//NVP_STOP (NVP_X_FLOAT0);
//nvpLogTime (NVP_X_FLOAT0,nvpTime[NVP_X_FLOAT0]);

#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TEXSWBLT);
    nvpLogTime (NVP_T_TEXSWBLT,nvpTime[NVP_T_TEXSWBLT]);
#endif

    /*
     * done
     */
    NV_D3D_GLOBAL_SAVE();
    lpBltData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * nvTextureAllocSwizzleSurface
 *
 * allocate a swizzled surface
 */
BOOL nvTextureAllocSwizzleSurface
(
    PNVD3DTEXTURE pTexture,
    DWORD         dwSize,
    DWORD         dwAllocFlags,
    DWORD         dwAllocPrefs
)
{
    DWORD dwIndex;
    DWORD dwAddr;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureAllocSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    if (pTexture->dwSwizzleAddr[dwIndex])
    {
        /*
         * the texure is allocated already - assume we are relocating it (destructive)
         */
        if (!nvTextureFreeSwizzleSurface(pTexture)) return FALSE;
    }

    /*
     * allocate texture surface
     */

    pTexture->dwSwizzleAddr[dwIndex] = pTexture->dwSwizzleOffset[dwIndex]
                                     = 0;
    if (!nvTextureAllocSurface(pTexture->lpDriverObject,dwAllocFlags,dwAllocPrefs,dwSize,
                               &dwAddr,&dwAllocFlags)) return FALSE;

    /*
     * get offset
     */
    pTexture->dwSwizzleAddr[dwIndex]   = dwAddr;
    pTexture->dwSwizzleOffset[dwIndex] = GetTextureOffsetFromAddr(dwAddr,dwAllocFlags);
    pTexture->dwSwizzleFlags[dwIndex] &= ~NV4_TEXMASK_LOCATION;
    pTexture->dwSwizzleFlags[dwIndex] |= dwAllocFlags;
    pTexture->dwTextureContextDma      = (dwAllocFlags & NV4_TEXLOC_VID)
                                       ? (NV054_FORMAT_CONTEXT_DMA_B)
                                       : (NV054_FORMAT_CONTEXT_DMA_A);

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureFreeSwizzleSurface
 *
 * frees a swizzled surface
 */
BOOL nvTextureFreeSwizzleSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD i,j;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureFreeSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    j = (pTexture->dwTextureFlags & NV4_TEXFLAG_SWIZZLE_INDEX_MAX) >> 4; // # of swizzle surfaces allocated
    for (i=0; i<=j; i++)
    {
        if (pTexture->dwSwizzleAddr[i])
        {
            if (!nvTextureFreeSurface(pTexture->lpDriverObject,
                                      pTexture->dwSwizzleAddr[i],
                                      pTexture->dwMipMapSizeBytes,
                                      pTexture->dwSwizzleFlags[i] & NV4_TEXMASK_LOCATION)) return FALSE;
        }

        pTexture->dwSwizzleAddr[i]   = pTexture->dwSwizzleOffset[i]
                                     = 0;
        pTexture->dwSwizzleFlags[i] &= ~NV4_TEXMASK_LOCATION;
    }


    return FALSE;
}

/*
 * nvTextureAllocLinearSurface
 *
 * allocate a linear surface
 */
BOOL nvTextureAllocLinearSurface
(
    PNVD3DTEXTURE pTexture,
    DWORD         dwSize,
    DWORD         dwAllocFlags,
    DWORD         dwAllocPrefs
)
{
    DWORD dwAddr;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureAllocLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    if (pTexture->dwLinearAddr)
    {
        /*
         * the texure is allocated already - assume we are relocating it (destructive)
         */
        if (!nvTextureFreeLinearSurface(pTexture)) return FALSE;
    }

    /*
     * allocate texture surface
     */
    pTexture->dwLinearAddr = pTexture->dwLinearOffset
                           = 0;
    if (!nvTextureAllocSurface(pTexture->lpDriverObject,dwAllocFlags,dwAllocPrefs,dwSize,
                               &dwAddr,&dwAllocFlags)) return FALSE;

    /*
     * get offset
     */
    pTexture->dwLinearAddr    = dwAddr;
    pTexture->dwLinearOffset  = GetTextureOffsetFromAddr(dwAddr,dwAllocFlags);
    pTexture->dwTextureFlags &= ~(NV4_TEXLOC_ANYWHERE << NV4_TEXMASK_LINEAR_SHIFT);
    pTexture->dwTextureFlags |=  (dwAllocFlags        << NV4_TEXMASK_LINEAR_SHIFT);

    /*
     * done
     */
    return TRUE;
}

/*
 * nvTextureFreeLinearSurface
 *
 * frees a linear surface
 */
BOOL nvTextureFreeLinearSurface
(
    PNVD3DTEXTURE pTexture
)
{
#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvTextureFreeLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    if (pTexture->dwLinearAddr)
    {
        if (!nvTextureFreeSurface(pTexture->lpDriverObject,
                                  pTexture->dwLinearAddr,
                                  pTexture->dwMipMapSizeBytes,
                                  pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT)) return FALSE;
    }

    pTexture->dwLinearAddr = pTexture->dwLinearOffset
                           = 0;
    pTexture->dwTextureFlags &= ~(NV4_TEXLOC_ANYWHERE << NV4_TEXMASK_LINEAR_SHIFT);

    return FALSE;
}

/*
 * nvUpdateSwizzleSurface
 *
 * create and/or fill the swizzled surface from the linear surface
 * very much like the legacy nvLoadTexture
 */
BOOL nvUpdateSwizzleSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwIndex;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvUpdateSwizzleSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * get texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * does surface exist already?
     */
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
    {
        /*
         * no - create it now
         */
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
        DWORD dwAllocPrefs = NV4_TEXLOC_NOWHERE; // preference
        if (pTexture->lpLcl)
        {
            /*
             * agp / pci
             */
            if (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                if (pDriverData->GARTLinearBase)
                    dwAllocPrefs = NV4_TEXLOC_AGP;
                else
                    dwAllocPrefs = NV4_TEXLOC_PCI;
            }

            /*
             * video
             */
            if (dwAllocPrefs == NV4_TEXLOC_NOWHERE)
            {
                dwAllocPrefs = NV4_TEXLOC_VID;
            }
        }
        if (!nvTextureAllocSwizzleSurface(pTexture,pTexture->dwMipMapSizeBytes,dwAllocFlags,dwAllocPrefs))
        {
            return FALSE;
        }
    }
    else
    {
        /*
         * is surface already up to date?
         *  texels must be valid and
         */
        if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
        {
            return TRUE;
        }
    }

#ifdef DEBUG
    /*
     * is the source up to date?
     *  if not we cannot do any work. the algorithm always assume at least one
     *  surface to be valid (have up-to-date texels)
     */
    if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvUpdateSwizzleSurface: Both swizzle and linear not valid.");
    }
#endif


    /*
     * perform swizzle (nv4swiz.c)
     */
    nvSwizzleBlt (pTexture->dwLinearAddr, pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                      pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                      pTexture->dwDirtyX0,pTexture->dwDirtyY0,pTexture->dwDirtyX1,pTexture->dwDirtyY1,
                      pTexture->dwPitch,
                      pTexture,
                  TEX_SWIZZLE_ADDR(pTexture,dwIndex),TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION,
                      pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                      pTexture->dwDirtyX0,pTexture->dwDirtyY0,
                      pTexture->dwPitch,
                      pTexture,
                  pTexture->dwBPP,
                  NV_SWIZFLAG_SRCLINEAR | NV_SWIZFLAG_DESTSWIZZLED | NV_SWIZFLAG_ALLOWHW
#ifdef HW_PAL8
                      | ((pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED) ?
                      NV_SWIZFLAG_PALETTIZED : 0)
#endif
                  );

    /*
     * update flags & reset dirty rectangle. kill auto mips if they are enabled
     */
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP)
    {
        pTexture->dwTextureFlags   &= ~NV4_TEXFLAG_AUTOMIPMAP_VALID;
        pTexture->dwMipMapLevels    = 1;
        pTexture->dwAutoMipMapScene = pCurrentContext->dwSceneCount + NV4_TEXDEFAULT_AUTOMIPMAPTIME;

        /*
         * force hw reprogram
         */
        pCurrentContext->dwStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pCurrentContext);
    }
    pTexture->dwSwizzleFlags[dwIndex] |= NV4_TEXFLAG_VALID;
    pTexture->dwDirtyX0 = pTexture->dwDirtyY0
                        = pTexture->dwDirtyX1
                        = pTexture->dwDirtyY1
                        = 0;
    /*
     * done
     */
    return TRUE;
}

/*
 * nvUpdateLinearSurface
 *
 * create and/or fill the linear surface from the swizzled surface
 */
BOOL nvUpdateLinearSurface
(
    PNVD3DTEXTURE pTexture
)
{
    DWORD dwIndex;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvUpdateLinearSurface: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * cache texture info
     */
    dwIndex = TEX_SWIZZLE_INDEX(pTexture->dwTextureFlags);

    /*
     * does surface exist already?
     */
    if (!pTexture->dwLinearAddr)
    {
        /*
         * no - create it now
         */
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
        {
            return FALSE;
        }
    }
    else
    {
        /*
         * is surface already up to date?
         */
        if (pTexture->dwTextureFlags & NV4_TEXFLAG_LINEAR_VALID)
        {
            return TRUE;
        }
    }

    /*
     * Is the swizzle surface valid?
     *  if so then we deswizzle here. This is skipped usually when the app wants to
     *  lock the texture and haven't touched a pixel yet
     */
    if (pTexture->dwSwizzleFlags[dwIndex] & NV4_TEXFLAG_VALID)
    {
        /*
         * obtain access
         */
        nvTextureBlock (pTexture->dwRetireDate[dwIndex]);

        /*
         * perform deswizzle (nv4swiz.c)
         */
        nvSwizzleBlt (TEX_SWIZZLE_ADDR(pTexture,dwIndex),TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION,
                          pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                          pTexture->dwDirtyX0,pTexture->dwDirtyY0,pTexture->dwDirtyX1,pTexture->dwDirtyY1,
                          pTexture->dwPitch,
                          pTexture,
                      pTexture->dwLinearAddr, pTexture->dwTextureFlags >> NV4_TEXMASK_LINEAR_SHIFT,
                          pTexture->dwMipMapBaseU,pTexture->dwMipMapBaseV,
                          pTexture->dwDirtyX0,pTexture->dwDirtyY0,
                          pTexture->dwPitch,
                          pTexture,
                      pTexture->dwBPP,
                      NV_SWIZFLAG_SRCSWIZZLED | NV_SWIZFLAG_DESTLINEAR | NV_SWIZFLAG_ALLOWHW);
    }

    /*
     * update flags & reset dirty rectangle
     */
    pTexture->dwTextureFlags |= NV4_TEXFLAG_LINEAR_VALID;
    pTexture->dwDirtyX0       = pTexture->dwDirtyY0
                              = pTexture->dwDirtyX1
                              = pTexture->dwDirtyY1
                              = 0;

    /*
     * done
     */
    return TRUE;
}

#endif // NV_TEX2
/*****************************************************************************
 * Legacy code
 *****************************************************************************/

#ifndef NV_TEX2

BOOL nvFillTextureBuffer16Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvFillTextureBuffer32Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvHWSwizzleBlit(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL nvVideoTextureBlit(WORD,WORD,WORD,WORD,WORD,WORD,DWORD,DWORD,WORD,WORD,WORD,WORD,WORD,WORD,DWORD,DWORD,DWORD,DWORD,WORD,WORD,DWORD);

#endif //!NV_TEX2


/*
 * --------------------------------------------------------------------------
 * NV Specific Texture routines. (legacy)
 * --------------------------------------------------------------------------
 */

/*
 * nvAllocateInternalTexture
 *
 * allocates the swizzled surface for a texture.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvAllocateInternalTexture
(
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2
    DWORD dwAllocFlags;
    DWORD dwAllocPrefs;

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvAllocateInternalTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
    if (!pTexture->dwMipMapSizeBytes)
    {
        DPF ("nvAllocateInternalTexture: pTexture->dwMipMapSizeBytes == 0");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * deterine alloc flags & prefs
     */
    dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                 : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);

    dwAllocPrefs = NV4_TEXLOC_NOWHERE; // preference
    if (pTexture->lpLcl)
    {
        /*
         * agp / pci
         */
        if (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            if (pDriverData->GARTLinearBase)
                dwAllocPrefs = NV4_TEXLOC_AGP;
            else
                dwAllocPrefs = NV4_TEXLOC_PCI;
        }

        /*
         * video
         */
        if (dwAllocPrefs == NV4_TEXLOC_NOWHERE)
        {
            dwAllocPrefs = NV4_TEXLOC_VID;
        }
    }

    /*
     * allocate surface
     */
    if (!nvTextureAllocSwizzleSurface(pTexture,pTexture->dwMipMapSizeBytes,dwAllocFlags,dwAllocPrefs))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateInternalTexture: Internal Texture Allocation Failed");
        dbgD3DError();
        return (FALSE);
    }

    /*
     * Handy statistics.
     */
    statTextureCountTotal++;
    statTextureOmniCountTotal++;
    statTextureSizeTotal += pTexture->dwMipMapSizeBytes;
    statTextureOmniSizeTotal += pTexture->dwMipMapSizeBytes;

    if (pTexture->lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) {
        statTextureOmniCountPalette++;
        statTextureOmniSizePalette += pTexture->dwMipMapSizeBytes;
    }

    /*
     * done
     */
    return TRUE;

#else // !NV_TEX2

#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv = pTexture->lpDriverObject;
#endif
    /*
     * First check if Non-Local video memory explicitly specified.
     * If so, then don't try and put this texture in video memory unless there's no
     * room left in non-local memory.
     */
    if ((pTexture->lpLcl)
     && (pTexture->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM))
    {
        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP, allocate call DDRAW to allocate the AGP memory.
             */
            pTexture->dwTexturePointer = AllocAGPHeap(pTexture->lpDriverObject, pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the AGP heap base to the start of the texture data.
                 */
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer - pDriverData->GARTLinearBase;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Handy statistics.
                 */
                statTextureCountAgpHeap++;
                statTextureSizeAgpHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocation failed");

        }
        else
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            pTexture->dwTexturePointer = AllocTextureHeap(pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocation failed");
        }
    }

    /*
     * If the memory hasn't been allocated yet, try putting it in local video memory.
     */
    if ((!pTexture->dwTexturePointer)
     && (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE))
    {
        /*
         * Try putting the texture in video memory first if it meets the size requirement.
         */
        if (pTexture->dwWidth >= pDriverData->regMinVideoTextureSize)
        {
            /*
             * Call DDRAW to allocate memory from the video memory heap.
             */
#ifndef WINNT
            NVHEAP_ALLOC(pTexture->dwTexturePointer, pTexture->dwMipMapSizeBytes, TYPE_TEXTURE);
#else
            NVHEAP_ALLOC(pTexture->dwTexturePointer, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, TYPE_TEXTURE);
#endif  // !WINNT
            //pTexture->dwTexturePointer = DDHAL32_VidMemAlloc(pTexture->lpDriverObject, 0, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, 1);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the video heap base to the start of texture data.
                 */
                pTexture->dwTextureOffset      = ((pTexture->dwTexturePointer + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
                pTexture->dwTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
                pTexture->dwTextureFlags      |= NV3_TEXTURE_VIDEO_MEMORY;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                /*
                 * Increment count of video memory surfaces allocated.
                 */
                pDriverData->DDrawVideoSurfaceCount++;

                /*
                 * Handy statistics.
                 */
                statTextureCountVideo++;
                statTextureSizeVideo += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocation failed");
        }
    }

    /*
     * If the texture wasn't put into video memory, then try to put it in the system memory heap.
     */
    if (!pTexture->dwTexturePointer)
    {
        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP, allocate call DDRAW to allocate the AGP memory.
             */
            pTexture->dwTexturePointer = AllocAGPHeap(pTexture->lpDriverObject, pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                /*
                 * Calculate the offset from the AGP heap base to the start of the texture data.
                 */
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer - pDriverData->GARTLinearBase;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

                /*
                 * Handy statistics.
                 */
                statTextureCountAgpHeap++;
                statTextureSizeAgpHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinAgpHeap = min(statTextureDimensionMinAgpHeap, pTexture->dwWidth);
                statTextureDimensionMaxAgpHeap = max(statTextureDimensionMaxAgpHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: AGP Memory Allocation failed");
        }
        else
        {
            /*
             * On PCI, allocate from our internal texture heap.
             */
            pTexture->dwTexturePointer = AllocTextureHeap(pTexture->dwMipMapSizeBytes);
            if (pTexture->dwTexturePointer)
            {
                pTexture->dwTextureOffset     = pTexture->dwTexturePointer;
                pTexture->dwTextureContextDma = NV054_FORMAT_CONTEXT_DMA_A;

                /*
                 * Show where the texture was allocated.
                 */
                pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                /*
                 * Handy statistics.
                 */
                statTextureCountPciHeap++;
                statTextureSizePciHeap += pTexture->dwMipMapSizeBytes;
                statTextureDimensionMinPciHeap = min(statTextureDimensionMinPciHeap, pTexture->dwWidth);
                statTextureDimensionMaxPciHeap = max(statTextureDimensionMaxPciHeap, pTexture->dwWidth);
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocated");
            }
            else
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: PCI Memory Allocation failed");
        }
        if (pTexture->dwTexturePointer)
            pTexture->dwTextureFlags   &= ~NV3_TEXTURE_VIDEO_MEMORY;
        else
        {
            /*
             * Unable to allocate the texture.  Will need to do special
             * handling for this texture every time it is used.
             */
            if (pDriverData->regD3DEnableBits1 & REG_BIT1_VIDEO_TEXTURE_ENABLE)
            {
                /*
                 * Call DDRAW to allocate memory from the video memory heap.
                 */
#ifndef WINNT
                NVHEAP_ALLOC(pTexture->dwTexturePointer, pTexture->dwMipMapSizeBytes, TYPE_TEXTURE);
#else
                NVHEAP_ALLOC(pTexture->dwTexturePointer, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, TYPE_TEXTURE);
#endif  // !WINNT
                //pTexture->dwTexturePointer = DDHAL32_VidMemAlloc(pTexture->lpDriverObject, 0, (pTexture->dwMipMapSizeBytes + NV_TEXTURE_PAD + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad, 1);
                if (pTexture->dwTexturePointer)
                {
                    /*
                     * Calculate the offset from the video heap base to the start of texture data.
                     */
                    pTexture->dwTextureOffset      = ((pTexture->dwTexturePointer + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
                    pTexture->dwTextureContextDma  = NV054_FORMAT_CONTEXT_DMA_B;
                    pTexture->dwTextureFlags      |= NV3_TEXTURE_VIDEO_MEMORY;

                    /*
                     * Show where the texture was allocated.
                     */
                    pTexture->lpLcl->ddsCaps.dwCaps &= ~(DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
                    pTexture->lpLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;

                    /*
                     * Increment count of video memory surfaces allocated.
                     */
                    pDriverData->DDrawVideoSurfaceCount++;

                    /*
                     * Handy statistics.
                     */
                    statTextureCountVideo++;
                    statTextureSizeVideo += pTexture->dwMipMapSizeBytes;
                    statTextureDimensionMinVideo = min(statTextureDimensionMinVideo, pTexture->dwWidth);
                    statTextureDimensionMaxVideo = max(statTextureDimensionMaxVideo, pTexture->dwWidth);
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocated");
                }
                else
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateInternalTexture: Video Memory Allocation failed");
            }
        }
    }

    /*
     * If there is no valid texture pointer at this point, then there simply is no memory left
     * to allocate it.  Return the error.
     */
    if (!pTexture->dwTexturePointer)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateInternalTexture: Internal Texture Allocation Failed");
        dbgD3DError();
        return (FALSE);
    }

    /*
     * Show that the internal texture memory has been allocated.
     * Also, since the memory has just been allocted, it can't possibly have valid
     * texture data, so mark it in need of loading.
     */
    pTexture->dwTextureFlags |= NV3_TEXTURE_INTERNAL_ALLOCATED;

    /*
     * Handy statistics.
     */
    statTextureCountTotal++;
    statTextureOmniCountTotal++;
    statTextureSizeTotal += pTexture->dwMipMapSizeBytes;
    statTextureOmniSizeTotal += pTexture->dwMipMapSizeBytes;

    if (pTexture->lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) {
        statTextureOmniCountPalette++;
        statTextureOmniSizePalette += pTexture->dwMipMapSizeBytes;
    }

    /*
     * Texture has been successfully created (but NOT loaded)
     */
    return (TRUE);
#endif // !NV_TEX2
}

/*
 * nvDestroyInternalTexture
 *
 * frees the swizzled surface for a texture.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvDestroyInternalTexture
(
    PNVD3DCONTEXT   pContext,
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvDestroyInternalTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * Validate the texture.
     */
    if (!pTexture) return FALSE;

    /*
     * Check for work
     */
    if (!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags)) return TRUE;

    /*
     * Deallocate the internal texture surface.
     */
    if (!nvTextureFreeSwizzleSurface(pTexture))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDestroyInternalTexture: Internal Texture Deallocation Failed");
        dbgD3DError();
        return FALSE;
    }

    /*
     * Update texture statistics.
     */
    statTextureCountTotal--;
    statTextureSizeTotal -= pTexture->dwMipMapSizeBytes;

    /*
     * done
     */
    return TRUE;

#else !NV_TEX2

#ifndef NVHEAPMGR
    LPDDRAWI_DIRECTDRAW_GBL pdrv     = pTexture->lpDriverObject;
#endif

    /*
     * Validate the texture.
     */
    if (!pTexture)
        return (FALSE);

    /*
     * Deallocate the internal texture surface.
     */
    if (!pTexture->dwTexturePointer)
        return (TRUE);

    if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
    {
        /*
         * Call DDRAW to de-allocate memory from the video memory heap.
         */
        NVHEAP_FREE (pTexture->dwTexturePointer);
        //DDHAL32_VidMemFree(pTexture->lpDriverObject, 0, pTexture->dwTexturePointer);

        /*
         * Decrement count of video memory surfaces allocated.
         */
        pDriverData->DDrawVideoSurfaceCount--;

        /*
         * Update texture statistics.
         */
        statTextureCountVideo--;
        statTextureSizeVideo -= pTexture->dwMipMapSizeBytes;
    }
    else
    {

        if (pDriverData->GARTLinearBase > 0)
        {
            /*
             * On AGP call DDRAW to de-allocate memory from AGP heap.
             */
            FreeAGPHeap(pTexture->lpDriverObject, pTexture->dwTexturePointer);

            /*
             * Update texture statistics.
             */
            statTextureCountAgpHeap--;
            statTextureSizeAgpHeap -= pTexture->dwMipMapSizeBytes;
        }
        else
        {
            /*
             * On PCI, de-allocate from our internal texture heap.
             */
            FreeTextureHeap(pTexture->dwTexturePointer);

            /*
             * Update texture statistics.
             */
            statTextureCountPciHeap--;
            statTextureSizePciHeap -= pTexture->dwMipMapSizeBytes;
        }
    }
    pTexture->dwTexturePointer  = (DWORD)NULL;
    pTexture->dwTextureOffset   = (DWORD)NULL;
    pTexture->dwTextureFlags   &= ~NV3_TEXTURE_INTERNAL_ALLOCATED;

    /*
     * Update texture statistics.
     */
    statTextureCountTotal--;
    statTextureSizeTotal -= pTexture->dwMipMapSizeBytes;
    return (TRUE);

#endif // !NV_TEX2
}


#ifndef NV_TEX2

void nvSwizzleTexture16Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstSwizzleBase
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    unsigned short *pSrcLinear;
    unsigned short *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned short *)dwDstSwizzleBase;
    /*
     * X1 is exclusive, so if X1 is even, then the real last texel is on an odd boundry and will
     * be included in the last DWORD copied by the inner loop.
     * If X1 is odd, then the last texel is an even texel and the odd texel component will
     * need to be copied as a WORD value after the inner loop completes.
     */
    switch (((dwSrcX0 & 0x01) << 1) | (dwSrcX1 & 0x01))
    {
        /*
         * Even start, even end.
         */
        case 0:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                while (xSrcCurrent < dwSrcX1)
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Even start, odd end.
         */
        case 1:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
            }
            break;

        /*
         * Odd start, even end.
         */
        case 2:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
                xSrcCurrent++;
                u = UV_INC(u, uInc, uMask);
                while (xSrcCurrent < dwSrcX1)
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Odd start, odd end.
         */
        case 3:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
                xSrcCurrent++;
                u = UV_INC(u, uInc, uMask);
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
            }
            break;
    }
}

void nvSwizzleTexture32Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstSwizzleBase
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    unsigned long *pSrcLinear;
    unsigned long *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned long *)dwDstSwizzleBase;
    // X1, Y1 are exclusive.
    for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
    {
        pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
        xSrcCurrent = dwSrcX0;
        u = u0;
        while (xSrcCurrent < dwSrcX1)
        {
            pDstSwizzle[UV_OFFSET(u,v)]   = pSrcLinear[xSrcCurrent];
            pDstSwizzle[UV_OFFSET(u,v)+1] = pSrcLinear[xSrcCurrent+1];
            xSrcCurrent += 2;
            u = UV_INC(u, uInc2, uMask);
        }
    }
}

/*
 * General purpose texture de-swizzling.  This routine is called at most
 * once for any given texture, so there's only really a need for a single
 * general purpose routine.
 */
void nvDeSwizzleTexture
(
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwSrcSwizzleBase,
    DWORD   dwTextureFormat
)
{
    DWORD   u, v;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwAdjustedWidth;
    unsigned long *pDstLinear;
    unsigned long *pSrcSwizzle;

    switch (dwTextureFormat)
    {
        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
        case NV054_FORMAT_COLOR_LE_R5G6B5:
        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
            // for 16-bit textures, divide the width by two since
            // we move four bytes at a time
            dwAdjustedWidth = dwWidth >> 1;
            break;
        default:
            dwAdjustedWidth = dwWidth;
            break;
    }

    pSrcSwizzle = (unsigned long *)dwSrcSwizzleBase;

    // for 1xN and Mx1 textures, no deswizzling is necessary. just copy
    if ((dwAdjustedWidth <= 1) || (dwHeight == 1)) {
        pDstLinear = (unsigned long *)dwDstLinearBase;
        for (u=0; u < ((dwHeight*dwPitch)>>2); u++)
            pDstLinear[u] = pSrcSwizzle[u];
        return;
    }

    for (yDstCurrent = 0;
         yDstCurrent < dwHeight;
         yDstCurrent++)
    {
        V_INTERLEAVE(v, yDstCurrent, dwWidth, dwHeight);
        pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent * dwPitch));
        for (xDstCurrent = 0;
             xDstCurrent < dwAdjustedWidth;
             xDstCurrent++)
        {
            U_INTERLEAVE(u, xDstCurrent, dwWidth, dwHeight);
            pDstLinear[xDstCurrent] = pSrcSwizzle[UV_OFFSET(u,v)];
        }
    }
    return;
}

BOOL nvLoadTexture
(
    PNVD3DTEXTURE   pTexture
)
{
    DWORD                       texBPP;
    DWORD                       texWidth, texHeight, texPitch;
    DWORD                       logbaseu, logbasev, mipmaplevels;
    DWORD                       dwSrcLinearBase;
    DWORD                       dwDstSwizzleBase;
    DWORD                       dwTextureOffset;
    DWORD                       dwCurrentSize;
    DWORD                       dwTextureFlags;
    DWORD                       dwSrcLimit;
    DWORD                       dwImageColorFormat;
    DWORD                       dwSurfaceColorFormat;
    DWORD                       dwBytesPerPixel;
    PNVD3DTEXTURE               pTextureMipMapLevel;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS;

    /*
     * Validate the context and texture pointers.
     */
    if (!pCurrentContext || !pTexture || !pTexture->dwTexturePointer)
        return (FALSE);

    /*
     * Validate the texture surface.
     */
    if (!(lclDDS = pTexture->lpLcl))
        return (FALSE);
    if (!(gblDDS = lclDDS->lpGbl))
        return (FALSE);
    if ((!gblDDS->fpVidMem) && (!pTexture->fpUserTexture))
        return (FALSE);

    /*
     * Get information about the source texture out of the texture structure.
     */
    dwTextureFlags  = pTexture->dwTextureFlags;
    texBPP          = pTexture->dwTextureColorFormat;
    texWidth        = lclDDS->lpGbl->wWidth;
    texHeight       = lclDDS->lpGbl->wHeight;
    texPitch        = lclDDS->lpGbl->lPitch;

    logbaseu        = pTexture->dwMipMapBaseU;
    logbasev        = pTexture->dwMipMapBaseV;
    mipmaplevels    = pTexture->dwMipMapLevels;

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

    /*
     * Get pointers to the source and destination textures.
     */
    dwSrcLinearBase  = (DWORD)((gblDDS->fpVidMem) ? gblDDS->fpVidMem : pTexture->fpUserTexture);
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
        dwDstSwizzleBase = pTexture->dwTexturePointer;
    else
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
        {
            dwDstSwizzleBase = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#ifdef WINNT
            dwDstSwizzleBase += (ULONG) pDriverData->ppdev->pjScreen;
#endif
        }
        else
        {
            if (pDriverData->GARTLinearBase > 0)
                dwDstSwizzleBase = pTexture->dwTexturePointer;
            else
                dwDstSwizzleBase = GetPointerTextureHeap(pTexture->dwTextureOffset);
        }
    }
    dwTextureOffset = pTexture->dwTextureOffset;
    pTextureMipMapLevel = pTexture;
    while (mipmaplevels)
    {
        /*
         * Only need to swizzle the texture if it has been modified.
         */
        if (pTextureMipMapLevel->dwTextureFlags & NV3_TEXTURE_MODIFIED)
        {
            /*
             * Display the source texture on the screen. (DEBUG only)
             */
            dbgDisplayLinearTexture(pTextureMipMapLevel->lpLcl, pTextureMipMapLevel->lpLcl, pTextureMipMapLevel->dwTextureColorFormat);

            if (pTextureMipMapLevel->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
            {
                dwSrcLimit = (texPitch * texHeight) - 1;
                switch (texBPP)
                {
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
                        dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
                        dwBytesPerPixel      = 2;
                        break;

                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
                        dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
                        dwBytesPerPixel      = 4;
                        break;
                }
                nvTMVideoTextureBlt (0,texPitch,0,0,texWidth,texHeight,
                                     dwSrcLinearBase,texPitch,0,0,
                                     dwTextureOffset,
                                     (WORD)logbaseu, (WORD)logbasev,
                                     texBPP);
            }
            else
            {
                /*
                 * Call correct swizzle routine based on the texture format (16bpp vs 32bpp)
                 */
                switch (texBPP)
                {
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        dwBytesPerPixel = 2;
                        nvSwizzleTexture16Bpp(0, 0,
                                              texWidth, texHeight,
                                              texWidth, texHeight,
                                              texPitch,
                                              dwSrcLinearBase,
                                              0, 0,
                                              dwDstSwizzleBase);
                        break;

                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        dwBytesPerPixel = 4;
                        nvSwizzleTexture32Bpp(0, 0,
                                              texWidth, texHeight,
                                              texWidth, texHeight,
                                              texPitch,
                                              dwSrcLinearBase,
                                              0, 0,
                                              dwDstSwizzleBase);
                        break;
                }
            }
            dbgDisplayTexture((PNVD3DCONTEXT)pTextureMipMapLevel->hContext, pTextureMipMapLevel);
        }
        mipmaplevels--;

        if ((pDriverData->regD3DEnableBits1 & REG_BIT1_USER_MIPMAPS_ENABLE)
         && (lclDDS->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
        {
            if ((lclDDS->lpAttachList)
                && (lclDDS = lclDDS->lpAttachList->lpAttached))
            {
                    dwCurrentSize     = ((1 << logbaseu) * dwBytesPerPixel) * (1 << logbasev);
                    texWidth          = lclDDS->lpGbl->wWidth;
                    texHeight         = lclDDS->lpGbl->wHeight;
                    texPitch          = lclDDS->lpGbl->lPitch;
                    dwSrcLinearBase   = (DWORD)lclDDS->lpGbl->fpVidMem;
                    dwDstSwizzleBase += dwCurrentSize;
                    logbaseu--;
                    logbasev--;
                    pTextureMipMapLevel = (PNVD3DTEXTURE)lclDDS->dwReserved1;
            }
            else
                mipmaplevels = 0;
        }
        else
        {
            mipmaplevels = 0;
        }
    }

    /*
     * Auto generate mipmaps
     */
    if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
    {
        nvTextureAutoMipMap (pTexture);
    }

    /*
     * Save frequently accessed globals.
     */
    NV_D3D_GLOBAL_SAVE();

    /*
     * Set the hardware texture format for this texture.
     */
    pTexture->dwTextureFlags  &= ~NV3_TEXTURE_MODIFIED;

    /*
     * Save the pointer to the texture data that the internal texture
     * was created from. This will be used for validation. If this pointer
     * is ever different from the pointer stored in the texture surface,
     * then the texture must be reloaded.
     */
    pTexture->fpTexture = (FLATPTR)pTexture->lpLcl->lpGbl->fpVidMem;

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    return (TRUE);
}

#endif //!NV_TEX2

/*
 * nvAllocateUserTexture
 *
 * Application texture memory allocation.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvAllocateUserTexture
(
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvAllocateUserTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * allocate if it does not already exist
     *
     * note that for mipmap chains we allocate seperate linear textures (unlike the linked version for swizzle)
     */
    if (!pTexture->dwLinearAddr)
    {
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateUserTexture: User Texture Allocation Failed");
            dbgD3DError();
            return (FALSE);
        }
    }

    /*
     * tag as invalid - will be deswizzled before use
     */
    pTexture->dwTextureFlags &= ~NV4_TEXFLAG_LINEAR_VALID;

    /*
     * done
     */
    return TRUE;

#else //!NV_TEX2

    DWORD                       dwBlockSize;
    HGLOBAL                     hMem;
    PNVD3DTEXTURE               pMipMapTexture;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   lpMipMapLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   lpMipMapGbl;

    /*
     * Make sure there is a valid texture pointer.
     */
    if ((!pTexture)
     || (!pTexture->lpLcl)
     || (!pTexture->lpLcl->lpGbl))
        return (FALSE);

    lpLcl = pTexture->lpLcl;
    lpGbl = lpLcl->lpGbl;

    /*
     * Allocate application's system memory texture surface if neccessary.
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
    {
        /*
         * Reuse the system memory texture surface already allocated.
         */
        lpGbl->fpVidMem    = pTexture->fpUserTexture;
        lpGbl->dwReserved1 = (DWORD)pTexture->hUserTexture;

        if (pTexture->dwTextureFlags & NV3_TEXTURE_BLIT_UPDATE)
        {
            /*
             * The internal texture memory was modified with a blit but the user texture memory
             * was not updated.  The internal texture needs to be de-swizzled before the application
             * can be given access to it.
             */
            nvDeSwizzleTexture((DWORD)lpGbl->wWidth,
                               (DWORD)lpGbl->wHeight,
                               (DWORD)lpGbl->lPitch,
                               (DWORD)lpGbl->fpVidMem,
                               (DWORD)pTexture->dwTexturePointer,
                               (DWORD)pTexture->dwTextureColorFormat);

            /*
             * Once the texture has been de-swizzled once, it should never need to be
             * de-swizzled again.  Clear the flag, if the need for de-swizzling ever comes
             * up again, it will get re-set.
             */
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_BLIT_UPDATE;
        }
    }
    else
    {
        /*
         * If this is a mipmap chain, we want to allocate memory for all mip
         * levels all at once, so find the base, mipmap texture and run
         * through the chain allocating and de-swizzling each level.
         * If this is not a mipmap chain, only only a single iteration will
         * be neccessary.
         */
        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            if (!pTexture->hMipBaseTexture)
                pMipMapTexture = pTexture;
            else
                pMipMapTexture = (PNVD3DTEXTURE)pTexture->hMipBaseTexture;
        }
        else
        {
            /*
             * Not a user mipmap chain, 1 mipmap level (i.e. only base texture)
             */
            pMipMapTexture = pTexture;
        }

        /*
         * Traverse the mipmap chain and allocate memory for each level.
         */
        while (pMipMapTexture)
        {
            lpMipMapLcl = pMipMapTexture->lpLcl;
            lpMipMapGbl = lpMipMapLcl->lpGbl;

            /*
             * Allocate the user system memory texture surface.
             */
            dwBlockSize = (DWORD)(lpMipMapGbl->lPitch * (LONG)lpMipMapGbl->wHeight);
            hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
            if (!hMem)
            {
                /*
                 * Could not allocate the internal texture memory.  Cleanup and return the error.
                 */
                lpMipMapGbl->dwReserved1      = (DWORD)NULL;
                pMipMapTexture->hUserTexture  = (HANDLE)NULL;
                pMipMapTexture->fpUserTexture = (FLATPTR)NULL;
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateUserTexture - User texture memory allocation failed");
                return (FALSE);
            }

            /*
             * Store the handle and pointer for the system memory surface in the global surface
             * data structure.
             */
            lpMipMapGbl->fpVidMem           = (FLATPTR)GlobalLock(hMem);
            lpMipMapGbl->dwReserved1        = (DWORD)hMem;
            pMipMapTexture->hUserTexture    = hMem;
            pMipMapTexture->fpUserTexture   = lpMipMapGbl->fpVidMem;
            pMipMapTexture->dwTextureFlags |= NV3_TEXTURE_USER_ALLOCATED;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateUserTexture - User Texture = %08lx", pMipMapTexture->fpUserTexture);

            if (pMipMapTexture->dwTextureFlags & NV3_TEXTURE_BLIT_UPDATE)
            {
                /*
                 * The internal texture memory was modified with a blit but the user texture memory
                 * was not updated.  The internal texture needs to be de-swizzled before the application
                 * can be given access to it.
                 */
                nvDeSwizzleTexture((DWORD)lpMipMapGbl->wWidth,
                                   (DWORD)lpMipMapGbl->wHeight,
                                   (DWORD)lpMipMapGbl->lPitch,
                                   (DWORD)lpMipMapGbl->fpVidMem,
                                   (DWORD)pMipMapTexture->dwTexturePointer,
                                   (DWORD)pTexture->dwTextureColorFormat);

                /*
                 * Once the texture has been de-swizzled once, it should never need to be
                 * de-swizzled again.  Clear the flag, if the need for de-swizzling ever comes
                 * up again, it will get re-set.
                 */
                pMipMapTexture->dwTextureFlags &= ~NV3_TEXTURE_BLIT_UPDATE;
            }

            /*
             * Move to the next mipmap in the chain.
             */
            if ((lpMipMapLcl->lpAttachList)
             && (lpMipMapLcl->lpAttachList->lpAttached)
             && (lpMipMapLcl->lpAttachList->lpAttached->dwReserved1))
            {
                pMipMapTexture = (PNVD3DTEXTURE)lpMipMapLcl->lpAttachList->lpAttached->dwReserved1;
            }
            else
                pMipMapTexture = (PNVD3DTEXTURE)NULL;
        }
    }

    return (TRUE);

#endif //!NV_TEX2
}

/*
 * nvCreateTextureSurface
 *
 * Direct Draw Texture Surface routines.
 */
BOOL nvCreateTextureSurface
(
    LPDDHAL_CREATESURFACEDATA   lpCreateSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS,
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS
)
{
    BOOL            bCanAutoMipMap;
#ifndef NV_TEX2
    DWORD           logCurrentU, logCurrentV;
    DWORD           j;
    HGLOBAL         hMem;
#endif
    DWORD           dwTextureFlags;
    DWORD           dwTextureFormat;
    DWORD           width, height;
    DWORD           mipmaplevels;
    DWORD           texWidth, texHeight, texPitch, minPitch;
    DWORD           texSizeBytes;
    DWORD           logWidth, logHeight;
    DWORD           dwBytesPerPixel;
    DWORD           dwSrcBitCount;
    LONG            lPitch;
    HDDRVITEM       hTexture;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * It's possible that the internal texture data structure has already been allocated (in
     * the case where the texture handle was allocated first).  Try and get the pointer to
     * it.
     */
    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvCreateTextureSurface - lclDDS = %08lx, gblDDS = %08lx", lclDDS, gblDDS);
    hTexture = lclDDS->dwReserved1;
    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * Initialize the texture flags.  Use the current flags in the texture data structure
     * if there is one.  Otherwise, start from scratch.
     */
    dwTextureFlags = (pTexture) ? pTexture->dwTextureFlags : 0;

    /*
     * Only supporting RGB 16 and 32bpp formats.
     */
    if (lclDDS->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        if ((gblDDS->ddpfSurface.dwFlags & DDPF_RGB)
         || ((gblDDS->ddpfSurface.dwFlags & DDPF_FOURCC)
         &&  (gblDDS->ddpfSurface.dwFourCC == FOURCC_RGB0)))
        {
            if ((gblDDS->ddpfSurface.dwRGBBitCount != 16)
             && (gblDDS->ddpfSurface.dwRGBBitCount != 32)
             && ((gblDDS->ddpfSurface.dwRGBBitCount != 8)
              || ((gblDDS->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) != DDPF_PALETTEINDEXED8)))
            {
                /*
                 * Invalid pixel format. Return the error.
                 */
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
        }
    }

    /*
     * Determine the color format of the texture.
     */
    bCanAutoMipMap = FALSE;
    if (lclDDS->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        if (gblDDS->ddpfSurface.dwRGBBitCount == 16)
        {
            switch (gblDDS->ddpfSurface.dwRGBAlphaBitMask)
            {
                case 0x0000:
                    if (gblDDS->ddpfSurface.dwRBitMask == 0x7C00)
                    {
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X1R5G5B5;
                        bCanAutoMipMap  = TRUE;
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X1R5G5B5");
                    }
                    else
                    {
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
                        bCanAutoMipMap  = TRUE;
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
                    }
                    break;
                case 0x8000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A1R5G5B5");
                    break;
                case 0xF000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A4R4G4B4;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A4R4G4B4");
                    break;
            }
            dwBytesPerPixel = 2;
            dwSrcBitCount = 16;
        }
        else if (gblDDS->ddpfSurface.dwRGBBitCount == 32)
        {
            switch (gblDDS->ddpfSurface.dwRGBAlphaBitMask)
            {
                case 0x00000000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                    bCanAutoMipMap  = TRUE;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
                    break;
                case 0xFF000000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A8R8G8B8;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A8R8G8B8");
                    break;
            }
            dwBytesPerPixel = 4;
            dwSrcBitCount = 32;
        }
        else if (gblDDS->ddpfSurface.dwRGBBitCount == 8)
        {
            if (pDriverData->regPal8TextureConvert == REG_P8TC_NONE)
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
            if (gblDDS->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)
            {
                switch (pDriverData->regPal8TextureConvert)
                {
                    case REG_P8TC_8TOR5G6B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 565!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
                        dwBytesPerPixel = 2;
                        break;
                    case REG_P8TC_8TOX1R5G5B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a X555!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X1R5G5B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X1R5G5B5;
                        dwBytesPerPixel = 2;
                        break;
                    case REG_P8TC_8TOA1R5G5B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 1555!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A1R5G5B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;
                        dwBytesPerPixel = 2;
                        break;

                    case REG_P8TC_8TOX8R8G8B8:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a X888!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                        dwBytesPerPixel = 4;
                        break;
                    case REG_P8TC_8TOA8R8G8B8:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 8888!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A8R8G8B8");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                        dwBytesPerPixel = 4;
                        break;
                    default:
                        dbgD3DError();
                        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                        lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return (FALSE);
                }
            }
            else if (gblDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
            {
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit Luminance Texture!");
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_Y8");
                dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                dwBytesPerPixel = 1;
            }
            else
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
            dwSrcBitCount = 8;
#ifdef HW_PAL8
            dwTextureFlags |= NV4_TEXFLAG_PALETTIZED;
#endif
        }
        else
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
            lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return (FALSE);
        }
    }
    else
    {
        /*
         * If the texture doesn't specify a pixel format, that means it's the same format
         * as the device.  One application that actually does this is Indy Racing League.
         */
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - No Pixel format Given!");
        if (pDriverData->bi.biBitCount == 16)
        {
            dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
            dwBytesPerPixel = 2;
            dwSrcBitCount   = 16;
            bCanAutoMipMap  = TRUE;
        }
        else if (pDriverData->bi.biBitCount == 32)
        {
            dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
            dwBytesPerPixel = 4;
            dwSrcBitCount   = 32;
            bCanAutoMipMap  = TRUE;
        }
        else
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
            lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return (FALSE);
        }
    }

    /*
     * Make sure there's a valid color format in the texture format register.
     */
    if (!dwTextureFormat)
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Texture format not set!!");

    if (pDriverData->regD3DEnableBits1 & REG_BIT1_RESTRICT_AUTO_MIPMAPS)
    {
        if (lclDDS->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
            bCanAutoMipMap = FALSE;
    }
    else
        bCanAutoMipMap = TRUE;

    /*
     * Validate width, height and pitch. Get commonly used values local.
     */
    minPitch = (pDriverData->regPal8TextureConvert == REG_P8TC_NONE) ? 2 : 1;

    if (((texWidth  = (long)gblDDS->wWidth)  == 0)
     || ((texHeight = (long)gblDDS->wHeight) == 0)
     || ((texPitch  = (long)gblDDS->lPitch)  <  minPitch))
    {
        /*
         * Invalid texture size. Return the error.
         */
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        lpCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
        return (FALSE);
    }

    /*
     * Validate that the texture dimensions are both powers of two.
     */
    if ((texWidth & (texWidth - 1))
     || (texHeight & (texHeight - 1)))
    {
        /*
         * The texture is not a power of two. Return the error.
         */
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Texture not power of 2");
        lpCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
        return (FALSE);
    }

    /*
     * Determine which power of two by finding the bit position.
     */
    __asm
    {
        mov ecx,[texWidth]
        mov ebx,[texHeight]
        mov [width],ecx             // width = texWidth
        bsf eax,ecx                 //   486 instruction to count the bit position
        mov [height],ebx            // height = texHeight
        bsf edx,ebx                 //   486 instruction to count the bit position
        mov [logWidth],eax
        mov [logHeight],edx;
    }

    /*
     * Determine the number of MipMap levels based on the maximum image
     * size and the maximum number of MipMap levels. For auto-generated
     * MipMaps, this is based on a registry setting.  For user defined
     * MipMaps, this will be a combination of the number of levels supplied
     * by the application as well as the maximum number of levels set in
     * the registry.
     */
    if (lclDDS->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        if (pDriverData->regD3DEnableBits1 & REG_BIT1_USER_MIPMAPS_ENABLE)
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            /*
             * Rather than grab the mipmap count from the structure, I'm just
             * going to traverse the chain and manually count the levels.
             * This way I can't get it wrong.
             */
            mipmaplevels = 1;
            lclMip = lclDDS;
            while (lclMip
                && lclMip->lpAttachList)
            {
                mipmaplevels++;
                lclMip = lclMip->lpAttachList->lpAttached;
            }

            /*
             * Check if this is the base level or one of the mip levels.
             */
            if (lclDDS->lpAttachListFrom)
#ifdef NV_TEX2
                dwTextureFlags |= NV4_TEXFLAG_USER_MIP_LEVEL;
#else
                dwTextureFlags |= NV3_TEXTURE_USER_MIP_LEVEL;
#endif
        }
        else
        {
            mipmaplevels = 1;
        }
    }
    else
    {
        /*
         * Set the number of mipmap levels to auto generate.
         */
        mipmaplevels = 1L; // default
        /*
         * if we haven't drawn some frames yet and ...
         */
        if (bCanAutoMipMap
#ifndef NV_TEX2
         && (pCurrentContext && (pCurrentContext->dwSceneCount < 3))
#endif
           )
        {
            /*
             * the texture dimensions are okay
             */
            if ((logWidth + 1 == logHeight    )     // 2:1
             || (logWidth     == logHeight    )     // 1:1
             || (logWidth     == logHeight + 1))    // 1:2
            {
                if ((dwSrcBitCount != 8)
                 && (pDriverData->regMipMapLevels))
                {
                    mipmaplevels = min(logWidth,logHeight) + 1;
                    mipmaplevels = min(mipmaplevels, pDriverData->regMipMapLevels);
                }
            }
        }

        /*
         * update texture flags
         */
#ifdef NV_TEX2
        // test: disable auto mipmaps totally for now.
        //       also update mipmap disables to not redo HW if not really needed
        //dwTextureFlags |= (mipmaplevels > 1) ? NV4_TEXFLAG_AUTOMIPMAP : 0;
#else
        dwTextureFlags |= (mipmaplevels > 1) ? NV4_TEXTURE_AUTOMIPMAPPED : 0;
#endif
    }

    /*
     * Calculate the size of the NV3 format texture including mip maps.
     */
#ifdef NV_TEX2
    texSizeBytes = nvTextureCalcMipMapSize(logWidth,logHeight,mipmaplevels) * dwBytesPerPixel;
#else
    texSizeBytes    = 0;
    logCurrentU     = logWidth;
    logCurrentV     = logHeight;
    for (j = 0; j < mipmaplevels; j++)
    {
        texSizeBytes += (1 << (logCurrentU + logCurrentV)) * dwBytesPerPixel;
        logCurrentU--;
        logCurrentV--;
    }
#endif // !NV_TEX2

    /*
     * All the pertinent texture data has now been validated and calculated.
     * Time for allocating all the memory for the texture surface and texture data structures.
     *
     * Calculate the pitch for the application system memory texture.
     */
    lPitch = texWidth * dwBytesPerPixel;
    gblDDS->lPitch = lPitch;

    /*
     * Allocate an internal texture data structure if there isn't one allocated yet.
     */
    if (!pTexture)
    {
        /*
         * Internal texture data structure not allocated yet.  Allocate it now.
         */
#ifndef OLDSTUFF
        hTexture = (HDDRVITEM)HEAPALLOC((HANDLE)pDriverData->hTextures_gbl,
                                sizeof(NVD3DTEXTURE));
#else
        hTexture = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hTextures_gbl,
                                        HEAP_ZERO_MEMORY,
                                        sizeof(NVD3DTEXTURE));
#endif // #ifndef OLDSTUFF
        pTexture = (PNVD3DTEXTURE)hTexture;
        if (!pTexture)
        {
            /*
             * Could not allocate the internal data structure.  Cleanup and return the error.
             */
            gblDDS->fpVidMem        = (FLATPTR)NULL;
            gblDDS->dwReserved1     = (DWORD)NULL;
            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Could not allocate internal data structure!");
            return (FALSE);
        }
        pDriverData->dwD3DTextureCount++;

        /*
         * Store the handle for the internal texture data structure in the driver reserved field.
         */
        lclDDS->dwReserved1 = hTexture;

        /*
         * Make sure a few key fields are intialized to zero.
         */
/* allocated with HEAP_ZERO_MEMORY - not needed
        pTexture->dwTexturePointer  = 0;
        pTexture->dwTextureOffset   = 0;
        pTexture->fpTexture         = 0;
        pTexture->hUserTexture      = 0;
        pTexture->fpUserTexture     = 0;
*/
        pTexture->dwDriverData      = (DWORD)pDriverData;

        /*
         * Update the texture list.
         */
        pTexture->pTexturePrev = (PNVD3DTEXTURE)NULL;
        pTexture->pTextureNext = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture;
        pDriverData->dwTextureListHead = (DWORD)pTexture;
    }
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - pTexture = %08lx", pTexture);

    /*
     * Initialize texture information
     */
    pTexture->lpDriverObject       = lpCreateSurface->lpDD;
    pTexture->lpLcl                = lclDDS;
    pTexture->dwWidth              = texWidth;
    pTexture->dwHeight             = texHeight;
    pTexture->dwPitch              = (DWORD)lPitch;
    pTexture->dwMipMapBaseU        = logWidth;
    pTexture->dwMipMapBaseV        = logHeight;
    pTexture->dwMipMapSizeBytes    = texSizeBytes;
    pTexture->dwTextureColorFormat = dwTextureFormat;
#ifdef NV_TEX2
    pTexture->dwBPP                = dwBytesPerPixel;
    pTexture->dwMipMapLevels       = (dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP) ? 1 : mipmaplevels;
    pTexture->dwTextureFlags       = dwTextureFlags;
    pTexture->dwAutoMipMapScene    = NV4_TEXDEFAULT_AUTOMIPMAPTIME;
    if (pCurrentContext) pTexture->dwAutoMipMapScene += pCurrentContext->dwSceneCount;
    pTexture->dwAutoMipMapCount    = mipmaplevels;
    pTexture->dwDirtyX0            = pTexture->dwDirtyY0
                                   = 0;
    pTexture->dwDirtyX1            = pTexture->dwWidth;
    pTexture->dwDirtyY1            = pTexture->dwHeight;
    pTexture->dwLockUpdateCount    = 0;
    pTexture->dwBlitUpdateCount    = 0;
#else
    pTexture->dwUpdateCount        = 0;
    pTexture->dwMipMapLevels       = mipmaplevels;
    pTexture->dwTextureFlags       = dwTextureFlags | (bCanAutoMipMap ? NV4_TEXTURE_CAN_AUTO_MIPMAP : 0);
#endif

    /*
     * update user mip levels - this code assumes that the
     * base texture is already allocated
     */
#ifdef NV_TEX2
    if (dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
#else
    if (dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
#endif
    {
        DWORD                       dwMipMapLevel;
        DWORD                       dwMipMapOffset;
        PNVD3DTEXTURE               pMipBaseTexture;
        LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

        /*
         * Find the base texture handle.
         */
        dwMipMapLevel = 1;
        lclMip = lclDDS->lpAttachListFrom->lpAttached;
        while (lclMip->lpAttachListFrom)
        {
            lclMip = lclMip->lpAttachListFrom->lpAttached;
            dwMipMapLevel++;
        }
        pTexture->hMipBaseTexture = lclMip->dwReserved1;

        /*
         * Calculate the starting offset and pointer for this
         * mipmap level.
         */
        pMipBaseTexture = (PNVD3DTEXTURE)pTexture->hMipBaseTexture;
        if (pMipBaseTexture)
        {
#ifdef NV_TEX2
            DWORD dwIndex = TEX_SWIZZLE_INDEX(pMipBaseTexture->dwTextureFlags);

            dwMipMapOffset = nvTextureCalcMipMapSize(pMipBaseTexture->dwMipMapBaseU,
                                                     pMipBaseTexture->dwMipMapBaseV,
                                                     dwMipMapLevel) * dwBytesPerPixel;
#else
            logCurrentU    = pMipBaseTexture->dwMipMapBaseU;
            logCurrentV    = pMipBaseTexture->dwMipMapBaseV;
            dwMipMapOffset = 0;
            for (j = dwMipMapLevel; j > 0; j--)
            {
                dwMipMapOffset += ((1 << logCurrentU) * dwBytesPerPixel) * (1 << logCurrentV);
                logCurrentU--;
                logCurrentV--;
            }
#endif //!NV_TEX2
            pTexture->dwTextureContextDma = pMipBaseTexture->dwTextureContextDma;

#ifdef NV_TEX2

            pTexture->dwTextureFlags  &= ~(NV4_TEXMASK_LINEAR_LOCATION | NV4_TEXFLAG_SWIZZLE_INDEX);
            pTexture->dwTextureFlags  |= dwIndex | (pMipBaseTexture->dwTextureFlags & NV4_TEXMASK_LINEAR_LOCATION);
            TEX_SWIZZLE_FLAGS(pTexture,dwIndex) = (TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & ~NV4_TEXMASK_LOCATION)
                                                | (TEX_SWIZZLE_FLAGS(pMipBaseTexture,dwIndex) & NV4_TEXMASK_LOCATION);
            pTexture->dwSwizzleOffset[dwIndex]  = pMipBaseTexture->dwSwizzleOffset[dwIndex] + dwMipMapOffset;

            pTexture->dwSwizzleAddr[dwIndex]    = GetTextureAddrFromOffset(pTexture->dwSwizzleOffset[dwIndex],TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION);
#else
            pTexture->dwTextureOffset = pMipBaseTexture->dwTextureOffset + dwMipMapOffset;
            if (pMipBaseTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
            {
#ifndef WINNT
                pTexture->dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                pTexture->dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif
                pTexture->dwTextureFlags |= NV3_TEXTURE_VIDEO_MEMORY;
            }
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    pTexture->dwTexturePointer = pMipBaseTexture->dwTexturePointer + dwMipMapOffset;
                else
                    pTexture->dwTexturePointer = GetPointerTextureHeap(pMipBaseTexture->dwTextureOffset) + dwMipMapOffset;
            }
#endif // !NV_TEX2
        }
    }
    else
        pTexture->hMipBaseTexture = 0;

    /*
     * Allocate the internal texture surface if it's not already allocated.
     */
#ifdef NV_TEX2
    if ((!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
      && !(pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL))
#else
    if ((!(pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED))
     && (!(pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)))
#endif
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        /*
         * Allocate memory for NV internal texture format buffer.
         */
        if (!nvAllocateInternalTexture(pTexture))
        {
            /*
             * Could not allocate the internal texture memory.  Cleanup and return the error.
             */
            gblDDS->fpVidMem        = (FLATPTR)NULL;
            gblDDS->dwReserved1     = (DWORD)NULL;
#ifndef NV_TEX2
            pTexture->hUserTexture  = (HANDLE)NULL;
            pTexture->fpUserTexture = (FLATPTR)NULL;
#endif
            nvDestroyTextureStructure(pTexture);
            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Could not allocate internal texture memory!");
            NV_D3D_GLOBAL_SAVE();
            return (FALSE);
        }
#ifdef NV_TEX2
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - Internal Texture = %08lx", TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags));
#else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - Internal Texture = %08lx", pTexture->dwTexturePointer);
#endif

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }

#ifdef HW_PAL8
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         NV4_TEXLOC_SYS,
                                         NV4_TEXLOC_SYS);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif

#ifdef DIRECTSWIZZLE
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif //DIRECTSWIZZLE

#if 0
#ifdef NV_TEX2
    /*
     * if texture is dynamic, give it a linear copy - this way we do not have to wait for staging space
     */
    if ((lpCreateSurface->lpDDSurfaceDesc->dwSize >= sizeof(DDSURFACEDESC2))
     && (((DDSURFACEDESC2*)&lpCreateSurface->lpDDSurfaceDesc)->ddsCaps.dwCaps2 & DDSCAPS2_HINTDYNAMIC)) {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif  // NV_TEX2
#endif 0

#ifdef NV_TEX2
    /*
     * Set the fpVidMem pointer in the global surface structure to be the internal
     * texture memory pointer unless we already have a linear surface lying around
     */
#ifndef WINNT
    gblDDS->fpVidMem    = pTexture->dwLinearAddr ? pTexture->dwLinearAddr
                                                 : TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
    gblDDS->fpVidMem    = pTexture->dwLinearAddr ? pTexture->dwLinearAddr
                                                 : TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#endif
#else
    /*
     * Set the fpVidMem pointer in the global surface structure to be the internal
     * texture memory pointer.  The only time that seperate user texture memory needs
     * to be allocated is in the event that the application is directly touching the
     * texture memory.  If all accesses to the texture are done using DDRAW, then there
     * is no need for a seperate copy of the texture in system memory since the texture
     * swizzling is now done at DDRAW Blit time.  If, however, the application locks the
     * texture surface, then seperate texture memory will need to be alloacted and the
     * the fpVidMem pointer will be switched at that point.
     */
    gblDDS->fpVidMem    = pTexture->dwTexturePointer;
#endif
    gblDDS->dwReserved1 = 0;

#ifndef NV_TEX2
    /*
     * Show that the texture surface has been allocated.
     */
    pTexture->dwTextureFlags |= NV3_TEXTURE_SURFACE_ALLOCATED;
#endif

    /*
     * If this is really an 8 bit palettized texture, then an extra system memory
     * texture surface needs to be allocated and some information in the surface structure
     * needs to be modified.
     */
    if ((dwSrcBitCount == 8) && (dwBytesPerPixel != 1))
    {
#ifdef NV_TEX2
        DWORD dwAllocFlags;
#endif
        NV_D3D_GLOBAL_SETUP();
        /*
         * Allocate the user system memory texture surface.
         */
        lPitch = texWidth;
        gblDDS->lPitch = lPitch;
        texSizeBytes = (DWORD)(lPitch * (LONG)texHeight);
#ifdef NV_TEX2
        dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                   : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         texSizeBytes,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
#else  // !NV_TEX2
        hMem = GlobalAlloc(GHND | GMEM_SHARE, texSizeBytes);
        if (!hMem)
#endif // !NV_TEX2
        {
            /*
             * Could not allocate the internal texture memory.  Cleanup and return the error.
             */
#ifndef NV_TEX2
            pTexture->hUserTexture  = (HANDLE)NULL;
            pTexture->fpUserTexture = (FLATPTR)NULL;
#endif
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - User texture memory allocation failed");
        }
        else
        {
            /*
             * Store the handle and pointer for the system memory surface in the global surface
             * data structure.
             */
#ifdef NV_TEX2
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - User Texture = %08lx", pTexture->dwLinearAddr);
#else
            gblDDS->fpVidMem          = (FLATPTR)GlobalLock(hMem);
            gblDDS->dwReserved1       = (DWORD)hMem;
            pTexture->hUserTexture    = hMem;
            pTexture->fpUserTexture   = gblDDS->fpVidMem;
            pTexture->dwTextureFlags |= NV3_TEXTURE_USER_ALLOCATED;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - User Texture = %08lx", pTexture->fpUserTexture);
#endif //!NV_TEX2
        }
        NV_D3D_GLOBAL_SAVE();
    }

    /*
     * Texture surface allocated successfully.
     */
    return (TRUE);
}

BOOL nvDestroyTextureSurface
(
    LPDDHAL_DESTROYSURFACEDATA  lpDestroySurface,
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS,
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS
)
{
    HGLOBAL         hMem;
    HDDRVITEM       hTexture;
    PNVD3DCONTEXT   pContext = 0;
    PNVD3DTEXTURE   pTexture = 0;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvDestroyTextureSurface - lclDDS = %08lx, gblDDS = %08lx", lclDDS, gblDDS);

    /*
     * Get the handle of the system memory texture surface.
     */
    hMem = (HGLOBAL)gblDDS->dwReserved1;

    /*
     * Get pointer to the texture being destroyed.
     */
    hTexture = lclDDS->dwReserved1;
    pTexture = (PNVD3DTEXTURE)hTexture;
    if (pTexture)
    {
        /*
         * Get pointer to the context.
         */
        pContext = (PNVD3DCONTEXT)pTexture->hContext;
        if (pContext)
        {
            /*
             * Make sure the context does not refer to the texture being destroyed.
             */
            if (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == hTexture)
                pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

#ifndef NV_TEX2
        /*
         * Mark the texture surface as de-allocated.
         */
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_SURFACE_ALLOCATED;
#endif

        /*
         * Free any memory that is currently allocated.
         */
#ifdef NV_TEX2
        if (pTexture->dwLinearAddr)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->dwLinearAddr);
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
            nvTextureFreeLinearSurface (pTexture);
            NV_D3D_GLOBAL_SAVE();
        }
        if (TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Internal Texture = %08lx", TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags));
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
            nvTextureFreeSwizzleSurface (pTexture);
            NV_D3D_GLOBAL_SAVE();
        }
#else // !NV_TEX2
        /* Under WINNT, defer destruction of user allocated texture surface
         * until the texture handle is destroyed. We can't free the user
         * address here since we may not be running in the context of the
         * process which created the texture.
         */
#ifndef WINNT
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->fpUserTexture);
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
            GlobalUnlock(hMem);
            GlobalFree(hMem);
        }
#endif // #ifndef WINNT
        if (pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Internal Texture = %08lx", pTexture->dwTexturePointer);
            NV_D3D_GLOBAL_SETUP();
            nvDestroyInternalTexture(pContext, pTexture);
            NV_D3D_GLOBAL_SAVE();
       }
#endif // !NV_TEX2

        /*
         * Do a little cleanup.
         */
        gblDDS->fpVidMem           = 0;
        gblDDS->dwReserved1        = 0;
#ifndef NV_TEX2
        pTexture->hUserTexture     = 0;
        pTexture->fpUserTexture    = 0;
        pTexture->dwTexturePointer = 0;
        pTexture->dwTextureOffset  = 0;
#endif
        pTexture->lpLcl            = 0;

        /*
         * Only destroy the internal texture data structure if the texture handle has already
         * been de-allocated.
         */
#ifdef NV_TEX2
        if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_HANDLE_ALLOCATED))
#else
        if (!(pTexture->dwTextureFlags & NV3_TEXTURE_HANDLE_ALLOCATED))
#endif
        {
            /*
             * Setup frequently accessed globals.
             */
            NV_D3D_GLOBAL_SETUP();

            /*
             * Free the memory allocated for the internal texture data structure.
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Texture Structure = %08lx", pTexture);
            nvDestroyTextureStructure(pTexture);
            lclDDS->dwReserved1 = (DWORD)NULL;
            NV_D3D_GLOBAL_SAVE();
        }
    }
    else
    {
        /*
         * Free the system memory texture surface.
         */
        if (hMem)
        {
            GlobalUnlock(hMem);
            GlobalFree(hMem);
        }
        gblDDS->fpVidMem    = 0;
        gblDDS->dwReserved1 = 0;
    }

    /*
     * Return successful return codes.
     */
    lpDestroySurface->ddRVal = DD_OK;
    return (TRUE);
}

#ifndef NV_TEX2

void nvSwizzleBlit16Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwDstSwizzleBase,
    DWORD   dwTextureFormat
)
{
    WORD    wSrcTexel;
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwSrcTexel;
    unsigned short *pSrcLinear;
    unsigned short *pDstLinear;
    unsigned short *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned short *)dwDstSwizzleBase;
    // X1 is exclusive, so if X1 is even, then the real last texel is on an odd boundry.
    switch (((dwSrcX0 & 0x01) << 1) | (dwSrcX1 & 0x01))
    {
        /*
         * Even start, even end.
         */
        case 0:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                while (xSrcCurrent < dwSrcX1)
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Even start, odd end.
         */
        case 1:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
            }
            break;

        /*
         * Odd start, even end.
         */
        case 2:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
                xSrcCurrent++;
                xDstCurrent++;
                u = UV_INC(u, uInc, uMask);
                while (xSrcCurrent < dwSrcX1)
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Odd start, odd end.
         */
        case 3:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
                xSrcCurrent++;
                xDstCurrent++;
                u = UV_INC(u, uInc, uMask);
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
            }
            break;
    }
}

void nvSwizzleBlit32Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwDstSwizzleBase,
    DWORD   dwTextureFormat
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwSrcTexel;
    unsigned long *pSrcLinear;
    unsigned long *pDstLinear;
    unsigned long *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned long *)dwDstSwizzleBase;
    for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
         ySrcCurrent < dwSrcY1;
         ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
    {
        pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
        pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
        xSrcCurrent = dwSrcX0;
        xDstCurrent = dwDstX0;
        u = u0;
        while (xSrcCurrent < dwSrcX1)
        {
            dwSrcTexel = pSrcLinear[xSrcCurrent];
            pDstSwizzle[UV_OFFSET(u,v)]   = dwSrcTexel;
            pDstLinear[xDstCurrent]       = dwSrcTexel;
            dwSrcTexel = pSrcLinear[xSrcCurrent+1];
            pDstSwizzle[UV_OFFSET(u,v)+1] = dwSrcTexel;
            pDstLinear[xDstCurrent+1]     = dwSrcTexel;
            xSrcCurrent += 2;
            xDstCurrent += 2;
            u = UV_INC(u, uInc2, uMask);
        }
    }
}

void nvTextureBlit8Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned char              *pSrcLinear;
    unsigned char              *pDstLinear;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    BOOL                        bLuminanceTexture = FALSE;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat  = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    DWORD                       xSrc, ySrc, xDst, yDst;
    DWORD                       dwColor;
    DWORD                       u, v;
    LPPALETTEENTRY              pPalette;
    BYTE                        bIndex;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
    {
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwLuminanceBitCount;
        bLuminanceTexture = TRUE;
    }
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else if (gblDstDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
    {
        dwSrcBitCount = gblDstDDS->ddpfSurface.dwLuminanceBitCount;
        bLuminanceTexture = TRUE;
    }
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if ((dwSrcBitCount != dwDstBitCount)
     || (dwSrcBitCount != 8))
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit8Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    if (bLuminanceTexture)
    {
        pPalette = 0;
    }
    else
    {
#ifndef WINNT // BUGBUG - Under WINNT, where's the palette?
        if ((!lclDstDDS->lpDDPalette)
         || (!lclDstDDS->lpDDPalette->lpLcl)
         || (!lclDstDDS->lpDDPalette->lpLcl->lpGbl)
         || (!lclDstDDS->lpDDPalette->lpLcl->lpGbl->lpColorTable))
        {
            if (pTexture)
                pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
            pPalette = 0;
        }
        else
            pPalette = lclDstDDS->lpDDPalette->lpLcl->lpGbl->lpColorTable;
#endif // #ifndef WINNT
    }

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    if (bLuminanceTexture)
    {
        unsigned char   *pDstSwizzle;
        unsigned char   bColor;

        /*
         * Straight 8bit swizzle.
         */
        pDstSwizzle = (unsigned char *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bColor = pSrcLinear[xSrc];
                U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                pDstSwizzle[UV_OFFSET(u,v)] = bColor;
            }
        }
    }
    else if (pDriverData->regPal8TextureConvert == REG_P8TC_8TOR5G6B5)
    {
        unsigned short             *pDstSwizzle;
        WORD                        wColor;
        pDstSwizzle = (unsigned short *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 8)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xFC) << 3)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3);
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = wColor;
                }
            }
        }
    }
    else if ((pDriverData->regPal8TextureConvert == REG_P8TC_8TOX1R5G5B5)
          || (pDriverData->regPal8TextureConvert == REG_P8TC_8TOA1R5G5B5))
    {
        unsigned short             *pDstSwizzle;
        WORD                        wColor;
        pDstSwizzle = (unsigned short *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 7)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xF8) << 2)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3)
                           | 0x8000;
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = wColor;
                }
            }
        }
    }
    else if ((pDriverData->regPal8TextureConvert == REG_P8TC_8TOX8R8G8B8)
          || (pDriverData->regPal8TextureConvert == REG_P8TC_8TOX8R8G8B8))
    {
        unsigned long              *pDstSwizzle;
        pDstSwizzle = (unsigned long *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    dwColor = ((DWORD)(pPalette[bIndex].peRed) << 16)
                            | ((DWORD)(pPalette[bIndex].peGreen) << 8)
                            | (DWORD)(pPalette[bIndex].peBlue)
                            | 0xFF000000;
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = dwColor;
                }
            }
        }
    }
    dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
}

void nvTextureBlit16Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned short             *pSrcLinear;
    unsigned short             *pDstLinear;
    long                        xCount, yCount;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    DWORD                       ySrcCurrent;
    DWORD                       yDstCurrent;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat  = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if (dwSrcBitCount != dwSrcBitCount)
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit16Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }
    else if (dwSrcBitCount == 32)
    {
        nvTextureBlit32Bpp(pbd);
        return;
    }
    else if (dwSrcBitCount == 8)
    {
        nvTextureBlit8Bpp(pbd);
        return;
    }

    /*
     * Check for a non-square texture.
     */
    if (gblDstDDS->wWidth != gblDstDDS->wHeight)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureBlit16bpp - Non-Square Texture!!");

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT

            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    /*
     * If there's a valid pointer to an internal texture surface, then a dual
     * internal/user texture blit can be performed.
     */
    if (dwTexturePointer)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

        dwTextureFormat = pTexture->dwTextureColorFormat;

        /*
         * Decide what kind of texture blit to do.
         */
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            /*
             * The application has locked the surface so there are two
             * copies of the texture to update.
             * If the swizzled texture is in video memory:
             * First do a fast linear copy from the source surface to the
             * linear user surface, then use the hardware to swizzle the
             * texture.
             * If the swizzled texture is in non-local video memory:
             * Do the swizzle and the linear blit at the same time.
             *
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                /*
                 * Now use hardware to do the swizzle from user texture memory.
                 */
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     dwDstLinearBase,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                nvSwizzleBlit16Bpp((DWORD)dwSrcX0,
                                   (DWORD)dwSrcY0,
                                   (DWORD)dwSrcX1,
                                   (DWORD)dwSrcY1,
                                   (DWORD)gblDstDDS->wWidth,
                                   (DWORD)gblDstDDS->wHeight,
                                   (DWORD)dwSrcPitch,
                                   (DWORD)dwSrcLinearBase,
                                   (DWORD)dwDstX0,
                                   (DWORD)dwDstY0,
                                   (DWORD)dwDstPitch,
                                   (DWORD)dwDstLinearBase,
                                   (DWORD)dwTexturePointer,
                                   (DWORD)dwTextureFormat);
            }
        }
        else
        {
            /*
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     0,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                /*
                 * This is a good application.  It's not locking and touching the texture directly
                 * so there is only one copy of the texture to deal with.  Only need to swizzle the
                 * texture to the internal texture memory.
                 */
                nvSwizzleTexture16Bpp((DWORD)dwSrcX0,
                                      (DWORD)dwSrcY0,
                                      (DWORD)dwSrcX1,
                                      (DWORD)dwSrcY1,
                                      (DWORD)gblDstDDS->wWidth,
                                      (DWORD)gblDstDDS->wHeight,
                                      (DWORD)dwSrcPitch,
                                      (DWORD)dwSrcLinearBase,
                                      (DWORD)dwDstX0,
                                      (DWORD)dwDstY0,
                                      (DWORD)dwTexturePointer);
            }

            /*
             * Only the internal texture surface has been modified.  If a lock on this texture
             * comes through then it will be neccessary to de-swizzle the internal texture
             * to the user texture memory, so set the flag that shows this has happened.
             */
            pTexture->dwTextureFlags  |= NV3_TEXTURE_BLIT_UPDATE;
        }
        pTexture->fpTexture        = (FLATPTR)dwDstLinearBase;
        pTexture->dwTextureFlags  &= ~(NV3_TEXTURE_MODIFIED | NV3_TEXTURE_MUST_RELOAD);

        /*
         * Auto generate mipmaps
         */
        if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
        {
            nvTextureAutoMipMap (pTexture);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

        /*
         * Display the texture surface to the current display buffer (debug only).
         */
        dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
    }
    else
    {
        /*
         * Set up the starting postion of the blit.
         */
        yDstCurrent = dwDstY0;
        ySrcCurrent = dwSrcY0;

        /*
         * Don't have an internal texture suface, so just do the blit to
         * the user texture surface.
         */
        for (yCount = 0; yCount < yHeight; yCount++)
        {
            pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent++ * dwSrcPitch));
            pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent++ * dwDstPitch));
            for (xCount = 0; xCount < xWidth; xCount++)
                pDstLinear[dwDstX0 + xCount] = pSrcLinear[dwSrcX0 + xCount];
        }
    }

    return;
}
void nvTextureBlit32Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned long              *pSrcLinear;
    unsigned long              *pDstLinear;
    long                        xCount, yCount;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    DWORD                       ySrcCurrent;
    DWORD                       yDstCurrent;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if (dwSrcBitCount != dwSrcBitCount)
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit32Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }
    else if (dwSrcBitCount == 16)
    {
        nvTextureBlit16Bpp(pbd);
        return;
    }
    else if (dwSrcBitCount == 8)
    {
        nvTextureBlit8Bpp(pbd);
        return;
    }

    /*
     * Check for a non-square texture.
     */
    if (gblDstDDS->wWidth != gblDstDDS->wHeight)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureBlit32bpp - Non-Square Texture!!");

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     * NOTE: X1 and Y1 are exclusive!!
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    /*
     * If there's a valid pointer to an internal texture surface, then a dual
     * internal/user texture blit can be performed.
     */
    if (dwTexturePointer)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

        dwTextureFormat = pTexture->dwTextureColorFormat;

        /*
         * Decide what kind of texture blit to do.
         */
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            /*
             * The application has locked the surface so there are two
             * copies of the texture to update.
             * If the swizzled texture is in video memory:
             * First do a fast linear copy from the source surface to the
             * linear user surface, then use the hardware to swizzle the
             * texture.
             * If the swizzled texture is in non-local video memory:
             * Do the swizzle and the linear blit at the same time.
             *
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                /*
                 * Now use hardware to do the swizzle from user texture memory.
                 */
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     dwDstLinearBase,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                nvSwizzleBlit32Bpp((DWORD)dwSrcX0,
                                   (DWORD)dwSrcY0,
                                   (DWORD)dwSrcX1,
                                   (DWORD)dwSrcY1,
                                   (DWORD)gblDstDDS->wWidth,
                                   (DWORD)gblDstDDS->wHeight,
                                   (DWORD)dwSrcPitch,
                                   (DWORD)dwSrcLinearBase,
                                   (DWORD)dwDstX0,
                                   (DWORD)dwDstY0,
                                   (DWORD)dwDstPitch,
                                   (DWORD)dwDstLinearBase,
                                   (DWORD)dwTexturePointer,
                                   (DWORD)dwTextureFormat);
            }
        }
        else
        {
            /*
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     0,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                /*
                 * This is a good application.  It's not locking and touching the texture directly
                 * so there is only one copy of the texture to deal with.  Only need to swizzle the
                 * texture to the internal texture memory.
                 */
                nvSwizzleTexture32Bpp((DWORD)dwSrcX0,
                                      (DWORD)dwSrcY0,
                                      (DWORD)dwSrcX1,
                                      (DWORD)dwSrcY1,
                                      (DWORD)gblDstDDS->wWidth,
                                      (DWORD)gblDstDDS->wHeight,
                                      (DWORD)dwSrcPitch,
                                      (DWORD)dwSrcLinearBase,
                                      (DWORD)dwDstX0,
                                      (DWORD)dwDstY0,
                                      (DWORD)dwTexturePointer);
            }

            /*
             * Only the internal texture surface has been modified.  If a lock on this texture
             * comes through then it will be neccessary to de-swizzle the internal texture
             * to the user texture memory, so set the flag that shows this has happened.
             */
            pTexture->dwTextureFlags  |= NV3_TEXTURE_BLIT_UPDATE;
        }
        pTexture->fpTexture        = (FLATPTR)dwDstLinearBase;
        pTexture->dwTextureFlags  &= ~(NV3_TEXTURE_MODIFIED | NV3_TEXTURE_MUST_RELOAD);

        /*
         * Auto generate mipmaps
         */
        if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
        {
            nvTextureAutoMipMap (pTexture);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

        /*
         * Display the texture surface to the current display buffer (debug only).
         */
        dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
    }
    else
    {

        /*
         * Set up the starting postion of the blit.
         */
        yDstCurrent = dwDstY0;
        ySrcCurrent = dwSrcY0;

        /*
         * Don't have an internal texture suface, so just do the blit to
         * the user texture surface.
         */
        for (yCount = 0; yCount < yHeight; yCount++)
        {
            pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent++ * dwSrcPitch));
            pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent++ * dwDstPitch));
            for (xCount = 0; xCount < xWidth; xCount++)
                pDstLinear[dwDstX0 + xCount] = pSrcLinear[dwSrcX0 + xCount];
        }
    }

    return;
}
#endif // !NV_TEX2

/*
 *
 */
DWORD UnplugSystemMemoryTextureContext
(
    void
)
{
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

    /*
     * Unplug from DX6 triangle
     */
#ifndef CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetStartMethod + sizeSetData));
#endif  // !CACHE_FREECOUNT
    while (nvFreeCount < (sizeSetObject + sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_A, 1);
    nvglSetData(nvFifo, nvFreeCount, NV01_NULL_OBJECT);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < ((sizeSetStartMethod + sizeSetData) * 3))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         ((sizeSetStartMethod + sizeSetData) * 3));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NOTIFY, 1);
    nvglSetData(nvFifo, nvFreeCount, NV055_NOTIFY_WRITE_ONLY);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Unplug from DX5 triangle
     */
    while (nvFreeCount < (sizeSetObject + sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetStartMethod + sizeSetData));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_A, 1);
    nvglSetData(nvFifo, nvFreeCount, NV01_NULL_OBJECT);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglDx5TriangleNotify(nvFifo, nvFreeCount, NV_DD_SPARE);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (0);
}

/*
 * Some commonly used code for setting up the system memory/agp memory texture contexts and
 * DMA pusher contexts.
 */
DWORD AdjustTextureLimit
(
    DWORD   dwContext,
    DWORD   dwHeapBase,
    DWORD   dwNewLimit,
    DWORD   dwOldLimit
)
{
#ifdef  MULTI_MON
    DWORD   dwStatus;

    if (pDriverData->dwTextureContextValid)
    {
        /*
         * Should probably unplug the object before destroying.
         */
        while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                             (sizeSetObject + sizeSetDx6TriangleContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, NV01_NULL_OBJECT, NV01_NULL_OBJECT);

        while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                             (sizeSetObject + sizeSetDx5TriangleContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, NV01_NULL_OBJECT, NV01_NULL_OBJECT);
        nvStartDmaBuffer (FALSE);

        /*
         * First destroy the current context.
         */
        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(TRUE);
        pDriverData->dwTextureContextValid = FALSE;
    }

    dwStatus = 7; // NVOS03_STATUS_
    if (dwHeapBase && dwNewLimit)
    {
        dwStatus = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                       D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                       NV01_CONTEXT_DMA,
                                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                        ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                       (PVOID)dwHeapBase,
                                       dwNewLimit);
    }

    if (dwStatus != 0) // NVOS03_STATUS_SUCCESS
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AdjustTextureLimit: Could not resize system memory texture context");
        dbgD3DError();
        if (dwHeapBase && dwOldLimit)
        {
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                (PVOID)dwHeapBase,
                                dwOldLimit) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
        }
        else
        {
#ifndef WINNT
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                (PVOID)pDriverData->BaseAddress,
                                0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#else
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                (PVOID)pDriverData->ppdev->pjScreen,
                                0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#endif // #ifdef WINNT
        }
    }
    pDriverData->dwTextureContextValid = TRUE;

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (dwStatus);
#else   // !MULTI_MON
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;

    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, dwContext);
    nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                               dwHeapBase, pDriverData->flatSelector, dwNewLimit, 0);
    nvStartDmaBuffer (FALSE);
    pDriverData->dDrawSpareSubchannelObject = dwContext;
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    if (npDmaPusherSyncNotifier->status)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AdjustTextureLimit - Could not adjust the texture limit!!");
        dbgD3DError();
        npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
        if (dwOldLimit)
        {
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       dwHeapBase, pDriverData->flatSelector, dwOldLimit, 0);
        }
        else
        {
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       0, 0, 0, 0);
        }
        nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
        while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
        /*
         * non-0 = bad.  error locking memory.
         */
        return (1);
    }

    /*
     * 0 = good, no error.
     */
    return (0);
#endif  // !MULTI_MON
}
DWORD UpdateTriangleContexts
(
    void
)
{
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

    /*
     * Plug into DX6 triangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
    nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < ((sizeSetStartMethod + sizeSetData) * 3))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         ((sizeSetStartMethod + sizeSetData) * 3));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NOTIFY, 1);
    nvglSetData(nvFifo, nvFreeCount, NV055_NOTIFY_WRITE_ONLY);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Plug into DX5 triangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx5TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglDx5TriangleNotify(nvFifo, nvFreeCount, NV_DD_SPARE);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (0);
}

#ifdef  MULTI_MON
/*
 * Destroy all texture DMA contexts and free all allocated system memory for shutdown.
 */
void D3DDestroyTextureContexts
(
    void
)
{
    /*
     * Free the texture heap DMA context.
     */
    if (pDriverData->dwTextureContextValid)
    {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
        pDriverData->dwTextureContextValid = FALSE;
    }

    /*
     * Free the system memory texture heap.
     */
    if (pDriverData->hTextureHeap)
    {
        if (pDriverData->GARTLinearBase == 0)
        {
            /*
             * Only need to free the heap if it was allocated.  (it won't be
             * allocated on an AGP system)
             */
#ifndef OLDSTUFF
            HEAPFREE((HANDLE)pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif // #ifdef OLDSTUFF

        }
        else
            DestroyAGPListArray();
    }

    /*
     * Clean up a little bit.
     */
    pDriverData->hTextureHeap                           = (DWORD)NULL;
    (PTEXHEAPHEADER)pDriverData->pRealHeapBase         = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapBase      = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead  = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail  = (PTEXHEAPHEADER)NULL;
    pDriverData->dwTextureHeapSize                     = 0;
    pDriverData->dwTextureHeapSizeMax                  = 0;
    pDriverData->dwTextureHeapLimit                    = 0;
    pDriverData->dwTextureHeapLimitMax                 = 0;
    pDriverData->dwAllocSize                           = 0;
    pDriverData->dwFreeSize                            = 0;

    /*
     * Next free the texture manager heap context DMA.
     */
    if (pDriverData->dwTMStageHandle)
    {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);

        /*
         * And free the texture manager memory.
         */
        nvTMDestroy();
    }
}
#endif  // MULTI_MON

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tman.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TMAN.C                                                         *
*   Texture Blit Manager routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 06/03/98 - created.                     *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  // MULTI_MON

/*
 * externals
 */
void nvReset2DSurfaceFormat (void);

/*
 * Local Switches
 */
#define TM_OFFSETALIGN          32
#define TM_PITCHALIGN           4

/*
 * Locals
 */
BOOL bTMHadToWaitForStagingSpace;

/*
 * Local Routines
 */
DWORD __inline nvTMGetFreeSpace
(
    void
)
{
    long size;

    if (pDriverData->dwTMHead >= pDriverData->dwTMTail)
        size = (long)(pDriverData->dwTMStageMax - pDriverData->dwTMHead);
    else
        size = (long)(pDriverData->dwTMTail - pDriverData->dwTMHead - 1);

    return (size < 0) ? 0 : size;
}

/*
 * Public Routines
 */
DWORD nvPlacePsuedoNotifier
(
    DWORD offset,
    DWORD value
)
{
    DWORD topLft = 0x00000000 + (offset / 4);

    /*
     * Set proper surface info
     */
    while (nvFreeCount < (sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch));
    nvglSet2DSurfacesDestination (nvFifo,nvFreeCount,NV_DD_SURFACES, pDriverData->dwTMPseudoNotifierOffset);
    nvglSet2DSurfacesColorFormat (nvFifo,nvFreeCount,NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y32);
    nvglSet2DSurfacesPitch       (nvFifo,nvFreeCount,NV_DD_SURFACES, 0x20,0x20);

    /*
     * Do solid rect fill (with argument as color)
     */
    while (nvFreeCount < (sizeSetObject + 2 * sizeSetStartMethod + 3 * sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + 2 * sizeSetStartMethod + 3 * sizeSetData));
    nvglSetObject      (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_COLOR,1);
    nvglSetData        (nvFifo,nvFreeCount,             value);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_RECTANGLE(0),2);
    nvglSetData        (nvFifo,nvFreeCount,             topLft);
    nvglSetData        (nvFifo,nvFreeCount,             0x00010001);

    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE_2;

    /*
     * reset when we are done
     */
    nvReset2DSurfaceFormat();
    return 0;
}

/*
 * Create TexMan Heap
 */
DWORD nvTMCreate
(
    void
)
{
#ifdef TM_STAGER_IN_AGP
    DWORD dwAddr = 0;

    __asm int 3;

    if (pDriverData->GARTLinearBase)
    {
        /*
         * allocate agp memory
         */
        dwAddr = (DWORD)AllocAGPHeap(lpDriverObject, TM_STAGESPACE+0x2000);
        if (dwAddr)
        {
            /*
             * Setup variables
             */
            pDriverData->dwTMStageHandle = dwAddr; // keep addr here too
            pDriverData->dwTMStageMem    = dwAddr;
            pDriverData->dwTMStageAddr   = (pDriverData->dwTMStageMem + 0xfff) & 0xfffff000;
            pDriverData->dwTMStageMax    = pDriverData->dwTMStageAddr + TM_STAGESPACE;
            pDriverData->dwTMHead        = pDriverData->dwTMStageAddr;
            pDriverData->dwTMTail        = pDriverData->dwTMStageAddr;

            /*
             * Debug
             */
#ifdef DEBUG
            memset ((void*)pDriverData->dwTMStageAddr,0x55,TM_STAGESPACE);
#endif

            /*
             * Success
             */
            return 0;
        }
    }

    if (!dwAddr)
    {
        __asm int 3;
        // ***************************** fall back to PCI then - todo
        pDriverData->dwTMStageHandle = 0;
    }
#else
    /*
     * init
     */
    pDriverData->dwTMStageHandle = 0;

    /*
     * Allocate staging space
     */
#ifndef OLDSTUFF
    if (pDriverData->dwTMStageHandle = (DWORD)HEAPCREATE(TM_STAGESPACE+0x3000))
#else
    if (pDriverData->dwTMStageHandle = (DWORD)HeapCreate(HEAP_SHARED, TM_STAGESPACE+0x3000, 0))
#endif
    {
        /*
         * Allocate TexMan stage
         */
#ifndef OLDSTUFF
        if (pDriverData->dwTMStageMem = (DWORD)HEAPALLOC(pDriverData->dwTMStageHandle, TM_STAGESPACE+0x2000))
#else
        if (pDriverData->dwTMStageMem = (DWORD)HeapAlloc((HANDLE)pDriverData->dwTMStageHandle, HEAP_ZERO_MEMORY, TM_STAGESPACE+0x2000))
#endif
        {
            /*
             * Setup vairables
             */
            pDriverData->dwTMStageAddr = (pDriverData->dwTMStageMem + 0xfff) & 0xfffff000;
            pDriverData->dwTMStageMax  = pDriverData->dwTMStageAddr + TM_STAGESPACE;
            pDriverData->dwTMHead      = pDriverData->dwTMStageAddr;
            pDriverData->dwTMTail      = pDriverData->dwTMStageAddr;

            /*
             * Lock down the heap
             */
#ifdef  MULTI_MON
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                (PVOID)pDriverData->dwTMStageAddr,
                                TM_STAGESPACE + 0xfff) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#else   // !MULTI_MON
            while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
            nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       pDriverData->dwTMStageAddr, pDriverData->flatSelector, TM_STAGESPACE + 0xfff, 0);
            pDriverData->dDrawSpareSubchannelObject = D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY;
#endif  // !MULTI_MON

            /*
             * Debug
             */
#ifdef DEBUG
            memset ((void*)pDriverData->dwTMStageAddr,0x55,TM_STAGESPACE);
#endif

            /*
             * Success
             */
            return 0;
        }
        else
        {
#ifndef OLDSTUFF
            HEAPDESTROY (pDriverData->dwTMStageHandle);
#else
            HeapDestroy ((HANDLE)pDriverData->dwTMStageHandle);
#endif
        }
    }
#endif //TM_STAGER_IN_AGP

    pDriverData->dwTMStageHandle = 0; // <- this will indicate that we failed creating the texture manager
    return 1;
}

/*
 * Destroy TexMan Heap
 */
void nvTMDestroy
(
    void
)
{

#ifdef TM_STAGER_IN_AGP
    if (pDriverData->dwTMStageHandle)
    {
        FreeAGPHeap(lpDriverObject, pDriverData->dwTMStageHandle);
    }
#else
    if (pDriverData->dwTMStageHandle)
    {
        if (pDriverData->dwTMStageMem)
        {
#ifndef OLDSTUFF
            HEAPFREE (pDriverData->dwTMStageHandle,(void*)pDriverData->dwTMStageMem);
#else
            HeapFree ((HANDLE)pDriverData->dwTMStageHandle,0,(void*)pDriverData->dwTMStageMem);
#endif
            pDriverData->dwTMStageMem = 0;
        }
#ifndef OLDSTUFF
        HEAPDESTROY (pDriverData->dwTMStageHandle);
#else
        HeapDestroy ((HANDLE)pDriverData->dwTMStageHandle);
#endif
    }
#endif //TM_STAGER_IN_AGP

    pDriverData->dwTMStageHandle = 0;
}

/*
 * nvTMAllocTextureStagingSpace
 */
DWORD nvTMAllocTextureStagingSpace
(
    DWORD  dwSize,
    DWORD *pdwAddr,
    DWORD *pdwOffset
)
{
    DWORD dwSizeNeeded;
    DWORD dwFreeSpace;
    DWORD dwFirst;

#ifdef NV_NULL_HW_DRIVER
    *pdwAddr   = pDriverData->dwTMStageAddr;
    *pdwOffset = 0;
    return dwTMHead;
#endif //NV_NULL_HW_DRIVER

    /*
     * Get free space in staging heap
     */
    dwSizeNeeded = dwSize + TM_OFFSETALIGN;

    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Check 1");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMHead   = %08x",pDriverData->dwTMHead);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMTail   = %08x",pDriverData->dwTMTail);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   free space = %08x",nvTMGetFreeSpace());
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

    /*
     * Check if we can commit the space
     */
    dwFreeSpace  = nvTMGetFreeSpace();
    if (dwFreeSpace >= dwSizeNeeded)
    {
        DWORD addr;

    cont:
        addr     = (pDriverData->dwTMHead + (TM_OFFSETALIGN - 1)) & ~(TM_OFFSETALIGN-1);
        pDriverData->dwTMHead = addr + dwSize;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Commit Buffer");
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   New Head = %08x",pDriverData->dwTMHead);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   Buf Addr = %08x",addr);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   Buf Ofs  = %08x",addr - pDriverData->dwTMStageAddr);

        *pdwAddr   = addr;
#ifdef TM_STAGER_IN_AGP
        *pdwOffset = addr - pDriverData->GARTLinearBase;
#else
        *pdwOffset = addr - pDriverData->dwTMStageAddr;
#endif

        return pDriverData->dwTMHead; // this is what tail should be when texture blit retires
    }

    /*
     * Not enough space
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Out of staging space");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

#ifdef NV_PROFILE
    NVP_START(NVP_T_TSTAGE);
#endif

    dwFirst = 1;
    for (;;)
    {
        /*
         * Read Tail from psuedo notifier
         */
#ifdef DEBUG
        {
            DWORD old = pDriverData->dwTMTail;
#endif
#ifndef WINNT
        pDriverData->dwTMTail = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEX_RETIRE + pDriverData->BaseAddress);
#else
        pDriverData->dwTMTail = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEX_RETIRE + pDriverData->ppdev->pjScreen);
#endif // #ifdef WINNT

#ifdef DEBUG
            if (old < pDriverData->dwTMTail) memset ((void*)old,0x55,pDriverData->dwTMTail-old);
            if (old > pDriverData->dwTMTail) memset ((void*)old,0x55,pDriverData->dwTMStageMax-old);
        }
#endif

        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Check 2");
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMHead   = %08x",pDriverData->dwTMHead);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMTail   = %08x",pDriverData->dwTMTail);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   free space = %08x",nvTMGetFreeSpace());
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

        /*
         * Attempt to wrap around
         */
        if ((pDriverData->dwTMHead >= pDriverData->dwTMTail) && (pDriverData->dwTMTail > pDriverData->dwTMStageAddr)) {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Wrap around");
            /*
             * Set head to start of buffer
             */
            pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
            /*
             * Update tail
             */
            nvTMUpdateRetirementDate (pDriverData->dwTMHead);
            /*
             * Kick off data
             */
            nvStartDmaBuffer (FALSE);
        }

        /*
         * Check if we have enough space now
         */
        dwFreeSpace  = nvTMGetFreeSpace();
        if (dwFreeSpace >= dwSizeNeeded) goto retire;

        /*
         * Not enough space yet
         *   go to never-never land for a while
         *   save some PCI bus activity
         */
        if (dwFirst)
        {
            /*
             * Start Buffer just in case we have pending data (avoids hanging too)
             */
            nvStartDmaBuffer (FALSE);
            dwFirst = 0;
        }

        bTMHadToWaitForStagingSpace = TRUE;
        NV_DELAY;
    }

retire:
#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TSTAGE);
    nvpLogTime(NVP_T_TSTAGE,nvpTime[NVP_T_TSTAGE]);
#endif
    goto cont;
}

void nvTMUpdateRetirementDate
(
    DWORD dwRetirementAddress
)
{
    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "TM: Placing notifier at %08x",dwRetirementAddress);
    nvPlacePsuedoNotifier (NV_PN_TEX_RETIRE,dwRetirementAddress);
}

/*
 * Copy Texels
 */
void __inline nvTMCopyTexels
(
    DWORD dwSrcLine,
    DWORD dwSrcPitch,
    DWORD dwDst1Line,       // 1st destination
    DWORD dwDst1Pitch,
    DWORD dwDst2Line,       // 2nd destination (may be NULL)
    DWORD dwDst2Pitch,      // must be 0 when above is NULL
    DWORD dwSpanX,          // in bytes
    DWORD dwSpanY           // in lines
)
{
#ifdef NV_TEX2
    DWORD i,y;

    i = 4096 / dwSpanX; // move 4k at a time

    for (y = dwSpanY; y;)
    {
        DWORD h = min(y,i);
        DWORD z;

        if (h)
        {
            DWORD src = dwSrcLine;

            for (z=h; z; z--)
            {
                nvMemTouch (src,dwSpanX);
                src += dwSrcPitch;
            }
            for (z=h; z; z--)
            {
                nvMemCopy (dwDst1Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);
                if (dwDst2Line) nvMemCopy (dwDst2Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);

                dwDst1Line += dwDst1Pitch;
                dwDst2Line += dwDst2Pitch;
                dwSrcLine  += dwSrcPitch;
            }

            y -= h;
        }
        else // width too large for multi spans, do a line at a time
        {
            nvMemCopy (dwDst1Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);
            if (dwDst2Line) nvMemCopy (dwDst2Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);

            dwDst1Line += dwDst1Pitch;
            dwDst2Line += dwDst2Pitch;
            dwSrcLine  += dwSrcPitch;
            y--;
        }

    }

#else // !NV_TEX2

    long y;

    if (dwDst2Line) {
        if ((dwSpanX == dwDst1Pitch) && (dwSpanX == dwDst2Pitch) && (dwSpanX == dwSrcPitch))
        {
            DWORD size = dwSpanX * dwSpanY;
            while (size)
            {
                if (size >= 4096)
                {
                    memcpy ((void*)dwDst1Line,(void*)dwSrcLine,4096);
                    memcpy ((void*)dwDst2Line,(void*)dwSrcLine,4096);
                    size -= 4096;
                }
                else
                {
                    memcpy ((void*)dwDst1Line,(void*)dwSrcLine,size);
                    size = 0;
                }
            }
            return;
        }

        for (y=(long)dwSpanY; y>0; y--)
        {
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,dwSpanX);
            memcpy ((void*)dwDst2Line,(void*)dwSrcLine,dwSpanX);
            dwDst1Line += dwDst1Pitch;
            dwDst2Line += dwDst2Pitch;
            dwSrcLine  += dwSrcPitch;
        }
    }
    else
    {
        if ((dwSpanX == dwDst1Pitch) && (dwSpanX == dwSrcPitch))
        {
            DWORD size = dwSpanX * dwSpanY;
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,size);
            return;
        }

        for (y=(long)dwSpanY; y>0; y--)
        {
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,dwSpanX);
            dwDst1Line += dwDst1Pitch;
            dwSrcLine  += dwSrcPitch;
        }
    }
#endif // !NV_TEX2
}

/*
 * Setup swizzled Blt
 */
void __inline nvTMSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,

    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight
)
{
    /*
     * target surface
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwMipMapBaseU)
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwMipMapBaseV)),
                                         dwDstSwizzleOffset);

    /*
     * format
     */
    while (nvFreeCount < (sizeSetObject + sizeSetScaledImageFormat))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetScaledImageFormat));
    nvglSetObject               (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (nvFifo,nvFreeCount,NV_DD_SPARE, dwImageColorFormat);

    /*
     * source memory context
     */
    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
#ifdef TM_STAGER_IN_AGP
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
#else
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
#endif

    /*
     * clip
     */
    while (nvFreeCount < (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy));
    nvglScaledImageClip          (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (nvFifo,nvFreeCount,NV_DD_SPARE, (1<<20), (1<<20));

    /*
     * src & go
     */
    while (nvFreeCount < (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint));
    nvglScaledImageInSize   (nvFifo, nvFreeCount, NV_DD_SPARE, dwBlitWidth, dwBlitHeight);
    nvglScaledImageInFormat (nvFifo, nvFreeCount, NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0);

    pDriverData->dDrawSpareSubchannelObject = D3D_SCALED_IMAGE_FROM_MEMORY;
}

/*
 * Stage a Texture Swizzle Blt
 */
void nvTMVideoTextureBlt
(
    DWORD dwSrcLinearBase,
    DWORD dwSrcPitch,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcX1,
    DWORD dwSrcY1,
    DWORD dwDstLinearBase,
    DWORD dwDstPitch,
    DWORD dwDstX0,
    DWORD dwDstY0,
    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwTextureColorFormat
)
{
    DWORD dwImageColorFormat;
    DWORD dwSurfaceColorFormat;
    DWORD dwBytesPerPixel;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStagePitch;
    DWORD dwStageSize;
    DWORD dwSrcLinearAddr;
    DWORD dwDstLinearAddr;
    DWORD dwSpan;

    /*
     * Determine surface attributes
     */
    switch (dwTextureColorFormat)
    {
        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
        case NV054_FORMAT_COLOR_LE_R5G6B5:
        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
            dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
            dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
            dwBytesPerPixel      = 2;
            break;

        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
            dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
            dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
            dwBytesPerPixel      = 4;
            break;
    }

    /*
     * Calc staging area
     */
    dwHeight        = dwSrcY1 - dwSrcY0;
    dwWidth         = dwSrcX1 - dwSrcX0;
    dwSpan          = dwWidth * dwBytesPerPixel;
    dwStagePitch    = (dwSpan + (TM_PITCHALIGN-1)) & ~(TM_PITCHALIGN-1);
    dwStageSize     = dwStagePitch * dwHeight;
    dwSrcLinearAddr = dwSrcLinearBase + (dwSrcPitch * dwSrcY0) + (dwSrcX0 * dwBytesPerPixel);
    dwDstLinearAddr = dwDstLinearBase + (dwDstPitch * dwDstY0) + (dwDstX0 * dwBytesPerPixel);

    if (dwWidth >= 2048) {

        // the HW can't swizzle textures this wide. do it via CPU

        nvFlushDmaBuffers();

        if (dwSrcLinearBase) {

            // we've got a linear source and two destinations: one linear. one swizzled

            if (dwBytesPerPixel == 2) {
                nvSwizzleBlit16Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwSrcLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }
            else {
                nvSwizzleBlit32Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwSrcLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }

        }

        else {

            // we've got one linear source (passed in via dwDstLinearBase for reasons
            // that totally escape me) and one swizzled destination

            if (dwBytesPerPixel == 2) {
                nvSwizzleBlit16Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwDstLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,  // copy it back on top of itself
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }
            else {
                nvSwizzleBlit32Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwDstLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,  // copy it back on top of itself
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }

        }

        return;
    }

    /*
     * Small requests can be handled elegantly in one step
     */
    if (dwStageSize < (TM_STAGESPACE / 2))
    {
        DWORD dwStageHandle;
        DWORD dwStageAddr;
        DWORD dwStageOffset;

        /*
         * Allocate staging space - this function may kick off pusher
         */
        dwStageHandle = nvTMAllocTextureStagingSpace(dwStageSize,&dwStageAddr,&dwStageOffset);

        /*
         * Copy texels
         */
        if (dwSrcLinearBase)
        {
            if (dwDstLinearBase)
                nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest 1
                                dwDstLinearAddr,dwDstPitch,     // dest 2
                                dwSpan,dwHeight);
            else
                nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest
                                0,0,                            // nop
                                dwSpan,dwHeight);
        }
        else
            nvTMCopyTexels (dwDstLinearAddr,dwDstPitch,     // source
                            dwStageAddr,dwStagePitch,       // dest
                            0,0,                            // nop
                            dwSpan,dwHeight);

        /*
         * Setup the swizzle Blt
         */
        nvTMSwizzleBlt (dwStageOffset,dwStagePitch,dwImageColorFormat,
                        dwDstSwizzleOffset,dwMipMapBaseU,dwMipMapBaseV,dwSurfaceColorFormat,
                        dwDstX0,dwDstY0,dwWidth,dwHeight);

        /*
         * Report Retirement
         */
        nvTMUpdateRetirementDate (dwStageHandle);

        /*
         * Start Buffer just in case HW is idle
         */
        nvStartDmaBuffer (TRUE);
    }
    else
    /*
     * Large textures are sent in sections
     */
    {
        DWORD dwSection;
        DWORD dwSectionDelta;
        DWORD dwSectionSrcPitch;
        DWORD dwSectionDstPitch;
        DWORD dwSectionHeight;

        /*
         * init
         */
        dwSectionDelta    = (TM_STAGESPACE / 3) / dwStagePitch; // # of lines to fill 1/3 of the buffer
        dwSectionSrcPitch = (dwSrcLinearBase) ? (dwSrcPitch * dwSectionDelta) : 0;
        dwSectionDstPitch = (dwDstLinearBase) ? (dwDstPitch * dwSectionDelta) : 0;

        /*
         * step through sections
         */

        /*
        { // fill swizzle buffer
            DWORD size = (1<<dwMipMapBaseU)*(1<<dwMipMapBaseV)*dwBytesPerPixel;
            memset ((void*)(dwDstSwizzleOffset+pDriverData->BaseAddress),0xaa,size);
        }
        /**/

        for (dwSection = 0; dwSection < dwHeight; dwSection += dwSectionDelta)
        {
            DWORD dwStageHandle;
            DWORD dwStageAddr;
            DWORD dwStageOffset;

            /*
             * Prepare section
             */
            dwSectionHeight = dwHeight - dwSection;
            if (dwSectionHeight > dwSectionDelta) dwSectionHeight = dwSectionDelta;
            dwStageSize     = dwStagePitch * dwSectionHeight;

            /*
             * Allocate staging space - this function may kick off pusher
             */
            dwStageHandle = nvTMAllocTextureStagingSpace(dwStageSize,&dwStageAddr,&dwStageOffset);

            /*
             * Copy texels
             */
            if (dwSrcLinearBase)
            {
                if (dwDstLinearBase)
                    nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                    dwStageAddr,dwStagePitch,       // dest 1
                                    dwDstLinearAddr,dwDstPitch,     // dest 2
                                    dwSpan,dwSectionHeight);
                else
                    nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                    dwStageAddr,dwStagePitch,       // dest
                                    0,0,                            // nop
                                    dwSpan,dwSectionHeight);
            }
            else
                nvTMCopyTexels (dwDstLinearAddr,dwDstPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest
                                0,0,                            // nop
                                dwSpan,dwSectionHeight);

            /*
             * Setup the swizzle Blt
             */
            nvTMSwizzleBlt (dwStageOffset,dwStagePitch,dwImageColorFormat,
                            dwDstSwizzleOffset,dwMipMapBaseU,dwMipMapBaseV,dwSurfaceColorFormat,
                            dwDstX0,dwDstY0,dwWidth,dwSectionHeight);

            /*
             * Report Retirement
             */
            nvTMUpdateRetirementDate (dwStageHandle);

            /*
             * Start Buffer
             */
            nvStartDmaBuffer (TRUE);

        /*
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        Sleep (10);
        /**/

            /*
             * prep for next
             */
            dwSrcLinearAddr += dwSectionSrcPitch;
            dwDstLinearAddr += dwSectionDstPitch;
            dwDstY0         += dwSectionDelta;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\x86\x86.h ===
#ifndef _x86_h
#define _x86_h
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFISTP_rm32(rm)         x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm32(rm)          x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))

#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)

#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJL(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJNZ(disp)              { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }

#define xJMP(disp)              { DWORD _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)               // mov ebp,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(r,rm)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xRET                    x86s(1) x86b(0xc3)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_imm(rm,i)       x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)

#define xSHR_rm_imm(rm,i)       x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(2) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(2) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))
/*****************************************************************************
 * macros
 *****************************************************************************/

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILCGrowTo(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(BYTE)(x);              ilcCount++;
#define x86d(x)                 *(DWORD*)(ilcData+ilcCount) = (DWORD)(x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define x1                      0
#define x2                      1
#define x4                      2
#define x8                      3
#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo (DWORD dwNeed);

#endif //x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNACCESS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnaccess.asm
;
; Purpose:      This file implements the BeginAccess and EndAccess
;               Functions.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BeginAccess
;
; Purpose:      This function is the BeginAccess display driver callback
;               function used by other modules that need to syncronize
;               frame buffer access and access to the hardware.
;
; Arguments:    BeginAccess display driver stack frame
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GENERIC_BeginAccess, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wLeft
PARMW   wTop
PARMW   wRight
PARMW   wBottom
PARMW   wFlags
OPENPROC
        PUSHR   ds,esi
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
	bts	ds:[esi].DIBENGINE.deFlags,BUSY_BIT
	jc	BA_End

        test    wFlags,FB_ACCESS
        jz      @F
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	@F
        mov	esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess
@@:
	test	wFlags,CURSOREXCLUDE
	jz	@F

	mov	eax,lpDevice
	cmp	eax,cs:[CSlp16LogDevice]
	jne	@F

	push	lpDevice
	push	wLeft
	push	wTop
	push	wRight
	push	wBottom
	pushw	CURSOREXCLUDE
	call	DIB_BeginAccess
@@:
	; Turn off BUSY bit
        mov	esi,cs:[CSpGNLogicalDevice]
	and	ds:[esi].DIBENGINE.deFlags,NOT BUSY
BA_End:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_EndAccess
;
; Purpose:      This function is the EndAccess display driver callback
;               function. It is called by other modules after they have
;               finished accessing the frame buffer or other hardware.
;
; Arguments:    EndAccess display driver stack frame
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GENERIC_EndAccess, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wFlags
OPENPROC
	test	wFlags,CURSOREXCLUDE
	jz	EA_End

        PUSHR   ds,esi
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
	bts	ds:[esi].DIBENGINE.deFlags,BUSY_BIT
	jc	EA_Popr

        test    wFlags,FB_ACCESS
        jz      @F
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	@F
        mov	esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess
@@:
	mov	eax,lpDevice
	cmp	eax,cs:[CSlp16LogDevice]
	jne	@F

	push	lpDevice
	pushw	CURSOREXCLUDE
	call	DIB_EndAccess

@@:
	; Turn off BUSY bit
        mov	esi,cs:[CSpGNLogicalDevice]
	and	ds:[esi].DIBENGINE.deFlags,NOT BUSY

EA_Popr:
        POPR    ds,esi
EA_End:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBMPBTS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnbmpbts.asm
;
; Purpose:      This file holds the BitmapBits display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

DDB_SET                 EQU     1
DDB_GET                 EQU     2
DDB_COPY                EQU     4
DDB_SETWITHFILLER       EQU     8

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BitmapBits
;
; Purpose:      This function is the BitmapBits display driver entry point.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
; Returns:      The return values from the functions vary.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BitmapBits, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   dwFlags
PARMD   dwCount
PARMD   lpBits

LOCALD  dwBytesToCopyPerWholeScan
LOCALD  dwBytesToCopyPerPartialScan
LOCALD  dwPixelsToCopyPerWholeScan
LOCALD  dwWholeScansToCopy
LOCALD  dwTotalBytesToCopy
LOCALD  dwDstWrapWidth
LOCALD  dwSrcWrapWidth
LOCALD  dwSrcBpp
LOCALD  dwInVram
LOCALD  dwXferHeight
OPENPROC
        PUSHR   ds,esi,edi

        ; Check and block copies to the screen if it is busy
        mov     fs,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     fs:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitmapBitsPuntNoWait

        mov     eax,dwFlags
        mov     dwInVram,0
        cmp     eax,1
        je      BitmapBits_Set
        cmp     eax,4
        jc      BitmapBits_Get
        je      BitmapBits_Copy
        jmp     BitmapBits_SetWithFiller

GENERIC_BitmapBits      ENDP

;==============================================================================
;
; Function:     BitmapBits ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of BitmapBits. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_BitmapBitsPunt
GN_BitmapBitsPunt       PROC    NEAR
        sub     esi,esi
        lds     si,lpDstDev
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    eax,VRAM
        jz      GN_BitmapBitsPuntNoWait

        ; Syncronize with the engine
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess

PLABEL  GN_BitmapBitsPuntNoWait
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_BitmapBits
        jmp     DIB_BitmapBits
GN_BitmapBitsPunt       ENDP

PUBLIC  GN_BitmapBitsSuccess
GN_BitmapBitsSuccess    PROC    NEAR
        mov     eax,dwTotalBytesToCopy
        shld    edx,eax,10H
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 10H
GN_BitmapBitsSuccess    ENDP


;==============================================================================
;
; Function:     BitmapBits_Set
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_SET. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the raw flat linear data buffer pointed to by lpBits
;               to the dst bitmap whose header is pointed to by lpDstDev.
;
;               If lpDstDev points to a VRAM bitmap, then use the hardware
;               to do the transfer.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Set
BitmapBits_Set  PROC    NEAR

        ; Load up a ptr to the dst bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        ; Compute the smaller of bytes requested and size of bitmap.
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        imul    eax,ebx
        cmp     eax,dwCount
        jc      @F
        mov     eax,dwCount
@@:     mov     dwTotalBytesToCopy,eax

        ; Punt dst that we can't handle (this almost never happens)
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    eax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    eax,VRAM
        jz      NotVrm
        mov     dwInVram,1

        ; We may be able to use the hardware, but only if the
        ; number of bytes we are asked to copy is an integral
        ; number of scanlines. If there is a partial scanline,
        ; then we could do it, but since we only process
        ; rectangles with the hardware, we would have to do it
        ; in two operations. The 2 rect case almost never
        ; happens, so we use software for the case.
        mov     eax,dwTotalBytesToCopy
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        sub     edx,edx
        idiv    ecx
        mov     dwXferHeight,eax
        or      edx,edx
        jne     NotVrm

        ; USE THE HARDWARE HERE
        ; Let the vendor handle the whole thing
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr ds:[esi].DIBENGINE.deBits+4
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr ds:[esi].DIBENGINE.deBits
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        movzx   eax,word ptr lpBits+2
        movzx   ecx,word ptr lpBits+0
        push    eax
        push    ecx
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        push    eax
        push    ecx
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,word ptr ds:[esi].DIBENGINE.deWidth
        push    eax
        push    dwXferHeight
        mov     ecx,0CC0000H
        push    ecx
        push    ebx                                             ;lpBrush
        push    ebx                                             ;lpDrawMode
        push    ebx                                             ;size color table entry in bytes
        push    ebx                                             ;num color table entries
        push    ebx                                             ;lpColorTable
        push    ebx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        je      NotVrm
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

NotVrm:
        ; Load up the ptrs
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        les     edi,ds:[esi].DIBENGINE.deBits
        lds     si,lpBits
        mov     dwBytesToCopyPerWholeScan,ebx
        sub     ecx,ebx
        je      BitmapBits_CopyAll

        ; The pitch and width of the bitmap are not the same so ...
        sub     eax,eax
        mov     dwDstWrapWidth,ecx
        mov     dwSrcWrapWidth,eax
        jmp     BitmapBits_CopyByScan

BitmapBits_Set  ENDP


;==============================================================================
;
; Function:     BitmapBits_SetWithFiller
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_SETWITHFILLER. In
;               this flavor of the routine, you copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpBits to
;               the dst bitmap whose header is pointed to by lpDstDev.
;
;               This is like a BitmapBits_Set except that the raw data
;               buffer pointed to by lpBits is not flat. There are fill
;               bytes to prevent a break in the src data for a scanline.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_SetWithFiller
BitmapBits_SetWithFiller        PROC    NEAR

        ; Load up a ptr to the src bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    al,SELECTEDDIB
        jnz     GN_BitmapBitsPunt

        ; If the width in bytes of the dst is a power of 2 less than
        ; 64K, then we can treat the src as flat since there will be
        ; zero fillbytes.
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     eax,10000H
        sub     edx,edx
        div     ebx
        or      edx,edx
        je      BitmapBits_Set

        ; Also, we can treat the src as flat if we don't need to transfer
        ; more than 64K.
        cmp     ax,ds:[esi].DIBENGINE.deHeight
        ja      BitmapBits_Set

        ; Else, we are going to have to do it -- I vote we punt!
        ; This case almost never happens.
        jmp     GN_BitmapBitsPunt

BitmapBits_SetWithFiller        ENDP


;==============================================================================
;
; Function:     BitmapBits_Get
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_GET. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpDstDev to
;               the raw flat linear data buffer pointed to by lpBits.
;
;               If lpDstDev points to a VRAM bitmap, then use the hardware
;               DMA to do the transfer.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Get
BitmapBits_Get  PROC    NEAR

        ; Load up a ptr to the src bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        ; Copy the smaller of bytes requested and size of bitmap.
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        imul    eax,ebx
        cmp     eax,dwCount
        jc      @F
        mov     eax,dwCount
@@:     mov     dwTotalBytesToCopy,eax

        ; Punt dsts (actually sources in this case) that we can't handle
        mov     ax,ds:[esi].DIBENGINE.deFlags
        test    ax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    eax,VRAM
        jz      NotVrm
        mov     dwInVram,1

        ; We may be able to use the hardware, but only if the
        ; number of bytes we are asked to copy is an integral
        ; number of scanlines. If there is a partial scanline,
        ; then we could do it, but since we only process
        ; rectangles with the hardware, we would have to do it
        ; in two operations. The 2 rect case almost never
        ; happens, so we use software for the case.
        mov     eax,dwTotalBytesToCopy
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        sub     edx,edx
        idiv    ecx
        mov     dwXferHeight,eax
        or      edx,edx
        jne     NotVrm

        ; USE THE HARDWARE HERE
        ; Call the generic code to overlap DMAing and converting.
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        push    ebx
        movzx   eax,word ptr lpBits+2
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        movzx   eax,word ptr lpBits
        push    eax
        push    ecx
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        push    eax
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        push    ebx                                             ;lpSrcDev
        movzx   eax,word ptr ds:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr ds:[esi].DIBENGINE.deBits
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,ds:[esi].DIBENGINE.deWidth
        push    eax
        push    dwXferHeight
        mov     eax,0CC0000H
        push    eax
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[ecx]
        mov     edx,ebx
        cmp     ebx,MAX_BPP_INDICES
        jge     NotVrm
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        push    ecx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        je      NotVrm
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

NotVrm:
        ; Load up the ptrs
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        les     di,lpBits
        lds     esi,ds:[esi].DIBENGINE.deBits
        mov     dwBytesToCopyPerWholeScan,ebx
        sub     ecx,ebx
        je      BitmapBits_CopyAll

        ; The pitch and width of the bitmap are not the same so ...
        sub     eax,eax
        mov     dwSrcWrapWidth,ecx
        mov     dwDstWrapWidth,eax
        jmp     BitmapBits_CopyByScan

BitmapBits_Get  ENDP


;==============================================================================
;
; Function:     BitmapBits_Copy
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpBits to
;               the dst bitmap whose header is pointed to by lpDstDev.
;
;               If one of lpBits or lpDstDev points to a header which
;               is in VRAM, then hardware acceleration can be used.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Copy
BitmapBits_Copy PROC    NEAR

        ; Load up the ptrs to both bitmap headers
        sub     esi,esi
        sub     edi,edi
        lds     si,lpBits
        les     di,lpDstDev
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        mov     dwSrcBpp,eax

        ; With two bitmaps, things are different. We will not copy
        ; more bytes per scan than the narrower of two bitmaps.
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        movzx   ecx,es:[edi].DIBENGINE.deWidthBytes
        movzx   edx,ds:[esi].DIBENGINE.deWidth
        cmp     eax,ecx
        jc      @F
        movzx   edx,es:[edi].DIBENGINE.deWidth
        mov     eax,ecx
@@:     mov     dwBytesToCopyPerWholeScan,eax
        mov     dwPixelsToCopyPerWholeScan,edx

        ; We will not copy more scans than the shorter of the two.
        movzx   ebx,ds:[esi].DIBENGINE.deHeight
        movzx   edx,es:[edi].DIBENGINE.deHeight
        cmp     ebx,edx
        jc      @F
        mov     ebx,edx
@@:     mov     dwWholeScansToCopy,ebx

        ; For this call, we ignore the dwCount parameter and just copy
        ; the src to the dst clipping to the smaller of the two bitmaps.
        imul    eax,ebx
        mov     dwTotalBytesToCopy,eax

        ; Figure out how many scans this number of bytes correpsonds to:
        sub     edx,edx
        div     dwBytesToCopyPerWholeScan
        mov     dwBytesToCopyPerPartialScan,edx
        cmp     eax,dwWholeScansToCopy
        jc      @F
        mov     dwBytesToCopyPerPartialScan,0
        mov     eax,dwWholeScansToCopy
@@:     mov     dwWholeScansToCopy,eax

        ; Punt those we don't handle (very rare that we punt)
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        movzx   ebx,es:[edi].DIBENGINE.deFlags
        test    eax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    ebx,SELECTEDDIB
        jnz     GN_BitmapBitsPunt

        ; Now break out into the four cases --
        ; sys->sys, sys->vram, vram->sys, vram->vram
        ; We can use the hardware for the last three cases
        test    eax,VRAM
        jz      @F
        test    ebx,VRAM
        jnz     BitmapBits_CopyVramToVram
        jmp     BitmapBits_CopyVramToSystem
@@:     test    ebx,VRAM
        jnz     BitmapBits_CopySystemToVram
        jmp     BitmapBits_CopySystemToSystem

BitmapBits_Copy ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyVramToVram
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               and dst bitmaps are both known to be in vram.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyVramToVram
BitmapBits_CopyVramToVram       PROC    NEAR

        cmp     dwWholeScansToCopy,0
        je      @F
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpBits
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        push    eax                             ; wDstX:wDstY
        push    eax                             ; wSrcX:wSrcY
        mov     eax,dwPixelsToCopyPerWholeScan
        shl     eax,10H
        or      eax,dwWholeScansToCopy
        push    eax                             ; wExtX:wExtY
        mov     ecx,0CC0000H
        push    ecx
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jle     FailHW
@@:
        ; Do the extra portion of a scan
        cmp     dwBytesToCopyPerPartialScan,0
        je      GN_BitmapBitsSuccess
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpBits
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        mov     eax,dwWholeScansToCopy
        push    eax                             ; wDstX:wDstY
        push    eax                             ; wSrcX:wSrcY

        ; To how many pixels do the extra bytes correspond?
        mov     eax,dwBytesToCopyPerPartialScan
        cmp     dwSrcBpp,8
        je      @F
        shr     eax,1
        cmp     dwSrcBpp,32
        jc      @F
        shr     eax,1
@@:     shl     eax,10H
        mov     ax,1
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess

FailHW:
        jmp     BitmapBits_CopySystemToSystem

BitmapBits_CopyVramToVram       ENDP


;==============================================================================
;
; Function:     BitmapBits_CopySystemToVram
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               bitmap is in system memory and the and dst bitmap is in
;               VRAM.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               ds:esi  DIBENGINE ptr for src
;               es:edi  DIBENGINE ptr for dst
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopySystemToVram
BitmapBits_CopySystemToVram     PROC    NEAR

        ; Let the vendor handle the whole thing
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        movzx   ecx,es:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        push    ecx
        push    es:[edi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        push    eax
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,word ptr ds:[esi].DIBENGINE.deWidth
        push    eax
        movzx   eax,word ptr ds:[esi].DIBENGINE.deHeight
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx                                             ;lpBrush
        push    ebx                                             ;lpDrawMode
        push    ebx                                             ;size color table entry in bytes
        push    ebx                                             ;num color table entries
        push    ebx                                             ;lpColorTable
        push    ebx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        mov     dwInVram,1
        je      BitmapBits_CopySystemToSystem
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

BitmapBits_CopySystemToVram     ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyVramToSystem
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               bitmap is in video memory and the and dst bitmap is in
;               system memory.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyVramToSystem
BitmapBits_CopyVramToSystem     PROC    NEAR

        ; Call the generic code to overlap DMAing and converting.
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        push    ebx
        movzx   eax,es:[edi].DIBENGINEHDR.deBitsSelector
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[edi].DIBENGINEHDR.deBitsOffset
        push    ecx
        push    es:[edi].DIBENGINEHDR.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        push    ebx                                             ;lpSrcDev
        movzx   eax,ds:[esi].DIBENGINEHDR.deBitsSelector
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    ds:[esi].DIBENGINEHDR.deBitsOffset
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,ds:[esi].DIBENGINE.deWidth
        push    eax
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        push    eax
        mov     eax,0CC0000H
        push    eax
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[ecx]
        mov     edx,ebx
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        push    ecx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        mov     dwInVram,1
        je      BitmapBits_CopySystemToSystem
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

BitmapBits_CopyVramToSystem     ENDP


;==============================================================================
;
; Function:     BitmapBits_CopySystemToSystem
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               and dst bitmaps are both in system memory.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy              can be 0
;               dwBytesToCopyPerPartialScan     can be 0
;
;==============================================================================
PUBLIC  BitmapBits_CopySystemToSystem
BitmapBits_CopySystemToSystem   PROC    NEAR

        ; Reload these ptrs and do it in software
        sub     esi,esi
        sub     edi,edi
        lds     si,lpBits
        les     di,lpDstDev

        ; We can treat the bitmaps as one big linear array of bytes if
        ; the width in bytes and pitches of the bitmaps match.
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        movzx   ebx,es:[edi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        mov     edx,es:[edi].DIBENGINE.deDeltaScan
        add     eax,3
        add     ebx,3
        and     eax,NOT 3
        and     ebx,NOT 3
        cmp     eax,ebx
        jne     AsRect
        cmp     eax,ecx
        jne     AsRect
        cmp     ebx,edx
        jne     AsRect

        ; Linear it is, copy up all the bytes desired
        imul    ecx,dwWholeScansToCopy
        add     ecx,dwBytesToCopyPerPartialScan
        mov     dwTotalBytesToCopy,ecx
        lds     esi,ds:[esi].DIBENGINE.deBits
        les     edi,es:[edi].DIBENGINE.deBits
        jmp     BitmapBits_CopyAll

AsRect:
        ; Compute wrap widths, load ptrs and go copy it
        sub     ecx,dwBytesToCopyPerWholeScan
        sub     edx,dwBytesToCopyPerWholeScan
        mov     dwSrcWrapWidth,ecx
        mov     dwDstWrapWidth,edx
        lds     esi,ds:[esi].DIBENGINE.deBits
        les     edi,es:[edi].DIBENGINE.deBits
        jmp     BitmapBits_CopyByScan

BitmapBits_CopySystemToSystem   ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyByScan
;
; Purpose:      This function is jumped to when we are ready to copy
;               data from one place to another. Unfortunately,it is
;               not just one long linear block, but rather rectangle
;               to rectangle. Wait for idle, if needed, and then copy.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               ds:esi                  ptr to src bits
;               es:edi                  ptr to dst bits
;               dwTotalBytesToCopy
;               dwBytesToCopyPerWholeScan
;               dwSrcWrapWidth
;               dwDstWrapWidth
;
;==============================================================================
PUBLIC  BitmapBits_CopyByScan
BitmapBits_CopyByScan   PROC    NEAR

        cmp     dwInVram,0
        jz      @F

        ; Syncronize with the engine
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
@@:
        ; Compute the dword and partial dword counts
        mov     eax,dwBytesToCopyPerWholeScan
        mov     edx,dwTotalBytesToCopy
        jmp     @F
LoopY:
        mov     ecx,eax
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,eax
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
@@:     sub     edx,eax
        jge     LoopY

        ; Check for a partial scan
        add     edx,eax
        jle     GN_BitmapBitsSuccess
        mov     ecx,edx
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,edx
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]

        cmp     dwInVram,0
        jz      GN_BitmapBitsSuccess
        push    cs:[CSlp16LogDevice]
        pushw   FB_ACCESS
        call    GENERIC_EndAccess
        jmp     GN_BitmapBitsSuccess

BitmapBits_CopyByScan   ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyAll
;
; Purpose:      This function is jumped to when we are ready to copy
;               data from one place to another. It is just one long
;               linear block. We may need to wait for idle, though.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwTotalBytesToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyAll
BitmapBits_CopyAll      PROC    NEAR

        cmp     dwInVram,0
        jz      @F

        ; Syncronize with the engine
        push    lpDstDev
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
@@:
        mov     ecx,dwTotalBytesToCopy
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,dwTotalBytesToCopy
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]

        cmp     dwInVram,0
        jz      GN_BitmapBitsSuccess
        push    lpDstDev
        pushw   FB_ACCESS
        call    GENERIC_EndAccess
        jmp     GN_BitmapBitsSuccess

BitmapBits_CopyAll      ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4vx.c ===
/*
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 *
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4VX.C                                                           *
*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/23/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3d.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_FASTLOOPS

DWORD dwDrawPrimitiveTable[] =
{
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/
   (DWORD)nvAACapturePrimitive,
   (DWORD)nvDX5TriangleSetup,
   (DWORD)nvAACapturePrimitive,
   (DWORD)nvDX6TriangleSetup,
};

#else //~NV_FASTLOOPS

/*
 * Function Tables
 */
LPNVDRAWPRIM fnDX5Table[] =
{
    nvDX5Triangle                           ,
    nvDX5TriangleExpFog                     ,
    nvDX5TriangleExp2Fog                    ,
    nvDX5TriangleLinearFog                  ,
    nvDX5TriangleWBuf                       ,
    nvDX5TriangleExpFogWBuf                 ,
    nvDX5TriangleExp2FogWBuf                ,
    nvDX5TriangleLinearFogWBuf              ,
    nvDX5TriangleAACapture                  ,
    nvDX5TriangleAACaptureWBuf              ,
    nvDX5TriangleSetup
};

LPNVINDEXEDPRIM fnDX5IndexedTable[] =
{
    nvDX5TriangleIndexed                    ,
    nvDX5TriangleExpFogIndexed              ,
    nvDX5TriangleExp2FogIndexed             ,
    nvDX5TriangleLinearFogIndexed           ,
    nvDX5TriangleIndexedWBuf                ,
    nvDX5TriangleExpFogIndexedWBuf          ,
    nvDX5TriangleExp2FogIndexedWBuf         ,
    nvDX5TriangleLinearFogIndexedWBuf       ,
    nvDX5TriangleIndexedAACapture           ,
    nvDX5TriangleIndexedAACaptureWBuf       ,
    nvDX5IndexedTriangleSetup
};

LPNVFVFDRAWPRIM fnDX5FlexTable[] =
{
    nvDX5FlexTriangle                       ,
    nvDX5FlexTriangleExpFog                 ,
    nvDX5FlexTriangleExp2Fog                ,
    nvDX5FlexTriangleLinearFog              ,
    nvDX5FlexTriangleWBuf                   ,
    nvDX5FlexTriangleExpFogWBuf             ,
    nvDX5FlexTriangleExp2FogWBuf            ,
    nvDX5FlexTriangleLinearFogWBuf          ,
    nvDX5FlexTriangleAACapture              ,
    nvDX5FlexTriangleAACaptureWBuf          ,
    nvDX5FlexTriangleSetup
};

LPNVFVFINDEXEDPRIM fnDX5FlexIndexedTable[] =
{
    nvDX5FlexTriangleIndexed                ,
    nvDX5FlexTriangleExpFogIndexed          ,
    nvDX5FlexTriangleExp2FogIndexed         ,
    nvDX5FlexTriangleLinearFogIndexed       ,
    nvDX5FlexTriangleIndexedWBuf            ,
    nvDX5FlexTriangleExpFogIndexedWBuf      ,
    nvDX5FlexTriangleExp2FogIndexedWBuf     ,
    nvDX5FlexTriangleLinearFogIndexedWBuf   ,
    nvDX5FlexTriangleIndexedAACapture       ,
    nvDX5FlexTriangleIndexedAACaptureWBuf   ,
    nvDX5FlexIndexedTriangleSetup
};

LPNVFVFDRAWPRIM fnDX6FlexTable[] =
{
    nvDX6FlexTriangle                       ,
    nvDX6FlexTriangleExpFog                 ,
    nvDX6FlexTriangleExp2Fog                ,
    nvDX6FlexTriangleLinearFog              ,
    nvDX6FlexTriangleWBuf                   ,
    nvDX6FlexTriangleExpFogWBuf             ,
    nvDX6FlexTriangleExp2FogWBuf            ,
    nvDX6FlexTriangleLinearFogWBuf          ,
    nvDX6FlexTriangleAACapture              ,
    nvDX6FlexTriangleAACaptureWBuf          ,
    nvDX6FlexTriangleSetup
};

LPNVFVFINDEXEDPRIM fnDX6FlexIndexedTable[] =
{
    nvDX6FlexTriangleIndexed                ,
    nvDX6FlexTriangleExpFogIndexed          ,
    nvDX6FlexTriangleExp2FogIndexed         ,
    nvDX6FlexTriangleLinearFogIndexed       ,
    nvDX6FlexTriangleIndexedWBuf            ,
    nvDX6FlexTriangleExpFogIndexedWBuf      ,
    nvDX6FlexTriangleExp2FogIndexedWBuf     ,
    nvDX6FlexTriangleLinearFogIndexedWBuf   ,
    nvDX6FlexTriangleIndexedAACapture       ,
    nvDX6FlexTriangleIndexedAACaptureWBuf   ,
    nvDX6FlexIndexedTriangleSetup
};


/*
 * Function declarations
 */

// nvDX5Triangle
#define  PROC_        "nvDX5Triangle                           "
#define  PROC         nvDX5Triangle
#define  VERTEX       nvglDX5TriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#include "nv4loop.c"
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFog
#define  PROC_        "nvDX5TriangleExpFog                     "
#define  PROC         nvDX5TriangleExpFog
#define  VERTEX       nvglDX5TriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2Fog
#define  PROC_        "nvDX5TriangleExp2Fog                    "
#define  PROC         nvDX5TriangleExp2Fog
#define  VERTEX       nvglDX5TriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFog
#define  PROC_        "nvDX5TriangleLinearFog                  "
#define  PROC         nvDX5TriangleLinearFog
#define  VERTEX       nvglDX5TriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleWBuf
#define  PROC_        "nvDX5TriangleWBuf                       "
#define  PROC         nvDX5TriangleWBuf
#define  VERTEX       nvglDX5TriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogWBuf
#define  PROC_        "nvDX5TriangleExpFogWBuf                 "
#define  PROC         nvDX5TriangleExpFogWBuf
#define  VERTEX       nvglDX5TriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogWBuf
#define  PROC_        "nvDX5TriangleExp2FogWBuf                "
#define  PROC         nvDX5TriangleExp2FogWBuf
#define  VERTEX       nvglDX5TriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogWBuf
#define  PROC_        "nvDX5TriangleLinearFogWBuf              "
#define  PROC         nvDX5TriangleLinearFogWBuf
#define  VERTEX       nvglDX5TriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexed
#define  PROC_        "nvDX5TriangleIndexed                    "
#define  PROC         nvDX5TriangleIndexed
#define  VERTEX       nvglDX5TriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogIndexed
#define  PROC_        "nvDX5TriangleExpFogIndexed              "
#define  PROC         nvDX5TriangleExpFogIndexed
#define  VERTEX       nvglDX5TriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogIndexed
#define  PROC_        "nvDX5TriangleExp2FogIndexed             "
#define  PROC         nvDX5TriangleExp2FogIndexed
#define  VERTEX       nvglDX5TriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogIndexed
#define  PROC_        "nvDX5TriangleLinearFogIndexed           "
#define  PROC         nvDX5TriangleLinearFogIndexed
#define  VERTEX       nvglDX5TriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedWBuf
#define  PROC_        "nvDX5TriangleIndexedWBuf                "
#define  PROC         nvDX5TriangleIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogIndexedWBuf
#define  PROC_        "nvDX5TriangleExpFogIndexedWBuf          "
#define  PROC         nvDX5TriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX5TriangleExp2FogIndexedWBuf         "
#define  PROC         nvDX5TriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX5TriangleLinearFogIndexedWBuf       "
#define  PROC         nvDX5TriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleAACapture
#define  PROC_        "nvDX5TriangleAACapture                  "
#define  PROC         nvDX5TriangleAACapture
#define  VERTEX       nvglDX5TriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleAACaptureWBuf
#define  PROC_        "nvDX5TriangleAACaptureWBuf              "
#define  PROC         nvDX5TriangleAACaptureWBuf
#define  VERTEX       nvglDX5TriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedAACapture
#define  PROC_        "nvDX5TriangleIndexedAACapture           "
#define  PROC         nvDX5TriangleIndexedAACapture
#define  VERTEX       nvglDX5TriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX5TriangleIndexedAACaptureWBuf       "
#define  PROC         nvDX5TriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX5TriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangle
#define  PROC_        "nvDX5FlexTriangle                       "
#define  PROC         nvDX5FlexTriangle
#define  VERTEX       nvglDX5FlexTriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFog
#define  PROC_        "nvDX5FlexTriangleExpFog                 "
#define  PROC         nvDX5FlexTriangleExpFog
#define  VERTEX       nvglDX5FlexTriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2Fog
#define  PROC_        "nvDX5FlexTriangleExp2Fog                "
#define  PROC         nvDX5FlexTriangleExp2Fog
#define  VERTEX       nvglDX5FlexTriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFog
#define  PROC_        "nvDX5FlexTriangleLinearFog              "
#define  PROC         nvDX5FlexTriangleLinearFog
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleWBuf
#define  PROC_        "nvDX5FlexTriangleWBuf                   "
#define  PROC         nvDX5FlexTriangleWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogWBuf
#define  PROC_        "nvDX5FlexTriangleExpFogWBuf             "
#define  PROC         nvDX5FlexTriangleExpFogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogWBuf
#define  PROC_        "nvDX5FlexTriangleExp2FogWBuf            "
#define  PROC         nvDX5FlexTriangleExp2FogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogWBuf
#define  PROC_        "nvDX5FlexTriangleLinearFogWBuf          "
#define  PROC         nvDX5FlexTriangleLinearFogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexed
#define  PROC_        "nvDX5FlexTriangleIndexed                "
#define  PROC         nvDX5FlexTriangleIndexed
#define  VERTEX       nvglDX5FlexTriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogIndexed
#define  PROC_        "nvDX5FlexTriangleExpFogIndexed          "
#define  PROC         nvDX5FlexTriangleExpFogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogIndexed
#define  PROC_        "nvDX5FlexTriangleExp2FogIndexed         "
#define  PROC         nvDX5FlexTriangleExp2FogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogIndexed
#define  PROC_        "nvDX5FlexTriangleLinearFogIndexed       "
#define  PROC         nvDX5FlexTriangleLinearFogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleIndexedWBuf            "
#define  PROC         nvDX5FlexTriangleIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleExpFogIndexedWBuf      "
#define  PROC         nvDX5FlexTriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleExp2FogIndexedWBuf     "
#define  PROC         nvDX5FlexTriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleLinearFogIndexedWBuf   "
#define  PROC         nvDX5FlexTriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleAACapture
#define  PROC_        "nvDX5FlexTriangleAACapture              "
#define  PROC         nvDX5FlexTriangleAACapture
#define  VERTEX       nvglDX5FlexTriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleAACaptureWBuf
#define  PROC_        "nvDX5FlexTriangleAACaptureWBuf          "
#define  PROC         nvDX5FlexTriangleAACaptureWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedAACapture
#define  PROC_        "nvDX5FlexTriangleIndexedAACapture       "
#define  PROC         nvDX5FlexTriangleIndexedAACapture
#define  VERTEX       nvglDX5FlexTriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX5FlexTriangleIndexedAACaptureWBuf   "
#define  PROC         nvDX5FlexTriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangle
#define  PROC_        "nvDX6FlexTriangle                       "
#define  PROC         nvDX6FlexTriangle
#define  VERTEX       nvglDX6FlexTriangleVertex
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFog
#define  PROC_        "nvDX6FlexTriangleExpFog                 "
#define  PROC         nvDX6FlexTriangleExpFog
#define  VERTEX       nvglDX6FlexTriangleVertexExpFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2Fog
#define  PROC_        "nvDX6FlexTriangleExp2Fog                "
#define  PROC         nvDX6FlexTriangleExp2Fog
#define  VERTEX       nvglDX6FlexTriangleVertexExp2Fog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFog
#define  PROC_        "nvDX6FlexTriangleLinearFog              "
#define  PROC         nvDX6FlexTriangleLinearFog
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleWBuf
#define  PROC_        "nvDX6FlexTriangleWBuf                   "
#define  PROC         nvDX6FlexTriangleWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogWBuf
#define  PROC_        "nvDX6FlexTriangleExpFogWBuf             "
#define  PROC         nvDX6FlexTriangleExpFogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExpFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogWBuf
#define  PROC_        "nvDX6FlexTriangleExp2FogWBuf            "
#define  PROC         nvDX6FlexTriangleExp2FogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExp2FogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogWBuf
#define  PROC_        "nvDX6FlexTriangleLinearFogWBuf          "
#define  PROC         nvDX6FlexTriangleLinearFogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexed
#define  PROC_        "nvDX6FlexTriangleIndexed                "
#define  PROC         nvDX6FlexTriangleIndexed
#define  VERTEX       nvglDX6FlexTriangleVertex
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogIndexed
#define  PROC_        "nvDX6FlexTriangleExpFogIndexed          "
#define  PROC         nvDX6FlexTriangleExpFogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexExpFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogIndexed
#define  PROC_        "nvDX6FlexTriangleExp2FogIndexed         "
#define  PROC         nvDX6FlexTriangleExp2FogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexExp2Fog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogIndexed
#define  PROC_        "nvDX6FlexTriangleLinearFogIndexed       "
#define  PROC         nvDX6FlexTriangleLinearFogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleIndexedWBuf            "
#define  PROC         nvDX6FlexTriangleIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleExpFogIndexedWBuf      "
#define  PROC         nvDX6FlexTriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExpFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleExp2FogIndexedWBuf     "
#define  PROC         nvDX6FlexTriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExp2FogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleLinearFogIndexedWBuf   "
#define  PROC         nvDX6FlexTriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleAACapture
#define  PROC_        "nvDX6FlexTriangleAACapture              "
#define  PROC         nvDX6FlexTriangleAACapture
#define  VERTEX       nvglDX6FlexTriangleVertexAACapture
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleAACaptureWBuf
#define  PROC_        "nvDX6FlexTriangleAACaptureWBuf          "
#define  PROC         nvDX6FlexTriangleAACaptureWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexAACaptureWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedAACapture
#define  PROC_        "nvDX6FlexTriangleIndexedAACapture       "
#define  PROC         nvDX6FlexTriangleIndexedAACapture
#define  VERTEX       nvglDX6FlexTriangleVertexAACapture
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX6FlexTriangleIndexedAACaptureWBuf   "
#define  PROC         nvDX6FlexTriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexAACaptureWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

#endif //!NV_FASTLOOPS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBOARD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnboard.asm
;
; Purpose:      This file holds init routines for the GNBOARDCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szDisplayDeviceName
szDisplayDeviceName     DB      "DISPLAY",0

;==============================================================================
;
; Function:     GN_FindBoardContext
;
; Purpose:      This routine searches to see if a GNBOARDCX exists
;               for the board specified.
;
;		If this routine finds a GNBOARDCX already active on
;		this board, then it establishes the wFlatDataSelector
;		in the code segments. If it does not find one, then
;		the flat data selectors are left untouched.
;
; Arguments:
;               dwBoardDevnode
;
; Returns:      eax             GNBOARDCX ptr
;                               0 if there are no instances yet
;
;		If there are instances, then ds has the context selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindBoardContext, PASCAL, FRAME, FAR16
PARMD   dwBoardDevnode
OPENPROC
	; We need a flat data selector temporarily
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,-1
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
	mov	ds,ax

	; Now get the global mapping ptr
        call    HW_GetLogdevToBoardPtr

        ; Search the mapping array looking for this board context
        mov     ebx,eax
        mov     ecx,dwBoardDevnode
        sub     eax,eax
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FreeFlat
        cmp     ecx,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        jne     @F
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset
        jmp     FreeFlat
@@:
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1

FreeFlat:
	mov	dx,ds
	sub	cx,cx
	or	eax,eax
	je	@F
        mov	ecx,ds:[eax].GNBOARDCX.dwFlatDataSelector
        mov     es,wNVTEXT32_Alias_In_NVTEXT16
        mov     es:[wFlatDataSel],cx
        mov     es,wNVTEXT16_Alias_In_NVTEXT16
        mov     es:[wFlatDataSel_In_NVTEXT16],cx
@@:
        mov	ds,cx
	push	eax
	mov	eax,edx
        call    GN_UnmapAndFreeSelector
        pop	eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_CreateBoardContext
;
; Purpose:      This routine initializes a GNBOARDCX structure.
;
;		This routine stablishes the wFlatDataSelector
;		in the code segments.
;
; Arguments:
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateBoardContext, PASCAL, FRAME, FAR16
PARMD   dwThisLogDeviceHandle
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi
        sub     esi,esi

        ; Allocate memory for the GNBOARDCX
        pushd   SIZE GNBOARDCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

	; We need a flat data selector that everyone can use
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,-1
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt

        ; Put the flat selector in both code segments
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[wFlatDataSel],ax
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[wFlatDataSel_In_NVTEXT16],ax
        mov	ds,ax
        mov	ds:[esi].GNBOARDCX.dwFlatDataSelector,eax

        ; we are initting. Cleared at end of first modeset.
        mov     ds:[esi].GNBOARDCX.dwInitting,1

        ; Init this to 0
        mov     ds:[esi].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,0

        ; DirectX is not active right now
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,0

        ; Crete a HW board context
        push    dwThisLogDeviceHandle
        call    HW_CreateBoardContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNBOARDCX.pHWBoardCX,eax

        ; Ask RM about free offscreen space on this board
        push    eax
        call    HW_GetLargestOffscreenBlock
        mov     ds:[esi].GNBOARDCX.dwMemorySizeForValidateMode,eax

	; Create a heap
        mov     eax,MAX_OFFSCREEN_BITMAPS
        call    GN_HeapCreate
        mov     ds:[esi].GNBOARDCX.dwOffscreenHeap,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        or	eax,eax
        je	DoneIt
        and     ds:[esi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_HEAP_UNAVAILABLE

        push    esi
        call    GN_GetNumCRTCs
        mov     ds:[esi].GNBOARDCX.dwNumCrtcsOnBoard,eax

        ; We want the board path into the registry.
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo
        mov     ecx,sDispInfo.diDevNodeHandle
        mov     ds:[esi].GNBOARDCX.dwDeviceNodeHandle,ecx

        ; Build a 16:16 ptr to the display path. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNBOARDCX.szLocalDisplayBasePath
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,eax

        ; Fill in the actual path to our board registry stuff
        push    ds:[esi].GNBOARDCX.dwDeviceNodeHandle
        mov     ax,ds
        push    eax
        lea     ecx,[esi].GNBOARDCX.szLocalDisplayBasePath
        push    ecx
        sub     eax,eax
        mov     ax,SEG szDisplayDeviceName
        push    eax
        mov     ax,OFFSET szDisplayDeviceName
        movzx   eax,ax
        push    eax
        call    GN_GetDeviceLocalBasePath

        ; Init offset to bitmap info
        lea     eax,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,eax

        ; Clear/Reset the offscreen bitmap manager.
        push    esi
        call    GN_ClearOffscreenBitmapCache

        call    HW_GetLogdevToBoardPtr

        ; Search the mapping array looking for an empty slot
        ; and save off the GNBOARDCX there.
        mov     ebx,eax
        mov     ecx,ds:[esi].GNBOARDCX.dwDeviceNodeHandle
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FoundIt
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1
FoundIt:
        mov     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,ecx
        mov     ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset,esi

        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyBoardContext can clean up partial inits
        push    esi
        call    GN_DestroyBoardContext
        sub     eax,eax

ExitIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyBoardContext
;
; Purpose:      This routine destroys a GNBOARDCX structure.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds                      Selector for the board Context data
;               pGNBoardCXOffset        Offset to the board context data
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyBoardContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNBoardCXOffset
        or      esi,esi
        je      DoneIt

        ; If the DeviceNodeHandle is 0, then we didn't get far enough
        ; in the init to add an entry to the LOGDEVTOBOARD structure.
        cmp     ds:[esi].GNBOARDCX.dwDeviceNodeHandle,0
        je      NextThing

        ; Search the mapping array looking for this GNBOARDCX.
        call    HW_GetLogdevToBoardPtr
        mov     ebx,eax
        mov     ecx,ds:[esi].GNBOARDCX.dwDeviceNodeHandle
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      NextThing
        cmp     ecx,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        je      FoundIt
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1

FoundIt:
        ; Find the end of the array
        mov     edx,ebx
Back2:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FoundEnd
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back2

FoundEnd:
        ; Copy the last entry in the array down into the entry we
        ; are removing. Then zero out the final entry
        sub     ebx,SIZE LOGDEVTOBOARD
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset
        mov     ds:[edx].LOGDEVTOBOARD.dwGNBoardCXOffset,eax
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        mov     ds:[edx].LOGDEVTOBOARD.dwBoardDevnodeHandle,eax
        sub     eax,eax
        mov     ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset,eax
        mov     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,eax

NextThing:
        ; Free up the 16:16 base path ptr if need be
        cmp     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,0
        je      @f
        mov     eax,ds:[esi].GNBOARDCX.lpLocalDisplayBasePath
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,0
@@:
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        or	eax,eax
        je	@F
        call    GN_HeapDestroy
        mov     ds:[esi].GNBOARDCX.dwOffscreenHeap,0
@@:
        cmp     ds:[esi].GNBOARDCX.pHWBoardCX,0
        je      @F
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_DestroyBoardContext
        mov     ds:[esi].GNBOARDCX.pHWBoardCX,0
@@:

	; The following may have been allocated in the
	; SHARED MEMORY escapes. We need to free the
	; memory blocks if so.
	sub	ecx,ecx
LoopSM:
	mov	eax,ds:[esi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
	or	eax,eax
	je	@F
	mov	ds:[esi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
	PUSHR	ecx
	shr	eax,10H
	call	GN_MemoryFree
	POPR	ecx
@@:	inc	ecx
	cmp	ecx,MAX_SHARED_MEM_BLOCKS
	jc	LoopSM

	; Free the flat data selector
	mov	eax,ds:[esi].GNBOARDCX.dwFlatDataSelector
	or	eax,eax
	je	@F

	; To prevent the system chash we have to change DS
	; because it points to the selector we are going free.
	sub	ebx,ebx
	mov	ds,bx
	call	GN_UnmapAndFreeSelector

@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_AttachLogicalDeviceToBoard
;
; Purpose:      This routine attaches a logical device to a given
;               board by placing the logical device into the array
;               of GNLOGDEVCXs in the GNBOARDCX structure.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax                     0 failure
;                                       non-0 success
;                                       In this case, ecx is the
;                                       0 based instance number
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AttachLogicalDeviceToBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        sub     edx,edx
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B

        ; UhOh ... What is wrong here? This shouldn't happen.
        sub     eax,eax
        jmp     DoneIt
Found:
        mov     ecx,pGNLogdevCXOffset
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],ecx
        inc     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
        mov     ecx,eax
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ReattachLogicalDeviceToBoard
;
; Purpose:      This routine searches for the logical device / board
;               combination and then updates the GNBOARDCXs knowledge
;               of what GNLOGDEVCXs are attached to it.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffsetOld    GNLOGDEVCX ptr
;               pGNLogdevCXOffsetNew    GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ReattachLogicalDeviceToBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffsetOld
PARMD   pGNLogdevCXOffsetNew
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     edx,pGNLogdevCXOffsetOld
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B

        ; UhOh ... What is wrong here? This shouldn't happen.
        ; Cross your fingers and return slot 1 ....
        mov     eax,1
Found:
        mov     ecx,pGNLogdevCXOffsetNew
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_DetachLogicalDeviceFromBoard
;
; Purpose:      This routine detaches a logical device from a
;               given board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     Number of logical devices left attached to
;                       the board after this one detaches
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DetachLogicalDeviceFromBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     edx,pGNLogdevCXOffset
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B
        jmp     DoneIt

Found:
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],0

        ; One less logical device on this board
        dec     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
DoneIt:
        mov     eax,ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetPciDeviceID
;
; Purpose:      This routine gets the PCI Device ID of the board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetPciDeviceID, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetPciDeviceID
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetFrameBufferSelector
;
; Purpose:      This routine gets the frame buffer selector.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetFrameBufferSelector, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetFrameBufferSelector
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetNumCRTCs
;
; Purpose:      This routine gets the number of physical CRTCs
;               on the board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetNumCRTCs, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetNumCRTCs
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetBoardRegistryPath
;
; Purpose:      This routine gets the registry path to the board
;               info.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     ptr to a REGDATA structure describing registry path
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetBoardRegistryPath, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     eax,ds:[ebx].GNBOARDCX.lpLocalDisplayBasePath
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnblt.asm
;
; Purpose:      This file holds the Biblt display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IFDEF DEBUG
PUBLIC  bVramToVram, bMonoToVram, bColorToVram, bToSystem
bVramToVram     DB      0
bMonoToVram     DB      0
bColorToVram    DB      0
bToSystem       DB      0
ENDIF

;==============================================================================
;
; Function:     GENERIC_BitBlt
;
; Purpose:      This function is the BitBlt display driver entry point.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BitBlt, PASCAL, FRAME, FAR16
BITBLT_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        ; Filter out old style destinations
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev
        movzx   edi,byte ptr [dwRop3 + 2]
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        cmp     gs:[esi].DIBENGINE.deType,0
        je      GN_BitBltSystemMemoryDst

        ; New style dst with DIBENG Header. Filter based upon deFlags.
        movzx   eax,gs:[esi].DIBENGINE.deFlags
        movzx   edx,ds:[ebx].DIBENGINE.deFlags
        movzx   ecx,cs:Rop3Table[edi]
        test    ah,VRAM / 256
        jz      GN_BitBltSystemMemoryDst
        test    dh,PALETTE_XLAT / 256
        jnz     GN_BitBltPunt

        ; is it by BOARD or by CRTC? Depends how DOS works.
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitBltPunt

        ; Dispatch to routine based upon the rop
        cmp     cl,PAD
        je      GN_BitBltPatDstRop
        movsx   edx,byte ptr [dwRop3 + 2]
        cmp     cl,OND
        je      @f
        cmp     cl,PSD
        je      GN_BitBltPatUnknownSrcUnknownDstVram
        jmp     GN_BitBltSrcUnknownDstVram
@@:
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   ecx,byte ptr [dwRop3 + 2]
        jmp     HW_BitBltSolidPatDstRop                                         

GENERIC_BitBlt  ENDP


;==============================================================================
;
; Function:     BitBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of BitBlt. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_BitBltPunt
GN_BitBltPunt   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_BitBlt
        jmp     DIB_BitBlt
GN_BitBltPunt   ENDP

PUBLIC  GN_BitBltFail
GN_BitBltFail   PROC    NEAR
        sub     eax,eax
        jmp     GN_BitBltExit
GN_BitBltFail   ENDP

PUBLIC  GN_BitBltSuccess
GN_BitBltSuccess        PROC    NEAR
        mov     eax,1
GN_BitBltSuccess        ENDP

PUBLIC  GN_BitBltExit
GN_BitBltExit   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 20H
GN_BitBltExit   ENDP


;==============================================================================
;
; Function:     GN_BitBltPatDstRop
;
; Purpose:      This function does a bitblt when the rop involves a
;               pattern only or a pattern and a dst. This function
;               expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               ds              Context selector
;               gs:esi          ptr to lpDstDev
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltPatDstRop
GN_BitBltPatDstRop      PROC    NEAR

        mov     es,word ptr lpBrush+2
        movzx   edi,word ptr lpBrush+0
        mov     cl,byte ptr es:[edi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[edi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[edi].DIB_Brush8.dp8BrushBits
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        cmp     cl,BS_HOLLOW
        je      GN_BitBltSuccess
        jnc     @F
        test    al,COLORSOLID
        jz      HW_BitBltColorPatDstRop
        movzx   ecx,byte ptr [dwRop3 + 2]
        jmp     HW_BitBltSolidPatDstRop
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz      HW_BitBltColorPatDstRop
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     eax,fs:[edx].DRAWMODE.TextColor
        mov     ecx,fs:[edx].DRAWMODE.bkColor
        lea     edi,[edi].DIB_Brush8.dp8BrushMono
        jmp     HW_BitBltMonoPatDstRop
IsHatch:
        mov     eax,es:[edi].DIB_Brush8.dp8BgColor
        mov     ecx,es:[edi].DIB_Brush8.dp8FgColor
        lea     edi,[edi].DIB_Brush8.dp8BrushMask
        jmp     HW_BitBltMonoPatDstRop

GN_BitBltPatDstRop      ENDP


;==============================================================================
;
; Function:     GN_BitBltPatUnknownSrcUnknownDstVram
;
; Purpose:      This function does a bitblt when the rop involves a src
;               and a pattern and the dst is in Vram. This function
;               expects to be jumped to, not called.
;
;               This routine will call the hardware to set up the
;               pattern and then continue on as if it were just a
;               src,dst blt.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               ds              Context selector
;               ebx             GNLOGDEVCX ptr
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltPatUnknownSrcUnknownDstVram
GN_BitBltPatUnknownSrcUnknownDstVram    PROC    NEAR

        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        call    GN_PrepareBrush
        or      eax,eax
        jl      GN_BitBltFail
        je      GN_BitBltSuccess

        ; Reload the lpDstDev
        sub     esi,esi
        lgs     si,lpDstDev
        .errnz  $ - OFFSET GN_BitBltSrcUnknownDstVram

GN_BitBltPatUnknownSrcUnknownDstVram    ENDP



;==============================================================================
;
; Function:     GN_BitBltSrcUnknownDstVram
;
; Purpose:      This function does a bitblt when the rop involves a src
;               and the dst is in Vram. It may also involve a pattern
;               and the dst, but it doesn't have to. This function
;               expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltSrcUnknownDstVram
GN_BitBltSrcUnknownDstVram      PROC    NEAR

        ; Load a ptr to the source device
        mov     es,word ptr lpSrcDev+2
        movzx   edi,word ptr lpSrcDev+0

        ; First priority is to clip the source
        call    GN_BitBltClipSrc
        or      eax,eax
        je      GN_BitBltSuccess

        ; Dispatch the blt to the correct place
        sub     eax,eax
        mov     dwScansPerSeg,7FFFH
        movzx   ecx,es:[edi].DIBENGINE.deFlags
        cmp     ax,es:[edi].DIBENGINE.deType
        je      OldStyleSrc
        test    ch,VRAM / 256
        jnz     GN_BitBltSrcVramDstVram
        cmp     es:[edi].DIBENGINE.deBitsPixel,1
        jne     GN_BitBltSrcColorDstVram_1
        mov     eax,dword ptr es:[edi].DIBENGINE.deBits
        mov     bx,word ptr es:[edi].DIBENGINE.deBits+4
        mov     ecx,es:[edi].DIBENGINE.deDeltaScan
        mov     edx,7FFFH
        jmp     GN_BitBltSrcMonoDstVram_1

OldStyleSrc:
        cmp     es:[edi].BITMAP.bmBitsPixel,1
        jne     GN_BitBltPunt
        mov     edx,07FFFH
        cmp     ax,es:[edi].BITMAP.bmSegmentIndex
        je      @F
        movzx   ecx,es:[edi].BITMAP.bmScanSegment
        mov     dwScansPerSeg,ecx
        movzx   eax,wSrcY
        sub     edx,edx
        div     cx
        sub     ecx,edx
        mov     edx,ecx
@@:
        movzx   ecx,es:[edi].BITMAP.bmWidthBytes
        movzx   eax,word ptr es:[edi].BITMAP.bmBits
        movzx   ebx,word ptr es:[edi].BITMAP.bmBits+2
        movzx   edi,es:[edi].BITMAP.bmFillBytes
        jmp     GN_BitBltSrcMonoDstVram_1

GN_BitBltSrcUnknownDstVram      ENDP


;==============================================================================
;
; Function:     GN_BitBltClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for BitBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es:edi  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC  GN_BitBltClipSrc
GN_BitBltClipSrc        PROC    NEAR

        movsx   eax,wSrcX
        movsx   ecx,wSrcY
        movzx   ebx,es:[edi].DIBENGINE.deWidth
        movzx   edx,es:[edi].DIBENGINE.deHeight
        or      eax,eax
        js      ClipLeft
cld1:   or      ecx,ecx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     eax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     eax,eax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     ecx,ecx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     eax,eax
        ret

GN_BitBltClipSrc        ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcVramDstVram
;
; Purpose:      This function does a bitblt when the rop involves a source,
;               the source is in VRAM, and the dst is in VRAM. The rop may
;               also involve the dst and a pattern, but it may not. This
;               routine calls the hardware specific routine
;               HW_BitBltSrcVramDstVram to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es:edi          lpSrcDev
;               gs:esi          lpDstDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltSrcVramDstVram
GN_BitBltSrcVramDstVram PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bVramToVram],0
        jne     GN_BitBltPunt
ENDIF
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpSrcDev
        push    lpBrush
        push    lpDrawMode
        push    dword ptr wDstY
        push    dword ptr wSrcY
        push    dword ptr wExtY
        push    dwRop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltPunt
        jmp     GN_BitBltFail

GN_BitBltSrcVramDstVram ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcMonoDstVram_1
;
; Purpose:      This function does a bitblt when a source is involved,
;               the source is a mono bitmap, and the dst is in VRAM. The
;               rop may also involve the dst and a pattern, but it may
;               not. This routine calls the generic routine
;               GN_BitBltSrcMonoDstVram_1 to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es              selector of lpSrcDev
;               gs:esi          selector of lpDstDev
;               ds              Context selector
;               dwScansPerSeg   scans per segment of the mono bitmap
;               edx             starting from and including the wSrcY
;                               coord, this is the number of scanlines
;                               in the mono bitmap before there is a
;                               segment crossing (when you need to
;                               adjust the src pointer to account for
;                               the fillbytes.)
;               edi             padding bytes at the end of each segment
;               bx              src selector points to src bits
;               eax             src offset points to src bits
;               ecx             pitch of src bitmap in bytes
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSrcMonoDstVram_1
GN_BitBltSrcMonoDstVram_1 PROC  NEAR

IFDEF DEBUG
        cmp     cs:[bMonoToVram],0
        jne     GN_BitBltPunt
ENDIF
        mov     dwSrcBitsOffset,eax

        ; Let the hardware specific code handle the transfer.
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        push    ebx                             ; src sel
        push    dwSrcBitsOffset                 ; offset to src bits
        push    ecx                             ; src pitch in bytes
        xor     ebx,ebx                         ; clear high word of EBX
        les     bx,lpDrawMode
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    es:[ebx].DRAWMODE.TextColor
        push    es:[ebx].DRAWMODE.bkColor
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        push    edx
        push    dwScansPerSeg
        push    edi                             ; fill bytes
        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSrcMonoDstVram_1 ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcColorDstVram_1
;
; Purpose:      This function does a bitblt when a source is involved,
;               the source is a color DIBENG bitmap, and the dst is in
;               VRAM. The rop may also involve the dst and a pattern,
;               but it may not. This routine calls the hardware specific
;               routine HW_BitBltSrcMonoDstVram to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               es:edi          lpSrcDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSrcColorDstVram_1
GN_BitBltSrcColorDstVram_1      PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bColorToVram],0
        jne     GN_BitBltPunt
ENDIF
        ; Let the vendor handle the whole thing
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        movzx   ecx,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        push    ecx
        push    gs:[esi].DIBENGINE.deDeltaScan
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        movzx   eax, word ptr es:[edi].DIBENGINE.deBits+4
        mov     ecx,dword ptr es:[edi].DIBENGINE.deBits+0
        push    eax
        push    ecx
        movzx   eax,es:[edi].DIBENGINE.deBitsPixel
        mov     ecx,es:[edi].DIBENGINE.deDeltaScan
        push    eax
        push    ecx
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        sub     eax,eax
        push    eax                     ; size color table entry in bytes
        push    eax                     ; num color table entries
        push    eax                     ; lpColorTable
        push    eax
        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSrcColorDstVram_1      ENDP


;==============================================================================
;
; Function:     GN_BitBltSystemMemoryDst
;
; Purpose:      This routine gets jumped to when either the lpDstDev
;               points to an old BITMAP header or when lpDstDev points
;               to a new style DIBENGINE header but the deFlags field
;               does not have the VRAM bit set. Both these scenarios
;               describe a bitmap that is in system memory. We may
;               wish to handle a blt where the dst is in system memory
;               if there is also a source located in video memory since
;               we can use hardware DMA to transfer back from VRAM.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;		ds:ebx		ptr GNLOGDEVCX which is also PDEVICE
;               gs:esi          lpDstDev
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSystemMemoryDst
GN_BitBltSystemMemoryDst        PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bToSystem],0
        jne     GN_BitBltPunt
ENDIF

        ; Make sure hardware is not busy
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitBltPunt

        ; Prepare some things that we need for testing
        movzx   ecx,cs:Rop3Table[edi]

        ; If the dst is a BITMAP hdr, then punt cases where dst is color.
        cmp     gs:[esi].DIBENGINE.deType,0
        movzx   eax,gs:[esi].BITMAP.bmBitsPixel
        jne     IsDib
        cmp     eax,1
        ja      GN_BitBltPunt
        jmp     @F
IsDib:
        ; Punt dsts that we cannot handle
        test    gs:[esi].DIBENGINE.deFlags,PALETTE_XLAT
        jnz     GN_BitBltPunt
@@:
        ; Punt rops not involving a src
        cmp     cl,SAD
        jc      GN_BitBltPunt

        ; Punt if source is in system memory too.
        xor     edi,edi                 ; clear high word of EDI
        les     di,lpSrcDev
        cmp     es:[edi].DIBENGINE.deType,0
        je      GN_BitBltPunt
        test    es:[edi].DIBENGINE.deFlags,VRAM
        jz      GN_BitBltPunt

        ; We must clip to the src rectangle
        call    GN_BitBltClipSrc
        or      eax,eax
        je      GN_BitBltSuccess

        ; Call the generic code to overlap DMAing and converting.
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        pushd   0

        ; Get the dst parameters -- depends upon bitmap header format
        cmp     gs:[esi].DIBENGINE.deType,0
        jne     NewT
        movzx   eax,word ptr gs:[esi].BITMAP.bmBits+2
        movzx   ecx,word ptr gs:[esi].BITMAP.bmBits+0
        movzx   edx,word ptr gs:[esi].BITMAP.bmWidthBytes
        push    eax
        push    ecx
        pushd   1
        push    edx
        jmp     @F

NewT:   movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        movzx   ecx,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        push    ecx
        push    gs:[esi].DIBENGINE.deDeltaScan
@@:
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        push    lpSrcDev
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        movzx   ecx,es:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        push    ecx
        push    es:[edi].DIBENGINE.deDeltaScan
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        sub     eax,eax
        push    eax
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSystemMemoryDst        ENDP


;==============================================================================
;
; Function:     GN_PrepareBrush
;
; Purpose:      This function figures out the type of brush and
;               call the hardware specific routine to load the
;               brush into the hardware.
;
; Arguments:
;               ds              Context selector
;               ebx             GNLOGDEVCX ptr
;               es:esi          lpBrush
;
; Returns:
;               eax             -1      Failure
;               eax             0       Brush was hollow
;                               1       Success
;
; Preserve:     ds
;==============================================================================
DECPROC GN_PrepareBrush, PASCAL, FRAME, NEAR
PARMD   lpDrawMode
OPENPROC
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        cmp     cl,BS_HOLLOW
        je      IsHollow
        PUSH    OFFSET ReSetPat
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      IsFail
        test    al,PATTERNMONO
        jz      HW_LoadColorPattern
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     ecx,fs:[edx].DRAWMODE.TextColor
        mov     edx,fs:[edx].DRAWMODE.bkColor
        lea     esi,[esi].DIB_Brush8.dp8BrushMono
        mov     eax,-1
        jmp     HW_LoadMonoPattern
IsHatch:
        mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
        lea     esi,[esi].DIB_Brush8.dp8BrushMask
        mov     eax,-1
        jmp     HW_LoadMonoPattern

IsHollow:
        sub     eax,eax
        jmp     DoneIt

IsFail:
        mov     eax,-1
        jmp     DoneIt

ReSetPat:
        mov     eax,1
DoneIt:
CLOSEPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUBLIC  Rop3Table
Rop3Table       LABEL   BYTE
DB      OND,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    OND,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    OND,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    OND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tri.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TRI.C                                                          *
*   NV4 Old Execute Buffer Style RenderPrimitive DDI routines.              *
*   NOTE: Uses indexed primitive rendering routines in NV4INDEX.C           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"


PFNRENDERPRIMITIVEOP    pfnRenderPrimitiveOperation[] =
{
    nvRenderNoOp,           // Op codes are 1 based, so 0 is a no op.
    nvRenderPoint,
    nvRenderLine,
    nvRenderTriangle,
    nvRenderNoOp,           // 4  - not supported.
    nvRenderNoOp,           // 5  - not supported.
    nvRenderNoOp,           // 6  - not supported.
    nvRenderNoOp,           // 7  - not supported.
    nvRenderNoOp,           // 8  - not supported.
    nvRenderNoOp,           // 9  - not supported.
    nvRenderNoOp,           // 10 - not supported.
    nvRenderNoOp,           // 11 - not supported.
    nvRenderNoOp,           // 12 - not supported.
    nvRenderNoOp,           // 13 - not supported.
    nvRenderNoOp            // 14 - not supported.
};

DWORD nvRenderNoOp
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderNoOp - Unhandled instruction opcode");
    return (DD_OK);
}

DWORD nvRenderTriangle
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Call the appropriate wrapper function.
     */
    switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
    {
        case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(dwPrimCount,(LPWORD)lpPrim,LEGACY_STRIDES,(LPBYTE)lpVertices);
#else
            fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
#endif
            break;
        case D3DFILL_WIREFRAME:
            nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
            break;
        case D3DFILL_POINT:
            nvIndexedPointTriangle(dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
            break;
    }
    return (DD_OK);
}

#ifndef WINNT
/*
 * Old style execute buffer entry point.
 */
DWORD __stdcall nvRenderPrimitive
(
    LPD3DHAL_RENDERPRIMITIVEDATA    prd
)
{
    LPD3DINSTRUCTION    lpIns;
    LPBYTE              lpData;
    DWORD               dwPrimCount;
    LPBYTE              lpPrim;
    LPD3DTLVERTEX       lpVertices;

#ifdef NV_NULL_DRIVER
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    /*
     * NOTES:
     *
     * This callback is invoked when a primitive is to be rendered.
     * All the data is known to be clipped.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvRenderPrimitive - hContext = %08lx", prd->dwhContext);
    if (!(pCurrentContext = (PNVD3DCONTEXT)prd->dwhContext))
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);
    if (!pDriverData->NvDevFlatDma)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Check z-visibility test.
     */
    if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        /*
         * If you don't implement Z visibility testing, just do this.
         */
        prd->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        prd->ddrval    = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            prd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
    NV_AA_SEMANTICS_CHECK(pCurrentContext);
    if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
#endif  // CACHE_FREECOUNT

    /*
     * If the context has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * Prepare to parse the instructions.
     */
    prd->ddrval = DD_OK;
    lpData      = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    lpIns       = &prd->diInstruction;
    dwPrimCount = lpIns->wCount;
    lpPrim      = (LPBYTE)(lpData + prd->dwOffset);
    lpVertices  = (LPD3DTLVERTEX)((LPBYTE)((LPDDRAWI_DDRAWSURFACE_INT)prd->lpTLBuf)->lpLcl->lpGbl->fpVidMem + prd->dwTLOffset);
    pfnRenderPrimitiveOperation[lpIns->bOpcode](dwPrimCount, lpPrim, lpVertices);

    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);

    /*
     * The DEBUG driver has a flag that can be set to force a flush after every triangle
     * rendering call.  This is helpful for debugging when dbgFrontRender is enabled.
     */
    dbgFlushDmaBuffers(pCurrentContext);

    /*
     * Tell DDRAW that thee global clip state has changed.
     * Probably don't need this, but I'd rather be safe.
     */
    pDriverData->ddClipUpdate = TRUE;
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

    /*
     * Show that 3D rendering has occurred.
     */
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
#endif  NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBOARD2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnboard2.asm
;
; Purpose:      This file holds run-time routines for GNBOARDCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_BoardMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BoardMessage, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi
        mov     esi,pGNBoardCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     ChainIt

PreMS:
        ; Free up the memory used for offscreen allocations.
        ; This will appropriately flush all bitmaps to system
        ; memory as required.
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

PostMS:
        ; Alloc the memory used for offscreen allocations
        ; if DirectX is not running.
        cmp     ds:[esi].GNBOARDCX.dwDirectXActive,0
        jne     @F
        push    pGNBoardCXOffset
        pushd   1
        call    GN_ControlOffscreenAllocations
@@:
        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNBOARDCX.dwInitting,0
        jmp     ChainIt

DXEnum:
        jmp     ChainIt

DXOn:
        ; DirectX is coming up.
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,1

        ; Flush all offscreen bitmaps
        ; Free up the memory used for offscreen allocations.
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

DXOff:
        ; DirectX is going away.
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,0

        ; Alloc the memory used for offscreen allocations
        push    pGNBoardCXOffset
        pushd   1
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

DosOff:
PowerOn:
        ; Clear H/W busy for ALL logical devices.
        mov     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX
        mov     ecx,ds:[ebx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX

@@:
        mov     eax,ds:[ebx]
        or      eax,eax
        je      NextLogdevOff

        ; Enable HW access to device
        mov     ds:[eax].GNLOGDEVCX.dwHardwareBusy,0

NextLogdevOff:
        add     ebx,4
        loop    @B
        jmp     ChainIt

DosOn:
PowerOff:
        ; Flush all offscreen bitmaps
        push    pGNBoardCXOffset
        call    GN_ClearOffscreenBitmapCache

        ; Set H/W busy for ALL logical devices.
        mov     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX
        mov     ecx,ds:[ebx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX

@@:
        mov     eax,ds:[ebx]
        or      eax,eax
        je      NextLogdevOn

        ; Disable HW access to device
        mov     ds:[eax].GNLOGDEVCX.dwHardwareBusy,1

NextLogdevOn:
        add     ebx,4
        loop    @B
        jmp     ChainIt

DrvDis:
        ; Free up the memory used for offscreen allocations.
        ; ONLY if this is the primary driver. Any secondary
        ; disabling should not free the memory.
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      FlushOffscreen
        test    dwThisLogicalDeviceHandle_In_NVTEXT16,03H
        jnz     ChainIt

FlushOffscreen:
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

ChainIt:
        ; Call the hardware to inform it of the message
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_BoardMessage
        jmp     DoneIt

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_IsDevDataUniqueOnBoard
;
; Purpose:      This routine runs through all the CRTCCXs on the board
;               and sees if anyone else is using the same device and number
;               as the CRTCCX passed in. For example, you can call
;               this routine if you want to know, "is someone else
;               using CRT4?" or "is someone else using DFP6?" or
;               "TV2", etc.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNCrtcCXOffset         GNCRTCCX
;
; Returns:
;               eax                     TRUE no one else is using
;                                       the device and number in
;                                       the CRTCCX passed in
;                                       FALSE, someone is using it
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_IsDevDataUniqueOnBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNCrtcCXOffset
LOCALD  dwDesiredDevData
OPENPROC
        PUSHR   esi,edi
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dwDesiredDevData,eax

        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Is this the CRTCCX that we are comparing against?
        cmp     esi,pGNCrtcCXOffset
        je      NextCrtc

        ; No, so see if this enumerated CRTCCX's DevData is
        ; the same as the DevData in the passed in CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        cmp     ax,word ptr dwDesiredDevData
        POPR    eax,ebx,ecx,edx
        je      NotUnique

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

Unique:
        mov     eax,1
        jmp     DoneIt

NotUnique:
        sub     eax,eax
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindFirstCloneDevice
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board looking to see if any of them have a clone device.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               ebx                     GNLOGDEVCX ptr if one is found
;                                       that has a clone device.
;                                       Else 0
;               eax                     Which phys device number it is
;                                       if ebx is not 0.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindFirstCloneDevice, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
LOCALD  dwDesiredDevData
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev

        ; Start with the first clone
        mov     edx,1

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Ah! We found a clone device. Let's return it
        mov     ebx,ecx
        mov     eax,edx
        jmp     DoneIt

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; Didn't find one
        sub     ebx,ebx
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SendDevicesRemapMsgToAllLogDevs
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board and sends a MSG_DEVICESREMAPPED to each one.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SendDevicesRemapMsgToAllLogDevs, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     edi,edi

LoopLogdev:
        mov     eax,ds:[esi].GNBOARDCX.pGNLogdevCX[edi * 4]
        or      eax,eax
        je      NextLogdev

        push    eax
        pushd   MSG_DEVICESREMAPPED
        push    eax
        push    ds:[eax].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     edi
        cmp     edi,ds:[esi].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindLogdevWaitingToClone
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board looking to see if any of them would like to
;               have a clone device. (Generally this is the result
;               of a clone device having been "Stolen" away from them
;               if someone switches to multi-mon on the fly.)
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               eax                     GNLOGDEVCX ptr if one is found
;                                       that wants a clone device.
;                                       Else 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindLogdevWaitingToClone, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ecx,ecx

LoopLogdev:
        mov     eax,ds:[ebx].GNBOARDCX.pGNLogdevCX[ecx * 4]
        or      eax,eax
        je      NextLogdev

        cmp     ds:[eax].GNLOGDEVCX.dwNumClonesAwaited,0
        jne     DoneIt

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ecx
        cmp     ecx,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; Didn't find one
        sub     eax,eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindUnusedDevice
;
; Purpose:      This routine finds a device (and number -- like CRT6 or
;               DFP2), that is connected to the system and is not in use
;               by any other CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwUnusedIndex           0, 1, 2, 3, etc
;                                       This tells which unused device
;                                       to find. The zeroth, first
;                                       second, etc. They are always
;                                       ordered as CRTS, DFPS, TVS
; Returns:
;               eax                     DEVDATA describing device
;                                       0x0FFFFFFFF if couldn't find one
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindUnusedDevice, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwUnusedIndex
LOCALD  dwAllAttachedDevices
LOCALD  dwCurrentIndex
OPENPROC
        PUSHR   esi,edi

        ; First get a list of all the devices that exist and
        ; are attached.
        mov     eax,pGNBoardCXOffset
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_GetAllAttachedDevices

        ; If there is no display device present, and this is the primary
        ; driver, then we need to drive the CRT even though it is not present.
        ; However, we only want to do this if this is not a mobile system
        ; since a mobile system is guaranteed to have an LCD, and its absence
        ; along with the absence of any other display device is extremely
        ; bad news.
        cmp     eax,0
        jne     DeviceMapCont
        
        ; Only force a device which is not present to be treated as present
        ; if we are the primary driver!
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     DeviceMapCont

        ; This routine returns whether or not this is mobile behavior.
        mov     eax,pGNBoardCXOffset
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        cmp     ax,0
        jne     ReturnNoDevice
        mov     eax,1                   ; return CRT is attached
        jmp     DeviceMapCont
        
ReturnNoDevice:
        mov     eax,0
        
DeviceMapCont:
        mov     dwAllAttachedDevices,eax

        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset
        mov     dwNumDevices,0

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Get the dev data for this CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData

        ; watch out for the "no device" case
        cmp     eax,-1
        je      NoDevice

        ; Form a mask out of it
        mov     ecx,eax
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl

        ; Remove this bit from the list of attached devices
IFDEF DEBUG
        ; unless someone has hot-unplugged a device, the bit
        ; we are touching should currently be ON since it is
        ; the device that some CRTCCX is actively using
        test    eax,dwAllAttachedDevices
        jnz     @F
        int     3
@@:
ENDIF
        not     eax
        and     dwAllAttachedDevices,eax

NoDevice:
        POPR    eax,ebx,ecx,edx

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; If dwAllAttachedDevices if not 0, then there is an
        ; available device. If it is 0, then there isn't a device.
        mov     ecx,dwAllAttachedDevices
        or      ecx,ecx
        je      FailIt

        ; First look at CRTS
        mov     ebx,-1

        mov     eax,DEVTYPE_CRT + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next1
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next1:  shr     cl,1
        cmp     ah,8
        jc      @B

        ; Nope. Try DFPS
        shr     ecx,8
        mov     eax,DEVTYPE_DFP + 0FF00H
@@:     inc     ah
        test    ch,1
        jz      Next2
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next2:  shr     ch,1
        cmp     ah,8
        jc      @B

        ; Lasthope is TVS
        mov     eax,DEVTYPE_TV + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next3
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next3:  shr     cl,1
        cmp     ah,8
        jc      @B

FailIt:
        mov     eax,-1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetAllDeviceData
;
; Purpose:      This routine loads up three arrays. One will hold all the
;               devices/numbers needed by all CRTCCXs, the other will
;               hold the ptrs to the GNCRTCCXs and the last will hold
;               the ptrs to the corresponding HWCRTCCXs which want to
;               display on the corresponding device and device number
;               in the first array.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               lpDevData               DEVDATA array ptr
;               lpHWCrtcCX              ULONG array ptr (for HW Crtc CXs)
;               Maximum array length
;
; Returns:
;               eax                     number of devices found
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetAllDeviceData, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   lpDevData
PARMD   lpGNCrtcCX
PARMD   lpHWCrtcCX
PARMD   dwMaxLen
LOCALD  lpDevData_Inc
LOCALD  lpGNCrtcCX_Inc
LOCALD  lpHWCrtcCX_Inc
LOCALD  dwNumDevices
OPENPROC
        PUSHR   esi,edi
        mov     eax,lpDevData
        mov     lpDevData_Inc,eax
        mov     eax,lpHWCrtcCX
        mov     lpHWCrtcCX_Inc,eax
        mov     eax,lpGNCrtcCX
        mov     lpGNCrtcCX_Inc,eax
        mov     eax,pGNBoardCXOffset
        mov     dwNumDevices,0

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Get the dev data for this CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        les     di,lpDevData_Inc
        mov     es:[di],eax
        add     lpDevData_Inc,4

        ; Put the corresponding HW Crtc CX ptr in the other array
        les     di,lpGNCrtcCX_Inc
        mov     es:[di],esi
        add     lpGNCrtcCX_Inc,4
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        les     di,lpHWCrtcCX_Inc
        mov     es:[di],eax
        add     lpHWCrtcCX_Inc,4
        POPR    eax,ebx,ecx,edx

        inc     dwNumDevices

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; return the number of devices
        mov     eax,dwNumDevices
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDevDataMask
;
; Purpose:      This routine runs through all the CRTCCX in all
;               GNLOGDEVCXs on this board with the exception of
;               the CRTCCX passed in and forms a mask out of the
;               DEVDATAs.  The mask is as follows. The low byte
;               as a 1 in each bit where there is a CRTC in use
;               (i.e. bit 0 is set if some CRTCCX was using CRTC0, etc.)
;               Now, the next byte is the same thing for TVs and
;               the high byte is the same thing for DFPs.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:
;               eax                     device mask described in purpose
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDevDataMask, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset
        sub     edi,edi

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc
        cmp     esi,pGNCrtcCXOffset
        je      NextCrtc

        ; Get the dev data for this CRTCCX and OR it into the mask
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        shl     al,3
        add     al,ah
        mov     cl,al
        mov     ebx,1
        shl     ebx,cl
        or      edi,ebx
        POPR    eax,ebx,ecx,edx

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; return the mask
        mov     eax,edi
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP15.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp15.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 15bpp dst bitmap.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To15WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 15bpp value is pulled out of the table and
;               used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To15WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        movzx   eax,byte ptr ds:[esi]
        inc     esi
        and     eax,0FH
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     ax,fs:[ebx][eax * 2]
        mov     cx,fs:[ebx][ecx * 2]
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        movzx   eax,byte ptr ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer4To15DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 15bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To15DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
        and     ecx,00FH
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To15WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To15WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        shr     eax,10H
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     cx,fs:[ebx][eax * 2]
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To15DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 15bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To15DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,2
        jl      CheckLastPixels

ChunksOf2:
        movzx   eax,word ptr ds:[esi]
        add     esi,4
        movzx   ecx,al
        movzx   edx,ah
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        shr     ecx,3
        shr     edx,3
        ror     ecx,5
        ror     edx,5
        shr     cx,3
        shr     dx,3
        ror     ecx,5
        ror     edx,5
        shr     cx,3
        shr     dx,3
        rol     ecx,10
        rol     edx,10
        mov     es:[edi+0],cx
        mov     es:[edi+2],dx
        add     edi,4
        sub     dwTempExtX,2
        cmp     dwTempExtX,2
        jge     ChunksOf2

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,fs:[ebx][eax * 4]
        shr     ecx,3
        ror     ecx,5
        shr     cx,3
        ror     ecx,5
        shr     cx,3
        rol     ecx,10
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 15bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Let's compute the optimal inner loop. Basically, there
        ; is either 0 or 1 word to get dword aligned (a left edge),
        ; then 0 or more dwords (middle), and finally there may be
        ; an extra word on the end (right edge).
        mov     edx,dwExtX
        add     edx,edx
        mov     eax,esi
        and     eax,2
        sub     edx,eax
        mov     ecx,edx
        shr     eax,1
        cmp     edx,3
        adc     eax,eax
        and     ecx,2
        cmp     ecx,1
        adc     eax,eax
        xor     eax,3
        shr     edx,2
        jmp     NEAR PTR cs:JmpTable[eax * 4]

JmpTable:
DD      OFFSET L0_M0_R0,OFFSET L0_M0_R1,OFFSET L0_MX_R0,OFFSET L0_MX_R1
DD      OFFSET L1_M0_R0,OFFSET L1_M0_R1,OFFSET L1_MX_R0,OFFSET L1_MX_R1

L1_MX_R1:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R1
        jmp     Done

L1_MX_R0:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R0
        jmp     Done

L1_M0_R1:
        movs    dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_M0_R1
        jmp     Done

L0_MX_R1:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R1
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

L1_M0_R0:
L0_M0_R1:
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_M0_R1

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 16bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     ax,ds:[esi+0]
        mov     cx,ds:[esi+2]
        add     esi,4
        ror     eax,5
        ror     ecx,5
        shr     ax,1
        shr     cx,1
        rol     eax,5
        rol     ecx,5
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     ax,ds:[esi]
        add     esi,2
        ror     eax,5
        shr     ax,1
        rol     eax,5
        mov     es:[edi],ax
        add     edi,2

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 24bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     cl,ds:[esi+5]
        shl     ecx,10H
        mov     cx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

;==============================================================================
;
; Function:     GN_Xfer32To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 32bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     eax,ds:[esi]
        add     esi,4
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCLRBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnclrblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a color source located in system memory. There may
;               also be a pattern involved but maybe not. The code is
;               generic in terms of not touching hardware, but it does
;               make assumptions about hardware capability and to some
;               extent programming order. These should all be fine for
;               Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwTableBppToXlatFunc
dwTableBppToXlatFunc    LABEL   DWORD
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0                               ; GN_Xfer1To8 - use mono transfer
DD      OFFSET  GN_Xfer4To8WordXlat
DD      OFFSET  GN_Xfer8To8NoXlat
DD      OFFSET  GN_Xfer15To8
DD      OFFSET  GN_Xfer16To8
DD      OFFSET  GN_Xfer24To8
DD      OFFSET  GN_Xfer32To8
DD      0;                              ; GN_Xfer1To15 - use mono transfer
DD      OFFSET  GN_Xfer4To15DwordXlat
DD      OFFSET  GN_Xfer8To15DwordXlat
DD      OFFSET  GN_Xfer15To15
DD      OFFSET  GN_Xfer16To15
DD      OFFSET  GN_Xfer24To15
DD      OFFSET  GN_Xfer32To15
DD      0                               ; GN_Xfer1To16 - use mono transfer
DD      OFFSET  GN_Xfer4To16DwordXlat
DD      OFFSET  GN_Xfer8To16DwordXlat
DD      OFFSET  GN_Xfer15To16
DD      OFFSET  GN_Xfer16To16
DD      OFFSET  GN_Xfer24To16
DD      OFFSET  GN_Xfer32To16
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0                               ; GN_Xfer1To32 - use mono transfer
DD      OFFSET  GN_Xfer4To32
DD      OFFSET  GN_Xfer8To32
DD      OFFSET  GN_Xfer15To32
DD      OFFSET  GN_Xfer16To32
DD      OFFSET  GN_Xfer24To32
DD      OFFSET  GN_Xfer32To32

PUBLIC  bTableBppToIndex
bTableBppToIndex        LABEL   BYTE
DB      08H,    00H,    08H,    08H,    01H,    08H,    08H,    08H
DB      02H,    08H,    08H,    08H,    08H,    08H,    08H,    03H
DB      04H,    08H,    08H,    08H,    08H,    08H,    08H,    08H
DB      05H,    08H,    08H,    08H,    08H,    08H,    08H,    08H
DB      06H

;==============================================================================
;
; Function:     GN_BitBltSrcColorDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be. The color depth of the src and
;               dst do not have to agree. Hence there is some sort of
;               pixel depth translation going on. The general strategy
;               implemented in this routine is:
;
;               1) Compute all the neccessary data
;
;               2) Call the HW_BeginSrcColorDstVram routine to set up
;                  the chip to expect to receive dwExtX * dwExtY pixels
;                  in the Destination Pixel Depth and place them
;                  in the rectangle whose upper left corner is at
;                  dwDstLeft,dwDstTop. HW_BeginSrcColorDstVram will
;                  also set the rop, base address, set up the pattern, etc.
;
;               3) GN_BitBltSrcColorDstVram calls the routine
;                  HW_BlockSrcColorDstVram to wait for enough space
;                  in the hardware buffer.
;
;               4) GN_BitBltSrcColorDstVram calls an inner loop routine
;                  which reads src pixels, translates them to dst space
;                  and stores them in the hardware. The inner loop routine
;                  can do partial scanlines or an integral number of scans.
;
;               5) Steps 3 and 4 are repeated until the entire bitmap has
;                  been transferred.
;
;               6) HW_EndSrcColorDstVram is called to allow the hardware
;                  specific code to clean up anything it needs to.
;
; Arguments:
;               ds              Context Selector
;               pNotUsed        Don't use this
;               dwDstBitsSel    Selector for the dst bits
;               dwDstBitsOffset Offset to the dst bits
;               dwDstBpp        bits per pixel of the dst bitmap
;               dwDstPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcBpp        Bits Per Pixel in the src image
;                               This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcTop        top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brhs and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate pattern 0 bits, and
;                               DRAWMODE.bkColor specifies the color to
;                               which to translate pattern 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               dwSizeColorTableEntry  bytes per entry in the color table
;               dwColorTableEntries  number of entries in the color table
;               lpColorTable    ptr to a color table. This ptr will be
;                               NULL if no color table is necessary.
;               pfnCopyXlatArg  If this argument is not NULL then it is
;                               the correct inner loop to use. If it is
;                               NULL, then the correct inner loop needs
;                               to be computed from the pixel depths of
;                               the src and dst, and the color table.
;
;       There will be a color table if:
;
;       1) The src is 4bpp. If the dst is 8bpp, then each entry will be
;          2 bytes. Only the low byte is used and is the remapped dst
;          color. If the dst is any other color depth besides 8bpp, then
;          each entry is 4 bytes -- a 32bpp logical color. These entries
;          will need to be mapped to the correct dst color depth.
;
;       2) the src is 8bpp and the dst is not 8bpp. Each entry is is
;          4 bytes -- a 32bpp logical color. These entries will need
;          to be mapped to the correct dst color depth.
;
;       There may be a color table if the src is 8bpp and the dst is
;       8bpp, but there also may not. If there is a color table then
;       each entry is 2 bytes in length. Only the low byte is used and
;       is the remapped dst color.
;
;       In all other cases, there is no color table. In some cases you
;       don't need one. i.e. if you are going from 15bpp->15bpp no
;       remapping is necessary -- just copy the source to the dst. On
;       the other hand if you are going from 24bpp->15bpp, there is no
;       color table either, but you need to convert each 24bit pixel to
;       a 15bit pixel. You MUST do these conversions in a manner identical
;       to the way the DIBENG does the conversions. If you aren't familiar
;       with the various algorithms the DIBENG uses for converting colors,
;       ask someone who is. They are not necessarily what you think. i.e.
;       15->24 does not just expand each 5bit color to an 8bit color by
;       tacking three 0 bits on the low end. There is a pseudo rounding
;       algorithm that is used.
;
; Returns:      eax     0       The routine will be punted to software
;                       else    the return code to GDI
;
;       Do not trash ds,esi,edi
;
;==============================================================================
DECPROC GN_BitBltSrcColorDstVram, PASCAL, NOFRAME, NEAR
;PARMD   pNotUsed
;PARMD   dwDstBitsSel
;PARMD   dwDstBitsOffset
;PARMD   dwDstBpp
;PARMD   dwDstPitch
;PARMD   dwDstLeft
;PARMD   dwDstTop
;PARMD   dwSrcBitsSel
;PARMD   dwSrcBitsOffset
;PARMD   dwSrcBpp
;PARMD   dwSrcPitch
;PARMD   dwSrcLeft
;PARMD   dwSrcTop
;PARMD   dwExtX
;PARMD   dwExtY
;PARMD   dwRop3
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   dwSizeColorTableEntry
;PARMD   dwColorTableEntries
;PARMD   lpColorTable
;PARMD   pfnCopyXlatArg
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    ebx
        push    eax
        jmp	GN_StretchBltSrcColorDstVram
CLOSEPROC

;=============================================================
DECPROC GN_StretchBltSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pNotUsed
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwSizeColorTableEntry
PARMD   dwColorTableEntries
PARMD   lpColorTable
PARMD   pfnCopyXlatArg
PARMD   dwExtDstX
PARMD   dwExtDstY
PARMD   lpClipRect

; These are needed by the generic code
LOCALD  pfnCopyXlat
LOCALD  dwDstBytesPerPixel
LOCALD  dwDstWrapWidth
LOCALD  dwAlignedExtXInPixels
LOCALD  dwAlignedDstExtXInBytes
LOCALD  dwSrcStart
LOCALD  dwSrcWrapWidth
LOCALD  dwMaxTransferSizeInBytes
LOCALD  dwScansPerBlock
LOCALD  dwBytesPerBlock
LOCALD  dwPixelsPerBlock
LOCALD  lpFinalColorTable
LOCALD  pHWBoardCXOffset
LOCALD  dwCXSel
LOCALD  dwScale
LOCALD	pfnHWBlockProc
LOCALS  FinalColorTable,400H
OPENPROC
        PUSHR   ds,esi,edi

        mov     dwCXSel,ds
	mov	eax,dwExtDstX
	or	eax,dwExtDstY
	mov	dwScale,eax

	mov	eax,HW_BlockSrcColorDstVram
	jz	@F
	mov	eax,HW_BlockStretchSrcColorDstVram
@@:
	mov	pfnHWBlockProc,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Determine the inner loop copy/xlat routine

        ; If the caller supplied the correct copy routine, we are done
        mov     eax,pfnCopyXlatArg
        mov     pfnCopyXlat,eax
        or      eax,eax
        jne     DoneCT

        ; Figure out the correct copy/xlat routine from the pixel depth
        ; of the src and the dst.
        mov     ebx,dwDstBpp
        mov     edx,dwSrcBpp
        movzx   ebx,cs:bTableBppToIndex[ebx]
        movzx   edx,cs:bTableBppToIndex[edx]
        cmp     ebx,MAX_BPP_INDICES
        jge     DoneIt
        cmp     edx,MAX_BPP_INDICES
        jge     DoneIt
	imul	ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        mov     pfnCopyXlat,ecx

        ; The copy/xlat routine selected may not be quite correct. There
        ; are some special cases if a color table is involved.
        mov     eax,lpColorTable
        mov     lpFinalColorTable,eax
        or      eax,eax
        je      DoneCT

        ; If the copy/xlat routine is for 8->8, we need to know the size
        ; of a color table entry in order to get the correct routine.
        cmp     ecx,OFFSET GN_Xfer8To8NoXlat
        jne     @F
        mov     pfnCopyXlat,OFFSET GN_Xfer8To8ByteXlat
        cmp     dwSizeColorTableEntry,1
        je      DoneCT
        mov     pfnCopyXlat,OFFSET GN_Xfer8To8WordXlat
        jmp     DoneCT
@@:
        ; If the xlat is 4->15,16 or 8->15,16 and each color table entry
        ; is 32bits, then we may want to pre-convert the color table
        ; entries so we won't have to do a lookup from 4->32 (or 8->32)
        ; and then convert the 32 bit pixel down to 15 or 16. For a
        ; 4bpp source, we'll just say it is always worth pre-converting
        ; the table since there are at most 16 entries in the color table.
        ; For an 8bpp source, there may be 256 table entries and if we
        ; are only going to be processing a handful of pixels, converting
        ; the whole color table may be a waste. Check appropriately.
        cmp     dwSrcBpp,4
        je      S4
        cmp     dwSrcBpp,8
        jne     DoneCT
        mov     eax,dwExtX
        imul    eax,dwExtY
        cmp     eax,100H
        jc      DoneCT
        mov     ecx,403H
        mov     edx,OFFSET GN_Xfer8To15WordXlat
        cmp     dwDstBpp,15
        je      @F
        cmp     dwDstBpp,16
        jne     DoneCT
        mov     ecx,202H
        mov     edx,OFFSET GN_Xfer8To16WordXlat
        jmp     @F
S4:
        mov     ecx,403H
        mov     edx,OFFSET GN_Xfer4To15WordXlat
        cmp     dwDstBpp,15
        je      @F
        cmp     dwDstBpp,16
        jne     DoneCT
        mov     ecx,202H
        mov     edx,OFFSET GN_Xfer4To16WordXlat
@@:
        mov     pfnCopyXlat,edx
        sub     esi,esi
        lds     si,lpColorTable
        push    ss
        pop     es
        sub     edi,edi
        lea     di,FinalColorTable
        mov     edx,dwColorTableEntries
        mov     word ptr lpFinalColorTable+0,di
        mov     word ptr lpFinalColorTable+2,es
        call    GN_ConvertColorTableFrom32To16
DoneCT:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Compute the byte width of a dword aligned dst scan and also
        ; the number of dst pixels that woud fit in this aligned scan.
        mov     eax,dwExtX
        mov     edx,eax
        mov     ebx,dwDstBpp
        inc     ebx
        shr     ebx,3
        imul    eax,ebx
        mov     ecx,eax
        add     eax,3
        and     eax,NOT 3
        mov     dwAlignedDstExtXInBytes,eax
        sub     eax,ecx
        je      Skip
@@:     inc     edx
        sub     eax,ebx
        jne     @B
Skip:   mov     dwAlignedExtXInPixels,edx

        ; Compute src address and wrap width -- dlightly different for
        ; 4bpp vs. 8bpp and higher.
        mov     eax,dwSrcPitch
        mov     edx,dwSrcTop
        imul    edx,eax
        add     edx,dwSrcBitsOffset
        mov     ecx,dwSrcBpp
        mov     ebx,dwExtX
        cmp     ecx,4
        je      Is4
Is8orM:
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx
        sub     eax,ebx
        imul    ecx,dwSrcLeft
        add     edx,ecx
        jmp     @F
Is4:
        add     eax,eax
        add     edx,edx
        sub     eax,ebx
        add     edx,dwSrcLeft
        jmp     @F
@@:
        mov     dwSrcWrapWidth,eax
        mov     dwSrcStart,edx
DoneW:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Call the hardware specific routine to setup for the transfer
        mov     ds,dwCXSel
        mov     ebx,cs:[CSpGNLogicalDevice]
        mov     ecx,ds:[ebx].GNLOGDEVCX.pGNBoardCX


        mov     eax,ds:[ecx].GNBOARDCX.pHWBoardCX
        mov     pHWBoardCXOffset,eax

        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    dwDstBitsOffset
        push    dwDstPitch
        push    dwDstBpp
        push    dwDstLeft
        push    dwDstTop
	cmp	dwScale,0
	jne	StretchCase

        push    dwExtX
        push    dwExtY
        push    dwAlignedExtXInPixels
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
        call    HW_BeginSrcColorDstVram
	jmp	@F

StretchCase:
        push    dwExtDstX
        push    dwExtDstY
        push    dwExtX
        push    dwExtY
        push    dwAlignedExtXInPixels
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
	push	lpClipRect
        call    HW_BeginStretchSrcColorDstVram

@@:
        or      eax,eax
        je      DoneIt
        mov     dwDstWrapWidth,ebx
        mov     dwMaxTransferSizeInBytes,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcColorDstVram routine is called.
        ; The generic code has agreed not to touch es -- it is the
        ; hardware's selector for whatever purposes it may need.

        ; Now we can begin the inner loop. Ther are two different cases
        ; that can occur and we will handle them separately.
        ; 1) The number of bytes that are to be transferred for a single
        ;    scanline is larger than the most the hardware can accept
        ;    in one shot. Each scanline must be broken into multiple
        ;    pieces. This is most typically the FIFO based model.
        ; 2) At least one scanline, possibly many, can be sent as a
        ;    single transfer. This is the typical DMA scenario.
        push    OFFSET CRet
        cmp     ecx,dwAlignedDstExtXInBytes
        jge     GN_XferWholeColorScans
        jmp     GN_XferPartialColorScans
CRet:
        ; Let the hardware know we are done
        mov     esi,pHWBoardCXOffset
        call    HW_EndSrcColorDstVram
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     eax,1

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_XferWholeColorScans
;
; Purpose:      This function is called from GN_BitBltSrcColorDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcColorDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each
;                       pixel is put in the buffer and the wrapWidth
;                       can be added appropriately. These are the
;                       only changes allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeColorScans
GN_XferWholeColorScans  PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedDstExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedDstExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
        sub     ebx,ebx
        lfs     bx,lpFinalColorTable

LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ecx,dwScansPerBlock
        sub     dwExtY,ecx
        jge     @F
        add     ecx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedDstExtXInBytes
        imul    eax,ecx
@@:
        ; Get ready to call inner loop
        push    dwExtX
        push    ecx
        push    dwSrcWrapWidth
        push    dwDstWrapWidth

        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        push    esi
        mov     esi,pHWBoardCXOffset
        call    NEAR PTR pfnHWBlockProc
        pop     esi

        ; Call the inner loop to process a chunk of scans
        call    NEAR PTR pfnCopyXlat

        ; If there are more scans to do, go for it.
        cmp     dwExtY,0
        jg      LoopY
        ret

GN_XferWholeColorScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialColorScans
;
; Purpose:      This function is called from GN_BitBltSrcColorDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcColorDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each
;                       pixel is put in the buffer and the wrapWidth
;                       can be added appropriately. These are the
;                       only changes allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialColorScans
GN_XferPartialColorScans        PROC    NEAR

        ; We can't send a whole scanline in a single transfer so
        ; compute how many pixels we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        mov     ebx,dwDstBpp
        inc     ebx
        shr     ebx,3
        mov     dwDstBytesPerPixel,ebx
        div     ebx
        mov     dwPixelsPerBlock,eax
        imul    eax,ebx
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
        sub     ebx,ebx
        lfs     bx,lpFinalColorTable

LoopY:
        push    dwExtX
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ecx,dwPixelsPerBlock
        sub     dwExtX,ecx
        jge     @F
        add     ecx,dwExtX
        mov     dwExtX,0
        mov     eax,dwDstBytesPerPixel
        imul    eax,ecx
        add     eax,3
        and     eax, NOT 3
@@:
        ; Get ready to call inner loop
        push    ecx
        pushd   0                               ; Only partial scanlines
        push    dwSrcWrapWidth
        push    dwDstWrapWidth

        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        push    esi
        mov     esi,pHWBoardCXOffset
        call    NEAR PTR pfnHWBlockProc
        pop     esi

        ; Call the inner loop to process a chunk of scans
        call    NEAR PTR pfnCopyXlat

        ; Are there more pixels left on this scanline?
        cmp     dwExtX,0
        jne     LoopX
        pop     dwExtX

        ; Go to next scanline
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jg      LoopY
        ret

GN_XferPartialColorScans        ENDP


;==============================================================================
;
; Function:     GN_ConvertColorTableFrom32To16
;
; Purpose:      This function is called to convert a color table from
;               one with 32bpp color entries to one with 15bpp or 16bpp
;               color entries. The conversion code must be functionally
;               equivalent to the DIBENG.
;
; Arguments:
;               ds:esi  ptr to src color table with 32bpp entries
;               edx     number of entries in src color table
;               es:edi  ptr to dst color table with 15bpp entries
;               ecx     403H if should convert to 15bpp (5-5-5)
;                       202H if should convert to 16bpp (5-6-5)
;
; Returns:      The table has been converted.
;
; Preserve:     None
;==============================================================================
DECPROC GN_ConvertColorTableFrom32To16, PASCAL, NOFRAME, NEAR
OPENPROC
@@:
        mov     eax,ds:[esi]
        add     esi,4

        shld    ebx,eax,10H
        sub     bl,04
        cmc
        sbb     bh,bh
        and     bl,bh
        shl     bx,05

        mov     bl,ah
        sub     bl,ch
        cmc
        sbb     ah,ah
        and     bl,ah
        shr     bx,cl

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah

        shl     eax,18H
        shld    ebx,eax,05

        mov     es:[edi],bx
        add     edi,2
        dec     edx
        jne     @B
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCRTC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncrtc.asm
;
; Purpose:      This file holds init routines for GNCRTCCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include minivdd.inc
.listall

IF      (MAX_MODEOUT_SIZE LT (SIZE MODEOUT))
echo MAX_MODEOUT_SIZE less than size of MODEOUT structure
.err
ENDIF
IF      (MAX_DISPDATA_SIZE LT (SIZE DISPDATA))
echo MAX_DISPDATA_SIZE less than size of DISPDATA structure
.err
ENDIF
IF      (MAX_MODEINFO_SIZE LT SIZE MODEINFO)
echo MAX_MODEINFO_SIZE less than size of MODEINFO structure
.err
ENDIF

OPENSEG  _DATA, USE16, DATA
PUBLIC  szPowerUpSubkey
szPowerUpSubkey         DB      "PowerUpFlags",0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_CreateCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of GNCRTCCX structure.
;
; Arguments:
;               ds                      Selector for the Context data
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwIsBootCrtc            TRUE if this is the CRTC we
;                                       are booting windows on. In a
;                                       Clone situation, this is only
;                                       the first of the clone monitors
;                                       that are the boot set.
;
; Returns:      eax     0       failure
;                       else    Success and eax is a GNCRTCCX ptr
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateCrtcContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwLogDeviceInstance
PARMD   dwPhysDeviceInstance
PARMD   dwIsBootCrtc
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        ; Allocate memory for the GNCRTCCX
        pushd   SIZE GNCRTCCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting.
        mov     ds:[esi].GNCRTCCX.dwInitting,1
        mov     eax,dwLogDeviceInstance
        mov     ds:[esi].GNCRTCCX.dwLogicalDeviceInstance,eax
        mov     eax,dwPhysDeviceInstance
        mov     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,eax
        mov     eax,dwIsBootCrtc
        mov     ds:[esi].GNCRTCCX.dwBootCrtc,eax

        ; Save this
        mov     eax,pGNBoardCXOffset
        mov     ds:[esi].GNCRTCCX.pGNBoardCX,eax

        ; Crate the HW logical device next
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_CreateCrtcContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNCRTCCX.pHWCrtcCX,eax

        ; Build a 16:16 ptr to the monitor path. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.szLocalMonitorBasePath
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpLocalMonitorBasePath,eax

        ; Build a 16:16 ptr to the DISPDATA. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeOut
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpCrtcModeOut,eax

        ; Build a 16:16 ptr to the DISPDATA. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sNvmodeDispData
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpNvmodeDispData,eax
        lea     edi,[esi].GNCRTCCX.sNvmodeDispData

        push    ds:[esi].GNCRTCCX.pGNBoardCX
        call    GN_GetBoardRegistryPath
        mov     ds:[edi].DISPDATA.lpBoardRegistryData,eax
        mov     ds:[esi].GNCRTCCX.lpBoardRegistryData,eax

        ; The base monitor registry path
        mov     eax,ds:[esi].GNCRTCCX.lpLocalMonitorBasePath
        mov     ds:[edi].DISPDATA.lpMonitorRegistryData,eax

        ; Get the PCI device ID
        push    ds:[esi].GNCRTCCX.pGNBoardCX
        call    GN_GetPciDeviceID
        mov     ds:[edi].DISPDATA.dwDeviceID,eax

        ; We don't use this anymore since we validate the physical
        ; and virtual modes independently. I'd like to get rid of it,
        ; but for now we just set the amount of memory to a really
        ; big amount so that this will not be a limitation on the mode.
        mov     eax,10000000H
        mov     ds:[edi].DISPDATA.dwVideoMemoryInBytes,eax

        ; Get the maximum DFP scaling
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_GetMaxDfpScaledXRes
        mov     ds:[edi].DISPDATA.dwMaxDfpScaledXResInPixels,eax

        ; Fill out address of GN_GetDisplayPitch so MODESET DLL can
        ; call back to display driver to get the pitch.
        mov     ax,SEG GN_Far16GetModeSize
        shl     eax,10h
        mov     ecx,OFFSET GN_Far16GetModeSize
        mov     ax,cx
        mov     ds:[edi].DISPDATA.lpfnGetModeSize,eax
        mov     ecx,OFFSET GN_Far16IsModeAcceptedByDriver
        mov     ax,cx
        mov     ds:[edi].DISPDATA.lpfnIsModeAcceptedByDriver,eax
        mov     ds:[edi].DISPDATA.dwContext1,ds
        mov     ds:[edi].DISPDATA.dwContext2,esi

        ; Fill the maximum resolution for TV
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_GetMaxTVOutResolution
        mov     ds:[edi].DISPDATA.dwMaxTVOutResolution,eax
        mov     ds:[edi].DISPDATA.dwTVEncoderType,ebx

        ; Build a 16:16 ptr to the Edid Buffer. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sEdidBuffer
        add     ebx,eax
        mov     eax,1
        mov     ecx,MAX_EDID_BUFFER_SIZE
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpEdidBuffer,eax
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0

        ; Build a 16:16 ptr to the sCrtcModeInfo.MIDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        lea     ebx,[ebx].MODEINFO.MIDevData
        add     ebx,eax
        mov     eax,1
        mov     ecx,MAX_EDID_BUFFER_SIZE
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[edi].DISPDATA.lpDevData,eax

        ; Get the desired display device
        push    esi
        call    GN_GetDisplayDevice

        ; This forces an EDID read also for cases where we read more
        ; frequently than just at boot time.
        mov     ds:[esi].GNCRTCCX.dwTicksSinceLastEdidRead,0

        ; Ask the hardware how many bits per color gun
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_BitsPerColorGun
        mov     ds:[esi].GNCRTCCX.dwBitsPerColorChannel,eax

        ; Ask the Hardware how many cursors it can cache
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        pushd   MAX_CACHEABLE_CURSORS
        call    HW_SizeCursorCache
        mov     ds:[esi].GNCRTCCX.dwMaxCacheableCursors,eax

        ; We force the first modeset after a GNCRTCCX creation
        ; to be a "display device change" modeset which means
        ; that the .inf status will be ignored -- the initial
        ; inf status that Windows gives us is unreliable.
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1

        ; Now we can create it
        push    esi
        call    GN_CreateCursorCache
        or      eax,eax
        je      DoneIt

        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; Build a 16:16 ptr to the sCrtcModeInfo. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        add     ebx,eax
        mov     eax,1
        mov     ecx,SIZE MODEINFO
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpCrtcModeInfo,eax

        ; Initialize the palette table
        ; The first ten entries are system colors
        mov     edi,OFFSET SystemColorTableFirst10
        sub     ebx,ebx
@@:     mov     eax,cs:[edi]
        add     edi,4
        mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,10
        jc      @B

        ; The middle 236 are just set to a default value
        mov     edi,OFFSET SystemColorTableDefault
        mov     eax,cs:[edi]
@@:     mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,246
        jc      @B

        ; The last ten entries are system colors also
        mov     edi,OFFSET SystemColorTableLast10
@@:     mov     eax,cs:[edi]
        add     edi,4
        mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,256
        jc      @B

        ; Create an identity gamma table.
        mov     ebx,0FFH
        mov     eax,0FFFFFFH
@@:     mov     ds:[esi][ebx * 4].GNCRTCCX.dwGammaTable,eax
        sub     eax,10101H
        dec     ebx
        jge     @B

        ; Return Success
        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyBoardContext can clean up partial inits
        push    esi
        call    GN_DestroyCrtcContext
        sub     eax,eax

ExitIt:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyCrtcContext
;
; Purpose:      This routine destroys a GNCRTCCX.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset Offset to the crtc context data to destroy
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyCrtcContext, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Turn off the cursor.
        push    pGNCrtcCXOffset
        pushd   0
        pushd   0
        call    GN_TurnCursorOffOrOn

        cmp     ds:[esi].GNCRTCCX.pCursorCache,0
        je      @F

        ; Now we can destroy the cursor cache.
        push    pGNCrtcCXOffset
        call    GN_DestroyCursorCache
@@:
        ; Free the 16:16 ptr to the lpCrtcModeInfo buffer
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpCrtcModeInfo,0
@@:


        ; Free the 16:16 ptr to the edid buffer
        mov     eax,ds:[esi].GNCRTCCX.lpEdidBuffer
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpEdidBuffer,0
@@:

        ; Free the 16:16 ptr to the lpNvmodeDispData buffer
        mov     eax,ds:[esi].GNCRTCCX.lpNvmodeDispData
        or      eax,eax
        je      DoneDispData

        push    eax
        CALLFAR16IND lpfnFreeMasterLists,es,bx

        ; Free the 16:16 ptr lpDevData in the NvModeDispData struct
        lea     ebx,[esi].GNCRTCCX.sNvmodeDispData
        mov     eax,ds:[ebx].DISPDATA.lpDevData
        or      eax,eax
        je      @F
        shr     eax,10H
        mov     ds:[ebx].DISPDATA.lpDevData,0
        call    GN_UnmapAndFreeSelector
@@:
        mov     eax,ds:[esi].GNCRTCCX.lpNvmodeDispData
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpNvmodeDispData,0
DoneDispData:

        ; Free the 16:16 ptr to the lpNvmodeDispData buffer
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeOut
        or      eax,eax
        je      DoneModeOut
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeOut
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpCrtcModeOut,0
DoneModeOut:

        ; Free the 16:16 ptr to the lpLocalMonitorBasePath buffer
        mov     eax,ds:[esi].GNCRTCCX.lpLocalMonitorBasePath
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpLocalMonitorBasePath,0
@@:
        cmp     ds:[esi].GNCRTCCX.pHWCrtcCX,0
        je      @F
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_DestroyCrtcContext
        mov     ds:[esi].GNCRTCCX.pHWCrtcCX,0

@@:
        ; Free the memory for the object.
        push    esi
        call    HW_FreeFlatMemory

        ; Indicate that we destroyed something.
        mov     eax,1
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLargestEdidMode
;
; Purpose:      This function gets the largest EDI mode for the
;               current device type and tv format if they have
;               an EDID. If not, the mode passed in is unchanged.
;
; Arguments:
;               ds              CX Sel
;               pGNCrtcCXOffset GNCRTCCX ptr
;               lpModeInfo      MODEINFO ptr
;
; Returns:      eax     FALSE then there was no EDID mode
;                       TRUE lpModeInfo was overridden with the largest
;                               EDID mode.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetLargestEdidMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfo
OPENPROC
        mov     ecx,pGNCrtcCXOffset
        push    ds:[ecx].GNCRTCCX.lpEdidBuffer
        push    ds:[ecx].GNCRTCCX.dwEdidSize
        push    lpModeInfo
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetRefreshRateForDesktop
;
; Purpose:      This function gets the refresh rate for the desktop.
;               A refresh rate is really a CRTC thing, not a desktop
;               thing, but this is a Windows messiness. They have
;               a refresh rate affiliated with the desktop because
;               they don't understand about virtual desktops.
;
; Arguments:
;               ds              CX Sel
;               pGNCrtcCXOffset GNCRTCCX ptr
;               lpModeInfo      MODEINFO ptr
;
; Returns:      lpModeInfo->dwRefreshRate was filled in with some
;               refresh rate.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetRefreshRateForDesktop, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfo
OPENPROC
        mov     ebx,pGNCrtcCXOffset
        mov     gs,word ptr lpModeInfo+2
        movzx   eax,word ptr lpModeInfo
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        lea     ecx,[ebx].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ecx].MODEINFO.MIDevData
        mov     gs:[eax].MODEINFO.MIDevData,ecx
        push    lpModeInfo
        push    ds:[ebx].GNCRTCCX.lpEdidBuffer
        push    ds:[ebx].GNCRTCCX.dwEdidSize
        CALLFAR16IND lpfnGetRefreshRateForDesktop,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_DoOddballStuffAtBoot
;
; Purpose:      This function does some things that need to be done
;               at boot that are pretty random. Here is the list.
;               1) Clear PowerUp flags in the registry so that
;                       the control panel will know if the system
;                       has been rebooted since the the last time
;                       the control panel was invoked.
;
; Arguments:
;               ds      CX Sel
;               esi     GNCRTCCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DoOddballStuffAtBoot, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     ebx,pGNCrtcCXOffset
        lfs     bx,ds:[ebx].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpBoardRegistryData
        mov     ax,_DATA
        push    ax
        mov     ax,OFFSET szPowerUpSubkey
        push    ax
        CALLFAR16IND lpfnDeleteLocalRegEntry,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckAndMaybeReadEdid
;
; Purpose:      This function check to see if the EDID needs to be reread
;               and if so, then does the EDID read.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CheckAndMaybeReadEdid, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
LOCALD  dwCurrentEdidSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Read the registry to determine if the EDID should be reread.
        ; If AX is returned as 1, then the registry key ForceEdidRead
        ; exists and is enabled.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetEdidRegistryKey,es,ax
        movzx   eax,ax
        or      eax,eax
        je      DoneRead

OKToReadEdid:
        ; Even Now we still won't read the EDID if we have read it
        ; very recently. This prevents long delays on monitors with
        ; no EDID which take a while to timeout.
        cmp     ds:[esi].GNCRTCCX.dwTicksSinceLastEdidRead,MIN_TICKS_BEFORE_REREADING_EDID
        jc      DoneRead

MustReRead:
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        cmp     ds:[ebx].MODEINFO.MIDevData.cType,DEVTYPE_TV
        je      DoneRead
        
        ; OK, NOW we can read the EDID
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX

        ; JKTODO -- Need to be able to specify Device And Number
        ; For now, just device
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        push    ds:[ebx].MODEINFO.MIDevData
        lea     eax,[esi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[esi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid

DoneRead:
        mov     eax,ds:[esi].GNCRTCCX.dwEdidSize
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Far16GetModeSize
;
; Purpose:      This function returns the amount of memory taken up
;               by a given mode and the pitch for a gievn mode.
;               This function is called from 16bit C code. It must
;               lie within 64K of the start of a segment. We put it
;               in a 16Bit segment just to make things easier.
;
; Arguments:
;               dwContextData1  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the Context Selector.
;
;               dwContextData2  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the GNCRTCCX ptr.
;
;               dwXRes          X Resolution of mode to get size for
;               dwYRes          Y Resolution of mode to get size for
;               dwBpp           Color depth of mode to get size for
;               lpPitch         place to return pitch
;               lpSize          place to return total bytes needed for mode
;
; Returns:      TRUE
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_Far16GetModeSize, PASCAL, FRAME, FAR16
PARMD   dwContextData1
PARMD   dwContextData2
PARMD   dwXRes
PARMD   dwYRes
PARMD   dwBpp
PARMD   lpPitch
PARMD   lpSize
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,dwContextData1
        mov     ebx,dwContextData2
        mov     ebx,ds:[ebx].GNCRTCCX.pGNBoardCX

        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwXRes
        push    dwYRes
        push    dwBpp
        call    HW_GetModeDimensions

        lfs     si,lpPitch
        mov     fs:[si],eax
        lfs     si,lpSize
        mov     fs:[si],ebx

        mov     ax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Far16IsModeAcceptedByDriver
;
; Purpose:      This function gets called from the modeset dll
;               to allow the driver to veto or accept a mode.
;               Technically, you may also modify the output
;               timings, but this is discouraged and should
;               only be done in extreme cases.
;
; Arguments:
;               dwContextData1  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the Context Selector.
;
;               dwContextData2  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the GNCRTCCX ptr.
;
;               lpDispData      LPDISPDATA ptr
;               lpModeOut       LPMODEOUT ptr
;               lpEdidBuffer    LPCHAR ptr to an edid buffer
;               dwEdidSize      ULONG size in bytes of edid (0 if no edid)
;
; Returns:      TRUE
;
; Preserve:     ds,esi,edi
;==============================================================================
CALL_LINKREG    MACRO   label1,linkreg
        LOCAL   quickret
        mov     linkreg,OFFSET quickret
        jmp     label1
quickret:
ENDM

DECPROC GN_Far16IsModeAcceptedByDriver, PASCAL, FRAME, FAR16
PARMD   dwContextData1
PARMD   dwContextData2
PARMD   lpDispData
PARMD   lpModeOut
PARMD   lpEdidBuffer
PARMD   dwEdidSize
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  pTheHWCrtcCX
OPENPROC
        PUSHR   ds,esi,edi

        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        mov     ds,dwContextData1
        mov     esi,dwContextData2

        ; Just in case the HWCRTCCX has been locked by somebody
        ; else, we have to look a couple places for it.
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pTheHWCrtcCX,eax

        ; The paramter list we have to provide is the following:
        ; pHWCrtcCXOffset
        ; dwTotalWidth0
        ; dwVisibleWidth0
        ; dwTotalHeight0
        ; dwVisibleHeight0
        ; dwPixelDepth0
        ; dwPixelClock0
        ; dwRefreshRate0
        ; dwTotalWidth1
        ; dwVisibleWidth1
        ; dwTotalHeight1
        ; dwVisibleHeight1
        ; dwPixelDepth1
        ; dwPixelClock1
        ; dwRefreshRate1
        ;
        ; The 0 on the end means physical head 0 and the 1 means
        ; physical head 1. If you are only concerned with the mode
        ; on one of the two heads (i.e. the other head is not active)
        ; set dwTotalWidth for that head to 0.

        ; push the HWCRTCCX
        push    pTheHWCrtcCX

        push    ds:[esi].GNCRTCCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; See if the device we are testing is on head 0
        push    pTheHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        or      eax,eax
        je      UseNewParamsFirst

        ; If it is on head -1, we don't know!! It may not have
        ; been mapped yet. Unh! We will assume that it is the
        ; right one in this case, though.
        cmp     eax,-1
        je      UseNewParamsFirst

        ; We are on a non-0 legal head. Are there two devices?
        cmp     dwDeviceCount,1
        je      NullForFirst

TwoDevicesNewIsNotHead0:
        lfs     bx,lpGNCrtcCX
        mov     ecx,fs:[bx]
        mov     edx,fs:[bx + 4]
        cmp     ecx,esi
        jne     @F
        mov     ecx,edx
@@:
        push    ds
        pop     fs
        lea     ecx,[ecx].GNCRTCCX.sCrtcModeOut
        CALL_LINKREG  PushParams,edx

        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG  PushParams,edx
        jmp     DoTheCall

NullForFirst:
        ; Nulls for head 0, and head 1 must be the "new" one
        CALL_LINKREG    PushNulls,edx

        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG    PushParams,edx
        jmp     DoTheCall

UseNewParamsFirst:
        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG    PushParams,edx

        ; OK, now, are we even concerned with two displays?
        cmp     dwDeviceCount,1
        je      NullForSecond

        ; Find the paramters for the device that isn't "new"
        lfs     bx,lpGNCrtcCX
        mov     ecx,fs:[bx]
        mov     edx,fs:[bx + 4]
        cmp     ecx,esi
        je      GotSecondCrtcCX
        mov     edx,ecx
        jmp     GotSecondCrtcCX

NullForSecond:
        CALL_LINKREG    PushNulls,edx
        jmp     DoTheCall

GotSecondCrtcCX:
        ; edx = GNCRTCCX
        lea     ecx,[edx].GNCRTCCX.sCrtcModeOut
        push    ds
        pop     fs
        CALL_LINKREG    PushParams,edx
        jmp     DoTheCall

DoTheCall:
        call    HW_IsBandwidthOK
        jmp     Done

PushParams:
        movzx   eax,fs:[ecx].MODEOUT.wHTotal
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wXRes
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wVTotal
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wYRes
        push    eax
        mov     eax,fs:[ecx].MODEOUT.dwFormat
        shr     eax,16
        and     eax,3
        inc     eax
        cmp     eax,3
        jne     @F
        mov     eax,2
@@:     shl     eax,3
        push    eax
        push    fs:[ecx].MODEOUT.dwPixelClock
        movzx   eax,fs:[ecx].MODEOUT.wRefreshRate
        push    eax
        jmp     edx

PushNulls:
        sub     eax,eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        jmp     edx

Done:
        POPR    ds,esi,edi
CLOSEPROC


ALIGN 4
SystemColorTableFirst10 LABEL   BYTE
;       blue,   green,  red,    flags
DB      000H,   000H,   000H,   000H
DB      000H,   000H,   080H,   000H
DB      000H,   080H,   000H,   000H
DB      000H,   080H,   080H,   000H
DB      080H,   000H,   000H,   000H
DB      080H,   000H,   080H,   000H
DB      080H,   080H,   000H,   000H
DB      0C0H,   0C0H,   0C0H,   MAPTOWHITE
DB      0C0H,   0DCH,   0C0H,   NONSTATIC+MAPTOWHITE
DB      0F0H,   0CAH,   0A6H,   NONSTATIC+MAPTOWHITE

SystemColorTableDefault LABEL   BYTE
;       blue,   green,  red,    flags
DB      000H,   000H,   000H,   NONSTATIC

SystemColorTableLast10  LABEL   BYTE
;       blue,   green,  red,    flags
DB      0F0H,   0FBH,   0FFH,   NONSTATIC+MAPTOWHITE
DB      0A4H,   0A0H,   0A0H,   NONSTATIC+MAPTOWHITE
DB      080H,   080H,   080H,   MAPTOWHITE
DB      000H,   000H,   0FFH,   000H
DB      000H,   0FFH,   000H,   MAPTOWHITE
DB      000H,   0FFH,   0FFH,   MAPTOWHITE
DB      0FFH,   000H,   000H,   000H
DB      0FFH,   000H,   0FFH,   000H
DB      0FFH,   0FFH,   000H,   MAPTOWHITE
DB      0FFH,   0FFH,   0FFH,   MAPTOWHITE

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP8.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp8.asm
;
; Purpose:      This file has functions to copy X-bpp bitmaps to
;               16bpp bitmaps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To8WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 16bpp value is pulled out of the table. The
;               low byte of this word should be used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To8WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     cl,fs:[ebx][eax * 2]
        mov     es:[edi],cl
        inc     edi
        sub     ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
        shr     eax,4
        and     ecx,00FH
        mov     al,fs:[ebx][eax * 2]
        mov     cl,fs:[ebx][ecx * 2]
        mov     es:[edi+0],al
        mov     es:[edi+1],cl
        add     edi,2
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        sub     ecx,ecx
        dec     edx
        jl      NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
        shr     eax,4
        mov     al,fs:[ebx][eax * 2]
        mov     es:[edi],al
        inc     edi
        inc     ecx

NextScan:
        shl     esi,1
        add     esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8NoXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. There is no
;               color translate table needed. Just copy the src to the
;               dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer8To8NoXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Are there just a few bytes to do?
        mov     eax,esi
        neg     eax
        and     eax,3
        mov     edx,dwExtX
        sub     edx,eax
        jg      @F
        mov     eax,dwExtX
        sub     ebx,ebx
        jmp     L0_M0_RX
@@:
        ; We can
        sub     ecx,ecx
        mov     ebx,edx
        shr     edx,2
        and     ebx,3
        or      eax,eax
        setne   cl
        cmp     edx,1
        adc     ecx,ecx
        cmp     ebx,1
        adc     ecx,ecx
        xor     ecx,3
        jmp     NEAR PTR cs:CopyJmpTable[ecx * 4]


CopyJmpTable    LABEL   DWORD
DD      OFFSET L0_M0_R0,OFFSET L0_M0_RX,OFFSET L0_MX_R0,OFFSET L0_MX_RX
DD      OFFSET LX_M0_R0,OFFSET LX_M0_RX,OFFSET LX_MX_R0,OFFSET LX_MX_RX

LX_MX_RX:
        mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,ebx
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LX_MX_RX
        jmp     Done

LX_MX_R0:
        mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LX_MX_R0
        jmp     Done

L0_MX_RX:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,ebx
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_RX
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

LX_M0_RX:
LX_M0_R0:
L0_M0_RX:
        add     eax,ebx
@@:     mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     @B
        jmp     Done

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8ByteXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 1,
;               and a byte value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To8ByteXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        sub     ecx,ecx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        mov     cl,al
        mov     al,fs:[ebx + ecx]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx]
        rol     eax,10H
        mov     cl,al
        mov     al,fs:[ebx + ecx]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx]
        rol     eax,10H
        mov     es:[edi],eax
        sub     edx,4
        add     edi,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     cl,ds:[esi]
        inc     esi
        mov     al,fs:[ebx + ecx]
        mov     es:[edi],al
        inc     edi
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out. The low byte of this word
;               is written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To8WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwBytesRest
OPENPROC
LoopTop:
        mov     edx,dwExtX
        sub     ecx,ecx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        mov     cl,al
        mov     al,fs:[ebx + ecx * 2]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx * 2]
        rol     eax,10H
        mov     cl,al
        mov     al,fs:[ebx + ecx * 2]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx * 2]
        rol     eax,10H
        mov     es:[edi],eax
        sub     edx,4
        add     edi,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     cl,ds:[esi]
        inc     esi
        mov     al,fs:[ebx + ecx * 2]
        mov     es:[edi],al
        inc     edi
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 15bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     dx,ds:[esi]
        and     edx,7FFFH
        add     esi,2
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 16bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
        sub     eax,eax
LoopX:
        mov     ax,ds:[esi]
        ror     eax,5
        shr     ax,1
        rol     eax,5
        add     esi,2
        mov     al,fs:[ebx + eax]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 24bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     al,ds:[esi]
        shr     al,3
        shrd    edx,eax,5
        mov     al,ds:[esi + 1]
        shr     al,3
        shrd    edx,eax,5
        xor     ah,ah
        mov     al,ds:[esi + 2]
        shr     al,3
        shrd    edx,eax,16H
        add     esi,3
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 32bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     al,ds:[esi]
        shr     al,3
        shrd    edx,eax,5
        mov     al,ds:[esi + 1]
        shr     al,3
        shrd    edx,eax,5
        xor     ah,ah
        mov     al,ds:[esi + 2]
        shr     al,3
        shrd    edx,eax,16H
        add     esi,4
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP32.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp32.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 32bpp dst bitmap.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 32bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               and used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 32bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,al
        movzx   edx,ah
        shr     eax,10H
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        movzx   ecx,al
        movzx   edx,ah
        add     edi,8
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 15bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer15To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD	dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        ; First chunk of 2
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5 + 8
        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8

        ; Do a second chunk of two
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
	shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5 + 8
        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5 + 8
        mov     es:[edi],ecx
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 16bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer16To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        ; First chunk of 2
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5
                                        shrd    edx,ebx,5
        shr     eax,5
                                        shr     ebx,5
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,1
                                        sar     edx,1
        shrd    ecx,eax,6
                                        shrd    edx,ebx,6
        shr     eax,6
                                        shr     ebx,6
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5 + 8
                                        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8

        ; Do a seond chunk of two
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5
                                        shrd    edx,ebx,5
        shr     eax,5
                                        shr     ebx,5
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,1
                                        sar     edx,1
        shrd    ecx,eax,6
                                        shrd    edx,ebx,6
        shr     eax,6
                                        shr     ebx,6
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5 + 8
                                        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,1
        shrd    ecx,eax,6
        shr     eax,6
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5 + 8
        mov     es:[edi],ecx
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 24bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer24To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+2]
        add     esi,6
        shr     ecx,8
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        mov     es:[edi],eax
        add     edi,4
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 32bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. In fast, there is no conversion
;               period. Just copy the src to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer32To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
@@:
        mov     ecx,dwExtX
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     @B
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCLRINF.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnclrinf.asm
;
; Purpose:      This file holds the ColorInfo display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

COMPARE_VS_DIBENG       MACRO
        LOCAL   skip1, skip2
IFDEF DEBUG
        movzx   ecx,sp
        push    eax
        push    edx
        push    lpDstDev
        push    dwColorIn
        push    lpPhysColor
        call    DIB_ColorInfo
        mov     ebx,eax
        mov     ecx,edx
        pop     edx
        pop     eax
        cmp     ax,bx
        je      skip1
        int     3
skip1:
        cmp     cx,dx
        je      skip2
        int     3
skip2:
ENDIF
ENDM


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  Table5To8
Table5To8       LABEL   BYTE
DB      000H, 010H, 018H, 020H, 028H, 030H, 038H, 040H
DB      048H, 050H, 058H, 060H, 068H, 070H, 078H, 080H
DB      088H, 090H, 098H, 0A0H, 0A8H, 0B0H, 0B8H, 0C0H
DB      0C8H, 0D0H, 0D8H, 0E0H, 0E8H, 0F0H, 0F8H, 0FFH

PUBLIC  Table6To8
Table6To8       LABEL   BYTE
DB      000H, 008H, 00CH, 010H, 014H, 018H, 01CH, 020H
DB      024H, 028H, 02CH, 030H, 034H, 038H, 03CH, 040H
DB      044H, 048H, 04CH, 050H, 054H, 058H, 05CH, 060H
DB      064H, 068H, 06CH, 070H, 074H, 078H, 07CH, 080H
DB      084H, 088H, 08CH, 090H, 094H, 098H, 09CH, 0A0H
DB      0A4H, 0A8H, 0ACH, 0B0H, 0B4H, 0B8H, 0BCH, 0C0H
DB      0C4H, 0C8H, 0CCH, 0D0H, 0D4H, 0D8H, 0DCH, 0E0H
DB      0E4H, 0E8H, 0ECH, 0F0H, 0F4H, 0F8H, 0FCH, 0FFH

;==============================================================================
;
; Function:     GENERIC_ColorInfo
;
; Purpose:      This function is the ColorInfo display driver entry point.
;
;==============================================================================
lpDstDev        TEXTEQU <dword ptr ss:[ecx + 0CH]>
dwColorIn       TEXTEQU <dword ptr ss:[ecx + 08H]>
lpPhysColor     TEXTEQU <dword ptr ss:[ecx + 04H]>

DECPROC GENERIC_ColorInfo, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   dwColorIn
;PARMD   lpPhysColor
OPENPROC
        movzx   ecx,sp
        sub     ebx,ebx
        lfs     bx,lpDstDev

        ; Only handle 16bpp and 32bpp color info calls
        mov     al,fs:[ebx].DIBENGINE.deBitsPixel
        movzx   edx,fs:[ebx].DIBENGINE.deFlags
        cmp     al,32
        je      Bpp32
        cmp     al,16
        jne     Punt

Bpp16:
        ; Only deal with 5-6-5
        test    edx,FIVE6FIVE
        jz      Punt

        ; Break into LogToPhys and PhysToLog cases
        mov     eax,dwColorIn
        cmp     word ptr lpPhysColor+2,0
        je      Phys16ToLog

LogToPhys16:
        test    eax,0FF000000H
        jnz     LogPaletteIndexToPhys

LogRGBToPhys16:
        lfs     bx,lpPhysColor

        ; Special case check for black
        and     eax,0FFFFFFH
        jne     @F
        or      eax,40000000H
        mov     fs:[ebx],eax
        mov     byte ptr fs:[ebx + 3],40H
        sub     edx,edx
        COMPARE_VS_DIBENG
        RETFAR16  0CH
@@:
        ; Special case check for white
        cmp     eax,0FFFFFFH
        jne     @F
        or      eax,40000000H
        mov     fs:[ebx],eax
        mov     byte ptr fs:[ebx + 3],40H
        mov     edx,0FFH
        COMPARE_VS_DIBENG
        RETFAR16  0CH
@@:
        ; Not special -- convert 32 to 16 the hard way
        movzx   edx,al
        shr     eax,8
        xchg    ah,dl
        sub     al,02H
        jnc     @F
        sub     al,al
@@:     sub     ah,4
        jnc     @F
        sub     ah,ah
@@:     sub     dl,4
        jnc     @F
        sub     dl,dl
@@:     shr     ah,3
        shl     edx,18H
        shr     ax,2
        shld    eax,edx,5
        movzx   eax,ax
        mov     fs:[ebx],eax

Phys16ToLog:
        ; Convert 16 to 32 via tables
        mov     ebx,eax
        and     eax,1FH
        shr     ebx,5
        mov     dl,cs:Table5To8[eax]
        mov     ecx,ebx
        and     ebx,3FH
        shr     ecx,6
        and     ecx,1FH
        mov     ah,cs:Table6To8[ebx]
        mov     al,cs:Table5To8[ecx]
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Bpp32:
        movzx   eax,word ptr dwColorIn
        movzx   edx,word ptr dwColorIn+2
        cmp     word ptr lpPhysColor+2,0
        je      Phys32ToLog

LogToPhys32:
        ; Watch for palette indices
        or	dh,dh
        jne     LogPaletteIndexToPhys

        ; Easy -- just switch red and blue
        lfs     bx,lpPhysColor
        mov     byte ptr fs:[ebx+0],dl
        mov     byte ptr fs:[ebx+1],ah
        mov     byte ptr fs:[ebx+2],al
        mov     byte ptr fs:[ebx+3],00
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Phys32ToLog:
        ; Easy -- just switch red and blue
        xchg    al,dl
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

LogPaletteIndexToPhys:
        or      eax,0FFFF0000H
        lfs     bx,lpPhysColor
        mov     fs:[ebx],eax
        shld    edx,eax,10H
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Punt:
        jmp     DIB_ColorInfo
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCNTRL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gncntrl.asm
;
; Purpose:      This file holds the Control display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include escape.inc
include tvout.inc
include modeext.inc

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
LOCALD  dwCRTCCount
LOCALD  dwCopyStandard
LOCALD  pGNCrtcCXOffset
LOCALD  pHWCrtcCXOffset
LOCALD  pGNLogdevCXUsingTheHead
LOCALD  pGNCrtcCXUsingTheHead
LOCALD  pHWCrtcCXUsingTheHead
LOCALD  dwLogCrtcIndex
ENDM

QUERYESCSUPPORT         TEXTEQU <8>
MOUSETRAILS             TEXTEQU <39>
DCICOMMAND              TEXTEQU <3075>
EDDESCAPE                               TEXTEQU <0EEEE0000H>
EDDESC_SCROLL                   TEXTEQU <0EDD00012H>

EDDESC_SCROLL_DATA      struc
dwSize          dd      ?               ;// = sizeof(struct tagSCROLL_DATA)
dwCommand       dd      ?               ;// = EDDESC_SCROLL
cyLines         dd      ?               ;// # of lines vertical panning
EDDESC_SCROLL_DATA      ends

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_Control
;
; Purpose:      This function is the Control display driver entry point.
;               It will handle all the Windows defined escapes. Any non-
;               Windows escapes will be passed off to the hardware
;               specific routine.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Control, PASCAL, FRAME, FAR16
CONTROL_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi
        pushf
        cld

        ; We want a ptr to the GNLOGDEVCX passed in (which is
        ; not necessarily the one corresponding to this driver!
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     eax,lpDstDev
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        mov     esi,eax

        movzx   eax,wFunction
        push    OFFSET RetAddr
        cmp     eax,QUERYESCSUPPORT
        je      GN_ControlQuery
        cmp     eax,DCICOMMAND
        je      GN_ControlDDraw
        cmp     eax,MOUSETRAILS
        je      GN_MouseTrails
        add     sp,@WordSize

        push    OFFSET Done
        cmp     eax,GN_ESC_GET_PDEVICE
        je      GN_ControlReturnPDevice
        cmp     eax,GN_ESC_ALLOC_SELECTOR_AND_MAP
        je      GN_ControlAllocSelectorAndMap
        cmp     eax,GN_ESC_UNMAP_AND_FREE_SELECTOR
        je      GN_ControlUnmapAndFreeSelector
        cmp     eax,NV_ESC_ALLOC_SHARED_MEMORY
        je      GN_ControlAllocSharedMemory
        cmp     eax,NV_ESC_FREE_SHARED_MEMORY
        je      GN_ControlFreeSharedMemory
        cmp     eax,NV_ESC_GET_SHARED_MEMORY
        je      GN_ControlGetSharedMemory
        cmp     eax,GN_ESC_SET_CURSOR
        je      GN_ControlSetCursor
        cmp     eax,NV_ESC_DVD_MACROVISION_CMD
        je      GN_DvdMacrovisionCommand
        cmp     eax,OPENGL_GETINFO
        je      GN_OpenGLGetInfo
        cmp     eax,VIDEO_PARAMETERS
        je      GN_VideoParameters
        cmp     eax,NV_ESC_GET_LOCAL_REGISTRY_PATH
        je      GN_GetLocalRegistryPath
        cmp     eax,NV_ESC_GET_REGISTRY_MODE_LIST
        je      GN_GetRegistryModeList
        cmp     eax,NV_ESC_PRIMARY_INFO
        je      GN_GetPrimaryInfo
        cmp     eax,NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST
        je      GN_GetRegistryDesktopModeList
        cmp     eax,ESC_NV_QUERY_HEAD_REFRESH_RATE
        je      GN_QueryHeadRefreshRate
        cmp     eax,NV_ESC_ENABLE_DISABLE_SOFTWARE_CURSOR
        je      GN_SoftwareCursor
        cmp	eax,NV_ESC_SET_CPL_DWORD
        je      GN_SetCplDword
        cmp	eax,NV_ESC_GET_CPL_DWORD
        je      GN_GetCplDword
        add     sp,@WordSize

        ; See if it is a dualhead specific escape
        push    esi                     ; GNLOGDEVCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    ControlPanelInterface
        or      ecx,ecx
        jne     Done

        ; See if it is a hardware specific escape
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    HW_ControlAction
        or      ecx,ecx
        jne     Done

BackPunt:
        ; Punt it to DIBENG
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    DIB_Control
        jmp     Done

RetAddr:
        or      ecx,ecx
        je      BackPunt
Done:
        popf
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlQuery
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is QUERYESCSUPPORT. This routine should
;               see first if it is a generic escape it knows about and,
;               if so, it should return the appropriate return code. If
;               it is not a generic escape, this routine will call the
;               hardware specific query routine to see if it is a HW
;               specific escape.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds:esi
;==============================================================================
DECPROC GN_ControlQuery, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
        les     bx,lpIn
        mov     ecx,1
        movzx   edx,word ptr es:[ebx]

        cmp     edx,DCICOMMAND
        jne     @F
        mov     eax,(DD_HAL_VERSION - 1)        ; WHQL certification "bit"
        jmp     Done
@@:
        cmp     edx,OPENGL_GETINFO
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        cmp     edx,OPENGL_CMD
        jne     @F
        sub     eax,eax
        jmp     Done
@@:
        cmp     edx,VIDEO_PARAMETERS
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        cmp     edx,NV_ESC_DVD_MACROVISION_CMD
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    HW_ControlQuery
        or      ecx,ecx
        jne     Done

        ; Punt it to DIBENG
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    DIB_Control
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDraw
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND. This routine will
;               handle the flavors of DCICOMMAND escapes it knows about
;               and punt the rest to the DIBENG.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     0   DCICOMMAND sub-function was not recognized
;                       1   DCICOMMAND sub-function was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDraw, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx

        ; Punt if lpIn is NULL or if the version is wrong
        cmp     ebx,lpIn
        je      Punt
        les     bx,lpIn
        cmp     es:[ebx].MYDCICMD.dwVersion,DD_VERSION
        jne     Punt

        push    OFFSET Handled
        mov     eax,es:[ebx].MYDCICMD.dwCommand
        cmp     eax,DDNEWCALLBACKFNS
        je      GN_ControlDDrawNewCallbackFns
        cmp     eax,DDGET32BITDRIVERNAME
        je      GN_ControlDDrawGet32BitDriverName
        cmp     eax,DDCREATEDRIVEROBJECT
        je      GN_ControlDDrawCreateDriverObject
        cmp     eax,DDVERSIONINFO
        je      GN_ControlDDrawDDVersionInfo

        ; These are not really standard DCI escapes. The
        ; DDNVCREATEDRIVEROBJECT escape tells us that the DirectX
        ; driver just went from having no apps attached to having one
        ; app attached. The DDNVDESTROYDRIVEROBJECT tells us that
        ; Direct X just went from having 1 app attached to having no
        ; apps attached.
        cmp     eax,DDNVCREATEDRIVEROBJECT
        je      GN_ControlDDrawNVCreateDriverObject
        cmp     eax,DDNVDESTROYDRIVEROBJECT
        je      GN_ControlDDrawNVDestroyDriverObject

        ; For a little applet someone wrote.
        cmp     eax,EDDESCAPE
        je      GN_RollerToolEscape
        add     sp,@WordSize

Punt:
        sub     ecx,ecx
        jmp     Done

Handled:
        mov     ecx,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNewCallbackFns
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNEWCALLBACKFNS.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNewCallbackFns, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Save the callbacks to internal direct functions
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].MYDCICMD.dwParam1

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    eax
        call    HW_SetNewDirxCallbacks

        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawGet32BitDriverName
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDGET32BITDRIVERNAME.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawGet32BitDriverName, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Copy the Direct Draw Dll Name into the lpOut structure
        ; so the system knows which Dll to load.
        movzx   ebx,word ptr lpOut+0
        movzx   eax,word ptr lpOut+2
        lea     edx,[ebx].MYDD32BITDRIVERDATA.szName
        lea     ecx,[ebx].MYDD32BITDRIVERDATA.szEntryPoint

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    eax
        push    edx
        push    eax
        push    ecx
        call    HW_GetDirectXDllNameAndEntryPoint

        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].MYDD32BITDRIVERDATA.dwContext,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawCreateDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDCREATEDRIVEROBJECT.
;
;               NOTE: This function may get called in a DISABLED
;               secondary display driver in which case we will
;               never actually receive a DD
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawCreateDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Let everyone know that DirectX is at least enumerating.
        push    esi
        pushd   MSG_DIRECTX_ENUM
        push    esi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; We are supposed to return the hInstance of our driver for this
        ; sub-escape. If we don't know it, then return 0.
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetDirectXInstance
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx],eax

        ; Success code
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNVCreateDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNVCREATEDRIVEROBJECT.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNVCreateDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Let everyone know that DirectX is starting up.
        push    esi
        pushd   MSG_DIRECTXON
        push    esi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; Need to remember that directX is active
        mov     ds:[esi].GNLOGDEVCX.bDirectXActive,1

Done:
        ; Return success and handled
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNVDestroyDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNVDESTROYDRIVEROBJECT.
;
;		NOTE: Due to a messed up DirectX run-time, we
;		can get multiple creates and only one destroy.
;		When we get the destroy we need to shut down
;		DirectX on ALL logical devices, not just the
;		one corresponding to the driver we are called in.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNVDestroyDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
	; Inform all GNLOGDEVCXs on this board thwt DirectX is going away
	mov	dwCRTCCount,0
LoopT:
	mov	ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
	mov	eax,dwCRTCCount
	mov	edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
	or	edi,edi
	je	@F

        push    edi
        pushd   MSG_DIRECTXOFF
        push    edi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; Need to remember that directX is not active
        mov     ds:[edi].GNLOGDEVCX.bDirectXActive,0

@@:
	inc	dwCRTCCount
	mov	eax,dwCRTCCount
	mov	ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopT

Done:
        ; Return success and handled
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawDDVersionInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDVERSIONINFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawDDVersionInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; This Microsoft DDK said to do this. Stuff the run-time
        ; version of DirectX which the DirectX driver was built to
        ; handle in dwHALVersion. If the lpOut ptr it NULL, then fail.
        sub     eax,eax
        cmp     eax,lpOut
        je      Done

        sub     ebx,ebx
        les     bx,lpIn
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    es:[ebx].MYDCICMD.dwParam1
        call    HW_GetDirectXRuntimeVersion

        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].MYDDVERSIONDATA.dwHALVersion,eax
        mov     eax,1
Done:
CLOSEPROC

;==============================================================================
;
; Function:     GN_RollerToolEscape
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is EDDESCAPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:
;==============================================================================
DECPROC GN_RollerToolEscape, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; This Microsoft DDK said to do this. Stuff the run-time
        ; version of DirectX which the DirectX driver was built to
        ; handle in dwHALVersion. If the lpOut ptr it NULL, then fail.
        sub     eax,eax
        cmp     eax,lpIn
        je      Done

        sub     ebx,ebx
        les     bx,lpIn
        cmp     es:[ebx].EDDESC_SCROLL_DATA.dwCommand,EDDESC_SCROLL
        jne     Done
        cmp     es:[ebx].EDDESC_SCROLL_DATA.dwSize,size EDDESC_SCROLL_DATA
        jne     Done
        mov     eax,es:[ebx].EDDESC_SCROLL_DATA.cyLines

        add     ds:[esi].GNLOGDEVCX.dwCurrentLine,eax
        jns     @F
        mov     ds:[esi].GNLOGDEVCX.dwCurrentLine,0

@@:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[ecx].GNBOARDCX.dwMemorySizeForValidateMode
        sub     edx,edx
        idiv    ds:[esi].DIBENGINEHDR.deDeltaScan

        ; eax = whole height of videomemory.
        movzx   ecx,ds:[esi].DIBENGINEHDR.deHeight
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentLine
        add     edx,ecx
        cmp     edx,eax
        jbe     @F
        sub     eax,ecx
        mov     ds:[esi].GNLOGDEVCX.dwCurrentLine,eax

@@:
        mov     ecx,ds:[esi].DIBENGINEHDR.deDeltaScan
        mov     eax,ds:[esi].GNLOGDEVCX.dwCurrentLine
        imul    eax,ecx

IF 0
        ; Tell the CRTC0 where the base of the panning should be.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[0]
        push    eax                                     ;PanBase
        push    ecx                                     ;Pitch
        call    GN_SetPanBaseAndPitch
ENDIF
        mov     eax,1
Done:
CLOSEPROC

;==============================================================================
;
; Function:     GN_MouseTrails
;
; Purpose:      This function is called when an escape is changing the
;               mouse trails state.
;
;               I could not find a definition of the lpIn and lpOut
;               ptrs when wFunction = MOUSETRAILS, but by using the
;               debugger I inferred the following:
;               lpOut is NULL
;               lpIn points to a 16bit value which tells the number
;               of trails to display. It is 0 to turn off mouse trails.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               ecx     = 0 so that we will pass the call to the DIBENG
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_MouseTrails, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Enumerate CRTCs attached
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

LoopCRTC:
        ; If this CRTC is not a NULL context ...
        mov     edx,ds:[edi]
        or      edx,edx
        je      NextCrtc

        ; Get the cursor cache ptr
        mov     ecx,ds:[edx].GNCRTCCX.pCursorCache
        or      ecx,ecx
        je      NextCrtc

        ; Clear cursor cache
        push    ecx
        push    edx
        call    GN_ClearCursorCache
        pop     ecx

        ; Turn on / off the TRAILS bit accordingly
        sub     ebx,ebx
        les     bx,lpIn

        or      ds:[ecx].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_MOVE
        cmp     word ptr es:[ebx],0
        jne     @F
        and     ds:[ecx].CURSORCACHE.dwCursorFlags,NOT (CURSOR_HAS_TRAILS OR CURSOR_MOVE)

        ; Initialize position for h/w cursor only.
        push    ecx
        mov     eax,dword ptr ds:[ecx].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        call    GENERIC_MoveCursor
        pop     ecx
@@:
        ; Now patch the cursor depended entries
        push    ds:[ecx].CURSORCACHE.dwCursorFlags
        call    GN_TurnExcludeOffOrOn

NextCrtc:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

        ; Return that we want the call passed to the DIBENG also.
        sub     ecx,ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_SoftwareCursor
;
; Purpose:      This function is called when an escape is changing to/from
;               a hardware cursor from/to a software cursor.
;
;               I could not find a definition of the lpIn and lpOut
;               ptrs when wFunction = MOUSETRAILS, but by using the
;               debugger I inferred the following:
;               lpOut is NULL
;               lpIn points to a 16bit value which tells the number
;               of trails to display. It is 0 to turn off mouse trails.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               ecx     = 0 so that we will pass the call to the DIBENG
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_SoftwareCursor, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Enumerate CRTCs attached
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

LoopCRTC:
        ; If this CRTC is not a NULL context ...
        mov     edx,ds:[edi]
        or      edx,edx
        je      NextCrtc

        ; Get the cursor cache ptr
        mov     ecx,ds:[edx].GNCRTCCX.pCursorCache
        or      ecx,ecx
        je      NextCrtc

        ; Clear cursor cache
        push    ecx
        push    edx
        call    GN_ClearCursorCache
        pop     ecx

        ; Turn on / off the TRAILS bit accordingly
        sub     ebx,ebx
        les     bx,lpIn

        or      ds:[ecx].CURSORCACHE.dwCursorFlags,CURSOR_IS_SOFTWARE OR CURSOR_MOVE
        cmp     word ptr es:[ebx],0
        jne     @F
        and     ds:[ecx].CURSORCACHE.dwCursorFlags,NOT (CURSOR_IS_SOFTWARE OR CURSOR_MOVE)

        ; Initialize position for h/w cursor only.
        push    ecx
        mov     eax,dword ptr ds:[ecx].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        call    GENERIC_MoveCursor
        pop     ecx
@@:
        ; Now patch the cursor depended entries
        push    ds:[ecx].CURSORCACHE.dwCursorFlags
        call    GN_TurnExcludeOffOrOn

NextCrtc:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

        ; Return that we want the call passed to the DIBENG also.
        sub     ecx,ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlReturnPDevice
;
; Purpose:      This function returns the PDevice as both
;               a 16:16 and a flat 32bit ptr.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               The linear address is provided as the first dword in the
;               lpOut structure and a 16:16 ptr is provided in the 2nd dword.
;               See escape.h for mode details.
;               Aslo return ecx = 1 to show that we handled the call.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlReturnPDevice, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],esi
        mov     eax,cs:[CSlp16LogDevice_In_NVTEXT16]
        mov     es:[edi + 4],eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetCplDword
;
; Purpose:      This function saves the dword passed in. It can be
;		gotten again by the caller by issuing the
;		NV_ESC_GET_CPL_DWORD. Note that the display driver
;		makes no attempt to interpret this data in any way.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_SetCplDword, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi]
        mov	ds:[esi].GNLOGDEVCX.dwCplData,eax
        mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCplDword
;
; Purpose:      This function returns the cpl dword. It was saved
;		when the caller issued the NV_ESC_SET_CPL_DWORD.
;		It was initialized to -1 at boot.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               dword pointed to by lpOut is set to the saved
;		control panel data.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_GetCplDword, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov	eax,ds:[esi].GNLOGDEVCX.dwCplData
        mov     es:[edi],eax
        mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlAllocSelectorAndMap
;
; Purpose:      This function allocs a selector and maps it to
;               a linear address given for the given length.
;
;               The lpIn argument should point to 2 DWORDS.
;               The first DWORD is the linear base address the
;               newly allcated seelctor should get.
;               The second DWORD specifies the limit of the selector.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               The return value is a 16bit WORD that is placed where
;               lpOut points to. The 16bit value is the newly allocated
;               slector. It is 0 if the routine failed.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlAllocSelectorAndMap, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        mov     eax,1
        mov     ebx,es:[edi]
        mov     ecx,es:[edi + 4]
        call    GN_AllocSelectorAndMapIt
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
CLOSEPROC

;==============================================================================
;
; Function:     GN_ControlUnmapAndFreeSelector
;
; Purpose:      This function unmaps and frees a selector.
;
;               The first 16 bit WORD pointed to by lpIn has
;               the selector to free.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlUnmapAndFreeSelector, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        movzx   eax,word ptr es:[edi]
        or      eax,eax
        je      @f
        call    GN_UnmapAndFreeSelector
        mov     eax,1
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlAllocSharedMemory
;
; Purpose:      This function allocates shared memory for the
;               caller and remembers the allocation.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlAllocSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Look for a free entry in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
        je      FoundOne
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundOne:
        PUSHR   ecx
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].ESC_ALLOC_SHARED_MEMORY_IN.dwNumBytes
        call    GN_MemoryAlloc
        POPR    ecx
        or      eax,eax
        je      DoneIt

        ; Save off the memory allocated in the GNBOARDCX
        sub     ebx,ebx
        les     bx,lpIn
        shl     edx,10H
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,edx
        mov     eax,es:[ebx].ESC_ALLOC_SHARED_MEMORY_IN.dwID
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID,eax
        shr     edx,10H
        push    edx
        call    GN_GetSelectorBase

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_ALLOC_SHARED_MEMORY_OUT.pMemBlock,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlFreeSharedMemory
;
; Purpose:      This function frees shared memory for the caller.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlFreeSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].ESC_FREE_SHARED_MEMORY_IN.dwID

        ; Look for this ID in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID
        je      FoundOne
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundOne:
        mov     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
        shr     eax,10H
        call    GN_MemoryFree
        mov     eax,1

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_FREE_SHARED_MEMORY_OUT.dwSuccess,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlGetSharedMemory
;
; Purpose:      This function gets a shared memory ptr allocated
;               at some point in the past.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlGetSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        sub     ebx,ebx
        les     bx,lpIn
        mov     edx,es:[ebx].ESC_GET_SHARED_MEMORY_IN.dwID

        ; Look for this ID in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     edx,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID
        je      FoundIt
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundIt:
        mov     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_GET_SHARED_MEMORY_OUT.pMemBlock,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlSetCursor
;
; Purpose:      This function sets a cursor.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlSetCursor, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; We allow applications to directly set the cursor, allowing
        ; cursors that are different sized from what Windows will allow.
        ; Also, other formats are supported for debug builds.
        push    dword ptr lpIn
        call    GENERIC_SetCursor
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_DvdMacrovisionCommand
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_DVD_MACROVISION_CMD.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             appropriate macrovision returns
;
; Preserve:
;==============================================================================
DECPROC GN_DvdMacrovisionCommand, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; If this is not the first ID that has been set AND it does not
        ; match the current ID, then there is an error.
        mov     eax,ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID
        or      eax,eax
        je      @F
        sub     ebx,ebx
        les     bx,lpIn
        cmp     eax,es:[ebx].MACROVISION_INFO.dwMacrovisionNavigatorID
        je      @F
        les     di,lpOut
        mov     dword ptr es:[ebx].MACROVISION_INFO.dwMacrovisionData,'DABU'
        sub     eax,eax
        jmp     DoneIt
@@:
        ; The ID is OK. If the display device is a real TV or PAL
        ; system, then save it. Otherwise, we don't care.
        push    edi
        call    GN_GetDevData
        movzx   edx,al
        mov     eax,1
        cmp     edx,DEVTYPE_TV
        jne     DoneIt

        cmp     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,0
        jne     DoneIt
        sub     ebx,ebx
        les     bx,lpIn
        mov     edx,es:[ebx].MACROVISION_INFO.dwMacrovisionNavigatorID
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,edx
        sub     eax,eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_OpenGLGetInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is OPENGL_GETINFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               eax                     1
;               If the first dword in the lpIn ptr is GETINFO_DRVNAME
;               then the lpOut ponts to a OPENGL_GETINFO structure.
;               You should fill in the relevant feilds and return eax = 1.
;               If the first dword of lpIn is not GETINFO_DRVNAME
;               or it is, but you can't fill in the releveant fields
;               return eax = 0.
;
; Preserve:
;==============================================================================
DECPROC GN_OpenGLGetInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        sub     eax,eax
        cmp     dword ptr es:[edi],OPENGL_GETINFO_DRVNAME
        jne     DoneIt

        movzx   eax,word ptr lpOut+0
        movzx   ecx,word ptr lpOut+2
        lea     eax,[eax].OPENGL_INFO.awch
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    ecx
        push    eax
        call    HW_GetOpenGLRegistryName

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].OPENGL_INFO.ulVersion,eax
        mov     es:[edi].OPENGL_INFO.ulDriverVersion,ebx
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_OpenGLCommand
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is OPENGL_CMD.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax                     0
;
; Preserve:
;==============================================================================
DECPROC GN_OpenGLCommand, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_VideoParameters
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is VIDEO_PARAMETERS.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax                     0
;
; Preserve:
;==============================================================================
DECPROC GN_VideoParameters, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        push    OFFSET VpRet
        cmp     es:[edi].VIDEOPARAMETERS.dwCommand,VP_COMMAND_GET
        je      GN_VpCommandGet
        cmp     es:[edi].VIDEOPARAMETERS.dwCommand,VP_COMMAND_SET
        je      GN_VpCommandSet
        add     sp,@WordSize
        sub     eax,eax
VpRet:
CLOSEPROC


;==============================================================================
;
; Function:     GN_VpCommandGet
;
; Purpose:      This function is called when the escape is
;               VIDEO_PARAMETERS and the specific flavor is
;               VP_COMMAND_GET.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX
;               es:edi          VIDEOPARAMETERS ptr
;
; Returns:      eax     value to return to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_VpCommandGet, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
FindTV:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      NextCrtc
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
        mov     es,word ptr lpIn+2
        cmp     al,DEVTYPE_TV
        je      IsTv
NextCrtc:
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      FindTV
        sub     ebx,ebx
        mov     es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_TV_MODE OR VP_FLAGS_TV_STANDARD
        mov     es:[edi].VIDEOPARAMETERS.dwTVStandard,VP_TV_STANDARD_WIN_VGA
        mov     es:[edi].VIDEOPARAMETERS.dwAvailableTVStandard,VP_TV_STANDARD_WIN_VGA
        mov     dwCopyStandard,0
        jmp     GotT
IsTv:
        shr     eax,10H
        mov     ecx,VP_TV_STANDARD_NTSC_M
        cmp     al,TVTYPE_NTSCM
        je      FoundTV
        cmp     al,TVTYPE_NTSCJ
        je      FoundTV
        mov     ecx,VP_TV_STANDARD_PAL_B
FoundTV:
        mov     es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_TV_MODE OR VP_FLAGS_TV_STANDARD
        mov     es:[edi].VIDEOPARAMETERS.dwTVStandard,ecx
        mov     es:[edi].VIDEOPARAMETERS.dwAvailableTVStandard,ecx
        mov     dwCopyStandard,ecx
GotT:
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pHWCrtcCXOffset,eax

        mov     es:[edi].VIDEOPARAMETERS.dwAvailableModes,VP_MODE_WIN_GRAPHICS

        ; Set the maximum unscaled width and height
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_MAX_UNSCALED
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        movzx   ecx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[edi].VIDEOPARAMETERS.dwMaxUnscaledX,eax
        mov     es:[edi].VIDEOPARAMETERS.dwMaxUnscaledY,ecx
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_POSITION
        mov     es:[edi].VIDEOPARAMETERS.dwPositionX,0
        mov     es:[edi].VIDEOPARAMETERS.dwPositionY,0
        mov     es:[edi].VIDEOPARAMETERS.dwCPType,0
        mov     es:[edi].VIDEOPARAMETERS.dwCPStandard,0

        push    pHWCrtcCXOffset
        call    HW_IsMacroVisionEncoderAttached
        or      eax,eax
        je      No_MV

        ; Yes, we have macrovision
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_COPYPROTECT
        mov     es:[edi].VIDEOPARAMETERS.dwCPType,VP_CP_TYPE_APS_TRIGGER
        mov     eax,ds:[esi].GNLOGDEVCX.dwMacrovisionMode
        mov     es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits,eax
        mov     eax,dwCopyStandard
        mov     es:[edi].VIDEOPARAMETERS.dwCPStandard,eax
No_MV:
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_VpCommandSet
;
; Purpose:      This function is called when the escape is
;               VIDEO_PARAMETERS and the specific flavor is
;               VP_COMMAND_SET.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX
;               es:edi          VIDEOPARAMETERS ptr
;
; Returns:      eax     value to return to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_VpCommandSet, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC

        ; The only "set" command we support is CopyProtect
        test    es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_COPYPROTECT
        jz      Fail

        sub     ebx,ebx

        ; We'll be using these local variables.
        ; dwCRTCCount = last non-TV device index.
        ; dwCopyStandard = 1 if we are forcing Macrovision for a non-TV device.
        mov     dwCRTCCount,ebx
        mov     dwCopyStandard,ebx

FindTV1:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      NextCrtc1
        mov     dwCRTCCount,ebx
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
        cmp     al,DEVTYPE_TV
        je      FoundTv
NextCrtc1:
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      FindTV1

        ; If no TV device was found, use the last non-TV device to
        ; make sure the new Macrovision level gets down to the RM.
        mov     ebx,dwCRTCCount
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      SkipToFail
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
                mov     dwCopyStandard,1
        jmp     FoundTv

SkipToFail:
        jmp     Fail

FoundTv:
        mov     es,word ptr lpIn+2
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     pGNCrtcCXOffset,ebx
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pHWCrtcCXOffset,eax

        ; Ask hardware if we have macrovision capability
        push    pHWCrtcCXOffset
        call    HW_IsMacroVisionEncoderAttached
        mov     ebx,pGNCrtcCXOffset
        or      eax,eax
        je      Fail

        ; The only copy protection mechanism we support is APS trigger
        cmp     es:[edi].VIDEOPARAMETERS.dwCPType,VP_CP_TYPE_APS_TRIGGER
        jne     Fail

        ; Are we being asked to activate copy protection?
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_ACTIVATE
        jne     Next1

        ; Try to set the Copy protection
        mov     eax,es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits
        and     eax,3
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jnz     @F
        or      ecx,4
@@:

        push    ecx

        ; If we are forcing Macrovision through a non-TV device to
        ; get the Macrovision level to the RM, use default width/height.
        cmp     dwCopyStandard, 1
        jnz     SkipNormal
        mov     eax,800
        push    eax
        mov     eax,600
        push    eax
        jmp     SkipCommon

        ; Else use normal calculated width and height.
SkipNormal:
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax

SkipCommon:
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        or      eax,eax
        je      Fail

        ; Save current key and bump to next key
        mov     eax,ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey
        mov     ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey,eax
        mov     es:[edi].VIDEOPARAMETERS.dwCPKey,eax
        inc     ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey
        mov     eax,1
        jmp     Done
Next1:
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_DEACTIVATE
        jne     Next2

        ; We can deactivate if the requester has the right key
        mov     eax,DISP_CHANGE_BADPARAM
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey
        cmp     edx,es:[edi].VIDEOPARAMETERS.dwCPKey
        jne     Done
        sub     eax,eax
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jz      @F
        mov     ecx,4
@@:
        push    ecx
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        jmp     Done
Next2:
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_CHANGE
        jne     Next3

        ; We can change the CP if the requester has the right key
        mov     eax,DISP_CHANGE_BADPARAM
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey
        cmp     edx,es:[edi].VIDEOPARAMETERS.dwCPKey
        jne     Done
        mov     eax,es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits
        and     eax,3
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jz      WasNotProt
        or      ecx,ecx
        jnz     ChangeProt
ChangeBrightness:
        or      ecx,4
        jmp     ChangeProt
WasNotProt:
        or      ecx,ecx
        jnz     ChangeBrightness
ChangeProt:
        push    ecx
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        jmp     Done
Next3:
Fail:
        sub     eax,eax
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLocalRegistryPath
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_LOCAL_REGISTRY_PATH.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetLocalRegistryPath, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the logical context
        mov     esi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        sub     edi,edi
        les     di,lpOut
        mov     ecx,4
        mov     eax,dword ptr ds:[esi].GNBOARDCX.szLocalDisplayBasePath
        mov     es:[edi],eax
@@:
        mov     al,ds:[esi].GNBOARDCX.szLocalDisplayBasePath[ecx]
        mov     es:es:[edi][ecx],al
        inc     ecx
        or      al,al
        jne     @B

        ; Tack on NVidia to the end of it
        mov     dword ptr es:[edi][ecx - 1],'ivN\'
        mov     dword ptr es:[edi][ecx + 3],'aid'
        mov     eax,1
CLOSEPROC



;==============================================================================
;
; Function:     GN_GetRegistryModeList
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_REGISTRY_MODE_LIST.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetRegistryModeList, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Find an available GNCRTCCX ptr, just so we can use
        ; the DISPDATA structure from it
        mov     edx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        sub     eax,4
        sub     ecx,ecx

@@:     add     eax,4
        cmp     ecx,ds:[eax]
        jne     @F
        dec     edx
        jne     @B
        sub	eax,eax
        jmp	LastPart
@@:
        ; If lpIn is NULL, we want to return the number of modes,
        ; which means that we should pass in a NULL ptr for the modelist.
        mov     edx,MODETYPE_MODEENTRY
        sub     ebx,ebx
        cmp     lpIn,0
        je      @F

        ; Check lpIn
        mov     edx,MODETYPE_MODEENTRYNORR
        mov     ebx,lpOut
        les     di,lpIn
        cmp     dword ptr es:[di],MODETYPE_MODEENTRYANDPITCH
        ja      @F
        mov     edx,es:[di]
@@:
        mov     eax,ds:[eax]
        push    ds:[eax].GNCRTCCX.lpNvmodeDispData
        push    ebx
        push    edx
        CALLFAR16IND lpfnGetModeList,es,ax

LastPart:
        ; If lpIn was NULL, then we want to return the number of modes
        cmp     lpIn,0
        jne     @F
        les     di,lpOut
        movzx   eax,ax
        mov     es:[di],eax
@@:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetPrimaryInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_PRIMARY_INFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetPrimaryInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        les     di,lpIn
        mov     eax,es:[di].NV_PRIMARY_INFO.ulHeadNum
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jae     FailIt

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    eax
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      FailIt
        mov     esi,ebx

Success:
        les     di,lpOut
        mov     es:[di].NV_PRIMARY_INFO.ulReturnCode,1
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     es:[di].NV_PRIMARY_INFO.ulWidth2,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[di].NV_PRIMARY_INFO.ulHeight,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     es:[di].NV_PRIMARY_INFO.ulDepth,eax
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        mov     es:[di].NV_PRIMARY_INFO.ulPitch,eax
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        mov     es:[di].NV_PRIMARY_INFO.ulPrimarydwOffset,eax
        mov     eax,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     es:[di].NV_PRIMARY_INFO.ulNumActiveDACs,eax
        sub     eax,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPanningPtr,eax
        mov     es:[di].NV_PRIMARY_INFO.ulFullscreenPtr,eax
        jmp     DoneIt

FailIt:
        ; Clear out everything to zero
        les     di,lpOut
        sub     eax,eax
        mov     es:[di].NV_PRIMARY_INFO.ulReturnCode,eax
        mov     es:[di].NV_PRIMARY_INFO.ulWidth2,eax
        mov     es:[di].NV_PRIMARY_INFO.ulHeight,eax
        mov     es:[di].NV_PRIMARY_INFO.ulDepth,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPitch,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPrimarydwOffset,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPanningPtr,eax
        mov     es:[di].NV_PRIMARY_INFO.ulFullscreenPtr,eax

DoneIt:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetRegistryDesktopModeList
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetRegistryDesktopModeList, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Find an available GNCRTCCX ptr, just so we can use
        ; the DISPDATA structure from it
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     edx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        sub     eax,4
        sub     ecx,ecx

@@:     add     eax,4
        cmp     ecx,ds:[eax]
        jne     @F
        dec     edx
        jne     @B
        sub	eax,eax
        jmp	LastPart
@@:
        ; If lpIn is NULL, we want to return the number of modes,
        ; which means that we should pass in a NULL ptr for the modelist.
        mov     edx,MODETYPE_MODEENTRY
        sub     ebx,ebx
        cmp     lpIn,0
        je      @F

        ; Check lpIn
        mov     edx,MODETYPE_MODEENTRYNORR
        mov     ebx,lpOut
        les     di,lpIn
        cmp     dword ptr es:[di],MODETYPE_MODEENTRYANDPITCH
        ja      @F
        mov     edx,es:[di]
@@:
        mov     eax,ds:[eax]
        push    ds:[eax].GNCRTCCX.lpNvmodeDispData
        push    ebx
        push    edx
        CALLFAR16IND lpfnGetDesktopModeList,es,ax

LastPart:
        ; If lpIn was NULL, then we want to return the number of modes
        cmp     lpIn,0
        jne     @F
        les     di,lpOut
        movzx   eax,ax
        mov     es:[di],eax
@@:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_QueryHeadRefreshRate
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is ESC_NV_QUERY_HEAD_REFRESH_RATE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_QueryHeadRefreshRate, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        les     di,lpIn
        mov     eax,es:[di]                     ;Head number
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jae     FailIt

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    eax
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      FailIt
        mov     esi,eax

        lea     esi,ds:[esi].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[esi].MODEINFO.dwRefreshRate
        les     di,lpOut
        mov     es:[di],eax
        jmp     DoneIt

FailIt:
        les     di,lpOut
        sub     eax,eax
        mov     es:[di],eax

DoneIt:
        mov     eax,1
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP16.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp16.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 16bpp dst bitmap.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To16WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 16bpp RGB value is pulled out of the table
;               and written as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To16WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        movzx   eax,byte ptr ds:[esi]
        inc     esi
        and     eax,0FH
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     ax,fs:[ebx][eax * 2]
        mov     cx,fs:[ebx][ecx * 2]
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        movzx   eax,byte ptr ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer4To16DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 16bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To16DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To16WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To16WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        shr     eax,10H
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     cx,fs:[ebx][eax * 2]
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To16DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 16bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To16DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,2
        jl      CheckLastPixels

ChunksOf2:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        movzx   ecx,al
        movzx   edx,ah
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        shld    eax,ecx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,ch
        sub     al,2
        cmc
        sbb     ch,ch
        and     al,ch
        shr     ax,2

        sub     cl,04
        cmc
        sbb     ch,ch
        and     cl,ch

        shl     ecx,18H
        shld    eax,ecx,05
        mov     es:[edi+0],ax

        shld    eax,edx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,dh
        sub     al,2
        cmc
        sbb     dh,dh
        and     al,dh
        shr     ax,2

        sub     dl,04
        cmc
        sbb     dh,dh
        and     dl,dh

        shl     edx,18H
        shld    eax,edx,05
        mov     es:[edi+2],ax

        add     edi,4
        sub     dwTempExtX,2
        cmp     dwTempExtX,2
        jge     ChunksOf2

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,fs:[ebx][eax * 4]
        shld    eax,ecx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,ch
        sub     al,2
        cmc
        sbb     ch,ch
        and     al,ch
        shr     ax,2

        sub     cl,04
        cmc
        sbb     ch,ch
        and     cl,ch

        shl     ecx,18H
        shld    eax,ecx,05
        mov     es:[edi],ax

        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 15bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     ax,ds:[esi+0]
        mov     cx,ds:[esi+2]
        add     esi,4
        ror     eax,5
        ror     ecx,5
        shl     ax,1
        shl     cx,1
        rol     eax,5
        rol     ecx,5
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     ax,ds:[esi]
        add     esi,2
        ror     eax,5
        shl     ax,1
        rol     eax,5
        mov     es:[edi],ax
        add     edi,2

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 16bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. In fact, no conversion is needed at all.
;               Just copy the src to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Let's compute the optimal inner loop. Basically, there
        ; is either 0 or 1 word to get dword aligned (a left edge),
        ; then 0 or more dwords (middle), and finally there may be
        ; an extra word on the end (right edge).
        mov     edx,dwExtX
        add     edx,edx
        mov     eax,esi
        and     eax,2
        sub     edx,eax
        mov     ecx,edx
        shr     eax,1
        cmp     edx,3
        adc     eax,eax
        and     ecx,2
        cmp     ecx,1
        adc     eax,eax
        xor     eax,3
        shr     edx,2
        jmp     NEAR PTR cs:JmpTable[eax * 4]

JmpTable:
DD      OFFSET L0_M0_R0,OFFSET L0_M0_R1,OFFSET L0_MX_R0,OFFSET L0_MX_R1
DD      OFFSET L1_M0_R0,OFFSET L1_M0_R1,OFFSET L1_MX_R0,OFFSET L1_MX_R1

L1_MX_R1:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R1
        jmp     Done

L1_MX_R0:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R0
        jmp     Done

L1_M0_R1:
        movs    dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_M0_R1
        jmp     Done

L0_MX_R1:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R1
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

L1_M0_R0:
L0_M0_R1:
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_M0_R1

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 24bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     cl,ds:[esi+5]
        shl     ecx,10H
        mov     cx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 32bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     eax,ds:[esi]
        add     esi,4
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gndibs.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibs.asm
;
; Purpose:      This file implements some of the optimization routines
;               for specific portions of benchmarks or apps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

IF 0
	; FOR SetDIBItsToDevice, these are the widths that have
	; alot of repeated pixels
        cmp     ecx,2EAH
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1E2H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1C0H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,208H
        je      HW_SetDIBitsSingleScan_Sizeable
        jmp     Not_Sizeable
ENDIF

IF 0
	; FOR StretchDIBits, these are the widths that have
	; alot of repeated pixels
        cmp     ecx,2E8H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1E2H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1C0H
        je      HW_SetDIBitsSingleScan_Sizeable
        jmp     Not_Sizeable
ENDIF


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC	dwEnableDibRunLengths
dwEnableDibRunLengths	DD	0

;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp32
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 32bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp32, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        lea     esi,[edx][eax * 4]
@@:
        movzx   eax,byte ptr es:[ebx]
        inc     ebx
        mov     edx,fs:[edi][eax * 4]
        mov     gs:[esi],edx
        add     esi,4
        dec     ecx
        jne     @B
        mov     eax,1
	ret

RunLengths:
        lea     esi,[edx][eax * 4]

NextRun32:
        ; Load up the first src pixel
        movzx   eax,byte ptr es:[ebx]
        mov     edx,fs:[edi + eax * 4]
        imul    eax,1010101H
        cmp     ecx,4
        jl      Tl2

        ; Do the run cppropriately
@@:     cmp     eax,es:[ebx]
        jne     EndDwordRun32
        mov     gs:[esi + 00H],edx
        mov     gs:[esi + 04H],edx
        mov     gs:[esi + 08H],edx
        mov     gs:[esi + 0CH],edx
        add     esi,10H
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl2:
        or      ecx,ecx
        je      EndLine

EndDwordRun32:
@@:
        cmp     al,es:[ebx]
        jne     EndByteRun32
        mov     gs:[esi],edx
        add     esi,4
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun32:
        or      ecx,ecx
        jne     NextRun32

EndLine:
	mov	eax,1
	ret
ENDPROC


;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp16
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 16bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
; 		edx     y * deltascan + deBitsOffset
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp16, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        push    ebp
        lea     esi,[edx][eax * 2]
back:
        movzx   edx,byte ptr es:[ebx]
        inc     ebx
        movzx   eax,byte ptr fs:[edi + edx * 4 + 0]
        movzx   ebp,byte ptr fs:[edi + edx * 4 + 1]
        movzx   edx,byte ptr fs:[edi + edx * 4 + 2]

        sub     eax,4
        jnc     @F
        sub     eax,eax
@@:     sub     ebp,2
        jnc     @F
        sub     ebp,ebp
@@:     sub     edx,4
        jnc     @F
        sub     edx,edx
@@:     shr     ebp,2
        shr     edx,3
        shr     eax,3
        shl     ebp,5
        shl     edx,0BH
        or      eax,ebp
        or      eax,edx
        mov     gs:[esi],ax
        add     esi,2
        dec     ecx
        je      done1
        movzx   edx,byte ptr es:[ebx - 1]
@@:
        cmp     dl,es:[ebx]
        jne     back
        inc     ebx
        mov     gs:[esi],ax
        add     esi,2
        dec     ecx
        jne     @B
done1:
        pop     ebp
        mov     eax,1
        ret


RunLengths:
        lea     esi,[edx][eax * 2]

NextRun16:
        ; Load up the first src pixel
        movzx   edx,byte ptr es:[ebx]

        ; Remap the color into edx
        push    ebx
        movzx   eax,byte ptr fs:[edi + edx * 4 + 0]
        movzx   ebx,byte ptr fs:[edi + edx * 4 + 1]
        movzx   edx,byte ptr fs:[edi + edx * 4 + 2]
        sub     eax,4
        jnc     @F
        sub     eax,eax
@@:     sub     ebx,2
        jnc     @F
        sub     ebx,ebx
@@:     sub     edx,4
        jnc     @F
        sub     edx,edx
@@:     shr     ebx,2
        shr     edx,3
        shr     eax,3
        shl     ebx,5
        shl     edx,0BH
        or      eax,ebx
        or      eax,edx
        pop     ebx

        ; get the color into both words
        shrd    edx,eax,10H
        mov     dx,ax

        ; Now get the src pixel again into all 4 bytes of eax
        movzx   eax,byte ptr es:[ebx]
        imul    eax,1010101H

        ; Go into the dword loop if there are enough pixels left
        cmp     ecx,4
        jl      Tl1

        ; Do the run cppropriately
@@:     cmp     eax,es:[ebx]
        jne     EndDwordRun16
        mov     gs:[esi + 00H],edx
        mov     gs:[esi + 04H],edx
        add     esi,8
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl1:
        or      ecx,ecx
        je      EndLine

EndDwordRun16:
@@:
        cmp     al,es:[ebx]
        jne     EndByteRun16
        mov     gs:[esi],dx
        add     esi,2
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun16:
        or      ecx,ecx
        jne     NextRun16

EndLine:
        mov     eax,1
        ret
ENDPROC


;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp8
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 8bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
; 		edx     y * deltascan + deBitsOffset
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp8, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        lea     esi,[edx][eax]

Next_Pixel:
        movzx   edx,byte ptr es:[ebx]
        inc     ebx
        mov     al,fs:[edi][edx * 2]
        mov     gs:[esi],al
        inc     esi
        dec     ecx
        jne     Next_Pixel
        mov     eax,1
        ret

RunLengths:
        lea     esi,[edx][eax]

NextRun8:
        ; Load up the first src pixel
        movzx   edx,byte ptr es:[ebx]
        movzx   eax,byte ptr fs:[edi + edx * 2]
        imul	edx,1010101H
        imul    eax,1010101H
        cmp     ecx,4
        jl      Tl2

        ; Do the run cppropriately
@@:     cmp     edx,es:[ebx]
        jne     EndDwordRun8
        mov     gs:[esi + 00H],eax
        add     esi,4
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl2:
        or      ecx,ecx
        je      EndLine

EndDwordRun8:
@@:
        cmp     dl,es:[ebx]
        jne     EndByteRun8
        mov     gs:[esi],al
        add     esi,4
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun8:
        or      ecx,ecx
        jne     NextRun8

EndLine:
	mov	eax,1
	ret
ENDPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibblt.asm
;
; Purpose:      This file holds the DibBlt display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_DibBlt
;
; Purpose:      This function is the DibBlt display driver entry point.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_DibBlt, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   iStart
PARMW   cScans
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpDrawMode
PARMD   lpTranslate

LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwPhysColor
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        sub     eax,eax
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0
        mov     ds,word ptr lpDIBInfo+2
        movzx   edi,word ptr lpDIBInfo+0

        ; not handling negative cScans case
        cmp     ax,cScans
        jge     GN_DibBltPunt

        ; The case where lpDIBBits is NULL is a sizing request -- punt it
        cmp     eax,lpDIBBits
        je      GN_DibBltPuntNoWait

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and src is mono, then punt it.
        cmp     gs:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     ds:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_DibBltPunt
        ; It we're reading from 8bpp screen, then punt it. 
        cmp     fGet,0
        jne     GN_DibBltPunt
@@:
ELSE
        ; If the dst is 8bpp, then punt it.
        cmp     gs:[esi].DIBENGINE.deBitsPixel,8
        je      GN_DibBltPunt
ENDIF

        ; We only do RGB DIBs (No Compression)
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_RGB
        jne     GN_DibBltPunt

        ; If the bitmap is not in VRAM, then punt it.
        cmp     ax,gs:[esi].DIBENGINE.deType
        je      GN_DibBltPuntNoWait

        test    gs:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_DibBltPuntNoWait

        ; Clip the call now since we are going to handle it
        call    GN_DibBltClip
        or      eax,eax
        je      GN_DibBltSuccess

        ; Syncronize with other drawing components
        mov     fs,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     fs:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_DibBltPunt

        ; Is this a DIB->Bitmap or Bitmap->DIB conversion
        cmp     fGet,0
        jne     GN_DibBltGet
        cmp     ds:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_DibBltSetColor
        jmp     GN_DibBltSetMono

GENERIC_DibBlt  ENDP


;==============================================================================
;
; Functions:    DibBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of DibBlt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_DibBltPunt
GN_DibBltPunt     PROC    NEAR
        ; If the bitmap is in VRAM, then we must wait for idle
        ; because the DIBENG will not.
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0
        cmp     gs:[esi].DIBENGINE.deType,0
        je      GN_DibBltPuntNoWait
        test    gs:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_DibBltPuntNoWait
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
        .errnz  $ - OFFSET GN_DibBltPuntNoWait
GN_DibBltPunt   ENDP

PUBLIC  GN_DibBltPuntNoWait
GN_DibBltPuntNoWait PROC    NEAR
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
        test    gs:[esi].DIBENGINEHDR.deFlags,PALETTIZED
        setne   al
        movzx   eax,al
        POPR    ds,esi,edi
        STOPPROC
        pop     ecx
        push    ax
        push    ecx
PLABEL  Punt_DibBlt
        jmp     DIB_DibBltExt
GN_DibBltPuntNoWait ENDP


PUBLIC  GN_DibBltSuccess
GN_DibBltSuccess  PROC    NEAR
        movzx   eax,cScans
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1AH
GN_DibBltSuccess  ENDP


;==============================================================================
;
; Function:     GN_DibBltSetMono
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;               The operation is from a DIB to a Bitmap and the DIB is mono.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltSetMono
GN_DibBltSetMono        PROC    NEAR

        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        sub     ecx,ecx
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    ecx
        push    ecx
        push    dwExtX
        push    dwExtY

        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        push    lpDstDev
        mov     eax,dword ptr ds:[edi].BitmapInfo.bmiColors[0]
        bswap   eax
        ror     eax,8
        push    eax
        push    esi
        call    GENERIC_ColorInfo
        push    dwPhysColor

        cmp     ds:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        push    lpDstDev
        mov     eax,dword ptr ds:[edi].BitmapInfo.bmiColors[4]
        bswap   eax
        ror     eax,8
        push    eax
        push    esi
        call    GENERIC_ColorInfo
@@:     push    dwPhysColor

        sub     eax,eax
        mov     edx,07FFFH
        pushd   0CC0000H                        ; Rop3
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    eax                             ; fill bytes

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltSetMono        ENDP


;==============================================================================
;
; Function:     GN_DibBltSetColor
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the color transfer.
;               The operation is from a DIB to a Bitmap and the DIB is color.
;               (this could be a 4, 8, 15, 16, 24, or 32bpp DIB.)
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltSetColor
GN_DibBltSetColor       PROC    NEAR

        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,ds:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibBltPunt
        inc     ecx
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibBltPunt
@@:
        ; For this conversion, we use color transfer
        mov     es,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    es:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   edx,word ptr lpDIBBits+2
        sub     eax,eax
        push    edx
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    eax                             ; dwSrcLeft
        push    eax                             ; dwSrcTop
        push    dwExtX
        push    dwExtY

        pushd   0CC0000H
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     gs:[esi].DIBENGINEHDR.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     bx,ds
        shl     ebx,10H
        lea     bx,[di].BitmapInfo.bmiColors
        mov     edx,ds:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltSetColor       ENDP


;==============================================================================
;
; Function:     GN_DibBltGet
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the DMA back transfer
;               interleaved with the copy into the correct system
;               memory bitmap.
;               The operation is from a Bitmap to a DIB.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltGet
GN_DibBltGet    PROC    NEAR

        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   eax,ds:[edi].BitmapInfoHeader.biBitCount
        cmp     eax,10H
        jne     @F
        mov     eax,0FH
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibBltPunt
        inc     eax
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibBltPunt
@@:
        ; Use the GetVramBitmap to interleave DMA and conversion
        push    cs:[CSpGNLogicalDevice]
        sub     edx,edx
        push    edx
        push    lpDIBInfo
        movzx   ecx,word ptr lpDIBBits+2
        push    ecx
        push    dwDibBitsOffset
        push    eax
        push    dwDibPitch
        push    edx             ; dwDibLeft
        push    edx             ; dwDibTop

        push    lpDstDev        ; It's called dstdev but it is really the src
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    gs:[esi].DIBENGINEHDR.deBitsOffset
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        push    dwExtX
        push    dwExtY
        pushd   0CC0000H
        push    edx             ; lpBrush
        push    lpDrawMode      ; lpDrawMode
        push    edx             ; pfnCopyXlat :Let called func figure it out

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltGet    ENDP


;==============================================================================
;
; Function:     GN_DibBltClip
;
; Purpose:      This function clips the DIB and Bitmap for DibBlt.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     ds,edi,gs
;==============================================================================
PUBLIC  GN_DibBltClip
GN_DibBltClip   PROC    NEAR

        ; If there is nothing to do, then report all clipped
        movsx   ecx,cScans
        or      ecx,ecx
        je      AllClipped

        ; Ext X = minimum (Bitmap Width, DIB width)
        movsx   eax,gs:[esi].DIBENGINE.deWidth
        mov     edx,ds:[edi].BitmapInfoHeader.biWidth
        cmp     eax,edx
        jl      @F
        mov     eax,edx
@@:     mov     dwExtX,eax

        ; Compute the unsigned DIB pitch. We will make it signed to
        ; indicate DIB orientation later when we adjust the bits ptr.
        movzx   eax,ds:[edi].BitmapInfoHeader.biBitCount
        mov     ecx,ds:[edi].BitmapInfoHeader.biWidth
        imul    eax,ecx
        add     eax,31
        and     eax,NOT 31
        shr     eax,3
        mov     dwDibPitch,eax
        movzx   edx,word ptr lpDIBBits
        mov     dwDibBitsOffset,edx

        ; Based upon the sign of the DIB height, adjust for DIB orientation.
        mov     edx,ds:[edi].BitmapInfoHeader.biHeight
        or      edx,edx
        js      @F
        movzx   ecx,cScans
        dec     ecx
        imul    ecx,eax
        add     dwDibBitsOffset,ecx
        neg     eax
        mov     dwDibPitch,eax
        neg     edx
@@:     neg     edx

        ; The only thing left is Bitmap top and bottom coords
        movsx   ebx,iStart
        movsx   ecx,cScans
        sub     edx,ebx
        sub     edx,ecx
        mov     dwBmpTop,edx
        sub     edx,edx
        mov     dwExtY,ecx
        mov     dwBmpLeft,edx
        mov     eax,1
        ret

AllClipped:
        sub     eax,eax
        ret

GN_DibBltClip   ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibdev.asm
;
; Purpose:      This file holds the SetDIBitsToDevice display driver
;               entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_SetDIBitsToDevice
;
; Purpose:      This function is the SetDIBitsToDevice driver entry point.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetDIBitsToDevice, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wInitScan
PARMW   wNumScans
PARMD   lpClipRect
PARMD   lpDrawMode
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
LOCALD  dwBmpBitsPixel
LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwDibLeft
LOCALD  dwDibTop
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwDibWidth
LOCALD  dwDibHeight
LOCALD  lpPhysColor
LOCALD  dwPhysColor
LOCALD  dwFlagSecondPhysColorPresent
OPENPROC
        PUSHR   ds,esi,edi
        sub     esi,esi
        sub     edi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        lfs     di,lpDIBInfo

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_DibDevPunt

        ; We only do RGB DIBs (No Compression)
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_RGB
        jne     GN_DibDevPunt

IF DIB_PROCESS_SINGLESCAN
        ; Special case the 8bpp dibs that are 1 scanline high,
        ; where wInitScan = 0 and wNumScans = 1.
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biHeight,1
        jne     @F
        movzx   eax,wInitScan
        movzx   ecx,wNumScans
        or      eax,eax
        jne     @F
        cmp     ecx,1
        je      GN_SetDIBitsSingleScan
@@:
ENDIF

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and src is mono, then punt it.
        cmp     ds:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_DibDev8BppPunt
@@:
ELSE
        ; If the dst is 8bpp, then punt it. Already handled SingleScan case.
        cmp     ds:[esi].DIBENGINE.deBitsPixel,8
        je      GN_DibDev8BppPunt
ENDIF

        ; First, clip the DIB
        call    GN_SetDIBitsToDeviceClip
        or      eax,eax
        je      GN_DibDevExit
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Break the call out into cases.
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_SetColorDibToDevice
        jmp     GN_SetMonoDibToDevice
ENDPROC


;==============================================================================
;
; Function:     SetDIBitsToDevice ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of SetDIBitsToDevice. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_DibDevPunt
GN_DibDevPunt   PROC    NEAR
        push    lpDstDev
        push    wDstX
        push    wDstY
        push    wInitScan
        push    wNumScans
        push    lpClipRect
        push    lpDrawMode
        push    lpDIBBits
        push    lpDIBInfo
        push    lpTranslate
PLABEL  Punt_DibToDevice
        call    DIB_DibToDevice
        .errnz  $ - OFFSET GN_DibDevExit

GN_DibDevPunt   ENDP

PUBLIC  GN_DibDevExit
GN_DibDevExit   PROC    NEAR
        POPR    ds,esi,edi
        mov     sp,bp
        mov     ecx,ss:[ebp + 4]
        pop     ebp
IF DIB_FAST_EXIT
        cmp     ax,-1
        je      @F
        cmp     cs:[bUseSetDIBitsFastExit],0
        je      @F
        cmp     ecx,cs:[lpfnGdiCode03_2119]
        jne     @F
        add     sp,4 + 20H
        jmp     GdiCode03_2119
@@:
ENDIF
        ; Clean and return normally
        RETFAR16 20H
GN_DibDevExit   ENDP


;==============================================================================
;
; Function:     GN_DibDev8BppPunt (SetDIBitsToDevice ending routine)
;
; Purpose:      This function is a work-around for a bug in the
;               DIBEngine DIB compiler.  At 8bpp, if the destination
;               bitmap is not word aligned (i.e. (wDestX & 1) == 1)
;               AND the clip rect is one (1) pixel wide AND the clip
;               rect is misaligned by 3 (i.e. (wClipLeft & 3) == 3),
;               AND the stretch is 1:1, then the DIB compiler will
;               fail to compile the code to do the pixel copy
;               (tested in the 16bpp source case) but will compile
;               the epilogue code incrementing the source and dest
;               pointers furiously.
;               The result of this is somewhat unsatisfying.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
DECPROC GN_DibDev8BppPunt, PASCAL, NOFRAME, NEAR
OPENPROC
        test    wDstX,1                 ; Check for unaligned destination
        jz      GN_DibDevPunt
        xor     esi,esi
        cmp     word ptr [lpClipRect + 2],si
        jz      GN_DibDevPunt
        lfs     si,lpClipRect

        movzx   eax,fs:[esi].RECT.left
        inc     eax
        cmp     ax,fs:[esi].RECT.right  ; Check if clip is 1 pixel wide
        jnz     GN_DibDevPunt
        and     eax,3                   ; Check for (clipleft mod 4) == 3
        jnz     GN_DibDevPunt

        ; Clean and return a failure normally
        POPR    ds,esi,edi
        mov     sp,bp
        mov     eax,-1
        pop     ebp
        RETFAR16 20H
ENDPROC


;==============================================================================
;
; Function:     GN_SetMonoDibToDevice
;
; Purpose:      This function is jumped to from the SetDIBitsToDevice
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the SetDIBitsToDevice ending routines.
;
;==============================================================================
DECPROC GN_SetMonoDibToDevice, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        ; The bg and fg colors come from the color table at end of DIB
        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        mov     lpPhysColor,esi

        mov     esi,dword ptr fs:[edi].BitmapInfo.bmiColors[0]
        cmp     fs:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        mov     edi,dword ptr fs:[edi].BitmapInfo.bmiColors[4]
        push    lpDstDev
        bswap   edi
        ror     edi,8
        push    edi
        push    lpPhysColor
        call    GENERIC_ColorInfo
        mov     edi,dwPhysColor
@@:
        push    lpDstDev
        bswap   esi
        ror     esi,8
        push    esi
        push    lpPhysColor
        call    GENERIC_ColorInfo

        ; push two translated colors
        push    dwPhysColor
        push    edi

        mov     ecx,0CC0000H
        mov     edx,07FFFH
        sub     ebx,ebx
        push    ecx                             ; Rop3
        push    ebx                             ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    ebx                             ; fill bytes

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_DibDevPunt
        movzx   eax,wNumScans
        jmp     GN_DibDevExit
ENDPROC


;==============================================================================
;
; Function:     GN_SetColorDibToDevice
;
; Purpose:      This function is jumped to from the SetDIBitsToDevice
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the color transfer.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the SetDIBitsToDevice ending routines.
;
;==============================================================================
DECPROC GN_SetColorDibToDevice, PASCAL, NOFRAME, NEAR
OPENPROC
        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,fs:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibDevPunt
        inc     ecx
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibDevPunt
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   edx,word ptr lpDIBBits+2
        push    edx
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY
        sub     eax,eax
        pushd   0CC0000H
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     ebx,lpDIBInfo
        add     bx,word ptr fs:[edi].BitmapInfoHeader.biSize
        mov     edx,fs:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        je      GN_DibDevPunt
        movzx   eax,wNumScans
        jmp     GN_DibDevExit
ENDPROC


;==============================================================================
;
; Function:     GN_SetDIBitsToDeviceClip
;
; Purpose:      This function clips the DIB and Bitmap for SetDIBitsToDevice.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_SetDIBitsToDeviceClip, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We need this for the clipping.
        xor     esi,esi                 ; clear high word of ESI
        les     si,lpClipRect

        ; Get the width and height of the DIB and compute the signed pitch.
        mov     ecx,fs:[edi].BitmapInfoHeader.biHeight
        mov     edx,fs:[edi].BitmapInfoHeader.biWidth
        movzx   eax,fs:[edi].BitmapInfoHeader.biBitCount
        imul    eax,edx
        add     eax,1FH
        shr     eax,3
        and     eax,NOT 3
        neg     ecx
        jns     @F
        neg     ecx
        neg     eax
@@:     mov     dwDibWidth,edx
        mov     dwDibHeight,ecx
        mov     dwDibPitch,eax

        ; Bitmap Top = maximum(pClipRect->top, wDstY);
        movsx   eax,wDstY
        movsx   ecx,es:[esi].RECT.top
        mov     ebx,eax
        cmp     eax,ecx
        jge     @F
        mov     eax,ecx
@@:
        ; Bitmap Top = maximum (0, wDstY)
        ; Dib Top = maximum (0, wDstY) - wDstY
        or      eax,eax
        jge     @F
        sub     eax,eax
@@:     mov     dwBmpTop,eax
        sub     eax,ebx
        mov     dwDibTop,eax

        ; wClippedNumScans = mimimum (DibHeight - wInitScan, wNumScans)
        mov     edx,dwDibHeight
        movsx   eax,wInitScan
        movsx   ecx,wNumScans
        sub     edx,eax
        cmp     edx,ecx
        jle     @F
        mov     edx,ecx
@@:     or      edx,edx
        jle     AllClipped

        ; Bitmap Bottom = mimimum (lpClipRect->bottom, wDstY + wClippedNumScans)
        movzx   eax,es:[esi].RECT.bottom
        add     ebx,edx
        cmp     ebx,eax
        jl      @F
        mov     ebx,eax
@@:     sub     ebx,dwBmpTop
        jle     AllClipped
        mov     dwExtY,ebx

        ; Bitmap Left = maximum(pClipRect->left, wDstX);
        movsx   eax,wDstX
        movsx   ecx,es:[esi].RECT.left
        mov     ebx,eax
        cmp     eax,ecx
        jge     @F
        mov     eax,ecx
@@:
        ; Bitmap Left = maximum (0, wDstX)
        ; Dib Left = maximum (0, wDstX) - wDstX
        or      eax,eax
        jge     @F
        sub     eax,eax
@@:     mov     dwBmpLeft,eax
        sub     eax,ebx
        mov     dwDibLeft,eax

        ; Bitmap Right = minimum(lpClipRect->right, wDstX + DibWidth)
        ; SetDib X Ext = Bitmap Right - Bitmap Left
        mov     eax,dwDibWidth
        movsx   ecx,es:[esi].RECT.right
        add     eax,ebx
        cmp     eax,ecx
        jl      @F
        mov     eax,ecx
@@:     sub     eax,dwBmpLeft
        jle     AllClipped
        mov     dwExtX,eax

        ; Make a ptr to the DIB Bits based upon the orientation of the
        ; DIB (right side up or upside down).
        mov     ecx,dwDibPitch
        movzx   ebx,word ptr lpDIBBits
        or      ecx,ecx
        jg      @F
        mov     edx,dwDibHeight
        neg     ecx
        dec     edx
        imul    ecx,edx
        add     ebx,ecx
@@:     mov     dwDibBitsOffset,ebx

        mov     eax,1
        ret

AllClipped:
        sub     eax,eax
        ret
ENDPROC


IF DIB_PROCESS_SINGLESCAN
;==============================================================================
;
; Function:     GN_SetDIBitsSingleScan
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsToDevice
;               when the generic code has determined that the call
;               matches this special case: the DIB is 8bpp, 1 scanline
;               high, wInitScan = 0, and wNumScans = 1.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      None
;               This routine jumps to other routines which eventually
;               jump to GN_DibDevExit with the proper return code for
;               the SetDIBitsToDevice call when they are done.
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_SetDIBitsSingleScan, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        mov     dwBmpBitsPixel,eax

        sub     esi,esi
        les     si,lpClipRect
        sub     eax,eax

        ; clip top and bottom
        movsx   edx,wDstY
        movsx   ebx,es:[esi].RECT.top
        cmp     edx,ebx
        jl      GN_DibDevExit
        movsx   ebx,es:[esi].RECT.bottom
        sub     ebx,edx
        cmp     ebx,fs:[edi].BitmapInfoHeader.biHeight
        jg      GN_DibDevExit

        ; clip left
        movsx   eax,wDstX
        movsx   ecx,es:[esi].RECT.left
        sub     ebx,ebx
        cmp     eax,ecx
        jge     @F
        mov     ebx,ecx
        sub     ebx,eax
        mov     eax,ecx
@@:
        ; clip right
        movsx   ecx,es:[esi].RECT.right
        sub     ecx,eax
        cmp     ecx,fs:[edi].BitmapInfoHeader.biWidth
        jg      GN_DibDevExit

        ; At this point:
        ; eax = clipped DstX
        ; ebx = number src pixels clipped on left edge
        ; ecx = clipped ExtX
        ; edx = clipped DstY

        ; Load up the src ptr
        movzx   esi,word ptr lpDIBBits
        mov     es,word ptr lpDIBBits+2
        add     ebx,esi

        ; Point to the color table
        mov     esi,cs:[CSpGNLogicalDevice]
        add     edi,fs:[edi].BitmapInfoHeader.biSize

        ; Get the dst ptr in gs:edx
        imul    edx,ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        add     edx,ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        mov     gs,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector

        ; Sync with the hardware
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess

        ; Dispatch to correct color depth routine
        push    OFFSET GN_DibDevExit
        cmp     dwBmpBitsPixel,10H
        ja      GN_DibSingleScan_Bpp32
        je      GN_DibSingleScan_Bpp16

        ; if not NULL, need to use lpTranslate
        cmp     lpTranslate,0
        je      GN_DibSingleScan_Bpp8
        sub     edi,edi
        lfs     di,lpTranslate
        jmp     GN_DibSingleScan_Bpp8
ENDPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBXIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibxit.asm
;
; Purpose:      This file streamlines the exit process on SetDIBitsToDevice
;               and StretchDIBits.
;
;               The code is kind of messy -- I don't understand what
;               is going on everywhere, but I just tried to optimize.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

EXPORT_ORDINAL_FOR_WRITE_PRINTER        TEXTEQU <269>
EXPORT_ORDINAL_FOR_GETDIBITS            TEXTEQU <441>
EXPORT_ORDINAL_FOR_POLYGON              TEXTEQU <36>
EXPORT_ORDINAL_FOR_ALLOCCSTODSALIAS     TEXTEQU <170>

;  From MSVC60/INCLUDE/OLENLS.H: 
;
;  A language ID is a 16 bit value which is the combination of a
;  primary language ID and a secondary language ID.  The bits are
;  allocated as follows:
;
;       +-----------------------+-------------------------+
;       |      Sublanguage ID   |   Primary Language ID   |
;       +-----------------------+-------------------------+
;        15                   10 9                       0   bit
;
;
;  Language ID creation/extraction macros:
;
;    MAKELANGID    - construct language id from primary language id and
;                    sublanguage id.
;    PRIMARYLANGID - extract primary language id from a language id.
;    SUBLANGID     - extract sublanguage id from a language id.
;
PRIMARY_LANG_MASK                       TEXTEQU <03FFh>

OPENSEG  _DATA, USE16, DATA
szGdi           DB      "GDI",0
szKernel        DB      "KERNEL",0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bUseStretchDIBitsFastExit, bUseSetDIBitsFastExit
bUseSetDIBitsFastExit           DB      0
bUseStretchDIBitsFastExit       DB      0

PUBLIC  lpfnGdiCode03_20B7
lpfnGdiCode03_20B7      DD      0

PUBLIC  lpfnGdiCode03_2119
lpfnGdiCode03_2119      DD      0

CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC  lpfnGdiCode43_165E
lpfnGdiCode43_165E      DD      0

PUBLIC  lpfnGdiCode03_20C9
lpfnGdiCode03_20C9      DD      0

PUBLIC  lpfnGdiCode25_01B8
lpfnGdiCode25_01B8      DD      0

PUBLIC  dwFlatKernelDataSeg
dwFlatKernelDataSeg     DD      0

PUBLIC  wKernelDataSeg, wLDTSelector
wKernelDataSeg          DW      0
wLDTSelector            DW      0

PUBLIC  dwTableRightToLeftLangIDs
dwTableRightToLeftLangIDs       LABEL   WORD
;       Arabic
DD      0001H
;       Hebrew.
DD      000DH
;       -1 signals the end of the table
DD      -1

szNlsLocalePath DB      "System\CurrentControlSet\Control\Nls\Locale",0

;==========================================================================
;
; Function:     GN_InitDibFastExit
;
; Purpose:      This routine inits stuff for the fast exit code on
;               SetDIBitsToDevice and StretchDIBits.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==========================================================================
DECPROC GN_InitDibFastExit, PASCAL, FRAME, FAR16
PARMD	lpNvmodeDispData
LOCALD  hLocaleKey
LOCALD  dwSize
LOCALS  szDefault,4
LOCALS  szDefaultLang,16
OPENPROC
        PUSHR   ds,esi,edi

        ; Clear these out to begin with
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[bUseSetDIBitsFastExit],0
        mov     ds:[bUseStretchDIBitsFastExit],0

        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]

        ; We are going to read the registry -- if we are on Arabic
        ; or Hebrew Windows (right to left reading languages), then
        ; we cannot do this patch.
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,cs
        lea     ebx,szNlsLocalePath
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocaleKey
        mov     ax,ss
        push    ax
        push    bx                      ; phkResult
        call    RegCreateKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done

        ; Read the "" string in this key. It should be equal
        ; to something like: "00000401" or "0000040D"  -- it
        ; will be the string version of a language identifier.
        sub     ecx,ecx
        mov     szDefault[0],cl
        mov     szDefaultLang[0],cl
        mov     dwSize,16
        mov     ax,ss
        shl     eax,10H
        push    hLocaleKey
        lea     ax,szDefault
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDefaultLang
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        mov     edi,edx

        ; close the key
        push    hLocaleKey
        call    RegCloseKey

        ; If there was an error reading, then to be safe, leave
        ; the fast dib stuff off.
        cmp     edi,ERROR_SUCCESS
        jne     Done

        ; Convert the language ID returned to a number
        sub     edx,edx
        sub     ebx,ebx
        sub     eax,eax
@@:
	add	ebp,ebx
        movzx   ecx,byte ptr szDefaultLang
	sub	ebp,ebx
        cmp     ecx,'0'
        jc      NoMoreDigits
        cmp     ecx,'9'
        jbe     FoundNumber
        cmp     ecx,'A'
        jc      NoMoreDigits
        cmp     ecx,'F'
        jbe     FoundHexCap
        cmp     ecx,'a'
        jc      NoMoreDigits
        cmp     ecx,'f'
        ja      NoMoreDigits
FoundHexSmall:
        sub     ecx, 'a' - 10
        jmp     NextDigit
FoundHexCap:
        sub     ecx, 'A' - 10
        jmp     NextDigit
FoundNumber:
        sub     ecx, '0'
NextDigit:
        imul    eax,10H
        add     eax,ecx
        inc     ebx
        jmp     @B

NoMoreDigits:
        and     eax, PRIMARY_LANG_MASK

        ; Compare the primary language ID returned against all the
        ; right to left language IDs. If it matches any one of them,
        ; then no fast dib exit.
        mov     edi, OFFSET dwTableRightToLeftLangIDs
@@:
        mov     ebx, cs:[edi]
        add     edi, 4
        cmp     ebx, -1
        je      NoMatch
        cmp     eax, ebx
        jne     @B
        jmp     Done
NoMatch:

	push	lpNvmodeDispData
        CALLFAR16IND lpfnGetControlVisionFlag,es,ax
	cmp	ax,0FEH
	jne	Done

        ; Get GDI module handle
        mov     ax,_DATA
        mov     cx,OFFSET szGdi
        push    ax
        push    cx
        call    GetModuleHandle
        mov     si,ax

        ; I need the selector value of GDI code segment 43 and the
        ; WRITE_PRINTER function happens to be in Gdi Code segment 43.
        push    si
        pushd   EXPORT_ORDINAL_FOR_WRITE_PRINTER
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,165EH
        mov     ds:[lpfnGdiCode43_165E],edx

        ; I need the selector value of GDI code segment 3 and the
        ; GetDIBits function happens to be in Gdi Code segment 3.
        push    si
        pushd   EXPORT_ORDINAL_FOR_GETDIBITS
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,20C9H
        mov     ds:[lpfnGdiCode03_20C9],edx

        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     dx,2119H
        mov     ds:[lpfnGdiCode03_2119],edx
        mov     dx,20B7H
        mov     ds:[lpfnGdiCode03_20B7],edx

        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]

        ; I need the selector value of GDI code segment 25 and the
        ; Polygon function happens to be in Gdi Code segment 25.
        push    si
        pushd   EXPORT_ORDINAL_FOR_POLYGON
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,01B8H
        mov     ds:[lpfnGdiCode25_01B8],edx

        ; Get the module handle for KERNEL
        mov     ax,_DATA
        mov     cx,OFFSET szKernel
        push    ax
        push    cx
        call    GetModuleHandle
        mov     si,ax

        ; I need the Kernel Data selector which is in the Kernel Code
        ; segment 1 and offset 2. AllocCSToDSAlias is in Kernel Code Seg 1.
        push    si
        pushd   EXPORT_ORDINAL_FOR_ALLOCCSTODSALIAS
        call    GetProcAddress
        or      dx,dx
        je      Done
        mov     di,dx

        ; Get the kernel data seg and the flat data seg pointer.
        ; The fast exit code requires that the Data seg selector be
        ; an LDT selector and not a GDT selector.
        mov     es,di
        sub     ebx,ebx
        movzx   eax,word ptr es:[ebx + 02H]
        test    eax,4
        jz      Done
        mov     ds:[wKernelDataSeg],ax
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     ds:[dwFlatKernelDataSeg],edx

        ; Get the selector which points to the base of the LDT.
        ; The fast exit code requires that this selector be
        ; an LDT selector and not a GDT selector.
        mov     es,di
        sub     ebx,ebx
        movzx   eax,word ptr es:[ebx + 06H]
        test    eax,4
        jz      Done
        mov     ds:[wLDTSelector],ax

        ; Everything worked! Set the flags saying we can do fast exit.
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[bUseSetDIBitsFastExit],1
        mov     ds:[bUseStretchDIBitsFastExit],1

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==========================================================================
;
; Function:     GdiCode03_2119
;               GdiCode03_217C
;
; Purpose:      This is the routine we return to from SetDibBitsToDevice.
;               It is in GDI Code segment 3 at offset 2119. We pick up
;               execution at this point.
;               StretchDIBits initially returns to Gdi Code segment 3
;               at offset 20B7. But almost always (and the only time we
;               come here), goes on to Gdi Code segment 3 at offset 217C.
;
; Arguments:    eax     Return Value from SetDIBitsToDevice
;               20H bytes of parameters
;               STACK:  CODE3:2119
;               OldEbp
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==========================================================================
GdiCode03_2119	PROC    FAR16
        ; Don't know what this test is for, but do it
        test    byte ptr ss:[di + 02H],40H
        jz      G3_20C9
        .errnz  $ - OFFSET GdiCode03_217C
GdiCode03_2119	ENDP

GdiCode03_217C	PROC    FAR16
        ; We may need to free this handle
        cmp     word ptr ss:[bp - 28H],0
        jne     G3_2183

G3_2189:
        ; I don't know what this does.
        cmp     dword ptr ss:[bp - 32H],0
        jne     G3_2192

G3_2199:
        ; I don't know what this does.
        and     byte ptr ds:[si + 00FEH],0EFH

        ; I know this test has to do with ICM. If ICM was involved
        ; then we jump and clear out the ICM ptr. That's all I know.
        test    byte ptr ds:[si + 00B6H],80H
        jnz     G3_21A9

G3_21B1:
        ; Clear these off to go "out" to the next routine
        pop     edi
        pop     si
        pop     cx
        mov     ds,cx
        mov     sp,bp
        pop     bp

        ; Check the return address. It must be Code43:165E or
        ; we cannot handle it ourselves
        mov     ecx,cs:[lpfnGdiCode43_165E]
        movzx   ebx,sp
        cmp     ecx,ss:[ebx]
        je      G43_165E
        RETFAR16 20H

PLABEL  G3_20C9
        ; This path doesn't seem to happen much in the benchmark,
        ; so I will just jmp back in line to the correct place.
        mov     ss:[bp - 02H],ax
        jmp     FFP16 PTR cs:[lpfnGdiCode03_20C9]

G3_2183:
        ; Free the handle
        push    eax
        push    word ptr ss:[bp - 28H]
        call    GlobalFree
        pop     eax
        jmp     G3_2189

G3_2192:
        push    eax
        push    dword ptr ss:[bp - 32H]
        call    FFP16 PTR cs:[lpfnGdiCode25_01B8]
        pop     eax
        jmp     G3_2199

G3_21A9:
        mov     dword ptr ds:[si + 006EH],0
        jmp     G3_21B1
GdiCode03_217C	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;==========================================================================
;
; Function:     G43_165E
;
; Purpose:      This is the routine we evetually end up at when we return
;               from SetDibBitsToDevice or StretchDIBits.
;               It is in GDI Code segment 43 at offset 165E -- G43_165E.
;
; Arguments:    eax     return value from SetDIBitsToDevice or
;                       StretchDIBits
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==========================================================================
; These parameters are valid at this point.
dwSelectorColonFlag     TEXTEQU <dword ptr ss:[bp - 04H]>
wSelector1ToFree        TEXTEQU < word ptr ss:[bp - 02H]>
wSelector2ToFree        TEXTEQU < word ptr ss:[bp - 0AH]>

PUBLIC  G43_165E
G43_165E:
        ; This mimicks a RETFAR16 20H
        add     sp,24H

K2_7C9D:
        ; Save this guy!
        push    eax

        ; If both the selector and flag are zero, then nothing to free
        mov     eax,dwSelectorColonFlag
        or      ax,ax
        je      G43_166B
        test    eax,0FFFF0000H
        jz      G43_166B

        ; We will be needing the following register values throughout
        ; the routines so load them up now.
        mov     ds,cs:[wKernelDataSeg]
        mov     es,cs:[wLDTSelector]
        mov     fs,ds:[13A6H]

        ; Call the kernel routine to clean up one of the selectors
        ; it allocated to map a flat ptr for the thunk.
        movzx   edx,wSelector1ToFree
        call    K1_4BA0

G43_166B:
K1_593B:
        movzx   edx,wSelector2ToFree
        sub     edi,edi
        and     edx,0FFFFFFF8H
        je      K1_59BD

        movzx   eax,word ptr ds:[edi + 1A50H]
        sub     ecx,ecx
        mov     es:[edx + 00H],eax
        mov     es:[edx + 04H],ecx
        mov     ds:[edi + 1A50H],dx
        inc     word ptr ds:[edi + 1A52H]

K1_5970:
        cmp     word ptr ds:[edi + 1A52H],2AH
        jc      K1_59BD
        dec     word ptr ds:[edi + 1A52H]
        mov     ds:[edi + 1A50H],ax
        mov     dword ptr es:[edx + 00H],1
        mov     dword ptr es:[edx + 04H],0F300H
        or      edx,7
        call    K1_4BA0
        sub     edi,edi
        jmp     K1_5970

K1_59BD:
G43_168F:
        ; Restore the return value
        pop     eax
        mov     ebx,34H
        mov     sp,bp
        RETFAR32

; This is the end of the routine G43_165E
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;==============================================================================
;
; Function:     K1_4BA0
;
; Purpose:      This function is my implementation of K1_4BA0 -- Kernel
;               code segment 1, the routine at offset 4BA0. K1_4BA0
;               actually calls a number of other routines which call
;               other routines, etc. I have flattened the whole thing
;               and eliminated ALOT of code. I have tried to put
;               labels in my implementation that link to the correct
;               Kernel offset so that it is easier to see the
;               correspondence between the two.
;
; Arguments:    edx     selector to deal with
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==============================================================================
PUBLIC  K1_4BA0
K1_4BA0:
K1_356A:
K1_356F:
        sub     edi,edi
        mov     gs,ds:[121EH]

        ; I don't know what this is for
        cmp     edi,ds:[12E0H]
        je      K1_358D

K1_7F14:
        ; I don't know what this does
        mov     ebx,1364H
        mov     ecx,ds:[12E4H]
        mov     ecx,fs:[ecx]
        inc     dword ptr fs:[ecx + 38H]
        dec     dword ptr ds:[ebx + 10H]
        jne     K1_7F37
        inc     dword ptr ds:[ebx + 04H]
        mov     ds:[ebx + 08H],ecx
        jmp     K1_358D
K1_7F37:
        cmp     ds:[ebx + 08H],ecx
        jne     K1_7F43
        inc     dword ptr ds:[ebx + 04H]

K1_358D:
        ; I don't know what this does
        inc     word ptr gs:[edi + 1EH]

K1_4BAB:
K1_555D:
        ; Updating special arena area to indicate selector is going away.
        ; This is NOT the LDT.
        mov     gs,ds:[13AAH]
        mov     eax,ds:[1234H]
        mov     ebx,edx
        and     ebx,0FFFFFFF8H
        shr     ebx,1
        mov     gs:[eax + ebx],edi

K1_4BC2:
K1_4C85:
        ; Assume just 1 selector in the tile
        mov     ecx,1

        ; Make sure the selector is valid
        lar     ax,dx
        jne     K1_4CBD

        ; Test for system segment
        test    ah,10H
        jz      K1_4CBD

        ; Test for segment present
        test    ah,80H
        jz      K1_4CA4

K1_4CB1:
        ; Segment is present. The number of tiled selectors is
        ; the number of 64K chunks in the selector limit. If lsl
        ; fails, then ecx is unchanged -- i.e. just 1 selector.
        lsl     ecx,edx
        jnz     K1_4CBD
        shr     ecx,10H
        inc     ecx

K1_4CBD:
K1_4BF0:
        cmp     edi,ds:[12E0H]
        je      K1_4C18

K1_4C10:
K1_7F00:
K1_7E8E:
K1_7F0A:
K1_7D85:
        mov     eax,ds:[12E4H]
        mov     ebx,1364H
        mov     eax,fs:[eax]
        inc     dword ptr fs:[eax + 38H]
        dec     dword ptr ds:[ebx + 10H]
        je      K1_7DCD
        cmp     eax,ds:[ebx + 08H]
        jne     K1_7DB5
        inc     dword ptr ds:[ebx + 04H]
        jmp     K1_7DE9
K1_7DB5:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0AH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7DE9
K1_7DCD:
        inc     dword ptr ds:[ebx + 04H]
        mov     ds:[ebx + 08H],eax

K1_7DE9:
K1_4C18:
        mov     ebx,edx
        and     ebx,00000FFF8H
        mov     esi,ebx
        shr     esi,1
        cmp     si,ds:[1232H]
        jnc     K1_4C52

K1_4C30:
        ; The unused descriptors in the LDT are a linked list!
        ; ds:[13ACH] points to the head and ds:[13AEH] is the
        ; number of unused descriptors (e.g. selectors). The
        ; low word of a descriptor entry gives the next selector
        ; that is unused.
        movzx   esi,word ptr ds:[13ACH]
        inc     word ptr ds:[13AEH]
        movzx   eax,word ptr es:[esi]
        mov     es:[esi],bx
        mov     es:[ebx],ax
        mov     word ptr es:[ebx + 02H],di
        mov     dword ptr es:[ebx + 04H],0F0000H

K1_4C60:
        ; Once again -- don't know what this stuff does
        cmp     edi,ds:[12E0H]
        je      K1_4C76

K1_4C73:
K1_7FD1:
K1_7FDC:
K1_7DF2:
        mov     ebx,1364H
        dec     dword ptr ds:[ebx + 04H]
        je      K1_7E08
        inc     dword ptr ds:[ebx + 10H]
        jmp     K1_7E2C
K1_7E08:
        mov     ds:[ebx + 08H],edi
        inc     dword ptr ds:[ebx + 10H]
        jle     K1_7E1A

K1_7E2C:
K1_7FDF:
K1_7EA9:
        mov     eax,ds:[12E4H]
        mov     eax,fs:[eax]
        dec     dword ptr fs:[eax + 38H]
        jne     K1_7EFF
        cmp     edi,fs:[eax + 4CH]
        je      K1_7EFF
        mov     ah,12H
        call    FFP16 PTR ds:[1A80H]
        mov     eax,ds:[12E0H]
        mov     eax,fs:[eax]
        btr     dword ptr fs:[eax + 44H],7
        jnc     K1_7EFF
        movzx   eax,sp
        mov     ax,ss:[eax + 0FFFFF000H]
K1_7EFF:
K1_7FE2:
K1_4C76:
K1_4CC1:
        add     edx,8
        dec     ecx
        jne     K1_4CBD

K1_4CCB:
K1_4BDE:
K1_4BE4:
K1_359D:
        mov     gs,ds:[121EH]
        dec     word ptr gs:[edi + 1EH]
        jne     K1_35B2
        test    word ptr gs:[edi + 44H],1
        jz      K1_35B2
        and     word ptr gs:[edi + 44H],-2
        int     2
K1_35B2:
        cmp     edi,ds:[edi + 12E0H]
        je      K1_35D2

K1_35C9:
K1_7F56:
        mov     ebx,1364H
        dec     dword ptr ds:[ebx + 04H]
        jne     K1_7FA4
        mov     ds:[ebx + 08H],edi
        inc     dword ptr ds:[ebx + 10H]
        jle     K1_7F8E
K1_7F6C:
        mov     eax,ds:[edi + 12E4H]
        mov     eax,fs:[eax]
        dec     dword ptr fs:[eax + 38H]
        jne     K1_7F8B
        cmp     edi,fs:[eax + 4CH]
        jne     K1_7FAA
        jmp     K1_7F8B

K1_7FA4:
        inc     dword ptr ds:[ebx + 10H]
        jmp     K1_7F8B
K1_7FAA:
        mov     ah,12H
        call    FFP16 PTR ds:[1A80H]
        mov     eax,ds:[edi + 12E0H]
        mov     eax,fs:[eax]
        btr     dword ptr fs:[eax + 44H],7
        jnc     K1_7F8B
        movzx   eax,sp
        mov     ax,ss:[eax + 0FFFFF000H]
        jmp     K1_7F8B

K1_7F8B:
K1_35D2:
K1_4BED:
        ret

; This is the end of routine K1_4BA0. We need it a few times, so
; we made it a sub-routine.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K1_7F43:
K1_5830:
        ; Make a flat ptr to wKernelDataSeg+1364H and
        ; Service to main VDD -- I don't know what it does
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0AH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_358D

K1_4CA4:
        ; If the segment is not present then Windows stores the
        ; number of contiguous tiled selectors in the top byte
        ; of the LDT entry for the selector.
        movzx   ecx,byte ptr es:[ebx + 07H]
        jmp     K1_4CBD

K1_7E1A:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0BH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7E2C

K1_7F8E:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0BH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7F6C

K1_4C52:
        or      ebx,7
        mov     eax,1
        int     31H
        jmp     K1_4C60

CLOSESEG  _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNGETID.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gngetrid.asm
;
; Purpose:      This file holds the GetDriverResourceID display driver
;               entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_GetDriverResourceID
;
; Purpose:      This function is the GetDriverResourceID display driver
;               entry point.
;
; Arguments:    GetDriverResourceID Display Driver Stack Frame
;
; Returns:      The remapped resource id.
;
;==============================================================================
DECPROC GENERIC_GetDriverResourceID, PASCAL, FRAME, FAR16
PARMW   wResID
PARMD   lpResType
OPENPROC
        PUSHR   ds
        sub     edx,edx
        movzx   eax,wResID
        cmp     eax,3
        jne     @F
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     ebx,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        lds     bx,ds:[ebx].GNLOGDEVCX.lpGdiInfo
        cmp     ds:[ebx].GDIINFO.dpLogPixelsX,96
        je      @F
        mov     eax,2003
@@:     POPR    ds
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCURSOR.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncursor.asm
;
; Purpose:      This file holds the SetCursor, MoveCursor, and CheckCursor
;               display driver entry point.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc


OPENSEG  _DATA, USE16, DATA
; This structure is too big to put on the stack because sometimes
; GDI calls SetCursor with a 4K (!) stack and this is over 4K!
; We use this area to convert 8bpp cursors to 32bpp cursors to
; avoid problems where the palette changes while a cursor is
; still in the cache and then the pattern gets reloaded into the
; hardware without getting retranslated through the new palette.
SIZE_32BPP_CURSOR_PLUS_HEADER   TEXTEQU <SIZE CURSORDESCEX + AND_MASK_SIZE + 20H * 20H * 4>
TempCursor              DB      (SIZE_32BPP_CURSOR_PLUS_HEADER) DUP (0)
wTempCursorInUse        DW      0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_CreateCursorCache
;
; Purpose:      This function destroys a cursor cache. Memory is
;               freed and ptrs are zeroed.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      eax             0       then Failure
;                               non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Now allocate a cursor cache
        mov     eax, SIZE CURSORCACHE
        add     eax,(SIZE CURSORDESCEX * MAX_CACHEABLE_CURSORS)
        push    eax
        call    HW_AllocFlatMemory
        mov     ds:[esi].GNCRTCCX.pCursorCache,eax

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyCursorCache
;
; Purpose:      This function destroys a cursor cache. Memory is
;               freed and ptrs are zeroed.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Now allocate a cursor cache
        mov     eax,ds:[esi].GNCRTCCX.pCursorCache
        or      eax,eax
        je      @F

        push    esi
        call    GN_ClearCursorCache

        push    ds:[esi].GNCRTCCX.pCursorCache
        call    HW_FreeFlatMemory
        mov     ds:[esi].GNCRTCCX.pCursorCache,0
@@:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ClearCursorCache
;
; Purpose:      This function clears the cursor cache which will
;               cause all cache entries to be marked empty. However
;               it will not flush current patterns from the cache,
;               thus making sure the selected pattern remains valid
;               until the next pattern is set.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Mark all cache spots so that there will never be a match
        mov     ebx,ds:[esi].GNCRTCCX.pCursorCache
        mov     ecx,ds:[esi].GNCRTCCX.dwMaxCacheableCursors
        lea     ebx,[ebx + SIZE CURSORCACHE]
        mov     eax,-1
@@:     mov     ds:[ebx].CURSORDESCEX.wWidthBytes,ax
        mov     ds:[ebx].CURSORDESCEX.ExtraData.dwCursorHash,eax
        add     ebx,SIZE CURSORDESCEX
        dec     ecx
        jne     @B

        ; Set flags so that the cursor will be moved/selected correctly
        mov     ebx,ds:[esi].GNCRTCCX.pCursorCache
        or      ds:[ebx].CURSORCACHE.dwCursorFlags,CURSOR_MOVE OR CURSOR_SELECT OR CURSOR_IS_NULL
        mov     ds:[ebx].CURSORCACHE.dwNextCacheSlot,0

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ClearAllCursorCaches
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board and clears the cursor cache for each of them.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearAllCursorCaches, PASCAL, FRAME, FAR32
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev

        ; Start with the first CRTCCX
        mov     edx,0

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; We found a CRTCCX. Clear the cursor cache.
        push    eax                     ; save GNBOARDCX
        push    ebx                     ; save index into GNLOGDEVCXs
        push    ecx                     ; save GNLOGDEVCX
        push    edx                     ; save index into GNCRTCCXs
        push    esi
        call    GN_ClearCursorCache
        pop     edx                     ; restore index into GNCRTCCXs
        pop     ecx                     ; restore GNLOGDEVCX
        pop     ebx                     ; restore index into GNLOGDEVCXs
        pop     eax                     ; restore GNBOARDCX

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Convert8BppCursorTo32BppCursor
;
; Purpose:      This function converts an 8bpp cursor to a 32bpp
;               cursor.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lp8BppCursorShape       16:16 "src" 8bpp cursor
;               lp32BppCursorShape      16:16 ptr to place to store
;                                       converted cursor
;
; Returns:      eax = 0 - OK; NE 0 - Fail
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_Convert8BppCursorTo32BppCursor, PASCAL, FRAME, NEAR
PARMD   pGNCrtcCXOffset
PARMD   lp8BppCursorShape
PARMD   lp32BppCursorShape
OPENPROC
        PUSHR   esi,edi

        ; Convert the 8bpp cursor to a 32bpp cursor
        sub     esi,esi
        lfs     si,lp8BppCursorShape
        sub     edi,edi
        les     di,lp32BppCursorShape

        ; First copy the header
        movzx   eax,fs:[esi].CURSORDESC.wWidth
        imul    ax,fs:[esi].CURSORDESC.wHeight
        cmp     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        jg      WrongHeader
        mov     ecx,eax
        shr     ecx,5
        add     ecx,(SIZE CURSORHEADER) SHR 2
        rep     movs dword ptr es:[edi], fs:[esi]

        ; Fix up the bits per pixel field to say 32bpp
        movzx   ecx,word ptr lp32BppCursorShape
        mov     es:[ecx].CURSORDESC.bBitsPerPixel,32

        ; Now we are at the XOR mask for the cursor.
        ; Translate it through the palette, pixel by pixel
        mov     ebx,pGNCrtcCXOffset
        lea     ebx,[ebx].GNCRTCCX.dwPaletteTable
        mov     ecx,eax

Cont_Xlate:
        movzx   eax,byte ptr fs:[esi]
        inc     esi
        mov     eax,ds:[ebx][eax * 4]
        and     eax,00FFFFFFh
        mov     es:[edi],eax
        add     edi,4
        dec     ecx
        jne     Cont_Xlate
        sub     eax,eax

WrongHeader:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_SetCursor
;
; Purpose:      This function is the SetCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
; Arguments:
;               lpCursorShape   ptr to cursorShape structure
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetCursor, PASCAL, FRAME, FAR16, LOGOFF
PARMD   lpCursorShape
LOCALD  lpTempCursor
LOCALD  dwUsingTempCursorInDataSeg
LOCALD  dwTotalCursorDataSize
LOCALD  dwCursorsLeftToSearch
LOCALD  pThisCursorCache
LOCALD  dwMaxCursorCacheEntries
LOCALD  dwCursorPixelDepth
LOCALD  dwHadToAlloc
LOCALD  dwCRTCCount
LOCALD  ppGNCrtcCXOffset
LOCALD  pGNCrtcCXOffset
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Prepare for the routine
        mov     dwHadToAlloc,0
        cld

        ; Load up our context
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     DoneIt

        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     esi,ds:[eax]
        or      esi,esi
        je      NextCrtc

        ; Get a few things relating to this cursor cache
        mov     eax,ds:[esi].GNCRTCCX.dwMaxCacheableCursors
        mov     dwMaxCursorCacheEntries,eax
        mov     edi,ds:[esi].GNCRTCCX.pCursorCache
        or      edi,edi
        je      NextCrtc

        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        je      HW_SetCursor

        ; Check for NULL cursor ...
        or      ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        cmp     lpCursorShape,0
        je      @F
        and     ds:[edi].CURSORCACHE.dwCursorFlags,NOT CURSOR_IS_NULL
@@:
        ; We have to move the cursor first time after switching.
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_MOVE
        je      @F
        and     ds:[edi].CURSORCACHE.dwCursorFlags,NOT CURSOR_MOVE
        mov     eax,dword ptr ds:[edi].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        push    cs:[CSlp16LogDevice]
        call    DIB_MoveCursorExt

@@:
        push    lpCursorShape
        push    cs:[CSlp16LogDevice]
        call    DIB_SetCursorExt
        jmp     NextCrtc

HW_SetCursor:
        mov     pThisCursorCache,edi

        ; Check for NULL cursor ...
        cmp     lpCursorShape,0
        jne     NonNullCursor

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; A NULL lpCursorShape means to turn the cursor off.
NullCursor:
        ; disable the cursor on it
        or      ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        push    esi
        pushd   0
        pushd   0
        call    GN_TurnCursorOffOrOn
        jmp     NextCrtc
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NonNullCursor:
        ; See if we need to convert the 8bpp cursor to a 32bpp
        ; cursor through the palette. This way, palette changes
        ; won't affect the cursor color in the future. Do we have
        ; a temporary area to do the cursor translation? If not
        ; we have to allocate. The Alloc should not happen
        ; unless SetCursor reenters itself.
        mov     eax,lpCursorShape
        mov     lpTempCursor,eax
        sub     ebx,ebx
        sub     eax,eax
        les     bx,lpCursorShape

        ; Check for the valid selector first
        mov     ax,es
        lar     edx,eax
        jnz     DoneIt
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     DoneIt

        ; Check for the valid bpp
        mov     al,es:[ebx].CURSORDESC.bBitsPerPixel
        cmp     al,1
        je      CheckCache
        cmp     al,4
        je      CheckCache
        cmp     al,15
        je      CheckCache
        cmp     al,16
        je      CheckCache
        cmp     al,24
        je      CheckCache
        cmp     al,32
        je      CheckCache
        cmp     al,8
        jne     DoneIt

        mov     ax,SEG TempCursor
        shl     eax,10H
        lea     ax,TempCursor
        mov     lpTempCursor,eax

        mov     ax,_DATA
        mov     fs,ax
        mov     ecx,1
        xchg    cx,fs:[wTempCursorInUse]
        or      ecx,ecx
        je      @F

        mov     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        call    GN_MemoryAlloc
        or      eax,eax
        je      SetCursorDone
        shl     edx,10H
        mov     lpTempCursor,edx
        mov     dwHadToAlloc,1
@@:
        push    esi
        push    lpCursorShape
        push    lpTempCursor
        call    GN_Convert8BppCursorTo32BppCursor
        or      eax,eax
        jnz     SetCursorDone

        ; Reload this
        sub     ebx,ebx
        les     bx,lpTempCursor
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CheckCache:
        ; es:ebx should point to the CURSORDESCEX

        ; See if this cursor shape is currently in the cache
        ; First we calculate the size of the cursor in EBX
        movzx   ecx,es:[ebx].CURSORDESC.bBitsPerPixel
        mov     dwCursorPixelDepth,ecx

        ; Convert 15 to 16
        cmp     ecx,15
        sete    al
        movzx   eax,al
        add     ecx,eax

        ; Anything over 32bpp gets set to 32bpp
        ; For Debug Only:
        ; 33Bpp = ARGB format
        ; 34Bpp = ARGB premultiplied format
        cmp     ecx,32
        jle     @F
        mov     ecx,32
@@:
        ; Figure out the total size of the CURSORDESC
        ; plus the AND_MASK and the cursor data
        inc     ecx
        movzx   eax,es:[ebx].CURSORDESC.wWidth
        imul    eax,ecx
        movzx   ecx,es:[ebx].CURSORDESC.wHeight
        imul    eax,ecx
        shr     eax,3
        add     eax,(SIZE CURSORHEADER)
        shr     eax,2
        cmp     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        jg      SetCursorDone
        mov     dwTotalCursorDataSize,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; It's a little quicker to find by hashing first
        mov     eax,dwMaxCursorCacheEntries
        mov     dwCursorsLeftToSearch,eax
        mov     eax,pThisCursorCache
        add     eax,SIZE CURSORCACHE
        mov     esi,lpCursorShape
HashLoop:
        cmp     esi,ds:[eax].CURSORDESCEX.ExtraData.dwCursorHash
        je      HashHit
HashFail:
        add     eax,SIZE CURSORDESCEX
        dec     dwCursorsLeftToSearch
        jne     HashLoop
        jmp     CheckLong
HashHit:
        movzx   edi,word ptr lpTempCursor
        lea     esi,[eax].CURSORDESCEX.wHotX
        mov     ecx,dwTotalCursorDataSize
        repe    cmps dword ptr ds:[esi], es:[edi]
        je      CursorMatch
        mov     esi,lpCursorShape
        jmp     HashFail
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Didn't find a hash match. Check everything the long way.
CheckLong:
        mov     edi,pThisCursorCache
        lea     eax,[edi + SIZE CURSORCACHE].CURSORDESCEX.wHotX
        mov     ecx,dwMaxCursorCacheEntries
        mov     dwCursorsLeftToSearch,ecx

LongLoop:
        movzx   edi,word ptr lpTempCursor
        mov     esi,eax
        mov     ecx,dwTotalCursorDataSize
        repe    cmps dword ptr ds:[esi], es:[edi]
        je      CursorMatch
        add     eax,SIZE CURSORDESCEX
        dec     dwCursorsLeftToSearch
        jne     LongLoop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NoMatch:
        ; Didn't find a match, so use the next cache slot
        mov     edx,pThisCursorCache
        mov     eax,ds:[edx].CURSORCACHE.dwNextCacheSlot
        mov     ds:[edx].CURSORCACHE.dwSelectedCacheSlot,eax
        imul    edi,eax,SIZE CURSORDESCEX
        lea     edi,[edx + SIZE CURSORCACHE][edi]
        mov     ecx,lpCursorShape
        mov     ds:[edi].CURSORDESCEX.ExtraData.dwCursorHash,ecx
        sub     esi,esi
        lfs     si,lpTempCursor
        mov     cx,ds
        mov     es,cx
        add     edi,SIZE CURSOREXTRA
        mov     ecx,dwTotalCursorDataSize
        rep     movs dword ptr es:[edi], fs:[esi]

        ; Indicate which cursor slot needs updating by the hardware and
        ; also that some lazy activity is required.
        lea     ecx,[eax + NUM_CURSOR_FLAGS]
        mov     ebx,1
        shl     ebx,cl
        or      ebx,CURSOR_MOVE OR CURSOR_SELECT
        or      ebx,ds:[edx].CURSORCACHE.dwCursorFlags
        and     ebx,NOT CURSOR_IS_NULL
        mov     ds:[edx].CURSORCACHE.dwCursorFlags,ebx

        ; Update the next cache slot.  The first three cursors to
        ; go in are usually the really common ones, like the arrow,
        ; the hourglass, and the arrow/hourglass combo. So never
        ; kick the first three out once they go in.
        inc     eax
        cmp     eax,dwMaxCursorCacheEntries
        jc      @F
        mov     eax,3
@@:     mov     ds:[edx].CURSORCACHE.dwNextCacheSlot,eax
        mov     ebx,edx
        jmp     SetCursorWhere

CursorMatch:
        ; edx is the cursor cache number that matched
        mov     ebx,pThisCursorCache
        mov     edx,dwMaxCursorCacheEntries
        sub     edx,dwCursorsLeftToSearch
        mov     ds:[ebx].CURSORCACHE.dwSelectedCacheSlot,edx

        ; Don't put off the lazy activity for cursors that are already
        ; in the cache or the cursor seems unresponsive.
        mov     eax,ds:[ebx].CURSORCACHE.dwCursorFlags
        and     eax,NOT CURSOR_IS_NULL
        or      eax,CURSOR_MOVE OR CURSOR_SELECT
        mov     ds:[ebx].CURSORCACHE.dwCursorFlags,eax

SetCursorWhere:
        mov     eax,ppGNCrtcCXOffset
        push    dword ptr ds:[eax]
        call    GN_CursorAction
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetCursorDone:
        cmp     dwHadToAlloc,0
        je      @F
        movzx   eax,word ptr lpTempCursor+2
        call    GN_MemoryFree
        jmp     Skip5
@@:
        ; We didn't have to alloc, so wemust have been using
        ; the TempCursor
        mov     ax,_DATA
        mov     fs,ax
        mov     fs:[wTempCursorInUse],0
Skip5:

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoneIt:
        ; We are Done!
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_CursorAction
;
; Purpose:      This function should be called when it is desired to
;               set, move, select, or enable the cursor. The appropriate
;               sequencing is performed to do all the actions in the
;               correct order.
;
; Arguments:
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CursorAction, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pGNCrtcCXOffset
LOCALD  pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,ds:[edi].GNCRTCCX.pHWCrtcCX
        mov     pHWCrtcCXOffset,eax

        ; Check the semaphore so we don't step on ourselves
        bts     ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_SEMAPHORE_BIT
        jc      BlockedSemaphore

        ; Handle cursor setting first. There may be many cursors to set
        ; because SetCursor may have been called multiple times since
        ; the last lazy call to this routine. However, only bother
        ; placing the cursor we are going to select into the HW.

        ; If the currently selected cursor needs setting, then do so
        mov     ecx,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        add     ecx,NUM_CURSOR_FLAGS
        mov     eax,1
        shl     eax,cl
        test    ds:[esi].CURSORCACHE.dwCursorFlags,eax
        jz      Set1

        ; Clear out the SETTING bit for the particular cache slot
        not     eax
        and     ds:[esi].CURSORCACHE.dwCursorFlags, eax
        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot

        ; Call the hw specific code to set the cursor pattern into vidmem
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     eax,[edi].CURSORDESCEX.wHotX

        push    pHWCrtcCXOffset
        push    ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        push    eax
        call    HW_CursorSet
        mov     ds:[edi].CURSORDESCEX.ExtraData.dwCursorType,eax

Set1:
        ; Handle cursor selection second
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_SELECT
        jz      Select1

        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     edx,[edi].CURSORDESCEX.wHotX

        push    pHWCrtcCXOffset
        push    eax
        push    ds:[edi].CURSORDESCEX.ExtraData.dwCursorType
        push    edx
        call    HW_CursorSelect
        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_SELECT

Select1:
        ; Handle cursor moves last
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_MOVE
        jz      Move1

        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        push    pGNCrtcCXOffset
        push    word ptr ds:[esi].CURSORCACHE.wCursorX
        push    word ptr ds:[esi].CURSORCACHE.wCursorY
        call    GN_CheckPanAndMoveCursor

        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_MOVE

Move1:
        push    pGNCrtcCXOffset
        pushd   1
        pushd   0
        call    GN_TurnCursorOffOrOn

        ; turn off the blocking semaphore
        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_SEMAPHORE

BlockedSemaphore:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_MoveCursor
;
; Purpose:      This function is the MoveCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
; Arguments:    wX, wY          coords of new cursor location
;
;==============================================================================
DECPROC GENERIC_MoveCursor, PASCAL, FRAME, FAR16, LOGOFF
PARMW   wX
PARMW   wY
LOCALD  ppGNCrtcCXOffset
LOCALD  dwCRTCCount
LOCALD  PhysicalXRes
LOCALD  PhysicalYRes
LOCALD  NewScanStart
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Load up our context
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     edi,ds:[eax]
        or      edi,edi
        je      NextCrtc

        push    edi
        push    word ptr wX
        push    word ptr wY
        call    GN_CheckPanAndMoveCursor

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

done:
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckPanAndMoveCursor
;
; Purpose:      This function checks if the PhysicalViewport needs to pan
;               and updates its coordinates in the GNCRTCCX if so. This
;               function then figures out the physical postion of the
;               cursor relative to the virtual desktop.
;
; Arguments:    pGNCrtcCXOffset GNCRTCCX ptr
;               wX, wY          coords of new cursor location
;
;==============================================================================
DECPROC GN_CheckPanAndMoveCursor, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pGNCrtcCXOffset
PARMW   wX
PARMW   wY
LOCALD  dwCRTCCount
LOCALD  PhysicalXRes
LOCALD  PhysicalYRes
LOCALD  NewScanStart
OPENPROC
        PUSHR   esi,edi

        ; Call the DIBENG first
        push    dword ptr wY
        push    cs:[CSlp16LogDevice]
        call    DIB_MoveCursorExt

        mov     edi,pGNCrtcCXOffset
        mov     esi,cs:[CSpGNLogicalDevice]

        ; If the cursor has not been enabled, then we are done
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        or      ebx,ebx
        je      done

        cmp     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,0
        je      skip_pan

        mov     NewScanStart,0
        sub     edx,edx

        ; Check to make sure the cusor coordinates are inside the
        ; virtual desktop window.
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        cmp     ax,wX
        jge     @F
        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        cmp     ax,wY
        jl      skip_pan

@@:
        ; Calculate the physical X and Y of the ViewPort.
        mov     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        mov     PhysicalXRes,eax
        mov     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        mov     PhysicalYRes,eax

        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     eax,PhysicalXRes
        cmp     edx,eax
        jne     check_XLeft
        
        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     eax,PhysicalYRes
        cmp     edx,eax
        jne     check_YTop
        jmp     skip_pan

check_XLeft:
        movzx   eax,wX
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        jle     @F
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
@@:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        jge     check_XRight
        
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     edx,PhysicalXRes
        add     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,edx
        mov     NewScanStart,1
        jmp     check_YTop

check_XRight:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight
        jle     check_YTop

        inc     eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     edx,PhysicalXRes
        sub     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,edx
        mov     NewScanStart,1

check_YTop:
        movzx   eax,wY
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        jle     @F
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
@@:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        jge     check_YBottom
        
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     edx,PhysicalYRes
        add     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,edx
        mov     NewScanStart,1
        jmp     set_scanline_start

check_YBottom:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom
        jle     set_scanline_start

        inc     eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     edx,PhysicalYRes
        sub     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,edx
        mov     NewScanStart,1

set_scanline_start:
        cmp     NewScanStart,1
        jne     skip_pan

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     skip_pan

        push    edi
        call    GN_SetPanRectangle
        
skip_pan:

        ; Save the coords for later
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,dword ptr wY
        ror     eax,10H
        mov     dword ptr ds:[ebx].CURSORCACHE.wCursorX,eax

        ; Is this a hardware or software cursor
        ; For software cursors, we don't have to enumerate the
        ; CRTCs for Clone Mode since a software cursor is embedded
        ; in the frame buffer. Writing it once will have it show
        ; up on all cloned monitors.
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        test    ds:[ebx].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     done

        ; Since this is a hardware cursor, we need to subtract the position
        ; of the topleft corner from the cursor position of the virtual
        ; desktop in order to get the cursor position relative to the
        ; physical desktop.
        mov     edx,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        shl     edx,10h
        sub     eax,edx
        mov     edx,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        sub     ax,dx
        
        ; We need the actual CURSORDESC for the selected cursor
        ; since we need to know its hot spot
        mov     ecx,ds:[ebx].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,SIZE CURSORDESCEX
        lea     edx,[ebx + SIZE CURSORCACHE][ecx]

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     done

        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    eax
        push    dword ptr ds:[edx].CURSORDESCEX.wHotX
        call    HW_CursorMove

done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_CheckCursor
;
; Purpose:      This function is the CheckCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
;==============================================================================
DECPROC GENERIC_CheckCursor, PASCAL, FRAME, FAR16, LOGOFF
LOCALD  ppGNCrtcCXOffset
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Just in case the driver is deinitted but we still get called
        cmp     cs:[CSpGNLogicalDevice],0
        je      Done

        ;!!!!!! FIGURE OUT WHERE IS THE CRITICAL INTERVAL !!!!!!
        sub     eax,eax
        mov     ax,cs:[wFlatDataSel]
        lar     edx,eax
        jnz     Done
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     Done
        mov     ds,ax
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Always call the DIBENGINE CheckCursor just in case
        push    cs:[CSlp16LogDevice]
        call    DIB_CheckCursorExt

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     Done

        ; This is used as a time base for a few things in the driver
        inc     ds:[esi].GNLOGDEVCX.dwCheckCursorCount
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        inc     ds:[eax].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded

        ; Deal with Windows bug doing repaint request processing
        call    GN_CheckUserRepaint

        ; Set up to enumerate all CRTC attached to this logical device
        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     edi,ds:[eax]
        or      edi,edi
        je      NextCrtc

        ; If the cursor has not been enabled, then we are done
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        or      esi,esi
        je      NextCrtc

        ; If the cursor is NULL, then we're done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        jnz     NextCrtc

        ; If the cursor is software, then we're done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     NextCrtc

        ; If the cursor has no action to take then we are done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,(((1 SHL MAX_CACHEABLE_CURSORS) - 1) SHL NUM_CURSOR_FLAGS) OR CURSOR_MOVE OR CURSOR_SELECT
        jz      NextCrtc

        push    edi
        call    GN_CursorAction

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

Done:
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_TurnCursorOffOrOn
;
; Purpose:      This function turns off the cursor. If the cursor is
;               software, this routine do nothing.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwZeroForOffOneForOn    Just what it says
;               dwMoveCursor            if this parameter s non-0, then the
;                                       cursor position is updated as well
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_TurnCursorOffOrOn, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pGNCrtcCXOffset
PARMD   dwZeroForOffOneForOn
PARMD   dwMoveCursor
OPENPROC
        PUSHR   esi,edi

        mov     esi,pGNCrtcCXOffset
        mov     edi,ds:[esi].GNCRTCCX.pCursorCache
        or      edi,edi
        je      Done

        ; Is mouse trails active?
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     Done

        cmp     dwZeroForOffOneForOn,0
        je      HwOff

        ; Are we supposed to move the cursor?
        cmp     dwMoveCursor,0
        je      @F
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr ds:[edi].CURSORCACHE.wCursorX
        pushd   0
        call    HW_CursorMove

@@:
        ; Don't turn the cursor on if it is NULL ...
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        jnz     Done

        ; Turn the cursor back on
        push    esi
        call    GN_CursorAction

HwOff:
        ; Turn off/on the hardware cursor
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        pushd   dwZeroForOffOneForOn
        call    HW_CursorEnable

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResetSelectedCursor
;
; Purpose:      This function takes the currently selected cursor
;               and recalls SetCursor with the pattern. We need
;               this for times when there is a modeset or whatever
;               and the cursor gets turned off and marked as NULL,
;               but the system does not call SetCursor to turn it
;               back on.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResetSelectedCursor, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pGNCrtcCXOffset
LOCALD  lpResetCursorShape
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot

        ; Call the hw specific code to set the cursor pattern into vidmem
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     ebx,[edi].CURSORDESCEX.wHotX

        mov     eax,1
        mov     ecx,SIZE CURSORDESC + (CURSOR_WIDTH * CURSOR_HEIGHT * 4)
        call    GN_AllocSelectorAndMapIt
        shl     eax,10H
        mov     lpResetCursorShape,eax

        push    lpResetCursorShape
        CALLFAR16 GENERIC_SetCursor

        mov     eax,lpResetCursorShape
        shr     eax,10H
        call    GN_UnmapAndFreeSelector

        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCRTC2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncrtc2.asm
;
; Purpose:      This file holds run-time routines for GNCRTCCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include minivdd.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szMonitorDeviceName
szMonitorDeviceName     DB      "MONITOR",0

;============================================================================
;
; Function:     GN_CrtcMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
; Returns:      None
;
; Preserve:     ds,esi,edi
;============================================================================
DECPROC GN_CrtcMessage, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      MoveLogDev
        cmp     eax,MSG_DEVICESREMAPPED
        je      DevRemap
        jmp     ChainIt

PreMS:
        jmp     ChainIt

PostMS:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNCRTCCX.dwInitting,0
        jmp     ChainIt

DXEnum:
DXOn:
DXOff:
        jmp     ChainIt

DosOff:
        push    dwData1
        push    esi
        call    GN_SetBytesPerPixelAndBytesPerLine

        push    esi
        call    GN_SetPanRectangle

        ; Now, reload the color map
        push    esi
        call    GN_ResetColorMap

PowerOn:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache
        jmp     ChainIt

DosOn:
DrvDis:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; Set a NULL cursor so the cursor will disappear
        pushd   0
        call    GENERIC_SetCursor

PowerOff:
        jmp     ChainIt

MoveLogDev:
        jmp     ChainIt

DevRemap:
        push    pGNCrtcCXOffset
        push    dwData1
        call    GN_CrtcDeviceHasBeenRemapped
        jmp     ChainIt

ChainIt:
        ; Call the hardware to inform it of the message
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_CrtcMessage

DoneIt2:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestoreCrtcState
;
; Purpose:      This routine gets called to put the GNCRTCCX
;               back into the HWCRTCCX.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestoreCrtcState, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
OPENPROC
        PUSHR   esi

        ; Reset the mode
        push    pGNCrtcCXOffset
        push    pGNLogDevCXOffset
        call    GN_SetCrtcMode

        ; Force the cursor cache to be re-created
        push    pGNCrtcCXOffset
        call    GN_ClearCursorCache

        ; Turn the cursor back on if it is not NULL
        push    pGNCrtcCXOffset
        pushd   1
        pushd   1
        call    GN_TurnCursorOffOrOn

        ; restore the
        push    pGNCrtcCXOffset
        call    GN_ResetColorMap

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcDeviceHasBeenRemapped
;
; Purpose:      This routine gets called whenever we get the
;               DEVICESREMAPPED message. The CRTC must update
;               any internal state it needs to because its
;               display device has changed.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcDeviceHasBeenRemapped, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
LOCALD  pHWCrtcCXOffset
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Check for video mirror enabled on this CRTC?
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCXWhenLocked
@@:
        mov     pHWCrtcCXOffset,eax

        ; We only do this for the primary device in each driver
        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     @F

        ; This forces the monitors to be re-enumerated and
        ; it forces Windows to reget all the EDIDS which
        ; may be necessary after a device remapping. We pass
        ; up the physical head that the first Windows logical
        ; device is using.
        push    pHWCrtcCXOffset
        call    HW_GetPhysicalCrtcIndex
        mov     ebx,pGNLogDevCXOffset
        push    ds:[ebx].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        or      eax,80000000H
        push    eax
        call    GN_VddReenumerateDevNode

@@:
        push    pHWCrtcCXOffset
        call    HW_GetDacLimits
        lea     edi,[esi].GNCRTCCX.sNvmodeDispData
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz8bpp,eax
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz16bpp,ebx
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz32bpp,ecx

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; Get the registry path to our device local stuff.
        ; Anything that is not the primary device does not
        ; get an .inf file.
        ; Also, because the results of Reenumerate are asyncronous
        ; and delayed by about five seconds, when switching display
        ; devices we have to just go without a .inf status the first
        ; time. A modeset that occurs but does not involve a display
        ; device switch will attempt to reget the .inf status.
        ; However, if we are initting, and the device is the primary,
        ; get the INF or we won't have it for modesets until the display
        ; device changes.
        mov     ds:[edi].DISPDATA.dwMonitorInfType,UNKNOWN_DEVICE
        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     @F
        cmp     ds:[esi].GNCRTCCX.dwInitting,1
        je      GetDevPath
        cmp     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,0
        jne     @F
        
GetDevPath:
        lea     eax,[esi].GNCRTCCX.szLocalMonitorBasePath
        push    sDispInfo.diMonitorDevNodeHandle
        mov     ax,ds
        push    eax
        lea     ecx,[esi].GNCRTCCX.szLocalMonitorBasePath
        push    ecx
        mov     ax,SEG szMonitorDeviceName
        push    eax
        mov     ax,OFFSET szMonitorDeviceName
        movzx   eax,ax
        push    eax
        call    GN_GetDeviceLocalBasePath
        mov     ds:[edi].DISPDATA.dwMonitorInfType,ecx
@@:
        ; In case it was set, clear out the display device change flag
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,0

        ; Assume no Edid
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0

        ; Reread the EDID if the device is not a TV
        push    esi
        call    GN_GetDevData
        cmp     al,DEVTYPE_TV
        je      @F

        ; Read the EDID for this device
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    pHWCrtcCXOffset
        push    eax
        lea     eax,[esi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[esi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid
@@:
        ; Set the new Display Device type into the registry
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.dwLogicalDeviceInstance
        push    ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[ebx].DISPDATA.lpDevData
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        ; If this device is a TV, set the TV Format in the ResMan.
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        lfs     bx,fs:[ebx].DISPDATA.lpDevData
        mov     eax,fs:[ebx]
        cmp     al,DEVTYPE_TV
        jne     SkipTVFormat
        push    pHWCrtcCXOffset
        push    eax
        call    HW_SetResManTvFormat
        
SkipTVFormat:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcRemapArray
;
; Purpose:      This routine gets all the display devices types
;               associated with all the CRTCCXs, asks the hardware
;               for a remapping.
;
;               The caller must have verified that the set of all
;               display device types in all the CRTCCXs are able
;               to be used simultaneously, presumably by having
;               called HW_CanDevicesBeMapped.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwRestoreStates         Restore the CRTC state
;                                       for those devices which
;                                       changed under the remap
;                                       if this is non-0.
;                                       otherwise, don't.
;
; Returns:
;               eax                     A dword specifying which devices
;                                       have changed. If bit 0 is a 1,
;                                       then first device in the lpDevData
;                                       array was remapped. If bit 1, is a
;                                       1, then the 2nd device in lpDevData
;                                       array was remapped, etc...
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcRemapArray, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Just some setup
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Get all the attached devices
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData

        ; Ask the hardware to resolve the mappings so things
        ; will just work ;-).
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    lpHWCrtcCX
        push    eax
        call    HW_MapDevices
        push    eax

        ; Send a message around telling everyone that the
        ; hardware has remapped device assignments.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_SendDevicesRemapMsgToAllLogDevs

        pop     eax
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestoreAllCrtcStates
;
; Purpose:      This routine gets called to restore all the
;               CRTC states.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwRestoreStates         Restore the CRTC state
;                                       for those devices which
;                                       changed under the remap
;                                       if this is non-0.
;                                       otherwise, don't.
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestoreAllCrtcStates, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevDataMask
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Just some setup
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Get all the attached devices
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; We need to go into a loop here. Restore all states
        sub     edi,edi

        ; Get the Device Data Mask for all display devices.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ebx
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange

Loopit7:
        ; Is this CRTCCX valid?
        sub     ebx,ebx
        les     bx,lpGNCrtcCX
        push    dword ptr es:[ebx][edi * 4]
        push    esi
        call    GN_RestoreCrtcState
        inc     edi
        cmp     edi,dwDeviceCount
        jc      Loopit7

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetBytesPerPixelAndBytesPerLine
;
; Purpose:      This routine gets called to let the CRTCCX know
;               the current number of bytes per pixel and bytes
;               per line. It needs this to do panning.
;
; Arguments:
;               ds                      CX Sel
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetBytesPerPixelAndBytesPerLine, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     ebx,pGNLogdevCXOffset
        mov     ecx,pGNCrtcCXOffset
        movzx   eax,ds:[ebx].DIBENGINEHDR.deBitsPixel
        inc     eax
        shr     eax,3
        mov     ds:[ecx].GNCRTCCX.dwBytesPerPixelInCurrentMode,eax
        mov     eax,ds:[ebx].DIBENGINEHDR.deDeltaScan
        mov     ds:[ecx].GNCRTCCX.dwBytesPerLineInCurrentMode,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetPanRectangle
;
; Purpose:      This routine gets called whenever the panning
;               rectangle needs to be reset. The fields in
;               the GNCRTCCX.rcPhysicalViewport have been
;               modified and need to get set back into the
;               hardware.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetPanRectangle, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        ; Set the Pan Coordinates
        mov     ebx,pGNCrtcCXOffset
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        imul    eax,ds:[ebx].GNCRTCCX.dwBytesPerLineInCurrentMode
        mov     ecx,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        imul    ecx,ds:[ebx].GNCRTCCX.dwBytesPerPixelInCurrentMode
        add     eax,ecx

        ; Note that we must have a multiple of 4 for the hardware to
        ; pan to it, but this means the address may not match the
        ; rectangle coordinates exactly. We can fix that if it ever
        ; really becomes an issue. For right now, I'll ignore it.
        add     eax,3
        and     eax,NOT 3

        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    eax
        call    HW_SetPanOffset
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDevData
;
; Purpose:      This routine gets called to get the DevData for the
;               CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      GNCRTCCX.sCrtcModeInfo.MIDevData
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDevData, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     eax,pGNCrtcCXOffset
        lea     eax,[eax].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[eax].MODEINFO.MIDevData
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetDevData
;
; Purpose:      This routine gets called to set the DevData for the
;               CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               NewDevData              DEVDATA
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetDevData, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   NewDevData
OPENPROC
        mov     ecx,pGNCrtcCXOffset
        mov     eax,NewDevData
        lea     ecx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     ds:[ecx].MODEINFO.MIDevData,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_AssignCrtcModeOnlyBackOffSpatial
;
; Purpose:      This routine assigns the CRTC mode to be the mode
;               passed in. If the CRTC cannot do the mode passed
;               in, then back off ONLY the XRes, and YRes, to
;               get the mode that it can do. Try to leave the
;               refresh rate alone.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpNewModeInfo           DEVDATA
;
; Returns:      GNCRTCCX.CrtcDevData
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AssignCrtcModeOnlyBackOffSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpNewModeInfo
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Use the suggested mode passed in
        sub     edi,edi
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    es:[edi].MODEINFO.MIDevData
        sub     esi,esi
        lfs     si,lpNewModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        sub     edi,SIZE MODEINFO
        pop     es:[edi].MODEINFO.MIDevData

        mov     esi,pGNCrtcCXOffset

        ; We don't have a way to back off just the XRes,YRes at
        ; this point. This may back off the refresh rate. JKTODO
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCrtcMode
;
; Purpose:      This routine gets called to get the mode which should
;               be set on this CRTC.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpSuggMode              mode to use if no mode found
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetCrtcMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpSuggMode
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; First, if there is a forced mode we MUST set that
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetForcedDisplayMode,es,ax
        or      ax,ax
        jne     @F

        ; If not, just read the last mode that was set on this device
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     @F

        ; Use the suggested mode passed in
        sub     edi,edi
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    es:[edi].MODEINFO.MIDevData
        sub     esi,esi
        lfs     si,lpSuggMode
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        sub     edi,SIZE MODEINFO
        pop     es:[edi].MODEINFO.MIDevData
@@:
        
        ; Validate the mode but first update the color depth to match
        ; the desktop. It also resets the lpCrtcModeInfo passed in to
        ; something it can handle if the mode provided was out of its
        ; range.
        mov     esi,pGNCrtcCXOffset
        sub     edi,edi
        les     di,lpSuggMode
        mov     eax,es:[edi].MODEINFO.dwBpp
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        mov     es:[edi].MODEINFO.dwBpp,eax
        
        ; Now we are ready to validate!
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestrictOtherModeSpatial
;
; Purpose:      This routine gets called to munge down some other
;               mode to something smaller than the CRTC mode. If
;               the other mode is already smaller, then nothing
;               happens.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpOtherModeInfo         MODEINFO structure describing mode
;                                       to restrict CRTC mode to
;
; Returns:
;               eax     1 then mode was reduced
;                       0 then mode did not need to be changed
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestrictOtherModeSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpOtherModeInfo
OPENPROC
        PUSHR   esi

        mov     eax,pGNCrtcCXOffset
        sub     ebx,ebx
        lfs     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        sub     edx,edx
        les     dx,lpOtherModeInfo
        sub     esi,esi

        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     ecx,fs:[ebx].MODEINFO.dwYRes
        cmp     eax,es:[edx].MODEINFO.dwXRes
        jb      DropOther
        cmp     ecx,es:[edx].MODEINFO.dwYRes
        jae     IsOK

DropOther:
        mov     es:[edx].MODEINFO.dwXRes,eax
        mov     es:[edx].MODEINFO.dwYRes,ecx
        mov     esi,1
IsOK:
        mov     eax,esi
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestrictCrtcModeSpatial
;
; Purpose:      This routine gets called to munge down the CRTC
;               mode to something smaller than the other mode. If
;               the CRTC mode is already smaller, then nothing happens.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpOtherModeInfo         MODEINFO structure describing mode
;                                       to restrict CRTC mode to
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestrictCrtcModeSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpOtherModeInfo
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNCrtcCXOffset
        sub     ebx,ebx
        lfs     bx,lpOtherModeInfo
        sub     edx,edx
        les     dx,ds:[eax].GNCRTCCX.lpCrtcModeInfo

        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     ecx,fs:[ebx].MODEINFO.dwYRes

        cmp     eax,es:[edx].MODEINFO.dwXRes
        ja      @F
        mov     es:[edx].MODEINFO.dwXRes,eax
@@:
        cmp     ecx,es:[edx].MODEINFO.dwYRes
        ja      @F
        mov     es:[edx].MODEINFO.dwYRes,ecx
        
@@:
        ; We now need to validate this mode as it may not be a valid mode since
        ; both the XRes and YRes may not have been changed to the new value,
        ; e.g., if the desktop is 1600x900 and the GNCRTCCX.lpCrtcModeInfo
        ; is set to 1400x1050, we'll end up with 1400x900.
        mov     esi,pGNCrtcCXOffset
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcWriteModeToReg
;
; Purpose:      This routine can write out the phys CRTC mode to
;               the registry under certain conditions. It can either
;               always write it out, or only write it out if there
;               is no current phys mode in the registry for the
;               current CRTCCX device.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwFlag                  if FALSE, always write mode to reg
;                                       if TRUE, only write mode to reg if
;                                       there is no mode in the reg for it
;                                       already
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcWriteModeToReg, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   dwFlag
LOCALV  sModeInfo,MODEINFO
LOCALD  lpThisModeInfo
OPENPROC
        PUSHR   esi,edi

        cmp     dwFlag,0
        je      @F

        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpThisModeInfo,eax

        ; Copy the CRTC MODEINFO struct over to a temporary spot
        mov     edi,pGNCrtcCXOffset
        sub     esi,esi
        lfs     si,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        sub     edi,edi
        les     di,lpThisModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        ; Is there already a mode for it?
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        push    lpThisModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     DoneIt
@@:
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        push    ds:[eax].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax
DoneIt:
        POPR    esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_SetCrtcMode
;
; Purpose:      This routine gets called to get the mode which should
;               be set on this CRTC. This routine cannot fail. Hence,
;               the caller must have validated that this mode can be
;               set on this CRTC. The mode is revalidated in here
;               however, and backed down if there is a problem.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               pGNLogDevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetCrtcMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
LOCALD  lpSettableModeInfo
LOCALV  sSettableModeInfo,MODEINFO
LOCALD  dwTopEdge
LOCALD  dwLeftEdge
LOCALD  dwBottomEdge
LOCALD  dwRightEdge
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset

        ; Need this a few times
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableModeInfo
        mov     lpSettableModeInfo,eax

        ; Make sure the refresh rate list in the registry
        ; is the intersection of this specific hardware
        ; device and our board's capabilities.
        mov     ebx,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        lea     ebx,[ebx].MODEINFO.MIDevData
        push    ebx
        push    ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    ds:[edi].GNCRTCCX.lpEdidBuffer
        push    ds:[edi].GNCRTCCX.dwEdidSize
        call    FFP16 PTR lpfnResetRefreshRates

        ; Get the correct timings for this CRTC
        push    ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    ds:[edi].GNCRTCCX.lpEdidBuffer
        push    ds:[edi].GNCRTCCX.dwEdidSize
        push    ds:[edi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[edi].GNCRTCCX.lpCrtcModeOut
        push    lpSettableModeInfo
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        lfs     si,lpSettableModeInfo
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        mov     edi,pGNCrtcCXOffset

        ; Remember the bytes per pixel and bytes per line of this mode
        push    pGNLogDevCXOffset
        push    edi
        call    GN_SetBytesPerPixelAndBytesPerLine

        ; Update the mode pitch to the desktop pitch
        mov     ecx,pGNLogDevCXOffset
        mov     eax,ds:[ecx].DIBENGINEHDR.deDeltaScan
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        mov     fs:[bx].MODEOUT.dwPitchInBytes,eax

        ; Fill in the Format field of the ModeOut structure whether
        ; or not this is the primary physical device on the primary
        ; logical device
        cmp     ds:[edi].GNCRTCCX.dwLogicalDeviceInstance,0
        jne     NotPrimary
        cmp     ds:[edi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     NotPrimary
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        or      fs:[ebx].MODEOUT.dwFormat,10000000h

NotPrimary:
        ; Call the hardware to program the timings
        mov     ebx,pGNLogDevCXOffset
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    dword ptr ds:[ebx].DIBENGINEHDR.deBitsOffset
        push    ds:[edi].GNCRTCCX.lpCrtcModeOut
        call    HW_SetCrtcMode

        ; Get the registry key for whether or not a StopImage needs to
        ; be issued. If StopImage is issued, this will blank the display.
        mov     ebx,pGNLogDevCXOffset
        push    ds:[ebx].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetModesetStopImage,es,ax
        cmp     ax,1
        jne     SetViewPort
        
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        call    HW_SetStopImage
        jmp     Done
        
SetViewPort:
        ; Set the viewport coordinates
        push    ds:[edi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        mov     ax,ss
        shl     eax,10h
        lea     ax,dwLeftEdge
        push    eax
        lea     ax,dwTopEdge
        push    eax
        lea     ax,dwRightEdge
        push    eax
        lea     ax,dwBottomEdge
        push    eax
        CALLFAR16IND lpfnGetAutoPanMode,es,ax

        cmp     ax,0
        je      NoAutoPanRegKey

        ; Make sure the PhysicalViewport in the registry is smaller
        ; than the virtual mode.
        mov     ecx,pGNLogDevCXOffset
        movzx   edx,ds:[ecx].GNLOGDEVCX.Dibeng.deWidth
        cmp     edx,dwRightEdge
        jl      NoAutoPanRegKey
        movzx   edx,ds:[ecx].GNLOGDEVCX.Dibeng.deHeight
        cmp     edx,dwBottomEdge
        jl      NoAutoPanRegKey

        ; Make sure that the PhysicalViewport in the registry is the
        ; same dimensions as the mode that was set.
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        movzx   eax,fs:[ebx].MODEOUT.wXRes
        mov     edx,dwRightEdge
        sub     edx,dwLeftEdge
        cmp     eax,edx
        jne     NoAutoPanRegKey
        movzx   eax,fs:[ebx].MODEOUT.wYRes
        mov     edx,dwBottomEdge
        sub     edx,dwTopEdge
        cmp     eax,edx
        jne     NoAutoPanRegKey

SetScanLineStart:
        ; Use registry entry to set scanline start and freeze origin.
        mov     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,0
        mov     eax,dwTopEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     eax,dwLeftEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     eax,dwBottomEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     eax,dwRightEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        jmp     DoPanSet

NoAutoPanRegKey:
        ; No AutoPanMode registry entry start in upper left hand corner
        ; and enable PanAndScan.
        mov     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,1
        lea     ebx,ds:[edi].GNCRTCCX.sCrtcModeInfo
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,0
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,0
        mov     eax,ds:[ebx].MODEINFO.dwXRes
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     eax,ds:[ebx].MODEINFO.dwYRes
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax

DoPanSet:
        push    edi
        call    GN_SetPanRectangle

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDisplayDevice
;
; Purpose:      This routine gets called to get the desired display
;               device.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDisplayDevice, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
LOCALD  LocalDevData
OPENPROC
        mov     ebx,pGNCrtcCXOffset

        ; Now let us get the display device
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.dwLogicalDeviceInstance
        push    ds:[ebx].GNCRTCCX.dwPhysicalDeviceInstance
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnGetDisplayDevice,es,ax
        or      ax,ax
        jne     GetTVFormat

        ; We didn't find one so setup for CRT0
        mov     LocalDevData,DEVTYPE_CRT
        jmp     SetDevData
        
GetTVFormat:
        ; Get the TV format from the ResMan. IF this is not a TV, the Format
        ; will be returned as 0.
        mov     ebx,pGNCrtcCXOffset
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax

SetDevData:
        push    pGNCrtcCXOffset
        push    dword ptr LocalDevData
        call    GN_SetDevData
CLOSEPROC



;==============================================================================
;
; Function:     GN_SetCrtcGamma
;
; Purpose:      This function is called to set the gamma ramp.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pGammaRamp      ptr to gamma ramp
;                               256 words of red followed by
;                               256 words of greed followed by
;                               256 words of blue followed by
;                               Only the high byte of each
;                               word is relevant.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_SetCrtcGamma, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGammaRamp
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; First, copy the gamma table passed in
        mov     edi,pGammaRamp
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        mov     ecx,100H
@@:
        movzx   eax,byte ptr ds:[edi + 200H * 0 + 1]
        shl     eax,10H
        mov     ah,byte ptr ds:[edi + 200H * 1 + 1]
        mov     al,byte ptr ds:[edi + 200H * 2 + 1]
        add     edi,2
        mov     ds:[esi],eax
        add     esi,4
        dec     ecx
        jne     @B

        ; If we are in a palettized mode, then we are done!
        mov     esi,pGNCrtcCXOffset
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        je      Done

        lea     eax,[esi].GNCRTCCX.dwGammaTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCrtcGamma
;
; Purpose:      This function is called to get the gamma ramp.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pGammaRamp      ptr to gamma ramp
;                               256 words of red followed by
;                               256 words of greed followed by
;                               256 words of blue followed by
;                               Only the high byte of each
;                               word is relevant.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_GetCrtcGamma, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGammaRamp
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Copy the current gamma table to the passed in array ptr
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        mov     edi,pGammaRamp
        mov     ecx,100H
        sub     eax,eax
        sub     ebx,ebx
        sub     edx,edx
@@:
        mov     dh,ds:[esi + 0]
        mov     bh,ds:[esi + 1]
        mov     ah,ds:[esi + 2]
        add     esi,4
        mov     ds:[edi + 200H * 0],ax
        mov     ds:[edi + 200H * 1],bx
        mov     ds:[edi + 200H * 2],dx
        add     edi,2
        dec     ecx
        jne     @B

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetCrtcPalette
;
; Purpose:      This function is called to set the palette.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pPalette        ptr to palette
;                               256 dwords of XBGR
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_SetCrtcPalette, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pPalette
PARMD   dwFirstIndex
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset

        ; First, copy the gamma table passed in
        mov     esi,pPalette
        lea     edi,[edi].GNCRTCCX.dwPaletteTable
        mov     eax,dwFirstIndex
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        ; If we are not in a palettized mode, then we are done!
        mov     esi,pGNCrtcCXOffset
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        jne     Done

        lea     eax,[esi].GNCRTCCX.dwPaletteTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        push    dwFirstIndex
        push    dwNumEntries
        call    HW_SetPalette
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResetColorMap
;
; Purpose:      This function tells the hardware to reload the color
;               map -- either the palette or the gamma table, whichever
;               one is currently being used.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_ResetColorMap, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        