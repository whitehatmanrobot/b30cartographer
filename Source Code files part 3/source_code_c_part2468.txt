eak;
	case DMUS_PMSGT_PATCH:
		//DMUS_PATCH_PMSG
		((DMUS_PATCH_PMSG*)*ppPMsg)->byInstrument		= 1;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byMSB				= 0;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byLSB				= 0;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byPad[0]			= 0;
		break;
	case DMUS_PMSGT_SYSEX:
		//DMUS_SYSEX_PMSG
		//DWORD   dwLen;			// length of the data
		//BYTE    abData[1];		// array of data, length equal to dwLen
		break;
	case DMUS_PMSGT_TEMPO:
		//DMUS_TEMPO_PMSG
		((DMUS_TEMPO_PMSG*)*ppPMsg)->dblTempo			= 60;			// the tempo
		break;
	case DMUS_PMSGT_TIMESIG:
		//DMUS_TIMESIG_PMSG
	    //BYTE    bBeatsPerMeasure;	// beats per measure (top of time sig)
	    //BYTE    bBeat;			// what note receives the beat (bottom of time sig)
			                        // we can assume that 0 means 256th note
		//WORD    wGridsPerBeat;    // grids per beat
		break;
	case DMUS_PMSGT_TRANSPOSE:
		//DMUS_TRANSPOSE_PMSG 
		((DMUS_TRANSPOSE_PMSG*)*ppPMsg)->nTranspose		= -1;			// one half step down
	    //((DMUS_TRANSPOSE_PMSG*)*ppPMsg)->wMergeIndex;					// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
		break;
	case DMUS_PMSGT_CHANNEL_PRIORITY:
		//DMUS_CHANNEL_PRIORITY_PMSG 
	    //DWORD   dwChannelPriority;
		break;
	}

	// fail from here on out
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 13) Performance->ClonePMsg
	// **********************************************************************
	hr = pwPerformance->ClonePMsg((*ppPMsg),ppPMsgClone);
	if(FAILED(hr) || !(*ppPMsgClone))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::ClonePMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 14) Compare PMsgs
	// **********************************************************************
	hr = pTake->CompareTwoPMsgs((*ppPMsg),(*ppPMsgClone));
	if(FAILED(hr) || (hr == S_FALSE))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: CRecTake::CompareTwoPMsgs failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 15) Change cloned pmsg
	// **********************************************************************
	switch(dwPMsgType)
	{
	case DMUS_PMSGT_CURVE:
//		((DMUS_CURVE_PMSG*)*ppPMsgClone)->nStartValue		= 127;			// ignored
		((DMUS_CURVE_PMSG*)*ppPMsgClone)->nEndValue			= 0;		// fade out.
		break;
	case DMUS_PMSGT_MIDI:
		((DMUS_MIDI_PMSG*)*ppPMsgClone)->bByte2				= 127;		// higher
		break;
	case DMUS_PMSGT_NOTE:
		((DMUS_NOTE_PMSG*)*ppPMsgClone)->mtDuration			/= 8;		// shorter
		((DMUS_NOTE_PMSG*)*ppPMsgClone)->bMidiValue			+= 1;		// upa half step
		break;
	case DMUS_PMSGT_NOTIFICATION:
		break;
	case DMUS_PMSGT_PATCH:
		((DMUS_PATCH_PMSG*)*ppPMsgClone)->byInstrument		= 0;
		break;
	case DMUS_PMSGT_SYSEX:
		break;
	case DMUS_PMSGT_TEMPO:
		((DMUS_TEMPO_PMSG*)*ppPMsgClone)->dblTempo			= 200;		// the tempo
		break;
	case DMUS_PMSGT_TIMESIG:
		break;
	case DMUS_PMSGT_TRANSPOSE:
		((DMUS_TRANSPOSE_PMSG*)*ppPMsgClone)->nTranspose	= 2;		// two steps up
		break;
	case DMUS_PMSGT_CHANNEL_PRIORITY:
		break;
	}
	// **********************************************************************
	// 16) Performance->PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx(pwSegment,0,NULL,DMUS_SEGF_BEAT,0,&pwSegState,NULL,pNewPath); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 17) Performance->GetLatencyTime
	// **********************************************************************
	hr = pwPerformance->GetLatencyTime(&rtTimeNow);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: Performance->GetLatencyTime failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 18) Performance->ReferenceToMusicTime
	// **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime(rtTimeNow,&mtTimeNow);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: Performance->ReferenceToMusicTime failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	(*ppPMsg)->mtTime		= mtTimeNow; 				// at next measure boundary
	(*ppPMsgClone)->mtTime	= mtTimeNow + (768 * 4);	// 4 beats past the first pmsg.
	// **********************************************************************
	// 19) SegState->QueryInterface(IID_IDirectMusicGraph
	// **********************************************************************
	hr = pwSegState->QueryInterface(IID_IDirectMusicGraph,(void **) &pGraph);
	if(FAILED(hr) || !pGraph)
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMSegmentState::QueryInterface(IID_IDirectMusicGraph) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 20) Graph->StampPMsgs
	// **********************************************************************
	hr = pGraph->StampPMsg(*ppPMsg);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMToolGraph::StampPMsg(pPMsg) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pGraph->StampPMsg(*ppPMsgClone);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMToolGraph::StampPMsg(pPMsgClone) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 21) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 100; // once every 100 mseconds
	iCheckPlaying = 300; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: PlaySegment (first Segment) timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 22) Performance->SendPMsg(both)
	// **********************************************************************
	hr = pwPerformance->SendPMsg(*ppPMsg);
	if(FAILED(hr))
	{
		pwPerformance->FreePMsg(*ppPMsg);
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::SendPMsg(Curve) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->SendPMsg(*ppPMsgClone);
	if(FAILED(hr))
	{
		pwPerformance->FreePMsg(*ppPMsgClone);
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::SendPMsg(Clone) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 23) Wait for IsPlaying to be false
	// **********************************************************************
	counter = 0;
	SleepTime = 1000; // once a second
	iCheckPlaying = 30; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::IsPlaying did not return false (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// we got this far we must have passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 24) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	delete pTake;

	if(pGraph)
	{
		pGraph->Release();
		pGraph = NULL;
	}
	if(pwGraph)
	{
		pwGraph->Release();
		pwGraph = NULL;
	}
	if(pNewPath)
	{
		pNewPath->Release();
		pNewPath = NULL;
	}
	if(pwSegState)
	{
		pwSegState->Release();
		pwSegState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::ClonePMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::ClonePMsg()<nl>
//
// Test Function: <nl>
// tdmperv8AllocPMsgChannelGroup()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance <nl>
//  3) CoCreateLoader<nl>
//  4) Loader->GetObject(Segment)<nl>
//  5) Performance->InitAudio<nl>
//  6) Performance->CreateStandardAudioPath<nl>
//  7) Create Test Tool<nl>
//  8) CoCreateGraph<nl>
//  9) Performance->SetGraph<nl>
//  10) Segment->SetParam(GUID_Download)<nl>
//  11) Performance->AllocPMsg<nl>
//  12) Set PMsg values<nl>
//  13) Performance->ClonePMsg<nl>
//  14) Compare PMsgs<nl>
//  15) Change cloned pmsg<nl>
//  16) Performance->PlaySegmentEx<nl>
//  17) Performance->GetLatencyTime<nl>
//  18) Performance->ReferenceToMusicTime<nl>
//  19) SegState->QueryInterface(IID_IDirectMusicGraph<nl>
//  20) Graph->StampPMsgs<nl>
//  21) Wait for IsPlaying to be true<nl>
//  22) Performance->SendPMsg(both)<nl>
//  23) Wait for IsPlaying to be false<nl>
//  24) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//	04/18/2000 - kcraven - finished<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8AllocPMsgChannelGroup(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath		= NULL;
	CtIDirectMusicLoader*		pwLoader		= NULL;
	CtIDirectMusicSegment*		pwSegment		= NULL;
	CtIDirectMusicSegmentState* pwSegState		= NULL;
	CtIDirectMusicGraph*		pwGraph 		= NULL;
	IDirectMusicGraph*			pGraph			= NULL;

	DWORD						dwPMsgFlags		= NULL;			// additional flags to set	
	DWORD						dwPChannel		= (DWORD)dwParam1; 
	DWORD						dwPMsgType		= (DWORD)dwParam2; //DMUS_PMSGT_NOTE;
	ULONG 						ulPMsgSize;

	// generic pointer
	DMUS_PMSG**					ppPMsg;

//	DMUS_PMSG*					pBase;
//	DMUS_CHANNEL_PRIORITY_PMSG*	pChanPri;
	DMUS_CURVE_PMSG*			pCurve;
	DMUS_MIDI_PMSG*				pMidi;
	DMUS_NOTE_PMSG*				pNote;
//	DMUS_NOTIFICATION_PMSG*		pNotify;
	DMUS_PATCH_PMSG*			pPatch;
//	DMUS_SYSEX_PMSG*			pSysex;
	DMUS_TEMPO_PMSG*			pTempo;
//	DMUS_TIMESIG_PMSG*			pTimeSig;
	DMUS_TRANSPOSE_PMSG*		pTrans;

	MUSIC_TIME					mtTimeNow;
	REFERENCE_TIME				rtTimeNow;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"testdrum.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc; 

//	MUSIC_TIME					mtLength;
//	REFERENCE_TIME				rtLength;
//	REFERENCE_TIME				rtMeasure;
//	REFERENCE_TIME				rtTmp;

	// gets intialized below
	int 						counter;
	int 						SleepTime;
	int 						iCheckPlaying; 

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader->GetObject(Segment)
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->InitAudio
	// **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,0,0,0,NULL); // don't create and audiopath 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Performance->CreateStandardAudioPath
	// **********************************************************************
	hr = pwPerformance->CreateStandardAudioPath(
		dwType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		TRUE,
		&pNewPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->CreateStandardAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pNewPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pNewPath is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 8) CoCreateGraph
	// **********************************************************************
	hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Performance->SetGraph
	// **********************************************************************
	hr = pwPerformance->SetGraph(pwGraph);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->SetGraph "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 10) Segment->SetParam(GUID_Download)
	// **********************************************************************	
	hr = pwPerformance->GetRealObjPtr(&pPerformance);
	if (FAILED( hr ))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
				"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 11) Performance->AllocPMsg
	// **********************************************************************
	if(dwPMsgType == NULL)
	{
		dwPMsgType = DMUS_PMSGT_NOTE;
	}
	switch(dwPMsgType)
	{
	case DMUS_PMSGT_CURVE:
		ulPMsgSize = sizeof(DMUS_CURVE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pCurve;
		break;
	case DMUS_PMSGT_MIDI:
		ulPMsgSize = sizeof(DMUS_MIDI_PMSG);
		ppPMsg = (DMUS_PMSG**)&pMidi;
		break;
	case DMUS_PMSGT_NOTE:
		ulPMsgSize = sizeof(DMUS_NOTE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pNote;
		break;
	case DMUS_PMSGT_PATCH:
		ulPMsgSize = sizeof(DMUS_PATCH_PMSG);
		ppPMsg = (DMUS_PMSG**)&pPatch;
		break;
	case DMUS_PMSGT_TEMPO:
		ulPMsgSize = sizeof(DMUS_TEMPO_PMSG);
		ppPMsg = (DMUS_PMSG**)&pTempo;
		break;
	case DMUS_PMSGT_TRANSPOSE:
		ulPMsgSize = sizeof(DMUS_TRANSPOSE_PMSG);
		ppPMsg = (DMUS_PMSG**)&pTrans;
		break;
	default:
		//not tested at the moment
		fnsLog(ABORTLOGLEVEL, TEXT("**** PENDING: PMsg type unsupported in this test case"));
		dwRes = FNS_PENDING;
		goto TEST_END;
	}

	// fail from here on out
	dwRes = FNS_FAIL;

	hr = pwPerformance->AllocPMsg(ulPMsgSize,(DMUS_PMSG**)ppPMsg);
	if(FAILED(hr) || !(*ppPMsg))
	{
		fnsLog(BUGLOGLEVEL,TEXT("**** ABORT: IDMPerformance::AllocPMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 12) Set PMsg values
	// **********************************************************************
	/*
		// common to all pmsgs

			#define DMUS_PMSG_PART                                                                              
			DWORD               dwSize;
			REFERENCE_TIME      rtTime;             //  real time (in 100 nanosecond increments)
			MUSIC_TIME          mtTime;             //  music time
			DWORD               dwFlags;            //  various bits (see DMUS_PMSGF_FLAGS enumeration)
			DWORD               dwPChannel;         //  Performance Channel. The Performance can
													//  use this to determine the port/channel.
			DWORD               dwVirtualTrackID;   //  virtual track ID
			IDirectMusicTool*   pTool;              //  tool interface pointer
			IDirectMusicGraph*  pGraph;             //  tool graph interface pointer
			DWORD               dwType;             //  PMSG type (see DMUS_PMSGT_TYPES defines)
			DWORD               dwVoiceID;          //  unique voice id which allows synthesizers to
													//  identify a specific event. For DirectX 6.0,
													//  this field should always be 0.
			DWORD               dwGroupID;          //  Track group id
			IUnknown*           punkUser;           //  user com pointer, auto released upon PMSG free
	*/

	// these are the choices for dwPChannel
    // dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH,
    // dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS,
    // dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE,
    // dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT,
	(*ppPMsg)->dwPChannel = dwPChannel;
	(*ppPMsg)->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8 | dwPMsgFlags;
	(*ppPMsg)->dwVirtualTrackID = 0;
	(*ppPMsg)->dwGroupID = -1;
	(*ppPMsg)->dwType = dwPMsgType;

	switch(dwPMsgType)
	{
	case DMUS_PMSGT_CURVE:
		//DMUS_CURVE_PMSG
		((DMUS_CURVE_PMSG*)*ppPMsg)->mtDuration			= 768 * 4;		// Curve lasts four beats.
		((DMUS_CURVE_PMSG*)*ppPMsg)->mtResetDuration	= 0;			// No reset.
		((DMUS_CURVE_PMSG*)*ppPMsg)->nStartValue		= 0;			// ignored
		((DMUS_CURVE_PMSG*)*ppPMsg)->nEndValue			= 127;			// fade to full volume.
		((DMUS_CURVE_PMSG*)*ppPMsg)->nResetValue		= 0;			// No reset.
		((DMUS_CURVE_PMSG*)*ppPMsg)->bType				= DMUS_CURVET_CCCURVE;
		((DMUS_CURVE_PMSG*)*ppPMsg)->bCurveShape		= DMUS_CURVES_LINEAR;
		((DMUS_CURVE_PMSG*)*ppPMsg)->bCCData			= 7;			// MIDI Volume controller.
		((DMUS_CURVE_PMSG*)*ppPMsg)->bFlags				= DMUS_CURVE_START_FROM_CURRENT; 
		((DMUS_CURVE_PMSG*)*ppPMsg)->wParamType			= 0; 			// This is for NRPN and RPN only.
		((DMUS_CURVE_PMSG*)*ppPMsg)->wMergeIndex		= 1;			// This will be added to the regular volume, not override it.
		break;
	case DMUS_PMSGT_MIDI:
		//DMUS_MIDI_PMSG
		((DMUS_MIDI_PMSG*)*ppPMsg)->bStatus				= MIDI_CCHANGE;
		((DMUS_MIDI_PMSG*)*ppPMsg)->bByte1				= 10;			// pan
		((DMUS_MIDI_PMSG*)*ppPMsg)->bByte2				= 0;			// left
		((DMUS_MIDI_PMSG*)*ppPMsg)->bPad[0]				= 0;
		break;
	case DMUS_PMSGT_NOTE:
		//DMUS_NOTE_PMSG
		((DMUS_NOTE_PMSG*)*ppPMsg)->mtDuration			= 768 * 8;		// duration
		((DMUS_NOTE_PMSG*)*ppPMsg)->wMusicValue			= 0;			// Description of note in chord and key
		((DMUS_NOTE_PMSG*)*ppPMsg)->wMeasure			= 0;			// Measure in which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->nOffset				= 0;			// Offset from grid at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bBeat				= 0;			// Beat (in measure) at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bGrid				= 0;			// Grid offset from beat at which this note occurs
		((DMUS_NOTE_PMSG*)*ppPMsg)->bVelocity			= 90;			// Note velocity
		((DMUS_NOTE_PMSG*)*ppPMsg)->bFlags				= DMUS_NOTEF_NOTEON;	// see DMUS_NOTEF_FLAGS
		((DMUS_NOTE_PMSG*)*ppPMsg)->bTimeRange			= 0;			// Range to randomize time
		((DMUS_NOTE_PMSG*)*ppPMsg)->bDurRange			= 0;			// Range to randomize duration
		((DMUS_NOTE_PMSG*)*ppPMsg)->bVelRange			= 0;			// Range to randomize velocity
		((DMUS_NOTE_PMSG*)*ppPMsg)->bPlayModeFlags		= DMUS_PLAYMODE_FIXED;	// Play mode
		((DMUS_NOTE_PMSG*)*ppPMsg)->bSubChordLevel		= 0;			// Which subchord level this note uses
		((DMUS_NOTE_PMSG*)*ppPMsg)->bMidiValue			= 36;			// The MIDI note value, converted from wMusicValue
		((DMUS_NOTE_PMSG*)*ppPMsg)->cTranspose			= 0;			// Transposition to add to midi note value after converted from wMusicValue
		break;
	case DMUS_PMSGT_PATCH:
		//DMUS_PATCH_PMSG
		((DMUS_PATCH_PMSG*)*ppPMsg)->byInstrument		= 1;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byMSB				= 0;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byLSB				= 0;
		((DMUS_PATCH_PMSG*)*ppPMsg)->byPad[0]			= 0;
		break;
	case DMUS_PMSGT_TEMPO:
		//DMUS_TEMPO_PMSG
		((DMUS_TEMPO_PMSG*)*ppPMsg)->dblTempo			= 60;			// the tempo
		break;
	case DMUS_PMSGT_TRANSPOSE:
		//DMUS_TRANSPOSE_PMSG 
		((DMUS_TRANSPOSE_PMSG*)*ppPMsg)->nTranspose		= -1;			// one half step down
		break;
	}
	// **********************************************************************
	// 16) Performance->PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx(pwSegment,0,NULL,DMUS_SEGF_BEAT,0,&pwSegState,NULL,pNewPath); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 17) Performance->GetLatencyTime
	// **********************************************************************
	hr = pwPerformance->GetLatencyTime(&rtTimeNow);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: Performance->GetLatencyTime failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 18) Performance->ReferenceToMusicTime
	// **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime(rtTimeNow,&mtTimeNow);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: Performance->ReferenceToMusicTime failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	(*ppPMsg)->mtTime		= mtTimeNow + (768 * 4); 				// at next measure boundary

	// **********************************************************************
	// 19) SegState->QueryInterface(IID_IDirectMusicGraph
	// **********************************************************************
	hr = pwSegState->QueryInterface(IID_IDirectMusicGraph,(void **) &pGraph);
	if(FAILED(hr) || !pGraph)
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMSegmentState::QueryInterface(IID_IDirectMusicGraph) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 20) Graph->StampPMsgs
	// **********************************************************************
	hr = pGraph->StampPMsg(*ppPMsg);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMToolGraph::StampPMsg(pPMsg) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 21) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 100; // once every 100 mseconds
	iCheckPlaying = 300; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: PlaySegment (first Segment) timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 22) Performance->SendPMsg(both)
	// **********************************************************************
	hr = pwPerformance->SendPMsg(*ppPMsg);
	if(FAILED(hr))
	{
		pwPerformance->FreePMsg(*ppPMsg);
		fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::SendPMsg(Curve) failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 23) Wait for IsPlaying to be false
	// **********************************************************************
	counter = 0;
	SleepTime = 1000; // once a second
	iCheckPlaying = 30; // check for 30 seconds max
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(BUGLOGLEVEL,TEXT("!!!! BUG: IDMPerformance::IsPlaying did not return false (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// we got this far we must have passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 24) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pGraph)
	{
		pGraph->Release();
		pGraph = NULL;
	}
	if(pwGraph)
	{
		pwGraph->Release();
		pwGraph = NULL;
	}
	if(pNewPath)
	{
		pNewPath->Release();
		pNewPath = NULL;
	}
	if(pwSegState)
	{
		pwSegState->Release();
		pwSegState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::CloseDown()<nl>
//
// Test Function: <nl>
// tdmperv8CloseDownTwiceTest()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	07/11/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8CloseDownTwiceTest(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	WCHAR*						pszFile			= L"test.mid";
	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusicLoader8		*pwLoader		= NULL;
	CtIDirectMusicPerformance8	*pwPerformance	= NULL;
	IDirectMusicPerformance8	*pPerformance	= NULL;
	CtIDirectMusicSegment8		*pwSegment		= NULL;

	DMUS_OBJECTDESC 			desc; 

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	DWORD						testtype		= (DWORD)dwParam2;

	switch(testtype)
	{
		case 1:
		case 2:
			break;
		default:
			return FNS_PENDING;
	}
	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,pszFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************
	switch(testtype)
	{
	case 1:
		hr = pwPerformance->Init(NULL,NULL,ghWnd);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		// **********************************************************************
		// 4.1) Add the Port
		// **********************************************************************	
		hr = pwPerformance->AddPort( NULL );
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 2:
		hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,DMUS_APATH_SHARED_STEREOPLUSREVERB,64,NULL,NULL);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->InitAudio(DMUS_APATH_SHARED_STEREOPLUSREVERB) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	hr = pwSegment->Download(pwPerformance); 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPerformance) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,			// Segment to play 
		0,NULL, 			// Optional stuff NULL. 
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff is NULL. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	Sleep(1000);
	// **********************************************************************
	// 4.2) CloseDown
	// **********************************************************************	
	hr = pwPerformance->CloseDown(); 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: First pwPerformance->CloseDown() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) CloseDown
	// **********************************************************************	
	hr = pwPerformance->CloseDown(); 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: Second pwPerformance->CloseDown() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwSegment && pwPerformance)
	{
		pwSegment->Unload(pwPerformance);
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::CreateAudioPath()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::CreateAudioPath(). <nl>
//
// Test Function: <nl>
// tdmperv8CreateAudioPath() <nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp <nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreateLoader<nl>
//  3) Loader8->SetSearchDirectory<nl>
//  4) Loader8->ScanDirectory<nl>
//  5) Loader8->GetObject(segment)<nl>
//  6) Segment8->GetAudioPathConfig<nl>
//  7) CoCreatePerformance<nl>
//  8) Performance8->InitAudio<nl>
//  9) Performance8->CreateAudioPath<nl>
//  10) AudioPath->GetObjectInPath(port)<nl>
//  11) Segment8->Download<nl>
//  12) Performance8->PlaySegmentEx<nl>
//  13) Wait for IsPlaying to be true<nl>
//  14) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8CreateAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_ABORTED;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
	CtIUnknown* 				pAudioPathConfig	= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	DMUS_OBJECTDESC 			desc; 
	DMUS_PORTCAPS				caps;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	DWORD						dwIndex 			= 0;
	IDirectMusicPort*			pDMPort 			= NULL;

	WCHAR	wszAudioPath[DMUS_MAX_FILENAME];
	WCHAR	wszSegment[DMUS_MAX_FILENAME];
	dmthSetPath(NULL);
	WCHAR	*wchPath	= gwszBasePath;
	WCHAR	*wchFile	= gwszMediaPath;
	BOOL	bGetAudPath	= FALSE;

	dwRes = FNS_ABORTED;

	if(dwParam1)
	{
		wcscpy(wszAudioPath,(WCHAR*)dwParam1); // special file
	}
	else
	{
		wcscpy(wszAudioPath,L"Standard.aud");	// default file
		bGetAudPath	= TRUE;	// attempt to get audiopathconfig from segment 
	}
	if(dwParam2)
	{
		wcscpy(wszSegment,(WCHAR*)dwParam2); // special file
	}
	else
	{
		wcscpy(wszSegment,L"test.mid"); // default file
	}

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicLoader object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) Loader8->SetSearchDirectory
	// **********************************************************************
	hr = pwLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader8->ScanDirectory
	// **********************************************************************
	hr = pwLoader8->ScanDirectory(CLSID_DirectMusicCollection, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(dls) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader8->ScanDirectory(CLSID_DirectMusicStyle, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(style) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Loader8->GetObject(segment)
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,wszSegment);
	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Segment8->GetAudioPathConfig
	// **********************************************************************
	// try to get the audiopathconfig if we are using the default
	if(bGetAudPath)
	{
		// expected to fail if the segment has no audiopath config 
		hr = pwSegment8->GetAudioPathConfig(&pAudioPathConfig);
		 
		if(FAILED(hr) && (hr != DMUS_E_NO_AUDIOPATH_CONFIG))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Segment8->GetAudioPathConfig(pAudioPathConfig) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// if there is no audiopathconfig in the segment use the default
	if((!bGetAudPath) || ((bGetAudPath) && FAILED(hr)))
	{
		ZeroMemory(&desc, sizeof(desc));
		desc.dwSize = sizeof(DMUS_OBJECTDESC);
		desc.guidClass = CLSID_DirectMusicAudioPathConfig;
		desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
		wcscpy(desc.wszFileName,wszAudioPath);

		hr = pwLoader8->GetObject(&desc,CTIID_IUnknown,(void **)&pAudioPathConfig);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader8->GetObject(pAudioPathConfig) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 7) CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 8) Performance8->InitAudio
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		NULL,	// Can be NULL, pointer to NULL, or valid
		NULL,	// Can be NULL, pointer to NULL, or valid 
		ghWnd,	// HWND for initializing DSound.
		0,		// Requested standard audio path or 0.
		0,		// Number of PChannels, if default audio path to be created.
		0,		// Sample rate for all ports and DSound sink
		NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// fail from here on out
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 9) Performance8->CreateAudioPath
	// **********************************************************************
	hr = pwPerformance8->CreateAudioPath(pAudioPathConfig,TRUE,&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 10) AudioPath->GetObjectInPath(port)
	// **********************************************************************
	dwIndex = 0;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_PORT,0,GUID_All_Objects,dwIndex,IID_IDirectMusicPort,(void**)&pDMPort)))
	{
		// Go on to the next port in the audio path
		dwIndex++;

		if(pDMPort)
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s)"),dwIndex,tdmXlatHRESULT(hr));
			ZeroMemory(&caps, sizeof(DMUS_PORTCAPS));
			caps.dwSize = sizeof(DMUS_PORTCAPS);
			hr = pDMPort->GetCaps(&caps);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPort->GetCaps ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			}
			else
			{
				fnsIncrementIndent();
				tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL,&caps);
				fnsDecrementIndent();
			}
			// Release the port
			pDMPort->Release();
			pDMPort = NULL;
		}
		else
		{
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT NOT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s) but pPort is NULL"),dwIndex,tdmXlatHRESULT(hr));
		}

	}
	if(FAILED(hr) && (DMUS_E_NOT_FOUND != hr) || (dwIndex < 1))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 11) Segment8->Download
	// **********************************************************************	
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 12) Performance8->PlaySegmentEx
	// **********************************************************************	
	hr = pwPerformance8->PlaySegmentEx( 
		pwSegment8, 	// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		NULL,			// DMUS_SEGF_ flags.
		0,				// Time to start playback. 
		NULL,			// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		pAudioPath);	// Optional audioPath to play on. 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 13) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// we go to here - we passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 14) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8 && pwSegment8)
	{
		pwSegment8->Unload(pwPerformance8); //we don't care if this fails at the moment
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pDMPort)
	{
		pDMPort->Release();
		pDMPort = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPathConfig)
	{
		pAudioPathConfig->Release();
		pAudioPathConfig = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::CreateStandardAudioPath()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::CreateStandardAudioPath().<nl>
//
// Test Function: <nl>
// tdmperv8CreateStandardAudioPath()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create CtIDirectMusicPerformance8 object<nl> 
//	 3.0) Create CtIDirectMusicLoader object <nl>
//	 3.3) Get a Segment<nl>
//	 4) InitAudio the performance<nl>
//	 5) Call CreateStandardAudioPath - the function to be tested<nl>
//	 6.0.0) Verify the results - the audio path is no NULL<nl>
//	 6.1.0) Play the segment - Download the band<nl>
//	 6.1.1) PlaySegmentEx<nl>
//	 6.1.2) Wait for IsPlaying to return true (or time out)<nl>
//	 6.3) Verification - Get a known object (port) out of the audio path.<nl>
//	 6.4) Verification - Call QI for the same type object to Verify it's what we think it is<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8CreateStandardAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance8	= NULL;
	IDirectMusicPerformance8*	pPerformance	= NULL;
	CtIDirectMusicAudioPath*	pNewPath1		= NULL;
	CtIDirectMusicAudioPath*	pNewPath2		= NULL;
//	CtIDirectMusicAudioPath*	pNewPath3		= NULL;
	CtIDirectMusicAudioPath**	ppNewPath		= NULL;
	CtIDirectMusicLoader*		pwLoader		= NULL;
	CtIDirectMusicSegment*		pwSegment		= NULL;

	IUnknown*					pUnknown		= NULL;
	IUnknown*					pUnkQI			= NULL;
	DWORD						dwStage;
	DWORD						dwBuffer;
	GUID						guidObject;
	GUID						guidInterface;
//	int 						index			= 0;
	int 						getobj			= 1; // how may times to getobjectinpath	

	BOOL						doenv			= (BOOL)fCoCreate;
	DWORD						dwType;
	DWORD						dwType1			= (DWORD)dwParam1;
	DWORD						dwType2			= (DWORD)dwParam2; // if not NULL this path gets created first. It may share a port with the next path. 
	DWORD						dwPChannelCount = 16;

	WCHAR						pMidiFile[] 	= L"test.mid";
	dmthSetPath(pMidiFile);
	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc; 

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create CtIDirectMusicPerformance8 object 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) Create CtIDirectMusicLoader object 
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Get a Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
//	fnsIncrementIndent();
//	fnsLog(FYILOGLEVEL, TEXT("**** FYI: Loader->GetObject(pwSegment) ")
//				TEXT("returned (%s == %08Xh)"),
//				tdmXlatHRESULT(hr), hr);
//	fnsDecrementIndent();
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) InitAudio the performance
	// **********************************************************************
	hr = pwPerformance8->InitAudio(NULL,NULL,ghWnd,0,0,0,NULL); // don't create an audiopath 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	// fail from no on
	dwRes = FNS_FAIL;

	// **********************************************************************
	// 8) Call CreateStandardAudioPath - the function to be tested
	// **********************************************************************
	hr = pwPerformance8->CreateStandardAudioPath(
		dwType1, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		TRUE,
		&pNewPath1);
	if(FAILED(hr))

	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateStandardAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Verify the results - the audio path is no NULL
	// **********************************************************************
	if(!pNewPath1)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pNewPath1 is NULL"));
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Call CreateStandardAudioPath - the function to be tested
	// **********************************************************************
	if(dwType2)
	{
		hr = pwPerformance8->CreateStandardAudioPath(
			dwType2, 			// Choice of standard audio path.
			dwPChannelCount,	// How many pchannels to create.
			TRUE,
			&pNewPath2);
		if(FAILED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->CreateStandardAudioPath ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	// **********************************************************************
	// 7) Verify the results - the audio path is no NULL
	// **********************************************************************
		if(!pNewPath2)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pNewPath2 is NULL"));
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 10) Call CreateStandardAudioPath - the function to be tested
	// **********************************************************************
	if(pNewPath2)
	{
		ppNewPath = &pNewPath2;
		dwType = dwType2;
		getobj++; // do getobjectinpath one more time
	}
	else
	{
		ppNewPath = &pNewPath1;
		dwType = dwType1;
	}
	// **********************************************************************
	// 11) Play the segment - Download the band
	// **********************************************************************	
	hr = pwPerformance8->GetRealObjPtr(&pPerformance);
	if (FAILED( hr ))
	{
		fnsLog(ABORTLOGLEVEL, "!!!! BUG: Failed to get Real Object Pointer(performance) "
				"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwSegment->SetParam(Download) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 12) PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx( 
		pwSegment,		// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		DMUS_SEGF_BEAT, // DMUS_SEGF_ flags.
		0,				// Time to start playback. 
		NULL,			// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		(*ppNewPath));		// Optional audioPath to play on. 

	// playback is expectedto fail on an env only path
/*DANDAN
	if(DMUS_APATH_GLOBALFX_ENV == dwType)
	{
		if(SUCCEEDED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->PlaySegmentEx ")
					TEXT("should have but did not fail (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	else
	{
*/
		if(FAILED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegment ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	// **********************************************************************
	// 13) Wait for IsPlaying to return true (or time out)
	// **********************************************************************
		counter = 0;
		SleepTime = 1000;
		while ((hr = pwPerformance8->IsPlaying(pwSegment, NULL)) != S_OK)	
		{
			Sleep(SleepTime);
			if(counter++ >TimeOutValue)
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
					TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
//	}
	// **********************************************************************
	// 14) Verification - Get a known object (port) out of the audio path.
	// **********************************************************************
	while((getobj--) > 0)
	{
		switch(dwType)
		{
		case DMUS_APATH_SHARED_STEREOPLUSREVERB:
			dwStage 		= DMUS_PATH_BUFFER;
			guidObject		= GUID_All_Objects; //GUID_Buffer_Reverb;
			guidInterface	= IID_IDirectSoundBuffer;
			dwBuffer		= 1;
			break;
		case DMUS_APATH_DYNAMIC_3D:
			dwStage 		= DMUS_PATH_BUFFER;
			guidObject		= GUID_All_Objects; //GUID_Buffer_3D;
			guidInterface	= IID_IDirectSound3DBuffer8;
			dwBuffer		= 0;
			break;
		case DMUS_APATH_DYNAMIC_MONO:
			dwStage 		= DMUS_PATH_BUFFER;
			guidObject		= GUID_All_Objects; //GUID_Buffer_Mono;
			guidInterface	= IID_IDirectSoundBuffer;
			dwBuffer		= 0;
			break;
		case DMUS_APATH_DYNAMIC_STEREO:
			dwStage 		= DMUS_PATH_BUFFER;
			guidObject		= GUID_All_Objects; //GUID_Buffer_Stereo;
			guidInterface	= IID_IDirectSoundBuffer;
			dwBuffer		= 0;
			break;
        default:
			fnsLog(ABORTLOGLEVEL, "TEST APP ERROR!!!  Kelly's the wave of the future, but he's using an invalid type");
			goto TEST_END;
            
		}
		hr = (*ppNewPath)->GetObjectInPath(
			DMUS_PCHANNEL_ALL,		//dwPChannel
			dwStage,				//dwStage
			dwBuffer,				//dwBuffer
			guidObject, 			//guidObject
			0, //index,				//dwIndex
			guidInterface,			//idInterface
			(void **)&pUnknown);	//pinterface
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: AudioPath->GetObjectInPath ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		// **********************************************************************
		// 15) Verify the results - the audio path is no NULL
		// **********************************************************************
		if(!pUnknown)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pUnknown is NULL"));
			goto TEST_END;
		}
		// **********************************************************************
		// 16) Verification - Call QI for the same type object to Verify it's what we think it is
		// **********************************************************************
		hr = pUnknown->QueryInterface(guidInterface, (void **)&pUnkQI);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: IUnknown->QueryInterface ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}

		// if we have path2 we have two paths
		// and we were using type2 the first time
		// so we set it back to type1 for the next time
		if(pNewPath2)
		{
			dwType = dwType1;
			ppNewPath = &pNewPath1;
		}

		// cleanup for the next time
		if(pUnknown)
		{
			pUnknown->Release();
			pUnknown = NULL;
		}
		if(pUnkQI)
		{
			pUnkQI->Release();
			pUnkQI = NULL;
		}
	}

	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// we passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 17) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pUnknown)
	{
		pUnknown->Release();
		pUnknown = NULL;
	}
	if(pUnkQI)
	{
		pUnkQI->Release();
		pUnkQI = NULL;
	}
	if(pPerformance && pwSegment)
	{
		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pNewPath1)
	{
		pNewPath1->Release();
		pNewPath1 = NULL;
	}
	if(pNewPath2)
	{
		pNewPath2->Release();
		pNewPath2 = NULL;
	}
/*DANDAN
	if(pNewPath3)
	{
		pNewPath3->Release();
		pNewPath3 = NULL;
	}
*/
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::GetDefaultAudioPath()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::GetDefaultAudioPath().<nl>
//
// Test Function: <nl>
// tdmperv8GetDefaultAudioPath()
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance <nl>
//  3) CoCreateLoader<nl>
//  4) Loader8->GetObject <nl>
//  5) Performance8->InitAudio<nl>
//  6) Performance8->CreateStandardAudioPath<nl>
//  7) Performance8->GetDefaultAudioPath<nl>
//  8) Segment8->Download<nl>
//  9) Performance8->PlaySegmentEx<nl>
//  10) Wait for IsPlaying to be true<nl>
//  11) Verify the audiopath<nl>
//  12) Wait for IsPlaying to be false<nl>
//  13) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8GetDefaultAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_ABORTED;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	CtIDirectMusicAudioPath*	pAudioPath2			= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
	DMUS_OBJECTDESC 			desc; 
	DWORD						dwDefaultPathType	= dwParam1;
	DWORD						dwType2				= dwParam2;
	DWORD						dwPChannelCount 	= 64;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	dmthSetPath(L"test.mid");
//	WCHAR	*wchPath	= gwszBasePath;
	WCHAR	*wchFile	= gwszMediaPath;

	PATH_DEFINITION*		ppPathDef = NULL;		

	switch(dwParam1)
	{
	case DMUS_APATH_SHARED_STEREOPLUSREVERB:
		ppPathDef = &g_DefaultPathStereoPlusReverb;
		break;
	case DMUS_APATH_DYNAMIC_3D:
		break;
	case DMUS_APATH_DYNAMIC_MONO:
		break;
	case DMUS_APATH_DYNAMIC_STEREO:
		break;
	default:
		//Note: 
        fnsLog(ABORTLOGLEVEL, "TEST APP ERROR: tdmperv8GetDefaultAudioPath can't use this type of path!!");
		goto TEST_END;
		break;
	}

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicLoader8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader8->GetObject 
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance8->InitAudio
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		NULL,NULL,ghWnd,
		dwDefaultPathType,	// Requested standard audio path or 0.
		dwPChannelCount,	// Number of PChannels, if default audio path to be created.
		0,					// flags is no params
		NULL); //&audparams);		// audparams structure
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Performance8->CreateStandardAudioPath
	// **********************************************************************
	if(dwType2)
	{
		//this trick doesn't work to get sound when using ENV because it MUST be created before the ENV path
		hr = pwPerformance8->CreateStandardAudioPath(
			dwType2, 			// Choice of standard audio path.
			dwPChannelCount,	// How many pchannels to create.
			TRUE,
			&pAudioPath2);
		if(FAILED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->CreateStandardAudioPath ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(!pAudioPath2)
		{
			fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pAudioPath2 is NULL"));
			goto TEST_END;
		}
	}

	// fail from here on our
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 7) Performance8->GetDefaultAudioPath
	// **********************************************************************
	hr = pwPerformance8->GetDefaultAudioPath(&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 8) Segment8->Download
	// **********************************************************************	
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwSegment8->Download ")
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Performance8->PlaySegmentEx
	// **********************************************************************	
	hr = pwPerformance8->PlaySegmentEx( 
		pwSegment8, 				// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,NULL,NULL,0,NULL,NULL,	// Optional stuff all NULL
		pAudioPath);				// Optional audioPath to play on. 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PlaySegment ")
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 10) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 11) Verify the audiopath
	// **********************************************************************
	if(ppPathDef)
	{
		fnsIncrementIndent();
		fnsLog(ABORTLOGLEVEL,    TEXT(""));
		fnsLog(ABORTLOGLEVEL,    TEXT("----AudioPath Verification------------------------------------"));
		fnsIncrementIndent();
		hr = VerifyPathData(ppPathDef,pAudioPath);
		fnsDecrementIndent();
		fnsLog(ABORTLOGLEVEL,    TEXT("--------------------------------------------------------------"));
		fnsLog(ABORTLOGLEVEL,    TEXT(""));
		fnsDecrementIndent();
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG:---Verification of DMUS_XXX_PATH_MUSIC defaults failed."),tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	else
	{
			fnsLog(ABORTLOGLEVEL, TEXT("         ----Verification of DMUS_XXX_PATH_MUSIC not done."));
	}
	// **********************************************************************
	// 12) Wait for IsPlaying to be false
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	// pass if we got this far
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 13) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8 && pwSegment8)
	{
		pwSegment8->Unload(pwPerformance8); //we don't care if this fails at the moment
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}
	if(pAudioPath2)
	{
		pAudioPath2->Release();
		pAudioPath2 = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::GetParamEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::GetParamEx()<nl>
//
// Test Function: <nl>
// tdmperv8GetParamEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance<nl>
//  3) CoCreateLoader<nl>
//  4) Loader->GetObject<nl>
//  5) Performance->InitAudio<nl>
//  6) Segment->SetParam(GUID_Download)<nl>
//  7) Performance->PlaySegmentEx<nl>
//  8) Wait for IsPlaying to be true<nl>
//  9) Performance->GetParamEx(GUID_TimeSignature)<nl>
//  10) Wait for IsPlaying to be false<nl>
//  11) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	07/06/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8GetParamEx(
	BOOL boolParam1,
	BOOL boolParam2,
	LPARAM lparamParam3,
	LPARAM lparamParam4)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;
	CtIDirectMusicPerformance8* pwPerformance	= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicSegment8*		pwSegment		= NULL;
	CtIDirectMusicSegmentState* pwSegState		= NULL;

//	MUSIC_TIME mtTimeNow;
//	REFERENCE_TIME rtTimeNow;

	DWORD						dwType			= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount = 16;

	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	DMUS_OBJECTDESC 			desc;
	MUSIC_TIME					mtTime;

	void*						pstruct;
	DMUS_PLAY_MARKER_PARAM		playmarker;
	DMUS_RHYTHM_PARAM			rhythm;
	DMUS_TIMESIGNATURE			timesig;
	DMUS_VALID_START_PARAM		starttime;
	DMUS_VARIATIONS_PARAM		variation;

	// gets intialized below
	int 						counter;
	int 						SleepTime;
	int 						iCheckPlaying; 

	GUID*						guid;
	DWORD						testtype		= (DWORD)lparamParam4;

	switch(testtype)
	{
	case 1: // GUID_Play_Marker
		dmthSetPath(L"markers.sgt");
		guid = (GUID*)&GUID_Play_Marker;
		ZeroMemory(&playmarker,sizeof(DMUS_PLAY_MARKER_PARAM));
		pstruct = (void*)&playmarker;
		break;
	case 2: // GUID_RhythmParam
		dmthSetPath(L"scalpatt.sgt");
		guid = (GUID*)&GUID_RhythmParam;
		ZeroMemory(&rhythm,sizeof(DMUS_RHYTHM_PARAM));
		ZeroMemory(&timesig,sizeof(DMUS_TIMESIGNATURE));
		pstruct = (void*)&rhythm;
		break;
	case 3: // GUID_TimeSignature
		dmthSetPath(L"test.mid");
		guid = (GUID*)&GUID_TimeSignature;
		ZeroMemory(&timesig,sizeof(DMUS_TIMESIGNATURE));
		pstruct = (void*)&timesig;
		break;
	case 4: // GUID_Valid_Start_Time
		dmthSetPath(L"markers.sgt");
		guid = (GUID*)&GUID_Valid_Start_Time;
		ZeroMemory(&starttime,sizeof(DMUS_VALID_START_PARAM));
		pstruct = (void*)&starttime;
		break;
	case 5: // GUID_Variations
		dmthSetPath(L"scalpatt.sgt");
		guid = (GUID*)&GUID_Variations;
		ZeroMemory(&variation,sizeof(DMUS_VARIATIONS_PARAM));
		pstruct = (void*)&variation;
		break;
	default:
		return FNS_PENDING;
	}

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader8 object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Loader->GetObject
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,wchFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("Test case aborting"));
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->InitAudio
	// **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,dwType,dwPChannelCount,0,NULL); // create standard audiopath w/defaults 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) Segment->SetParam(GUID_Download)
	// **********************************************************************	
	hr = pwSegment->Download(pwPerformance); // needs real object
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPerformance) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Performance->PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,		// Segment to play. Alternately, could be an IDirectMusicSong. 
		0,				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		DMUS_SEGF_BEAT, // DMUS_SEGF_ flags.
		0,				// Time to start playback. 
		&pwSegState,	// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		NULL);		// Optional audioPath to play on. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 8) Wait for IsPlaying to be true
	// **********************************************************************
	counter = 0;
	SleepTime = 20; // 20 msecs - very fast
	iCheckPlaying = 100; // check faster because we expect this be true almost immediately - time out after 2 seconds
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > iCheckPlaying)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment (first Segment) timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}

	// fail from here on out
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 9) Performance->GetParamEx(GUID_TimeSignature)
	// **********************************************************************
	hr = pwPerformance->GetTime(NULL,&mtTime);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetTime() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(testtype == 2) //we need to get the time signature
	{
		hr = pwPerformance->GetParamEx(GUID_TimeSignature,0,0xFFFFFFFF,DMUS_SEG_ANYTRACK,mtTime,NULL,&timesig);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetParamEx() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		rhythm.TimeSig.mtTime			= timesig.mtTime;
		rhythm.TimeSig.bBeatsPerMeasure	= timesig.bBeatsPerMeasure;
		rhythm.TimeSig.bBeat			= timesig.bBeat;
		rhythm.TimeSig.wGridsPerBeat	= timesig.wGridsPerBeat;
	}
	hr = pwPerformance->GetParamEx((*guid),0,0xFFFFFFFF,0,mtTime,NULL,pstruct);
//	hr = pwPerformance->GetParamEx((*guid),0,0xFFFFFFFF,DMUS_SEG_ANYTRACK,0,NULL,pstruct);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetParamEx() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	switch(testtype)
	{
	case 1: // GUID_Play_Marker
		fnsLog(FYILOGLEVEL, TEXT("        DMUS_PLAY_MARKER_PARAM   :"));
		fnsLog(FYILOGLEVEL, TEXT("        mtTime                   : %016X"), playmarker.mtTime);
		break;
	case 2: // GUID_RhythmParam
		pstruct = (void*)&rhythm;
		fnsLog(FYILOGLEVEL, TEXT("        DMUS_RHYTHM_PARAM        :"));
		fnsLog(FYILOGLEVEL, TEXT("        TimeSig.mtTime           : %016X"), rhythm.TimeSig.mtTime);
		fnsLog(FYILOGLEVEL, TEXT("        TimeSig.bBeatsPerMeasure : %d"), rhythm.TimeSig.bBeatsPerMeasure);
		fnsLog(FYILOGLEVEL, TEXT("        TimeSig.bBeat            : %d"), rhythm.TimeSig.bBeat);
		fnsLog(FYILOGLEVEL, TEXT("        TimeSig.wGridsPerBeat    : %d"), rhythm.TimeSig.wGridsPerBeat);
		fnsLog(FYILOGLEVEL, TEXT("        dwRhythmPattern          : %08X"), rhythm.dwRhythmPattern);
		break;
	case 3: // GUID_TimeSignature
		fnsLog(FYILOGLEVEL, TEXT("        DMUS_TIMESIGNATURE       :"));
		fnsLog(FYILOGLEVEL, TEXT("        mtTime                   : %016X"), timesig.mtTime);
		fnsLog(FYILOGLEVEL, TEXT("        bBeatsPerMeasure         : %d"), timesig.bBeatsPerMeasure);
		fnsLog(FYILOGLEVEL, TEXT("        bBeat                    : %d"), timesig.bBeat);
		fnsLog(FYILOGLEVEL, TEXT("        wGridsPerBeat            : %d"), timesig.wGridsPerBeat);
		break;
	case 4: // GUID_Valid_Start_Time
		fnsLog(FYILOGLEVEL, TEXT("        DMUS_VALID_START_PARAM   :"));
		fnsLog(FYILOGLEVEL, TEXT("        mtTime                   : %016X"), starttime.mtTime);
		break;
	case 5: // GUID_Variations
		fnsLog(FYILOGLEVEL, TEXT("        DMUS_VARIATIONS_PARAM    :"));
		fnsLog(FYILOGLEVEL, TEXT("        dwPChannelsUsed          : %08X"), variation.dwPChannelsUsed);
		fnsLog(FYILOGLEVEL, TEXT("        padwPChannels            : %ph"), variation.padwPChannels);
		fnsLog(FYILOGLEVEL, TEXT("        padwVariations           : %ph"), variation.padwVariations);
		pstruct = (void*)&variation;
		break;
	}
	// **********************************************************************
	// 10) Wait for IsPlaying to be false
	// **********************************************************************
	hr = pwPerformance->Stop(NULL,NULL,0,0);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Stop() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
//	counter = 0;
//	SleepTime = 1000; // once a second
//	iCheckPlaying = 30; // check for 30 seconds max
//	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) == S_OK)	
//	{
//		Sleep(SleepTime);
//		if(counter++ > iCheckPlaying)
//		{
//		fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAILED: IDMPerformance::IsPlaying did not return false (%s == %08Xh)"),
//				tdmXlatHRESULT(hr), hr);
//			goto TEST_END;
//		}
//	}

	// we got this far we must have passed
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 11) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance && pwSegment)
//	if(pPerformance && pwSegment)
	{
		pwSegment->Unload(pwPerformance); //don't care about the return code at this point
//		pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't care about the return code at this point
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegState)
	{
		pwSegState->Release();
		pwSegState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
//	if(pPerformance)
//	{
//		pPerformance->Release();
//		pPerformance = NULL;
//	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::InitAudio()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::InitAudio()<nl>
//
// Test Function: <nl>
// tdmperv8InitAudio()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance <nl>
//  3) Performance8->InitAudio<nl>
//  4) Performance8->GetDefaultAudioPath<nl>
//  5) AudioPath->GetObjectInPath(buffer)<nl>
//  6) AudioPath->GetObjectInPath(port)<nl>
//  7) Port->GetFormat<nl>
//  8) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8InitAudio(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_ABORTED;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	CtIDirectMusic* 			pwMusic 			= NULL;

	IUnknown*					pUnknown			= NULL;
	IUnknown*					pUnkQI				= NULL;

	BOOL						bCheckFormat		= (DWORD)fCoCreate;
	DWORD						dwDefaultPathType	= (DWORD)dwParam1;
	DWORD						dwPChannelCount 	= 16;
	DWORD						dwSampleRate		= (DWORD)dwParam2;
	DMUS_AUDIOPARAMS			audioparams;
	DMUS_AUDIOPARAMS*			paudioparams		= NULL;

	DWORD						dwStage;
	DWORD						dwBuffer;
	GUID						guidObject;
	GUID						guidInterface;
	DWORD						dwIndex 			= 0;
	IDirectMusicPort*			pDMPort 			= NULL;

	DMUS_PORTCAPS				caps;
    LPWAVEFORMATEX				pWfx				= NULL;
    DWORD						dwWfxSize			= 0;
    DWORD						dwBufferSize		= 0;


	// **********************************************************************
	// 0) Use AudioParams only if we pass the sample rate as a parameter
	// **********************************************************************
	if(dwSampleRate)
	{
		paudioparams = &audioparams;
		ZeroMemory(paudioparams,sizeof(DMUS_AUDIOPARAMS));
		paudioparams->dwSize = sizeof(DMUS_AUDIOPARAMS);
		paudioparams->dwValidData = DMUS_AUDIOPARAMS_SAMPLERATE;
		paudioparams->dwSampleRate = dwSampleRate;
	}
	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 3) Performance8->InitAudio
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		&pwMusic,NULL,ghWnd,
		dwDefaultPathType,	
		dwPChannelCount,	
		NULL,		
		paudioparams);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwMusic)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwMusic is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Performance8->GetDefaultAudioPath
	// **********************************************************************
	hr = pwPerformance8->GetDefaultAudioPath(&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		goto TEST_END;
	}
	// get all the port there are - just for the heck of it - if the path is good this should not fail
	switch(dwDefaultPathType)
	{
	case DMUS_APATH_SHARED_STEREOPLUSREVERB:
		dwStage 		= DMUS_PATH_BUFFER;
		guidObject		= GUID_All_Objects; //GUID_Buffer_Reverb;
		guidInterface	= IID_IDirectSoundBuffer;
		dwBuffer		= 1;
		break;
	case DMUS_APATH_DYNAMIC_3D:
		dwStage 		= DMUS_PATH_BUFFER;
		guidObject		= GUID_All_Objects; //GUID_Buffer_3D;
		guidInterface	= IID_IDirectSoundBuffer;
		dwBuffer		= 0;
		break;
	case DMUS_APATH_DYNAMIC_MONO:
		dwStage 		= DMUS_PATH_BUFFER;
		guidObject		= GUID_All_Objects; //GUID_Buffer_Mono;
		guidInterface	= IID_IDirectSoundBuffer;
		dwBuffer		= 0;
		break;
	case DMUS_APATH_DYNAMIC_STEREO:
		dwStage 		= DMUS_PATH_BUFFER;
		guidObject		= GUID_All_Objects; //GUID_Buffer_Stereo;
		guidInterface	= IID_IDirectSoundBuffer;
		dwBuffer		= 0;
		break;
    default:
        fnsLog(ABORTLOGLEVEL, TEXT("Test error!!  Kelly, you're calling this with wrong path type!"));
        goto TEST_END;
	}
	// **********************************************************************
	// 5) AudioPath->GetObjectInPath(buffer)
	// **********************************************************************
	dwIndex = 0;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,dwStage,dwBuffer,guidObject,dwIndex++,guidInterface,(void**)&pUnknown)))
	{
		hr = pUnknown->QueryInterface(guidInterface, (void **)&pUnkQI);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: IUnknown->QueryInterface ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(pUnknown)
		{
			pUnknown->Release();
			pUnknown = NULL;
		}
		if(pUnkQI)
		{
			pUnkQI->Release();
			pUnkQI = NULL;
		}
		fnsLog(BUGLOGLEVEL, TEXT("*** PORT FOUND: IDirectMusicAudioPath::GetObjectInPath(%ld) succeeded (%s,%s)"),dwIndex,tdmXlatGUID(guidObject),tdmXlatGUID(guidInterface));
	}
	// **********************************************************************
	// 6) AudioPath->GetObjectInPath(port)
	// **********************************************************************
	dwIndex = 0;
	guidInterface = IID_IDirectMusicPort;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_PORT,0,GUID_All_Objects,dwIndex++,IID_IDirectMusicPort,(void**)&pDMPort)))
	{
		if(pDMPort)
		{
			fnsIncrementIndent();
			fnsLog(BUGLOGLEVEL, TEXT("*** PORT FOUND: IDirectMusicAudioPath::GetObjectInPath(%ld) succeeded (%s)"),dwIndex,tdmXlatGUID(guidInterface));
			fnsDecrementIndent();
			ZeroMemory(&caps, sizeof(DMUS_PORTCAPS));
			caps.dwSize = sizeof(DMUS_PORTCAPS);
			hr = pDMPort->GetCaps(&caps);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPort->GetCaps ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
			else
			{
				fnsIncrementIndent();
				tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL,&caps);
				fnsDecrementIndent();
			}
			if(bCheckFormat)
			{
				dwWfxSize = 0;
				dwBufferSize = 0;
// **********************************************************************
// 7) Port->GetFormat
// **********************************************************************
				hr = pDMPort->GetFormat(NULL, &dwWfxSize, &dwBufferSize);
				if(FAILED(hr))
				{
					fnsLog(ABORTLOGLEVEL, "**** ABORT: Port->GetFormat failed");
					goto TEST_END;
				}
				pWfx = (WAVEFORMATEX *)LocalAlloc(LPTR, dwWfxSize);
				if(NULL == pWfx)
				{
					fnsLog(ABORTLOGLEVEL, "**** ABORT: LocalAlloc failed");
					goto TEST_END;
				}
				hr = pDMPort->GetFormat(pWfx, &dwWfxSize, &dwBufferSize);
				if(FAILED(hr))
				{
					fnsLog(ABORTLOGLEVEL, "**** ABORT: Port->GetFormat failed");
					goto TEST_END;
				}
				fnsLog(FYILOGLEVEL, TEXT("--- Sample Rate: (%d)"),pWfx->nSamplesPerSec);
				LocalFree(pWfx);
				pWfx = NULL;
			}

			// Release the port
			pDMPort->Release();
			pDMPort = NULL;
		}
		else
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: PORT NOT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s) but pPort is NULL"),dwIndex,tdmXlatHRESULT(hr));
			goto TEST_END;
		}
	}
	if(FAILED(hr) && (DMUS_E_NOT_FOUND != hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicAudioPath->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pWfx)
	{
		LocalFree(pWfx);
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	if(pDMPort)
	{
		pDMPort->Release();
		pDMPort = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}
	if(pUnknown)
	{
		pUnknown->Release();
		pUnknown = NULL;
	}
	if(pUnkQI)
	{
		pUnkQI->Release();
		pUnkQI = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx()<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	WCHAR*						pszFile 		= NULL;
	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusicLoader8		*pwLoader		= NULL;
	CtIDirectMusicPerformance8	*pwPerformance	= NULL;
	IDirectMusicPerformance8	*pPerformance	= NULL;
	CtIDirectMusicSegment8		*pwSegment		= NULL;

	DMUS_OBJECTDESC 			desc; 

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	BOOL						fAuto;
	DWORD						testtype		= (DWORD)dwParam2;

	switch(testtype)
	{
		case 1:
			fAuto = FALSE;
			pszFile = L"test.mid";
			break;
		case 2:
		case 4:
			fAuto = TRUE;
			pszFile = L"WaveEmbed.sgt";
			break;
		case 3:
		case 5:
			fAuto = FALSE;
			pszFile = L"WaveEmbed.sgt";
			break;
		default:
			return FNS_PENDING;
	}
	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,pszFile);
	hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************
	switch(testtype)
	{
	case 1:
	case 2:
	case 3:
		hr = pwPerformance->Init(NULL,NULL,ghWnd);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		// **********************************************************************
		// 4.1) Add the Port
		// **********************************************************************	
		hr = pwPerformance->AddPort( NULL );
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 4:
	case 5:
		hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,DMUS_APATH_SHARED_STEREOPLUSREVERB,64,NULL,NULL);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(fAuto)
	{
		hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	else
	{
		hr = pwPerformance->GetRealObjPtr(&pPerformance);
		if (FAILED( hr ))
		{
			fnsLog(ABORTLOGLEVEL, "**** ABORT: Failed to get Real Object Pointer(performance) "
					"(HRESULT: %s == %08Xh)", tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwSegment->SetParam(GUID_Download, -1, 0, 0, (void*)pPerformance); // needs real object - no need to release - no addref done 
		if(testtype == 3)
		{
			if(hr != E_NOTIMPL)
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
						TEXT("did not return E_NOTIMPL (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
		else if(FAILED(hr)) // 3 == downloading was
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetParam(Download) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,			// Segment to play 
		0,NULL, 			// Optional stuff NULL. 
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff is NULL. 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	Sleep(4000);
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		if((!fAuto) && pPerformance)
		{
			pwSegment->SetParam(GUID_Unload, -1, 0, 0, (void*)pPerformance); //don't case about the return code at this point
		}
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pPerformance)
	{
		pPerformance->Release();
		pPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx(types)_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx(types)<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentTypeEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	05/22/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentTypeEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusic*				pwMusic			= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicPerformance8*	pwPerformance	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState	= NULL;
	CtIDirectMusicSegment8*		pwSegment		= NULL;
	CtIDirectMusicSegment8*		pwTransSeg		= NULL;
	CtIDirectMusicSegment8*		pwOneSeg		= NULL;
//	CtIDirectMusicSong8*		pwSong			= NULL;
	CtIDirectMusicAudioPath*	pwPath			= NULL;
	CtIDirectMusicAudioPath*	pwPath2			= NULL;
	CtIDirectMusicObject*		pwPathCfg		= NULL;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 20;

	DWORD						testtype		= (DWORD)dwParam2;

	WCHAR*						pMidiFile 		= L"test.mid";
	WCHAR*						pPathFile 		= NULL;
	WCHAR*						pOneFile 		= NULL;
//	WCHAR*						pSngFile 		= NULL;
	WCHAR*						pTransFile 		= NULL;
	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	DWORD						dwPathType2		= DMUS_APATH_DYNAMIC_STEREO;
	DWORD						dwPChannelCount2	= 1;
	BOOL						fActivate		= TRUE;
	BOOL						fAuto			= FALSE;
	DWORD						dwFlags			= DMUS_SEGF_BEAT;
	BOOL						hardware		= FALSE;

	// which type of test to do
	switch(testtype)
	{
	case 0: //download
	case 2: 
	case 4:
		break;
	case 5:
		pPathFile 		= L"both_1.aud";
		pMidiFile 		= L"test2.sgt";
		hardware		= TRUE;
		break;
	case 6:
		pPathFile 		= L"both_1.aud";
		pMidiFile 		= L"test2.sgt";
		fAuto			= TRUE;
		hardware		= TRUE;
		break;
	case 7:
		pPathFile 		= L"both_2.aud";
		pMidiFile 		= L"test2.sgt";
		hardware		= TRUE;
		break;
	case 8:
		pPathFile 		= L"both_2.aud";
		pMidiFile 		= L"test2.sgt";
		fAuto			= TRUE;
		hardware		= TRUE;
		break;
//	case 9: // play song with no transition
//		pMidiFile		= NULL; // no second file
//		pSngFile 		= L"blues.sng";
//		break;
//	case 10: // play song w/ autotransition to default seg
//		pSngFile 		= L"blues.sng";
//		dwFlags			= DMUS_SEGF_MEASURE|DMUS_SEGF_AUTOTRANSITION;
//		break;
//	case 11: //play song with autotransition to composable seg 
//		pSngFile 		= L"blues.sng";
//		pMidiFile		= L"Seg8STC.sgt";
//		dwFlags			= DMUS_SEGF_MEASURE|DMUS_SEGF_AUTOTRANSITION;
//		break;
	case 12: // play seg w/ autotransition using template
		pOneFile 		= L"Seg8STC.sgt";
		pMidiFile		= L"test.sgt";
		pTransFile		= L"AutoTrans.sgt";
		dwFlags			= DMUS_SEGF_MEASURE|DMUS_SEGF_AUTOTRANSITION;
		fAuto			= TRUE;
		break;
//	case 13: // play song w/ autotransition using template
//		pSngFile 		= L"blues.sng";
//		pMidiFile		= L"test.sgt";
//		pTransFile		= L"AutoTrans.sgt";
//		dwFlags			= DMUS_SEGF_MEASURE|DMUS_SEGF_AUTOTRANSITION;
//		fAuto			= TRUE;
//		break;
//	case 14: // play song w/ autotransition using template but no autotransition flag
//		pSngFile 		= L"blues.sng";
//		pMidiFile		= L"test.sgt";
//		pTransFile		= L"AutoTrans.sgt";
//		dwFlags			= DMUS_SEGF_MEASURE; //|DMUS_SEGF_AUTOTRANSITION;
//		fAuto			= TRUE;
//		break;
	case 15: // play song w/ autotransition using template but no autotransition flag
//		pSngFile 		= L"blues.sng";
		pMidiFile		= L"portbvt1.wav";
//		pTransFile		= L"AutoTrans.sgt";
//		dwFlags			= DMUS_SEGF_MEASURE; //|DMUS_SEGF_AUTOTRANSITION;
//		fAuto			= TRUE;
		break;
	case 1: //autodownload
	case 3:
		fAuto			= TRUE;
		break;
	default: // not null - not supported
		return FNS_PENDING;
		break;
	}
	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	if(pTransFile)
	{
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pTransFile,(void **)&pwTransSeg);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	if(pOneFile)
	{
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pOneFile,(void **)&pwOneSeg);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
//	if(pSngFile)
//	{
//		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSong,CTIID_IDirectMusicSong8,pSngFile,(void **)&pwSong);
//		if(FAILED(hr))
//		{
//			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
//					TEXT("failed (%s == %08Xh)"),
//					tdmXlatHRESULT(hr), hr);
//			goto TEST_END;
//		}
//	}
	if(pMidiFile)
	{
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pMidiFile,(void **)&pwSegment);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	if(pPathFile)
	{
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicAudioPathConfig,CTIID_IDirectMusicObject,pPathFile,(void **)&pwPathCfg);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwPathCfg) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************	
	switch(testtype)
	{
	default:
		hr = pwPerformance->InitAudio(&pwMusic,NULL,ghWnd,NULL,NULL,NULL,NULL);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init or InitAudio(NULLs) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 2:
	case 3:
		hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init or InitAudio(NULLs) ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}

	// **********************************************************************
	// 4.1) Add the Port
	// **********************************************************************	
	switch(testtype)
	{
	default:
		if(!pwPathCfg)
		{
			hr = pwPerformance->CreateStandardAudioPath(
				dwPathType, 			// Choice of standard audio path.
				dwPChannelCount,	// How many pchannels to create.
				fActivate,
				&pwPath);
			if(FAILED(hr))
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
			if(!pwPath)
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
				goto TEST_END;
			}
			if(testtype == 4)
			{
				hr = pwPerformance->CreateStandardAudioPath(
					dwPathType2, 			// Choice of standard audio path.
					dwPChannelCount2,	// How many pchannels to create.
					fActivate,
					&pwPath2);
				if(FAILED(hr))
				{
					fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath(2) ")
							TEXT("failed (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
					goto TEST_END;
				}
				if(!pwPath2)
				{
					fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath2 is NULL "));
					goto TEST_END;
				}
			}
		}
		else
		{
			hr = pwPerformance->CreateAudioPath(
				pwPathCfg, 			// audio path confif object.
				fActivate,
				&pwPath);
			if(!HasDSOne(pwMusic) && hardware)
			{
				// CreateAudioPath is expected to fail
				if(SUCCEEDED(hr))
				{
					//failed
					goto TEST_END;
				}
				else
				{
					//passed
					if(hr == E_NOINTERFACE)
					{
						dwRes = FNS_PASS;
					}
					goto TEST_END;
				}
			}
			if(FAILED(hr))
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateAudioPath() ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
			if(!pwPath)
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
				goto TEST_END;
			}
		}
		if(fAuto && pwPath)
		{
			hr = pwPerformance->SetDefaultAudioPath(pwPath);
			if(FAILED(hr))
			{
				fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateAudioPath() ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
			pwPath->Release();
			pwPath = NULL;
		}
		break;
	case 2:
	case 3:
		hr = pwPerformance->AddPort(NULL);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath or AddPort() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(fAuto)
	{
		hr = pwPerformance->SetGlobalParam(GUID_PerfAutoDownload, &fAuto, sizeof(BOOL));
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	else
	{
		switch(testtype)
		{
		case 4:
			hr = pwSegment->Download(pwPath2); //we would have aborted earlier if pwPath2 was NULL
			break;
		case 5:
		case 6:
		case 7:
		case 8:
			hr = pwSegment->Download(pwPath);
			break;
		case 9:
		case 10:
		case 11:
			if(pwSegment)
			{
				hr = pwSegment->Download(pwPath);
				if(FAILED(hr))
				{
					fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download() ")
							TEXT("failed (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
					goto TEST_END;
				}
				if(S_FALSE == hr)
				{
					fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download() ")
							TEXT("returned (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
				}
			}
//			hr = pwSong->Download(pwPath);
			break;
		default:
			hr = pwSegment->Download(pwPerformance);
			break;
		}
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download() ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	if(pwOneSeg)
	{
		hr = pwOneSeg->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwOneSeg->SetRepeats ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}

		hr = pwPerformance->PlaySegmentEx( 
			pwOneSeg, 
			0,
			NULL,
			DMUS_SEGF_BEAT,
			0,
			&pwSegmentState,
			NULL,
			pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		counter = 0;
		SleepTime = 1000;
		while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) != S_OK)	
		{
			Sleep(SleepTime);
			if(counter++ > TimeOutValue)
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
					TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
//		Sleep(4000);
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
//	if(pwSong)
//	{
//		hr = pwPerformance->PlaySegmentEx( 
//		pwSong, 
//		0,
//		pwTransSeg,
//		DMUS_SEGF_BEAT,
//		0,
//		&pwSegmentState,
//		NULL,
//		pwPath);
//		if(FAILED(hr))
//		{
//			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
//					TEXT("failed (%s == %08Xh)"),
//					tdmXlatHRESULT(hr), hr);
//			goto TEST_END;
//		}
//		counter = 0;
//		SleepTime = 1000;
//		while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) != S_OK)	
//		{
//			Sleep(SleepTime);
//			if(counter++ > TimeOutValue)
//			{
//				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
//					TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
//					tdmXlatHRESULT(hr), hr);
//				goto TEST_END;
//			}
//		}
////		Sleep(4000);
//	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegment)
	{
		hr = pwSegment->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwSegment->SetRepeats ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwPerformance->PlaySegmentEx( 
		pwSegment, 
		0,
		pwTransSeg,
		dwFlags,
		0,
		&pwSegmentState,
		NULL,
		pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		counter = 0;
		SleepTime = 1000;
		while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) != S_OK)	
		{
			Sleep(SleepTime);
			if(counter++ > TimeOutValue)
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
					TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
//		Sleep(4000);
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
//	Sleep(8000);
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
	}
	if(pwSegment)
	{
		switch(testtype)
		{
		case 0: //download
			if(pwPerformance)
			{
				pwSegment->Unload(pwPerformance); //don't care about the return code at this point
			}
			break;
		case 2: 
			if(pwPath)
			{
				pwSegment->Unload(pwPath); //don't care about the return code at this point
			}
			break;
		case 4:
			if(pwPath2)
			{
				pwSegment->Unload(pwPath2); //don't care about the return code at this point
			}
			break;
		}
		pwSegment->Release();
		pwSegment = NULL;
	}
//	if(pwSong)
//	{
//		if(pwPath)
//		{
//			pwSong->Unload(pwPath); //don't care about the return code at this point
//		}
//		pwSong->Release();
//		pwSong = NULL;
//	}
	if(pwTransSeg)
	{
		pwTransSeg->Release();
		pwTransSeg = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwPath)
	{
		pwPath->Release();
		pwPath = NULL;
	}
	if(pwPath2)
	{
		pwPath2->Release();
		pwPath2 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx(from)_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx(from)<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentExFrom()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	05/22/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentExFrom(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusic*				pwMusic			= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicPerformance8*	pwPerformance	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState1	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState2	= NULL;
	CtIDirectMusicSegment8*		pwPSegment		= NULL;
	CtIDirectMusicSegment8*		pwTSegment		= NULL;
	CtIDirectMusicSegment8*		pwSSegment		= NULL;
	CtIDirectMusicSegment8*		pwWSegment		= NULL;
	CtIDirectMusicAudioPath*	pwPath			= NULL;
	CtIDirectMusicAudioPath*	pwPath2			= NULL;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	DWORD						testtype		= (DWORD)dwParam2;

	WCHAR*						pPMidiFile 		= L"test.mid";
	WCHAR*						pSMidiFile 		= L"test.sgt";
	WCHAR*						pWMidiFile 		= L"rdrum.sgt";
	WCHAR*						pTemplateFile 	= L"Seg8STC.sgt";
	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	BOOL						fActivate		= TRUE;
	DWORD						dwFlags			= NULL;

	// which type of test to do
	switch(testtype)
	{
	case 1: // self beat
	case 2: // self measure
	case 3: // self queue
	case 4: // autotransition beat
	case 5: // autotransition measure
	case 6: // autotransition queue
		break;
	case 7: // autotransition to second segment
		pPMidiFile 		= L"synctest.mid";
		break;
	default: // not null - not supported
		return FNS_PENDING;
		break;
	}
	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicCollection, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(dls) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicChordMap, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(chordmap) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader->ScanDirectory(CLSID_DirectMusicStyle, L"*", NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->ScanDirectory(style) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pPMidiFile,(void **)&pwPSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	switch(testtype)
	{
	case 4: // autotransition
	case 5: // autotransition
	case 6: // autotransition
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pTemplateFile,(void **)&pwTSegment);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwTSegment->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Segment->SetRepeats() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 7: // secondary segment
		hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pWMidiFile,(void **)&pwWSegment);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwWSegment->SetRepeats(0);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Segment->SetRepeats() ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pSMidiFile,(void **)&pwSSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************	
	// **********************************************************************
	// 4.1) Add the Port
	// **********************************************************************	
	hr = pwPerformance->InitAudio(&pwMusic,NULL,ghWnd,NULL,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init or InitAudio(NULLs) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(pwPSegment)
	{
		hr = pwPSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	if(pwSSegment)
	{
		hr = pwSSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	if(pwWSegment)
	{
		hr = pwWSegment->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	// **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwPSegment, 
		0,
		NULL,
		DMUS_SEGF_QUEUE,
		0,
		&pwSegmentState1,
		NULL,
		pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 300;
	while ((hr = pwPerformance->IsPlaying(pwPSegment,NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 1) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	switch(testtype)
	{
	case 1: // from self
		dwFlags = DMUS_SEGF_BEAT;
		break;
	case 2: // from self
		dwFlags = DMUS_SEGF_MEASURE;
		break;
	case 3: // from self
		dwFlags = DMUS_SEGF_QUEUE;
		break;
	case 4: // autotransition
		dwFlags = DMUS_SEGF_BEAT | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 5: // autotransition
		dwFlags = DMUS_SEGF_MEASURE | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 6: // autotransition
		dwFlags = DMUS_SEGF_QUEUE | DMUS_SEGF_AUTOTRANSITION;
		break;
	case 7: // autotransition second segment
		dwFlags = DMUS_SEGF_MEASURE | DMUS_SEGF_SECONDARY;
		break;
	}
	switch(testtype)
	{
	default: // from self
		hr = pwPerformance->PlaySegmentEx( 
			pwSSegment, 
			NULL,
			pwTSegment,
			dwFlags,
			NULL,
			&pwSegmentState2,
			pwSegmentState1,
			pwPath);
		break;
	case 7: // from self
		hr = pwPerformance->PlaySegmentEx( 
			pwSSegment, 
			NULL,
			NULL,
			dwFlags,
			NULL,
			&pwSegmentState2,
			NULL,
			pwPath);
		break;
	}
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	switch(testtype)
	{
	case 4:
	case 5:
	case 6:
		hr = pwPerformance->IsPlaying(pwSSegment,NULL);
		if(SUCCEEDED(hr) && (S_FALSE != hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: Performance->IsPlaying ")
					TEXT("succeeded and should not have (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	case 7:
		dwFlags = DMUS_SEGF_QUEUE | DMUS_SEGF_SECONDARY;
		hr = pwPerformance->PlaySegmentEx( 
			pwWSegment, 
			NULL,
			NULL,
			dwFlags,
			NULL,
			NULL,
			pwSegmentState2,
			pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		break;
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState2)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segstate) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState2)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 2) timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	if(pwWSegment)
	{
		counter = 0;
		SleepTime = 3000;
		while ((hr = pwPerformance->IsPlaying(pwWSegment,NULL)) == S_OK)	
		{
			Sleep(SleepTime);
			if(counter++ > TimeOutValue)
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 3) timed out\n")
					TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
	}
	if(pwPSegment)
	{
		if(pwPath)
		{
			pwPSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwPSegment->Release();
		pwPSegment = NULL;
	}
	if(pwSegmentState1)
	{
		pwSegmentState1->Release();
		pwSegmentState1 = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwTSegment)
	{
		pwTSegment->Release();
		pwTSegment = NULL;
	}
	if(pwSSegment)
	{
		if(pwPath)
		{
			pwSSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwSSegment->Release();
		pwSSegment = NULL;
	}
	if(pwWSegment)
	{
		if(pwPath)
		{
			pwWSegment->Unload(pwPath); //don't care about the return code at this point
		}
		pwWSegment->Release();
		pwWSegment = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwPath)
	{
		pwPath->Release();
		pwPath = NULL;
	}
	if(pwPath2)
	{
		pwPath2->Release();
		pwPath2 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::SetDefaultAudioPath()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::SetDefaultAudioPath()<nl>
//
// Test Function: <nl>
// tdmperv8SetDefaultAudioPath()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1)   Initialize<nl>
//	 2.0) Create Loader<nl>
//	 2.1) Get the Segment<nl>
//	 2.2) Get the AudioPath<nl>
//	 3.0) Create CtIDirectMusicPerformance8 object <nl>
//	 3.1) InitAudio the performance witha standard audio path that plays silent<nl>
//	 4.0) Create an AudioPath from the audiopathconfig file to be set later<nl>
//	 4.1) Verify the results<nl>
//	 5.0) Play the segment - Download<nl>
//	 5.1) PlaySegmentEx<nl>
//	 5.2) Verify silent playback - Wait for IsPlaying - NO SOUND EXPECTED<nl>
//	 5.3) Quickly unload - if there had been sound (bug) it should stop <nl>
//	 6)   Call SetDefaultAudioPath - the function to be tested<nl>
//	 7.0) Verification - Play a segment - Download<nl>
//	 7.1) Verification - PlaySegmentEx<nl>
//	 7.2) Verification - Wait for IsPlaying - should make sound this time<nl>
//	 8)   Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8SetDefaultAudioPath(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_ABORTED;
	HRESULT 					hr					= S_OK;

	CtIDirectMusic*				pwMusic				= NULL;
	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicLoader8*		pwLoader8			= NULL;
	CtIDirectMusicSegment8* 	pwSegment8			= NULL;
	CtIUnknown* 				pAudioPathConfig	= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	DMUS_OBJECTDESC 			desc; 

	int 						counter 			= 0;
	int 						SleepTime			= 3000;
	int 						TimeOutValue		= 10;

	WCHAR*						pMidiFile			= NULL;
	WCHAR*						pAudPathFile		= NULL;
	DWORD						testtype			= (DWORD)dwParam2;
	BOOL						hardware			= FALSE;

	switch(testtype)
	{
	case 1:
		pAudPathFile		= L"Standard.aud";
		pMidiFile			= L"test.mid";
		break;
	case 2:
		pAudPathFile		= L"Standard3DShared.aud";
		pMidiFile			= L"test.mid";
		break;
	case 3:
		pAudPathFile		= L"StandardReverbShared.aud";
		pMidiFile			= L"test.mid";
		break;
	case 4:
		pAudPathFile		= L"both_1.aud";
		pMidiFile			= L"test.sgt";
		hardware			= TRUE;
		break;
	case 5:
		pAudPathFile		= L"both_2.aud";
		pMidiFile			= L"test2.sgt";
		hardware			= TRUE;
		break;
	default:
		return FNS_PENDING;
	}
	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader8);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2.1) Get the Segment with fullpath
	// **********************************************************************
	dmthSetPath(pMidiFile);
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,gwszMediaPath);
	hr = pwLoader8->GetObject(&desc,CTIID_IDirectMusicSegment8,(void **)&pwSegment8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pwSegment8) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2.2) Get the AudioPath wih fullpath
	// **********************************************************************
	dmthSetPath(pAudPathFile);
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicAudioPathConfig;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
	wcscpy(desc.wszFileName,gwszMediaPath);
	hr = pwLoader8->GetObject(&desc,CTIID_IUnknown,(void **)&pAudioPathConfig);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(pAudioPathConfig) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create CtIDirectMusicPerformance8 object 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) InitAudio the performance witha standard audio path that plays silent
	// **********************************************************************
	hr = pwPerformance8->InitAudio(&pwMusic,NULL,ghWnd,NULL,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Create an AudioPath from the audiopathconfig file to be set later
	// **********************************************************************
	hr = pwPerformance8->CreateAudioPath(pAudioPathConfig,TRUE,&pAudioPath);
	if(!HasDSOne(pwMusic) && hardware)
	{
		// CreateAudioPath is expected to fail
		if(SUCCEEDED(hr))
		{
			//failed
			goto TEST_END;
		}
		else
		{
			//passed
			if(hr == E_NOINTERFACE)
			{
				dwRes = FNS_PASS;
			}
			goto TEST_END;
		}
	}
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->CreateAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Verify the results
	// **********************************************************************
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pAudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) Play the segment - Download
	// **********************************************************************	
	hr = pwSegment8->Download(pwPerformance8);
	if(FAILED(hr))
	{
			fnsLog(BUGLOGLEVEL, TEXT("**** ABORT: pwSegment8->Download ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 6) Call SetDefaultAudioPath - the function to be tested<nl>
	// **********************************************************************
	hr = pwPerformance8->SetDefaultAudioPath(pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->SetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 7.1) Verification - PlaySegmentEx
	// **********************************************************************
	hr = pwPerformance8->PlaySegmentEx( 
		pwSegment8, 		// Segment to play 
		0,NULL, 			// Optional stuff NULL 
		DMUS_SEGF_BEAT, 	// DMUS_SEGF_ flags.
		0,NULL,NULL,NULL);	// Optional stuff NULL - use default audio path 
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx ")
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 7.2) Verification - Wait for IsPlaying - should make sound this time
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(pwSegment8, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying() timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwSegment8 && pwPerformance8)
	{
		pwSegment8->Unload(pwPerformance8); // don't care about return code
	}
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwSegment8)
	{
		pwSegment8->Release();
		pwSegment8 = NULL;
	}
	if(pwLoader8)
	{
		pwLoader8->Release();
		pwLoader8 = NULL;
	}
	if(pAudioPathConfig)
	{
		pAudioPathConfig->Release();
		pAudioPathConfig = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::SetParamHook()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::SetParamHook()<nl>
//
// Test Function: <nl>
// tdmperv8SetParamHook()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
// 1) Initialize <nl>
// 2) Clean up Objects, uninitialize, and return results <nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
/*
cdDWORD tdmperv8SetParamHook(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	return tdmhookGetParam (fCoCreate, fMaxDebug, dwParam1, dwParam2);
}	
*/




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::StopEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::StopEx()<nl>
//
// Test Function: <nl>
// tdmperv8StopEx()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create a Performance8<nl>
//	 3.0) Create a Loader<nl>
//	 3.1) Get the Segment object with fullpath<nl>
//	 4.0) Init the Performance8 as level 1<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Turn on AutoDownload<nl>
//	 5.0) Play the segment - PlaySegmentEx<nl>
//	 5.1) Wait for IsPlaying to return true (or time out)<nl>
//	 6) Call StopEx - the method we are testing<nl>
//	 7) Verification - Wait for IsPlaying to return false (or time out)<nl>
//	 8) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8StopEx(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	WCHAR*						pMidiFile	 	= NULL;
//	WCHAR*						pSongFile	 	= NULL;

//	WCHAR*						wchPath 		= gwszBasePath;
	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusicLoader8		*pwLoader		= NULL;
	CtIDirectMusicPerformance8	*pwPerformance8 = NULL;
	CtIDirectMusicSegmentState	*pwSegmentState	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
//	CtIDirectMusicSong			*pwSong			= NULL;
	CtIDirectMusicAudioPath		*pwPath			= NULL;

	DMUS_OBJECTDESC 			desc; 

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	BOOL						fActivate		= TRUE;
	DWORD						dwFlags			= DMUS_SEGF_MEASURE;

	if(fCoCreate) // use autotransition flag
	{
		dwFlags |= DMUS_SEGF_AUTOTRANSITION;
	}
	DWORD stopthis = (DWORD)dwParam1;
	DWORD testtype = (DWORD)dwParam2;

	switch(testtype)
	{
	default:
		pMidiFile	 	= L"test.mid";
		break;
//	case 1:
//		pSongFile	 	= L"blues.sng";
//		break;
	case 2:
		pMidiFile	 	= L"amaaud1.sgt";
		break;
	}


	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create a Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create a Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) Get the Segment object with fullpath
	// **********************************************************************
	if(pMidiFile)
	{
		dmthSetPath(pMidiFile);
		ZeroMemory(&desc, sizeof(desc));
		desc.dwSize = sizeof(DMUS_OBJECTDESC);
		desc.guidClass = CLSID_DirectMusicSegment;
		desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
		wcscpy(desc.wszFileName,wchFile);
		hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSegment,(void **)&pwSegment);
	}
//	else if(pSongFile)
//	{
//		dmthSetPath(pSongFile);
//		ZeroMemory(&desc, sizeof(desc));
//		desc.dwSize = sizeof(DMUS_OBJECTDESC);
//		desc.guidClass = CLSID_DirectMusicSong;
//		desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);
//		wcscpy(desc.wszFileName,wchFile);
//		hr = pwLoader->GetObject(&desc,CTIID_IDirectMusicSong8,(void **)&pwSong);
//	}
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance8 as level 1
	// **********************************************************************	
	hr = pwPerformance8->InitAudio(NULL,NULL,ghWnd,NULL,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.1) Add the default Port
	// **********************************************************************	
	hr = pwPerformance8->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Turn on AutoDownload
	// **********************************************************************	
	BOOL fAuto;
	fAuto = TRUE;
	hr = pwPerformance8->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance8->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5.0) Play the segment - PlaySegmentEx
	// **********************************************************************
	if(pwSegment)
	{
		hr = pwPerformance8->PlaySegmentEx(pwSegment,0,NULL,DMUS_SEGF_BEAT,0,&pwSegmentState,NULL,pwPath); 
	}
//	else if(pwSong)
//	{
//		hr = pwPerformance8->PlaySegmentEx(pwSong,0,NULL,DMUS_SEGF_BEAT,0,&pwSegmentState,NULL,pwPath); 
//	}
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance8->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5.1) Wait for IsPlaying to return true (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(NULL,pwSegmentState)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out\n")
				TEXT("Segment did not start playing in the time speciied (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	Sleep(1000);
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 6) Call StopEx - the method we are testing
	// **********************************************************************
	if(stopthis == 1) // audiopath
	{
		hr = pwPerformance8->StopEx(
			pwPath,			// Segstate, AudioPath, Segment, or Song to stop. 
			0,					// Optional time.
			dwFlags); // Standard SEGF flags for setting time.
	}
	else if(stopthis == 2) // segmentstate
	{
		hr = pwPerformance8->StopEx(
			pwSegmentState,			// Segstate, AudioPath, Segment, or Song to stop. 
			0,					// Optional time.
			dwFlags); // Standard SEGF flags for setting time.
	}
	else if(pwSegment)
	{
		hr = pwPerformance8->StopEx(
			pwSegment,			// Segstate, AudioPath, Segment, or Song to stop. 
			0,					// Optional time.
			dwFlags); // Standard SEGF flags for setting time.
	}
//	else if(pwSong)
//	{
//		hr = pwPerformance8->StopEx(
//			pwSong,				// Segstate, AudioPath, Segment, or Song to stop. 
//			0,					// Optional time.
//			dwFlags); // Standard SEGF flags for setting time.
//	}
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance8->StopEx ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Verification - Wait for IsPlaying to return false (or time out)
	// **********************************************************************
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance8->IsPlaying(NULL,pwSegmentState)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance8->IsPlaying() is true\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwPath)
	{
		pwPath->Release();
		pwPath = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
//	if(pwSong)
//	{
//		pwSong->Release();
//		pwSong = NULL;
//	}

	dmthCoUninitialize();	
	return dwRes;
}	




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx()<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentNoPiano()<nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance<nl>
//  3) Create a Notification Event<nl>
//  4) Performance->Init<nl>
//  5) Performance->AddPort<nl>
//  6) CoCreateLoader<nl>
//  7) Set path and scan for everything<nl>
//  8) Loader->LoadObjectFromFile(segment)<nl>
//  9) Segment->Download<nl>
//  10) Performance->SetNotificationHandle<nl>
//  11) Performance->AddNotificationType<nl>
//  12) Performance->PlaySegment<nl>
//  13) Wait for the segment to finish playing<nl>
//  14) Cleanup objects, uninitialize COM, Return test result<nl>
//
// History: <nl>
//  05/16/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentNoPiano
(
	BOOL fCoCreate, 
	BOOL fMaxDebug,						
	LPARAM dwParam1, 
	LPARAM dwParam2
)
{
	HRESULT 					hr						= E_NOTIMPL;
	DWORD						dwRes					= FNS_ABORTED;

	CtIDirectMusicPerformance*	pwPerformance			= NULL;
	CtIDirectMusicSegment8*		pwSegment				= NULL;
	CtIDirectMusicLoader8*		pwLoader	 			= NULL;

	DMUS_NOTIFICATION_PMSG		*pEvent 				= NULL;
	HANDLE						hNotify 				= INVALID_HANDLE_VALUE;
	BOOL						endwhile				= FALSE;
	DWORD						dwResult				= 0;

	WCHAR szFilename[] = L"DPrimary2.SGT";

	//Set the path
	dmthSetPath(NULL);
	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** COM initialization failed! (%s == %08Xh)"),
		tdmXlatHRESULT(hr), hr);
		fnsLog(ABORTLOGLEVEL, TEXT("**** Test case aborting."));
		return FNS_ABORTED;
	}
	// **********************************************************************
	// 2)  CoCreatePerformance
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 3)  Create a Notification Event
	// **********************************************************************
	hNotify = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotify || INVALID_HANDLE_VALUE == hNotify)
	{
		fnsLog(ABORTLOGLEVEL,
			"**** ABORT: hNotify Event failed (hNotify == %08Xh)",
			hNotify);
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Performance->Init
	// **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if (FAILED (hr))
	{
		fnsLog (ABORTLOGLEVEL,
			"**** ABORT: Performance->Init failed (%s == %08Xh)",
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Performance->AddPort
	// **********************************************************************
	hr =  pwPerformance->AddPort(NULL);
	if (FAILED (hr))
	{
		fnsLog (ABORTLOGLEVEL,
			"**** ABORT: Performance->AddPort failed (%s == %08Xh)",
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) CoCreateLoader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicLoader object creation ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 7) Set path and scan for everything
	// **********************************************************************
	hr = SearchAndScanAllMedia(pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ERROR: SearchAndScanAllMedia failed!!"));
		goto TEST_END;
	}
	// **********************************************************************
	// 8) Loader->LoadObjectFromFile(segment)
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,
									CTIID_IDirectMusicSegment8,
									szFilename,
									(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: dmlLoadSegment "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 9) Segment->Download
	// **********************************************************************
	hr = pwSegment->Download(pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: pwSegment->Download(performance) "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 10) Performance->SetNotificationHandle
	// **********************************************************************
	hr = pwPerformance->SetNotificationHandle(hNotify,0);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL,
			"!!!! BUG: pwPerformance->SetNotificationHandle (valid event)"
				"failed (%s == %08Xh)",
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 11) Performance->AddNotificationType
	// **********************************************************************
	hr = pwPerformance->AddNotificationType(GUID_NOTIFICATION_SEGMENT);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			"!!!! BUG: pwPerformance->AddNotificationType(GUID_NOTIFICATION_SEGMENT) "
			"failed (%s == %08Xh)",
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	//BUGBUG
	// hack to insure download has finished
	Sleep(1000);

	dwRes = FNS_FAIL;
	// **********************************************************************
	// 12) Performance->PlaySegment
	// **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegment "
				"failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 13) Wait for the segment to finish playing
	// **********************************************************************
	endwhile = FALSE;
	while(FALSE == endwhile)
	{
		dwResult = WaitForSingleObject(hNotify,20000); //20 seconds
		if(WAIT_OBJECT_0 != dwResult)
		{
			fnsLog(ABORTLOGLEVEL,
				"**** ABORT: WaitForSingleObject != "
				"WAIT_OBJECT_0 (%08Xh)",dwResult);
			endwhile = TRUE;
		}
		while(SUCCEEDED(hr = pwPerformance->GetNotificationPMsg(&pEvent)) && (hr != S_FALSE))
		{
			if(!pEvent)
			{
				continue;
			}

			if(pEvent->guidNotificationType == GUID_NOTIFICATION_SEGMENT)
			{
				switch(pEvent->dwNotificationOption)
				{
				case DMUS_NOTIFICATION_SEGSTART:
					fnsLog(FYILOGLEVEL,"--- FYI: Performance PMsg: DMUS_NOTIFICATION_SEGSTART");
					break;
				case DMUS_NOTIFICATION_SEGEND:
					fnsLog(FYILOGLEVEL,"--- FYI: Performance PMsg: DMUS_NOTIFICATION_SEGEND");
					endwhile = TRUE;
					break;
				case DMUS_NOTIFICATION_SEGALMOSTEND:
					fnsLog(FYILOGLEVEL,"--- FYI: Performance PMsg: DMUS_NOTIFICATION_SEGALMOSTEND");
					break;
				case DMUS_NOTIFICATION_SEGLOOP:
					fnsLog(FYILOGLEVEL,"--- FYI: Performance PMsg: DMUS_NOTIFICATION_SEGLOOP");
					break;
				default:
					fnsLog(FYILOGLEVEL,"--- FYI: Performance PMsg: UNKNOWN");
					endwhile = TRUE;
					break;
				}
			}
			else
			{
				fnsLog(BUGLOGLEVEL,"!!!! BUG: Unexpected Performance PMsg: NotificationType: UNKNOWN");
				goto TEST_END;
			}
			hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
			pEvent = NULL;
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->FreePMsg ")
						TEXT("failed (%s == %08Xh)"),
						tdmXlatHRESULT(hr), hr);
				goto TEST_END;
			}
		}
		if(FAILED(hr))
		{
		  fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 14) Cleanup objects, uninitialize COM, Return test result
	// **********************************************************************
	if (pwPerformance)
	{
		if(pwSegment)
		{
			pwSegment->Unload(pwPerformance);
		}
		pwPerformance->SetNotificationHandle(0,0);
		if(pEvent)
		{
			pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
		}
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
	}
	if(INVALID_HANDLE_VALUE != hNotify)
	{
		CloseHandle(hNotify);
	}

	pwPerformance	= SafeRelease (pwPerformance);
	pwSegment		= SafeRelease (pwSegment);
	pwLoader		= SafeRelease (pwLoader);

	dmthCoUninitialize();
	return dwRes;
}





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICSONG DANHAFF
//
// File : tdmperfv.cpp
//
// History: <nl>
//  07/18/2000 - danhaff - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE


//  Regression for ManBug 39879

// ReproSteps:
// 1. Create a DirectSound.
// 2. Create a DirectMusic performance.
// 3. Pass the DirectSound object into InitAudio.
// 4. Play a WAV file through DirectMusic.
// 5. Stop and release the WAV segment.
// 6. Release the performance. (Access violation occurs here)

//--------------------------------------------------------------------------;
DWORD tdmperfvInitAudioPlayWave(
    BOOL fCoCreate,
    BOOL fMaxDebug,
    LPARAM dwParam1,
    LPARAM dwParam2)
{
    DWORD                       dwRes           = FNS_FAIL;
    HRESULT                     hr              = S_OK;

    dmthSetPath(NULL);
    WCHAR   *wchPath                            = gwszMediaPath;
    char    *chPath                             = gszMediaPath;
    CtIDirectMusicLoader8          *ptLoader8   = NULL;
    CtIDirectMusicPerformance8     *ptPerf8     = NULL;
    CtIDirectMusicSegment8         *ptSeg8Wave  = NULL;
    CtIDirectMusicAudioPath        *ptAudioPath = NULL;
    CtIDirectMusic                 *ptDM        = NULL;
    IDirectSound8                  *pDS8         = NULL;
    IDirectSound                   *pDS          = NULL;
    DMUS_OBJECTDESC                desc         = {0};

    // **********************************************************************
    // 1) Initialize
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL,
            TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 1. Create a DirectSound8 object
    hr = DirectSoundCreate8(NULL, &pDS8, NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** DirectSoundCreate failed. %s (%08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

  //Get the DS1 interface from it.
    hr = pDS8->QueryInterface(IID_IDirectSound, (void **)&pDS);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** QI for IDirectSound1 failed. %s (%08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }
    
    //Release the DS8 interface.
    SAFE_RELEASE(pDS8);


    //Set Cooperative level on it.
    pDS->SetCooperativeLevel(ghWnd, DSSCL_PRIORITY);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** SetCooperativeLevel failed with %s (%08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 2. Create a DirectMusic performance.
    hr = dmthCreatePerformance (IID_IDirectMusicPerformance8, &ptPerf8);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreatePerformance (IID_IDirectMusicPerformance8failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 2.3 Create a DirectMusic object.
    hr = dmthCreateDMBaseObj(IID_IDirectMusic, &ptDM);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreatePerformance (IID_IDirectMusicPerformance8failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }



//3. Pass the DirectSound object into InitAudio. (don't know what path he's using)
//    hr = ptPerf8->InitAudio (NULL, &pDS, ghWnd, DMUS_APATH_DYNAMIC_3D, 16, DMUS_AUDIOF_ALL, NULL);
    hr = ptPerf8->InitAudio (NULL, &pDS, ghWnd, DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, DMUS_AUDIOF_ALL, NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ptPerformance->InitAudio failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    // Create a loader
    hr = dmthCreateLoader (IID_IDirectMusicLoader8, &ptLoader8);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreateLoader failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    //This call should always succeed.
    hr = ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, gwszMediaPath, FALSE);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ERROR: IDirectMusicLoader8::SetSearchDirectory failed!!");
        goto TEST_END;
    }


    // Do a stupid scan of the directory since the loader can't figure this out for itself
    hr = ptLoader8->ScanDirectory(CLSID_DirectMusicSegment, L"*", NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ptLoader->ScanDirectory failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }



	// **********************************************************************
	// 3) Get the AudioPath and Segment8
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,L"PortBVT1.wav");

	hr = ptLoader8->GetObject(&desc, CTIID_IDirectMusicSegment8,(void **)&ptSeg8Wave);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(ptSeg8Wave) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

  
    hr = ptPerf8->GetDefaultAudioPath(&ptAudioPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetDefaultAudioPath")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    //Download this so we can hear it.
    hr = ptSeg8Wave->Download(ptAudioPath);
    if (hr != S_OK)
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** Download returned %s (%08Xh) instead of S_OK"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 4. Play a WAV file through DirectMusic.
    hr = ptPerf8->PlaySegmentEx(ptSeg8Wave, NULL, NULL, DMUS_SEGF_DEFAULT, 0, NULL, NULL, ptAudioPath);
    if (hr != S_OK)
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** PlaySegmentEx returned %s (%08Xh) instead of S_OK"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

//Wait a second.
    Sleep(1500);

// 5. Stop and release the WAV segment.
    hr = ptPerf8->Stop(ptSeg8Wave, NULL, 0, 0);
    if (hr != S_OK)
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** StopEx returned %s (%08Xh) instead of S_OK"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 6. Release the performance. (Access violation occurs here)
    if (ptPerf8)
    {
        ptPerf8->CloseDown();
        SAFE_RELEASE(ptPerf8);
    }

    dwRes = FNS_PASS;

TEST_END:

    //Unload this so we don't leak.
    if (ptSeg8Wave && ptAudioPath)
    {
        hr = ptSeg8Wave->Unload(ptAudioPath);
        if (hr != S_OK)
        {
            fnsLog(ABORTLOGLEVEL, TEXT("**** LEAK!!!returned %s (%08Xh) instead of S_OK"),tdmXlatHRESULT(hr), hr);
        }
    }

    // **********************************************************************
    // 18) Cleanup objects and uninitialize and Return results
    // *********************************************************************
    if (ptPerf8)
    {
        ptPerf8->CloseDown();
        SAFE_RELEASE(ptPerf8);
    }

    SAFE_RELEASE(ptLoader8);
    SAFE_RELEASE(ptSeg8Wave);
    SAFE_RELEASE(ptAudioPath);
    SAFE_RELEASE(ptDM);
    SAFE_RELEASE(pDS8);
    SAFE_RELEASE(pDS);
    dmthCoUninitialize();
    return dwRes;
}
//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICSONG DANHAFF
//
// File : tdmperfv.cpp
//
// History: <nl>
//  07/18/2000 - danhaff - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE


//  Regression for ManBug 39879

// ReproSteps:
// 1. Create a DirectSound.
// 2. Create a DirectMusic performance.
// 3. Pass the DirectSound object into InitAudio.
// 4. Play a WAV file through DirectMusic.
// 5. Stop and release the WAV segment.
// 6. Release the performance. (Access violation occurs here)

//--------------------------------------------------------------------------;
DWORD tdmperfvInitAudioPlayWaveLoop(
    BOOL fCoCreate,
    BOOL fMaxDebug,
    LPARAM dwParam1,
    LPARAM dwParam2)
{
    DWORD                       dwRes           = FNS_FAIL;
    HRESULT                     hr              = S_OK;

    dmthSetPath(NULL);
    WCHAR   *wchPath                            = gwszMediaPath;
    char    *chPath                             = gszMediaPath;
    CtIDirectMusicLoader8          *ptLoader8   = NULL;
    CtIDirectMusicPerformance8     *ptPerf8     = NULL;
    CtIDirectMusicSegment8         *ptSeg8Wave  = NULL;
    CtIDirectMusicAudioPath        *ptAudioPath = NULL;

    DMUS_OBJECTDESC                desc         = {0};

	DMUS_CURVE_PMSG*			pCurve;

    // **********************************************************************
    // 1) Initialize
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL,
            TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = dmthCreatePerformance (IID_IDirectMusicPerformance8, &ptPerf8);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreatePerformance (IID_IDirectMusicPerformance8failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptPerf8->InitAudio (NULL, NULL, ghWnd, DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, DMUS_AUDIOF_ALL, NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ptPerformance->InitAudio failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = dmthCreateLoader (IID_IDirectMusicLoader8, &ptLoader8);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreateLoader failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    hr = ptLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, gwszMediaPath, FALSE);
    if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ERROR: IDirectMusicLoader8::SetSearchDirectory failed!!");
        goto TEST_END;
    }

    hr = ptLoader8->ScanDirectory(CLSID_DirectMusicSegment, L"*", NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ptLoader->ScanDirectory failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

	// **********************************************************************
	// 3) Get the AudioPath and Segment8
	// **********************************************************************
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	wcscpy(desc.wszFileName,L"PortBVT1.wav");
	hr = ptLoader8->GetObject(&desc, CTIID_IDirectMusicSegment8,(void **)&ptSeg8Wave);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** Loader8->GetObject(ptSeg8Wave) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptSeg8Wave->Download(ptPerf8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ptSeg8Wave->Download")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

    hr = ptSeg8Wave->SetRepeats(3); //play 4 time
    if(FAILED(hr))
    {
		fnsLog(ABORTLOGLEVEL, TEXT("**** ptSeg8Wave->SetRepeats")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
    }

	//allocpmsg
	hr = ptPerf8->AllocPMsg(sizeof(DMUS_CURVE_PMSG), (DMUS_PMSG**) &pCurve);
	if(FAILED(hr) || !pCurve)
	{
		fnsLog(BUGLOGLEVEL,TEXT("**** ABORT: IDMPerformance::AllocPMsg failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	ZeroMemory(pCurve, sizeof(DMUS_CURVE_PMSG));

	pCurve->dwSize = sizeof(DMUS_CURVE_PMSG);
	pCurve->rtTime = 0;
	pCurve->dwFlags = DMUS_PMSGF_DX8 | DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;  
	pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
	pCurve->dwType = DMUS_PMSGT_CURVE;            
	pCurve->dwGroupID = 0xFFFFFFF;

//	pCurve->mtOriginalStart = 0;
	pCurve->mtDuration = 200;
	pCurve->nStartValue = 0;				
	pCurve->nEndValue = 0;
	pCurve->bCurveShape = DMUS_CURVES_LINEAR;
	pCurve->bCCData = 7;
	pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;  
	pCurve->bType = DMUS_CURVET_CCCURVE ;
	pCurve->wMergeIndex = 0;
	pCurve->mtResetDuration = 0;

    hr = ptPerf8->PlaySegmentEx(ptSeg8Wave, NULL, NULL, DMUS_SEGF_DEFAULT, 0, NULL, NULL, NULL);
    if(FAILED(hr))
    {
		ptPerf8->FreePMsg((DMUS_PMSG*) pCurve);
        fnsLog(ABORTLOGLEVEL, TEXT("**** PlaySegmentEx returned %s (%08Xh) instead of S_OK"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }
	Sleep(200);
	hr = ptPerf8->SendPMsg((DMUS_PMSG*) pCurve);
    if(FAILED(hr))
    {
		ptPerf8->FreePMsg((DMUS_PMSG*) pCurve);
        fnsLog(ABORTLOGLEVEL, TEXT("**** SendPMsg returned %s (%08Xh) instead of S_OK"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }
//Wait a second.
    Sleep(5000);

    dwRes = FNS_PASS;

TEST_END:
    // **********************************************************************
    // 18) Cleanup objects and uninitialize and Return results
    // *********************************************************************
    if (ptPerf8 && ptSeg8Wave)
    {
		ptPerf8->Stop(NULL, NULL, 0, 0);
	    ptSeg8Wave->Unload(ptPerf8);
	}
    if (ptPerf8)
    {
        ptPerf8->CloseDown();
        SAFE_RELEASE(ptPerf8);
    }

    SAFE_RELEASE(ptLoader8);
    SAFE_RELEASE(ptSeg8Wave);
    SAFE_RELEASE(ptAudioPath);

    dmthCoUninitialize();
    return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICSONG KCRAVEN
//
// File : tdmperfv.cpp
//
// History: <nl>
//  07/18/2000 - kcraven - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE
// ReproSteps:
// 1. Create a DirectSound.
// 2. Create a DirectMusic performance.
// 3. Pass the DirectSound object into InitAudio. (fails!!)

//--------------------------------------------------------------------------;
DWORD tdmperfvInitAudioWithDSound(
    BOOL fCoCreate,
    BOOL fMaxDebug,
    LPARAM dwParam1,
    LPARAM dwParam2)
{
    DWORD                       dwRes           = FNS_FAIL;
    HRESULT                     hr              = S_OK;

    dmthSetPath(NULL);
    WCHAR   *wchPath                            = gwszMediaPath;
    char    *chPath                             = gszMediaPath;
    CtIDirectMusicPerformance8     *ptPerf8     = NULL;
    IDirectSound8                   *pDS8         = NULL;
    IDirectSound                   *pDS         = NULL;

    // **********************************************************************
    // 1) Initialize
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL,
            TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }



// 1. Create a DirectSound8
    if (fCoCreate)
    {
        hr = DirectSoundCreate8(NULL, &pDS8, NULL);
        if (FAILED (hr))
        {
            fnsLog(ABORTLOGLEVEL, TEXT("**** DirectSoundCreate failed. %s (%08Xh)"),
                tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }

        hr = pDS8->QueryInterface(IID_IDirectSound, (void **)&pDS);
        if (FAILED (hr))
        {
            fnsLog(ABORTLOGLEVEL, TEXT("**** QI for DirectSound failed. %s (%08Xh)"),
                tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_DirectSound8,
                              NULL,               // don't support aggregation yet
                              CLSCTX_INPROC_SERVER,
                              IID_IDirectSound,
                              (void**)&pDS);
        if (FAILED (hr))
        {
            fnsLog(ABORTLOGLEVEL, TEXT("**** CoCreate(DSound8) failed with (%08Xh)"),
                tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }

        hr = pDS->Initialize(NULL);
        if (FAILED (hr))
        {
            fnsLog(ABORTLOGLEVEL, TEXT("**** CDSound8->Initialize failed with %s (%08Xh)"),
                tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }


    }

//
    hr = pDS->SetCooperativeLevel(ghWnd, DSSCL_PRIORITY);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** CDSound8->SetCooperativeLevel failed with %s (%08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

// 2. Create a DirectMusic performance.
    hr = dmthCreatePerformance (IID_IDirectMusicPerformance8, &ptPerf8);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** dmthCreatePerformance (IID_IDirectMusicPerformance8failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

//3. Pass the DirectSound object into InitAudio. (don't know what path he's using)
    hr = ptPerf8->InitAudio (NULL, &pDS, ghWnd, DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, 0, NULL);
    if (FAILED (hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ptPerformance->InitAudio failed! (%s == %08Xh)"),
            tdmXlatHRESULT(hr), hr);
        goto TEST_END;
    }

    dwRes = FNS_PASS;

TEST_END:
    // **********************************************************************
    // 18) Cleanup objects and uninitialize and Return results
    // *********************************************************************



    if (ptPerf8)
    {
        ptPerf8->CloseDown();
        SAFE_RELEASE(ptPerf8);
    }
    SAFE_RELEASE(pDS8);
    if (pDS)
    {
        pDS->SetCooperativeLevel(ghWnd, DSSCL_NORMAL);
        SAFE_RELEASE(pDS);
    }

    dmthCoUninitialize();
    return dwRes;
}




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::InitAudio()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::InitAudio()<nl>
//
// Test Function: <nl>
// tdmperv8InitAudio()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//  1) CoInitialize<nl>
//  2) CoCreatePerformance <nl>
//  3) Performance8->InitAudio<nl>
//  4) Performance8->GetDefaultAudioPath<nl>
//  5) AudioPath->GetObjectInPath(buffer)<nl>
//  6) AudioPath->GetObjectInPath(port)<nl>
//  7) Port->GetFormat<nl>
//  8) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	03/15/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PChannelInfo(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_ABORTED;
	HRESULT 					hr					= S_OK;

	CtIDirectMusicPerformance8* pwPerformance8		= NULL;
	CtIDirectMusicAudioPath*	pAudioPath			= NULL;
	CtIDirectMusic* 			pwMusic 			= NULL;

	BOOL						bCheckFormat		= (DWORD)fCoCreate;
	DWORD						dwDefaultPathType	= (DWORD)dwParam1;
	DWORD						dwPChannelCount 	= 64;

	DWORD						dwStage;
	DWORD						dwBuffer;
	GUID						guidObject;
	GUID						guidInterface;
	DWORD						dwIndex 			= 0;
	IDirectMusicPort*			pDMPortPath 		= NULL;
	IDirectMusicPort*			pDMPortInfo	 		= NULL;
	CtIDirectMusicPort*			pwPortInfo	 		= NULL;

	DWORD						dwPChannel			= 0;
	DWORD						dwGroup				= 0;
	DWORD						dwMChannel			= 0;

	// **********************************************************************
	// 1) CoInitialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) CoCreatePerformance 
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance8);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
	// **********************************************************************
	// 3) Performance8->InitAudio
	// **********************************************************************
	hr = pwPerformance8->InitAudio(
		&pwMusic,NULL,ghWnd,
		dwDefaultPathType,	
		dwPChannelCount,	
		NULL,		
		NULL);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->InitAudio ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwMusic)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwMusic is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Performance8->GetDefaultAudioPath
	// **********************************************************************
	hr = pwPerformance8->GetDefaultAudioPath(&pAudioPath);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance8->GetDefaultAudioPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pAudioPath)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pAudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 6) AudioPath->GetObjectInPath(port)
	// **********************************************************************
	dwIndex = 0;
	guidInterface = IID_IDirectMusicPort;
	while(S_OK == (hr = pAudioPath->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_PORT,0,GUID_All_Objects,dwIndex++,IID_IDirectMusicPort,(void**)&pDMPortPath)))
	{
		if(pDMPortPath)
		{
			dwPChannel = 0;
			fnsLog(FYILOGLEVEL, TEXT("    ----    pPort->PChannelInfo(%s,%s,%s)"),"dwPChannel","   dwGroup","dwMChannel");
			while(dwPChannel < (dwPChannelCount + 1)) // +1 should be invalid
			{
				hr = pwPerformance8->PChannelInfo(dwPChannel,&pwPortInfo,&dwGroup,&dwMChannel);
				if(FAILED(hr))
				{
					if(dwPChannel < dwPChannelCount) // valid pchannel range for this port 0 - 63
					{
						fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PChannelInfo ")
							TEXT("failed (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
						goto TEST_END;
					}
					else if(hr != E_INVALIDARG) // result if requested pchannel is out of valid range
					{
						fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance8->PChannelInfo ")
							TEXT("failed (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
						goto TEST_END;
					}
					else
					{
						hr = S_OK; //test passed with correct HRESULT
					}
				}
				else
				{
					//get real port
					hr = pwPortInfo->GetRealObjPtr(&pDMPortInfo);
					if(FAILED(hr))
					{
						fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPortInfo->GetRealObj ")
							TEXT("failed (%s == %08Xh)"),
							tdmXlatHRESULT(hr), hr);
						goto TEST_END;
					}
					//log data and compare port pointers
					fnsLog(FYILOGLEVEL, TEXT("    ----    pPort->PChannelInfo(%10d,%10d,%10d)"),dwPChannel,dwGroup,dwMChannel);
					if(pDMPortInfo != pDMPortPath)
					{
						fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetObjectInPath and PChannelInfo did not return the same port!"));
						fnsLog(BUGLOGLEVEL, TEXT("          portpDMPortInfo != pDMPortPath (%p != %p)"),pDMPortInfo,pDMPortPath);
						goto TEST_END;
					}
				}
				if(pwPortInfo) 
				{
					pwPortInfo->Release();
					pwPortInfo = NULL;
				}
				if(pDMPortInfo) 
				{
					pDMPortInfo->Release();
					pDMPortInfo = NULL;
				}
				++dwPChannel;
			}
			// Release the ports
			pDMPortPath->Release();
			pDMPortPath = NULL;
		}
		else
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: PORT NOT FOUND: AudioPath::GetObjectInPath(%ld) succeeded (%s) but pPort is NULL"),dwIndex,tdmXlatHRESULT(hr));
			goto TEST_END;
		}
	}
	if(FAILED(hr) && (DMUS_E_NOT_FOUND != hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicAudioPath->GetObjectInPath ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	dwRes = FNS_PASS;

TEST_END:
	// **********************************************************************
	// 8) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance8)
	{
		pwPerformance8->CloseDown();
		pwPerformance8->Release();
		pwPerformance8 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	if(pDMPortPath)
	{
		pDMPortPath->Release();
		pDMPortPath = NULL;
	}
	if(pDMPortInfo)
	{
		pDMPortInfo->Release();
		pDMPortInfo = NULL;
	}
	if(pwPortInfo)
	{
		pwPortInfo->Release();
		pwPortInfo = NULL;
	}
	if(pAudioPath)
	{
		pAudioPath->Release();
		pAudioPath = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx().
//
// Test Function: <nl>
// tdmperv8PlayWaveAsSegment <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERV8.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicLoader object <nl>
// 4) Call Loader->LoadObjectFromFile() to Segment object <nl>
// 5) Call Segment->GetLength() and check results <nl>
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History:
//  09/19/2000 - kcraven - Created
//
// @index topic | IDIRECTMUSICPERFORMANCE8_CASES
//--------------------------------------------------------------------------;
DWORD tdmperv8PlayWaveAsSegment(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicPerformance8*	pwPerformance	= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicSegment8*		pwSegment		= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState	= NULL;
	WCHAR*						pFile			= (WCHAR*)dwParam1;

	int 						counter 		= 0;
	int 						SleepTime		= 1000;
	int 						TimeOutValue	= 10;

	dmthSetPath(NULL);

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }
    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance8 object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    // **********************************************************************
    // 3) Call the function to be tested and Test the function
    // **********************************************************************
	hr = pwPerformance->InitAudio(NULL,NULL,ghWnd,DMUS_APATH_SHARED_STEREOPLUSREVERB,64,0,NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8->InitAudio ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
    // 3.1) Create Loader
    // **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
        goto TEST_END;
	}
	// **********************************************************************
    // 3.2) SetSearchDirectory
    // **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes,gwszBasePath,FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
    // 3.1) Get File
    // **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pFile,(void **)&pwSegment);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->LoadObjectFromFile(pwSegment) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
    // **********************************************************************
    // 5) Call Segment->Download and check results
    // **********************************************************************
	hr = pwSegment->Download(pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: Segment->GetLength ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	dwRes = FNS_FAIL;
    // **********************************************************************
    // 5) Call pwPerformance->PlaySegmentEx and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment,  	// Segment to play. Alternately, could be an IDirectMusicSong. 
		0, 				// If song, which segment in the song. 
		NULL,			// Optional template segment to compose transition with. 
		NULL,			// DMUS_SEGF_ flags.
		0, 				// Time to start playback. 
		&pwSegmentState,			// Returned Segment State. 
		NULL,			// Optional segmentstate or audiopath to replace.
		NULL);			// Optional audioPath to play on. 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("!!!! FAIL: pwPerformance->PlaySegmentEx ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	counter = 0;
	SleepTime = 1000;
	while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out\n")
				TEXT("Segment did not start playing in the time speciied (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = pwPerformance->IsPlaying(NULL,pwSegmentState)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out\n")
				TEXT("Segment did not stop playing in the time speciied (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwSegment && pwPerformance)
	{
		pwSegment->Unload(pwPerformance);
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	
	dmthCoUninitialize();	
	return dwRes;
}








//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx(RPN)_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx(RPN)<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentExRPN()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	10/6/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentExRPN(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusic*				pwMusic			= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicPerformance8*	pwPerformance	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState1	= NULL;
	CtIDirectMusicSegmentState*	pwSegmentState2	= NULL;
	CtIDirectMusicSegment8*		pwSegment1		= NULL;
	CtIDirectMusicSegment8*		pwSegment2		= NULL;
	CtIDirectMusicAudioPath*	pwPath1			= NULL;
	CtIDirectMusicAudioPath*	pwPath2			= NULL;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	WCHAR*						pMidiFile1 		= L"rpn0.mid";
	WCHAR*						pMidiFile2 		= L"rpn1.mid";
	DWORD						dwPathType		= DMUS_APATH_DYNAMIC_STEREO;
//	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	BOOL						fActivate		= TRUE;
	DWORD						dwFlags			= NULL;
	MUSIC_TIME					mtNow1			= 0;
	MUSIC_TIME					mtNow2			= 0;
	long						lVolume			= 0;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pMidiFile1,(void **)&pwSegment1);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment1) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pMidiFile2,(void **)&pwSegment2);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment2) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************	
	hr = pwPerformance->InitAudio(&pwMusic,NULL,ghWnd,NULL,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->InitAudio(NULLs) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath1);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath1)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	hr = pwPerformance->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath2);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath2)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(pwSegment1)
	{
		hr = pwSegment1->Download(pwPath1);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment1->Download(pwPath1) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment1->Download(pwPath1) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	if(pwSegment2)
	{
		hr = pwSegment2->Download(pwPath2);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment2->Download(pwPath2) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment2->Download(pwPath2) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}
	// **********************************************************************
	// 5) Call PlaySegmentEx - the method to be tested
	// **********************************************************************
	lVolume = -1000;
	hr = pwPerformance->SetGlobalParam(GUID_PerfMasterVolume,&lVolume,sizeof(long));
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->SetGlobalParam(volume) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->GetTime(NULL,&mtNow1);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetTime(&mtNow1) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}

	mtNow1 += (768 * 4); // one 4/4 measure
	mtNow2 = mtNow1;

	fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwPerformance1->GetTime(%d) "),(long)mtNow1);

	dwRes = FNS_FAIL;
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment1, 
		0,
		NULL,
		DMUS_SEGF_SECONDARY,
		mtNow1,
		&pwSegmentState1,
		NULL,
		pwPath1);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx(pSegment1) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->PlaySegmentEx( 
		pwSegment2, 
		0,
		NULL,
		DMUS_SEGF_BEAT,
		mtNow2,
		&pwSegmentState2,
		NULL,
		pwPath2);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx(pSegment2) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 6) varification - segment should play
	// **********************************************************************
	counter = 0;
	SleepTime = 300;
	while ((hr = pwPerformance->IsPlaying(pwSegment1,NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 1) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 300;
	while ((hr = pwPerformance->IsPlaying(pwSegment2,NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 2) timed out\n")
				TEXT("Segment did not start playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = pwPerformance->IsPlaying(pwSegment1,NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 1) timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	counter = 0;
	SleepTime = 3000;
	while ((hr = pwPerformance->IsPlaying(pwSegment2,NULL)) == S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ > TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IsPlaying(segment 2) timed out\n")
				TEXT("Segment did not stop playing in the time specified (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
	}
	if(pwSegment1)
	{
		if(pwPath1)
		{
			pwSegment1->Unload(pwPath1); //don't care about the return code at this point
		}
		pwSegment1->Release();
		pwSegment1 = NULL;
	}
	if(pwSegment2)
	{
		if(pwPath2)
		{
			pwSegment2->Unload(pwPath2); //don't care about the return code at this point
		}
		pwSegment2->Release();
		pwSegment2 = NULL;
	}
	if(pwSegmentState1)
	{
		pwSegmentState1->Release();
		pwSegmentState1 = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwPath1)
	{
		pwPath1->Release();
		pwPath1 = NULL;
	}
	if(pwPath2)
	{
		pwPath2->Release();
		pwPath2 = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE8 KCRAVEN
//
// @topic IDirectMusicPerformance8::PlaySegmentEx(synthleak)_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance8::PlaySegmentEx(synthleak)<nl>
//
// Test Function: <nl>
// tdmperv8PlaySegmentExSynthLeak()<nl>
//
// Parameters: <nl>
//	BOOL	fCoCreate	- unused <nl>
//	BOOL	fMaxDebug	- unused <nl>
//	DWORD	dwParam1	- unused <nl>
//	DWORD	dwParam2	- unused <nl>
//
// File : tdmperv8.cpp<nl>
//
// Steps: <nl>
//	 1) Initialize<nl>
//	 2) Create Performance8<nl>
//	 3.0) Create Loader<nl>
//	 3.1) SetSearchDirectory<nl>
//	 3.2) Get the Segment<nl>
//	 4.0) Init the Performance<nl>
//	 4.1) Add the default Port<nl>
//	 4.2) Download<nl>
//	 5) Call PlaySegmentEx - the method to be tested<nl>
//	 6) varification - segment should play<nl>
//	 7) Cleanup objects and uninitialize and Return results<nl>
//
// History: <nl>
//	10/09/2000 - kcraven - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE8
//--------------------------------------------------------------------------;
DWORD tdmperv8PlaySegmentExSynthLeak(
	BOOL fCoCreate,
	BOOL fMaxDebug,
	LPARAM dwParam1,
	LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_ABORTED;
	HRESULT 					hr				= S_OK;

	dmthSetPath(NULL);
	WCHAR*						wchPath 		= gwszBasePath;
//	WCHAR*						wchFile 		= gwszMediaPath;

	CtIDirectMusic*				pwMusic			= NULL;
	CtIDirectMusicLoader8*		pwLoader		= NULL;
	CtIDirectMusicPerformance8*	pwPerformance	= NULL;
	CtIDirectMusicSegment8*		pwSegment1		= NULL;
	CtIDirectMusicAudioPath*	pwPath			= NULL;

	int 						counter 		= 0;
	int 						SleepTime		= 3000;
	int 						TimeOutValue	= 10;

	WCHAR*						pMidiFile1 		= L"synthleak.sgt";
	DWORD						dwPathType		= DMUS_APATH_DYNAMIC_STEREO;
//	DWORD						dwPathType		= DMUS_APATH_SHARED_STEREOPLUSREVERB;
	DWORD						dwPChannelCount	= 16;
	BOOL						fActivate		= TRUE;
	DWORD						dwFlags			= NULL;
	int							again			= 0;

	// **********************************************************************
	// 1) Initialize
	// **********************************************************************
	hr = dmthCoInitialize(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  initialization failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 2) Create Performance8
	// **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance8, &pwPerformance);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance8 creation "),
			TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.0) Create Loader
	// **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader8, &pwLoader);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Loader object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.1) SetSearchDirectory
	// **********************************************************************
	hr = pwLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 3.2) Get the Segment
	// **********************************************************************
	hr = pwLoader->LoadObjectFromFile(CLSID_DirectMusicSegment,CTIID_IDirectMusicSegment8,pMidiFile1,(void **)&pwSegment1);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pwSegment1) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	// **********************************************************************
	// 4.0) Init the Performance
	// **********************************************************************	
	hr = pwPerformance->InitAudio(&pwMusic,NULL,ghWnd,NULL,NULL,NULL,NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->InitAudio(NULLs) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	hr = pwPerformance->CreateStandardAudioPath(
		dwPathType, 			// Choice of standard audio path.
		dwPChannelCount,	// How many pchannels to create.
		fActivate,
		&pwPath);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->CreateStandardAudioPath() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		goto TEST_END;
	}
	if(!pwPath)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AudioPath is NULL "));
		goto TEST_END;
	}
	// **********************************************************************
	// 4.2) Download
	// **********************************************************************	
	if(pwSegment1)
	{
		hr = pwSegment1->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment1->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		if(S_FALSE == hr)
		{
			fnsLog(FYILOGLEVEL, TEXT("---- FYI: pwSegment1->Download(pwPath) ")
					TEXT("returned (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		}
	}

	dwRes = FNS_FAIL;

	// **********************************************************************
	// 4.3) Play
	// **********************************************************************	
	for(again = 0;again < 10;again++)
	{
		hr = pwSegment1->Download(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment1->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		hr = pwPerformance->PlaySegmentEx( 
			pwSegment1, 
			0,
			NULL,
			0,
			0,
			NULL,
			NULL,
			pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("!!!! BUG: pwPerformance->PlaySegmentEx(pSegment1) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
		Sleep(400);
		hr = pwSegment1->Unload(pwPath);
		if(FAILED(hr))
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment1->Download(pwPath) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			goto TEST_END;
		}
	}
	dwRes = FNS_PASS;

TEST_END:
	// *********************************************************************
	// 7) Cleanup objects and uninitialize and Return results
	// *********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
	}
	if(pwSegment1)
	{
		if(pwPath)
		{
			pwSegment1->Unload(pwPath); //don't care about the return code at this point
		}
		pwSegment1->Release();
		pwSegment1 = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwPath)
	{
		pwPath->Release();
		pwPath = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\TemplateError\DMTest1\tdmperfv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tdmperfv.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// tdmperfv.cpp
//
// Valid Test case functions for IDirectMusicPerformance methods (valid parameters)
//
// Functions:
//  tdmperfAdjustTimeValidTest1()
//
// History:
//  03/27/1998 - a-llucar - created
//===========================================================================

#include "tdmusic.h"
#include "tdmperf.h"
#include "tdmatool.h"
#include "time.h"
#include <sys/timeb.h>
#define DWORD_MAX	0xffffffff;
#define ULONG_MIN	0

	const DWORD SEGF_FLAGS[]=
	{
		DMUS_SEGF_REFTIME,
		DMUS_SEGF_AFTERPREPARETIME,
		DMUS_SEGF_GRID,
		DMUS_SEGF_BEAT,
		DMUS_SEGF_MEASURE,
		DMUS_SEGF_DEFAULT,
		DMUS_SEGF_SECONDARY,
		DMUS_SEGF_QUEUE,
		DMUS_SEGF_CONTROL
	};

	const GUID *AllDMGuids[]=
	{
			&CLSID_DirectMusicPerformance,
			&CLSID_DirectMusicSegment,
			&CLSID_DirectMusicSegmentState,
			&CLSID_DirectMusicGraph,
			&CLSID_DirectMusicTempoTrack,
			&CLSID_DirectMusicSeqTrack,
			&CLSID_DirectMusicSysExTrack,
			&CLSID_DirectMusicTimeSigTrack,
			&CLSID_DirectMusicStyle,
			&CLSID_DirectMusicChordTrack,
			&CLSID_DirectMusicCommandTrack,
			&CLSID_DirectMusicStyleTrack,
			&CLSID_DirectMusicMotifTrack,
			&CLSID_DirectMusicChordMap,
			&CLSID_DirectMusicComposer,
			&CLSID_DirectMusicSignPostTrack,
			&CLSID_DirectMusicLoader,
			&CLSID_DirectMusicBandTrack,
			&CLSID_DirectMusicBand,
			&CLSID_DirectMusicChordMapTrack,
			&CLSID_DirectMusicMuteTrack,
			&GUID_DirectMusicAllTypes,
			&GUID_NOTIFICATION_SEGMENT,
			&GUID_NOTIFICATION_MEASUREANDBEAT,
			&GUID_NOTIFICATION_CHORD,
			&GUID_NOTIFICATION_COMMAND,
			&GUID_CommandParam,
			&GUID_ChordParam,
			&GUID_RhythmParam,
			&GUID_IDirectMusicStyle,
			&GUID_TempoParam,
			&GUID_Download,
			&GUID_Unload,
			&GUID_Enable_Auto_Download,
			&GUID_Disable_Auto_Download,
			&GUID_Clear_All_Bands,
			&GUID_IDirectMusicBand,
			&GUID_IgnoreBankSelectForGM,
			&GUID_ConnectToDLSCollection,
			&GUID_IDirectMusicChordMap,
			&GUID_MuteParam,
			&GUID_PerfMasterTempo,
			&GUID_PerfMasterVolume,
			&GUID_PerfMasterGrooveLevel,
			&GUID_DefaultGMCollection,
			&IID_IDirectMusicLoader,
			&IID_IDirectMusicGetLoader,
			&IID_IDirectMusicObject,
			&IID_IDirectMusicSegment,
			&IID_IDirectMusicSegmentState,
			&IID_IDirectMusicTrack,
			&IID_IDirectMusicPerformance,
			&IID_IDirectMusicTool,
			&IID_IDirectMusicGraph,
			&IID_IDirectMusicStyle,
			&IID_IDirectMusicChordMap,
			&IID_IDirectMusicComposer,
			&IID_IDirectMusicBand
	};

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AdjustTime()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AdjustTime(). <nl>
// Calls AdjustTime() back and forth while Segment is currently playing. <nl>
//
// Test Function: <nl>
// tdmperfvAdjustTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile convienence function <nl>
// 4) Call AdjustTime(large negative) and check results <nl>
// 5) Call AdjustTime(large positive) and check results <nl>
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/29/1998 - a-llucar - Created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAdjustTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	CtIDirectMusicSegment			*pwSegment		= NULL;
	WCHAR							*pMidiFile		= (WCHAR*)dwParam1;
	REFERENCE_TIME					rtNow			= 0;
   	
	// **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call AdjustTime(large negative) and check results
    // **********************************************************************
	Sleep(3000);
	hr = pwPerformance->GetTime(&rtNow, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  Performance->Gettime")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("GetTime returned %08Xh"), rtNow);
	rtNow = 0;

	hr = pwPerformance->AdjustTime( -10000000);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AdjustTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->GetTime(&rtNow, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  Performance->Gettime")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("GetTime returned %08Xh"), rtNow);
	Sleep(7000);

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoInitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}	// End tdmperfAdjustTimeValidTest1()


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddPort()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AddPort(). <nl>
// Calls AddPort passing NULL for pPort
//
// Test Function: <nl>
// tdmperfvAddPortValidTest1<nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load a Segment Object <nl>
// 4) Init the performance <nl>
// 5) Call Performance->AddPort passing NULL <nl>
// 6) Release objects, CoUninitialize, and check results <nl>
//
// History: <nl>
//  03/29/1998 - a-llucar - created <nl>
//  07/08/1998 - a-llucar - clean up <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAddPortValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;

	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;
	WCHAR						*wchPath		= gwszBasePath;
	char						*chPath			= gszMediaPath;
	dmthSetPath(NULL);
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 4) Init the performance
	// **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call Performance->AddPort passing NULL
	// **********************************************************************
	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and check results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddPort()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AddPort(). <nl>
// Calls AddPort() while a Segment is currently playing.
//
// Test Function: <nl>
// tdmperfvAddPortValidTest2<nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call dmthPlayMidiFile convienence function<nl>
// 4) Create a Port and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/29/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAddPortValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	WCHAR						*pMidiFile		= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(S_OK != hr)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}    
	Sleep(3000);

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and check results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::CloseDown()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::CloseDown().
//		Calls CloseDown() without first Init'ing the performance.
//
// Test Function: <nl>
// tdmperfvCloseDownValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call CloseDown() and check results <nl>
// 4) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvCloseDownValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;	
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call Closedown() and check results
    // **********************************************************************
	hr = pwPerformance->CloseDown();
	if(FAILED(hr))     
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->CloseDown ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 4) Release objects, CoUninitialize, and return result
    // **********************************************************************
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	
	dmthCoUninitialize();	
	return dwRes;
}	// End IDirectMusicPerformance->CloseDown() Test


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannel()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AssignPChannel(). <nl>
//		Re-assigns the same PChannel twice.  Checks results. <nl>
//
// Test Function: <nl>
// tdmperfvAssignPChannelValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call AssignPChannel twice to the same dwPChannel number and check results <nl>
// 8) Call RemovePort and check results <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAssignPChannelValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTPARAMS				dmos;
	GUID				        guidPort		= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, "**** ABORT: GetDefaultPort failed! "
                "(%s == %08Xh)",
                dmthXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);

    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort(pwPort);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}    
	
    // **********************************************************************
    // 7) Call AssignPChannel and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannel(5, pwPort, 1, 0);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannel ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->AssignPChannel(5, pwPort, 1, 0);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannel ")
                TEXT("failed (%s == %08Xh) \n (Attempted to assign the same PChannel number twice)."),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 8) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort(pwPort);
	if(FAILED(hr))
	{
        fnsLog(FYILOGLEVEL, TEXT("**** FYI: IDirectMusicPerformance->RemovePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
	}

TEST_END:
	// **********************************************************************
    // 9) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannel()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AssignPChannel(). <nl>
//		Calls AssignPChannel before calling AddPort(). <nl>
//		NOTE:  We Expect this test to Fail! <nl>
//
// Test Function: <nl>
// tdmperfvAssignPChannelValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AssignPChannel and check results <nl>
// 7) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAssignPChannelValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD								dwRes					= FNS_PASS;
	HRESULT							hr						= S_OK;
	CtIDirectMusic					*pwMusic				= NULL;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicPort			*pwPort				= NULL;
	GUID								guidPort				= GUID_NULL;
	DMUS_PORTPARAMS				dmos;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, "**** ABORT: GetDefaultPort failed! "
                "(%s == %08Xh)",
                dmthXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);

    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AssignPChannel and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannel( 5, pwPort, 1, 0 );
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: WE EXPECT THIS TO RETURN E_INVALIDARG!!!!"));
	if(hr != E_INVALIDARG) //expecting a fail (E_INVALIDARG)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannel ")
                TEXT("did not return correctly(%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
	// **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannelBlock()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AssignPChannelBlock(). <nl>
//		Assigns the same PChannelBlock twice <nl>
//
// Test Function: <nl>
// tdmperfvAssignPChannelBlockValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AddPort and check results <nl>
// 7) Call AssignPChannelBlock (twice to same dwBlockNum) and check results <nl>
// 8) Call RemovePort and check results <nl>
// 9) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAssignPChannelBlockValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTPARAMS				dmos;
	GUID				        guidPort		= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, "**** ABORT: GetDefaultPort failed! "
                "(%s == %08Xh)",
                dmthXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);

    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call AddPort and check results
    // **********************************************************************
	hr = pwPerformance->AddPort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:: IDirectMusicPerformance->AddPort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}    
	
    // **********************************************************************
    // 7) Call AssignPChannelBlock and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannelBlock( 3, pwPort, 1 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannelBlock ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->AssignPChannelBlock( 3, pwPort, 1 );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannelBlock ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
	// **********************************************************************
    // 8) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort( pwPort );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->RemovePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
	}

TEST_END:
	// **********************************************************************
    // 9) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AssignPChannelBlock()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AssignPChannelBlock(). <nl>
//		AssignPChannelBlock call before AddPort()<nl>
//
// Test Function: <nl>
// tdmperfvAssignPChannelBlockValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init a Performance <nl>
// 4) Enumerate a Port and check results <nl>
// 5) Create a Port and check results <nl>
// 6) Call AssignPChannelBlock (without call to AddPort()) and check results <nl>
// 7) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
// 03/30/98 - a-llucar - created. 
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAssignPChannelBlockValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusic				*pwMusic		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicPort			*pwPort			= NULL;
	DMUS_PORTPARAMS				dmos;
	GUID				        guidPort		= GUID_NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init a Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Enumerate a Port and check results
    // **********************************************************************
	hr = pwMusic->GetDefaultPort(&guidPort);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, "**** ABORT: GetDefaultPort failed! "
                "(%s == %08Xh)",
                dmthXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a Port and check results
    // **********************************************************************
	ZeroMemory(&dmos, sizeof(dmos));
	dmos.dwSize = sizeof(DMUS_PORTPARAMS);
	
	hr = pwMusic->CreatePort(
		guidPort,
        &dmos, 
        &pwPort, 
        NULL);

    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwMusic->CreatePort ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 6) Call AssignPChannelBlock and check results
    // **********************************************************************
	hr = pwPerformance->AssignPChannelBlock( 3, pwPort, 1 );
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: WE EXPECT THIS TO RETURN E_INVALIDARG!!!!"));
	if(hr != E_INVALIDARG)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AssignPChannelBlock ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
	// **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if( pwMusic )
	{
		pwMusic->Release();
		pwMusic = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddNotificationType()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AddNotificationType(). <nl>
//		Calls AddNotificationType(NULL) <nl>
//
// Test Function: <nl>
// tdmperfvAddNotificationTypeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call AddNotificationType(NULL) and check results <nl>
// 4) Call RemoveNotificationType(NULL) and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  04/01/1998 - a-llucar - created <nl>
//
//	Note:  Same test for AddNotificationTypeValidTest1() and RemoveNotificationTypeValidTest1(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAddNotificationTypeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						         LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call AddNotificationType and check results
    // **********************************************************************
	hr = pwPerformance->AddNotificationType(GUID_NULL);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AddNotificationType ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call RemoveNotificationType and check results
    // **********************************************************************
	hr = pwPerformance->RemoveNotificationType(GUID_NULL);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->RemoveNotificationType ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RemoveNotificationType()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::RemoveNotificationType(). <nl>
//		Calls RemoveNotificationType(NULL) <nl>
//
// Test Function: <nl>
// tdmperfvAddNotificationTypeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call AddNotificationType(NULL) and check results <nl>
// 4) Call RemoveNotificationType(NULL) and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  04/01/1998 - a-llucar - created <nl>
//
//	Note:  Same test for AddNotificationTypeValidTest1() and RemoveNotificationTypeValidTest1(). <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!!!! Test used is tdmperfvAddNotificationTypeValidTest1 !!!!!!!!!!!!!!



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AddNotificationType()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AddNotificationType(). <nl>
//		Calls AddNotificationType with All types of guids <nl>
//
// Test Function: <nl>
// tdmperfvAddNotificationTypeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType(All Types) and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - created <nl>
//
//  NOTE: Same test used for AddNotificationType(), GetNotificationPMsg() and FreePMsg()
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAddNotificationTypeValidTest2(BOOL fCoCreate, 
											BOOL fMaxDebug, 
											LPARAM dwParam1, 
											LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	DMUS_NOTIFICATION_PMSG		*pEvent				= NULL;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	HANDLE						hNotification;
	DWORD						dwResult;
	GUID						*guidNotification	= (GUID*)dwParam1;
	WCHAR						*pMidiFile			= (WCHAR*)dwParam2;
    char                        szGuid[MAX_LOGSTRING];

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }
    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // **********************************************************************
    // 3) Create an Event for hNotification
    // **********************************************************************
	hNotification = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotification )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Unable to Create an hNotificationEvent \n")
		    TEXT("(%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 4) Create an Event for hNotification and check results
	// *********************************************************************
	hr = pwPerformance->SetNotificationHandle( hNotification, 0 );
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->SetNotificationHandle  ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5) AddNotificationType and check results 
	// **********************************************************************
	hr = pwPerformance->AddNotificationType(*guidNotification);
	if(FAILED(hr))
	{
	    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->AddNotificationType ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
   	// **********************************************************************
    // 6) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
   	// **********************************************************************
    // 7) Wait for a single object to know that things should be fine
    // **********************************************************************
	dwResult = WaitForSingleObject( hNotification, 10000 );
	if( dwResult != WAIT_OBJECT_0 )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: WaitForSingleObject ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
    // 8) Call GetNotificationPMsg and check results
    // **********************************************************************
	hr = pwPerformance->GetNotificationPMsg(&pEvent);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// Check to make sure that pEvent was populated
	if(!pEvent)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("pEvent was not set"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
    //**********************************************************************
    // Validate the Members of the PMsg
    //**********************************************************************
    //dwSize
    fnsLog(FYILOGLEVEL,"!!!! FYI: pEvent->dwSize = %d",pEvent->dwSize);
    if (pEvent->dwSize != sizeof(DMUS_NOTIFICATION_PMSG))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pEvent->dwSize incorrect.");
        fnsLog(BUGLOGLEVEL, "           Is: %d", pEvent->dwSize);
        fnsLog(BUGLOGLEVEL, "    Should be: %d", sizeof(DMUS_NOTIFICATION_PMSG));
		dwRes = FNS_FAIL;
		goto TEST_END;
    }
    //guidNotificationType
    dmthGUIDtoString(pEvent->guidNotificationType, szGuid);
    fnsLog(FYILOGLEVEL,"!!!! FYI: pEvent->guidNotificationType = %s (%s)",
        szGuid, dmthXlatGUID(pEvent->guidNotificationType));
    
    if (pEvent->guidNotificationType != (*guidNotification))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pEvent->guidNotificationType incorrect.");
        fnsLog(BUGLOGLEVEL, "           Is: %s (%s)",
                pEvent->guidNotificationType, 
                szGuid);
        fnsLog(BUGLOGLEVEL, "    Should be: %s (%s)",
                pEvent->guidNotificationType,
                dmthXlatGUID(*guidNotification));
		dwRes = FNS_FAIL;
		goto TEST_END;
    }
    // **********************************************************************
    // 9) Call FreePMsg and check results
    // **********************************************************************
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->FreePMsg ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(1000);
		
TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
        if (pEvent)
        {
        	pwPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
        }

        pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(hNotification)
	{
		CloseHandle(hNotification);
		hNotification = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetNotificationPMsg()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetNotificationPMsg(). <nl>
//		Calls GetNotificationPMsg with All types of guids <nl>
//
// Test Function: <nl>
// tdmperfvAddNotificationTypeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType(All Types) and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - created <nl>
//
//  NOTE: Same test used for AddNotificationType(), GetNotificationPMsg() and FreePMsg()
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetNotificationHandle()_Valid_Test1 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetNotificationHandle(). <nl>
//		Calls SetNotificationHandle (2 seconds wait), sleeps for 3 seconds, <nl>
//      and verifies that the Event was discarded. <nl>
//
// Test Function: <nl>
// tdmperfvSetNotificationHandleValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType(All Types) and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 7) Wait for a single object to know that things should be fine <nl>
// 8) Call GetNotificationPMsg and check results <nl>
// 9) Call FreePMsg and check results <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/16/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetNotificationHandleValidTest1(BOOL fCoCreate, 
											BOOL fMaxDebug, 
											LPARAM dwParam1, 
											LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	DMUS_NOTIFICATION_PMSG		*pEvent				= NULL;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	HANDLE						hNotification;
	DWORD						dwResult;
	WCHAR						*pMidiFile			= (WCHAR*)dwParam2;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create an Event for hNotification
    // **********************************************************************
	hNotification = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotification )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Unable to Create an hNotificationEvent \n")
		    TEXT("(%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
	// 4) Create an Event for hNotification and check results
	// *********************************************************************
	hr = pwPerformance->SetNotificationHandle( hNotification, 0 );
	if(FAILED(hr))
	{
	    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->SetNotificationHandle  ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
	// **********************************************************************
	// 5) AddNotificationType and check results 
	// **********************************************************************
	hr = pwPerformance->AddNotificationType(GUID_NOTIFICATION_MEASUREANDBEAT);
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddNotificationType ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	Sleep(3000);
   	// **********************************************************************
    // 6) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

   	// **********************************************************************
    // 7) Wait for a single object to know that things should be fine
    // **********************************************************************
	dwResult = WaitForSingleObject( hNotification, 10000 );
	if( dwResult != WAIT_OBJECT_0 ) // It found a notification, which it shouldn't have
	{
	    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: WaitForSingleObject ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
	// Check to make sure that pEvent was discarded
	if(pEvent)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetNotificationPMsg ")
                TEXT("pEvent was set, but it should not have been."));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	Sleep(1000);
		
TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if (hNotification)
	{
		CloseHandle(hNotification);
		hNotification = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetTime(). <nl>
//		Calls GetTime passing NULL for both rt and mt. 
//
// Test Function: <nl>
// tdmperfvGetTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create Performance object <nl>
// 3) Init the Performance <nl>
// 4) Call GetTime() and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusic					*pwMusic			= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime() and check results
    // **********************************************************************
	hr = pwPerformance->GetTime(NULL, NULL);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
		
TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
      pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Init()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Init().
//	Call Init passing in an empty DirectMusic object
//
// Test Function: <nl>
// tdmperfvInitValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call function to be tested, and check results<nl>
// 4) Release objects, dmthCoUninitialize, and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvInitValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;	
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusic				*pwMusic		= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call the function to be tested 
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	//XXXXX		

TEST_END:
    // **********************************************************************
    // 4 Release objects, CoUninitialize, and return result
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}	// End IDirectMusicPerformance->Init() Test


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MusicToReferenceTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::MusicToReferenceTime(). <nl>
//		Call MusicToReferenceTime without first Initing the performance. <nl>
//		Expects to fail! <nl>
//
// Test Function: <nl>
// tdmperfvMusicToReferenceTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call MusicToReferenceTime and check results (EXPECT DMUS_E_NO_MASTER_CLOCK) <nl>
// 4) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvMusicToReferenceTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	REFERENCE_TIME				rt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 3) Call MusicToReferenceTime and check results
    // **********************************************************************
	hr = pwPerformance->MusicToReferenceTime( 1000, &rt );

	// EXPECT FAIL
	fnsLog(FYILOGLEVEL, TEXT("NOTE:  WE EXPECT THIS TO FAIL!"));
	if(hr != DMUS_E_NO_MASTER_CLOCK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusicToReference ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::ReferenceToMusicTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::ReferenceToMusicTime(). <nl>
//		Call ReferenceToMusicTime without first Initing the performance. <nl>
//		Expects to fail! <nl>
//
// Test Function: <nl>
// tdmperfvReferenceToMusicTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call ReferenceToMusicTime and check results (EXPECT DMUS_E_NO_MASTER_CLOCK) <nl>
// 4) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvReferenceToMusicTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	MUSIC_TIME					mt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 3) Call ReferenceToMusicTime and check results
    // **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime( 1000, &mt );

	// EXPECT FAIL
	fnsLog(FYILOGLEVEL, TEXT("NOTE:  WE EXPECT THIS TO FAIL!"));
	if(hr != DMUS_E_NO_MASTER_CLOCK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetLatencyTime()_Valid_Test1 |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetLatencyTime(). <nl>
//		Calls GetLatencyTime through SYNTH port, checks to see if it returns the same as GetTime()<nl>
//
// Test Function: <nl>
// tdmperfvGetLatencyTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile() convienence function - SYNTH port <nl>
// 4) Call GetTime and check results <nl>
// 5) Call GetLatencyTime and check results <nl>
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetLatencyTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	REFERENCE_TIME				rtGetTime			= 0;
	REFERENCE_TIME				rtGetLatencyTime	= 0;
	int							GetDiff				= 0;
	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function - SYNTH port
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime and check results
    // **********************************************************************
	hr = pwPerformance->GetTime(&rtGetTime, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetLatencyTime and check results
    // **********************************************************************
	hr = pwPerformance->GetLatencyTime(&rtGetLatencyTime);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetLatencyTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	 
	// Check to see if rtGetTime and rtGetLatencyTime are close to each other
	GetDiff = (((int)rtGetLatencyTime - (int)rtGetTime) /10000); //converts to milliseconds
	if (GetDiff < -1000 || GetDiff > 1000)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Expected GetLatencyTime not close to GetTime \n ")
                TEXT("The difference between GetLatencyTime and GetTime is == %i\n"),
				GetDiff);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(1000);

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and check results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment(). <nl>
//		Plays a Segment through a MIDI port.
//
// Test Function: <nl>
// tdmperfvPlaySegmentValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object (wrapped IDMPerformance object) <nl>
// 3) Call dmthPlayMidiFile and check results (Through MIDI port) <nl>
// 4) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  05/01/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;

	WCHAR						*pMidiFile		= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function (Through MIDI port)
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, FALSE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: dmthPlayMidiFile convienence function failed "),
                TEXT("(%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(1000);

TEST_END:
    // **********************************************************************
    // 5) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if (pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}	


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Stop()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Stop(). <nl>
//		Calls Stop on a SegmentState instead of a Segment
//
// Test Function: <nl>
// tdmperfvStopValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile() convienence function <nl>
// 4) Calls Segment->IsPlaying() on the SegmentState and checks results <nl>
// 4) Calls Segment->Stop)_ on the SegmentState and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  04/24/1998 - a-llucar - created <nl>
//
//	Note:  Same test is used for tdmperfvStopValidTest1 and tdmperfvIsPlayingValidTest1 <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvStopValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;
	CtIDirectMusicPerformance 	*pwPerformance		= NULL;
	MUSIC_TIME					mt					= 1024;

	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)&pwSegmentState, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call Segment->IsPlaying() on SegmentState and checks results
    // **********************************************************************
	hr = pwPerformance->IsPlaying(NULL, pwSegmentState);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Segment->IsPlaying (on SegmentState) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call Stop and check results
    // **********************************************************************
	Sleep(1000);
	hr = pwPerformance->Stop(NULL, pwSegmentState, 0, 0);
    if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Stop (on SegmentState) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
	}

TEST_END:
	// **********************************************************************
    // 6) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;

}
//===========================================================================

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::IsPlaying()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::IsPlaying(). <nl>
//		Calls IsPlaying on a SegmentState instead of a Segment
//
// Test Function: <nl>
// tdmperfvStopValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile() convienence function <nl>
// 4) Calls Segment->IsPlaying() on the SegmentState and checks results <nl>
// 4) Calls Segment->Stop)_ on the SegmentState and check results <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  04/24/1998 - a-llucar - created <nl>
//
//	Note:  Same test is used for tdmperfvStopValidTest1 and tdmperfvIsPlayingValidTest1 <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// *********************** Uses tdmperfvStopValidTest1 *********************

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Stop()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Stop().
//		Calls GetSegmentState After Stop to make sure that it is released correctly by the stop.
//
// Test Function: <nl>
// tdmperfStopValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile() convienence function <nl>
// 4) Call GetTime() and check results <nl>
// 5) Call Stop and check results <nl>
// 6) Call GetSegmentState and check resutls <nl>
// 7) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  04/24/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvStopValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;
	CtIDirectMusicPerformance 	*pwPerformance		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState2	= NULL;
	MUSIC_TIME					mt					= 1024;

	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)&pwSegmentState, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime() and check results
    // **********************************************************************
	hr = pwPerformance->GetTime( NULL, &mt );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call Stop and check results
    // **********************************************************************
	Sleep(2000);
	hr = pwPerformance->Stop(NULL, NULL, 0, 0);
    if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Stop ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 6) Call GetSegmentState and check resutls
    // **********************************************************************
	fnsLog(FYILOGLEVEL, TEXT("**** FYI:  WE EXPECT THIS TO RETURN DMUS_E_NOT_FOUND"));
	hr = pwPerformance->GetSegmentState( &pwSegmentState2, mt + 15000);
	if(DMUS_E_NOT_FOUND != hr)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->GetSegmentState ")
				TEXT("did not return correctly! (Expected DMUS_E_NOT_FOUND) -- (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;

}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::CloseDown()_Valid_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::CloseDown().
//		Call CloseDown without call to Stop of a playing Segment.
//
// Test Function: <nl>
// tdmperfvCloseDownValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object<nl>
// 3) Call PlayMidiFile() convienence function<nl>
// 4) Call CloseDown(), and make sure everything is ok <nl>
// 5) Call IsPlaying(Segment) and make sure it's not playing (returns error) <nl>
// 6) Call IsPlaying(SegmentState) and make sure it's not playing (returns error) <nl>
// 7) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//	04-24-1998	a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvCloseDownValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;
	CtIDirectMusicPerformance 	*pwPerformance		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState2	= NULL;
	MUSIC_TIME					mt					= 1024;

	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)&pwSegmentState, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call CloseDown and check results
    // **********************************************************************
	hr = pwPerformance->CloseDown();
    if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->CloseDown ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call IsPlaying(Segment) and check results - EXPECTS FAILURE
    // **********************************************************************
	hr = pwPerformance->IsPlaying(pwSegment, NULL);
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: WE EXPECT THIS TO FAIL!!! We've already called CloseDown()!"));
	if(hr !=DMUS_E_NO_MASTER_CLOCK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->IsPlaying ")
                TEXT("did not return correctly (expected DMUS_E_NO_MASTER_CLOCK) (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call IsPlaying(SegmentState) and check results - EXPECTS FAILURE
    // **********************************************************************
	hr = pwPerformance->IsPlaying(NULL, pwSegmentState);
	fnsLog(FYILOGLEVEL, TEXT("**** FYI: WE EXPECT THIS TO FAIL!!! We've already called CloseDown()!"));
	if(hr !=DMUS_E_NO_MASTER_CLOCK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->IsPlaying ")
                TEXT("did not return correctly (expected DMUS_E_NO_MASTER_CLOCK) (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegmentState2)
	{
		pwSegmentState2->Release();
		pwSegmentState2 = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;

}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AllocPMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AllocPMsg().
//		AllocPMSG for Note, Curve, Tempo, and MIDI, SendPMsg,  and check results.
//
// Test Function: <nl>
// tdmperfvAllocPMsgValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note, Curve, Tempo, and MIDI messages and check result <nl>
// 5) Set up pMSG's for Note, Curve, Tempo, and MIDI<nl>
// 6) Call SendPMsg for Note, Curve, Tempo, and MIDI, and check result <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//
//	The same test is used for tdmperfvAllocPMsgValidTest1() and tdmperfvSendPMsgValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvAllocPMsgValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	DMUS_CURVE_PMSG					*pCurve			= NULL;
	DMUS_TEMPO_PMSG					*pTempo			= NULL;
	DMUS_MIDI_PMSG					*pMidi			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.1) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pNote, \n"),
                TEXT("pNote == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.2) Call AllocPMsg on pCurve and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG), (DMUS_PMSG**)&pCurve );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pCurve was properly populated
	if(!pCurve)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pCurve, \n"),
                TEXT("pCurve == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.3) Call AllocPMsg on pTempo and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG), (DMUS_PMSG**)&pTempo );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pTempo was properly populated
	if(!pTempo)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pTempo, \n"),
                TEXT("pTempo == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.4) Call AllocPMsg on pMidi and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pMidi was properly populated
	if(!pMidi)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pMidi, \n"),
                TEXT("pMidi == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5.1) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.2) Set pCurve with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pCurve, sizeof(DMUS_CURVE_PMSG) );
	pCurve->bFlags			= 1;
	pCurve->mtDuration		= 1000;
	pCurve->mtOriginalStart	= 0;
	pCurve->mtResetDuration	= 100;
	pCurve->nStartValue		= 0;
	pCurve->nEndValue		= 1000;
	pCurve->nResetValue		= 50;
	pCurve->wMeasure		= 8;
	pCurve->nOffset			= 0;
	pCurve->bBeat			= 2;
	pCurve->bGrid			= 0;
	pCurve->bType			= DMUS_CURVET_CCCURVE;
	pCurve->bCurveShape		= DMUS_CURVES_EXP;
	pCurve->dwFlags			= DMUS_PMSGF_REFTIME;
	
    // **********************************************************************
    // 5.3) Set pTempo with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
	pTempo->dblTempo		= 100;
	pTempo->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.4) Set pMidi with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pMidi, sizeof(DMUS_MIDI_PMSG) );
	pMidi->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6.1) Call SendPMsg on pNote and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.2) Call SendPMsg on pCurve and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pCurve );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 6.3) Call SendPMsg on pTempo and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.4) Call SendPMsg on pMidi and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pMidi );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SendPMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SendPMsg().
//		AllocPMSG for Note, Curve, Tempo, and MIDI, SendPMsg,  and check results.
//
// Test Function: <nl>
// tdmperfvAllocPMsgValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note, Curve, Tempo, and MIDI messages and check result <nl>
// 5) Set up pMSG's for Note, Curve, Tempo, and MIDI<nl>
// 6) Call SendPMsg for Note, Curve, Tempo, and MIDI, and check result <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//
//	The same test is used for tdmperfvAllocPMsgValidTest1() and tdmperfvSendPMsgValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!!!!!!!!!!!uses tdmperfvAllocPMsgValidTest1 !!!!!!!!!!!!!!!!!!!!!!!!!




//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE JIMMO
//
// @topic IDirectMusicPerformance::SendPMsg()_Valid_Test |
//
// Description: <nl>
// This test creates an instance of the CTDMTestTool and attaches it to
// a PMsg.  That PMsg is then sent via a call to Perf->SendPMsg.
// After a short sleep, FreePMsg is called and the refcount of the test
// tool is verfied to have been decremented by one (from the call to
// FreePMsg).  In this case, the TestTool is not used in the same context
// as a DirectMusicTool.  It's used because it implements the IUnknown
// interface.<nl>
//
// Test Function: <nl>
// tdmperfvSendPMsgWithCOMToolTest<nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - DMUS_PMSG_<type><nl>
//  DWORD   dwParam2    - unused<nl>
//
// File : TDMPERFV.CPP
//
// Steps:<nl>
// 1) Initialize COM.<nl>
// 2) Create CtIDirectMusicPerformance object
// 3) Call Perf->Init<nl>
// 4) Create Test Tool -- which will be attached to PMsg<nl>
// 5) Performance->AllocPMsg and check results<nl>
// 6) Setup the PMSG and Call StampPMsg() then check results<nl>
// 7) Call Perf->SendPMsg with Test Tool attached in punkUser of PMsg<nl>
// 8) Call Perf->FreePMsg<nl>
// 9) Verify that the Object was released by the Performance->FreePMsg()<nl>
// 10) Release objects, CoUninitialize, and return results<nl>
//
// History:
//  09/11/1998 - jimmo - Created
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSendPMsgWithCOMToolTest(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD                       dwRes           = FNS_PASS;
    HRESULT                     hr              = S_OK;
    CtIDirectMusicPerformance   *pCtPerformance = NULL;
    CtIDirectMusicSegment       *pCtSegment     = NULL;
    CtIDirectMusicGraph         *pCtGraph       = NULL;
    IDirectMusicGraph           *pGraph         = NULL;
        
    //The pPMsgTool will just act as a COM object and be sent through the Performance by attaching
    //it to a PMsg and calling Perf::SendPMsg to pipe it along
    CTDMTestTool                *pPMsgTool      = NULL;

    //The pGraphTool will actually be added to the performance graph, and will be responsible for
    //Calling Perf::FreePMsg, from within it's ProcessPMsg function.
    CTDMTestTool                *pGraphTool     = NULL;
    
    DMUS_PMSG                   *pdmusPMSG      = NULL;

    int                         nRefCount       = 0;
    BOOL                        fFreePMsg       = TRUE;
    BOOL                        fAuto           = TRUE;;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: COM initialization failed! (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // X) Create CtSegment object
    // **********************************************************************
    hr = dmthLoadSegment(L"test.mid", &pCtSegment);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicSegment object creation "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // X) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pCtPerformance);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Call Perf->Init
    // **********************************************************************
    hr = pCtPerformance->Init(NULL, NULL, ghWnd);
    if ( FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->Init(NULL, NULL, ghWnd) "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
 

    fAuto = TRUE;
    hr = pCtPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pCtPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->AddPort(NULL) "
                "failed (%s == %08Xh)", dmthXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}


    // **********************************************************************
    // 4) Create Test Tool -- which will be attached to PMsg
    // **********************************************************************
    pPMsgTool = new CTDMTestTool();

    if (NULL == pPMsgTool)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: failed to create tool (out of memory?)");
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // ***********************************************************************
    // X) Create Test Tool -- which will be inserted into the Performance
    //    graph, and will call FreePMsg upon getting a DMUS_PMSGT_USER message
    // ***********************************************************************
    pGraphTool = new CTDMTestTool();

    if (NULL == pGraphTool)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: failed to create tool (out of memory?)");
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // X) Setup pGraphTool so it will do it's thing
    // **********************************************************************
    fFreePMsg = TRUE;
    pGraphTool->SetParam(GUID_TestToolFreePMsg, &fFreePMsg, sizeof(BOOL));
    pGraphTool->AddPMSGType(DMUS_PMSGT_USER);

    // **********************************************************************
    // 2) Create Graph Object
    // **********************************************************************
    hr = dmthCreateGraph(IID_IDirectMusicGraph, &pCtGraph);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // X) Get Real pointe to graph
    // **********************************************************************
    hr = pCtGraph->GetRealObjPtr( &pGraph );
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pCtGraph->GetRealObjPtr() "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    if (NULL == pGraph)
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pCtGraph->GetRealObjPtr() "
                "returned a NULL pGraph pointer");
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


    // **********************************************************************
    // X) Insert pGraphTool into the graph
    // **********************************************************************
    hr = pGraph->InsertTool( (IDirectMusicTool*)pGraphTool, NULL, 0, 0 );
    if(FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Graph->InsertTool "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


    // **********************************************************************
    // X) Set the Performance's Graph
    // **********************************************************************
    hr = pCtPerformance->SetGraph( pCtGraph );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->SetGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 5) Performance->AllocPMsg and check results
    // **********************************************************************
    hr = pCtPerformance->AllocPMsg( sizeof(DMUS_PMSG), &pdmusPMSG );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->AllocPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 6) Setup the PMSG and Call StampPMsg() then check results
    // **********************************************************************
    pdmusPMSG->dwType   = DMUS_PMSGT_USER; //which is a message the Unique Tool handles

    pdmusPMSG->dwFlags  = 0;   //Clear out the flags, so we know what we're setting
    pdmusPMSG->dwFlags  = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;

    pdmusPMSG->mtTime   = 1500;
    pdmusPMSG->punkUser = pPMsgTool;

    nRefCount = pPMsgTool->m_cRef;      //Store Ref Cound before Sending PMsg
    pPMsgTool->AddRef();                //Needed because it's going to be released by FreeMsg

    // **********************************************************************
    // X) Call Perf->PlaySegment
    // **********************************************************************
    hr = pCtPerformance->PlaySegment(pCtSegment, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Perf->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    Sleep(1000);    //Wait a second before sending message

    // **********************************************************************
    // X) Call Perf->SendPMsg with Test Tool attached in punkUser of PMsg
    // **********************************************************************
    hr = pCtPerformance->SendPMsg(pdmusPMSG);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Perf->SendPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


	// **********************************************************************
    // 7) Set Notification
    // **********************************************************************
	hr = dmthGetNotification(pCtPerformance, GUID_NOTIFICATION_SEGMENT, DMUS_NOTIFICATION_MUSICSTOPPED, 20000);	
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthGetNotification ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	pCtPerformance->Stop(NULL, NULL, 0, 0);

    // **********************************************************************
    // 9) Verify that the Object was released by the Performance->FreePMsg()
    //    that was called in the pGraphTool's ProcessPMsg function
    // **********************************************************************
    if (nRefCount != pPMsgTool->m_cRef)
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: Release not called on pPMsgTool");
        fnsLog(BUGLOGLEVEL, "     Expected RefCount:%d", nRefCount);
        fnsLog(BUGLOGLEVEL, "              RefCount:%d", pPMsgTool->m_cRef);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }


TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
    if(pCtPerformance)
    {
        pCtPerformance->Stop(NULL, NULL, 0, 0);
        pCtPerformance->CloseDown();
    }

    if (pPMsgTool)
    {
        pPMsgTool->Release();
        pPMsgTool = NULL;
    }

    if (pGraph)
    {
        pGraph->Release();
        pGraph = NULL;
    }

    if (pCtGraph)
    {
        pCtGraph->Release();
        pCtGraph = NULL;
    }
	if (pGraphTool)
    {
        pGraphTool->Release();
        pGraphTool = NULL;
    }

    if(pCtPerformance)
    {
        pCtPerformance->Release();
        pCtPerformance = NULL;
    }
	if(pCtSegment)
	{
		pCtSegment->Release();
		pCtSegment = NULL;
	}
    dmthCoUninitialize();   
    return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetBumperLength()_Valid_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::SetBumperLength().
//		Calls SetBumperLength of length 0, while Segment is being played.
//
// Test Function: <nl>
// tdmperfvSetBumperLengthValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call dmthPlayMidiFile convienence function <nl>
// 4) Call SetBumperLength and Test the function <nl>
// 5) Call GetBumperLength and Test the function <nl>
// 6) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//	The same test is used for tdmperfvGetBumperLengthValidTest1() and tdmperfvSetBumperLengthValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetBumperLengthValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	DWORD						dwSet			= 0;
	DWORD						dwGet           = 2000;
	
	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call dmthPlayMidiFile convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call SetBumperLength and Test the function
    // **********************************************************************
	hr = pwPerformance->SetBumperLength(dwSet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetBumperLength() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetBumperLength and Test the function
    // **********************************************************************
	hr = pwPerformance->GetBumperLength(&dwGet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetBumperLength() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that dwSet and dwGet are the same
	if(dwSet != dwGet)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetPrepareTime not set correctly, ")
                TEXT("dwSet == %08Xh)"),
				TEXT("dwGet == %08Xh)"),
                dwSet, dwGet);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(2000);

TEST_END:
    // **********************************************************************
    // 6) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}

//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetBumperLength()_Valid_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::GetBumperLength().
//		Calls GetBumperLength of length 0, while segment is being played.
//
// Test Function: <nl>
// tdmperfvSetBumperLengthValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call dmthPlayMidiFile convienence function <nl>
// 4) Call SetBumperLength and Test the function <nl>
// 5) Call GetBumperLength and Test the function <nl>
// 6) Call Performance->Stop <nl>
// 7) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//	The same test is used for tdmperfvGetBumperLengthValidTest1() and tdmperfvSetBumperLengthValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
// !!!!!!!!!!!! uses tdmperfvSetBumperLengthValidTest1 !!!!!!!!!!!!!!!!!!!!!


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetBumperLength()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetBumperLength().
//		Calls SetBumperLength of length 50000, makes sure the PlaySegment doe not time out.
//
// Test Function: <nl>
// tdmperfvSetBumperLengthValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetBumperLength and Test the function <nl>
// 4) Call dmthPlayMidiFile convienence function <nl>
// 5) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetBumperLengthValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	DWORD						dwSet			= 50000000;
	
	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Init and AddPort
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	// **********************************************************************
    // 5) Call SetBumperLength and Test the function
    // **********************************************************************
	hr = pwPerformance->SetBumperLength(dwSet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetBumperLength() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Play the segment
    // **********************************************************************
	fnsLog(FYILOGLEVEL, TEXT("**** FYI:  Expecting this to time out.  If not, SetBumperLength did not work correctly!!!!!"));
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Set a notification for a measure/beat.  If it times out, we pass
    // **********************************************************************
	Sleep(2000);
	hr = pwPerformance->IsPlaying(pwSegment, NULL);
	if(FAILED(hr)) // means that the segment is playing, which means that the bumper length did not 
		// delay the start of the segment
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->IsPlaying ")
                TEXT("did not fail (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 8) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::FreePMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::FreePMsg().
//		AllocPMSG for Note, Curve, Tempo, and MIDI, FreePMsg,  and check results.
//
// Test Function: <nl>
// tdmperfvAllocPMsgValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note, Curve, Tempo, and MIDI messages and check result <nl>
// 5) Set up pMSG's for Note, Curve, Tempo, and MIDI<nl>
// 6) Call FreePMsg for Note, Curve, Tempo, and MIDI, and check result <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvFreePMsgValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	DMUS_CURVE_PMSG					*pCurve			= NULL;
	DMUS_TEMPO_PMSG					*pTempo			= NULL;
	DMUS_MIDI_PMSG					*pMidi			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.1) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pNote correctly, \n"),
                TEXT("pNote == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.2) Call AllocPMsg on pCurve and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG), (DMUS_PMSG**)&pCurve );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pCurve was properly populated
	if(!pCurve)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pCurve correctly, \n"),
                TEXT("pCurve == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.3) Call AllocPMsg on pTempo and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG), (DMUS_PMSG**)&pTempo );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pTempo was properly populated
	if(!pTempo)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pTempo correctly, \n"),
                TEXT("pTempo == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.4) Call AllocPMsg on pCurve and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pCurve was properly populated
	if(!pMidi)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pMidi correctly, \n"),
                TEXT("pMidi == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5.1) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.2) Set pCurve with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pCurve, sizeof(DMUS_CURVE_PMSG) );
	pCurve->bFlags			= 1;
	pCurve->mtDuration		= 1000;
	pCurve->mtOriginalStart	= 0;
	pCurve->mtResetDuration	= 100;
	pCurve->nStartValue		= 0;
	pCurve->nEndValue		= 1000;
	pCurve->nResetValue		= 50;
	pCurve->wMeasure		= 8;
	pCurve->nOffset			= 0;
	pCurve->bBeat			= 2;
	pCurve->bGrid			= 0;
	pCurve->bType			= DMUS_CURVET_CCCURVE;
	pCurve->bCurveShape		= DMUS_CURVES_EXP;
	pCurve->dwFlags			= DMUS_PMSGF_REFTIME;
	
    // **********************************************************************
    // 5.3) Set pTempo with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
	pTempo->dblTempo		= 100;
	pTempo->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.4) Set pMidi with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pMidi, sizeof(DMUS_MIDI_PMSG) );
	pMidi->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6.1) Call FreePMsg on pNote and check results
    // **********************************************************************	
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.2) Call FreePMsg on pCurve and check results
    // **********************************************************************	
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pCurve );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 6.3) Call FreePMsg on pTempo and check results
    // **********************************************************************	
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pTempo );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.4) Call FreePMsg on pMidi and check results
    // **********************************************************************	
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pMidi );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RemovePort()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::RemovePort().
//		Remove a port that is currently playing.
//
// Test Function: <nl>
// tdmperfvRemovePortValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) dmthCoInitialize <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Get the Segment object <nl>
// 4) Init the performance <nl>
// 5) Create a SynthPort <nl>
// 6) Add a port to our two performances <nl>
// 7) Call PlaySegment and check results <nl>
// 8) Make sure the segment is playing <nl>
// 9) RemovePort and check results <nl>
// 10) Release objects, CoUninitilalize, and return results <nl>
//
// History: <nl>
//  07/29/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvRemovePortValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD                       dwRes			= FNS_PASS;
    HRESULT                     hr				= S_OK;
    CtIDirectMusicPerformance   *pwPerformance	= NULL;
    CtIDirectMusicSegment       *pwSegment		= NULL;
    CtIDirectMusicPort          *pwPort			= NULL;
    CtIDirectMusic              *pwDM			= NULL;
    DMUS_PORTPARAMS             dmusPortParams;
    DWORD                       dwCounter       = 0;
    DWORD                       dwTimeOutValue  = 20;
    GUID                        guidSink;

	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: COM initialization failed! (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Load the segment
    // **********************************************************************
    hr = dmthLoadSegment(pSegmentFile, &pwSegment);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 4) Init the performance
    // **********************************************************************
    hr = pwPerformance->Init(&pwDM,NULL,ghWnd);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->Init "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Create a SynthPort
    // **********************************************************************
    ZeroMemory( &dmusPortParams, sizeof(DMUS_PORTPARAMS) );
    dmusPortParams.dwSize          = sizeof(DMUS_PORTPARAMS);  
    dmusPortParams.dwChannelGroups = 5; // create 5 channel groups on the port
    dmusPortParams.dwValidParams   = DMUS_PORTPARAMS_CHANNELGROUPS;

    ZeroMemory( &guidSink, sizeof(GUID) );

    hr = pwDM->CreatePort(
		CLSID_DirectMusicSynth, 
        &dmusPortParams, 
        &pwPort, 
        NULL );
    if ( FAILED(hr) )
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwDM->CreatePort "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 6) Add a port to our two performances
    // **********************************************************************
    hr = pwPerformance->AddPort(pwPort);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->AddPort(NULL) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
    pwPerformance->AssignPChannelBlock( 0, pwPort, 1 );

    // **********************************************************************
    // 7) Call PlaySegment and check results
    // **********************************************************************
    hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 8) Wait for IsPlaying to return or time out
    // **********************************************************************
    dwCounter = 0;
    while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)  
    {
        Sleep(1000);
        if(dwCounter++ > dwTimeOutValue)
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegment() timed out"
                "IsPlaying did not return the Segment (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }
    }

    // **********************************************************************
    // 9) Call RemovePort and check results
    // **********************************************************************
	hr = pwPerformance->RemovePort(pwPort);
    if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance->RemovePort "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }
	Sleep(1000);

TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
    if(pwPerformance)
    {
        pwPerformance->Stop(NULL, NULL, 0, 0);
        pwPerformance->CloseDown();
        pwPerformance->Release();
        pwPerformance = NULL;
    }
    if(pwSegment)
    {
        pwSegment->Release();
        pwSegment = NULL;
    }
    if(pwPort)
    {
        pwPort->Release();
        pwPort = NULL;
    }
    if(pwDM)
    {
        pwDM->Release();
        pwDM = NULL;
    }
	dmthCoUninitialize();   
    return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::DownloadInstrumentTest()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::DownloadInstrument(). <nl>
//			Checks NoteRange information when passing in NULL. <nl>
//
// Test Function: <nl>
// tdmperfvDownloadInstrumentValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create CtIDirectMusicLoader object<nl>
// 4) Get the Object from the loader<nl>
// 5) Do QI on the object for the collection <nl>
// 6) Create a wrapped Instrument Collection <nl>
// 7) Create a wrapper for IDirectMusicCollection Object <nl>
// 8) Get an instrument collection and release the collection <nl>
// 9) Call Init(NULL) and AddPort(NULL) to set everything up for downloading <nl>
// 10) Set DMUS_NoteRanges array information <nl>
// 11) Call Download and check results <nl>
// 12) Release object, CoUninitialize, and return results <nl>
//
// History: <nl>
//  05/08/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvDownloadInstrumentValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD								dwRes			= FNS_PASS;
	HRESULT								hr				= S_OK;
	CtIDirectMusicLoader				*pIDMLoader		= NULL;
	CtIDirectMusicCollection			*pwCollection	= NULL;
	CtIDirectMusicInstrument			*pwInstrument	= NULL;
	CtIDirectMusicDownloadedInstrument  *pwDownloaded	= NULL;
	CtIDirectMusicPerformance			*pwPerformance	= NULL;
	CtIDirectMusicPort					*pwPort			= NULL;
	DMUS_OBJECTDESC						desc; 
	DMUS_NOTERANGE						pNoteRanges[3];
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize											= sizeof(DMUS_OBJECTDESC);
	DWORD								dwGroup			= 0;
	DWORD								dwMChannel		= 0;
	WCHAR								*pDLS			= (WCHAR*)dwParam1;

	dmthSetPath(NULL);
	WCHAR								*wchPath		= gwszMediaPath;
	DWORD								dwPatch			= (DWORD)dwParam2;	

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicLoader object 
    // **********************************************************************	
	hr = dmthCreateLoader(IID_IDirectMusicLoader,&pIDMLoader);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicLoader object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Get the Object from the loader
    // **********************************************************************	
	hr = pIDMLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wchPath, FALSE);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->SetSeachDirectory(media directory) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	desc.guidClass = CLSID_DirectMusicCollection;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME );
	wcscpy( desc.wszFileName, pDLS);

	hr = pIDMLoader->GetObject(&desc,CTIID_IDirectMusicCollection,(void**)&pwCollection);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 8) Get an instrument collection and release the collection
    // **********************************************************************	
	hr = pwCollection->GetInstrument( dwPatch, &pwInstrument );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Collection->GetInstrument ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Call Init(NULL) and AddPort(NULL) 
    // **********************************************************************	
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 10) Set NoteRange information
    // **********************************************************************	
    ZeroMemory(&pNoteRanges, sizeof(DMUS_NOTERANGE));
	  	pNoteRanges[0].dwLowNote	= 0;
		pNoteRanges[0].dwHighNote	= 100;
		pNoteRanges[1].dwLowNote	= 110;
		pNoteRanges[1].dwHighNote	= 115;
		pNoteRanges[2].dwLowNote	= 116;
		pNoteRanges[2].dwHighNote	= 127;
    
	// **********************************************************************
    // 11) Call Download and check results
    // **********************************************************************	
	hr = pwPerformance->DownloadInstrument( pwInstrument, 
											0, 
											&pwDownloaded, 
											&pNoteRanges[1],
											1,
											&pwPort, 
											&dwGroup,
											&dwMChannel );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->DownloadInstrument ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if(pwDownloaded)
	{
		if(pwPort)
		{
			hr = pwPort->UnloadInstrument(pwDownloaded);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, 
					"!!!! BUG: pwPort->UnloadInstrument() failed! "
					"(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
				dwRes = FNS_FAIL;
			}
			pwPort->Release();
			pwPort = NULL;
		}
		pwDownloaded->Release();
		pwDownloaded = NULL;
	}

	// Pass NULL, set the dwNumNoteRanges != 0, expect FAIL
	hr = pwPerformance->DownloadInstrument( pwInstrument, 
											0, 
											&pwDownloaded, 
											NULL,
											3,
											&pwPort, 
											&dwGroup,
											&dwMChannel );
	if(SUCCEEDED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->DownloadInstrument (Passing NULL) ")
                TEXT("did not failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Make sure it handles setting dwNumNoteRanges == 0
	hr = pwPerformance->DownloadInstrument( pwInstrument, 
											0, 
											&pwDownloaded, 
											&pNoteRanges[2],
											0,
											&pwPort, 
											&dwGroup,
											&dwMChannel );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->DownloadInstrument ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 12) Release object, CoUninitialize, and return results
    // **********************************************************************
	if(pwDownloaded)
	{
		if(pwPort)
		{
			hr = pwPort->UnloadInstrument(pwDownloaded);
			if(FAILED(hr))
			{
				fnsLog(BUGLOGLEVEL, 
					"!!!! BUG: pwPort->UnloadInstrument() failed! "
					"(%s == %08Xh)",tdmXlatHRESULT(hr), hr);
				dwRes = FNS_FAIL;
			}
			pwPort->Release();
			pwPort = NULL;
		}
		pwDownloaded->Release();
		pwDownloaded = NULL;
	}
	if(pwCollection)
	{
		pwCollection->Release();
        pwCollection = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if( pIDMLoader )
	{
		pIDMLoader->Release();
        pIDMLoader = NULL;
	}
	if( pwPort )
	{
		pwPort->Release();
        pwPort = NULL;
	}
	if( pwDownloaded )
	{
		pwDownloaded->Release();
        pwDownloaded = NULL;
	}
	if( pwInstrument )
	{
		pwInstrument->Release();
        pwInstrument = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test | <nl>
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment().
//		Verifies that SegStates are released when segment is done playing. <nl>
//
// Test Function: <nl>
// tdmperfPlaySegmentValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) AddRef and Release SegState to get a pre-play value <nl>
// 3) Create CtIDirectMusicPerformance object <nl>
// 4) Call PlayMidiFile() convienence function <nl>
// 5) Make sure that Segment is done playing with IsPlaying loop <nl>
// 6) AddRef and Release SegState to get a post-play value <nl>
// 7) Compare pre-play and post-play values <nl>
// 8) Release objects, CoUninitialize, and return results<nl>
//
// History: <nl>
//  05/11/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;
	CtIDirectMusicPerformance 	*pwPerformance		= NULL;
	int							dwPlayingRef		= 0;
	int							dwAfterRef			= 0;
	int							counter				= 0;
	int							TimeOutValue		= 30;

	WCHAR						*pMidiFile			= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)&pwSegmentState, TRUE, pMidiFile);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(hr = pwPerformance->IsPlaying(pwSegment, NULL) == S_OK)
	{
	
		// **********************************************************************
		// 4) AddRef and Release SegState to get a pre-play value <nl>
		// **********************************************************************
		Sleep(1000);
		pwSegmentState->AddRef();
		dwPlayingRef = pwSegmentState->Release();
	}
	else
	{
		// It is already done playing, we'll abort
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  Unable to get a trace on the state of the segment during play"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Make sure that SegmentState is done by IsPlaying to return S_FALSE
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying((pwSegment), NULL)) != S_FALSE)	
	{
		Sleep(1000);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out waiting for segment to finish.\n")
				TEXT("IsPlaying did not return S_FALSE (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}

	// **********************************************************************
    // 6) AddRef and Release SegState to get a post-play value
    // **********************************************************************
	Sleep(10000);	//The performance "casually" releases SegmentStates after they are no longer needed.
	pwSegmentState->AddRef(); 
	dwAfterRef = pwSegmentState->Release();
	Sleep(2000);
	// **********************************************************************
    // 7) Compare dwInitialRef and dwAfterRef, make sure they are the same
    // **********************************************************************
	if (dwPlayingRef <= dwAfterRef)		//Checking to make sure that it loses at least 1
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: SegmentState was not released when it finished playing! ")
			TEXT("dwAfterRef   == %lu\n")
			TEXT("dwPlayingRef == %lu\n"),
			dwAfterRef, dwPlayingRef);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 8) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;

}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment(). <nl>
//			Checks to make sure that files play properly from the middle . <nl>
//			NOTE:  THIS IS A LISTENING TEST!  YOU SHOULD HEAR A D! <nl><nl>
//
// Test Function: <nl>
// tdmperfvPlaySegmentValidTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create a Loader object <nl>
// 4) Loader->EnableCache <nl>
// 5) Set the search directory <nl>
// 6) Load the segment object <nl>
// 7) QI for the Segment <nl>
// 8) Set up the Segment object <nl>
// 9) Call Init Test class on the object <nl> 
// 10) Add a Port <nl>
// 11) Call Segment->SetStartPoint so that it doesn't start at the beginning <nl>
// 12) Play the segment <nl>
// 13) Release objects, Co-Uninitialize, and return result <nl>
//
// History:
//  04/30/1998 - a-llucar - Created
//
//  Note - Same test is used for both GetLoopPointsValidTest1 and SetLoopPointsValidTest1
// @index topic | IDIRECTMUSICSEGMENT_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicLoader		*pwLoader		= NULL;
	IDirectMusicSegment			*pSegment		= NULL;
	CtIDirectMusicObject		*pwObject		= NULL;
    LPWSTR                      wszFilename     = L"PitchB.mid"; 
    LPWSTR                      wszExt          = L"mid";
	dmthSetPath(L"PitchB.mid");
	char						*chPath			= gszMediaPath;
	int							counter			= 0;
	int							SleepTime		= 1000;
	int							TimeOutValue	= 10;
	MUSIC_TIME					mtLength		= 0;
	MUSIC_TIME					mtStart			= 0;
	DMUS_OBJECTDESC				desc; 

//    dmthBeginMessage("You should hear a D");
	// **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicLoader object 
    // **********************************************************************
	hr = dmthCreateLoader(IID_IDirectMusicLoader, &pwLoader);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicLoader object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 4) Loader->EnableCache(GUID_DirectMusicAllTypes)
    // **********************************************************************
	hr = pwLoader->EnableCache(GUID_DirectMusicAllTypes, TRUE);
	if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->EnableCache ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

	// **********************************************************************
    // 5) SetSearchDirectory
    // **********************************************************************
	ZeroMemory(&desc, sizeof(desc));

	desc.dwSize = sizeof(DMUS_OBJECTDESC);
	desc.guidClass = CLSID_DirectMusicSegment;
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH);

	MultiByteToWideChar(CP_ACP, NULL, (LPCSTR)chPath, -1, desc.wszFileName, DMUS_MAX_FILENAME);
	
	// **********************************************************************
    // 6) Get the Segment object
    // **********************************************************************
	hr = pwLoader->GetObject(&pwObject, &desc);
	if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Loader->GetObject(pSegment) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 7) QueryInterface for the Segment object
    // **********************************************************************
	hr = pwObject->QueryInterface(IID_IDirectMusicSegment, (void **)&pSegment);
	if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: QueryInterface for pSegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 8) Set up a wrapped Segment object
    // **********************************************************************
	pwSegment = new CtIDirectMusicSegment;
	if (!pwSegment)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment did not get set(pwSegment == NULL) "));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Call InitTestClass on the wrapped segment
    // **********************************************************************
	hr = pwSegment->InitTestClass(pSegment);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->InitTestClass ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	// **********************************************************************
    // 10) Init and AddPort
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 11) Set the start point to other than the beginning
    // **********************************************************************	
	hr = pwSegment->GetLength(&mtLength);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->GetLength ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// make sure that mtLength is set to something other than 0
	if(!mtLength)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: mtLength was not set (mtLength == 0)"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	mtStart = (mtLength /2); //Half the length of the segment

	hr = pwSegment->SetStartPoint(mtStart);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetStartPoint ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	    
    // **********************************************************************
    // 12) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 13) Wait for IsPlaying to return favorably (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!! BUG: PlaySegment() timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
Sleep(3000);
//	dwRes = dmthEndMessage("Did it sound correct?");	

TEST_END:
    // **********************************************************************
    // 16) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwObject)
	{
		pwObject->Release();
		pwObject = NULL;
	}
	if(pSegment)
	{
		pSegment->Release();
		pSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::FreePMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::FreePMsg().
//		Frees a PMSG that's already been Freed, Expects DMUS_E_CANNOT_FREE <nl>
//
// Test Function: <nl>
// tdmperfvFreePMsgValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note <nl>
// 5) Set up pMSG's for Note <nl>
// 6) Call FreePMsg for Note twice, make sure it returns E_FAIL the second time <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvFreePMsgValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pNote correctly, \n"),
                TEXT("pNote == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6) Call FreePMsg on pNote and check results
    // **********************************************************************	
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pNote) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Call FreePMsg again, expect an E_FAIL
	hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pNote );
	if(hr != DMUS_E_CANNOT_FREE)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pNote) ")
                TEXT("did not return DMUS_E_CANNOT_FREE second time called. (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::FreePMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::FreePMsg().
//		Frees a PMSG that's already been sent, Expects DMUS_E_CANNOT_FREE <nl>
//
// Test Function: <nl>
// tdmperfvFreePMsgValidTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note <nl>
// 5) Set up pMSG's for Note <nl>
// 6) Call SendPMsg for the note <nl>
// 6) Call FreePMsg for Note, make sure it returns E_FAIL <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvFreePMsgValidTest3(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->AllocPMsg(pNote) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AllocPMsg did not properly populate pNote correctly, \n"),
                TEXT("pNote == NULL"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;


    // **********************************************************************
    // 6) Call SendPMsg on pNote and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->SendPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call FreePMsg on pNote and check results
    // **********************************************************************	
	if( fnsGetMetric(FNSMETRIC_STRESS) )  //commented out by JJ
	{
		fnsLog(FYILOGLEVEL, TEXT("---- FYI: PMSG NOT FREED -- BY-DESIGN -- WHEN RUNNING IN STRESS"));
	}
	else
	{
		hr = pwPerformance->FreePMsg( (DMUS_PMSG*)pNote );
		if(hr != DMUS_E_CANNOT_FREE)
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->FreePMsg(pNote) ")
					TEXT("EXPECTED DMUS_E_CANNOT_FREE (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetSegmentState()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetSegmentState().
//			Get a SegmentState that's set way into the future <nl>
//
// Test Function: <nl>
// tdmperfvGetSegmentStateValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object<nl>
// 3) Get the Segment object <nl>
// 4) Add the port <nl>
// 5) Call GetTime to get the current time and check results <nl>
// 6) Call PlaySegment way into the future and check results <nl>
// 7) Call ReferenceToMusicTime and check results <nl>
// 8) Call GetSegmentState way in the future <nl>
// 9) Release objects, CoUninitilalize, and return results <nl>
//
// History: <nl>
//  05/18/1998 - a-llucar - created<nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetSegmentStateValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	HRESULT						hr				= E_NOTIMPL;
	DWORD						dwRes			= FNS_PASS;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState	= NULL;
	REFERENCE_TIME				rt				= 0;
	MUSIC_TIME					mt				= 0;

	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Init and AddPort
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetTime to get the current time and check results
    // **********************************************************************
	hr = pwPerformance->GetTime(&rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	rt = rt + 100000000;

    // **********************************************************************
    // 6) Call PlaySegment way into the future and check results
    // **********************************************************************
	// Set PlaySegment to play at time 1 billion after now
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT | DMUS_SEGF_REFTIME, rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Call ReferenceToMusicTime and check results
    // **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime(rt, &mt);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 8) Call GetSegmentState way in the future
    // **********************************************************************
	hr = pwPerformance->GetSegmentState(&pwSegmentState, mt);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->GetSegmentState(way in the future) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(5000);
		
TEST_END:
    // **********************************************************************
    // 9) Release objects, CoUninitilalize, and return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthReleaseSegmentState(pwSegmentState);
	dmthCoUninitialize();
	return dwRes; 
} 


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment().
//			Play a segment that's set way into the future <nl>
//
// Test Function: <nl>
// tdmperfvPlaySegmentValidTest4 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object<nl>
// 3) Create CtIDirectMusicLoader object <nl>
// 4) Loader->EnableCache(GUID_DirectMusicAllTypes) <nl>
// 5) SetSearchDirectory <nl>
// 6) Get the Segment object <nl>
// 7) Add the port <nl>
// 8) Call GetTime to get the current time and check results <nl>
// 9) Call PlaySegment way into the future and check results <nl>
// 10) Release objects, CoUninitilalize, and return results <nl>
//
// History: <nl>
//  05/18/1998 - a-llucar - created <nl>
//
//		NOTE:  This is a listening test.  There should be a substantial pause before it starts playing! <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest4(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	HRESULT						hr				= E_NOTIMPL;
	DWORD						dwRes			= FNS_PASS;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusic				*pwMusic		= NULL;
	REFERENCE_TIME				rt				= 0;
	MUSIC_TIME					mt				= 0;

	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 7) Init and AddPort
    // **********************************************************************		
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); 
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 8) Call GetTime to get the current time and check results
    // **********************************************************************
	hr = pwPerformance->GetTime(&rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	rt = rt + 50000000;

    // **********************************************************************
    // 9) Call PlaySegment way into the future and check results
    // **********************************************************************
	// Set PlaySegment to play at time 1 billion after now
	hr = pwPerformance->PlaySegment((pwSegment), DMUS_SEGF_BEAT | DMUS_SEGF_REFTIME, rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	Sleep(10000);	
TEST_END:

    // **********************************************************************
    // 10) Release objects, CoUninitilalize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();
	return dwRes; 
} 


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Invalidate()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Invalidate(). <nl>
//		Tests dwFlags, able to pass any flag through app.cpp <nl>
//
// Test Function: <nl>
// tdmperfvInvalidateValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwFlags     - DMUS_SEGF_FLAGS <nl>
//	DWORD   mtTime      - Time to flush at <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call Invalidate passing DMUS_SEGF_FLAGS from app.cpp <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  01/14/1998 - markburt - created <nl>
//  03/23/1998 - a-llucar - clean up, logging installed, autodoc <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvInvalidateValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwFlags, LPARAM mtTime)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call Invalidate and check results
    // **********************************************************************
	hr = pwPerformance->Invalidate((MUSIC_TIME)mtTime, (DWORD)dwFlags);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->Invalidate "));
        fnsLog(BUGLOGLEVEL, TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		fnsLog(BUGLOGLEVEL,	TEXT("mtTime  == %lu\n"), mtTime);
		fnsLog(BUGLOGLEVEL,	TEXT("dwFlags == %08Xh\n"), dwFlags);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUnInitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetSegmentState()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetSegmentState().
//		Calls GetSegmentState while no segment is playing.  <nl>
//		Expects descriptive fail message.
//
// Test Function: <nl>
// tdmperfvGetSegmentStateValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PlayMidiFile() convienence function <nl>
// 4) Wait for IsPlaying to return S_FALSE (or time out) <nl>
// 5) Call GetSegmentState on Segment that's done playing <nl>
// 6) Release objects, dmthCoUninitialize, and return results <nl>
//
// History: <nl>
//  06/10/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetSegmentStateValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	CtIDirectMusicSegment			*pwSegment		= NULL;
	CtIDirectMusicSegmentState		*pwSegmentState	= NULL;
	int								counter			= 0;
	int								SleepTime		= 1000;
	int								TimeOutValue	= 15;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)&pwSegmentState, TRUE, NULL);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Wait for IsPlaying to return S_FALSE (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying((pwSegment), NULL)) != S_FALSE)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() did not time out\n")
				TEXT("IsPlaying continued playing the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}

    // **********************************************************************
    // 5) GetSegmentState on Segment that's done playing
    // **********************************************************************
	if (pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	hr = pwPerformance->GetSegmentState(&pwSegmentState, 1000000);
	if(hr != DMUS_E_NOT_FOUND)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetSegmentState ")
                TEXT("did not return correctly (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoInitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}	// End tdmperfvGetSegmentStateValidTest2()


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Stop()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Stop().
//			Stop a segment that's cued to play in the future <nl>
//
// Test Function: <nl>
// tdmperfvStopValidTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object<nl>
// 3) Get the Segment object <nl>
// 4) Add the port and Init <nl>
// 5) Call GetTime to get the current time and check results <nl>
// 6) Call PlaySegment way into the future and check results <nl>
// 7) Call Stop on the segment state that is going to play <nl>
// 8) Release objects, CoUninitilalize, and return results <nl>
//
// History: <nl>
//  06/10/1998 - a-llucar - created <nl>
//
//		NOTE:  This is a listening test.  YOU SHOULD HEAR NOTHING! <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvStopValidTest3(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	HRESULT						hr				= E_NOTIMPL;
	DWORD						dwRes			= FNS_PASS;
	IDirectMusicSegment			*pSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicLoader		*pwLoader		= NULL;
	CtIDirectMusicObject		*pwObject		= NULL;
	CtIDirectMusic				*pwMusic		= NULL;
	REFERENCE_TIME				rt				= 0;
	MUSIC_TIME					mt				= 0;

	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Init and AddPort
    // **********************************************************************		
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); 
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetTime to get the current time and check results
    // **********************************************************************
	hr = pwPerformance->GetTime(&rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	rt = rt + 80000000;

    // **********************************************************************
    // 6) Call PlaySegment way into the future and check results
    // **********************************************************************
	// Set PlaySegment to play at way into the future
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT | DMUS_SEGF_REFTIME, rt, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Call Stop on the segment that hasn't started playing yet
    // **********************************************************************
	hr = pwPerformance->Stop(NULL, NULL, 0, 0);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->Stop ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
	Sleep(10000);	
TEST_END:

    // **********************************************************************
    // 8) Release objects, CoUninitilalize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwLoader)
	{
		pwLoader->Release();
		pwLoader = NULL;
	}
	if(pSegment)
	{
		pSegment->Release();
		pSegment = NULL;
	}
	if(pwObject)
	{
		pwObject->Release();
		pwObject = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();
	return dwRes; 
} 


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetParam()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetParam() <nl>
//			Change the tempo of a Performance that is playing <nl>
//
// Test Function: <nl>
// tdmperfvSetParamValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an CtIDirectMusicLoader object <nl>
// 4) Enable cache on the loader <nl>
// 5) Load a Segment object <nl>
// 6) Call GetTrack on a Tempo object <nl>
// 7) Call SetParam to set the Tempo object <nl>
// 8) Call GetParam, and make sure that the tempo changed <nl>
// 9) Cleanup objects, uninitialize COM, and return test result <nl>
//
// History:
//  05/15/1998 - a-llucar - created <nl>
//
//	NOTE:  The same test is used for SetParamValidTest1 and GetParamValidTest1 <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetParamValidTest1(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicTrack			*pwTrack		= NULL;

	int							counter			= 0;
	int							SleepTime		= 1000;
	int							TimeOutValue	= 10;
	GUID						guid			= GUID_TempoParam;
	DMUS_TEMPO_PARAM			dmtp;
	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;
	char						*chPath			= gszMediaPath;
	WCHAR						*wchPath		= gwszBasePath;
	dmthSetPath(NULL);
	MUSIC_TIME					mt				= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create IDirectMusicTempoTrack object 
    // **********************************************************************	
	hr = dmthCreateTrack(CLSID_DirectMusicTempoTrack, IID_IDirectMusicTrack, &pwTrack);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate TempoTrack failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// **********************************************************************
    // 6) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 7) Init(NULL) and AddPort(NULL)
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	pwSegment->SetRepeats(5);

    // **********************************************************************
	// 8) Set dmtp with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( &dmtp, sizeof(dmtp) );
	dmtp.dblTempo = 300;

	// **********************************************************************
    // 10) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time Before = %ld"), mt);	

   	// **********************************************************************
    // 9) Call SetParam, check the results 
    // **********************************************************************
	hr = pwPerformance->SetParam(guid, 0xffffffff, 0, mt + 4000, (void*)&dmtp); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

	hr = pwPerformance->Invalidate(0, 0);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  Performance->Invalidate ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time After = %ld"), mt);	

   	// **********************************************************************
    // 10) Call GetParam, check the results 
    // **********************************************************************
	hr = pwPerformance->GetParam(guid, 0xffffffff, 0, mt + 2000, 0, (void*)&dmtp); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

    // **********************************************************************
    // 11) Wait for IsPlaying to return favorably (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
Sleep(10000);
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time After = %ld"), mt);	

TEST_END:
    // **********************************************************************
    // 12) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwTrack)
	{
		pwTrack->Release();
		pwTrack = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetParam()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetParam() <nl>
//			Change the tempo of a Performance that is playing <nl>
//
// Test Function: <nl>
// tdmsegvSetParamValidTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load a Segment object <nl>
// 4) Call GetTrack on a Tempo object <nl>
// 5) Call SetParam to set the Tempo object <nl>
// 6) Call GetParam, and make sure that the tempo changed <nl>
// 7) Cleanup objects, uninitialize COM, and return test result <nl>
//
// History:
//  08/20/1998 - a-llucar - created <nl>
//
//	NOTE:  The same test is used for SetParamValidTest1 and GetParamValidTest1 <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetParamValidTest3(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;
	
	MUSIC_TIME					mt				= 0;
	GUID						guid			= GUID_TimeSignature;
	DMUS_IO_TIMESIGNATURE_ITEM	pTempo;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Set up the performance to play
    // **********************************************************************
	hr = dmthPrePlay(&pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
 
	// **********************************************************************
    // 5) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time Before = %ld"), mt);	

   	// **********************************************************************
    // 6) Call GetParam, check the results 
    // **********************************************************************
	hr = pwSegment->GetParam(guid, 0xffffffff, 0, mt + 2000, 0, (void*)&pTempo); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   
	if((!pTempo.bBeatsPerMeasure) || (!pTempo.bBeat))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetParam ")
				TEXT("failed (did not populate BPM's or Beats)"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

	fnsLog(FYILOGLEVEL, "TimeSignature == %i / %i", pTempo.bBeatsPerMeasure, pTempo.bBeat);
	
   	// **********************************************************************
    // 7) GetNotification that shows we're playing
    // **********************************************************************
	hr = dmthGetNotification(pwPerformance, GUID_NOTIFICATION_MEASUREANDBEAT, DMUS_NOTIFICATION_MEASUREBEAT, 2000);	
	if (FAILED(hr)) 
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthGetNotification ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
		
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time After = %ld"), mt);	

TEST_END:
    // **********************************************************************
    // 8) Release objects, CoUninitialize, and return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGlobalParam()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetGlobalParam(). <nl>
//		Passes all different types of guids.
//
// Test Function: <nl>
// tdmperfvGetGlobalParamValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetGlobalParam, check results<nl>
// 4) Call GetGlobalParam, check results (make sure dw and dw2 are equal) <nl>
// 5) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//	06/25/1998 - a-llucar - created
//	07/21/1998 - a-llucar - changed it so that we use the Array instead of dwParam1
//
//	Note - GetGlobalParam() and SetGlobalParam() both use the same test.
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetGlobalParamValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	DWORD						dw				= 53;
	DWORD						dw2				= 0;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	int							i				= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call SetGlobalParam, check results
    // **********************************************************************
	for (i = 0; i < sizeof(AllDMGuids)/sizeof(GUID*); i++)
	{
		hr = pwPerformance->SetGlobalParam( *AllDMGuids[i], (void*)&dw, sizeof(AllDMGuids[i]));
		if(FAILED(hr))
		{
	        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
	                TEXT("failed (%s == %08Xh)"),
	                tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	    // **********************************************************************
	    // 4) Call GetGlobalParam, check results
	    // **********************************************************************
		hr = pwPerformance->GetGlobalParam( *AllDMGuids[i], (void*)&dw2, sizeof(AllDMGuids[i]));
		if(FAILED(hr))
		{
	        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam ")
	                TEXT("failed (%s == %08Xh)"),
	                tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
		// Check to make sure that the DWORD was properly populated
		if(dw != dw2)
		{
	        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam\n "));
			fnsLog(BUGLOGLEVEL, TEXT("pData was not properly set"));
	        fnsLog(BUGLOGLEVEL, TEXT("Expected dw  == %ld"), dw);
			fnsLog(BUGLOGLEVEL,	TEXT("Received dw2 == %ld"), dw2);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}	
	}

TEST_END:
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment().
//		Creates two ports, and calls primary and secondary segments
//
// Test Function: <nl>
// tdmperfvPlaySegmentValidTest5 <nl>
//
// Parameters: <nl>
//  BOOL    fUseNULL    - pass NULL or BOGUS <nl>
//  BOOL    fParamNum	- Which Parameter to test <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - Expected HRESULT <nl>
//
// File : TDMPERFI.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object (wrapped IDMPerformance object) <nl>
// 3) Load a Segment Object <nl>
// 4) Set up Performance to play <nl>
// 5) Call PlaySegment <nl>
// 6) Call Stop passing NULL or BOGUS parameter, check results <nl> 
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  06/21/1998 - a-llucar - created <nl>
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest5(BOOL fCoCreate, 
									BOOL fMaxDebug, 
									LPARAM dwParam1, 
									LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicPort			*pwPort				= NULL;
	CtIDirectMusicPort			*pwPort2			= NULL;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Set up the performance to play
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(pwPort);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(pwPort) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(pwPort2);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(pwPort2) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) call PlaySegment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment (primary) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(1000);
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT | DMUS_SEGF_SECONDARY, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment (secondary) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(1000);

TEST_END:
    // **********************************************************************
    // 6) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if (pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}
	if(pwPort)
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if(pwPort2)
	{
		pwPort2->Release();
		pwPort2 = NULL;
	} 
	dmthCoUninitialize();	
	return dwRes;
}	





//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PlaySegment()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment(). <nl>
//			Checks to make sure that files play properly from the middle . <nl>
//			This is identical to PlaySegmentValidTest3, except it's a producer generated segment.
//			NOTE:  THIS IS A LISTENING TEST!  YOU SHOULD HEAR A D! <nl><nl>
//
// Test Function: <nl>
// tdmperfvPlaySegmentValidTest6 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a wrapped Composer object <nl>
// 3) Create a wrapped Performance object <nl>
// 4) Load the media <nl>
// 5) Compose the two segments <nl>
// 6) Init and AddPort <nl>
// 7) Set the start point to other than the beginning <nl>
// 8) Call PlaySegment and check results <nl>
// 9) Wait for IsPlaying to return favorably (or time out) <nl>
// 10) Release objects, Co-Uninitialize, and return result <nl>
//
// History:
//  06/29/1998 - a-llucar - Created
//
//  Note - Same test is used for both GetLoopPointsValidTest1 and SetLoopPointsValidTest1
// @index topic | IDIRECTMUSICSEGMENT_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPlaySegmentValidTest6(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicComposer		*pwComposer		= NULL;
	CtIDirectMusicStyle			*pwStyle		= NULL;
	CtIDirectMusicChordMap		*pwChordMap	= NULL;
	int							counter			= 0;
	int							SleepTime		= 1000;
	int							TimeOutValue	= 10;
	MUSIC_TIME					mtLength		= 0;
	MUSIC_TIME					mtStart			= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object)
    // **********************************************************************
	hr = dmthCreateComposer(IID_IDirectMusicComposer,&pwComposer);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Composer Object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicPerformance object (wrapped IDMPerformance object)
    // **********************************************************************
	hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Performance Object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Load the media
    // **********************************************************************
	hr = dmthLoadStyle(L"PitBen.sty", &pwStyle);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadStyle ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = dmthLoadChordMap(NULL, &pwChordMap);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadChordMap ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Compose the two segments
    // **********************************************************************
	hr = pwComposer->ComposeSegmentFromShape(pwStyle, 4, DMUS_SHAPET_FALLING, 0, FALSE, FALSE, pwChordMap, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ComposeSegmentFromShape ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	// **********************************************************************
    // 6) Init and AddPort
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 7) Set the start point to other than the beginning
    // **********************************************************************	
	hr = pwSegment->GetLength(&mtLength);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->GetLength ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// make sure that mtLength is set to something other than 0
	if(!mtLength)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: mtLength was not set (mtLength == 0)"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	mtStart = (mtLength /2); //Half the length of the segment

	hr = pwSegment->SetStartPoint(mtStart);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwSegment->SetStartPoint ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	    
    // **********************************************************************
    // 8) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Wait for IsPlaying to return favorably (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
Sleep(5000);

TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwStyle)
	{
		pwStyle->Release();
		pwStyle = NULL;
	}
	if(pwComposer)
	{
		pwComposer->Release();
		pwComposer = NULL;
	}
	if(pwChordMap)
	{
		pwChordMap->Release();
		pwChordMap = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::QueryInterface_Valid_Test |
//
// Description: <nl>
//	QI an IDMPerformance for the passed in interface ID(which should be 
//	valid!) and verify that the IUnknown obtained from QIing that interface
//	is the same as the IUnknown obtained from QIing the original performance.
//
// Test Function: <nl>
//	tdmperfvQIValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - *IID to QI for <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a wrapped object <nl>
// 3) QI the interface for the IID given to us. <nl>
// 4) QI the newly obtained interface for IUnknown. <nl>
// 5) QI the original IDMPerformance for IUnknown. <nl>
// 6) Compare their pointers.  Report a bug if they differ. <nl>
// 7) Cleanup objects, uninitialize COM, and return test results. <nl>
//
// History:
//  07/16/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvQIValidTest1( BOOL fCoCreate,
					  BOOL fMaxDebug, 
					  LPARAM dwParam1, 
					  LPARAM dwParam2 )
{
    HRESULT hr		= E_NOTIMPL;
	DWORD	dwRes	= FNS_PASS;

	IUnknown						*pInterface			= NULL;
	IUnknown						*pIUnknown1			= NULL;
	IUnknown						*pIUnknown2			= NULL;
	CtIDirectMusicPerformance		*pwPerformance		= NULL;
	GUID							*pIID				= (GUID *)dwParam2;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize( NULL );
    if ( FAILED(hr) )
    {
        fnsLog( ABORTLOGLEVEL, "**** ABORT: COM initialization failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hr), hr );
        return FNS_ABORTED;
    }
	
    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// **********************************************************************
	// 3) QI the interface for the IID given to us.
    // **********************************************************************
	hr = pwPerformance->QueryInterface( *pIID, (void **)(&pInterface) );
    if ( FAILED(hr) )
    {
        fnsLog( ABORTLOGLEVEL, "**** ABORT: pwPerformance::QI failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hr), hr );
        dwRes = FNS_ABORTED;
		goto TEST_END;
    }

    // **********************************************************************
	// 4) QI the newly obtained interface for IUnknown.
    // **********************************************************************
    fnsLog( FYILOGLEVEL, "---- FYI: QI'ing obtained interface for IUnknown " );
	hr = pInterface->QueryInterface( IID_IUnknown, 
								(void **)(&pIUnknown1) );
    if ( FAILED(hr) )
    {
        fnsLog( BUGLOGLEVEL, "!!!! BUG: IDMPerformance::QI for IUnknown failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hr), hr );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }

    // **********************************************************************
	// 5) QI the original IDMBand for IUnknown.
    // **********************************************************************
	hr = pwPerformance->QueryInterface( IID_IUnknown, 
								(void **)(&pIUnknown2) );
    if ( FAILED(hr) )
    {
        fnsLog( BUGLOGLEVEL, "!!!! BUG: pwPerformance::QI for IUnknown failed! "
			"(%s == %08Xh)", dmthXlatHRESULT(hr), hr );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }

    // **********************************************************************
	// 6) Compare their pointers.  Report a bug if they differ.
    // **********************************************************************
	if ( pIUnknown1 != pIUnknown2 )
	{
        fnsLog( BUGLOGLEVEL, "!!!! BUG: IUnknown pointers are different! "
			"(%s == %08Xh)", dmthXlatHRESULT(hr), hr );
        dwRes = FNS_FAIL;
		goto TEST_END;
    }


TEST_END:
    // **********************************************************************
    // 7) Cleanup objects, uninitialize COM, and return test results.
    // **********************************************************************
	if (pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if ( pInterface )
	{
		pInterface->Release();
        pInterface = NULL;
	}

	if ( pIUnknown1 )
	{
		pIUnknown1->Release();
        pIUnknown1 = NULL;
	}
	
	if ( pIUnknown2 )
	{
		pIUnknown2->Release();
        pIUnknown2 = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetPrepareTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetPrepareTime().
//		Sets the Prepare Time way into the future, checks GetPrepareTime <nl>
//		after PlaySegment is called <nl>
//
// Test Function: <nl>
// tdmperfvSetPrepareTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetPrepareTime and Test the function <nl>
// 4) Call GetPrepareTime and Test the function <nl>
// 5) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  07/16/1998 - a-llucar - created <nl>
//
//	The same test is used for GetPrepareTimeValidTest1() and SetPrepareTimeValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetPrepareTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	DWORD						dwSet				= 10000;
	DWORD						dwGet				= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call SetPrepareTime and Test the function
    // **********************************************************************
	hr = pwPerformance->SetPrepareTime(dwSet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetPrepareTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) Set up the performance to play
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 6) call PlaySegment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, DMUS_SEGF_BEAT, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(5000);
						   
    // **********************************************************************
    // 7) Call GetPrepareTime and Test the function
    // **********************************************************************
	hr = pwPerformance->GetPrepareTime(&dwGet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetPrepareTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that dwSet and dwGet are the same
	if(dwSet != dwGet)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetPrepareTime not set correctly, ")
                TEXT("(dwSet == %08Xh)")
				TEXT("(dwGet == %08Xh)"),
                dwSet, dwGet);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
TEST_END:
    // **********************************************************************
    // 5) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	// Clean up the wrapper
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Stop()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PlaySegment().
//		Calls method passing all possible param types
//
// Test Function: <nl>
// tdmperfvStopCAPTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object (wrapped IDMPerformance object) <nl>
// 3) Load Segment
// 4) Pre-Play
// 5) Call PlaySegment and Stop for all params <nl>
// 6) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/22/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvStopCAPTest(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance*	pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState	= NULL;
	int							i				= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Set up the performance to play
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call PlayMidiFile() and stop passing all params
    // **********************************************************************
	for (i = 0; i < sizeof(SEGF_FLAGS)/sizeof(DWORD); i++)
	{
		fnsLog(FYILOGLEVEL, "i == %i", i);
		hr = pwPerformance->PlaySegment(pwSegment, SEGF_FLAGS[i], 0, &pwSegmentState);
		if(FAILED(hr))
		{
	        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment "),
	                TEXT("failed (%s == %08Xh)"),
	                tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
		
		hr = pwPerformance->Stop(pwSegment, NULL, 0, SEGF_FLAGS[i]);
		if(FAILED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->Stop")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
		}
		
		Sleep(500);
		if(pwSegmentState)
		{
			pwSegmentState->Release();
			pwSegmentState = NULL;
		}
	}
	// re-initialize i
	i = 0;
	// Do the same for SegmentState
	for (i = 0; i < sizeof(SEGF_FLAGS)/sizeof(DWORD); i++)
	{
		fnsLog(FYILOGLEVEL, "i == %i", i);
		hr = pwPerformance->PlaySegment(pwSegment, 32, 0, &pwSegmentState);
		if(FAILED(hr))
		{
	        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment "),
	                TEXT("failed (%s == %08Xh)"),
	                tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
		
		hr = pwPerformance->Stop(NULL, pwSegmentState, 0, SEGF_FLAGS[i]);
		if(FAILED(hr))
		{
			fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->Stop")
					TEXT("failed (%s == %08Xh)"),
					tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
		}
		
		Sleep(500);
		if(pwSegmentState)
		{
			pwSegmentState->Release();
			pwSegmentState = NULL;
		}
	}


TEST_END:
    // **********************************************************************
    // 6) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if (pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
        pwSegment = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetGraph()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetGraph().
//		Creates 2 performance objects, GetGraph from the first and <nl>
//		SetGraph on the second.
//
// Test Function: <nl>
// tdmperfvSetGraphValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create 2 CtIDirectMusicPerformance objects <nl>
// 3) Create Graph Object <nl>
// 4) dmthCreateEchoTool <nl>
// 5) Check to make sure Tool got set to something <nl>
// 6) Load the two segments <nl>
// 7) Insert Tool <nl>
// 8) Set the Performance Graph <nl>
// 9) Create DirectMusic Ojbect <nl>
// 10) Init the two performances <nl>
// 11) Create a SynthPort <nl>
// 12) Add a port to our two performances <nl>
// 13) Create the 5 channels for the echos <nl>
// 14) Performance->AllocPMsg and check results <nl>
// 15) Call StampPMsg() and check results <nl>
// 16) Call PlaySegment and check results <nl>
// 17) Call GetGraph, and pass it into pwGraph2 <nl>
// 18) Call SetGraph on the Second performance <nl>
// 19) Wait for IsPlaying to return or time out <nl>
// 20) Call PlaySegment on the second performance <nl>
// 21) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/22/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetGraphValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD                       dwRes			= FNS_PASS;
    HRESULT                     hr				= S_OK;
    CtIDirectMusicGraph         *pwGraph		= NULL;
    CtIDirectMusic              *pwDM			= NULL;
    CtIDirectMusicPerformance   *pwPerformance	= NULL;
    CtIDirectMusicSegment       *pwSegment		= NULL;
    CtIDirectMusicTool          *pwTool			= NULL;
    CtIDirectMusicPort          *pwPort			= NULL;
    DMUS_PMSG                   *pdmusPMSG		= NULL;
    DMUS_PORTPARAMS             dmusPortParams;
    DWORD                       dwCounter       = 0;
    DWORD                       dwTimeOutValue  = 20;
    GUID                        guidSink;
	CtIDirectMusicPerformance	*pwPerformance2	= NULL;
	CtIDirectMusicSegment		*pwSegment2		= NULL;
	CtIDirectMusicGraph			*pwGraph2		= NULL;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: COM initialization failed! (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 9) Create DirectMusic Object
    // **********************************************************************
	hr = dmthCreateDMBaseObj(IID_IDirectMusic, &pwDM);
	if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IDirectMusic object creation failed! (%s == %08Xh)", 
			tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

	pwDM->SetDirectSound(NULL, ghWnd);
	if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Music->SetDirectSound failed! (%s == %08Xh)", 
			tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 2) Create 2 CtIDirectMusicPerformance objects 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation (pwPerformance1) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance2);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation (pwPerformance2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Create Graph Object
    // **********************************************************************
    hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 4) dmthCreateEchoTool
    // **********************************************************************
    hr = dmthCreateEchoTool(IID_IDirectMusicTool, &pwTool, 3, DMUS_PPQ);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateEchoTool "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 5) Check to make sure Tool got set to something
    // **********************************************************************
    if ( NULL == pwTool )
    {   
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Something wrong with the Tool.  Should not be NULL.");
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


    // **********************************************************************
    // 6) Load the two segments
    // **********************************************************************
    hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = dmthLoadSegment(L"onestop2.mid", &pwSegment2);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 7) Insert Tool
    // **********************************************************************
    hr = pwGraph->InsertTool( pwTool, NULL, 0, 0 );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Graph->InsertTool "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 8) Set the Performance Graph
    // **********************************************************************
    hr = pwPerformance->SetGraph( pwGraph );
    if (FAILED( hr ))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: Performance->SetGraph(pwGraph) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }


    // **********************************************************************
    // 10) Init the two performances
    // **********************************************************************
    hr = pwPerformance->Init(&pwDM,NULL,ghWnd);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->Init "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	hr = pwPerformance2->Init(&pwDM,NULL,ghWnd);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance2->Init "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
    // set autodownload on
    fAuto = TRUE;
    hr = pwPerformance2->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance2->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 11) Create a SynthPort
    // **********************************************************************
    ZeroMemory( &dmusPortParams, sizeof(DMUS_PORTPARAMS) );
    dmusPortParams.dwSize          = sizeof(DMUS_PORTPARAMS);  
    dmusPortParams.dwChannelGroups = 5; // create 5 channel groups on the port
    dmusPortParams.dwValidParams   = DMUS_PORTPARAMS_CHANNELGROUPS;

    ZeroMemory( &guidSink, sizeof(GUID) );

    hr = pwDM->CreatePort(
		CLSID_DirectMusicSynth, 
        &dmusPortParams, 
        &pwPort, 
        NULL );
    if ( FAILED(hr) )
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwDM->CreatePort "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 12) Add a port to our two performances
    // **********************************************************************
    hr = pwPerformance->AddPort(pwPort);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->AddPort(NULL) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = pwPerformance2->AddPort(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance2->AddPort(NULL) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 13) Create the 5 channels for the echos
    // **********************************************************************
    // Assign blocks of 16 PChannels to this port.
    // Block 0, port pPort, and group 1 means to assign
    // PChannels 0-15 to group 1 on port pPort.
    // PChannels 0-15 correspond to the standard 16
    // MIDI channels.
    pwPerformance->AssignPChannelBlock( 0, pwPort, 1 );
    pwPerformance->AssignPChannelBlock( 1, pwPort, 2 ); //16 - 31 Group 2
    pwPerformance->AssignPChannelBlock( 2, pwPort, 3 ); //32 - 47 Group 3
    pwPerformance->AssignPChannelBlock( 3, pwPort, 4 ); //48 - 63 Group 4
    pwPerformance->AssignPChannelBlock( 4, pwPort, 5 ); //64 - 80 Group 5

    // **********************************************************************
    // 14) Performance->AllocPMsg and check results
    // **********************************************************************
    hr = pwPerformance->AllocPMsg( sizeof(DMUS_PMSG), &pdmusPMSG );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->AllocPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 15) Call StampPMsg() and check results
    // **********************************************************************   
    hr = pwGraph->StampPMsg(pdmusPMSG);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicTool->StampPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 16) Call PlaySegment and check results
    // **********************************************************************
    hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 17) Call GetGraph, and pass it into pwGraph2
    // **********************************************************************
	hr = pwPerformance->GetGraph(&pwGraph2);
	if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance->GetGraph(&pwGraph2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 18) Call SetGraph on the Second performance
    // **********************************************************************
	hr = pwPerformance2->SetGraph(pwGraph2);
	if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance2->SetGraph(pwGraph2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 19) Wait for IsPlaying to return or time out
    // **********************************************************************
    dwCounter = 0;
    while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)  
    {
        Sleep(1000);
        if(dwCounter++ > dwTimeOutValue)
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegment() timed out"
                "IsPlaying did not return the Segment (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }
    }

    Sleep(1000);
	
    // **********************************************************************
    // 20) Call PlaySegment on the second performance
    // **********************************************************************
	hr = pwPerformance2->PlaySegment(pwSegment2, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance2->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
	Sleep(5000);

TEST_END:
    // **********************************************************************
    // 21) Release objects, CoUninitialize, and return results
    // **********************************************************************
    if(pwPerformance)
    {
        if (pdmusPMSG)
            pwPerformance->FreePMsg((DMUS_PMSG *) pdmusPMSG);

        pwPerformance->Stop(NULL, NULL, 0, 0);
        pwPerformance->CloseDown();
        pwPerformance->Release();
        pwPerformance = NULL;
    }
	if(pwPerformance2)
	{
        pwPerformance2->Stop(NULL, NULL, 0, 0);
		pwPerformance2->CloseDown();
		pwPerformance2->Release();
		pwPerformance2 = NULL;
	}
    if(pwTool)
    {
        pwTool->Release();
        pwTool = NULL;
    }
    if(pwGraph)
    {
        pwGraph->Release();
        pwGraph = NULL;
    }
    if(pwSegment)
    {
        pwSegment->Release();
        pwSegment = NULL;
    }
    if(pwPort)
    {
        pwPort->Release();
        pwPort = NULL;
    }
    if(pwDM)
    {
        pwDM->Release();
        pwDM = NULL;
    }
	if(pwSegment2)
	{
		pwSegment2->Release();
		pwSegment2 = NULL;
	}
	if(pwGraph2)
	{
		pwGraph2->Release();
		pwGraph2 = NULL;
	}
    dmthCoUninitialize();   
    return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SendPMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SendPMsg().
//		Send a PMsg that's already been sent.
//
// Test Function: <nl>
// tdmperfvSendPMsgValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note <nl>
// 5) Set up pMSG's for Note <nl>
// 6) Call SendPMsg for Note and check result <nl>
// 7) Call SendPMsg again and look for return DMUS_E_ALREADY_SENT <nl>
// 8) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSendPMsgValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: Performance->Init ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pNote) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pNote, \n")
                TEXT("pNote == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6) Call SendPMsg on pNote and check results
    // **********************************************************************	
	fnsLog(FYILOGLEVEL, TEXT("We expect this to FAIL!"));
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pNote) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Call SendPMsg on pNote again and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	//BUGBUG - This should really be DMUS_E_ALREADY_SENT, but we're still in the non-forked stuff!
	if(hr != DMUS_E_ALREADY_SENT)
//	if(SUCCEEDED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg (same message second time) ")
                TEXT("did not return DMUS_E_ALREADY_SENT (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 8) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetQueueTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetQueueTime().
//		Calls GetQueueTime without Init'ing the port.  Expects DMUS_E_NO_MASTER_CLOCK.
//
// Test Function: <nl>
// tdmperfvGetQueueTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call GetQueueTime (expect DMUS_E_NO_MASTER_CLOCK) <nl>
// 4) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetQueueTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	REFERENCE_TIME					rtTime			= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Call GetQueueTime (expect DMUS_E_NO_MASTER_CLOCK)
    // **********************************************************************
	fnsLog(FYILOGLEVEL, TEXT("We expect this to FAIL!"));
	hr = pwPerformance->GetQueueTime(&rtTime);
	if(hr != DMUS_E_NO_MASTER_CLOCK)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetQueueTime ")
                TEXT("Did not return DMUS_E_NO_MASTER_CLOCK (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 4) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetQueueTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetQueueTime().
//		Calls GetQueueTime before and after Playing segment. <nl>
//		Expects them to be relatively close to each other. <nl>
//
// Test Function: <nl>
// tdmperfvGetQueueTimeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Set Bumper Length to 0 <nl>
// 4) Load Segment <nl>
// 5) PrePlay <nl>
// 6) Call GetQueueTime and store value <nl>
// 7) PlaySegment <nl>
// 8) Call GetQueueTime again, and compare values <nl>
// 9) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetQueueTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	CtIDirectMusicSegment			*pwSegment		= NULL;
	REFERENCE_TIME					rtTime			= 0;
	REFERENCE_TIME					rtTime2			= 0;
	MUSIC_TIME						mtTime			= 0;
	MUSIC_TIME						mtTime2			= 0;
	MUSIC_TIME						mtTimeNow		= 0;
	MUSIC_TIME						mtTimeNow2		= 0;
	MUSIC_TIME						mtTotalTime		= 0;
	MUSIC_TIME						mtTotalTime2	= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) SetBumperLength to zero
    // **********************************************************************
	hr = pwPerformance->SetBumperLength(0);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetBumperLength ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// **********************************************************************
    // 4) Load a Segment Object
    // **********************************************************************
   	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) PrePlay Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Init(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call GetQueueTime 
    // **********************************************************************
	hr = pwPerformance->GetTime(NULL, &mtTimeNow);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->GetQueueTime(&rtTime);
	if (FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetQueueTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->ReferenceToMusicTime(rtTime, &mtTime);
	if (FAILED(hr))	
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	mtTotalTime = mtTime - mtTimeNow;

	// **********************************************************************
    // 7) Play the segment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 8) Call GetQueueTime and compare two QueueTimes
    // **********************************************************************
	hr = pwPerformance->GetTime(NULL, &mtTimeNow2);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->GetQueueTime(&rtTime2);
	if (FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetQueueTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->ReferenceToMusicTime(rtTime2, &mtTime2);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	mtTotalTime2 = mtTime2 - mtTimeNow2;

	//BUGBUG this seems to be swayed HEAVILY by the logging in tdmusic.  If we log 10, the difference is
	// minimal, but logging 1 and there about 250 apart from each other.
	if((mtTotalTime2 - mtTotalTime) > 250)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: mtTotalTime and mtTotalTime2 are not close to each other."));
		fnsLog(BUGLOGLEVEL, TEXT("mtTotalTime  == %u"), mtTotalTime);
		fnsLog(BUGLOGLEVEL, TEXT("mtTotalTime2 == %u"), mtTotalTime2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 9) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetTime().
//		Calls GetTime passing in both mtTime and rtTime. <nl>
//		Expects them both to be populated. <nl>
//
// Test Function: <nl>
// tdmperfvGetTimeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call GetTime and check results <nl>
// 5) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	REFERENCE_TIME					rtTime			= 0;
	MUSIC_TIME						mtTime			= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the performance
    // **********************************************************************
    hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetTime passing in both mtTime and rtTime
    // **********************************************************************
	Sleep(100);
	hr = pwPerformance->GetTime(&rtTime, &mtTime);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->GetTime ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if (!rtTime)	//rtTime was not properly set
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->GetTime ")
				TEXT("rtTime was not properly set"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if (!mtTime)	//mtTime was not properly set
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->GetTime ")
				TEXT("mtTime was not properly set"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
TEST_END:
    // **********************************************************************
    // 5) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::Init()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::Init().
//		Calls Init on a DirectMusic object that was already created. <nl>
//		Expects return DMUS_E_ALREADY_INITED. <nl>
//
// Test Function: <nl>
// tdmperfvInitValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create a CtIDirectMusic object <nl>
// 4) Init the performance using our Music object <nl>
// 5) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvInitValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
//	CtIDirectMusic					*pwMusic		= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
	// **********************************************************************
    // 4) Init the performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    fnsLog(FYILOGLEVEL, TEXT("Note: We Expect this to FAIL."));
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(hr != DMUS_E_ALREADY_INITED)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->Init(Second call Init) ")
                TEXT("expected DMUS_E_ALREADY_INITED (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
TEST_END:
    // **********************************************************************
    // 5) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
//	if(pwMusic)
//	{
//		pwMusic->Release();
//		pwMusic = NULL;
//	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetLatencyTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetLatencyTime().
//		Calls GetLatencyTime after playing a segment and then after SetBumperLength to 0. <nl>
//		Expects latter to be smaller amount
//
// Test Function: <nl>
// tdmperfvGetLatencyTimeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load Segment <nl>
// 4) PrePlay <nl>
// 5) PlaySegment <nl>
// 6) Call GetLatencyTime and stores value <nl>
// 7) Set Bumper Length to 0 <nl>
// 8) Call GetLatencyTime again, and compare values <nl>
// 9) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/23/1998 - a-llucar - created <nl>
//  07/23/1999 - kcraven - edited <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetLatencyTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	CtIDirectMusicSegment			*pwSegment		= NULL;
	REFERENCE_TIME					rtTime			= 0;
	REFERENCE_TIME					rtTime2			= 0;

	DWORD							dwMilliseconds	= 0;

	REFERENCE_TIME					rtTimeNow		= 0;
	REFERENCE_TIME					rtTimeNow2		= 0;
	REFERENCE_TIME					rtTotalTime		= 0;
	REFERENCE_TIME					rtTotalTime2	= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Load a Segment Object
    // **********************************************************************
   	hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) PrePlay Performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Init(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) Play the segment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	hr = pwPerformance->GetBumperLength(&dwMilliseconds);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->GetBumperLength ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("**** FYI: dwMilliseconds == %u"), dwMilliseconds);

    // **********************************************************************
    // 6) Call GetLatencyTime 
    // **********************************************************************

	hr = pwPerformance->GetTime(&rtTimeNow,NULL);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->GetLatencyTime(&rtTime);
	if (FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetLatencyTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	rtTotalTime = rtTime - rtTimeNow;

    // **********************************************************************
    // 7) SetBumperLength to zero
    // **********************************************************************
	hr = pwPerformance->SetBumperLength(0);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetBumperLength ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->GetBumperLength(&dwMilliseconds);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->GetBumperLength ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("**** FYI: dwMilliseconds == %u"), dwMilliseconds);

    // **********************************************************************
    // 8) Call GetLatencyTime and compare two LatencyTimes
    // **********************************************************************

	hr = pwPerformance->GetTime(&rtTimeNow2,NULL);
	if (FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: GetTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->GetLatencyTime(&rtTime2);
	if (FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetLatencyTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	rtTotalTime2 = rtTime2 - rtTimeNow2;

	//convert to millisecs
	rtTotalTime /= 10000;
	rtTotalTime2 /= 10000;

	fnsLog(FYILOGLEVEL, TEXT("rtTotalTime  == %d"), rtTotalTime);
	fnsLog(FYILOGLEVEL, TEXT("rtTotalTime2 == %d"), rtTotalTime2);

	if(abs((int)(rtTotalTime2 - rtTotalTime)) > 2000) // 2 second swing
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: rtTotalTime2 is significantly different than rtTotalTime."));
		fnsLog(BUGLOGLEVEL, TEXT("Meaning that LatencyTime is not accurate"));
		dwRes = FNS_FAIL;
	}

TEST_END:
    // **********************************************************************
    // 9) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGlobalParam()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetGlobalParam(). <nl>
//		Passes all different types of guids.
//
// Test Function: <nl>
// tdmperfvGetGlobalParamValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create CtIDirectMusicComposer object <nl>
// 4) Load the media <nl>
// 5) Compose the Segment <nl>
// 6) Pre-Play the performance <nl>
// 7) Play the segment <nl> 
// 8) Call SetGlobalParam, check results<nl>
// 9) Call GetGlobalParam, check results (make sure dw and dw2 are equal) <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//	06/25/1998 - a-llucar - created
//	07/21/1998 - a-llucar - changed it so that we use the Array instead of dwParam1
//
//	Note - GetGlobalParam() and SetGlobalParam() both use the same test.
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetGlobalParamValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	GUID						guid			= GUID_PerfMasterGrooveLevel; 
	BYTE						bGroove			= 100;
	BYTE						bGroove2		= 5;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicComposer		*pwComposer		= NULL;
	CtIDirectMusicStyle			*pwStyle		= NULL;
	CtIDirectMusicChordMap	*pwChordMap	= NULL;

	int							i				= 0;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicComposer object (wrapped IDMComposer object)
    // **********************************************************************
	hr = dmthCreateComposer(IID_IDirectMusicComposer,&pwComposer);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Composer Object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Load the media
    // **********************************************************************
	hr = dmthLoadStyle(NULL, &pwStyle);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadStyle ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = dmthLoadChordMap(NULL, &pwChordMap);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadChordMap ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Compose a segment
    // **********************************************************************
	hr = pwComposer->ComposeSegmentFromShape(pwStyle, 16, DMUS_SHAPET_QUIET, 0, FALSE, FALSE, pwChordMap, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ComposeSegmentFromShape ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    
    // **********************************************************************
    // 6) PrePlay performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 7) Play the segment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(2000);

	// **********************************************************************
    // 8) Call SetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->SetGlobalParam(guid, &bGroove, 1);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(6000);

	// **********************************************************************
    // 9) Call GetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->GetGlobalParam( GUID_PerfMasterGrooveLevel, &bGroove2, 1);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that the DWORD was properly populated
	if(bGroove != bGroove2)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam\n ")
                TEXT("pData was not properly set\n")
                TEXT("Expected -- bGroove == %ld\n")
				TEXT("Received -- bGroove2 == %ld\n"),
				bGroove, bGroove2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}	

TEST_END:
	// **********************************************************************
    // 10) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(0, 0, NULL, NULL);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwComposer)
	{
		pwComposer->Release();
		pwComposer = NULL;
	}
	if(pwStyle)
	{
		pwStyle->Release();
		pwStyle = NULL;
	}
	if(pwChordMap)
	{
		pwChordMap->Release();
		pwChordMap = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PChannelInfo()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PChannelInfo(). <nl>
//		Calls PChannelInfo without setting up a Port <nl>
//
// Test Function: <nl>
// tdmperfvPChannelInfoValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call PChannelInfo and check results <nl>
// 4) Check to make sure that PChannelInfo returned the right info <nl>
// 5) Release object, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/24/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPChannelInfoValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPort				*pwPort			= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	DWORD							dwGroup			= 0;
	DWORD							dwChannel		= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init(NULL) and AddPort(NULL)
    // **********************************************************************	
	hr = pwPerformance->Init(NULL,NULL,ghWnd); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call PChannelInfo and check results
    // **********************************************************************
	fnsLog(FYILOGLEVEL, TEXT("We expect this to Fail!"));
	hr = pwPerformance->PChannelInfo( 0, &pwPort, &dwGroup, &dwChannel );
	if(SUCCEEDED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->PChannelInfo ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
    
TEST_END:
    // **********************************************************************
    // 5) Release object, CoUninitialize, and return results
    // **********************************************************************
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::PChannelInfo()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::PChannelInfo(). <nl>
//		Verifies that all PChannelInfo information is constant throughout. <nl>
//
// Test Function: <nl>
// tdmperfvPChannelInfoValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicComposer object (wrapped IDMComposer object) <nl>
// 3) Call AddPort (Synth) and check results <nl>
// 4) Call PChannelInfo and check results <nl>
// 5) Release object, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/24/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvPChannelInfoValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	CtIDirectMusicPort				*pwPort			= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	int								i				= 0;
	DWORD							dwGroup			= 0;
	DWORD							dwChannel		= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init(NULL) and AddPort(NULL)
    // **********************************************************************	
	hr = pwPerformance->Init(NULL,NULL,ghWnd); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL); 
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL)")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call PChannelInfo and check results
    // **********************************************************************
	for (i = 0; i < 17; i++)
	{
		if (pwPort)
		{
			pwPort->Release();
			pwPort = NULL;
		}
		hr = pwPerformance->PChannelInfo( 0, &pwPort, &dwGroup, &dwChannel );
		if(FAILED(hr))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->PChannelInfo ")
		            TEXT("failed (%s == %08Xh)"),
		            tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}

		if((NULL == pwPort) || (1 != dwGroup) || (0 != dwChannel))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->PChannelInfo ")
		            TEXT("Did not return the right information\n")
					TEXT("pwPort -- Expected NULL, Returned %08Xh\n")
					TEXT("dwGroup -- Expected 1, Returned %ld\n")
					TEXT("dwChannel -- Expected 0, Returned %ld\n"),
		            pwPort, dwGroup, dwChannel);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
    }
TEST_END:
    // **********************************************************************
    // 5) Release object, CoUninitialize, and return results
    // **********************************************************************
	if( pwPort )
	{
		pwPort->Release();
		pwPort = NULL;
	}
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}

	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetPrepareTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetPrepareTime().
//		Sets the Prepare Time to it's maximum, checks GetPrepareTime <nl>
//
// Test Function: <nl>
// tdmperfvSetPrepareTimeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Call SetPrepareTime and Test the function <nl>
// 4) Call GetPrepareTime and Test the function <nl>
// 5) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  07/24/1998 - a-llucar - created <nl>
//
//	The same test is used for GetPrepareTimeValidTest2() and SetPrepareTimeValidTest2() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetPrepareTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	DWORD						dwSet				= DWORD_MAX;
	DWORD						dwGet				= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Call SetPrepareTime and Test the function
    // **********************************************************************
	hr = pwPerformance->SetPrepareTime(dwSet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetPrepareTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call GetPrepareTime and Test the function
    // **********************************************************************
	hr = pwPerformance->GetPrepareTime(&dwGet);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetPrepareTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that dwSet and dwGet are the same
	if(dwSet != dwGet)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetPrepareTime not set correctly, ")
                TEXT("dwSet == %08Xh)"),
				TEXT("dwGet == %08Xh)"),
                dwSet, dwGet);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
TEST_END:
    // **********************************************************************
    // 5) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::IsPlaying()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::IsPlaying(). <nl>
//		Calls IsPlaying on a Secondary Segment <nl>
//
// Test Function: <nl>
// tdmperfvIsPlayingValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create CtIDirectMusicComposer object <nl>
// 4) Load the media <nl>
// 5) Compose the segment <nl>
// 6) Pre-Play performance <nl>
// 7) Play a segment <nl>
// 8) GetMotif, SetMotif, and Play Secondary Segment <nl>
// 9) Call IsPlaying, wait 1 second, and call IsPlaying again <nl> 
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/24/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvIsPlayingValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	CtIDirectMusicSegment		*pwSegment2			= NULL;
	CtIDirectMusicPerformance 	*pwPerformance		= NULL;
	CtIDirectMusicComposer		*pwComposer			= NULL;
	CtIDirectMusicStyle			*pwStyle			= NULL;
	CtIDirectMusicChordMap	*pwChordMap		= NULL;
	CtIDirectMusicSegmentState	*pwSegmentState		= NULL;

	WCHAR						wszName[100];
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create CtIDirectMusicComposer object (wrapped IDMComposer object)
    // **********************************************************************
	hr = dmthCreateComposer(IID_IDirectMusicComposer,&pwComposer);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate Composer Object ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Load the media
    // **********************************************************************
	hr = dmthLoadStyle(NULL, &pwStyle);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadStyle ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = dmthLoadChordMap(NULL, &pwChordMap);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadChordMap ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Compose the segment
    // **********************************************************************
	hr = pwComposer->ComposeSegmentFromShape(pwStyle, 16, DMUS_SHAPET_QUIET, 0, FALSE, FALSE, pwChordMap, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: ComposeSegmentFromShape ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
		
    // **********************************************************************
    // 6) PrePlay performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->AddPort(NULL) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 7) Play the segment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(2000);

    // **********************************************************************
    // 8) GetMotif, SetMotif, and Play Secondary Segment
    // **********************************************************************
	hr = pwStyle->EnumMotif(1, wszName);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Style->EnumMotif ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwStyle->GetMotif(wszName, &pwSegment2);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Style->GetMotif ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->PlaySegment(pwSegment2, DMUS_SEGF_SECONDARY, 0, &pwSegmentState);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->PlaySegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Call IsPlaying on Sec Segment, wait 1 second, call IsPlaying again
    // **********************************************************************
	hr = pwPerformance->IsPlaying(NULL, pwSegmentState);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->IsPlaying ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	Sleep(1000);
	hr = pwPerformance->IsPlaying(pwSegment, NULL);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->IsPlaying ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 10) Release objects, CoUninitialize, and return results 
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	if(pwSegment2)
	{
		pwSegment2->Release();
		pwSegment2 = NULL;
	}
	if(pwStyle)
	{
		pwStyle->Release();
		pwStyle = NULL;
	}
	if(pwChordMap)
	{
		pwChordMap->Release();
		pwChordMap = NULL;
	}
	if(pwComposer)
	{
		pwComposer->Release();
		pwComposer = NULL;
	}
	if(pwSegmentState)
	{
		pwSegmentState->Release();
		pwSegmentState = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetParam()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetParam() <nl>
//			Change the tempo of a Performance that is playing, <nl>
//			And already altered by SetGlobalParam <nl>
//
// Test Function: <nl>
// tdmperfvGetParamValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create IDirectMusicTempoTrack object <nl>
// 4) Get the Segment object <nl>
// 5) Init(NULL) and AddPort(NULL) <nl>
// 6) Set pTempo with a bunch of particulars <nl>
// 7) Call PlaySegment and check results <nl>
// 8) Call SetGlobalParam, check results <nl>
// 9) Call SetParam, check the results <nl>
// 10) Call GetParam, check the results <nl>
// 11) Wait for IsPlaying to return favorably (or time out) <nl>
// 12) Release objects, CoUninitialize, and return results <nl>
//
// History:
//  07/27/1998 - a-llucar - created <nl>
//
//	NOTE:  The same test is used for SetParamValidTest2 and GetParamValidTest2 <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetParamValidTest2(BOOL fCoCreate, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= E_NOTIMPL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicTrack			*pwTrack		= NULL;
	float						fTempo			= .5; //half tempo
	int							counter			= 0;
	int							SleepTime		= 1000;
	int							TimeOutValue	= 10;
	GUID						guid			= GUID_TempoParam;
	DMUS_TEMPO_PARAM			dmtp;
	WCHAR						*pSegmentFile	= (WCHAR*)dwParam1;
	char						*chPath			= gszMediaPath;
	WCHAR						*wchPath		= gwszBasePath;
	dmthSetPath(NULL);
	MUSIC_TIME					mt				= 0;

    // **********************************************************************
    // 1) Initialize COM
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  initialization failed! (%08Xh == %s)"),
					tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create IDirectMusicTempoTrack object 
    // **********************************************************************	
	hr = dmthCreateTrack(CLSID_DirectMusicTempoTrack, IID_IDirectMusicTrack, &pwTrack);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: CoCreate TempoTrack failed! (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	// **********************************************************************
    // 4) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(pSegmentFile, &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 5) Init(NULL) and AddPort(NULL)
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	pwSegment->SetRepeats(5);

    // **********************************************************************
	// 6) Set pTempo with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( &dmtp, sizeof(dmtp) );
	dmtp.dblTempo = 300;

	// **********************************************************************
    // 7) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->PlaySegment ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time Before = %ld"), mt);	

	// **********************************************************************
    // 8) Call SetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->SetGlobalParam(GUID_PerfMasterTempo, &fTempo, sizeof(float));
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

   	// **********************************************************************
    // 9) Call SetParam, check the results 
    // **********************************************************************
	hr = pwPerformance->SetParam(guid, 0xffffffff, 0, mt + 2000, (void*)&dmtp); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time After = %ld"), mt);	

   	// **********************************************************************
    // 10) Call GetParam, check the results 
    // **********************************************************************
	hr = pwSegment->GetParam(guid, 0xffffffff, 0, mt + 2000, 0, (void*)&dmtp); 
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetParam ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}   

    // **********************************************************************
    // 11) Wait for IsPlaying to return favorably (or time out)
    // **********************************************************************
	// Set counter back to zero
	counter = 0;
	while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)	
	{
		Sleep(SleepTime);
		if(counter++ >TimeOutValue)
		{
			fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment() timed out")
				TEXT("IsPlaying did not return the Segment (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}
Sleep(6000);
	pwPerformance->GetTime(NULL, &mt);
	fnsLog(FYILOGLEVEL, TEXT("Time After = %ld"), mt);	

TEST_END:
    // **********************************************************************
    // 12) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwTrack)
	{
		pwTrack->Release();
		pwTrack = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::AllocPMsg()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::AllocPMsg().
//		AllocPMSG for Note using boundary for cb.
//
// Test Function: <nl>
// tdmperfvAllocPMsgValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the Performance <nl>
// 4) Call AllocPMsg for Note, Curve, Tempo, and MIDI messages and check result <nl>
// 5) Set up pMSG's for Note, Curve, Tempo, and MIDI<nl>
// 6) Call SendPMsg for Note, Curve, Tempo, and MIDI, and check result <nl>
// 7) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  05/04/1998 - a-llucar - created <nl>
//
//	The same test is used for tdmperfvAllocPMsgValidTest1() and tdmperfvSendPMsgValidTest1() <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
/*
DWORD tdmperfvAllocPMsgValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD							dwRes			= FNS_PASS;
	HRESULT							hr				= S_OK;
	DMUS_NOTE_PMSG					*pNote			= NULL;
	DMUS_CURVE_PMSG					*pCurve			= NULL;
	DMUS_TEMPO_PMSG					*pTempo			= NULL;
	DMUS_MIDI_PMSG					*pMidi			= NULL;
	CtIDirectMusic					*pwMusic		= NULL;
	CtIDirectMusicPerformance		*pwPerformance	= NULL;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the Performance
    // **********************************************************************
	hr = pwPerformance->Init(&pwMusic,NULL,ghWnd);
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("*** ABORT: PerformanceNULL,NULL,ghWnd ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!pwMusic)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance not properly init'ed"));
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.1) Call AllocPMsg on pNote and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( ULONG_MAX, (DMUS_PMSG**)&pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pNote was properly populated
	if(!pNote)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pNote, \n"),
                TEXT("pNote == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.2) Call AllocPMsg on pCurve and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( ULONG_MAX, (DMUS_PMSG**)&pCurve );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pCurve was properly populated
	if(!pCurve)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pCurve, \n"),
                TEXT("pCurve == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.3) Call AllocPMsg on pTempo and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( ULONG_MAX, (DMUS_PMSG**)&pTempo );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pTempo was properly populated
	if(!pTempo)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pTempo, \n"),
                TEXT("pTempo == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 4.4) Call AllocPMsg on pMidi and check result
    // **********************************************************************
	hr = pwPerformance->AllocPMsg( ULONG_MAX, (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->AllocPMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Check to make sure that pMidi was properly populated
	if(!pMidi)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: AllocPMsg did not properly set pMidi, \n"),
                TEXT("pMidi == NULL"));
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 5.1) Set pNote with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pNote, sizeof(DMUS_NOTE_PMSG) );
	pNote->bFlags		= DMUS_NOTEF_NOTEON;
	pNote->bDurRange	= 100;
	pNote->wMusicValue	= 50;
	pNote->bVelocity	= 127;
	pNote->dwType		= DMUS_PMSGT_NOTE;
	pNote->dwFlags		= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.2) Set pCurve with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pCurve, sizeof(DMUS_CURVE_PMSG) );
	pCurve->bFlags			= 1;
	pCurve->mtDuration		= 1000;
	pCurve->mtOriginalStart	= 0;
	pCurve->mtResetDuration	= 100;
	pCurve->nStartValue		= 0;
	pCurve->nEndValue		= 1000;
	pCurve->nResetValue		= 50;
	pCurve->wMeasure		= 8;
	pCurve->nOffset			= 0;
	pCurve->bBeat			= 2;
	pCurve->bGrid			= 0;
	pCurve->bType			= DMUS_CURVET_CCCURVE;
	pCurve->bCurveShape		= DMUS_CURVES_EXP;
	pCurve->dwFlags			= DMUS_PMSGF_REFTIME;
	
    // **********************************************************************
    // 5.3) Set pTempo with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
	pTempo->dblTempo		= 100;
	pTempo->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 5.4) Set pMidi with a bunch of particulars
    // **********************************************************************	
	ZeroMemory( pMidi, sizeof(DMUS_MIDI_PMSG) );
	pMidi->dwFlags			= DMUS_PMSGF_REFTIME;

    // **********************************************************************
    // 6.1) Call SendPMsg on pNote and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pNote );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pNote) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.2) Call SendPMsg on pCurve and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pCurve );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pCurve) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 6.3) Call SendPMsg on pTempo and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pTempo) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 6.4) Call SendPMsg on pMidi and check results
    // **********************************************************************	
	hr = pwPerformance->SendPMsg( (DMUS_PMSG*)pMidi );
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SendPMsg(pMidi) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if(pwMusic)
	{
		pwMusic->Release();
		pwMusic = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
*/


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RemoveNotificationType()_Valid_Test2 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::RemoveNotificationType(). <nl>
//		Calls RemoveNotificationType with All types of guids <nl>
//
// Test Function: <nl>
// tdmperfvRemoveNotificationTypeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create an Event for hNotification <nl>
// 4) Create an Event for hNotification and check results <nl>
// 5) AddNotificationType(All Types) and check results <nl>
// 6) Call PlayMidiFile() convienence function <nl>
// 9) Call RemoveNotificationType and check results <nl>
// 10) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  03/23/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvRemoveNotificationTypeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
											LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	DMUS_NOTIFICATION_PMSG		*pEvent				= NULL;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	CtIDirectMusicSegment		*pwSegment			= NULL;
	HANDLE						hNotification;
	GUID						*guidNotification	= (GUID*)dwParam1;
	WCHAR						*pMidiFile			= (WCHAR*)dwParam2;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create an Event for hNotification
    // **********************************************************************
	hNotification = CreateEvent( NULL, FALSE, FALSE, NULL );
	if( !hNotification )
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Unable to Create an hNotificationEvent \n")
		    TEXT("(%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
	// 4) Create an Event for hNotification and check results
	// *********************************************************************
	pwPerformance->SetNotificationHandle( hNotification, 0 );
	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->SetNotificationHandle  ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
		
	// **********************************************************************
	// 5) AddNotificationType and check results 
	// **********************************************************************
	pwPerformance->AddNotificationType(*guidNotification);

	if(FAILED(hr))
	{
	    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddNotificationType ")
		    TEXT("failed (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

   	// **********************************************************************
    // 6) Call PlayMidiFile() convienence function
    // **********************************************************************
	hr = dmthPlayMidiFile(pwPerformance,CTIID_IDirectMusicSegment,(CtIDirectMusicSegment**)&pwSegment,(CtIDirectMusicSegmentState**)NULL, TRUE, pMidiFile);
	if(hr != S_OK)
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlayMidiFile convienence function "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Call RemoveNotificationType and check results
    // **********************************************************************
	pwPerformance->RemoveNotificationType(*guidNotification);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: pwPerformance->RemoveNotificationType ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	Sleep(1000);
		
TEST_END:
    // **********************************************************************
    // 8) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->Stop(NULL, NULL, 0, 0);
		pwPerformance->CloseDown();
		pwPerformance->Release();
		pwPerformance = NULL;
	}
	if (hNotification)
	{
		CloseHandle(hNotification);
		hNotification = NULL;
	}
	if(pwSegment)
	{
		pwSegment->Release();
		pwSegment = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::ReferenceToMusicTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::ReferenceToMusicTime(). <nl>
//		Call ReferenceToMusicTime at time rt == 0. <nl>
//		Expects to return mt == 0! <nl>
//
// Test Function: <nl>
// tdmperfvReferenceToMusicTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call ReferenceToMusicTime and check results <nl>
// 5) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/27/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvReferenceToMusicTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	MUSIC_TIME					mt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	
    // **********************************************************************
    // 3) Init the performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call ReferenceToMusicTime and check results
    // **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime( 0, &mt );

	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	if (mt != 0)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->ReferenceToMusicTime "));
        fnsLog(BUGLOGLEVEL, TEXT("Music Time did not return expected results"));
        fnsLog(BUGLOGLEVEL, TEXT("Expected: mt == 0 "));
        fnsLog(BUGLOGLEVEL, TEXT("Returned: mt == %u "), mt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MusicToReferenceTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::MusicToReferenceTime(). <nl>
//		Call MusicToReferenceTime at time rt == 0. <nl>
//		Expects to return mt == 0! <nl>
//
// Test Function: <nl>
// tdmperfvMusicToReferenceTimeTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call MusicToReferenceTime and check results <nl>
// 5) Cleanup objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  07/27/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvMusicToReferenceTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	REFERENCE_TIME				rt				= NULL;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 4) Call MusicToReferenceTime and check results
    // **********************************************************************
	hr = pwPerformance->MusicToReferenceTime( 0, &rt );

	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusicToReferenceTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	if (rt == 0)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusicToReferenceTime "));
        fnsLog(BUGLOGLEVEL, TEXT("Reference Time did not return expected results"));
        fnsLog(BUGLOGLEVEL, TEXT("Returned: rt == %u "), rt);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 5) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::SetGraph()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetGraph().
//		Creates 2 performance objects, GetGraph from the first and <nl>
//		SetGraph on the second.  Clears the Graph with SetGraph(NULL), <nl>
//		verifies with GetGraph(), and you should hear no Echo as it plays on. <nl>
//
// Test Function: <nl>
// tdmperfvSetGraphValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create 2 CtIDirectMusicPerformance objects <nl>
// 3) Create Graph Object <nl>
// 4) dmthCreateEchoTool <nl>
// 5) Check to make sure Tool got set to something <nl>
// 6) Load the two segments <nl>
// 7) Insert Tool <nl>
// 8) Set the Performance Graph <nl>
// 9) Create DirectMusic Object <nl>
// 10) Init the two performances <nl>
// 11) Create a SynthPort <nl>
// 12) Add a port to our two performances <nl>
// 13) Create the 5 channels for the echos <nl>
// 14) Performance->AllocPMsg and check results <nl>
// 15) Call StampPMsg() and check results <nl>
// 16) Call PlaySegment and check results <nl>
// 17) Call GetGraph, and pass it into pwGraph2 <nl>
// 18) Call SetGraph on the Second performance <nl>
// 19) Wait for IsPlaying to return or time out <nl>
// 20) Call PlaySegment on the second performance <nl>
// 21) Call SetGraph(NULL) to clear the graph from the performance <nl>
// 22) Call GetGraph(NULL) to clear the graph from the performance <nl>
// 23) Release objects, CoUninitialize, and return results <nl>
//
// History: <nl>
//  07/22/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvSetGraphValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD                       dwRes			= FNS_PASS;
    HRESULT                     hr				= S_OK;
    CtIDirectMusicGraph         *pwGraph		= NULL;
    CtIDirectMusicPerformance   *pwPerformance	= NULL;
    CtIDirectMusicSegment       *pwSegment		= NULL;
    CtIDirectMusicTool          *pwTool			= NULL;
    CtIDirectMusicPort          *pwPort			= NULL;
    CtIDirectMusic              *pwDM			= NULL;
    DMUS_PMSG                   *pdmusPMSG		= NULL;
    DMUS_PORTPARAMS             dmusPortParams;
    DWORD                       dwCounter       = 0;
    DWORD                       dwTimeOutValue  = 20;
    GUID                        guidSink;

	CtIDirectMusicPerformance	*pwPerformance2	= NULL;
	CtIDirectMusicSegment		*pwSegment2		= NULL;
	CtIDirectMusicGraph			*pwGraph2		= NULL;
	CtIDirectMusicGraph			*pwGraph3		= NULL;
	CtIDirectMusic				*pwDM2			= NULL;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: COM initialization failed! (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create 2 CtIDirectMusicPerformance objects 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation (pwPerformance1) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance2);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicPerformance object creation (pwPerformance2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 3) Create Graph Object
    // **********************************************************************
    hr = dmthCreateGraph(IID_IDirectMusicGraph, &pwGraph);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 4) dmthCreateEchoTool
    // **********************************************************************
    hr = dmthCreateEchoTool(IID_IDirectMusicTool, &pwTool, 3, DMUS_PPQ);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateEchoTool "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 5) Check to make sure Tool got set to something
    // **********************************************************************
    if ( NULL == pwTool )
    {   
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Something wrong with the Tool.  Should not be NULL.");
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


    // **********************************************************************
    // 6) Load the two segments
    // **********************************************************************
    hr = dmthLoadSegment(L"DSegTest3.sgt", &pwSegment);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = dmthLoadSegment(L"onestop2.mid", &pwSegment2);
    if (FAILED( hr ))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthLoadSegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 7) Insert Tool
    // **********************************************************************
    hr = pwGraph->InsertTool( pwTool, NULL, 0, 0 );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Graph->InsertTool "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 8) Set the Performance Graph
    // **********************************************************************
    hr = pwPerformance->SetGraph( pwGraph );
    if (FAILED( hr ))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: Performance->SetGraph(pwGraph) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 9) Create DirectMusic Object
    // **********************************************************************
	hr = dmthCreateDMBaseObj(IID_IDirectMusic, &pwDM);
	if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: IDirectMusic object creation failed! (%s == %08Xh)", 
			tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

	pwDM->SetDirectSound(NULL, ghWnd);
	if (FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Music->SetDirectSound failed! (%s == %08Xh)", 
			tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 10) Init the two performances
    // **********************************************************************
    hr = pwPerformance->Init(&pwDM,NULL,ghWnd);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->Init "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance2->Init(&pwDM,NULL,ghWnd);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance2->Init "
               "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
    // set autodownload on
    fAuto = TRUE;
    hr = pwPerformance2->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance2->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 11) Create a SynthPort
    // **********************************************************************
    ZeroMemory( &dmusPortParams, sizeof(DMUS_PORTPARAMS) );
    dmusPortParams.dwSize          = sizeof(DMUS_PORTPARAMS);  
    dmusPortParams.dwChannelGroups = 5; // create 5 channel groups on the port
    dmusPortParams.dwValidParams   = DMUS_PORTPARAMS_CHANNELGROUPS;

    ZeroMemory( &guidSink, sizeof(GUID) );

    hr = pwDM->CreatePort(
		CLSID_DirectMusicSynth, 
        &dmusPortParams, 
        &pwPort, 
        NULL );
    if ( FAILED(hr) )
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwDM->CreatePort "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 12) Add a port to our two performances
    // **********************************************************************
    hr = pwPerformance->AddPort(pwPort);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->AddPort(NULL) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    hr = pwPerformance2->AddPort(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance2->AddPort(NULL) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 13) Create the 5 channels for the echos
    // **********************************************************************
    // Assign blocks of 16 PChannels to this port.
    // Block 0, port pPort, and group 1 means to assign
    // PChannels 0-15 to group 1 on port pPort.
    // PChannels 0-15 correspond to the standard 16
    // MIDI channels.
    pwPerformance->AssignPChannelBlock( 0, pwPort, 1 );
    pwPerformance->AssignPChannelBlock( 1, pwPort, 2 ); //16 - 31 Group 2
    pwPerformance->AssignPChannelBlock( 2, pwPort, 3 ); //32 - 47 Group 3
    pwPerformance->AssignPChannelBlock( 3, pwPort, 4 ); //48 - 63 Group 4
    pwPerformance->AssignPChannelBlock( 4, pwPort, 5 ); //64 - 80 Group 5

    // **********************************************************************
    // 14) Performance->AllocPMsg and check results
    // **********************************************************************
    hr = pwPerformance->AllocPMsg( sizeof(DMUS_PMSG), &pdmusPMSG );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->AllocPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 15) Call StampPMsg() and check results
    // **********************************************************************   
    hr = pwGraph->StampPMsg(pdmusPMSG);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: DirectMusicTool->StampPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 16) Call PlaySegment and check results
    // **********************************************************************
    hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 17) Call GetGraph, and pass it into pwGraph2
    // **********************************************************************
	hr = pwPerformance->GetGraph(&pwGraph2);
	if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance->GetGraph(&pwGraph2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 18) Call SetGraph on the Second performance
    // **********************************************************************
	hr = pwPerformance2->SetGraph(pwGraph2);
	if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance2->SetGraph(pwGraph2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 19) Wait for IsPlaying to return or time out
    // **********************************************************************
    dwCounter = 0;
    while ((hr = pwPerformance->IsPlaying(pwSegment, NULL)) != S_OK)  
    {
        Sleep(1000);
        if(dwCounter++ > dwTimeOutValue)
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: PlaySegment() timed out"
                "IsPlaying did not return the Segment (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }
    }

    Sleep(1000);
	
    // **********************************************************************
    // 20) Call PlaySegment on the second performance
    // **********************************************************************
	hr = pwPerformance2->PlaySegment(pwSegment2, 0, 0, NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: pwPerformance2->PlaySegment "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
	Sleep(1000);

    // **********************************************************************
    // 21) Call SetGraph(NULL) to clear the graph from the performance
    // **********************************************************************
	hr = pwPerformance2->SetGraph(NULL);
	if(FAILED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance2->SetGraph(pwGraph2) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }

    // **********************************************************************
    // 22) Call GetGraph(NULL) to clear the graph from the performance
    // **********************************************************************
	hr = pwPerformance2->GetGraph(&pwGraph3);
	fnsLog(FYILOGLEVEL, "NOTE: We expect this to Fail");
	if(SUCCEEDED(hr))
    {
        fnsLog(BUGLOGLEVEL, "!!!! BUG: pwPerformance2->SetGraph(pwGraph3) "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_FAIL;
        goto TEST_END;
    }
	if(pwGraph3)
	{
		fnsLog(BUGLOGLEVEL, "!!!! BUG: SetGraph(NULL) did not clear the graph from the performance");
        dwRes = FNS_FAIL;
        goto TEST_END;
    }
	Sleep(10000);
	
TEST_END:
    // **********************************************************************
    // 23) Release objects, CoUninitialize, and return results
    // **********************************************************************
    if(pwPerformance)
    {
        if (pdmusPMSG)
            pwPerformance->FreePMsg((DMUS_PMSG *) pdmusPMSG);

        pwPerformance->Stop(NULL, NULL, 0, 0);
        pwPerformance->CloseDown();

        pwPerformance->Release();
        pwPerformance = NULL;
    }
    if(pwTool)
    {
        pwTool->Release();
        pwTool = NULL;
    }
    if(pwGraph)
    {
        pwGraph->Release();
        pwGraph = NULL;
    }
    if(pwSegment)
    {
        pwSegment->Release();
        pwSegment = NULL;
    }
    if(pwPort)
    {
        pwPort->Release();
        pwPort = NULL;
    }
    if(pwDM)
    {
        pwDM->Release();
        pwDM = NULL;
    }
	if(pwPerformance2)
	{
        pwPerformance2->Stop(NULL, NULL, 0, 0);
		pwPerformance2->CloseDown();
		pwPerformance2->Release();
		pwPerformance2 = NULL;
	}
	if(pwSegment2)
	{
		pwSegment2->Release();
		pwSegment2 = NULL;
	}
	if(pwGraph2)
	{
		pwGraph2->Release();
		pwGraph2 = NULL;
	}
	if(pwGraph3)
	{
		pwGraph3->Release();
		pwGraph3 = NULL;
	}
    dmthCoUninitialize();   
    return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetResolvedTime()_Valid test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetResolvedTime().
//		Calls GetResolvedTime while segment plays
//
// Test Function: <nl>
// tdmperfvGetResolvedTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load a segment <nl>
// 4) PrePlay <nl>
// 5) PlaySegment <nl>
// 5) Call GetResolvedTime <nl>
// 6) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  07/31/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetResolvedTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	REFERENCE_TIME				rtResolved		= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(L"test.mid", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Play the segment
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, NULL);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: PlaySegment ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 6) Call GetResolvedTime and check results
    // **********************************************************************
	hr = pwPerformance->GetResolvedTime(2000, &rtResolved, DMUS_SEGF_BEAT);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetResolvedTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// Test to make sure that dwSet and dwGet are the same
	if(!rtResolved)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetResolvedTime not set correctly, ")
                TEXT("rtResolved == %u)"), 
                rtResolved);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	// Clean up the wrapper
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetResolvedTime()_Valid test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetResolvedTime().
//		Calls GetResolvedTime passing in different Flags for dwFlags. <nl>
//
// Test Function: <nl>
// tdmperfvGetResolvedTimeValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Load a segment <nl>
// 4) PrePlay <nl>
// 5) Call GetResolvedTime <nl>
// 6) Cleanup objects and uninitialize COM and Return results <nl>
//
// History: <nl>
//  07/31/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetResolvedTimeValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	REFERENCE_TIME				rtResolved		= 0;
	int							i				= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Get the Segment object
    // **********************************************************************
   	hr = dmthLoadSegment(L"test.mid", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call GetResolvedTime and check results
    // **********************************************************************
	for (i = 0; i < sizeof(SEGF_FLAGS)/sizeof(DWORD); i++)
	{
		rtResolved = 0;	//Re-initialize rtResolved
		hr = pwPerformance->GetResolvedTime(2000, &rtResolved, SEGF_FLAGS[i]);
		if(FAILED(hr))
		{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetResolvedTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
		}

		// Test to make sure that dwSet and dwGet are the same
		if(!rtResolved)
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: GetResolvedTime not set correctly, ")
		            TEXT("rtResolved == %u)"), 
		            rtResolved);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
TEST_END:
    // **********************************************************************
    // 6) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	// Clean up the wrapper
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MusicToReferenceTime()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::MusicToReferenceTime(). <nl>
//		Calls GetTime(mt, rt).  Then, does a MusictoReferenceTime(mt, &rt2) and 
//		ReferenceToMusicTime(rt, &mt2).  Compares mt with mt2 and rt with rt2 to
//		verify that they are the same <nl>
//
// Test Function: <nl>
// tdmperfvMusicToReferenceTimeTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Init the performance <nl>
// 4) Call GetTime and check results <nl>
// 5) Call ReferenceToMusic and MusicToReference <nl>
//
// History: <nl>
//  07/27/1998 - a-llucar - created <nl>
//
//	NOTE:  Same test is used for MusicToReferenceTime3 and ReferenceToMusicTime3
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvMusicToReferenceTimeValidTest3(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	REFERENCE_TIME				rt				= 0;
	REFERENCE_TIME				rt2				= 0;
	MUSIC_TIME					mt				= 0;
	MUSIC_TIME					mt2				= 0;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Init the performance
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->Init(NULL) "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // **********************************************************************
    // 4) Call GetTime to get mt and rt
    // **********************************************************************
	Sleep(100); // insure some time has passed so NULL should never be returned
	hr = pwPerformance->GetTime( &rt, &mt );
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	if(!mt || !rt)
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT:  mt or rt was not set correctly"),
				TEXT("rt == %u, mt == %u"), rt, mt);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call ReferenceToMusic (and vice-versa) to get mt2 and rt2; compare
    // **********************************************************************
	hr = pwPerformance->ReferenceToMusicTime(rt, &mt2);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->ReferenceToMusicTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	hr = pwPerformance->MusicToReferenceTime(mt, &rt2);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->MusictoReferenceTime ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	if(mt != mt2)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: mt != mt2 ")
                TEXT("mt == %u, mt2 == %u"), mt, mt2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	if(rt + 10000 < rt2 || rt - 10000 > rt2)
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: rt != rt2 ")
                TEXT("rt == %u, rt2 == %u"), rt, rt2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 6) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}

	dmthCoUninitialize();	

	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::LoadFiles()_Valid_Test2 |
//
// Description: <nl>
//		Verifies that loading UNFO subchunks should be UXXX rather than IXXX<nl>
//
// Test Function: <nl>
// tdmperfvLoadFilesValidTest1<nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// History: <nl>
//  10/19/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
/*
DWORD tdmperfvLoadFilesValidTest1(BOOL fCheck1, BOOL fCheck2, 
											LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicStyle			*pwStyle			= NULL;
	CtIDirectMusicBand			*pwBand				= NULL;

	BOOL						fLoadStyle			= fCheck1;
	BOOL						fLoadBand			= fCheck2;
	WCHAR						*pStyleFile			= (WCHAR*)dwParam1;
	WCHAR						*pBandFile			= (WCHAR*)dwParam2;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Load Style File <nl>
    // **********************************************************************
	if(fCheck1)	// We want to look for a style file
	{
		hr = dmthLoadStyle(pStyleFile, &pwStyle);
		if(FAILED(hr))
		{
		    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicStyle object creation "),
		            TEXT("failed (%s == %08Xh)"),
		            tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}

    // **********************************************************************
    // 3) Load Band File <nl>
    // **********************************************************************
	if(fCheck2)	// We want to look for a band file
	{
		hr = dmthLoadBand(pBandFile, &pwBand);
		if(FAILED(hr))
		{
		    fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicBand object creation "),
		            TEXT("failed (%s == %08Xh)"),
		            tdmXlatHRESULT(hr), hr);
			dwRes = FNS_ABORTED;
			goto TEST_END;
		}
	}

TEST_END:
    // **********************************************************************
    // 4) Release objects, CoUninitialize, and return results
    // **********************************************************************
	dmthReleaseStyle(pwStyle);	
	if(pwBand)
	{
		pwBand->Release();
		pwBand = NULL;
	}
	dmthCoUninitialize();	
	return dwRes;
}
*/
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MultipleTools()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::SetGraph() <nl>
// This test inserts a tool at a given address, in an array of tools
// 
//
// Test Function: <nl>
// tdmPerfvMultipleToolsValidTest <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - Number of tools to create <nl>
//  DWORD   dwParam2    - Index at at which to stick Tool #(dwParam1 + 1) at<nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create Performance Object <nl>
// 3) Init the performance <nl>
// 4) AllocPMsg for the User PMsg <nl>
// 3) Create Graph Object<nl>
// 4) Create Array of Tools and insert them<nl>
//  4.1) Check Validity of the tool<nl>
//  4.2) Set the ID of the tool to the Index number<nl>
//  4.3) Set each tools m_fLogFlags to log USER PMsgs
//  4.4) Insert Tool at Index dwIndex. If last tool, insert at desired index<nl>
// 5) Get the tool at that index, to verify<nl>
// 6) Verify that the tool was the one we expected<nl>
// 7) Release objects, CoUninitialize, and return results<nl>
//
// History:
//	10/13/1998 - a-llucar - Created (based off of Graph test)
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmPerfvMultipleToolsValidTest(BOOL fIndexFromEnd, BOOL fMaxDebug, LPARAM dwParam1, LPARAM dwParam2)
{
    DWORD						dwRes			= FNS_PASS;
    HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
    CtIDirectMusicGraph			*pCtGraph		= NULL;
    CtIDirectMusicTool			*pCtTool		= NULL;
    LPVOID*						pCtTools		= NULL;

    DWORD						pdwPChannels[]	= {0,1,2,3,4,5}; //Array of PChannels just to make scenario richer.

    DWORD						dwIndex			= 0;
    DWORD						dwNumTools		= (DWORD)dwParam1; //Number of tools to create
    LONG						lToolIndex		= (LONG)(dwParam2 - 1); //Index at which to Insert Tool #(dwNumTools + 1) at
    DWORD						dwUniqueID		= 123456;
    CTDMTestTool*				pTestTool		= NULL;
    DMUS_PMSG                   *pdmusPMSG      = NULL;

    // **********************************************************************
    // 1) Initialize COM.
    // **********************************************************************
    hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: COM initialization failed! (%s == %08Xh)",
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) Init(NULL) and AddPort(NULL)
    // **********************************************************************
	hr = pwPerformance->Init(NULL,NULL,ghWnd);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->Init(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // set autodownload on
    BOOL fAuto;
    fAuto = TRUE;
    hr = pwPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAuto, sizeof(BOOL) );
	if(FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: Performance->SetGlobalParam(AutoDownload == TRUE) ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	hr = pwPerformance->AddPort(NULL);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: pwPerformance->AddPort(NULL) ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Create Graph Object
    // **********************************************************************
    hr = dmthCreateGraph(IID_IDirectMusicGraph, &pCtGraph);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

	// **********************************************************************
    // 4) Call AllocPMsg on pNote and check result
    // **********************************************************************
    hr = pwPerformance->AllocPMsg( sizeof(DMUS_PMSG), &pdmusPMSG );
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->AllocPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

    // **********************************************************************
    // 5.1) Set pUser with a bunch of particulars
    // **********************************************************************	
    pdmusPMSG->dwType   = DMUS_PMSGT_USER; //which is a message the Unique Tool handles
    pdmusPMSG->dwFlags  = DMUS_PMSGF_REFTIME | DMUS_PMSGF_TOOL_ATTIME;
//    pdmusPMSG->dwFlags  = DMUS_PMSGF_REFTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
//    pdmusPMSG->dwFlags  = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
    pdmusPMSG->rtTime   = 0;
	pdmusPMSG->mtTime   = 0;
    pdmusPMSG->punkUser = pTestTool;

    // **********************************************************************
    // 4.1) Create Array of Tools and insert them
    // **********************************************************************
    pCtTools = new LPVOID[dwNumTools];  
    for (dwIndex = 0; dwIndex < ( dwNumTools ); dwIndex++)
    {
        //Create a test tool
        hr = dmthCreateTestTool(IID_IDirectMusicTool, ((CtIDirectMusicTool**)(&pCtTools[dwIndex])) );
        if (FAILED( hr ))
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: dmthCreateTestTool (Tool #%d of %d)"
                    "failed (%s == %08Xh)", dwIndex, dwNumTools, tdmXlatHRESULT(hr), hr);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }
		
		// **********************************************************************
		// 4.2) Check Validity of the tool
		// **********************************************************************
        if (NULL == (&pCtTools[dwIndex]))
        {   
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Something wrong with Tool[%d].  Should not be NULL.",
                                   dwIndex);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }

        hr = ((CtIDirectMusicTool*)(pCtTools[dwIndex]))->QueryInterface(IID_ITDMTESTTOOL, (void**)&pTestTool);
        if (FAILED( hr ))
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: pCtTool->QI for TDMTestTool Failed"
                        "(%s == %08Xh)", tdmXlatHRESULT(hr), hr);
            goto TEST_END;
        }

        pTestTool->m_dwToolID = dwIndex;

	    // **********************************************************************
	    // 4.3) Set each tools m_fLogFlags to log USER PMsgs
	    // **********************************************************************   
	    pTestTool->SetLogFlags(TDMTESTTOOL_PMSGT_USER);

		//To Balance out the Ref
        pTestTool->Release();
        pTestTool = NULL;

        // *************************************************************************
        // 4.4) Insert Tool at Index dwIndex. If last tool, insert at desired index
        // *************************************************************************
        hr = pCtGraph->InsertTool( (CtIDirectMusicTool*)pCtTools[dwIndex], (DWORD*)&pdwPChannels, 6, 0);
        if(FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: Graph->InsertTool "
                    "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
            dwRes = FNS_ABORTED;
            goto TEST_END;
        }
   
	}

   
    // *************************************************************************
    // 4.5) Add Graph to the performance
    // *************************************************************************
	hr = pwPerformance->SetGraph(pCtGraph);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Performance->SetGraph "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }
		

    // *************************************************************************
    // 4.6) Stamp the pMsg
    // *************************************************************************
	hr = pCtGraph->StampPMsg(pdmusPMSG);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Graph->StampPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }


//	Sleep(4000);

    // **********************************************************************
    // X) Call Perf->SendPMsg with Test Tool attached in punkUser of PMsg
    // **********************************************************************
    hr = pwPerformance->SendPMsg(pdmusPMSG);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, "**** ABORT: Perf->SendPMsg "
                "failed (%s == %08Xh)", tdmXlatHRESULT(hr), hr);
        dwRes = FNS_ABORTED;
        goto TEST_END;
    }

	Sleep(2000);

    // **********************************************************************
    // 6) Verify that the each tool was incremented in the USER pmsg
    // **********************************************************************   
    for (dwIndex = 0; dwIndex < ( dwNumTools ); dwIndex++)
    {
		fnsLog(FYILOGLEVEL, "Checking Tool #%d", dwIndex);
        hr = ((CtIDirectMusicTool*)(pCtTools[dwIndex]))->QueryInterface(IID_ITDMTESTTOOL, (void**)&pTestTool);
        if (FAILED( hr ))
        {
            fnsLog(ABORTLOGLEVEL, "**** ABORT: pCtTool->QI for TDMTestTool Failed"
                        "(%s == %08Xh)", tdmXlatHRESULT(hr), hr);
		    dwRes = FNS_FAIL;
            goto TEST_END;
        }
		if(pTestTool->m_dwUserPmsg != 1)
        {
            fnsLog(BUGLOGLEVEL, "!!!! BUG: UserPMsg was not incramented correctly"
                        "(m_dwUserPmsg == %d)(index == %d)", pTestTool->m_dwUserPmsg,dwIndex);
	        dwRes = FNS_FAIL;
            goto TEST_END;
        }
        pTestTool->Release();
        pTestTool = NULL;
	}	
TEST_END:
    // **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	if(pwPerformance)
	{
		pwPerformance->CloseDown();
		pwPerformance->Release();
        pwPerformance = NULL;
	}
    if(pCtGraph)
    {
        pCtGraph->Release();
        pCtGraph = NULL;
    }

    if (pTestTool)
    {
        pTestTool->Release();
        pTestTool = NULL;
    }

    if (pCtTool)
    {
        pCtTool->Release();
        pCtTool = NULL;
    }

    //Nuke the tools
	if ( pCtTools )
	{
		for (dwIndex = 0; dwIndex < (dwNumTools); dwIndex++)
		{
	        if(pCtTools[dwIndex])
			{
	            if (((CtIDirectMusicTool*)pCtTools[dwIndex]))
				{
	                ((CtIDirectMusicTool*)pCtTools[dwIndex])->Release();
					pCtTools[dwIndex] = NULL;
				}
			}
		} 
		delete [] pCtTools;
		pCtTools = NULL;
	}

    dmthCoUninitialize();   
    return dwRes;
}


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::RhythmToTime()_Valid_Test |
//
// Description: <nl>
// Unit test function for IDirectMusicPerformance::RhythmToTime().
//		Compares RhythmToTime and TimeToRhythm using Midi File().
//
// Test Function: <nl>
// tdmperfvRhythmToTimeValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERF.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a Performance Object <nl>
// 3) Load the media <nl>
// 4) Set up the performance to play <nl>
// 5) Play the Segment <nl>
// 6) Get the current MUSIC_TIME <nl>
// 7) Get the current Time Signature using Performance->GetParam <nl>
// 8)Call GetStartTime to get the start of the segment <nl>
// 9)Call TimeToRhythm <nl>
// 10)Call RhythmToTime and compare mtTime with mtTime2 <nl>
// 11)Clean up objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  11/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvRhythmToTimeValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	CtIDirectMusicSegment		*pwSegment		= NULL;
	CtIDirectMusicStyle			*pwStyle		= NULL;
	CtIDirectMusicChordMap		*pwChordMap		= NULL;
	CtIDirectMusicComposer		*pwComposer		= NULL;
	CtIDirectMusicSegmentState	*pwSegState		= NULL;

	MUSIC_TIME					mtTime			= 0;
	MUSIC_TIME					mtTime2			= 0;
	MUSIC_TIME					mtStartTime		= 0;
	WORD						wMeasure		= 0;
	BYTE						bBeat			= 0;
	BYTE						bGrid			= 0;
	SHORT						nOffset			= 0;
	DMUS_TIMESIGNATURE			TimeSig;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Load the media
    // **********************************************************************
	hr = dmthLoadSegment(L"onestop2.mid", &pwSegment);
	if (FAILED(hr))
	{
		fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthLoadSegment")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 5) Call PlaySegment and check results
    // **********************************************************************
	hr = pwPerformance->PlaySegment(pwSegment, 0, 0, &pwSegState);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->PlaySegment() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	Sleep(2000);

    // **********************************************************************
    // 6) Get the current MusicTime
    // **********************************************************************
	hr = pwPerformance->GetTime(NULL, &mtTime);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetTime() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 7) Get the Time Signature
    // **********************************************************************
	hr = pwPerformance->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, &mtStartTime, (void*)&TimeSig);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: IDirectMusicPerformance->GetParam() ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	TimeSig.mtTime += mtTime;
	fnsLog(FYILOGLEVEL, "mtTime == %d\nTimeSig.mtTime == %d", mtTime, TimeSig.mtTime);

    // **********************************************************************
    // 8) Now we'll call TimeToRhythm to populate the TimeSignature
    // **********************************************************************
	hr = pwPerformance->TimeToRhythm(mtTime, &TimeSig, &wMeasure, &bBeat, &bGrid, &nOffset);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  IDirectMusicPerformance->TimeToRhythm() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	fnsLog(FYILOGLEVEL, TEXT("FYI:  \nwMeasures==%d\nbBeat == %d\nbGrid == %d\nnOffset == %d"),
				wMeasure, bBeat, bGrid, nOffset);

	if(!wMeasure && !bBeat && !bGrid && !nOffset)
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  TimeSignature was not set correctly")
				TEXT("wMeasure == %d\nbBeat == %d\nbGrid == %d\nnOffset == %d"),
				wMeasure, bBeat, bGrid, nOffset);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

    // **********************************************************************
    // 9) Call RhythmToTime and check results
    // **********************************************************************
	hr = pwPerformance->RhythmToTime(wMeasure, bBeat, bGrid, nOffset, &TimeSig, &mtTime2);
	if(FAILED(hr))
	{
		fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG:  IDirectMusicPerformance->RhythmToTime() ")
				TEXT("failed (%s == %08Xh)"),
				tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	if(mtTime != mtTime2)
	{

		pwPerformance->TimeToRhythm(mtTime, &TimeSig, &wMeasure, &bBeat, &bGrid, &nOffset);
		pwPerformance->RhythmToTime(wMeasure, bBeat, bGrid, nOffset, &TimeSig, &mtTime2);


		fnsLog(BUGLOGLEVEL, TEXT("mtTime and mtTime2 are not equal\n ")
				TEXT("mtTime == %d\nmtTime2 == %d"),
				mtTime, mtTime2);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 10) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthReleaseSegment(pwSegment);
	dmthReleaseStyle(pwStyle);
	dmthReleaseChordMap(pwChordMap);
	dmthReleaseComposer(pwComposer);
	dmthReleaseSegmentState(pwSegState);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MIDIToMusic()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::MIDIToMusic().
//		Call MIDIToMusic with:
//			A chord containing a key of 0xC, scalepattern of 0xab5ab5, and
//			a subchord with chord pattern 0x81, scale pattern 0x81081, chord
//			root of 0xc, and scale root of 0.  MIDI value of 0x36.  
//		It should return a MusicValue of 0x410f.
//
// Test Function: <nl>
// tdmperfvMIDIToMusicValidTest1 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a Performance Object <nl>
// 3) dmthPrePlay <nl>
// 4) Set DMUS_CHORD_KEY with relevant info <nl>
// 5) Call MIDIToMusic <nl>
// 6) Call MusicToMIDI and make sure we get the right information back <nl>
// 7)Clean up objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  11/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvMIDIToMusicValidTest1(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;
	
	WORD						pwMusicValue;
	DMUS_CHORD_KEY				ChordKey;
	BYTE						pbMidiValue;

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 4) Set DMUS_CHORD_KEY with relevant info
    // **********************************************************************		
	ChordKey.bKey = 0xC;
	ChordKey.dwScale = 0xab5ab5;
	ChordKey.bSubChordCount = 1;
	ChordKey.SubChordList[0].dwChordPattern = 0x81;
	ChordKey.SubChordList[0].dwScalePattern = 0x81081;
	ChordKey.SubChordList[0].bChordRoot = 0xC;
	ChordKey.SubChordList[0].bScaleRoot = 0;
	
	// **********************************************************************
    // 5) Call MIDIToMusic
    // **********************************************************************		
	hr = pwPerformance->MIDIToMusic(0x36, &ChordKey,
									DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS,
									0,
									&pwMusicValue);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->MIDIToMusic ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// Verify that we got the right information
	if(pwMusicValue != 0x420f)
	{
		fnsLog(BUGLOGLEVEL, "pwMusicValue did not return correctly (pwMusicValue == %08X)", pwMusicValue);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

	// **********************************************************************
    // 6) Call MusicToMIDI and make sure we get the right information back
    // **********************************************************************		
	hr = pwPerformance->MusicToMIDI(pwMusicValue, &ChordKey,
									DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS,
									0,
									&pbMidiValue);
	
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->MusicToMIDI ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// Verify that we got the right information
	if(pbMidiValue != 0x36)
	{
		fnsLog(BUGLOGLEVEL, "pbMidiValue did not return correctly (pbMidiValue == %08X)", pbMidiValue);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}

TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================



//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::MIDIToMusic()_Valid_Test |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::MIDIToMusic().
//		Call MIDIToMusic with (truyly) random information for key, scale
//		pattern, subchord, and chord.  Get the Midi Value, and then call
//		MusicToMIDI and verify that we get the same inforamtion back.
//
// Test Function: <nl>
// tdmperfvMIDIToMusicValidTest2 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create a Performance Object <nl>
// 3) Create a Composer Object <nl>
// 4) Load the media <nl>
// 5) Compose the segment <nl>
// 6) Set up the performance to play <nl>
// 7) Play the Segment <nl>
// 8) Get the current MUSIC_TIME <nl>
// 9) Get the current Time Signature <nl>
// 10)Call GetStartTime to get the start of the segment <nl>
// 11)Call TimeToRhythm <nl>
// 12)Call RhythmToTime and compare mtTime with mtTime2 <nl>
// 13)Clean up objects, uninitialize COM and return results <nl>
//
// History: <nl>
//  11/18/1998 - a-llucar - created <nl>
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvMIDIToMusicValidTest2(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes				= FNS_PASS;
	HRESULT						hr					= S_OK;
	CtIDirectMusicPerformance	*pwPerformance		= NULL;
	
	BYTE						bMIDIValue			= 0;
	BYTE						pbMIDIValueResult	= 0;
	WORD						wMusicValue			= 0;
	WORD						pwMusicValueResult	= 0;
	
	DMUS_CHORD_KEY				ChordKey;
	BYTE						bKey				= 0;
	DWORD						dwScale				= 0;
	DWORD						dwChordPattern		= 0;
	DWORD						dwScalePattern		= 0;
	BYTE						bChordRoot			= 0; // 0 - 23
	BYTE						bScaleRoot			= 0; // 0 - 23
	BYTE						bPlayMode			= 0; // 1 - 32
	long						CurrentNum			= 0; // PlaceHolder
	long						Seed				= 0;
	
	BYTE						bMIDIValueInc		= 0;
	BYTE						bPlayModeInc		= 0;
	struct _timeb tstruct;
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicSegment object creation "),
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

	// **********************************************************************
    // 3) dmthPrePlay
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}



	// **********************************************************************
    // 5) Call MIDIToMusic
    // **********************************************************************		
	for (bMIDIValueInc = 0; bMIDIValueInc < 127; bMIDIValueInc++)
	{
	    _ftime( &tstruct );
	    Seed = ((tstruct.millitm) * (tstruct.millitm));		
		fnsLog(CALLLOGLEVEL, "bMIDIValue == %d", bMIDIValueInc);
		Sleep(388);
		srand((unsigned)(Seed));
		fnsLog(CALLLOGLEVEL, "---FYI: Seed == %u", Seed);
		
		ChordKey.bKey = (BYTE)rand();
		ChordKey.dwScale = (DWORD)rand();
		ChordKey.bSubChordCount = 1;
		ChordKey.SubChordList[0].dwChordPattern = (DWORD)rand();//dwChordPattern;
		ChordKey.SubChordList[0].dwScalePattern = (DWORD)rand();//dwScalePattern;
		ChordKey.SubChordList[0].bChordRoot = (BYTE)rand();//bChordRoot;
		ChordKey.SubChordList[0].bScaleRoot = (BYTE)rand();//bScaleRoot;
		bChordRoot = 20;	//0-23
		bScaleRoot = 16;	//0-23

		hr = pwPerformance->MIDIToMusic(bMIDIValueInc,//bMIDIValue,
										&ChordKey,
										0,
										0,
										&pwMusicValueResult);
		if(FAILED(hr))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->MIDIToMusic ")
		            TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}

		// **********************************************************************
		// 6) Call MusicToMIDI and make sure we get the right information back
		// **********************************************************************		
		hr = pwPerformance->MusicToMIDI(pwMusicValueResult, 
										&ChordKey,
										0,
										0,
										&pbMIDIValueResult);
	
		if(FAILED(hr))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: Performance->MusicToMIDI ")
		            TEXT("failed (%s == %08Xh)"), tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}

		// Verify that we got the right information
		if(pbMIDIValueResult != bMIDIValueInc)
		{
			fnsLog(BUGLOGLEVEL, "!!!! BUG: The value we entered didn't come back out\nbMIDIValue == %08Xh\npbMIDIValueResult == %08Xh", bMIDIValueInc, pbMIDIValueResult);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}	
TEST_END:
    // **********************************************************************
    // 7) Cleanup objects and uninitialize COM and Return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGlobalParam()_Valid_Test3 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetGlobalParam(). <nl>
//		Test integrity of setting custom global params.
//
// Test Function: <nl>
// tdmperfvGetGlobalParamValidTest3 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create CtIDirectMusicPerformance object <nl>
// 3) Create a 256 byte buffer, initialized so that each byyte value is it's index into the buffer (0, 1, 2, ... FF)
// 4) Set up the performance
// 5) Call SetGlobalParam with this GUID and buffer
// 6) Call GetGlobalParam with this GUID and a new buffer to receive previous buffer
// 7) Verify data by using a quick For loop and check byte values.
// 8) Clean up
// 
// History: <nl>
//	03/02/1999 - a-llucar - created
//  07/22/1999 - kcraven - fixed test 
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetGlobalParamValidTest3(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

	GUID						customGUID		= {0x4b97c03, 0xd0cd, 0x11d2, 0xa5, 0x65, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1};
	int							i				= 0;

	DWORD						dwSizeOfBuffer	= (DWORD)dwParam1;

	BYTE						*bBuffer;
	BYTE						*bReturn;
	bBuffer						= (BYTE*)malloc(sizeof(BYTE) * dwSizeOfBuffer);
	bReturn						= (BYTE*)malloc(sizeof(BYTE) * dwSizeOfBuffer);

    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	 hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }
    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
    // **********************************************************************
    // 3) Initialize the byte buffer
    // **********************************************************************
	for (i = 0; i < (int)dwSizeOfBuffer; i++)
	{
		bBuffer[i] = (BYTE)(i % 256);
		bReturn[i] = 0;
	}
	// **********************************************************************
    // 4) Init and AddPort
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}
	// **********************************************************************
	// 5) Call SetGlobalParam, check results
	// **********************************************************************
	hr = pwPerformance->SetGlobalParam(customGUID, bBuffer, dwSizeOfBuffer);
	if(FAILED(hr))
	{
	    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
	            TEXT("failed (%s == %08Xh)"),
	            tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
    // 6) Call GetGlobalParam, check results
    // **********************************************************************
	hr = pwPerformance->GetGlobalParam(customGUID, bReturn, dwSizeOfBuffer);
	if(FAILED(hr))
	{
        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_FAIL;
		goto TEST_END;
	}
	// **********************************************************************
    // 7) Verify that the bReturn[i] and bBuffer[i] are the same
    // **********************************************************************
	for (i = 0; i < (int)dwSizeOfBuffer; i++)
	{
		// Check to make sure that the DWORD was properly populated
		if(bBuffer[i] != bReturn[i])
		{
	        fnsLog(BUGLOGLEVEL,
				TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam data not equal! ")
				TEXT("(index == %ld)(%ld != %ld)"),i,bBuffer[i], bReturn[i]);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}	
	}	

TEST_END:
	// **********************************************************************
    // 8) Release objects, CoUninitialize, and return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	free (bBuffer);
	free (bReturn);
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================


//--------------------------------------------------------------------------;
// @doc IDIRECTMUSICPERFORMANCE A-LLUCAR
//
// @topic IDirectMusicPerformance::GetGlobalParam()_Valid_Test4 |
//
// Description: <nl>
// Valid test function for IDirectMusicPerformance::GetGlobalParam(). <nl>
//		Test integrity of setting custom global params.
//
// Test Function: <nl>
// tdmperfvGetGlobalParamValidTest4 <nl>
//
// Parameters: <nl>
//  BOOL    fCoCreate   - unused <nl>
//  BOOL    fMaxDebug   - unused <nl>
//  DWORD   dwParam1    - unused <nl>
//	DWORD   dwParam2    - unused <nl>
//
// File : TDMPERFV.CPP
//
// Steps: <nl>
// 1) Initialize COM. <nl>
// 2) Create 10 GUIDs
// 3) Create 10 buffers - Initialize all byte values to index of buffers (first buffer will contain all 0's,
//    second all 1's, ect.) - use memset for this
// 4) Call SetGlobalParam for each GUID and buffer combination in random order
// 5) Retrieve the GUID's and buffers in random order
// 6) Verify each buffer by it's GUID index
// 7) Clean up
// 
// History: <nl>
//	03/02/1999 - a-llucar - created
//
// @index topic | IDIRECTMUSICPERFORMANCE_CASES
//--------------------------------------------------------------------------;
DWORD tdmperfvGetGlobalParamValidTest4(BOOL fCoCreate, BOOL fMaxDebug, 
						   LPARAM dwParam1, LPARAM dwParam2)
{
	DWORD						dwRes			= FNS_PASS;
	HRESULT						hr				= S_OK;
	CtIDirectMusicPerformance	*pwPerformance	= NULL;

	GUID						customGUID[10] = 
	{
	{0xf29b9152, 0xd287, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x6dc5480, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x16337c60, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x3f3d0270, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x4d54cc20, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x5b5a3f90, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x693f9c10, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x751d6cd0, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x832d9290, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1},
	{0x8c61ddb0, 0xd288, 0x11d2, 0xa5, 0x6f, 0x0, 0x60, 0x8, 0x95, 0xd3, 0xa1}
	};

	BYTE						bBuffer[10];
	BYTE						bReturn[10];

	int							i				= 0;
	
    // **********************************************************************
    // 1) Initialize COM. <nl>
    // **********************************************************************
	hr = dmthCoInitialize(NULL);
    if(FAILED(hr))
    {
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: COM initialization failed! (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
        return FNS_ABORTED;
    }

    // **********************************************************************
    // 2) Create CtIDirectMusicPerformance object 
    // **********************************************************************
    hr = dmthCreatePerformance(IID_IDirectMusicPerformance, &pwPerformance);
	if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: DirectMusicPerformance object creation ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}

    // **********************************************************************
    // 3) Initialize the two buffers (setting bReturn[i] to something else
    // **********************************************************************
	for (i = 0; i < 10; i++)
	{
		bBuffer[i] = ((i * 10) + i);
		bReturn[i] = 125;
	}

	// **********************************************************************
    // 4) Init and AddPort
    // **********************************************************************		
	hr = dmthPrePlay(&pwPerformance);
    if(FAILED(hr))
	{
        fnsLog(ABORTLOGLEVEL, TEXT("**** ABORT: dmthPrePlay ")
                TEXT("failed (%s == %08Xh)"),
                tdmXlatHRESULT(hr), hr);
		dwRes = FNS_ABORTED;
		goto TEST_END;
	}


	for (i = 0; i <10; i = i + 2)
	{
		// **********************************************************************
		// 5) Call SetGlobalParam, check results
		// **********************************************************************
		hr = pwPerformance->SetGlobalParam(customGUID[i], &bBuffer[i], sizeof(BYTE));
		if(FAILED(hr))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
		            TEXT("failed (%s == %08Xh)"),
		            tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	for (i = 1; i < 10; i = i + 2)
	{
		// **********************************************************************
		// 5) Call SetGlobalParam, check results
		// **********************************************************************
		hr = pwPerformance->SetGlobalParam(customGUID[i], &bBuffer[i], sizeof(BYTE));
		if(FAILED(hr))
		{
		    fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->SetGlobalParam ")
		            TEXT("failed (%s == %08Xh)"),
		            tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	}
	for (i = 9; i >= 0; i--)
	{
		// **********************************************************************
	    // 6) Call GetGlobalParam, check results
	    // **********************************************************************
		hr = pwPerformance->GetGlobalParam(customGUID[i], &bReturn[i], sizeof(BYTE));
		if(FAILED(hr))
		{
	        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam ")
	                TEXT("failed (%s == %08Xh)"),
	                tdmXlatHRESULT(hr), hr);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}
	
		// Check to make sure that the DWORD was properly populated
		if(bReturn[i] != ((i * 10) + i))
		{
	        fnsLog(BUGLOGLEVEL, TEXT("!!!! BUG: IDirectMusicPerformance->GetGlobalParam\n ")
	                TEXT("pData was not properly set\n")
	                TEXT("Expected -- bBuffer == %ld\n")
					TEXT("Received -- bReturn == %ld\n"),
					((i * 10) + i), bReturn[i]);
			dwRes = FNS_FAIL;
			goto TEST_END;
		}	
	}	

TEST_END:
	// **********************************************************************
    // 7) Release objects, CoUninitialize, and return results
    // **********************************************************************
	dmthReleasePerformance(pwPerformance);
	
	dmthCoUninitialize();	
	return dwRes;
}
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\unused\CICMusic.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       CICMusic.h
//
//--------------------------------------------------------------------------

//===========================================================================
//	CICMusic.h
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//	History:
//		03/09/2000 - danhaff/ruswoods - created
//      04/25/2000 - danhaff - added another Init() to specify whether we
//                             create an APATH_SHARED_ENV before
//                             creating the user-specified path.
//      01/05/2001 - danhaff - Ported to XBox.
//===========================================================================
#include <dmusici.h>

#pragma once 

#define GF_AUDIOPATH        1
#define GF_SEGMENT8         2
#define GF_SEGMENTSTATE8    4




class CICMusic
{

protected:
    IDirectSound                    *m_pDirectSound;
    IDirectMusic                  *m_pDirectMusic;
    IDirectMusicLoader8           *m_pLoader8;
    IDirectMusicPerformance8      *m_pPerformance8;
    IUnknown                      *m_pUnkAudioPathConfig;
    IDirectMusicAudioPath         *m_pAudioPath;
    IDirectMusicAudioPath         *m_pAudioPathEnv;
    IDirectMusicSegment8          *m_pSegment8;
    IDirectMusicSegmentState8     *m_pSegmentState8;
    IDirectMusicSegmentState      *m_pSegmentState;
//    HWND                             m_hWnd;
    BOOL                             m_bCOMInitialized;

public :
    // *************************************************************
    CICMusic(void);

    // *************************************************************
	~CICMusic(void);

    // *************************************************************
	HRESULT Init      (LPCWSTR wszSegment,
                      DWORD dwDefaultPathType,
  //                    DWORD dwUseAPathEnv,
                      DWORD dwPChannelCount = 16);

    // *************************************************************
    HRESULT Init      (LPCWSTR wszSegment,
                      LPCWSTR wszConfig);//,
    //                  DWORD dwUseAPathEnv);

    // *************************************************************
    HRESULT Shutdown(void);

    // *************************************************************
	HRESULT GetInterface(IDirectSound **ppDirectSound);
    
    // *************************************************************
	HRESULT GetInterface(IDirectMusic **pptDirectMusic);

    // *************************************************************
	HRESULT GetInterface(IDirectMusicLoader8 **pptLoader8);

    // *************************************************************
	HRESULT GetInterface(IDirectMusicPerformance8 **pptPerformance8);

    // *************************************************************
	HRESULT GetInterface(IUnknown **pptUnkAudioPathConfig);

    // *************************************************************
	HRESULT GetInterface(IDirectMusicAudioPath **pptAudioPath);

    // *************************************************************
    HRESULT GetInterface(IDirectMusicSegment8** pptSegment8);
    
    // *************************************************************
    HRESULT GetInterface(IDirectMusicSegmentState** pptSegmentState);

    // *************************************************************
    HRESULT GetInterface(IDirectMusicSegmentState8** pptSegmentState8);

    // *************************************************************
    HRESULT GetAudioPathEnv(IDirectMusicAudioPath **pptAudioPathEnv);


private:
    // *************************************************************
    HRESULT PrivateInitialize(LPCWSTR wszSegment,
                                 LPCWSTR wszConfig,
                                 DWORD dwDefaultPathType,
//                                 DWORD dwUseAPathEnv,
                                 DWORD dwPChannelCount
                                 );
    // *************************************************************
    HRESULT PrivateUninitialize(void);



};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\unused\CICMusic.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       CICMusic.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// CICMusic.cpp
// Provides initialization and cleanup behavior for basic DirectMusic functionality
// Specifically, an IDirectMusic, IDirectMusicLoader, and IDirectMusicPerformance.
//
//
// Functions:
//
//
//	History:
//		03/09/2000 - danhaff/ruswoods - created
//      03/27/2000 - danhaff - Made Init call UnInit first, fixed bugs
//      08/29/2000 - danhaff - Removed instances of DYNAMIC_APATH_ENV3D
//      01/05/2001 - danhaff - Ported to XBox.
//
/////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "cicmusic.h"


//--------------------------------------------------------------------------;
// Description: <nl>
// Constructor for CICMusic
//
//
// Parameters: <nl>
//   hWnd: hWnd of our window.
//
// Notes:
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
CICMusic::CICMusic(void)
:
m_pDirectSound (NULL),
m_pDirectMusic (NULL),
m_pLoader8 (NULL),
m_pPerformance8 (NULL),
m_pAudioPath (NULL),
m_pAudioPathEnv (NULL),
m_pUnkAudioPathConfig (NULL),
m_pSegment8(NULL),
m_pSegmentState8(NULL),
m_pSegmentState(NULL),
//m_hWnd (ghWnd),
m_bCOMInitialized(FALSE)
{
    //What are you looking at?
};


//--------------------------------------------------------------------------;
// Description: <nl>
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init
(
LPCWSTR wszSegment,
DWORD dwDefaultPathType,
//DWORD dwUseAPathEnv,
DWORD dwPChannelCount)
{
    HRESULT hr;

    __try
    {
        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;
        
        //Now perform our initialization.
        hr = PrivateInitialize(wszSegment, NULL, dwDefaultPathType, /*dwUseAPathEnv,*/ dwPChannelCount);
        if (S_OK != hr)
            __leave;
    }
    __finally
    {
    }

    return hr;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Init(
LPCWSTR wszSegment,
LPCWSTR wszConfig)//,
//DWORD dwUseAPathEnv)
{
    HRESULT hr;
    __try
    {
        //First uninitialize anything we've initialized, so we don't leave dangling pointers.
        hr = PrivateUninitialize();
        if (S_OK != hr)
            __leave;

        //Now perform our initialization.
        hr = PrivateInitialize(wszSegment,              //Specified segment.
                               wszConfig,               //Specified AP config file.
                               NULL,                    //Don't use a standard path type.
                               //dwUseAPathEnv,    //Whether to create teh APATH_ENV
                               0);                      //pChannels don't matter cuz we're using file.
        if (S_OK != hr)
            __leave;

    }
    __finally
    {
    }
    return hr;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//   Shutdowns the class, just like the destructor.  I added this
//   because sometimes you want to shut it down early.
//
// Notes:
//
// History: <nl>
//		03/27/2000 - danhaff - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::Shutdown(void)
{
    HRESULT hr;
    hr = PrivateUninitialize();
    return hr;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Destructor for CICMusic
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
CICMusic::~CICMusic ()
{
    PrivateUninitialize();
}



//--------------------------------------------------------------------------;
// Description: <nl>
// Initialization function for CICMusic, called by both constructors.
//
//
// Parameters: <nl>
//
// Notes:
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateInitialize(
LPCWSTR wszSegment,
LPCWSTR wszConfig,
DWORD dwDefaultPathType,
//DWORD dwUseAPathEnv,
DWORD dwPChannelCount
)
{
HRESULT hr;
IDirectMusicPerformance8 *pPerformance8 = NULL;

    __try
    {
        //Verify that one of the correct types of standardpaths was passed, if any.
        if (dwDefaultPathType != 0                                  &&
            dwDefaultPathType != DMUS_APATH_SHARED_STEREOPLUSREVERB &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_3D              &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_STEREO          &&
            dwDefaultPathType != DMUS_APATH_DYNAMIC_MONO            
            )
        {
            fnsLog(ABORTLOGLEVEL, ALL, "**** TEST APP ERROR:  Someone passed an invalid value for dwDefaultPathType!!");
            __leave;
        }

/*
        //Call this pointless function.
        if (!m_bCOMInitialized)
        {
            dmthCoInitialize(NULL);
            m_bCOMInitialized = TRUE;
        }
*/

        //Create performance
        DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance8,(void**)&m_pPerformance8 );
	    if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: CreatePerformance returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
            __leave;

        }

	    //Create a new Loader8.
        DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader8,(void**)&m_pLoader8 );
	    if (S_OK != hr)
	    {
            fnsLog(ABORTLOGLEVEL, ALL, "**** ERROR: CICMusic: CreateLoader returned (%s == %08Xh)",
                    tdmXlatHRESULT(hr), hr);
            __leave;
	    }

        //Make loader aware of everything in media directory.
        //  Note: This may return S_FALSE because it didn't find files of the specified type - that is okay,

/*
        hr = SearchAndScanAllMedia((IDirectMusicLoader *)m_pLoader8);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, ALL, "**** ERROR: SearchAndScanAllMedia returned (%s == %08Xh)",
                    tdmXlatHRESULT(hr), hr);
            __leave;
        }
*/

        //This call should always succeed.
        hr = m_pLoader8->SetSearchDirectory(GUID_DirectMusicAllTypes, gwszMediaPath, FALSE);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL, ALL, "**** ERROR: CICMusic: IDirectMusicLoader8::SetSearchDirectory failed!!");
            __leave;
        }


        //Initaudio, but w/o setting a default path.
        //hr = m_pPerformance8->InitAudio (&m_pDirectMusic, &m_pDirectSound, m_hWnd, NULL, NULL, NULL, NULL);
        hr = m_pPerformance8->InitAudio (&m_pDirectMusic, &m_pDirectSound, NULL, NULL, NULL, NULL, NULL);
        if (S_OK != hr)
        {
            // Log failure
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: Perf8->InitAudio returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
            __leave;
        }

        //If we pass in an audiopath config file, make that the default path, otherwise choose
        //  and standard default path.  This decision was made by which constructor to use.
        if (wszConfig)
        {

            //Load up the audiopath config.
            //There is no actual interface for this; we use the IUnknown interface
            //  for this object.
            hr = m_pLoader8->LoadObjectFromFile(CLSID_DirectMusicAudioPathConfig,
                                                 CTIID_IUnknown,
                                                 (WCHAR *)wszConfig,
                                                 (void **)&m_pUnkAudioPathConfig);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
    			TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load audiopath config %ls!! (%s == %08Xh)"),
			    PathFindFileNameW(wszConfig),
                tdmXlatHRESULT(hr), hr);
                __leave;
            }

            //Make that audiopath config into a real audiopath
            hr = m_pPerformance8->CreateAudioPath(m_pUnkAudioPathConfig, TRUE, &m_pAudioPath);
    	    if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
			    TEXT("**** ABORT:  CICMusic: Perf8->CreateAudioPath failed from loaded config file %ls!! (%s == %08Xh)"),
			    wszConfig, tdmXlatHRESULT(hr), hr);
                __leave;
            }

        }
        else
        {
            //Call CreateStandardAudioPath.
            hr = m_pPerformance8->CreateStandardAudioPath(dwDefaultPathType, dwPChannelCount, TRUE, &m_pAudioPath);
            if (S_OK != hr)
            {
                fnsLog(ABORTLOGLEVEL,
			    TEXT("**** ABORT:  CICMusic: Perf8->CreateStandardAudioPath returned (%s == %08Xh)"),
			    tdmXlatHRESULT(hr), hr);
                __leave;
            }            
        }


        //Set the audiopath we created as the default.
        hr = m_pPerformance8->SetDefaultAudioPath(m_pAudioPath);
    	if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: Perf8->SetDefaultAudioPath failed from file %ls!! (%s == %08Xh)"),
			wszConfig, tdmXlatHRESULT(hr), hr);
            __leave;
        }

        // Load the segment.
        hr = m_pLoader8->LoadObjectFromFile(CLSID_DirectMusicSegment,
                                        CTIID_IDirectMusicSegment8,
                                        (WCHAR *)wszSegment,
                                        (void **)&m_pSegment8);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicLoader8->LoadObjectFromFile failed to load segment %ls!! (%s == %08Xh)"),
            PathFindFileNameW(wszSegment),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Tell the segment to repeat forever.
        hr = m_pSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicSegment8->SetRepeats(DMUS_SEG_REPEAT_INFINITE) returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Get the real Performance8 ptr from the performance, so we can pass it to SetParam.
        hr = m_pPerformance8->GetRealObjPtr(&pPerformance8);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicPerformance8->GetRealObjPtr returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }

        //Cause the correct instruments to be downloaded.
        hr = m_pSegment8->Download((IUnknown *)m_pAudioPath);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicSegment8->Download returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }


        //Play the segment on the default audio path, and get the segment state.
        hr = m_pPerformance8->PlaySegmentEx((IUnknown *)m_pSegment8,
                                            NULL,                   //no segment id, this isn't a song
                                            NULL,                   //no transition to compose
                                            NULL,                   //no DMUS_SEGF flags
                                            0,                      //time to start playback (right away)
                                            &m_pSegmentState,     //returned segment state
                                            NULL,                   //no segstate to replace
                                            NULL);                  //play on default audiopath.
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: IDirectMusicPerformance8->PlaySegmentEx returned (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }


        //Get a SegmentState8 also, since it's more useful and what we'll be testing.
        hr = dmthQueryInterface8(&m_pSegmentState, &m_pSegmentState8);
        if (S_OK != hr)
        {
            fnsLog(ABORTLOGLEVEL,
			TEXT("**** ABORT:  CICMusic: QI'ing SegmentState8 from SegmentState returned. (%s == %08Xh)"),
			tdmXlatHRESULT(hr), hr);
                __leave;
        }
    }
    __finally
    {
        //Release the only thing we allocated locally during this function.
        SAFE_RELEASE(pPerformance8);

        //If init failed, release all members.
        if (S_OK != hr)
            PrivateUninitialize();
    }

return hr;
};






//--------------------------------------------------------------------------;
// Description: <nl>
//  Frees up everything in the object.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::PrivateUninitialize(void)
{
    //Might as well have the return value somewhere.
    HRESULT hr = S_OK;

    //Unload what we downloaded.
    if (m_pAudioPath && m_pSegment8)
    {
        hr = m_pSegment8->Unload((IUnknown *)m_pAudioPath);
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
		    TEXT("**** WARNING!!! POSSIBLE MEMORY LEAK, CONTACT KCRAVEN OR DANHAFF:  CICMusic: IDirectMusicSegment8->Unload returned (%s == %08Xh)"),
		    tdmXlatHRESULT(hr), hr);
        }
    }

    //Release all the interfaces we've stashed, except the performance which must be Closed down and
    //  released last.
	SAFE_RELEASE (m_pSegmentState);
	SAFE_RELEASE (m_pSegmentState8);
    SAFE_RELEASE (m_pSegment8);
    SAFE_RELEASE (m_pAudioPath);
    SAFE_RELEASE (m_pAudioPathEnv);
    SAFE_RELEASE (m_pUnkAudioPathConfig);
	SAFE_RELEASE (m_pLoader8);
	SAFE_RELEASE (m_pDirectMusic);
    SAFE_RELEASE (m_pDirectSound);

    //Performance must ALWAYS be closed down last.
	if (m_pPerformance8)
    {
		hr = m_pPerformance8->CloseDown();
        if (FAILED(hr))
        {
            fnsLog(ABORTLOGLEVEL,
		    TEXT("**** WARNING!!! CONTACT KCRAVEN OR DANHAFF:  CICMusic: IDirectMusicPerformance8->CloseDown() returned (%s == %08Xh)"),
		    tdmXlatHRESULT(hr), hr);
        }
    }

    //Finally release the performance.
	SAFE_RELEASE (m_pPerformance8);


    //Undo whatever happened in dmthCoInitialize()
    if (m_bCOMInitialized)
    {
        dmthCoUninitialize();
        m_bCOMInitialized = FALSE;
    }

    return hr;
};



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetDirectSound
//
// Parameters: <nl>
//      ppDirectSound: contains address of pointer to contain unwrapped IDirectSound.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectSound ** ppDirectSound)
{
    if (ppDirectSound && m_pDirectSound)
    {
        *ppDirectSound = m_pDirectSound;
        m_pDirectSound->AddRef();
        return S_OK;
    }
    else if (!ppDirectSound)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//      GetDirectMusic
//
// Parameters: <nl>
//      pptDirectMusic: contains address of pointer to contain wrapped IDirectMusic.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusic** pptDirectMusic)
{
    if (pptDirectMusic && m_pDirectMusic)
    {
        *pptDirectMusic = m_pDirectMusic;
        m_pDirectMusic->AddRef();
        return S_OK;
    }
    else if (!pptDirectMusic)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetLoader8
//
// Parameters: <nl>
//      pptLoader8: contains address of pointer to contain wrapped IDirectMusicLoader8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicLoader8** pptDirectMusicLoader8)
{
    if (pptDirectMusicLoader8 && m_pLoader8)
    {
        *pptDirectMusicLoader8 = m_pLoader8;
        m_pLoader8->AddRef();
        return S_OK;
    }
    else if (!pptDirectMusicLoader8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//  Gets the performance object, which must be created upon initialization.
//
// Parameters: <nl>
//      pptPerformance8: contains address of pointer to contain wrapped IDirectMusicPerformance8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicPerformance8 **pptPerformance8 )
{
    if (pptPerformance8 && m_pPerformance8)
    {
        *pptPerformance8 = m_pPerformance8;
        m_pPerformance8->AddRef();
        return S_OK;
    }
    else if (!pptPerformance8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;

};




//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped IDirectMusicAudioPath.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicAudioPath** pptAudioPath)
{
    if (pptAudioPath && m_pAudioPath)
    {
        *pptAudioPath= m_pAudioPath;
        m_pAudioPath->AddRef();
        return S_OK;
    }
    else if (!pptAudioPath)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}


//--------------------------------------------------------------------------;
// Description: <nl>
//      GetAudioPathConfig
//
// Parameters: <nl>
//      pptUnkAudioPathConfig: contains address of pointer to contain wrapped IDirectMusicAudioPathConfig.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IUnknown ** pptUnkAudioPathConfig)
{
    if (pptUnkAudioPathConfig && m_pUnkAudioPathConfig)
    {
        *pptUnkAudioPathConfig= m_pUnkAudioPathConfig;
        m_pUnkAudioPathConfig->AddRef();
        return S_OK;
    }
    else if (!pptUnkAudioPathConfig)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegment8
//
// Parameters: <nl>
//      pptSegment8: contains address of pointer to contain wrapped IDirectMusicSegment8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicSegment8** pptSegment8)
{
    if (pptSegment8 && m_pSegment8)
    {
        *pptSegment8 = m_pSegment8;
        m_pSegment8->AddRef();
        return S_OK;
    }
    else if (!pptSegment8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}

//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegmentState8
//
// Parameters: <nl>
//      pptSegmentState8: contains address of pointer to contain wrapped IDirectMusicSegmentState8.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicSegmentState8** pptSegmentState8)
{
    if (pptSegmentState8 && m_pSegmentState8)
    {
        *pptSegmentState8 = m_pSegmentState8;
        m_pSegmentState8->AddRef();
        return S_OK;
    }
    else if (!pptSegmentState8)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}



//--------------------------------------------------------------------------;
// Description: <nl>
//      GetSegmentState
//
// Parameters: <nl>
//      pptSegmentState: contains address of pointer to contain wrapped IDirectMusicSegmentState.
//
// History: <nl>
//		03/09/2000 - danhaff/ruswoods - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetInterface(IDirectMusicSegmentState** pptSegmentState)
{
    if (pptSegmentState && m_pSegmentState)
    {
        *pptSegmentState = m_pSegmentState;
        m_pSegmentState->AddRef();
        return S_OK;
    }
    else if (!pptSegmentState)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}




//--------------------------------------------------------------------------;
// Description: <nl>
//      GetEnvironmentPath
//
// Parameters: <nl>
//      pptAudioPath: contains address of pointer to contain wrapped
//      IDirectMusicAudioPath.
//
// History: <nl>
//		05/06/2000 - danhaff - created
//--------------------------------------------------------------------------;
HRESULT CICMusic::GetAudioPathEnv(IDirectMusicAudioPath **pptAudioPathEnv)
{
    if (pptAudioPathEnv && m_pAudioPathEnv)
    {
        *pptAudioPathEnv = m_pAudioPathEnv;
        m_pAudioPathEnv->AddRef();
        return S_OK;
    }
    else if (!pptAudioPathEnv)
    {
        return E_POINTER;
    }

    return OLE_E_BLANK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\unused\shlwapiLocal.h ===
#pragma once
//LPWSTR PathFindFileNameW(LPWSTR pPath);
/*
BOOL PathIsDirectory(LPCTSTR pszPath);
STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath);
STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot);
BOOL PathIsUNCServer(LPCTSTR pszPath);
STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath);
STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot);
STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile);
STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath);
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile);
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmtest1\unused\shlwapiLocal.cpp ===
//===========================================================================
// SHLWAPILOCAL.CPP
//
//  Because there are no good path functions in SHLWAPI, and because
//  that DLL isn't on Win95, and because we have to run our tests on Win95,
//  I have no choice but to copy that code in here and statically link it.
//
//===========================================================================
//#include "dmcs.h"
#include "globals.h"
#include "shlwapilocal.h"



#define TEXTW(quote) L##quote      

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

//danhaff - guessed this myself.
#define CH_WHACK TEXT('\\')

#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#define DBNotNULL(p)    (p)

void NearRootFixups (LPTSTR lpszPath, BOOL fUNC);

#define OFFSETOF(x)     ((UINT)(x))

/*
LPTSTR StrChr (LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

*/

LPWSTR PathFindFileNameW(LPWSTR pPath)
{
    LPWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}



/*
LPTSTR StrChr(LPTSTR lpsz, TCHAR ch)
{
    LPTSTR p = NULL;
    while (*lpsz)
    {
        if (*lpsz == ch)
        {
            p = lpsz;
            break;
        }
        lpsz = CharNext(lpsz);
    }
    return p;
}


BOOL ChrCmp(WORD w1, WORD wMatch)
{
  // Most of the time this won't match, so test it first for speed.
   //
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
        {
          return(w1 != wMatch);
        }
      return FALSE;
    }
  return TRUE;
}



LPSTR FAR PASCAL StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlen(lpStart);

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmp(*(WORD FAR *)lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}


LPCTSTR GetPCEnd(LPCTSTR lpszStart)
{
    LPCTSTR lpszEnd;

    lpszEnd = StrChr((char *)lpszStart, CH_WHACK);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }

    return lpszEnd;
}




//
// Given a pointer to the end of a path component, return a pointer to
// its begining.
// ie return a pointer to the previous backslash (or start of the string).
//
LPCTSTR PCStart(LPCTSTR lpszStart, LPCTSTR lpszEnd)
{
    LPCTSTR lpszBegin = StrRChr(lpszStart, lpszEnd, CH_WHACK);
    if (!lpszBegin)
    {
        lpszBegin = lpszStart;
    }
    return lpszBegin;
}





static __inline BOOL DBL_BSLASH(LPCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}


BOOL PathIsUNC(LPCTSTR pszPath)
{
    return DBL_BSLASH(pszPath);
}

__inline BOOL PathIsUNC(
    LPWSTR psz)
{
    return (psz[0] == L'\\' && psz[1] == L'\\');
}




BOOL PathIsUNCServer(LPCTSTR pszPath)
{
    if (DBL_BSLASH(pszPath))
    {
        int i = 0;
        LPTSTR szTmp;

        for (szTmp = (LPTSTR)pszPath; szTmp && *szTmp; szTmp = CharNext(szTmp) )
        {
            if (*szTmp==TEXT('\\'))
            {
                i++;
            }
        }

       return (i == 2);
    }

    return FALSE;
}



BOOL PathIsDirectory(LPCTSTR pszPath)
{
    DWORD dwAttribs;

    // SHELL32's PathIsDirectory also handles server/share
    // paths, but calls WNet APIs, which we cannot call.

    if (PathIsUNCServer(pszPath))
    {
        return FALSE;
    }
    else
    {
        dwAttribs = GetFileAttributes(pszPath);
        if (dwAttribs != (DWORD)-1)
            return (BOOL)(dwAttribs & FILE_ATTRIBUTE_DIRECTORY);
    }

    return FALSE;
}















STDAPI_(BOOL) PathIsRelative(LPCTSTR lpszPath)
{
//    RIPMSG(lpszPath && IS_VALID_STRING_PTR(lpszPath, -1), "PathIsRelative: caller passed bad lpszPath");

    if (!lpszPath || *lpszPath == 0)
    {
        // The NULL path is assumed relative
        return TRUE;
    }


    if (lpszPath[0] == CH_WHACK)
    {
        // Does it begin with a slash ?
        return FALSE;
    }
    else if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':'))
    {
        // Does it begin with a drive and a colon ?
        return FALSE;
    }
    else
    {
        // Probably relative.
        return TRUE;
    }
}














STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath)
{

    if (lpszPath)
    {
        LPTSTR lpszEnd;

        // perf: avoid lstrlen call for guys who pass in ptr to end
        // of buffer (or rather, EOB - 1).
        // note that such callers need to check for overflow themselves.
        int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

        // try to keep us from tromping over MAX_PATH in size.
        // if we find these cases, return NULL.  Note: We need to
        // check those places that call us to handle their GP fault
        // if they try to use the NULL!
        if (ichPath >= (MAX_PATH - 1))
        {
            return(NULL);
        }

        lpszEnd = lpszPath + ichPath;

        // this is really an error, caller shouldn't pass
        // an empty string
        if (!*lpszPath)
            return lpszEnd;

        // Get the end of the source directory
        switch(*CharPrev(lpszPath, lpszEnd))
        {
            case CH_WHACK:
                break;

            default:
                *lpszEnd++ = CH_WHACK;
                *lpszEnd = TEXT('\0');
        }

        return lpszEnd;
    }

    return NULL;
}





STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot)
{
    if (szRoot)
    {
        while(!PathIsRoot(szRoot))
        {
            if (!PathRemoveFileSpec(szRoot))
            {
                // If we didn't strip anything off,
                // must be current drive
                return(FALSE);
            }
        }

        return(TRUE);
    }
    return(FALSE);
}







STDAPI_(LPTSTR) PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPCTSTR lpszFile)
{

    if (lpszDest && (lpszDir || lpszFile))
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR pszT;

        if (!lpszFile || *lpszFile==TEXT('\0'))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));       // lpszFile is empty
        }
        else if (lpszDir && *lpszDir && PathIsRelative(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                int iLen = lstrlen(szTemp);

                if ((iLen + lstrlen(lpszFile)) < ARRAYSIZE(szTemp))
                    lstrcpy(pszT, lpszFile);
                else
                    return NULL;
            }
            else
            {
                return NULL;
            }
        }
        else if (lpszDir && *lpszDir && *lpszFile == CH_WHACK && !PathIsUNC(lpszFile))
        {
            lstrcpyn(szTemp, lpszDir, ARRAYSIZE(szTemp));
            // Note that we do not check that an actual root is returned;
            // it is assumed that we are given valid parameters
            PathStripToRoot(szTemp);

            pszT = PathAddBackslash(szTemp);
            if (pszT)
            {
                // Skip the backslash when copying
                // Note: We don't support strings longer than 4GB, but that's
                // okay because we already barf at MAX_PATH
                lstrcpyn(pszT, lpszFile+1, ARRAYSIZE(szTemp) - 1 - (int)(pszT-szTemp));
            }
            else
            {
                return NULL;
            }

        }
        else 
        {
            lstrcpyn(szTemp, lpszFile, ARRAYSIZE(szTemp));     // already fully qualified file part
        }

        PathCanonicalize(lpszDest, szTemp); // this deals with .. and . stuff
    }

    return lpszDest;
}




STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath)
{

    if (!pPath || !*pPath)
    {
        return FALSE;
    }

    if (!IsDBCSLeadByte(*pPath))
    {
        if (!lstrcmpi(pPath + 1, TEXT(":\\")))
        {
            // "X:\" case
            return TRUE;
        }
    }

    if ((*pPath == CH_WHACK) && (*(pPath + 1) == 0))
    {
        // "/" or "\" case
        return TRUE;
    }

    if (DBL_BSLASH(pPath))      // smells like UNC name
    {
        LPCTSTR p;
        int cBackslashes = 0;

        for (p = pPath + 2; *p; p = FAST_CharNext(p))
        {
            if (*p == TEXT('\\') && (++cBackslashes > 1))
            {
               // not a bare UNC name, therefore not a root dir 
               return FALSE;
            }
        }
        return TRUE;    // end of string with only 1 more backslash 
                        // must be a bare UNC, which looks like a root dir 
    }
    return FALSE;
}




STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = FAST_CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}



//----------------------------------------------------------
Purpose: Canonicalize a path.

Returns:
Cond:    --
//
STDAPI_(BOOL) PathCanonicalize(LPTSTR lpszDst, LPCTSTR lpszSrc)
{
    LPCTSTR lpchSrc;
    LPCTSTR lpchPCEnd;      // Pointer to end of path component.
    LPTSTR lpchDst;
    BOOL fUNC;
    int cbPC;


    if (!lpszDst || !lpszSrc)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //DEBUGWhackPathBuffer(lpszDst, MAX_PATH);
    
    fUNC = PathIsUNC(lpszSrc);    // Check for UNCness.

    // Init.
    lpchSrc = lpszSrc;
    lpchDst = lpszDst;

    while (*lpchSrc)
    {
        // REVIEW: this should just return the count
        lpchPCEnd = GetPCEnd(lpchSrc);
        cbPC = (int) (lpchPCEnd - lpchSrc)+1;

        if (cbPC == 1 && *lpchSrc == CH_WHACK)                                      // Check for slashes.
        {
            // Just copy them.
            *lpchDst = CH_WHACK;
            lpchDst++;
            lpchSrc++;
        }
        else if (cbPC == 2 && *lpchSrc == TEXT('.'))                                // Check for dots.
        {
            // Skip it...
            // Are we at the end?
            if (*(lpchSrc+1) == TEXT('\0'))
            {
                lpchDst--;
                lpchSrc++;
            }
            else
            {
                lpchSrc += 2;
            }
        }
        else if (cbPC == 3 && *lpchSrc == TEXT('.') && *(lpchSrc + 1) == TEXT('.')) // Check for dot dot.
        {
            // make sure we aren't already at the root
            if (!PathIsRoot(lpszDst))
            {
                // Go up... Remove the previous path component.
                lpchDst = (LPTSTR)PCStart(lpszDst, lpchDst - 1);
            }
            else
            {
                // When we can't back up, remove the trailing backslash
                // so we don't copy one again. (C:\..\FOO would otherwise
                // turn into C:\\FOO).
                if (*(lpchSrc + 2) == CH_WHACK)
                {
                    lpchSrc++;
                }
            }

            // skip ".."
            lpchSrc += 2;       
        }
        else                                                                        // Everything else
        {
            // Just copy it.
            lstrcpyn(lpchDst, lpchSrc, cbPC);
            lpchDst += cbPC - 1;
            lpchSrc += cbPC - 1;
        }

        // Keep everything nice and tidy.
        *lpchDst = TEXT('\0');
    }

    // Check for weirdo root directory stuff.
    NearRootFixups(lpszDst, fUNC);

    return TRUE;
}



//
// Fix up a few special cases so that things roughly make sense.
//
void NearRootFixups (LPTSTR lpszPath, BOOL fUNC)
{
    // Check for empty path.
    if (lpszPath[0] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[0] = CH_WHACK;
        lpszPath[1] = TEXT('\0');
    }
    // Check for missing slash.
    if (!IsDBCSLeadByte(lpszPath[0]) && lpszPath[1] == TEXT(':') && lpszPath[2] == TEXT('\0'))
    {
        // Fix up.
        lpszPath[2] = TEXT('\\');
        lpszPath[3] = TEXT('\0');
    }
    // Check for UNC root.
    if (fUNC && lpszPath[0] == TEXT('\\') && lpszPath[1] == TEXT('\0'))
    {
        // Fix up.
        //lpszPath[0] = TEXT('\\'); // already checked in if guard
        lpszPath[1] = TEXT('\\');
        lpszPath[2] = TEXT('\0');
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctaudpth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctaudpth.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctaudpth.cpp
//
// Test harness implementation of IDirectMusicAudioPath
//
// Functions:
//  CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::InitTestClass()
//  CtIDirectMusicAudioPath::GetRealObjPtr()
//  CtIDirectMusicAudioPath::QueryInterface()
//  CtIDirectMusicAudioPath::GetObjectInPath()
//  CtIDirectMusicAudioPath::ConvertPChannel()
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================

#include "globals.h"


//===========================================================================
// CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//
// Default constructor
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::CtIDirectMusicAudioPath(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicAudioPath";

} //*** end CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath(void)
{
    // nothing to do

} //*** end CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicAudioPath *pdmAudioPath - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::InitTestClass(IDirectMusicAudioPath *pdmAudioPath)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmAudioPath, sizeof(IDirectMusicAudioPath), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmAudioPath));

} //*** end CtIDirectMusicAudioPath::InitTestClass()


//===========================================================================
// CtIDirectMusicAudioPath::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicAudioPath **ppdmAudioPath - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmAudioPath, sizeof(IDirectMusicAudioPath*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmAudioPath));

} //*** end CtIDirectMusicAudioPath::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicAudioPath::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicAudioPath::QueryInterface()


//===========================================================================
// CtIDirectMusicAudioPath::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  12/17/1999 - kcraven - created
//  04/04/200 - kcraven - sync to dmusic changes
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetObjectInPath(
	DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void ** ppObject)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_ppObject			= TRUE;
    char    szGuidObj[MAX_LOGSTRING];
    char    szGuidIID[MAX_LOGSTRING];

    dmthGUIDtoString(guidObject, szGuidObj);
    dmthGUIDtoString(iidInterface, szGuidIID);

    if(!helpIsValidPtr((void*)ppObject, sizeof(void**), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppObject = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannel      == %08Xh%s",
								dwPChannel,
                                dwPChannel==DMUS_PCHANNEL_ALL ? " (DMUS_PCHANNEL_ALL)":"");
	fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
								dwStage, dmthXlatDMUS_STAGE(dwStage));
	fnsLog(PARAMLOGLEVEL, "dwBuffer      == %08Xh",
								dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject == %s (%s)",
								szGuidObj, dmthXlatGUID(guidObject));
	fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
								dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
								szGuidIID, dmthXlatGUID(iidInterface));
    fnsLog(PARAMLOGLEVEL, "ppObject == %p   %s",
								ppObject,
								(fValid_ppObject) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->GetObjectInPath(
												dwPChannel,
												dwStage,
												dwBuffer,
												guidObject,
												dwIndex,
												iidInterface,
												ppObject
												);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppObject)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
				ppObject);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::GetObjectInPath()


//===========================================================================
// CtIDirectMusicAudioPath::Activate()
//
// Encapsulates calls to Activate
//
// Parameters:
//  fActivate: True to activate, False to deactivate.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::Activate(BOOL fActivate)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "fActivate == %s", fActivate ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->Activate(fActivate);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    return hRes;


}

//===========================================================================
// CtIDirectMusicAudioPath::SetVolume()
//
// Encapsulates calls to SetVolume
//
// Parameters:
//  
//  lVolume:   Gain, in 100ths of a dB.
//  dwDuration Duration of volume ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::SetVolume(long lVolume, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVolume()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lVolume == %d", lVolume);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->SetVolume(lVolume, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVolume()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}



//===========================================================================
// CtIDirectMusicAudioPath::SetPitch()
//
// Encapsulates calls to SetPitch
//
// Parameters:
//  
//  lPitch:    Pitch bend, in 100ths of a semitone.
//  dwDuration Duration of Pitch ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::SetPitch(long lPitch, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetPitch()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lPitch == %d", lPitch);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->SetPitch(lPitch, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetPitch()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}



                                           




//===========================================================================
// CtIDirectMusicAudioPath::ConvertPChannel()
//
// Encapsulates calls to ConvertPChannel
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicAudioPath::ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    if(!helpIsValidPtr((void*)pdwPChannelOut, sizeof(DWORD), FALSE))
    {
        // bogus pointer, use as such
        fValid_pdwPChannelOut = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ConvertPChannel()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannelIn   == %08Xh",
								dwPChannelIn);
    fnsLog(PARAMLOGLEVEL, "pdwPChannelOut == %p   %s",
								pdwPChannelOut,
								(fValid_pdwPChannelOut) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->ConvertPChannel(dwPChannelIn,pdwPChannelOut);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ConvertPChannel()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_pdwPChannelOut)
	{
    	fnsLog(PARAMLOGLEVEL, "*pdwPChannelOut == %p",
				*pdwPChannelOut);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::ConvertPChannel()

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctobjct8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctobject8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctobject8.cpp
//
// Test harness implementation of IDirectMusicObject8
//
// Functions:
//  CtIDirectMusicObject8::Zombie();
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================

#include "globals.h"

//===========================================================================
// CtIDirectMusicObject8::CtIDirectMusicObject8()
//
// Default constructor
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================
CtIDirectMusicObject8::CtIDirectMusicObject8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicObject8";

//	m_bZombie = FALSE; //special BOOL for testing Zombie

} // ** end CtIDirectMusicObject8::CtIDirectMusicObject8()


//===========================================================================
// CtIDirectMusicObject8::~CtIDirectMusicObject8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================
CtIDirectMusicObject8::~CtIDirectMusicObject8(void)
{
    // nothing to do

} // ** end CtIDirectMusicObject8::~CtIDirectMusicObject8()


//===========================================================================
// CtIDirectMusicObject8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject8 pointer for future use.
//
// Parameters:
//  IDirectMusicObject8 *pdmObject8 - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicObject8::InitTestClass(IDirectMusicObject8 *pdmObject8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmObject8, sizeof(IDirectMusicObject8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmObject8));

} // ** end CtIDirectMusicObject8::InitTestClass()


//===========================================================================
// CtIDirectMusicObject8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicObject8 **ppdmObject8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicObject8::GetRealObjPtr(IDirectMusicObject8 **ppdmObject8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmObject8, sizeof(IDirectMusicObject8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmObject8));

} // ** end CtIDirectMusicObject8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicObject8::Zombie()
//
// Encapsulates calls to Zombie()
//
// History:
//  01/28/2000 - kcraven - created
//===========================================================================
/*
void CtIDirectMusicObject8::Zombie(void)
{                                           


    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Zombie()",
            m_szInterfaceName);

    // call the real function
    ((IDirectMusicObject8*)m_pUnk)->Zombie();

	m_bZombie = TRUE; //special BOOL for testing Zombie

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Zombie()",
            m_szInterfaceName);

    fnsDecrementIndent();

    // done
    return;

} // ** end CtIDirectMusicObject8::Zombie()
*/


//===========================================================================
// CtIDirectMusicObject::GetDescriptor()
//
// Encapsulates calls to GetDescriptor()
//
// History:
//  12/28/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//	07/21/1998 - t-jwex  - fValid_pDesc now set to false when desc==NULL
//===========================================================================
HRESULT CtIDirectMusicObject8::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->GetDescriptor(pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::GetDescriptor()



//===========================================================================
// CtIDirectMusicObject::SetDescriptor()
//
// Encapsulates calls to SetDescriptor()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//===========================================================================
HRESULT CtIDirectMusicObject8::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->SetDescriptor(pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::SetDescriptor()



//===========================================================================
// CtIDirectMusicObject::ParseDescriptor()
//
// Encapsulates calls to ParseDescriptor()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//	07/20/1998 - t-jwex  - fValid_pDesc now set to false when desc==NULL
//===========================================================================
HRESULT CtIDirectMusicObject8::ParseDescriptor(LPSTREAM pStream, 
                                              LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;
	BOOL				fValid_pStream		= TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

	// validate pStream
    if(!helpIsValidPtr(pStream, sizeof(BYTE), TRUE))
    {
        fValid_pStream = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ParseDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStream == %p   %s",
            pStream,
            (fValid_pStream) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->ParseDescriptor(pStream, pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ParseDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::ParseDescriptor()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctband8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctband8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctband8.cpp
//
// Test harness implementation of IDirectMusicBand8
//
// Functions:
//  CtIDirectMusicBand8::DownloadEx();     
//  CtIDirectMusicBand8::UnloadEx();  
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
 
#include "globals.h"

//===========================================================================
// CtIDirectMusicBand8::CtIDirectMusicBand8()
//
// Default constructor
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
CtIDirectMusicBand8::CtIDirectMusicBand8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicBand8";

} // *** end CtIDirectMusicBand8::CtIDirectMusicBand8()


//===========================================================================
// CtIDirectMusicBand8::~CtIDirectMusicBand8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
CtIDirectMusicBand8::~CtIDirectMusicBand8(void)
{
    // nothing to do

} // *** end CtIDirectMusicBand8::~CtIDirectMusicBand8()


//===========================================================================
// CtIDirectMusicBand8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicBand8 *pdmBand - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicBand8::InitTestClass(IDirectMusicBand8 *pdmBand8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmBand8, sizeof(IDirectMusicBand8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmBand8));
		
} // *** end CtIDirectMusicBand8::InitTestClass()


//===========================================================================
// CtIDirectMusicBand8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicBand8 **ppdmBand - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicBand8::GetRealObjPtr(IDirectMusicBand8 **ppdmBand8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmBand8, sizeof(IDirectMusicBand8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmBand8));

} // *** end CtIDirectMusicBand8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicBand8::DownloadEx()
//
// Encapsulates calls to DownloadEx()
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicBand8::DownloadEx(CtIUnknown *pAudioPath)
{                                           
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IUnknown*	pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath,sizeof(CtIUnknown), FALSE))
    {
        fValid_pAudioPath = FALSE;
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::DownloadEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBand8*)m_pUnk)->DownloadEx(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::DownloadEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicBand8::DownloadEx()


//===========================================================================
// CtIDirectMusicBand8::UnloadEx()
//
// Encapsulates calls to UnloadEx()
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicBand8::UnloadEx(CtIUnknown *pAudioPath)
{                                           
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IUnknown*	pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, 
                    sizeof(CtIUnknown), FALSE))
    {
        fValid_pAudioPath = FALSE;
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::UnloadEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBand8*)m_pUnk)->UnloadEx(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL,  "--- Returned from %s::UnloadEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicBand8::UnloadEx()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctcollec.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctcollec.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctcollec.cpp
//
// Test harness implementation of IDirectMusicCollection
//
// Functions:
//  CtIDirectMusicCollection::CtIDirectMusicCollection()
//  CtIDirectMusicCollection::~CtIDirectMusicCollection()
//  CtIDirectMusicCollection::InitTestClass()
//  CtIDirectMusicCollection::GetRealObjPtr()
//  CtIDirectMusicCollection::QueryInterface()
//  CtIDirectMusicCollection::AddRef()
//  CtIDirectMusicCollection::Release()
//  CtIDirectMusicCollection::GetInstrument()
//  CtIDirectMusicCollection::EnumInstrument()
//
// History:
//  10/24/1997 - davidkl - created
//  12/23/1997 - a-llucar - added GetInstrumentPatch, GetNumInstruments 
//  01/09/1998 - a-llucar - removed GetInstrumentPatch, GetNumInstrument, 
//                          added EnumInstrument
//  03/29/1998 - davidkl - brave new world... implemented as a derrived class
//===========================================================================

#include "globals.h"
//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicCollection::CtIDirectMusicCollection()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
CtIDirectMusicCollection::CtIDirectMusicCollection()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicCollection";

} //*** end CtIDirectMusicCollection::CtIDirectMusicCollection()


//===========================================================================
// CtIDirectMusicCollection::~CtIDirectMusicCollection()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
CtIDirectMusicCollection::~CtIDirectMusicCollection(void)
{
    // nothing to do

} //*** emd CtIDirectMusicCollection::~CtIDirectMusicCollection()


//===========================================================================
// CtIDirectMusicCollection::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicCollection object pointer for future use.
//
// Parameters:
//  IDirectMusicCollection *pdmCollect - pointer to real IDirectMusicCollection 
//                                      object
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicCollection::InitTestClass(IDirectMusicCollection *pdmCollect)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmCollect, sizeof(IDirectMusicCollection), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmCollect));

} //*** end CtIDirectMusicCollection::InitTestClass()


//===========================================================================
// CtIDirectMusicCollection::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicCollection **ppdmCollect - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	10/24/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicCollection::GetRealObjPtr(IDirectMusicCollection **ppdmCollect)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmCollect, sizeof(IDirectMusicCollection*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmCollect));

} //*** end CtIDirectMusicCollection::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicCollection::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicCollection::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicCollection::QueryInterface()


//===========================================================================
// CtIDirectMusicCollection::GetInstrument
//
// Encapsulates calls to GetInstrument
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetInstrument
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicCollection::GetInstrument(DWORD dwPatch, 
                                            CtIDirectMusicInstrument **pptdmInst)
{
    HRESULT                 hRes                = E_NOTIMPL;
    BOOL                    fValid_pptdmInst    = TRUE;
    IDirectMusicInstrument  *pdmInstrument      = NULL;
    IDirectMusicInstrument  **ppdmInstrument    = NULL;

    // validate pptdmInst
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicInstrument pointer, 
    //  we assume that we are to perform an invalid parameter test on 
    //  IDirectMusicCollection::GetInstrument().  Otherwise, we are to 
    //  create and return a CtIDirectMusicInstrument object
    if(!helpIsValidPtr((void*)pptdmInst, 
                        sizeof(CtIDirectMusicInstrument*),
                        FALSE))
    {
        fValid_pptdmInst = FALSE;

        // we have a bad pointer, use as the real thing
        ppdmInstrument = (IDirectMusicInstrument**)pptdmInst;
    }
    else
    {
        // valid pointer, create a real object
        ppdmInstrument = &pdmInstrument;

        // just in case we fail, init test object ptr to NULL
        *pptdmInst = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwPatch           == %08Xh",
            dwPatch);
    fnsLog(PARAMLOGLEVEL, "ppdmInstrument    == %p   %s",
            ppdmInstrument,
            fValid_pptdmInst ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicCollection*)m_pUnk)->GetInstrument(dwPatch, ppdmInstrument);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmInst)
    {
        fnsLog(PARAMLOGLEVEL, "*ppdmInstrument == %p",
            pdmInstrument);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmInstrument, pptdmInst);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmInst && pdmInstrument)
    {
        pdmInstrument->Release();
    }
    return hRes;

} //*** end CtIDirectMusicCollection::GetInstrument()


//===========================================================================
// CtIDirectMusicCollection::EnumInstrument
//
// Encapsulates calls to EnumInstrument
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to EnumInstrument
//
// History:
//  10/24/1997 - davidkl - created
//  03/29/1998 - davidkl - fixed ptr validation bug
//===========================================================================
HRESULT CtIDirectMusicCollection::EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, 
												 LPWSTR pName, DWORD cwchName)
{
    HRESULT                 hRes                = E_NOTIMPL;
    BOOL                    fValid_pdwPatch	    = TRUE;
	BOOL					fValid_pName		= TRUE;
    
	if(!helpIsValidPtr((void*)pdwPatch, sizeof(DWORD), FALSE))
    {
        fValid_pdwPatch = FALSE;
	}

//	can be NULL - don't check
//	if(!helpIsValidPtr((void*)pName, sizeof(WCHAR), FALSE))
//	{
//		fValid_pName = FALSE;
//	}

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pdwPatch == %p   %s",
            pdwPatch,
            fValid_pdwPatch ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pName == %08Xh",pName);
//    fnsLog(PARAMLOGLEVEL, "pName == %p   %s",
//          pName,
//          fValid_pName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "cwchName == %08Xh",
            cwchName);

    // call the real function
    hRes = ((IDirectMusicCollection*)m_pUnk)->EnumInstrument(dwIndex, 
                                                            pdwPatch, 
                                                            pName, 
                                                            cwchName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicCollection::EnumInstrument()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctband.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctband.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctband.cpp
//
// Test harness implementation of IDirectMusicBand
//
// Functions:
//  CtIDirectMusicBand::QueryInterface()
//  CtIDirectMusicBand::CreateSegment()
//  CtIDirectMusicBand::Download()
//  CtIDirectMusicBand::Unlaod()
//  CtIDirectMusicBand::GetFlags()
//
// History:
//  01/06/1997 - a-llucar - created
//  03/30/1998 - davidkl - brave new world... now inherits from CtIUnknown
//===========================================================================
 
#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicBand::CtIDirectMusicBand()
//
// Default constructor
//
// History:
//  01/05/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicBand::CtIDirectMusicBand(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicBand";

} //*** end CtIDirectMusicBand::CtIDirectMusicBand()


//===========================================================================
// CtIDirectMusicBand::~CtIDirectMusicBand()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/05/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicBand::~CtIDirectMusicBand(void)
{
    // nothing to do

} //*** end CtIDirectMusicBand::~CtIDirectMusicBand()


//===========================================================================
// CtIDirectMusicBand::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicBand *pdmBand - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/05/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicBand::InitTestClass(IDirectMusicBand *pdmBand)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmBand, sizeof(IDirectMusicBand), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmBand));
		
} //*** end CtIDirectMusicBand::InitTestClass()


//===========================================================================
// CtIDirectMusicBand::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicBand **ppdmBand - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/05/1997 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicBand::GetRealObjPtr(IDirectMusicBand **ppdmBand)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmBand, sizeof(IDirectMusicBand*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmBand));

} //*** end CtIDirectMusicBand::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicBand::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/05/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicBand::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicBand::QueryInterface


//===========================================================================
// CtIDirectMusicBand::CreateSegment()
//
// Encapsulates calls to CreateSegment()
//
// History:
//  01/05/1997 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes, enhanced logging
//===========================================================================
HRESULT CtIDirectMusicBand::CreateSegment(CtIDirectMusicSegment** pptdmSegment)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pptdmSegment = TRUE;
    IDirectMusicSegment *pdmSeg             = NULL;
    IDirectMusicSegment **ppdmSeg           = NULL;

    // validate pptdmSegment
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicBand::CreateSegment().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSegment, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSegment = FALSE;
        ppdmSeg = (IDirectMusicSegment**)pptdmSegment;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSeg = &pdmSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSegment = NULL;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreateSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppSegment == %p   %s",
            ppdmSeg,
            fValid_pptdmSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBand*)m_pUnk)->CreateSegment(ppdmSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CreateSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
                pdmSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSeg, pptdmSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh",
                    hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmSegment && pdmSeg)
    {
        pdmSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicBand::CreateSegment()
 

//===========================================================================
// CtIDirectMusicBand::Download()
//
// Encapsulates calls to Download()
//
// History:
//  01/05/1997 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes
//  04/02/1998 - davidkl - fixed ref. leak
//===========================================================================
HRESULT CtIDirectMusicBand::Download(CtIDirectMusicPerformance* ptdmPerformance)
{                                           
    HRESULT                 hRes                    = E_NOTIMPL;
    BOOL                    fValid_ptdmPerformance  = TRUE;
    IDirectMusicPerformance *pdmPerf                = NULL;

    // validate ptdmPerformance
    if(!helpIsValidPtr((void*)ptdmPerformance, 
                    sizeof(CtIDirectMusicPerformance), FALSE))
    {
        fValid_ptdmPerformance = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerformance;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerformance->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerformance == %p   %s",
            pdmPerf,
            fValid_ptdmPerformance ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBand*)m_pUnk)->Download(pdmPerf);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerformance && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicBand::Download()


//===========================================================================
// CtIDirectMusicBand::Unload()
//
// Encapsulates calls to Unload()
//
// History:
//  01/05/1997 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes
//  04/02/1998 - davidkl - fixed ref. leak
//===========================================================================
HRESULT CtIDirectMusicBand::Unload(CtIDirectMusicPerformance* ptdmPerformance)
{                                           
    HRESULT                 hRes                    = E_NOTIMPL;
    BOOL                    fValid_ptdmPerformance  = TRUE;
    IDirectMusicPerformance *pdmPerf                = NULL;

    // validate ptdmPerformance
    if(!helpIsValidPtr((void*)ptdmPerformance, 
                    sizeof(CtIDirectMusicPerformance), FALSE))
    {
        fValid_ptdmPerformance = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerformance;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerformance->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerformance == %p   %s",
            pdmPerf,
            fValid_ptdmPerformance ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBand*)m_pUnk)->Unload(pdmPerf);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerformance && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicBand::Unload()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctgraph.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctgraph.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctgraph.cpp
//
// Test harness implementation of IDirectMusicGraph
//
// Functions:
//  CtIDirectMusicGraph::CtIDirectMusicGraph()
//  CtIDirectMusicGraph::~CtIDirectMusicGraph()
//  CtIDirectMusicGraph::InitTestClass()
//  CtIDirectMusicGraph::GetRealObjPtr()
//  CtIDirectMusicGraph::QueryInterface()
//  CtIDirectMusicGraph::StampPMsg()
//  CtIDirectMusicGraph::InsertTool()
//  CtIDirectMusicGraph::GetTool()
//  CtIDirectMusicGraph::RemoveTool()
//
// History:
//  01/02/1998 - a-llucar - created
//  02/11/1998 - a-llucar - added InsertTool(), Shutdown() 
//  03/31/1998 - davidkl - inheritance update
//  09/26/1998 - a-llucar - removed Shutdown()
//===========================================================================

#include "globals.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicGraph::CtIDirectMusicGraph()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicGraph::CtIDirectMusicGraph(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicGraph";

} //*** end CtIDirectMusicGraph::CtIDirectMusicGraph()


//===========================================================================
// CtIDirectMusicGraph::~CtIDirectMusicGraph()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicGraph::~CtIDirectMusicGraph(void)
{
    // nothing to do

} //*** end CtIDirectMusicGraph::~CtIDirectMusicGraph()


//===========================================================================
// CtIDirectMusicGraph::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmGraph - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicGraph::InitTestClass(IDirectMusicGraph *pdmGraph)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmGraph, sizeof(IDirectMusicGraph), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmGraph));

} //*** end CtIDirectMusicGraph::InitTestClass()


//===========================================================================
// CtIDirectMusicGraph::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicGraph **ppdmGraph - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicGraph::GetRealObjPtr(IDirectMusicGraph **ppdmGraph)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmGraph, sizeof(IDirectMusicGraph*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmGraph));

} //*** end CtIDirectMusicGraph::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicGraph::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicGraph::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicGraph::QueryInterface


//===========================================================================
// CtIDirectMusicGraph::StampPMsg()
//
// Encapsulates calls to StampPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicGraph::StampPMsg(DMUS_PMSG* pPMSG)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_pPMSG    = TRUE;
    
    // validate pPipelineEvent
    if(!helpIsValidPtr((void*)pPMSG, sizeof(DMUS_PMSG), FALSE))
    {
        fValid_pPMSG	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::StampPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }

    // call the real function
    hRes = ((IDirectMusicGraph*)m_pUnk)->StampPMsg(pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::StampPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicGraph::StampPMsg()


//===========================================================================
// CtIDirectMusicGraph::InsertTool()
//
// Encapsulates calls to InsertTool
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicGraph::InsertTool(CtIDirectMusicTool* ptdmTool,
									    DWORD* pdwPChannels, 
                                        DWORD cPChannel,
										LONG lIndex)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL				fValid_ptdmTool		= TRUE;
    BOOL				fValid_pdwPChannels	= TRUE;
    IDirectMusicTool    *pdmTool            = NULL;

    // validate ptdmTool
    if(!helpIsValidPtr((void*)ptdmTool, sizeof(CtIDirectMusicTool), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTool = FALSE;
        pdmTool = (IDirectMusicTool*)ptdmTool;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTool->GetRealObjPtr(&pdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pdwPChannels
    if(!helpIsValidPtr((void*)pdwPChannels, sizeof(DWORD), FALSE))
    {
        fValid_pdwPChannels	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::InsertTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTool        == %p   %s",
            pdmTool,
            fValid_ptdmTool ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwPChannels == %p   %s",
            pdwPChannels,
            fValid_pdwPChannels ? "" : "BAD");
    if(fValid_pdwPChannels)
    {
        // BUGBUG log contents of pdwPChannels array @ MAXLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "cPChannel    == %08Xh",
            cPChannel);
    fnsLog(PARAMLOGLEVEL, "lIndex       == %08Xh",
            lIndex);

    // call the real function
    hRes = ((IDirectMusicGraph*)m_pUnk)->InsertTool(pdmTool, pdwPChannels, 
                                cPChannel, lIndex);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::InsertTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmTool && pdmTool)
    {
        pdmTool->Release();
    }    
    return hRes;

}
//*** end CtIDirectMusicGraph::InsertTool()


//===========================================================================
// CtIDirectMusicGraph::GetTool()
//
// Encapsulates calls to GetTool
//
// History:
//  04/03/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGraph::GetTool(DWORD dwIndex, 
                                    CtIDirectMusicTool **pptdmTool)
{
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pptdmTool    = TRUE;
    IDirectMusicTool    *pdmTool            = NULL;
    IDirectMusicTool    **ppdmTool          = NULL;

    //validate pptdmTool
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicTool pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicGraph::GetTool().  Otherwise, we are to create and
    //  return a CtIDirectMusicTool object
    if(!helpIsValidPtr((void*)pptdmTool, sizeof(CtIDirectMusicTool*),
        FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTool = FALSE;
        ppdmTool = (IDirectMusicTool**)pptdmTool;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTool = &pdmTool;

        // just in case we fail, init test object ptr to NULL
        *pptdmTool = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "ppTool  == %p   %s",
            ppdmTool,
            fValid_pptdmTool ? "" : "BAD");

    // call the real thing
    hRes = ((IDirectMusicGraph*)m_pUnk)->GetTool(dwIndex, ppdmTool);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(pptdmTool)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTool == %08Xh",
                pdmTool);
    }

    //create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTool, pptdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    //done
    if(fValid_pptdmTool && pdmTool)
    {
        pdmTool->Release();
    }
    return hRes;

} //*** end CtIDirectMusicGraph::GetTool()


//===========================================================================
// CtIDirectMusicGraph::RemoveTool()
//
// Encapsulates calls to RemoveTool
//
// History:
//  04/03/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGraph::RemoveTool(CtIDirectMusicTool *ptdmTool)
{
    HRESULT             hRes            = E_NOTIMPL;
    BOOL                fValid_ptdmTool = TRUE;
    IDirectMusicTool    *pdmTool        = NULL;

    // validate ptdmTool
    if(!helpIsValidPtr((void*)ptdmTool, sizeof(CtIDirectMusicTool), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTool = FALSE;
        pdmTool = (IDirectMusicTool*)ptdmTool;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTool->GetRealObjPtr(&pdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::RemoveTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTool == %p   %s",
            pdmTool,
            fValid_ptdmTool ? "" : "BAD");

    // call the real thing
    hRes = ((IDirectMusicGraph*)m_pUnk)->RemoveTool(pdmTool);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::RemoveTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    //done
END:
    if(fValid_ptdmTool && pdmTool)
    {
        pdmTool->Release();
    }
    return hRes;

} //*** end CtIDirectMusicGraph::RemoveTool()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctloadr8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctloadr8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctloadr8.cpp
//
// Test harness implementation of IDirectMusicLoader8
//
// Functions:
//	CtIDirectMusicLoader8::EnableGarbageCollector()
//	CtIDirectMusicLoader8::CollectGarbage()
//	CtIDirectMusicLoader8::ReleaseObjectByUnknown()
//	CtIDirectMusicLoader8::GetDynamicallyReferencedObject()
//	CtIDirectMusicLoader8::ReportDynamicallyReferencedObject()
//	CtIDirectMusicLoader8::LoadObjectFromFile()
//
// History:
//  01/24/2000 - kcraven - created
//  02/08/2000 - kcraven - matched changes to dmusic headers
//  02/18/2000 - kcraven - added LoadObjectFromFile - commented out
//===========================================================================
#include "globals.h"

//===========================================================================
// CtIDirectMusicLoader8::CtIDirectMusicLoader8()
//
// Default constructor
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
CtIDirectMusicLoader8::CtIDirectMusicLoader8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicLoader8";

} // ** end CtIDirectMusicLoader8::CtIDirectMusicLoader8()


//===========================================================================
// CtIDirectMusicLoader8::~CtIDirectMusicLoader8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
CtIDirectMusicLoader8::~CtIDirectMusicLoader8(void)
{
    // nothing to do

} // ** end CtIDirectMusicLoader8::~CtIDirectMusicLoader8()


//===========================================================================
// CtIDirectMusicLoader8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmLoader - pointer to real object
//
// Returns: 
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::InitTestClass(IDirectMusicLoader8 *pdmLoader8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmLoader8, sizeof(IDirectMusicLoader8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmLoader8));

} // ** end CtIDirectMusicLoader8::InitTestClass()


//===========================================================================
// CtIDirectMusicLoader8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicLoader8 **ppdmLoader - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::GetRealObjPtr(IDirectMusicLoader8 **ppdmLoader8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmLoader8, sizeof(IDirectMusicLoader8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmLoader8));

} // ** end CtIDirectMusicLoader8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicLoader8::GetObject()
//
// Encapsulates calls to GetObject()  This version of GetObject is quite a
//  bit smarter than previous incarnations -- it uses internal TDMUSIC IIDs
//  to determine when and which wrapped object to return (if we pass in an
//  actual DirectMusic IID, it returns an UNWRAPPED object).
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  06/24/1998 - davidkl - created
//  11/24/1999 - kcraven - added object wrapping
//  03/17/2000 - kcraven - added more object wrapping
//===========================================================================
HRESULT CtIDirectMusicLoader8::GetObject(LPDMUS_OBJECTDESC pDesc,
                                        REFIID riid,
                                        void** ppv)
{
    HRESULT hRes            = E_NOTIMPL;
    HRESULT hWrapRes        = E_NOTIMPL;
	BOOL    fValid_ppv      = TRUE;
	BOOL    fValid_pDesc    = TRUE;
    IID     riidReal;
    char    szIID[MAX_LOGSTRING];
	BOOL	bWrapObject		= TRUE;

	void**						ppdmv			= NULL;			

	IUnknown*					pdmUnknown		= NULL;
	IUnknown**					ppdmUnknown		= NULL;

	IDirectMusicObject8*		pdmObject		= NULL;
	IDirectMusicObject8**		ppdmObject		= NULL;

//	IDirectMusicBand*			pdmBand			= NULL;
//	IDirectMusicBand**			ppdmBand		= NULL;

//	IDirectMusicCollection*		pdmCollection	= NULL;
//	IDirectMusicCollection**	ppdmCollection	= NULL;

//	IDirectMusicChordMap*		pdmChordMap		= NULL;
//	IDirectMusicChordMap**		ppdmChordMap	= NULL;

//	IDirectMusicStyle*			pdmStyle		= NULL;
//	IDirectMusicStyle**			ppdmStyle		= NULL;

	IDirectMusicSegment8*		pdmSegment8		= NULL;
	IDirectMusicSegment8**		ppdmSegment8	= NULL;

//	IDirectMusicStyle8*			pdmStyle8		= NULL;
//	IDirectMusicStyle8**		ppdmStyle8		= NULL;

	IDirectMusicScript*			pdmScript		= NULL;
	IDirectMusicScript**		ppdmScript		= NULL;

	//IDirectMusicContainer*		pdmContainer	= NULL;
//	IDirectMusicContainer**		ppdmContainer	= NULL;

//	IDirectMusicSong*			pdmSong			= NULL;
//	IDirectMusicSong**			ppdmSong		= NULL;

//	IDirectSoundWave*			pdmWave			= NULL;
//	IDirectSoundWave**			ppdmWave		= NULL;

//	IDirectMusicGraph*			pdmGraph		= NULL;
//	IDirectMusicGraph**			ppdmGraph		= NULL;


    // validate ppv
    if(!helpIsValidPtr((void*)ppv, sizeof(void*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppv = FALSE;
    }

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

    // determine which IID we >really< want to use
    if(IsEqualIID(CTIID_IUnknown, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IUnknown, 
                    sizeof(GUID));
		ppdmUnknown = &pdmUnknown;
		ppdmv = (void**)ppdmUnknown;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicObject, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicObject, 
                    sizeof(GUID));
		ppdmObject = &pdmObject;
		ppdmv = (void**)ppdmObject;
		*ppv = NULL;
    }
/*
    else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicBand, 
                    sizeof(GUID));
		ppdmBand = &pdmBand;
		ppdmv = (void**)ppdmBand;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicCollection, 
                    sizeof(GUID));
		ppdmCollection = &pdmCollection;
		ppdmv = (void**)ppdmCollection;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicChordMap, 
                    sizeof(GUID));
		ppdmChordMap = &pdmChordMap;
		ppdmv = (void**)ppdmChordMap;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle, 
                    sizeof(GUID));
		ppdmStyle = &pdmStyle;
		ppdmv = (void**)ppdmStyle;
		*ppv = NULL;
    }

*/
    else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment8, 
                    sizeof(GUID));
		ppdmSegment8 = &pdmSegment8;
		ppdmv = (void**)ppdmSegment8;
		*ppv = NULL;
    }

/*
    else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle8, 
                    sizeof(GUID));
		ppdmStyle8 = &pdmStyle8;
		ppdmv = (void**)ppdmStyle8;
		*ppv = NULL;
    }
*/
	else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicScript, 
                    sizeof(GUID));
		ppdmScript = &pdmScript;
		ppdmv = (void**)ppdmScript;
		*ppv = NULL;
    }

/*
    else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicContainer, 
                    sizeof(GUID));
		ppdmContainer = &pdmContainer;
		ppdmv = (void**)ppdmContainer;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSong, 
                    sizeof(GUID));
		ppdmSong = &pdmSong;
		ppdmv = (void**)ppdmSong;
		*ppv = NULL;
    }
*/
/*
//PHOOPHOO
    else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectSoundWave, 
                    sizeof(GUID));
		ppdmWave = &pdmWave;
		ppdmv = (void**)ppdmWave;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicGraph, 
                    sizeof(GUID));
		ppdmGraph = &pdmGraph;
		ppdmv = (void**)ppdmGraph;
		*ppv = NULL;
    }
*/
	else
    {
        // trust that the loader is going to recognize this and we don't want it wrapped
		bWrapObject = FALSE;
        CopyMemory((void*)&riidReal, 
                    (void*)&riid, 
                    sizeof(GUID));
		ppdmv = ppv;
    }

    dmthGUIDtoString(riidReal, szIID);

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObject()", 
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }
    fnsLog(PARAMLOGLEVEL, "riid  == %s (%s)",
            szIID, dmthXlatGUID(riidReal));
    fnsLog(PARAMLOGLEVEL, "ppv   == %p   %s",
			ppdmv,
			fValid_ppv ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader*)m_pUnk)->GetObject(pDesc, 
                                                    riidReal, 
                                                    ppdmv);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppv)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppv == %p",
				*ppdmv);

		//we succeeded and we want to wrap the object and we got an object
		if(SUCCEEDED(hRes) && bWrapObject && *ppdmv)
		{
			// determine which IID we >really< want to use
			if(IsEqualIID(CTIID_IDirectMusicObject, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmObject,(CtIDirectMusicObject**)ppv);
				pdmObject->Release();
			}
			else if(IsEqualIID(CTIID_IUnknown, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmUnknown,(CtIUnknown**)ppv);
				pdmUnknown->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmBand,(CtIDirectMusicBand**)ppv);
				pdmBand->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmCollection,(CtIDirectMusicCollection**)ppv);
				pdmCollection->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmChordMap,(CtIDirectMusicChordMap**)ppv);
				pdmChordMap->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSegment,(CtIDirectMusicSegment**)ppv);
				pdmSegment->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmStyle,(CtIDirectMusicStyle**)ppv);
				pdmStyle->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmStyle8,(CtIDirectMusicStyle8**)ppv);
				pdmStyle8->Release();
			}
*/
			else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSegment8,(CtIDirectMusicSegment8**)ppv);
				pdmSegment8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmScript,(CtIDirectMusicScript**)ppv);
				pdmScript->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmContainer,(CtIDirectMusicContainer**)ppv);
				pdmContainer->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmSong,(CtIDirectMusicSong**)ppv);
				pdmSong->Release();
			}
*/
/*
//PHOOPHOO
			else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmWave,(CtIDirectSoundWave**)ppv);
				pdmWave->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
			{
				hWrapRes = dmthCreateTestWrappedObject(pdmGraph,(CtIDirectMusicGraph**)ppv);
				pdmGraph->Release();
			}
*/
			else
			{
				hWrapRes = E_FAIL; //don't support wrapping this interface
			}

			if(FAILED(hWrapRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hWrapRes);
				hRes = E_FAIL; //don't support wrapping this interface
			}
		}

	}

	fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader8::GetObject()


//===========================================================================
// CtIDirectMusicLoader8::SetObject(LPDMUS_OBJECTDESC pDesc)
//
// Encapsulates calls to SetObject()
//
// History:
//  10/13/1998 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::SetObject(LPDMUS_OBJECTDESC pDesc)
{
	HRESULT hRes = E_NOTIMPL;
	BOOL fValid_pDesc = TRUE;

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

	fnsIncrementIndent();
	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::SetObject()", 
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "pDesc    == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader*)m_pUnk)->SetObject(pDesc);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);

	fnsDecrementIndent();

    return hRes;

} //*** end CtIDirectMusicLoader8::SetObject()
 

//===========================================================================
// CtIDirectMusicLoader8::SetSearchDirectory()
//
// Encapsulates calls to SetSearchDirectory()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/26/1998 - davidkl - fixed logging and param validation code
//  03/30/1998 - davidkl - added fClear parameter
//===========================================================================
HRESULT CtIDirectMusicLoader8::SetSearchDirectory(GUID idClass, 
                                                CHAR *pzPath,
                                                BOOL fClear)
{                                           
    HRESULT hRes                = E_NOTIMPL;
	BOOL	fValid_pzPath		= TRUE;
    char    szGuid[MAX_LOGSTRING];  

    // validate pszPath
    if(!helpIsValidReadPtr((void*)pzPath, sizeof(CHAR), FALSE))
    {
        // bogus pointer, use as such
        fValid_pzPath = FALSE;
    }

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetSearchDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
    fnsLog(PARAMLOGLEVEL, "pzPath == %p   %s",
            pzPath,
            fValid_pzPath ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fClear  == %s",
            fClear ? "TRUE" : "FALSE");
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->SetSearchDirectory(idClass, 
                                                            pzPath,
                                                            fClear);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetSearchDirectory()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader8::SetSearchDirectory()

















//===========================================================================
// CtIDirectMusicLoader8::EnableGarbageCollector()
//
// Encapsulates calls to EnableGarbageCollector()
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicLoader8::EnableGarbageCollector(BOOL fEnable)
{                                           
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnableGarbageCollector()",
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "fEnable == %s",
            fEnable ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicLoader8*)m_pUnk)->EnableGarbageCollector(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnableGarbageCollector()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // ** end CtIDirectMusicLoader8::EnableGarbageCollector()
*/
	
	
	
//===========================================================================
// CtIDirectMusicLoader8::CollectGarbage()
//
// Encapsulates calls to CollectGarbage()
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
void CtIDirectMusicLoader8::CollectGarbage(void)
{                                           
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CollectGarbage()",
            m_szInterfaceName);

    // call the real function
    ((IDirectMusicLoader8*)m_pUnk)->CollectGarbage();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CollectGarbage()",
            m_szInterfaceName);

    fnsDecrementIndent();

    // done
    return;

} // ** end CtIDirectMusicLoader8::CollectGarbage()




//===========================================================================
// CtIDirectMusicLoader8::ReleaseObjectByUnknown()
//
// Encapsulates calls to ReleaseObjectByUnknown()
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================

HRESULT CtIDirectMusicLoader8::ReleaseObjectByUnknown(CtIUnknown *pObject)
{                                           
    HRESULT		hRes			= E_NOTIMPL;
	BOOL		fValid_pObject	= TRUE;
    IUnknown	*pdmObject		= NULL;
	
    // validate pObject
    if(!helpIsValidPtr((void*)pObject, sizeof(CtIUnknown), FALSE))
    {
        // bogus pointer, use as such
        fValid_pObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmObject = (IUnknown*)pObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pObject->GetRealObjPtr(&pdmObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ReleaseObjectByUnknown()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObject== %p   %s",
            pObject, 
            fValid_pObject ? "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicLoader8*)m_pUnk)->ReleaseObjectByUnknown(pdmObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ReleaseObjectByUnknown()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pObject && pdmObject)
    {
        pdmObject->Release();
    }
    return hRes;

} // ** end CtIDirectMusicLoader8::ReleaseObjectByUnknown()

/*
//===========================================================================
// CtIDirectMusicLoader8::GetDynamicallyReferencedObject()
//
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//  01/24/2000 - kcraven - created
//  02/08/2000 - kcraven - matched changes to dmusic headers
//  04/06/2000 - danhaff - removed as per dmusic header changes.
//===========================================================================
HRESULT CtIDirectMusicLoader8::GetDynamicallyReferencedObject(
	CtIDirectMusicObject *pSourceObject,
	LPDMUS_OBJECTDESC pDesc,
	REFIID riid,
	LPVOID FAR *ppv)
{
    HRESULT hRes					= E_NOTIMPL;
	IDirectMusicObject*	pdmSourceObject	= NULL;
	BOOL	fValid_pSourceObject	= TRUE;
	BOOL	fValid_pDesc			= TRUE;
    IID		riidReal;
	BOOL	fValid_ppv				= TRUE;
    char    szIID[MAX_LOGSTRING];
	BOOL	bWrapObject				= TRUE;

	void**						ppdmv			= NULL;			
	IDirectMusicObject*			pdmObject		= NULL;
	IDirectMusicObject8*		pdmObject8		= NULL;
	IDirectMusicBand*			pdmBand			= NULL;
	IDirectMusicBand8*			pdmBand8		= NULL;
	IDirectMusicCollection*		pdmCollection	= NULL;
	IDirectMusicChordMap*		pdmChordMap		= NULL;
	IDirectMusicSegment*		pdmSegment		= NULL;
	IDirectMusicStyle*			pdmStyle		= NULL;
	IDirectMusicSegment8*		pdmSegment8		= NULL;
	IDirectMusicStyle8*			pdmStyle8		= NULL;

	IDirectMusicObject**		ppdmObject		= NULL;
	IDirectMusicObject8**		ppdmObject8		= NULL;
	IDirectMusicBand**			ppdmBand		= NULL;
	IDirectMusicBand8**			ppdmBand8		= NULL;
	IDirectMusicCollection**	ppdmCollection	= NULL;
	IDirectMusicChordMap**		ppdmChordMap	= NULL;
	IDirectMusicSegment**		ppdmSegment		= NULL;
	IDirectMusicStyle**			ppdmStyle		= NULL;
	IDirectMusicSegment8**		ppdmSegment8	= NULL;
	IDirectMusicStyle8**		ppdmStyle8		= NULL;

	IDirectMusicScript*			pdmScript		= NULL;
	IDirectMusicScript**		ppdmScript		= NULL;

	    // validate pSourceObject
    if(!helpIsValidPtr((void*)pSourceObject, sizeof(CtIDirectMusicObject), FALSE))
    {
        // bogus pointer, use as such
        fValid_pSourceObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmSourceObject = (IDirectMusicObject*)pSourceObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pSourceObject->GetRealObjPtr(&pdmSourceObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppv
    if(!helpIsValidPtr((void*)ppv, sizeof(void*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppv = FALSE;
    }

	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }

    // determine which IID we >really< want to use
    if(IsEqualIID(CTIID_IDirectMusicObject, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicObject, 
                    sizeof(GUID));
		ppdmObject = &pdmObject;
		ppdmv = (void**)ppdmObject;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicObject8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicObject8, 
                    sizeof(GUID));
		ppdmObject8 = &pdmObject8;
		ppdmv = (void**)ppdmObject8;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicBand, 
                    sizeof(GUID));
		ppdmBand = &pdmBand;
		ppdmv = (void**)ppdmBand;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicBand8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicBand8, 
                    sizeof(GUID));
		ppdmBand8 = &pdmBand8;
		ppdmv = (void**)ppdmBand8;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicCollection, 
                    sizeof(GUID));
		ppdmCollection = &pdmCollection;
		ppdmv = (void**)ppdmCollection;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicChordMap, 
                    sizeof(GUID));
		ppdmChordMap = &pdmChordMap;
		ppdmv = (void**)ppdmChordMap;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment, 
                    sizeof(GUID));
		ppdmSegment = &pdmSegment;
		ppdmv = (void**)ppdmSegment;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle, 
                    sizeof(GUID));
		ppdmStyle = &pdmStyle;
		ppdmv = (void**)ppdmStyle;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment8, 
                    sizeof(GUID));
		ppdmSegment8 = &pdmSegment8;
		ppdmv = (void**)ppdmSegment8;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle8, 
                    sizeof(GUID));
		ppdmStyle8 = &pdmStyle8;
		ppdmv = (void**)ppdmStyle8;
		*ppv = NULL;
    }
    else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicScript, 
                    sizeof(GUID));
		ppdmScript = &pdmScript;
		ppdmv = (void**)ppdmScript;
		*ppv = NULL;
    }
    else
    {
        // trust that the loader is going to recognize this and we don't want it wrapped
		bWrapObject = FALSE;
        CopyMemory((void*)&riidReal, 
                    (void*)&riid, 
                    sizeof(GUID));
		ppdmv = ppv;
    }

    dmthGUIDtoString(riidReal, szIID);

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDynamicallyReferencedObject()", 
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourceObject == %p   %s",
			pdmSourceObject,
			fValid_pSourceObject ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "pDesc         == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
    if(fValid_pDesc)
    {
        // BUGBUG log contents of pDesc (STRUCTLOGLEVEL)
    }
    fnsLog(PARAMLOGLEVEL, "riid          == %s (%s)",
            szIID, dmthXlatGUID(riidReal));
    fnsLog(PARAMLOGLEVEL, "ppv           == %p   %s",
			ppdmv,
			fValid_ppv ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader8*)m_pUnk)->GetDynamicallyReferencedObject(
												pdmSourceObject,
												pDesc,
												riidReal,
												ppdmv);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDynamicallyReferencedObject()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppv)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppv == %p",
				*ppdmv);

		//we succeeded and we want to wrap the object and we got an object
		if(SUCCEEDED(hRes) && bWrapObject && *ppdmv)
		{
			// determine which IID we >really< want to use
			if(IsEqualIID(CTIID_IDirectMusicObject, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmObject,(CtIDirectMusicObject**)ppv);
				pdmObject->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicObject8, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmObject8,(CtIDirectMusicObject8**)ppv);
				pdmObject8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmBand,(CtIDirectMusicBand**)ppv);
				pdmBand->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicBand8, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmBand8,(CtIDirectMusicBand8**)ppv);
				pdmBand8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmCollection,(CtIDirectMusicCollection**)ppv);
				pdmCollection->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmChordMap,(CtIDirectMusicChordMap**)ppv);
				pdmChordMap->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmSegment,(CtIDirectMusicSegment**)ppv);
				pdmSegment->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmStyle,(CtIDirectMusicStyle**)ppv);
				pdmStyle->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmSegment8,(CtIDirectMusicSegment8**)ppv);
				pdmSegment8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmStyle8,(CtIDirectMusicStyle8**)ppv);
				pdmStyle8->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
			{
				hRes = dmthCreateTestWrappedObject(pdmScript,(CtIDirectMusicScript**)ppv);
				pdmScript->Release();
			}
			else
			{
				hRes = E_FAIL; //we want to but don't support wrapping this interface
			}

			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object (%08Xh)", hRes);
			}
		}

	}

	fnsDecrementIndent();

END:
    if(fValid_pSourceObject && pdmSourceObject)
    {
        pdmSourceObject->Release();
    }
    // done
    return hRes;

} // ** end CtIDirectMusicLoader8::GetDynamicallyReferencedObject()




//===========================================================================
// CtIDirectMusicLoader8::ReportDynamicallyReferencedObject()
//
// Encapsulates calls to ReportDynamicallyReferencedObject()
//
// History:
//  01/24/2000 - kcraven - created
//  02/08/2000 - kcraven - matched changes to dmusic headers
//  04/06/2000 - danhaff - removed as per dmusic header changes
//===========================================================================
HRESULT CtIDirectMusicLoader8::ReportDynamicallyReferencedObject
(
	CtIDirectMusicObject *pSourceObject,
	CtIUnknown *pReferencedObject
)
{                                           
    HRESULT				hRes						= E_NOTIMPL;
	BOOL				fValid_pSourceObject		= TRUE;
    IDirectMusicObject	*pdmSourceObject			= NULL;
	BOOL				fValid_pReferencedObject	= TRUE;
    IUnknown			*pdmReferencedObject		= NULL;
	
    // validate pSourceObject
    if(!helpIsValidPtr((void*)pSourceObject, sizeof(CtIDirectMusicObject), FALSE))
    {
        // bogus pointer, use as such
        fValid_pSourceObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmSourceObject = (IDirectMusicObject*)pSourceObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pSourceObject->GetRealObjPtr(&pdmSourceObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
    // validate pReferencedObject
    if(!helpIsValidPtr((void*)pReferencedObject, sizeof(CtIUnknown), FALSE))
    {
        // bogus pointer, use as such
        fValid_pReferencedObject = FALSE;
        // we have a bogus pointer, use it as such
        pdmReferencedObject = (IUnknown*)pReferencedObject;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pReferencedObject->GetRealObjPtr(&pdmReferencedObject);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ReportDynamicallyReferencedObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourceObject     == %p   %s",
            pdmSourceObject, 
            fValid_pSourceObject ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pReferencedObject == %p   %s",
            pdmReferencedObject, 
            fValid_pReferencedObject ? "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicLoader8*)m_pUnk)->ReportDynamicallyReferencedObject(pdmSourceObject,pdmReferencedObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ReportDynamicallyReferencedObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pSourceObject && pdmSourceObject)
    {
        pdmSourceObject->Release();
    }
    if(fValid_pReferencedObject && pdmReferencedObject)
    {
        pdmReferencedObject->Release();
    }
    return hRes;

} // ** end CtIDirectMusicLoader8::ReportDynamicallyReferencedObject()


*/

//===========================================================================
// CtIDirectMusicLoader8::LoadObjectFromFile()
//
// Encapsulates calls to LoadObjectFromFile()
//
// Note: Make sure that if you want a wrapped test class, you pass in the
//       test class's IID, not the real one!!!
// History:
//  02/18/2000 - kcraven - created
//  03/04/2000 - danhaff - took life in hands and uncommented it :)
//===========================================================================
HRESULT CtIDirectMusicLoader8::LoadObjectFromFile(
	REFGUID rguidClassID,
	REFIID riid,			//iidInterfaceID
	const CHAR *pzFilePath,
	void ** ppv)			//ppObject
{
	HRESULT hRes				= E_NOTIMPL;
	HRESULT hResWrap            = E_NOTIMPL;
	BOOL	fValid_ppv			= TRUE;
	BOOL	fValid_pzFilePath	= TRUE;
//	GUID	dwrguidClassID;
	IID		riidReal;
	char	szGUID[MAX_LOGSTRING];
	char	szIID[MAX_LOGSTRING];
	BOOL	bWrapObject			= TRUE;

	void**						ppdmv			= NULL;			

	IUnknown*					pdmUnknown		= NULL;
	IUnknown**					ppdmUnknown		= NULL;

	IDirectMusicObject8*		pdmObject8		= NULL;
	IDirectMusicObject8**		ppdmObject8		= NULL;

//	IDirectMusicBand*			pdmBand			= NULL;
//	IDirectMusicBand**			ppdmBand		= NULL;

//	IDirectMusicCollection*		pdmCollection	= NULL;
//	IDirectMusicCollection**	ppdmCollection	= NULL;

//	IDirectMusicChordMap*		pdmChordMap		= NULL;
//	IDirectMusicChordMap**		ppdmChordMap	= NULL;

//	IDirectMusicStyle*			pdmStyle		= NULL;
//	IDirectMusicStyle**			ppdmStyle		= NULL;

	IDirectMusicSegment8*		pdmSegment8		= NULL;
	IDirectMusicSegment8**		ppdmSegment8	= NULL;

//	IDirectMusicStyle8*			pdmStyle8		= NULL;
//	IDirectMusicStyle8**		ppdmStyle8		= NULL;

//	IDirectSoundWave*           pdmWave         = NULL;
//	IDirectSoundWave**          ppdmWave        = NULL;

//	IDirectMusicContainer*      pdmContainer    = NULL;
//	IDirectMusicContainer**     ppdmContainer   = NULL;

//	IDirectMusicSong*			pdmSong			= NULL;
//	IDirectMusicSong**			ppdmSong		= NULL;

//	IDirectMusicGraph*			pdmGraph		= NULL;
//	IDirectMusicGraph**			ppdmGraph		= NULL;

	IDirectMusicScript*         pdmScript       = NULL;
	IDirectMusicScript**        ppdmScript      = NULL;

    // validate ppv
    if(!helpIsValidPtr((void*)ppv, sizeof(void*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppv = FALSE;
		ppdmv = ppv;
    }

	// validate pzFilePath
    if(!helpIsValidReadPtr((void*)pzFilePath, sizeof(CHAR), FALSE))
    {
		fValid_pzFilePath = FALSE;
    }

    // determine which IID we >really< want to use
    if(IsEqualIID(CTIID_IUnknown, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IUnknown, 
                    sizeof(GUID));
		ppdmUnknown = &pdmUnknown;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmUnknown;
			*ppv = NULL;
		}
    }
/*
    else if(IsEqualIID(CTIID_IDirectMusicObject, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicObject, 
                    sizeof(GUID));
		ppdmObject = &pdmObject;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmObject;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicBand, 
                    sizeof(GUID));
		ppdmBand = &pdmBand;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmBand;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicCollection, 
                    sizeof(GUID));
		ppdmCollection = &pdmCollection;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmCollection;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicChordMap, 
                    sizeof(GUID));
		ppdmChordMap = &pdmChordMap;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmChordMap;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle, 
                    sizeof(GUID));
		ppdmStyle = &pdmStyle;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmStyle;
			*ppv = NULL;
		}
    }

*/
    else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSegment8, 
                    sizeof(GUID));
		ppdmSegment8 = &pdmSegment8;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmSegment8;
			*ppv = NULL;
		}
    }

	else if ( IsEqualIID( CTIID_IDirectMusicScript, riid ) )
	{
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicScript, 
                    sizeof(GUID));
		ppdmScript = &pdmScript;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmScript;
			*ppv = NULL;
		}
    }
/*
    else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicStyle8, 
                    sizeof(GUID));
		ppdmStyle8 = &pdmStyle8;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmStyle8;
			*ppv = NULL;
		}
    }
*/
/*
//PHOOPHOO
    else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectSoundWave, 
                    sizeof(GUID));
		ppdmWave = &pdmWave;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmWave;
			*ppv = NULL;
		}
    }
*/

/*
    else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicContainer, 
                    sizeof(GUID));
		ppdmContainer = &pdmContainer;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmContainer;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicSong, 
                    sizeof(GUID));
		ppdmSong = &pdmSong;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmSong;
			*ppv = NULL;
		}
    }
    else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
    {
        CopyMemory((void*)&riidReal, 
                    (void*)&IID_IDirectMusicGraph, 
                    sizeof(GUID));
		ppdmGraph = &pdmGraph;
		if(fValid_ppv)
		{
			ppdmv = (void**)ppdmGraph;
			*ppv = NULL;
		}
    }
*/
    else
    {
        // trust that the loader is going to recognize this and we don't want it wrapped
		bWrapObject = FALSE;
        CopyMemory((void*)&riidReal, 
                    (void*)&riid, 
                    sizeof(GUID));
		ppdmv = ppv;
    }

    dmthGUIDtoString(rguidClassID, szGUID);
    dmthGUIDtoString(riidReal, szIID);

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::LoadObjectFromFile()", 
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidClassID    == %s (%s)",
            szGUID, dmthXlatGUID(rguidClassID));
    fnsLog(PARAMLOGLEVEL, "iidInterfaceID  == %s (%s)",
            szIID, dmthXlatGUID(riidReal));
	fnsLog(PARAMLOGLEVEL, "pzFilePath     == %p   %s",
			pzFilePath, fValid_pzFilePath ? pzFilePath : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppv             == %p   %s",
			ppdmv,
			fValid_ppv ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicLoader8*)m_pUnk)->LoadObjectFromFile(
											rguidClassID,
											riidReal,		//iidInterfaceID
											pzFilePath,
											ppdmv);			//ppObject

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::LoadObjectFromFile()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppv)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppv == %p",
				*ppdmv);

		//we succeeded and we want to wrap the object and we got an object
		if(SUCCEEDED(hRes) && bWrapObject && *ppdmv)
		{
			// determine which IID we >really< want to use
/*
			if(IsEqualIID(CTIID_IDirectMusicObject, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmObject,(CtIDirectMusicObject**)ppv);
				pdmObject->Release();
			}
			else 
            */
            if(IsEqualIID(CTIID_IUnknown, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmUnknown,(CtIUnknown**)ppv);
				pdmUnknown->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicBand, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmBand,(CtIDirectMusicBand**)ppv);
				pdmBand->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicCollection, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmCollection,(CtIDirectMusicCollection**)ppv);
				pdmCollection->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicChordMap, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmChordMap,(CtIDirectMusicChordMap**)ppv);
				pdmChordMap->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSegment, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmSegment,(CtIDirectMusicSegment**)ppv);
				pdmSegment->Release();
			}
*/

			else if(IsEqualIID(CTIID_IDirectMusicScript, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmScript,(CtIDirectMusicScript**)ppv);
				pdmScript->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicStyle, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmStyle,(CtIDirectMusicStyle**)ppv);
				pdmStyle->Release();
			}
*/
			else if(IsEqualIID(CTIID_IDirectMusicSegment8, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmSegment8,(CtIDirectMusicSegment8**)ppv);
				pdmSegment8->Release();
			}
/*
			else if(IsEqualIID(CTIID_IDirectMusicStyle8, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmStyle8,(CtIDirectMusicStyle8**)ppv);
				pdmStyle8->Release();
			}
*/
/*
			else if(IsEqualIID(CTIID_IDirectSoundWave, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmWave,(CtIDirectSoundWave **)ppv);
				pdmWave->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicContainer, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmContainer,(CtIDirectMusicContainer **)ppv);
				pdmContainer->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicSong, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmSong,(CtIDirectMusicSong **)ppv);
				pdmSong->Release();
			}
			else if(IsEqualIID(CTIID_IDirectMusicGraph, riid))
			{
				hResWrap = dmthCreateTestWrappedObject(pdmGraph,(CtIDirectMusicGraph **)ppv);
				pdmGraph->Release();
			}
*/
			else
			{
				hResWrap = E_FAIL; //don't support wrapping this interface
			}

			if(FAILED(hResWrap))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hResWrap);
                hRes = E_FAIL;
			}
		}
	}

	fnsDecrementIndent();

    // done
    return hRes;

} // ** end CtIDirectMusicLoader8::LoadObjectFromFile()



//===========================================================================
// CtIDirectMusicLoader::ClearCache()
//
// Encapsulates calls to ClearCache()
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicLoader8::ClearCache(GUID idClass)
{                                           
    HRESULT hRes                = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];  

    fnsIncrementIndent();

    // make the guid readable
    tdmGUIDtoString(idClass, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ClearCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "idClass == %s (%s)",
            szGuid, tdmXlatGUID(idClass));
            
    // call the real function
    hRes = ((IDirectMusicLoader*)m_pUnk)->ClearCache(idClass);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ClearCache()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicLoader::ClearCache()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctobject.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctobject.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctobject.cpp
//
// Test harness implementation of IDirectMusicObject
//
// Functions:
//  CtIDirectMusicObject::CtIDirectMusicObject()
//  CtIDirectMusicObject::~CtIDirectMusicObject()
//  CtIDirectMusicObject::InitTestClass()
//  CtIDirectMusicObject::GetRealObjPtr()
//  CtIDirectMusicObject::QueryInterface()
//  CtIDirectMusicObject::GetDescriptor()
//  CtIDirectMusicObject::SetDescriptor()
//  CtIDirectMusicObject::ParseDescriptor()
//
// History:
//  12/28/1997 - a-llucar - created
//  03/26/1997 - a-kellyc - removed references to dwType in DMUS_OBJECTDESC
//  03/29/1998 - davidkl - brave new world... now a derrived class
//===========================================================================

#include "globals.h"



//===========================================================================
// CtIDirectMusicObject::CtIDirectMusicObject()
//
// Default constructor
//
// History:
//  12/28/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicObject::CtIDirectMusicObject(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicObject";

} //*** end CtIDirectMusicObject::CtIDirectMusicObject()


//===========================================================================
// CtIDirectMusicObject::~CtIDirectMusicObject()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  12/28/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicObject::~CtIDirectMusicObject(void)
{
    // nothing to do

} //*** end CtIDirectMusicObject::~CtIDirectMusicObject()


//===========================================================================
// CtIDirectMusicObject::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmObject - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  12/28/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicObject::InitTestClass(IDirectMusicObject *pdmObject)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmObject, sizeof(IDirectMusicObject), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmObject));

} //*** end CtIDirectMusicObject::InitTestClass()


//===========================================================================
// CtIDirectMusicObject::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicObject **ppdmObject - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/28/1997 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicObject::GetRealObjPtr(IDirectMusicObject **ppdmObject)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmObject, sizeof(IDirectMusicObject*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmObject));

} //*** end CtIDirectMusicObject::GetRealObjPtr()



//===========================================================================
// CtIDirectMusicObject::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/28/1997 - a-llucar - created
//  1/8/98: bthomas - modified to return properly wrapped object based on riid
//  1/15/98: bthomas - made it more COM-like
//	1/19/98 - bthomas - check to see if we support wrapping the riid before doing it.
//===========================================================================
HRESULT CtIDirectMusicObject::QueryInterface(REFIID riid, 
											LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicObject::QueryInterface


//===========================================================================
// CtIDirectMusicObject::GetDescriptor()
//
// Encapsulates calls to GetDescriptor()
//
// History:
//  12/28/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//	07/21/1998 - t-jwex  - fValid_pDesc now set to false when desc==NULL
//===========================================================================
HRESULT CtIDirectMusicObject::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->GetDescriptor(pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::GetDescriptor()



//===========================================================================
// CtIDirectMusicObject::SetDescriptor()
//
// Encapsulates calls to SetDescriptor()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//===========================================================================
HRESULT CtIDirectMusicObject::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->SetDescriptor(pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::SetDescriptor()



//===========================================================================
// CtIDirectMusicObject::ParseDescriptor()
//
// Encapsulates calls to ParseDescriptor()
//
// History:
//  12/29/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bug
//  03/29/1998 - davidkl - fixed ptr validation bug
//	07/20/1998 - t-jwex  - fValid_pDesc now set to false when desc==NULL
//===========================================================================
HRESULT CtIDirectMusicObject::ParseDescriptor(LPSTREAM pStream, 
                                              LPDMUS_OBJECTDESC pDesc)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pDesc	    = TRUE;
	BOOL				fValid_pStream		= TRUE;

	// validate pDesc
    if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
        fValid_pDesc = FALSE;
    }

	// validate pStream
    if(!helpIsValidPtr(pStream, sizeof(BYTE), TRUE))
    {
        fValid_pStream = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ParseDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStream == %p   %s",
            pStream,
            (fValid_pStream) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pDesc == %p   %s",
            pDesc,
            (fValid_pDesc) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicObject*)m_pUnk)->ParseDescriptor(pStream, pDesc);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ParseDescriptor()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pDesc)
    {
		dmthLogDMUS_OBJECTDESCStruct(*pDesc);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicObject::ParseDescriptor()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctunk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctunk.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctunk.cpp
//
// Test harness implementation of IUnknown
//
// Functions:
//  CtIUnknown::CtIUnknown()
//  CtIUnknown::~CtIUnknown()
//  CtIUnknown::InitTestClass()
//  CtIUnknown::GetRealObjPtr()
//  CtIUnknown::AddRef()
//  CtIUnknown::Release()
//  CtIUnknown::QueryInterface()
//
// History:
//  10/15/1997 - davidkl - created
//  04/01/1998 - davidkl - a little maintenance
//  04/26/2000 - danhaff - fixed Release bug.
//  07/20/2000 - danhaff - Added DMSTRESS functionality to this.
//===========================================================================

#include "globals.h"
#include "assert.h"

//===========================================================================
// CtIUnknown::CtIUnknown
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//===========================================================================
CtIUnknown::CtIUnknown(void)
{
HRESULT hr = S_OK;
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IUnknown";
//    m_pDMObjectStressor = NULL;
} //*** end CtIUnknown::CtIUnknown()


//===========================================================================
// CtIUnknown::CtIUnknown
//
// Default destructor
//
// Parameters: none
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//===========================================================================
CtIUnknown::~CtIUnknown(void)
{
/*
    if (m_pDMObjectStressor)
    {
        delete m_pDMObjectStressor;
        m_pDMObjectStressor = NULL;
    }
*/
} //*** end CtIUnknown::~CtIUnknown()


//===========================================================================
// CtIUnknown::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IUnknown object pointer for future use.
//
// Parameters:
//  IUnknown    *pUnk   - pointer to real IUnknown object
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//  08/01/2000 - danhaff - Updated with DMObjectStressor object.
//===========================================================================
HRESULT CtIUnknown::InitTestClass(IUnknown *pUnk)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pUnk, sizeof(IUnknown), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

	// if we get here, we succeeded
	m_pUnk = pUnk;
    m_pUnk->AddRef();

	//TODO: Need to allocate array corresponding to possible stressable interfaces on
	//		App initialization, allow the app to tweak it, then pass it in here to tell
	//		the DMObjectStressor which interfaces to stress.

	//Maybe we should ALWAYS initialize an objectstressor, and let it decide which
	//	interfaces to stress.

    
	//Initialize dmStress with this object, if that's enabled.
/*
    if (g_bDMStressOn && !m_pDMObjectStressor)
    {
        m_pDMObjectStressor = new DMOBJECTSTRESSOR();
        if (m_pDMObjectStressor)
        {
            HRESULT hr = S_OK;
            hr = m_pDMObjectStressor->Initialize(m_pUnk);
            if (FAILED(hr))
            {
                delete m_pDMObjectStressor;
                m_pDMObjectStressor = NULL;
            }

        }

    }
*/
	return  S_OK;

} //*** end CtIUnknown::InitTestClass()


//===========================================================================
// CtIUnknown::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IUnknown **ppUnk - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	03/16/1998 - davidkl - created
//===========================================================================
HRESULT CtIUnknown::GetRealObjPtr(IUnknown **ppUnk)
{

	// validate ppdm
	if(!helpIsValidPtr(ppUnk, sizeof(IUnknown*), FALSE))
	{
		return E_POINTER;
	}

	// if we get here, return m_pUnk
    *ppUnk = m_pUnk;
    m_pUnk->AddRef();
    return S_OK;

} //*** end CtIUnknown::GetRealObjPtr()


//===========================================================================
// CtIUnknown::AddRef
//
// Increments the reference count for our object
//
// Parameters: none
//
// Returns:
//  DWORD - new ref count
//
// History:
//	03/16/1998 - davidkl - created
//  03/26/1998 - davidkl - fixed potential faulting bug
//===========================================================================
DWORD CtIUnknown::AddRef(void)
{
    DWORD dwRealObjRefCount    = 0;

    // increment our object's refcount
    InterlockedIncrement((long*)&m_dwRefCount);

    fnsIncrementIndent();

    if(m_pUnk)
    {
        // log inputs to AddRef()
        fnsLog(CALLLOGLEVEL, "--- Calling %s::AddRef()", 
                m_szInterfaceName);

        // call the real AddRef()
        dwRealObjRefCount = m_pUnk->AddRef();

        // log results from AddRef()
        fnsLog(CALLLOGLEVEL, "--- Returned from %s::AddRef()", 
                m_szInterfaceName);
        fnsLog(PARAMLOGLEVEL, "dwRefCount == %08Xh", 
                dwRealObjRefCount);
    }

    fnsDecrementIndent();

    // done
//    return m_dwRefCount;

	//LOULOU - MODIFIED FOR TEST PURPOSES
	return dwRealObjRefCount;
    
} //*** end CtIUnknown::AddRef()


//===========================================================================
// CtIUnknown::Release
//
// Decrements the reference count for our object
//
// Parameters: none
//
// Returns:
//  DWORD - new ref count
//
// History:
//	03/16/1998 - davidkl - created
//  03/26/1998 - davidkl - fixed potential faulting bug
//  04/26/2000 - danhaff - fixed bug where we weren't decrementing internal refcount.
//===========================================================================
DWORD CtIUnknown::Release(void)
{
///    DWORD   dwOurRefCount       = m_dwRefCount;
    DWORD   dwRealObjRefCount   = 0;

    assert(m_dwRefCount);

    // decrement our object's refcount
    //InterlockedDecrement((long*)&dwOurRefCount);
    InterlockedDecrement((long*)&m_dwRefCount);

    fnsIncrementIndent();

    if(m_pUnk)
    {
        // log inputs to Release()
        fnsLog(CALLLOGLEVEL, "--- Calling %s::Release()", 
                m_szInterfaceName);

        // call the real Release()
        dwRealObjRefCount = m_pUnk->Release();

        // log results from Release()
        fnsLog(CALLLOGLEVEL, "--- Returned from %s::Release()", 
                m_szInterfaceName);
        fnsLog(PARAMLOGLEVEL, "dwRefCount == %08Xh", 
                dwRealObjRefCount);
    }

    fnsDecrementIndent();
  
    // is this the last release? if so, clean ourselves up
//    if(0 == dwOurRefCount)
    if(0 == m_dwRefCount)
    {
        delete this;
    }

    // done
//    return dwOurRefCount;
	//LOULOU - MODIFIED FOR TEST PURPOSES
	return dwRealObjRefCount;
} //*** end CtIUnknown::Release()


//===========================================================================
// CtIUnknown::QueryInterface
//
// Decrements the reference count for our object
//
// Parameters: none
//
// Returns:
//  DWORD - new ref count
//
// History:
//	03/16/1998 - davidkl - created
//===========================================================================
HRESULT CtIUnknown::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_ppvObj       = TRUE;
    char    szIID[MAX_LOGSTRING];

    // BUGBUG - need to figure out how to support returning test wrapped objects

	// validate ppvObj
    if(!helpIsValidPtr(ppvObj, sizeof(IUnknown*), FALSE))
    {
        fValid_ppvObj = FALSE;
    }

    // convert the IID into a string
    tdmGUIDtoString((REFGUID)riid, szIID);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::QueryInterface()", 
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "riid   == %s (%s)",
            szIID, tdmXlatGUID((REFGUID)riid));
    fnsLog(PARAMLOGLEVEL, "ppvObj == %p   %s",
            ppvObj,
            fValid_ppvObj ? "" : "BAD");

    // call the real function
    hRes = m_pUnk->QueryInterface(riid, ppvObj);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::QueryInterface()", 
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)", 
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppvObj)
    {
        fnsLog(PARAMLOGLEVEL, "*ppvObj == %p",
                *ppvObj);
    }

    fnsDecrementIndent();

    // done
    return hRes;
    
} //*** end CtIUnknown::QueryInterface()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\cttool.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cttool.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// cttool.cpp
//
// Test harness implementation of IDirectMusicTool
//
// Functions:
//  CtIDirectMusicTool::CtIDirectMusicTool()
//  CtIDirectMusicTool::~CtIDirectMusicTool()
//  CtIDirectMusicTool::InitTestClass()
//  CtIDirectMusicTool::GetRealObjPtr()
//  CtIDirectMusicTool::QueryInterface()
//  CtIDirectMusicTool::Init()
//  CtIDirectMusicTool::GetMsgDeliveryType()
//  CtIDirectMusicTool::GetMediaTypeArraySize()
//  CtIDirectMusicTool::GetMediaTypes()
//  CtIDirectMusicTool::ProcessPMsg()
//  CtIDirectMusicTool::Flush()
//
// History:
//  01/02/1998 - a-llucar - created
//  01/09/1998 - a-llucar - adapted ProcessEvent(), Flush(), Start(), 
//                          and Stop() to latest header
//  01/10/1998 - a-llucar - added GetQueueType(), GetMediaTypeArraySize(), 
//                          GetMediaTypeArray()
//  03/05/1998 - davidkl - updated to latest dmusic architecture
//  03/31/1998 - davidkl - inheritance update
//===========================================================================
#include "globals.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicTool::CtIDirectMusicTool()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicTool::CtIDirectMusicTool(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicTool";

} //*** end CtIDirectMusicTool::CtIDirectMusicTool()


//===========================================================================
// CtIDirectMusicTool::~CtIDirectMusicTool()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicTool::~CtIDirectMusicTool(void)
{
    // nothing to do

} //*** end CtIDirectMusicTool::~CtIDirectMusicTool()


//===========================================================================
// CtIDirectMusicTool::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmTool - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTool::InitTestClass(IDirectMusicTool *pdmTool)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmTool, sizeof(IDirectMusicTool), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmTool));

} //*** end CtIDirectMusicTool::InitTestClass()


//===========================================================================
// CtIDirectMusicTool::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicTool **ppdmTool - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicTool::GetRealObjPtr(IDirectMusicTool **ppdmTool)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmTool, sizeof(IDirectMusicTool*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmTool));

} //*** end CtIDirectMusicTool::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicTool::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTool::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicTool::QueryInterface


//===========================================================================
// CtIDirectMusicTool::AddRef()
//
// Encapsulates calls to AddRef
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
/*
DWORD CtIDirectMusicTool::AddRef(void)
{

    // increment our object's refcount
    m_dwRefCount++;

    // call the real AddRef
    tdmAddRef((IUnknown*)m_pdmTool, (LPCTSTR)m_szInterfaceName);

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicTool::AddRef()
*/	

//===========================================================================
// CtIDirectMusicTool::Release()
//
// Encapsulates calls to Release
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
/*
DWORD CtIDirectMusicTool::Release(void)
{

    // decrement our object's refcount
    m_dwRefCount--;

    // call the real Release
    tdmRelease((IUnknown*)m_pdmTool, (LPCTSTR)m_szInterfaceName);

    // clean ourselves up
    if(0 >= m_dwRefCount)
    {
        delete this;
    }

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicTool::Release()
*/

 
//===========================================================================
// CtIDirectMusicTool::Init()
//
// Encapsulates calls to Init
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - modified to use wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::Init(CtIDirectMusicGraph* ptdmGraph)
{
    HRESULT             hRes			    = E_NOTIMPL;
    BOOL                fValid_ptdmGraph    = TRUE;
    IDirectMusicGraph   *pdmGraph           = NULL;
    
    // validate ptdmGraph
    if(!helpIsValidPtr((void*)ptdmGraph, sizeof(CtIDirectMusicGraph), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmGraph = FALSE;
        pdmGraph = (IDirectMusicGraph*)ptdmGraph;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmGraph->GetRealObjPtr(&pdmGraph);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGraph == %p   %s",
            pdmGraph,
            fValid_ptdmGraph ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->Init(pdmGraph);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmGraph && pdmGraph)
    {
        pdmGraph->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::Init()


//===========================================================================
// CtIDirectMusicTool::GetMsgDeliveryType()
//
// Encapsulates calls to GetMsgDeliveryType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::GetMsgDeliveryType(DWORD* pdwDeliveryType)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwDeliveryType	= TRUE;
    
    // validate pdwQueueType
    if(!helpIsValidPtr((void*)pdwDeliveryType, sizeof(DWORD), FALSE))
    {
        fValid_pdwDeliveryType	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMsgDeliveryType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwDeliveryType == %p   %s",
            pdwDeliveryType,
            fValid_pdwDeliveryType ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMsgDeliveryType(pdwDeliveryType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMsgDeliveryType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes             == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwDeliveryType)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwDeliveryType == %08Xh",
                *pdwDeliveryType);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMsgDeliveryType()


//===========================================================================
// CtIDirectMusicTool::GetMediaTypeArraySize()
//
// Encapsulates calls to GetMediaTypeArraySize
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicTool::GetMediaTypeArraySize(DWORD* pdwNumElements)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL	fValid_pdwNumElements	= TRUE;
    
    // validate pdwNumElements
    if(!helpIsValidPtr((void*)pdwNumElements, sizeof(DWORD), FALSE))
    {
        fValid_pdwNumElements = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMediaTypeArraySize()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwNumElements == %p   %s",
            pdwNumElements,
            fValid_pdwNumElements ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMediaTypeArraySize(pdwNumElements);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMediaTypeArraySize()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwNumElements)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwNumElements == %08Xh",
                *pdwNumElements);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMediaTypeArraySize()


//===========================================================================
// CtIDirectMusicTool::GetMediaTypes()
//
// Encapsulates calls to GetMediaTypes
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/2998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::GetMediaTypes(DWORD** padwMediaTypes, 
                                        DWORD dwNumElements)
{
    HRESULT hRes					= E_NOTIMPL;
	BOOL	fValid_padwMediaTypes	= TRUE;
    
    // validate padwMediaTypes
    if(!helpIsValidPtr((void*)padwMediaTypes, sizeof(DWORD*), FALSE))
    {
        fValid_padwMediaTypes = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMediaTypes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "padwMediaTypes == %p   %s",
            padwMediaTypes,
            fValid_padwMediaTypes ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwNumElements == %08Xh",
            dwNumElements);

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMediaTypes(padwMediaTypes, dwNumElements);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMediaTypes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_padwMediaTypes)
    {
        // BUGBUG - log contents of padwMediaTypes @ MAXLOGLEVEL
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMediaTypes()


//===========================================================================
// CtIDirectMusicTool::ProcessPMsg()
//
// Encapsulates calls to ProcessPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::ProcessPMsg(CtIDirectMusicPerformance* ptdmPerf, 
                                        DMUS_PMSG* pPMSG)
{
    HRESULT                 hRes			= E_NOTIMPL;
    BOOL				    fValid_ptdmPerf	= TRUE;
	BOOL				    fValid_pPMSG	= TRUE;
    IDirectMusicPerformance *pdmPerf        = NULL;
    
    // validate ptdmPerf
    if(!helpIsValidPtr((void*)ptdmPerf, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerf;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pPMSG
    if(!helpIsValidPtr((void*)pPMSG, sizeof(pPMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ProcessPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerf == %p   %s",
            pdmPerf,
            fValid_ptdmPerf ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->ProcessPMsg(pdmPerf, pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ProcessPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::ProcessPMsg()


//===========================================================================
// CtIDirectMusicTool::Flush()
//
// Encapsulates calls to Flush
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//  04/10/1998 - davidkl - added rtTime param
//===========================================================================
HRESULT CtIDirectMusicTool::Flush(CtIDirectMusicPerformance* ptdmPerf, 
                                    DMUS_PMSG* pPMSG,
                                    REFERENCE_TIME rtTime)
{
    HRESULT                 hRes			= E_NOTIMPL;
    BOOL				    fValid_ptdmPerf	= TRUE;
	BOOL				    fValid_pPMSG	= TRUE;
    IDirectMusicPerformance *pdmPerf        = NULL;
    
    // validate ptdmPerf
    if(!helpIsValidPtr((void*)ptdmPerf, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerf;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pPipelineEvent
    if(!helpIsValidPtr((void*)pPMSG, sizeof(pPMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Flush()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerf  == %p   %s",
            pdmPerf,
            fValid_ptdmPerf ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pPMSG  == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "rtTime == %016Xh",
            rtTime);

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->Flush(pdmPerf, pPMSG, rtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Flush()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::Flush()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctscript.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctscript.cpp
//
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
// ctscript.cpp
//
// Test harness implementation of IDirectMusicScript
//
// Functions:
//    CtIDirectMusicScript::CtIDirectMusicScript()
//    CtIDirectMusicScript::~CtIDirectMusicScript()
//    CtIDirectMusicScript::InitTestClass()
//    CtIDirectMusicScript::GetRealObjPtr()
//  IUnknown
//    CtIDirectMusicScript::QueryInterface()
//
//    CtIDirectMusicScript::Init()
//    CtIDirectMusicScript::CallRoutine()
//    CtIDirectMusicScript::SetVariableVariant()
//    CtIDirectMusicScript::GetVariableVariant()
//    CtIDirectMusicScript::SetVariableNumber()
//    CtIDirectMusicScript::GetVariableNumber()
//    CtIDirectMusicScript::SetVariableObject()
//    CtIDirectMusicScript::GetVariableObject()
//    CtIDirectMusicScript::EnumRoutine()
//    CtIDirectMusicScript::EnumVariable()
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - updated for changes to IDMScript changes (removed
//                         IDMScriptError in favor of the structure ptr)
//===========================================================================


#include "globals.h"

//===========================================================================
// CtIDirectMusicScript::CtIDirectMusicScript()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
CtIDirectMusicScript::CtIDirectMusicScript()
{
    // initialize our member variables
    m_pUnk = NULL;
    m_dwRefCount = 1;
    m_szInterfaceName = "IDirectMusicScript";

} //*** end CtIDirectMusicScript::CtIDirectMusicScript()




//===========================================================================
// CtIDirectMusicScript::~CtIDirectMusicScript()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
CtIDirectMusicScript::~CtIDirectMusicScript(void)
{
    // nothing to do

} //*** emd CtIDirectMusicScript::~CtIDirectMusicScript()




//===========================================================================
// CtIDirectMusicScript::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicScript object pointer for future use.
//
// Parameters:
//  CtIDirectMusicScript    *pdmScript    - pointer to real IDirectMusicScript object
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScript::InitTestClass(IDirectMusicScript *pdmScript)
{
    // validate pointer... if bad, return error
    if(!helpIsValidPtr(pdmScript, sizeof(IDirectMusicScript), FALSE))
    {
        m_pUnk = NULL;
        return E_POINTER;
    }

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmScript));

} //*** end CtIDirectMusicScript::InitTestClass()




//===========================================================================
// CtIDirectMusicScript::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//  IDirectMusicScript **ppdmScript - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScript::GetRealObjPtr(IDirectMusicScript **ppdmScript)
{

    // validate ppdm
    if(!helpIsValidPtr(ppdmScript, sizeof(IDirectMusicScript*), FALSE))
    {
        return E_POINTER;
    }

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmScript));

} //*** end CtIDirectMusicScript::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicScript::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScript::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicScript::QueryInterface()




//===========================================================================
// CtIDirectMusicScript::Init()
//
// Encapsulates calls to Init
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::Init
(
    CtIDirectMusicPerformance* pPerformance,
    DMUS_SCRIPT_ERRORINFO*     pdmScriptErrorInfo
)
{
    HRESULT                     hRes                = E_FAIL;
    BOOL                        fValid_pPerformance = TRUE;
    BOOL                        fValid_pdmScriptErr = TRUE;
    IDirectMusicPerformance*    pdmPerfomance       = NULL;

    // validate pPerformance
    if(!helpIsValidPtr((void*)pPerformance, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pPerformance = FALSE;
        pdmPerfomance = (IDirectMusicPerformance*)pPerformance;

    }
    else
    {
        // good pointer, get the real object
        hRes = pPerformance->GetRealObjPtr(&pdmPerfomance);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }


    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL,  "--- Calling %s::Init()",  m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerfomance == %p   %s",
            pdmPerfomance, fValid_pPerformance ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->Init(pdmPerfomance, pdmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pPerformance && pdmPerfomance)
    {
        pdmPerfomance->Release();
    }
    return hRes;

} //*** end CtIDirectMusicScript::Init()




//===========================================================================
// CtIDirectMusicScript::CallRoutine()
//
// Encapsulates calls to CallRoutine
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::CallRoutine
(
    CHAR                       *pszRoutineName,   
    DMUS_SCRIPT_ERRORINFO*      pdmScriptErrorInfo)
{
    HRESULT     hRes                    = E_FAIL;
    BOOL        fValid_pszRoutineName  = TRUE;
    BOOL        fValid_pdmScriptErr     = TRUE;

    // validate pwszRoutineName
    if(!helpIsValidReadPtr((void*)pszRoutineName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszRoutineName = FALSE;
    }
    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs 
    fnsLog(CALLLOGLEVEL,    "--- Calling %s::CallRoutine()",  m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL,   "pszRoutineName == %s (%p)   %s",
           pszRoutineName, pszRoutineName, fValid_pszRoutineName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL,   "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->CallRoutine(pszRoutineName, pdmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CallRoutine()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::CallRoutine()




//===========================================================================
// CtIDirectMusicScript::SetVariableVariant()
//
// Encapsulates calls to SetVariableVariant
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
/*
HRESULT CtIDirectMusicScript::SetVariableVariant
(
    WCHAR                   *pwszVariableName,
    VARIANT                 varValue,//BUGBUG this needs to be a ptr
    BOOL                    fSetRef,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pwszVariableName = TRUE;
    BOOL            fValid_pdmScriptErr     = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;

    // validate pwszVariableName
    if(!helpIsValidPtr((void*)pwszVariableName, sizeof(WCHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszVariableName = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVariableVariant()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszVariableName == %s (%p)   %s",
            pwszVariableName, pwszVariableName, fValid_pwszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "varValue         == %08Xh", varValue);
    fnsLog(PARAMLOGLEVEL, "fSetRef          == %08Xh", fSetRef);
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->SetVariableVariant(pwszVariableName, varValue, fSetRef, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVariableVariant()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::SetVariableVariant()




//===========================================================================
// CtIDirectMusicScript::GetVariableVariant()
//
// Encapsulates calls to GetVariableVariant
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::GetVariableVariant
(
    WCHAR                   *pwszVariableName,
    VARIANT                 *pvarValue,         //BUGBUG this needs to be a ptr
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pwszVariableName = TRUE;
    BOOL            fValid_pvarValue        = TRUE;
    BOOL            fValid_pdmScriptErr     = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;


    // validate pwszVariableName
    if(!helpIsValidPtr((void*)pwszVariableName, sizeof(WCHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszVariableName = FALSE;
    }

    // validate pvarValue
    if(!helpIsValidPtr((void*)pvarValue, sizeof(VARIANT*), FALSE))
    {
        fValid_pvarValue = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetVariableVariant()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszVariableName == %ls (%p)   %s", pwszVariableName, pwszVariableName,
            fValid_pwszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pvarValue        == %p   %s", pvarValue, fValid_pvarValue ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->GetVariableVariant(pwszVariableName,pvarValue, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetVariableVariant()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::GetVariableVariant()

*/


//===========================================================================
// CtIDirectMusicScript::SetVariableNumber()
//
// Encapsulates calls to SetVariableNumber
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::SetVariableNumber
(
    CHAR                   *pszVariableName,
    LONG                    lValue,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pszVariableName = TRUE;
    BOOL            fValid_pdmScriptErr     = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;

    // validate pszVariableName
    if(!helpIsValidReadPtr((void*)pszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszVariableName = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVariableNumber()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pszVariableName == %s (%p)   %s",
            pszVariableName, pszVariableName, fValid_pszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "lValue           == %d", lValue);
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->SetVariableNumber(pszVariableName,lValue, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVariableNumber()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::SetVariableNumber()




//===========================================================================
// CtIDirectMusicScript::GetVariableNumber()
//
// Encapsulates calls to GetVariableNumber
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::GetVariableNumber
(
    CHAR                   *pszVariableName,
    LONG                    *plValue,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pszVariableName = TRUE;
    BOOL            fValid_plValue          = TRUE;
    BOOL            fValid_pdmScriptErr     = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;

    // validate pszVariableName
    if(!helpIsValidReadPtr((void*)pszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszVariableName = FALSE;
    }

    // validate plValue
    if(!helpIsValidPtr((void*)plValue, sizeof(LONG*), FALSE))
    {
        fValid_plValue = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetVariableNumber()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pszVariableName == %s (%p)   %s",
            pszVariableName, pszVariableName, fValid_pszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "plValue          == %p   %s",
            plValue, fValid_plValue ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->GetVariableNumber(pszVariableName, plValue, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetVariableNumber()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::GetVariableNumber()




//===========================================================================
// CtIDirectMusicScript::SetVariableObject()
//
// Encapsulates calls to SetVariableObject
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//  02/20/2000 - jimmo   - Now takes an IUnknown* instead of CtIUnkown.
//                         It's a type, like BOOL or LONG, so we don't wrap it.
//                         This simplifies testing code.
//===========================================================================
HRESULT CtIDirectMusicScript::SetVariableObject
(
    CHAR                   *pwszVariableName,
    IUnknown                *punkValue,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                        = E_FAIL;
    BOOL            fValid_pwszVariableName     = TRUE;
    BOOL            fValid_punkValue            = TRUE;
    BOOL            fValid_pdmScriptErr         = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;

    // validate pwszVariableName
    if(!helpIsValidReadPtr((void*)pwszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszVariableName = FALSE;
    }

    // validate punkValue
    if(!helpIsValidPtr((void*)punkValue, sizeof(IUnknown*), FALSE))
    {
        fValid_punkValue = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVariableObject()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszVariableName == %s (%p)   %s",
            pwszVariableName, pwszVariableName, fValid_pwszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "punkValue        == %p   %s",
            punkValue, fValid_punkValue ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->SetVariableObject(pwszVariableName, punkValue, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVariableObject()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    return hRes;

} //*** end CtIDirectMusicScript::SetVariableObject()




//===========================================================================
// CtIDirectMusicScript::GetVariableObject()
//
// Encapsulates calls to GetVariableObject
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//  02/20/2000 - jimmo   - Now takes an IUnknown* instead of CtIUnkown.
//                         It's a type, like BOOL or LONG, so we don't wrap it.
//                         This simplifies testing code.
//===========================================================================
HRESULT CtIDirectMusicScript::GetVariableObject
(
	CHAR *pwszVariableName,
	REFIID riid,
	LPVOID FAR *ppv,
	DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pwszVariableName = TRUE;
    BOOL            fValid_pdmScriptErr     = TRUE;
  
    // validate pwszVariableName
    if(!helpIsValidReadPtr((void*)pwszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszVariableName = FALSE;
    }

//BUGBUG
// validation
// riid
// ppv

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetVariableObject()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszVariableName == %s (%p)   %s", pwszVariableName, pwszVariableName,
            fValid_pwszVariableName ? "" : "BAD");

//BUGBUG
// riid logging
// ppv  logging

    fnsLog(PARAMLOGLEVEL, "pErrorInfo == %p   %s",
            pErrorInfo, fValid_pdmScriptErr ? "" : "BAD");
    
    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->GetVariableObject(pwszVariableName, riid, ppv, pErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetVariableObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pErrorInfo);


    fnsDecrementIndent();

    return hRes;

} //*** end CtIDirectMusicScript::GetVariableObject()




//===========================================================================
// CtIDirectMusicScript::EnumRoutine()
//
// Encapsulates calls to EnumRoutine
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
/*
HRESULT CtIDirectMusicScript::EnumRoutine
(
    DWORD dwIndex,
    WCHAR *pwszName
)
{
    HRESULT hRes            = E_FAIL;
    BOOL    fValid_pwszName = TRUE;

    // validate pwszRoutineName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszName = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumRoutine()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex  == %08Xh", dwIndex);
    fnsLog(PARAMLOGLEVEL, "pwszName == (%p)   %s",
            pwszName, fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->EnumRoutine(dwIndex,pwszName);

    // log results
    fnsLog(PARAMLOGLEVEL, "Found pwszName == %s (%p)   %s",
            pwszName, pwszName, fValid_pwszName ? "" : "BAD");
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumRoutine()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::EnumRoutine()




//===========================================================================
// CtIDirectMusicScript::EnumVariable()
//
// Encapsulates calls to EnumVariable
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::EnumVariable
(
    DWORD dwIndex,
    WCHAR *pwszName
)
{
    HRESULT hRes            = E_FAIL;
    BOOL    fValid_pwszName = TRUE;

    // validate pwszRoutineName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pwszName = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumVariable()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex  == %08Xh", dwIndex);
    fnsLog(PARAMLOGLEVEL, "pwszName == %s (%p)   %s",
            pwszName, pwszName, fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->EnumVariable(dwIndex,pwszName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumVariable()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::EnumVariable()



*/


//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================








//===========================================================================
// CtIDirectMusicScript::SetVariableString()
//
// Encapsulates calls to SetVariableString
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::SetVariableString
(
    CHAR                   *pszVariableName,
    CHAR                   *pszValue,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    HRESULT         hRes                    = E_FAIL;
    BOOL            fValid_pszVariableName = TRUE;
    BOOL            fValid_pszValue        = TRUE;
    BOOL            fValid_pdmScriptErr    = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;

    // validate pszVariableName
    if(!helpIsValidReadPtr((void*)pszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszVariableName = FALSE;
    }

    // validate pszValue
    if(!helpIsValidReadPtr((void*)pszValue, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszValue = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVariableString()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pszVariableName == %s (%p)   %s",
            pszVariableName, pszVariableName, fValid_pszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pszValue == %s (%p)   %s",
            pszValue, pszValue, fValid_pszValue ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->SetVariableString(pszVariableName, pszValue, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVariableString()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",tdmXlatHRESULT(hRes), hRes);
    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::SetVariableString()






//===========================================================================
// CtIDirectMusicScript::GetVariableString()
//
// Encapsulates calls to GetVariableString
//
// NOTE:  We're passing in pdmScriptErrorInfo as a pointer and nota ptr->ptr
//        because the Init API fills in this structure, changing no ptrs.
//        If the API changes, we may have to  modify this scheme.
//
// History:
//  10/26/1999 - kcraven - created
//  02/17/2000 - jimmo   - modified to remove IDMScriptError
//===========================================================================
HRESULT CtIDirectMusicScript::GetVariableString
(
    CHAR                   *pszVariableName,
    CHAR                   *pszValue,
    LONG                    lLength,
    LONG                   *plConverted,
    DMUS_SCRIPT_ERRORINFO  *pdmScriptErrorInfo
)
{
    HRESULT         hRes                   = E_FAIL;
    BOOL            fValid_pszVariableName = TRUE;
    BOOL            fValid_pszValue        = TRUE;
    BOOL            fValid_plConverted     = TRUE;
    BOOL            fValid_pdmScriptErr    = TRUE;

    DMUS_SCRIPT_ERRORINFO       dmScriptErrorInfo;



    // validate pszVariableName
    if(!helpIsValidReadPtr((void*)pszVariableName, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszVariableName = FALSE;
    }

    // validate pszValue
    if(!helpIsValidPtr((void*)pszValue, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pszValue = FALSE;
    }

    // validate plConverted
    if(!helpIsValidPtr((void*)plConverted, sizeof(CHAR*), FALSE))
    {
        // bogus pointer, use as such
        fValid_plConverted = FALSE;
    }

    // validate DMUS_SCRIPT_ERRORINFO
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO*), FALSE))
    {
        fValid_pdmScriptErr = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetVariableString()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pszVariableName == %s (%p)   %s",
            pszVariableName, pszVariableName, fValid_pszVariableName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pszValue == %p %s",
            pszValue, fValid_pszValue ? "" : "(BAD)");
    fnsLog(PARAMLOGLEVEL, "lLength == %d", lLength);

    fnsLog(PARAMLOGLEVEL, "plConverted == %p %s",
            plConverted, fValid_plConverted ? "" : "(BAD)");

    fnsLog(PARAMLOGLEVEL, "pdmScriptErrorInfo == %p   %s",
            pdmScriptErrorInfo, fValid_pdmScriptErr ? "" : "BAD");

    if (TRUE == fValid_pdmScriptErr)
    {
        dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);
    }

    // call the real function
    hRes = ((IDirectMusicScript*)m_pUnk)->GetVariableString(pszVariableName, pszValue, lLength, plConverted, &dmScriptErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetVariableString()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",tdmXlatHRESULT(hRes), hRes);
    
    if (fValid_pszValue)
        fnsLog(PARAMLOGLEVEL, "pszValue = %s", pszValue);

    if (fValid_plConverted)
        fnsLog(PARAMLOGLEVEL, "plConverted = %d", plConverted);

    dmthLogDMUS_SCRIPT_ERRORINFO(CALLLOGLEVEL, pdmScriptErrorInfo);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScript::GetVariableString()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctperf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctperf8.cpp
//
//--------------------------------------------------------------------------


#include "globals.h"
//---------------------------------------------------------------------------

//===========================================================================
// CtIDirectMusicPerformance8::CtIDirectMusicPerformance8()
//
// Default constructor
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPerformance8::CtIDirectMusicPerformance8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicPerformance8";
} 




//===========================================================================
// CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8(void)
{
} // *** end CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8()




//===========================================================================
// CtIDirectMusicPerformance8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmPerformance - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::InitTestClass(IDirectMusicPerformance8 *pdmPerformance8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmPerformance8, sizeof(IDirectMusicPerformance8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmPerformance8));

} // *** end CtIDirectMusicPerformance8::InitTestClass()




//===========================================================================
// CtIDirectMusicPerformance8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicPerformance8 **ppdmPerformance8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmPerformance8, sizeof(IDirectMusicPerformance8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmPerformance8));

} // *** end CtIDirectMusicPerformance8::GetRealObjPtr()


//===========================================================================
// CtIUnknown::AddRef
//
// Increments the reference count for our object
//
// Parameters: none
//
// Returns:
//  DWORD - new ref count
//
// History:
//	03/16/1998 - davidkl - created
//  03/26/1998 - davidkl - fixed potential faulting bug
//===========================================================================
DWORD CtIDirectMusicPerformance8::AddRef(void)
{
    DWORD dwRealObjRefCount    = 0;

    // increment our object's refcount
    InterlockedIncrement((long*)&m_dwRefCount);

    fnsIncrementIndent();

    if(m_pUnk)
    {
        // log inputs to AddRef()
        fnsLog(CALLLOGLEVEL, "--- Calling %s::AddRef()", 
                m_szInterfaceName);

        // call the real AddRef()
        dwRealObjRefCount = ((IDirectMusicPerformance*)m_pUnk)->AddRef();

        // log results from AddRef()
        fnsLog(CALLLOGLEVEL, "--- Returned from %s::AddRef()", 
                m_szInterfaceName);
        fnsLog(PARAMLOGLEVEL, "dwRefCount == %08Xh", 
                dwRealObjRefCount);
    }

    fnsDecrementIndent();

    // done
//    return m_dwRefCount;

	//LOULOU - MODIFIED FOR TEST PURPOSES
	return dwRealObjRefCount;
    
} //*** end CtIUnknown::AddRef()


//===========================================================================
// CtIUnknown::Release
//
// Decrements the reference count for our object
//
// Parameters: none
//
// Returns:
//  DWORD - new ref count
//
// History:
//	03/16/1998 - davidkl - created
//  03/26/1998 - davidkl - fixed potential faulting bug
//===========================================================================
DWORD CtIDirectMusicPerformance8::Release(void)
{
//    DWORD   dwOurRefCount       = m_dwRefCount;
    DWORD   dwRealObjRefCount   = 0;

    // decrement our object's refcount
    InterlockedDecrement((long*)&m_dwRefCount);
//    InterlockedDecrement((long*)&dwOurRefCount);

    fnsIncrementIndent();

    if(m_pUnk)
    {
        // log inputs to Release()
        fnsLog(CALLLOGLEVEL, "--- Calling %s::Release()", 
                m_szInterfaceName);

        // call the real Release()
        dwRealObjRefCount = ((IDirectMusicPerformance*)m_pUnk)->Release();

        // log results from Release()
        fnsLog(CALLLOGLEVEL, "--- Returned from %s::Release()", 
                m_szInterfaceName);
        fnsLog(PARAMLOGLEVEL, "dwRefCount == %08Xh", 
                dwRealObjRefCount);
    }

    fnsDecrementIndent();
  
    // is this the last release? if so, clean ourselves up
    if(0 == m_dwRefCount)
//    if(0 == dwOurRefCount)
    {
        delete this;
    }
    // done
	return dwRealObjRefCount;
} //*** end CtIUnknown::Release()



//===========================================================================
// CtIDirectMusicPerformance8::GetSegmentState()
//
// Encapsulates calls to GetSegmentState
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - modified to use wrapped classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetSegmentState(
                                    CtIDirectMusicSegmentState** pptdmSegmentState,
									MUSIC_TIME mtTime)
{
    HRESULT                     hRes						= E_NOTIMPL;
    BOOL		                fValid_pptdmSegmentState    = TRUE;
    IDirectMusicSegmentState    *pdmSegSt                   = NULL;
    IDirectMusicSegmentState    **ppdmSegSt                 = NULL;

    // validate pptdmSegmentState
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegmentState pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPerformance:PlaySegment().  Otherwise, we are to create and
    //  return a CtIDirectMusicSegmentState object
    if(!helpIsValidPtr((void*)pptdmSegmentState, 
                        sizeof(CtIDirectMusicSegmentState*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSegmentState = FALSE;
        ppdmSegSt = (IDirectMusicSegmentState**)pptdmSegmentState;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSegSt = &pdmSegSt;

        // just in case we fail, init test object ptr to NULL
        *pptdmSegmentState = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetSegmentState()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppSegmentState == %p   %s",
            ppdmSegSt,
            fValid_pptdmSegmentState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "mtTime         == %08Xh",
            mtTime);
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->GetSegmentState(ppdmSegSt, mtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetSegmentState()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSegmentState)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegmentState == %p",
                pdmSegSt);
    }

    // create the test object
    if(SUCCEEDED(hRes) && pptdmSegmentState)
    {
        hRes = dmthCreateTestWrappedObject(pdmSegSt, pptdmSegmentState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmSegmentState && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetSegmentState()



//===========================================================================
// CtIDirectMusicPerformance8::SendPMsg()
//
// Encapsulates calls to SendPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::SendPMsg(DMUS_PMSG* pPMSG)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_pPMSG    = TRUE;

    // validate pPMSG
    if(!helpIsValidPtr((void*)pPMSG, sizeof(DMUS_PMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SendPMSG()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG log contents of pPMSG @ STRUCTLOGLEVEL
    }
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->SendPMsg(pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SendPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::SendPMsg()

//===========================================================================
// CtIDirectMusicPerformance8::MusicToReferenceTime()
//
// Encapsulates calls to MusicToReferenceTime
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::MusicToReferenceTime(MUSIC_TIME mtTime, 
														REFERENCE_TIME* prtTime)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_prtTime				= TRUE;

    // validate prtTime
    if(!helpIsValidPtr((void*)prtTime, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtTime		= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::MusicToReferenceTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtTime == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "prtTime == %p   %s",
            prtTime,
            fValid_prtTime ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->MusicToReferenceTime(mtTime, prtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::MusicToReferenceTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtTime)
    {
        // BUGBUG log the contents of prtTime
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::MusicToReferenceTime()


//===========================================================================
// CtIDirectMusicPerformance8::ReferenceToMusicTime()
//
// Encapsulates calls to ReferenceToMusicTime
//
// History:
//  12/31/1997 - a-llucar - created
//  1/15/1998 - a-kellyc - 
//  03/04/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::ReferenceToMusicTime(REFERENCE_TIME rtTime,
														MUSIC_TIME* pmtTime)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pmtTime				= TRUE;

    // validate pmtTime
    if(!helpIsValidPtr((void*)pmtTime, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtTime		= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::ReferenceToMusicTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtTime == %016Xh",
            rtTime);
    fnsLog(PARAMLOGLEVEL, "pmtTime == %p   %s",
            pmtTime,
            fValid_pmtTime ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->ReferenceToMusicTime(rtTime, pmtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::ReferenceToMusicTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtTime)
    {
        // BUGBUG log the contents of pmtTime
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::ReferenceToMusicTime()

//===========================================================================
// CtIDirectMusicPerformance8::IsPlaying()
//
// Encapsulates calls to IsPlaying
//
// History:
//  12/31/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::IsPlaying(CtIDirectMusicSegment8* ptdmSegment,
                                        CtIDirectMusicSegmentState* ptdmSegState)
{
    HRESULT                     hRes				= E_NOTIMPL;
    BOOL		                fValid_ptdmSegState	= TRUE;
	BOOL		                fValid_ptdmSegment	= TRUE;
    IDirectMusicSegment         *pdmSeg             = NULL;
    IDirectMusicSegmentState    *pdmSegSt           = NULL;

    // validate pSegment
    if(!helpIsValidPtr((void*)ptdmSegment, sizeof(CtIDirectMusicSegment8), 
                    TRUE))
    {
        // bogus pointer, use as such
        fValid_ptdmSegment = FALSE;
        pdmSeg = (IDirectMusicSegment*)ptdmSegment;

    }
    else
    {
        // good pointer, get the real object
        if(ptdmSegment)
        {
            hRes = ptdmSegment->GetRealObjPtr(&pdmSeg);
            if(FAILED(hRes))
            {
                fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                        "object pointer (%s == %08Xh)",
                        tdmXlatHRESULT(hRes), hRes);
                goto END;
            }
        }
        else
        {
            // since NULL is ok
            pdmSeg = (IDirectMusicSegment*)ptdmSegment;
        }
    }

    // validate ptdmSegState
    if(!helpIsValidPtr((void*)ptdmSegState, 
                    sizeof(CtIDirectMusicSegmentState), TRUE))
    {
        // bogus pointer, use as such
        fValid_ptdmSegState = FALSE;
        pdmSegSt = (IDirectMusicSegmentState*)ptdmSegState;

    }
    else
    {
        // good pointer, get the real object
        if(ptdmSegState)
        {
            hRes = ptdmSegState->GetRealObjPtr(&pdmSegSt);
            if(FAILED(hRes))
            {
                fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                        "object pointer (%s == %08Xh)",
                        tdmXlatHRESULT(hRes), hRes);
                goto END;
            }
        }
        else
        {
            // since NULL is ok
            pdmSegSt = (IDirectMusicSegmentState*)ptdmSegState;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::IsPlaying()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSegment  == %p   %s",
            pdmSeg,
            fValid_ptdmSegment ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pSegState == %p   %s",
            pdmSegSt,
            fValid_ptdmSegState ? TEXT("") : TEXT("BAD"));
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->IsPlaying(pdmSeg, pdmSegSt);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::IsPlaying()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSegment && pdmSeg)
    {
        pdmSeg->Release();
    }
    if(fValid_ptdmSegState && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPerformance8::IsPlaying()



//===========================================================================
// CtIDirectMusicPerformance8::GetTime()
//
// Encapsulates calls to GetTime
//
// History:
//  12/31/1997 - a-llucar - created
//  1/15/1998 - a-kellyc - edited
//  03/04/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetTime(REFERENCE_TIME* prtNow, 
                                        MUSIC_TIME* pmtNow)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_prtNow	= TRUE;
	BOOL	fValid_pmtNow	= TRUE;

    // validate prtNow
    if(!helpIsValidPtr((void*)prtNow, sizeof(REFERENCE_TIME), TRUE))
    {
        fValid_prtNow = FALSE;
    }

    // validate pmtNow
    if(!helpIsValidPtr((void*)pmtNow, sizeof(MUSIC_TIME), TRUE))
    {
        fValid_pmtNow = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtNow == %p   %s",
            prtNow,
            fValid_prtNow ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pmtNow == %p   %s",
            pmtNow,
            fValid_pmtNow ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->GetTime(prtNow, pmtNow);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtNow && (NULL != prtNow))
    {
        fnsLog(PARAMLOGLEVEL, "*prtNow == %016Xh",
                *prtNow);
    }
    if(fValid_pmtNow && (NULL != pmtNow))
    {
        fnsLog(PARAMLOGLEVEL, "*pmtNow == %08Xh",
                *pmtNow);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetTime()

//===========================================================================
// CtIDirectMusicPerformance8::AllocPMsg()
//
// Encapsulates calls to AllocPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//  03/31/1998 - davidkl - fixed cb logging bug
//===========================================================================
HRESULT CtIDirectMusicPerformance8::AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_ppPMSG				= TRUE;

    // validate ppEvent
    if(!helpIsValidPtr((void*)ppPMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_ppPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::AllocPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "cb     == %08Xh",
            cb);
    fnsLog(PARAMLOGLEVEL, "ppPMSG == %p   %s",
            ppPMSG,
            fValid_ppPMSG ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->AllocPMsg(cb, ppPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::AllocPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppPMSG)
    {
        // BUGBUG - log contents of ppPMSG
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::AllocPMsg()


//===========================================================================
// CtIDirectMusicPerformance8::FreePMsg()
//
// Encapsulates calls to FreePMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::FreePMsg(DMUS_PMSG* pPMSG)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_pPMSG    = TRUE;

    // validate pEvent
    if(!helpIsValidPtr((void*)pPMSG, sizeof(DMUS_PMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::FreePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG log contents of pPMSG
    }
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->FreePMsg(pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::FreePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::FreePMsg()

//===========================================================================
// CtIDirectMusicPerformance8::GetNotificationPMsg()
//
// Encapsulates calls to GetNotificationPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetNotificationPMsg(
                                        DMUS_NOTIFICATION_PMSG** ppNotificationPMsg)
{
    HRESULT hRes				        = E_NOTIMPL;
    BOOL	fValid_ppNotificationPMsg	= TRUE;

    // validate ppNotifyEvent
    if(!helpIsValidPtr((void*)ppNotificationPMsg, sizeof(DMUS_PMSG**),
                        FALSE))
    {
        fValid_ppNotificationPMsg = FALSE;
    }
   
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetNotificationPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppNotificationPMsg == %p   %s",
            ppNotificationPMsg,
            fValid_ppNotificationPMsg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->GetNotificationPMsg(ppNotificationPMsg);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetNotificationPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppNotificationPMsg)
    {
        // BUGBUG log contents of ppNotificationPMsg
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetNotificationPMsg()


//===========================================================================
// CtIDirectMusicPerformance8::AddNotificationType()
//
// Encapsulates calls to AddNotificationType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicPerformance8::AddNotificationType(REFGUID rguidNotificationType)
{
    HRESULT hRes						    = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidNotificationType, szGuid);
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
            szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->AddNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::AddNotificationType()


//===========================================================================
// CtIDirectMusicPerformance8::RemoveNotificationType()
//
// Encapsulates calls to RemoveNotificationType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicPerformance8::RemoveNotificationType(
                                                REFGUID rguidNotificationType)
{
    HRESULT hRes						    = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidNotificationType, szGuid);
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
            szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->RemoveNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::RemoveNotificationType()


//===========================================================================
// CtIDirectMusicPerformance8::GetGlobalParam()
//
// Encapsulates calls to GetGlobalParam
//
// History:
//  01/10/1998 - a-llucar - created
//	01/15/1998 - markburt - modified ppData to pData
//  03/05/1998 - davidkl - renamed, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetGlobalParam(REFGUID rguidType, 
                                                void* pData, DWORD dwSize)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pData        = TRUE;
    char    szGuid[MAX_LOGSTRING];


    // validate pData
    if(!helpIsValidPtr((void*)pData, sizeof(BYTE) * dwSize, FALSE))
    {
        fValid_pData = FALSE;
    }
    
    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetGlobalParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType  == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "pData      == %p   %s",
			pData,
            fValid_pData ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwSize     == %08Xh",
			dwSize);
     
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->GetGlobalParam(rguidType, pData, dwSize);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetGlobalParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pData)
    {
        // BUBUG log contents of pData @ MAXLOGLEVEL
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetGlobalParam()


//===========================================================================
// CtIDirectMusicPerformance8::SetGlobalParam()
//
// Encapsulates calls to SetGlobalParam
//
// History:
//  01/10/1998 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicPerformance8::SetGlobalParam(REFGUID rguidType, 
                                                void* pData, DWORD dwSize)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL	fValid_pGuidType	= TRUE;
    BOOL    fValid_pData        = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pData
    if(!helpIsValidPtr((void*)pData, sizeof(BYTE) * dwSize, FALSE))
    {
        fValid_pData = FALSE;
    }
    
    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetGlobalParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "pData      == %p   %s",
			pData,
            fValid_pData ? "" : "BAD");
    if(fValid_pData)
    {
        // BUGBUG - log contents of pData @ MAXLOGLEVEL
    }
	fnsLog(PARAMLOGLEVEL, "dwSize     == %08Xh",
			dwSize);
     
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->SetGlobalParam(rguidType, pData, dwSize);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetGlobalParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::SetGlobal()


//===========================================================================
// CtIDirectMusicPerformance8::InitAudioX()
//
// Encapsulates calls to InitAudioX
//
// History:
//  01/16/2001 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::InitAudioX(
	DWORD dwDefaultPathType,                 // Requested default audio path type, also optional.
	DWORD dwPChannelCount,
    DWORD dwVoiceCount,               //Number of Voices (DSoundBuffers) allocated by synth.
    DWORD dwFlags)                   // Number of PChannels, if default audio path to be created.
{
    HRESULT			hRes					= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::InitAudioX()",
            m_szInterfaceName);
    
    fnsLog(PARAMLOGLEVEL, "dwDefaultPathType == %08Xh (%s)",
            dwDefaultPathType, dmthXlatDMUS_APATH(dwDefaultPathType));
    fnsLog(PARAMLOGLEVEL, "dwPChannelCount   == %08Xh",
            dwPChannelCount);
    fnsLog(PARAMLOGLEVEL, "dwVoiceCount   == %08Xh",
            dwVoiceCount);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);

		// call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->InitAudioX(dwDefaultPathType,dwPChannelCount, dwVoiceCount, dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::InitAudioX()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    return hRes;

} // *** end CtIDirectMusicPerformance8::InitAudioX()



//===========================================================================
// CtIDirectMusicPerformance8::PlaySegmentEx()
//
// Encapsulates calls to PlaySegmentEx
//
// History:
//  10/13/1999 - kcraven - created
//  01/17/2000 - kcraven - updated
//  02/02/2000 - kcraven - fixed logging string
//===========================================================================
HRESULT CtIDirectMusicPerformance8::PlaySegmentEx(CtIUnknown* pSource,                  // Segment to play. Alternately, could be an IDirectMusicSong.
                                           CHAR *pzSegmentName,                       // If song, which segment in the song.
                                           CtIUnknown* pTransition,                     // Optional template segment to compose transition with.
                                           DWORD dwFlags,                               // DMUS_SEGF_ flags.
                                           __int64 i64StartTime,                        // Time to start playback.
                                           CtIDirectMusicSegmentState8** ppSegmentState, // Returned Segment State.
                                           CtIUnknown *pFrom,                           // Optional segmentstate or audiopath to replace.
                                           CtIUnknown *pAudioPath)                      // Optional audioPath to play on.
//HRESULT CtIDirectMusicPerformance8::PlaySegmentEx
//(
//	CtIUnknown* pSource,
//	DWORD dwSegmentID,
//	CtIUnknown* pTransition,						// Optional
//	DWORD dwFlags, 
//	__int64 i64StartTime,
//	CtIDirectMusicSegmentState** ppSegmentState,	// Optional
//	CtIUnknown *pFrom,								// Optional
//	CtIUnknown *pAudioPath							// Optional
//)
{
    HRESULT                     hRes					= E_NOTIMPL;
    BOOL		                fValid_pSource			= TRUE;
    BOOL		                fValid_pTransition		= TRUE;
    BOOL		                fValid_ppSegmentState	= TRUE;
    BOOL		                fValid_pFrom			= TRUE;
    BOOL		                fValid_pAudioPath		= TRUE;
    IUnknown*					pdmSource				= NULL;
    IUnknown*					pdmTransition			= NULL;
    IDirectMusicSegmentState*	pdmSegSt                = NULL;
    IDirectMusicSegmentState**	ppdmSegSt				= NULL;
    IUnknown*					pdmFrom					= NULL;
	IUnknown*					pdmAudioPath			= NULL;

    // validate pSource
    if(!helpIsValidPtr((void*)pSource, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pSource = FALSE;
        pdmSource = (IUnknown*)pSource;

    }
    else
    {
        // good pointer, get the real object
        hRes = pSource->GetRealObjPtr(&pdmSource);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pTransition
    if(!helpIsValidPtr((void*)pTransition, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pTransition != NULL)
		{
			fValid_pTransition = FALSE;
		}
        pdmTransition = (IUnknown*)pTransition;

    }
    else
    {
        // good pointer, get the real object
        hRes = pTransition->GetRealObjPtr(&pdmTransition);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppSegmentState
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegmentState pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPerformance:PlaySegment().  Otherwise, we are to create and
    //  return a CtIDirectMusicSegmentState object
    // NOTE:
    //  NULL is valid here... be careful!
    if(!helpIsValidPtr((void*)ppSegmentState,
                        sizeof(CtIDirectMusicSegmentState*), TRUE))
    {
        // bogus pointer, use as such
        if(ppSegmentState != NULL)
		{
	        fValid_ppSegmentState = FALSE;
		}
        ppdmSegSt = (IDirectMusicSegmentState**)ppSegmentState;

    }
    else
    {
        if(ppSegmentState)
        {
            // valid pointer, create a real object
            ppdmSegSt = &pdmSegSt;

            // just in case we fail, init test object ptr to NULL
            *ppSegmentState = NULL;
        }

    }

     // validate pFrom
    if(!helpIsValidPtr((void*)pFrom, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pFrom != NULL)
		{
	        fValid_pFrom = FALSE;
		}
        pdmFrom = (IUnknown*)pFrom;

    }
    else
    {
        // good pointer, get the real object
        hRes = pFrom->GetRealObjPtr(&pdmFrom);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

   // validate pdmAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pAudioPath != NULL)
		{
	        fValid_pAudioPath = FALSE;
		}
        pdmAudioPath = (IUnknown*)pAudioPath;

    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::PlaySegmentEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSource        == %p   %s",
            pdmSource,
            fValid_pSource ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pzSegmentName == %p",
            pzSegmentName);
    fnsLog(PARAMLOGLEVEL, "pTransition    == %08Xh   %s",
            pdmTransition,
            fValid_pTransition ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwFlags        == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "i64StartTime   == %016Xh", //BUGBUG - can't print 64 bit numbers in fnshell
            i64StartTime);
    fnsLog(PARAMLOGLEVEL, "ppSegmentState == %p   %s",
            ppdmSegSt,
            fValid_ppSegmentState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pFrom          == %p   %s",
            pdmFrom,
            fValid_pFrom ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pAudioPath     == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->PlaySegmentEx(
				pdmSource,
				pzSegmentName,
				pdmTransition,
				dwFlags,
				i64StartTime,
				ppdmSegSt,
				pdmFrom,
				pdmAudioPath
				);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::PlaySegmentEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppSegmentState && ppSegmentState)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegmentState == %p",
                pdmSegSt);
    }

    // wrap the segment state so we don't return the real object
    if(SUCCEEDED(hRes) && ppSegmentState)
    {
        hRes = dmthCreateTestWrappedObject(pdmSegSt, ppSegmentState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_pSource && pdmSource)
    {
        pdmSource->Release();
    }
    if(fValid_pTransition && pdmTransition)
    {
        pdmTransition->Release();
    }
    if(fValid_ppSegmentState && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    if(fValid_pFrom && pdmFrom)
    {
        pdmFrom->Release();
    }
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPerformance8::PlaySegmentEx()




//===========================================================================
// CtIDirectMusicPerformance8::StopEx()
//
// Encapsulates calls to StopEx
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::StopEx
(
	CtIUnknown *pObjectToStop,
	__int64 i64StopTime,
	DWORD dwFlags
)
{
    HRESULT     hRes					= E_NOTIMPL;
    BOOL		fValid_pObjectToStop	= TRUE;
	IUnknown 	*pdmObjectToStop 		= NULL;

    // validate pObjectToStop
    if(!helpIsValidPtr((void*)pObjectToStop, sizeof(CtIUnknown), FALSE))
    {
        fValid_pObjectToStop = FALSE;
        pdmObjectToStop = (IUnknown*)pObjectToStop;
    }
    else
    {
        // good pointer, get the real object
        hRes = pObjectToStop->GetRealObjPtr(&pdmObjectToStop);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }


    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObjectToStop == %p   %s",
            pdmObjectToStop,
            fValid_pObjectToStop ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "i64StopTime   == %016Xh", //BUGBUG - can't print 64 bit numbers in fnshell
            i64StopTime);
    fnsLog(PARAMLOGLEVEL, "dwFlags       == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->StopEx(pdmObjectToStop,i64StopTime,dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
 END:
    if(fValid_pObjectToStop && pdmObjectToStop)
    {
        pdmObjectToStop->Release();
    }
   return hRes;

} // *** end CtIDirectMusicPerformance8::StopEx()




//===========================================================================
// CtIDirectMusicPerformance8::ClonePMsg()
//
// Encapsulates calls to ClonePMsg
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::ClonePMsg
(
	DMUS_PMSG* pSourcePMSG,
	DMUS_PMSG** ppCopyPMSG
)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pSourcePMSG				= TRUE;
    BOOL		fValid_ppCopyPMSG				= TRUE;

    // validate pSourcePMSG
    if(!helpIsValidPtr((void*)pSourcePMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_pSourcePMSG = FALSE;
    }

    // validate ppCopyPMSG
    if(!helpIsValidPtr((void*)ppCopyPMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_ppCopyPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourcePMSG == %p   %s",
            pSourcePMSG,
            fValid_pSourcePMSG ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppCopyPMSG  == %p   %s",
            ppCopyPMSG,
            fValid_ppCopyPMSG ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->ClonePMsg(pSourcePMSG,ppCopyPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicPerformance8::ClonePMsg()


//===========================================================================
// CtIDirectMusicPerformance8::CreateAudioPath()
//
// Encapsulates calls to CreateAudioPath
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateAudioPath(
	CtIUnknown *pSourceConfig, 
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath)
{
    HRESULT					hRes					= E_NOTIMPL;
    BOOL					fValid_pSourceConfig	= TRUE;
    BOOL					fValid_ppNewPath		= TRUE;
	IUnknown*				pdmSourceConfig 		= NULL;
    IDirectMusicAudioPath*	pdmNewPath				= NULL;
    IDirectMusicAudioPath**	ppdmNewPath				= NULL;


    // validate pSourceConfig
    if(!helpIsValidPtr((void*)pSourceConfig, sizeof(CtIUnknown), FALSE))
    {
        fValid_pSourceConfig = FALSE;
        pdmSourceConfig = (IUnknown*)pSourceConfig;
    }
    else
    {
        // good pointer, get the real object
        hRes = pSourceConfig->GetRealObjPtr(&pdmSourceConfig);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppNewPath
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmNewPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmNewPath = &pdmNewPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourceConfig == %p   %s",
            pdmSourceConfig,
            fValid_pSourceConfig ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fActivate     == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath     == %p   %s",
            ppdmNewPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateAudioPath(pdmSourceConfig,fActivate,ppdmNewPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmNewPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmNewPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmNewPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

END:
    // done
    if(fValid_ppNewPath && pdmNewPath)
    {
        pdmNewPath->Release();
    }

    //Added 7/13/00 - Danhaff
    if (fValid_pSourceConfig && pdmSourceConfig)
    {
        pdmSourceConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::CreateStandardAudioPath()
//
// Encapsulates calls to CreateStandardAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateStandardAudioPath
(
	DWORD dwType,
	DWORD dwPChannelCount,
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppNewPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwType          == %08Xh (%s)",
            dwType,
            dmthXlatDMUS_APATH(dwType));
    fnsLog(PARAMLOGLEVEL, "dwPChannelCount == %08Xh",
            dwPChannelCount);
    fnsLog(PARAMLOGLEVEL, "fActivate == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath       == %p   %s",
            ppdmPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateStandardAudioPath(dwType,dwPChannelCount,fActivate,ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppNewPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateStandardAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetDefaultAudioPath()
//
// Encapsulates calls to SetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::SetDefaultAudioPath
(
	CtIDirectMusicAudioPath *pAudioPath
)
{
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IDirectMusicAudioPath*	pdmPath	= NULL;

    // validate pTemplate
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIDirectMusicAudioPath),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pAudioPath = FALSE;
        pdmPath = (IDirectMusicAudioPath*)pAudioPath;

    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath       == %p   %s",
            pdmPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetDefaultAudioPath(pdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();
END:
    // done
    if(fValid_pAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetDefaultAudioPath()



//===========================================================================
// CtIDirectMusicPerformance8::GetDefaultAudioPath()
//
// Encapsulates calls to GetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetDefaultAudioPath
(
	CtIDirectMusicAudioPath **ppAudioPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppAudioPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppAudioPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppAudioPath= FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppAudioPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppAudioPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppAudioPath       == %p   %s",
            ppdmPath,
            fValid_ppAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetDefaultAudioPath(ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppAudioPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppAudioPath == %08Xh",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppAudioPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::GetDefaultAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetParamHook()
//
// Encapsulates calls to SetParamHook
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicPerformance8::SetParamHook(CtIDirectMusicParamHook* pIHook)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL		        fValid_pIHook    = TRUE;
    IDirectMusicParamHook   *pdmIHook           = NULL;

    // validate pSegment
    if(!helpIsValidPtr((void*)pIHook, sizeof(CtIDirectMusicGraph),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pIHook = FALSE;
        pdmIHook = (IDirectMusicParamHook*)pIHook;

    }
    else
    {
        // good pointer, get the real object
        hRes = pIHook->GetRealObjPtr(&pdmIHook);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGraph == %p   %s",
            pdmIHook,
            fValid_pIHook ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetParamHook(pdmIHook);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pIHook && pdmIHook)
    {
        pdmIHook->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetParamHook()
*/
//===========================================================================
// CtIDirectMusicPerformance8::GetParamEx()
//
// Encapsulates calls to GetParamEx
//
// History:
//  04/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetParamEx(
	REFGUID rguidType, 
	DWORD dwTrackID,
	DWORD dwGroupBits, 
	DWORD dwIndex, 
	MUSIC_TIME mtTime, 
	MUSIC_TIME* pmtNext, 
	void* pData)
{
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pmtNext		= TRUE;
	BOOL	fValid_pData		= TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtNext = FALSE;
    }
    
    // validate pData
    if(!helpIsValidPtr((void*)pData, 1, FALSE))
    {
        fValid_pData = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType    == %s (%s)",
			szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "dwTrackID    == %08Xh",
            dwTrackID);
    fnsLog(PARAMLOGLEVEL, "dwGroupBits  == %08Xh",
            dwGroupBits);
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
	fnsLog(PARAMLOGLEVEL, "mtTime       == %08Xh",
            mtTime);
	fnsLog(PARAMLOGLEVEL, "pmtNext      == %p   %s",
            pmtNext,
            fValid_pmtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pData        == %p   %s",
            pData,
            fValid_pData ? "" : "BAD");
     
    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetParamEx(
		rguidType, 
		dwTrackID,
		dwGroupBits, 
		dwIndex, 
		mtTime, 
		pmtNext, 
		pData);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtNext)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtNext   == %08Xh",
                *pmtNext);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetParamEx()




//===========================================================================
// CtIDirectMusicPerformance::CloseDown()
//
// Encapsulates calls to CloseDown
//
// History:
//  03/26/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicPerformance::CloseDown(void)
{
    HRESULT hRes = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CloseDown()",
            m_szInterfaceName);
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->CloseDown();

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CloseDown()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


// done
    return hRes;

} //*** end CtIDirectMusicPerformance::CloseDown()


//===========================================================================
// CtIDirectMusicPerformance::Invalidate()
//
// Encapsulates calls to Invalidate
//
// History:
//  12/31/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicPerformance::Invalidate(MUSIC_TIME mtTime, DWORD dwFlags)
{
    HRESULT     hRes						= E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Invalidate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtTime == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);
    
    // call the real function
    hRes = ((IDirectMusicPerformance*)m_pUnk)->Invalidate(mtTime, dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Invalidate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance::Invalidate()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctseg8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctseg8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctseg8.cpp
//
// Test harness implementation of IDirectMusicSegment
//
// Functions:
//    CtIDirectMusicSegment8::SetTrackConfig()
//    CtIDirectMusicSegment8::GetTrackConfig()
//    CtIDirectMusicSegment8::SetClockTimeDuration()
//    CtIDirectMusicSegment8::GetClockTimeDuration()
//    CtIDirectMusicSegment8::SetFlags();
//    CtIDirectMusicSegment8::GetFlags();
//    CtIDirectMusicSegment8::GetObjectInPath()
//    CtIDirectMusicSegment8::GetAudioPathConfig()
//    CtIDirectMusicSegment8::Compose()
//    CtIDirectMusicSegment8::Download()
//    CtIDirectMusicSegment8::Unload()
//
//
// History:
//  10/13/1999 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================

#include "globals.h"

//===========================================================================
// CtIDirectMusicSegment8::CtIDirectMusicSegment8()
//
// Default constructor
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegment8::CtIDirectMusicSegment8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSegment8";

} // *** end CtIDirectMusicSegment8::CtIDirectMusicSegment8()




//===========================================================================
// CtIDirectMusicSegment8::~CtIDirectMusicSegment8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegment8::~CtIDirectMusicSegment8(void)
{
    // nothing to do

} // *** end CtIDirectMusicSegment8::~CtIDirectMusicSegment8()




//===========================================================================
// CtIDirectMusicSegment8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicSegment8 *pdmSegment8 - pointer to real 
//                                      IDirectMusicSegment8 object
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::InitTestClass(IDirectMusicSegment8 *pdmSegment8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSegment8, sizeof(IDirectMusicSegment8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSegment8));

} // *** end CtIDirectMusicSegment8::InitTestClass()




//===========================================================================
// CtIDirectMusicSegment8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSegment8 **ppdmSegment8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetRealObjPtr(IDirectMusicSegment8 **ppdmSegment8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSegment8, sizeof(IDirectMusicSegment8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSegment8));

} // *** end CtIDirectMusicSegment8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicSegment8::SetTrackConfig()
//
// Encapsulates calls to SetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//  03/17/2000 - kcraven - fixedto match dmusic change
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetTrackConfig(
	REFGUID rguidTrackClassID,
    DWORD dwGroup,
    DWORD dwIndex,
    DWORD dwFlagsOn,
    DWORD dwFlagsOff)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID  = TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup    == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex    == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOn  == %08Xh",
            dwFlagsOn);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOff == %08Xh",
            dwFlagsOff);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			dwFlagsOn,
    			dwFlagsOff
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetTrackConfig()




//===========================================================================
// CtIDirectMusicSegment8::GetTrackConfig()
//
// Encapsulates calls to GetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetTrackConfig(
	REFGUID rguidTrackClassID,
	DWORD dwGroup,
	DWORD dwIndex,
	DWORD *pdwFlags)
{
    HRESULT hRes						= E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID	= TRUE;
    BOOL    fValid_pdwFlags				= TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

    // validate pdwFlags
    if(!helpIsValidPtr((void*)pdwFlags, sizeof(DWORD), FALSE))
    {
        fValid_pdwFlags = FALSE;
    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pdwFlags == %p",
            pdwFlags);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			pdwFlags
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);
    if(fValid_pdwFlags)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwFlags == %08Xh",
                *pdwFlags);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetTrackConfig()



//===========================================================================
// CtIDirectMusicSegment8::GetClockTimeDuration()
//
// Encapsulates calls to GetClockTimeDuration
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetClockTimeDuration(REFERENCE_TIME *prtDuration)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_prtDuration    = TRUE;
    
    // validate pmtLength
    if(!helpIsValidPtr((void*)prtDuration, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtDuration	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtDuration == %016Xh   %s",
            prtDuration,
            fValid_prtDuration ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetClockTimeDuration(prtDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtDuration)
    {
        fnsLog(PARAMLOGLEVEL, "*prtDuration == %016Xh",
                *prtDuration);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetClockTimeDuration()



//===========================================================================
// CtIDirectMusicSegment8::SetClockTimeDuration()
//
// Encapsulates calls to SetClockTimeDuration
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetClockTimeDuration(REFERENCE_TIME rtDuration)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtDuration == %016Xh",
            rtDuration);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetClockTimeDuration(rtDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetClockTimeDuration()
*/



//===========================================================================
// CtIDirectMusicSegment8::GetFlags()
//
// Encapsulates calls to GetFlags
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetFlags(DWORD *pdwFlags)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pdwFlags    = TRUE;
    
    // validate pmtLength
    if(!helpIsValidPtr((void*)pdwFlags, sizeof(DWORD), FALSE))
    {
        fValid_pdwFlags	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwFlags == %p   %s",
            pdwFlags,
            fValid_pdwFlags ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetFlags(pdwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwFlags)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwFlags == %08Xh",
                *pdwFlags);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetFlags()
*/



//===========================================================================
// CtIDirectMusicSegment8::SetFlags()
//
// Encapsulates calls to SetFlags
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetFlags(DWORD dwFlags)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetFlags(dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetFlags()
*/



//===========================================================================
// CtIDirectMusicSegment8::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  01/24/2000 - kcraven - created
//  04/06/2000 - danhaff - removed as per dmusic header changes.
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetObjectInPath
(
	DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void ** ppObject
)
{
    HRESULT             hRes					= E_NOTIMPL;
    BOOL	            fValid_ppObject		= TRUE;
    char                szguidObject[MAX_LOGSTRING];
    char                sziidInterface[MAX_LOGSTRING];


    // validate ppObject
    if(!helpIsValidPtr((void*)ppObject, sizeof(void*), FALSE))
    {
        fValid_ppObject = FALSE;
    }

    dmthGUIDtoString(guidObject, szguidObject);
    dmthGUIDtoString(iidInterface, sziidInterface);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwPChannel   == %08Xh",
            dwPChannel);
    fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
            dwStage, dmthXlatDMUS_PATH(dwStage));
    fnsLog(PARAMLOGLEVEL, "dwBuffer     == %08Xh",
            dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject   == %s (%s)",
            szguidObject, dmthXlatGUID(guidObject));
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
            sziidInterface, dmthXlatGUID(iidInterface));
	fnsLog(PARAMLOGLEVEL, "ppObject     == %p   %s",
            ppObject,
            fValid_ppObject ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetObjectInPath(
														dwPChannel,
														dwStage,
														dwBuffer,
														guidObject,
														dwIndex,
														iidInterface,
														ppObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppObject && *ppObject)
    {
        fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
                *ppObject);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetObjectInPath()

*/


//===========================================================================
// CtIDirectMusicSegment8::GetAudioPathConfig()
//
// Encapsulates calls to GetAudioPathConfig
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig)
{
    HRESULT		hRes						= E_NOTIMPL;
    BOOL		fValid_ppIAudioPathConfig	= TRUE;
    IUnknown	*pdmIAudioPathConfig		= NULL;
    IUnknown	**ppdmIAudioPathConfig		= NULL;

    // validate ppIAudioPathConfig
    if(!helpIsValidPtr((void*)ppIAudioPathConfig, sizeof(CtIUnknown*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppIAudioPathConfig = FALSE;
        ppdmIAudioPathConfig = (IUnknown**)ppIAudioPathConfig;

    }
    else
    {
        // valid pointer, create a real object
        ppdmIAudioPathConfig = &pdmIAudioPathConfig;

        // just in case we fail, init test object ptr to NULL
        *ppIAudioPathConfig = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppIAudioPathConfig == %p   %s",
            ppdmIAudioPathConfig,
            (fValid_ppIAudioPathConfig) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetAudioPathConfig(ppdmIAudioPathConfig);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppIAudioPathConfig)
    {
        fnsLog(PARAMLOGLEVEL, "*ppIAudioPathConfig == %p",
                pdmIAudioPathConfig);
		// create the test object
		if(SUCCEEDED(hRes) && pdmIAudioPathConfig)
		{
			hRes = dmthCreateTestWrappedObject(pdmIAudioPathConfig, ppIAudioPathConfig);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
			}
		}
    }

    fnsDecrementIndent();

    // done
    if(fValid_ppIAudioPathConfig && pdmIAudioPathConfig)
    {
        pdmIAudioPathConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::GetAudioPathConfig()


*/

//===========================================================================
// CtIDirectMusicSegment8::Compose()
//
// Encapsulates calls to Compose
//
// History:
//  01/24/2000 - kcraven - created
//  09/16/2000 - danhaff - fixed leak by not releasing real composed segment.
//===========================================================================
HRESULT CtIDirectMusicSegment8::Compose
(
	MUSIC_TIME mtTime,
	CtIDirectMusicSegment* pFromSegment,
	CtIDirectMusicSegment* pToSegment,
	CtIDirectMusicSegment** ppComposedSegment
)
{
    HRESULT	hRes								= E_NOTIMPL;
    BOOL	fValid_pFromSegment					= TRUE;
	BOOL	fValid_pToSegment					= TRUE;
	BOOL	fValid_ppComposedSegment			= TRUE;
    IDirectMusicSegment*	pdmFromSegment		= NULL;
    IDirectMusicSegment*	pdmToSegment		= NULL;
    IDirectMusicSegment*	pdmComposedSegment	= NULL;
    IDirectMusicSegment**	ppdmComposedSegment	= NULL;

    // validate pFromSegment
    if(!helpIsValidPtr((void*)pFromSegment, sizeof(CtIDirectMusicSegment),
                        TRUE))
    {
        fValid_pFromSegment = FALSE;

        // we have a bogus pointer, use it as such
        pdmFromSegment = (IDirectMusicSegment*)pFromSegment;
    }
    else
    {
        // we have a good pointer, get the real object
		if(pFromSegment) // bug NULL is OK
		{
			hRes = pFromSegment->GetRealObjPtr(&pdmFromSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
						"object pointer (%s == %08Xh)",
						tdmXlatHRESULT(hRes), hRes);
				goto END;
			}
		}
    }
    // validate pToSegment
    if(!helpIsValidPtr((void*)pToSegment, sizeof(CtIDirectMusicSegment),
                        TRUE))
    {
        fValid_pToSegment = FALSE;

        // we have a bogus pointer, use it as such
        pdmToSegment = (IDirectMusicSegment*)pToSegment;
    }
    else
    {
		if(pToSegment)
		{
			// we have a good pointer, get the real object
			hRes = pToSegment->GetRealObjPtr(&pdmToSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
						"object pointer (%s == %08Xh)",
						tdmXlatHRESULT(hRes), hRes);
				goto END;
			}
		}
    }
    // validate ppComposedSegment
    if(!helpIsValidPtr((void*)ppComposedSegment, sizeof(CtIDirectMusicSegment*), 
                    TRUE))
    {
        // bogus pointer, use as such
        fValid_ppComposedSegment = FALSE;
        ppdmComposedSegment = (IDirectMusicSegment**)ppComposedSegment;

    }
    else
    {
		if(ppComposedSegment)
		{
			// valid pointer, create a real object
			ppdmComposedSegment = &pdmComposedSegment;

			// just in case we fail, init test object ptr to NULL
			*ppComposedSegment = NULL;
		}
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtTime            == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "pFromSegment      == %p   %s",
            pdmFromSegment,
            (fValid_pFromSegment) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pToSegment        == %p   %s",
            pdmToSegment,
            (fValid_pToSegment) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppComposedSegment == %p   %s",
            ppdmComposedSegment,
            (fValid_ppComposedSegment) ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Compose(
												mtTime,
												pdmFromSegment,
												pdmToSegment,
												ppdmComposedSegment);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppComposedSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppComposedSegment == %p",
                pdmComposedSegment);
		// create the test object
		if(SUCCEEDED(hRes) && pdmComposedSegment)
		{
			hRes = dmthCreateTestWrappedObject(pdmComposedSegment, ppComposedSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}
    fnsDecrementIndent();

    // done
END:
    if(fValid_pFromSegment && pdmFromSegment)
    {
        pdmFromSegment->Release();
    }
    if(fValid_pToSegment && pdmToSegment)
    {
        pdmToSegment->Release();
    }
    
    //danhaff - added 9/16/00
    if (pdmComposedSegment)
    {
        pdmComposedSegment->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Compose()



//===========================================================================
// CtIDirectMusicSegment8::Download()
//
// Encapsulates calls to Download
//
// History:
//  01/24/2000 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::Download(CtIUnknown *pAudioPath)
{
    HRESULT					hRes				= E_NOTIMPL;
    BOOL					fValid_pAudioPath	= TRUE;
    IUnknown	*pdmAudioPath		= NULL;

    fnsLog(10, "Returning from Download() wrapper; invalid call");
    return S_OK;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                        FALSE))
    {
        fValid_pAudioPath = FALSE;

        // we have a bogus pointer, use it as such
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            (fValid_pAudioPath) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Download(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Download()




//===========================================================================
// CtIDirectMusicSegment8::Unload()
//
// Encapsulates calls to Unload
//
// History:
//  01/24/2000 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================
HRESULT CtIDirectMusicSegment8::Unload(CtIUnknown *pAudioPath)
{
    HRESULT					hRes				= E_NOTIMPL;
    BOOL					fValid_pAudioPath	= TRUE;
    IUnknown				*pdmAudioPath		= NULL;

    fnsLog(10, "Returning from Unload() wrapper; invalid call");
    return S_OK;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                        FALSE))
    {
        fValid_pAudioPath = FALSE;

        // we have a bogus pointer, use it as such
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            (fValid_pAudioPath) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Unload(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Unload()

*/

//===========================================================================
// CtIDirectMusicSegment::GetRepeats()
//
// Encapsulates calls to GetRepeats
//
// History:
//  12/31/1997 - a-llucar - created
//  03/16/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetRepeats(DWORD* pdwRepeats)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pdwRepeats   = TRUE;
    
    // validate pdwRepeats
    if(!helpIsValidPtr((void*)pdwRepeats, sizeof(DWORD), FALSE))
    {
        fValid_pdwRepeats	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwRepeats == %p   %s",
            pdwRepeats,
            fValid_pdwRepeats ?  "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetRepeats(pdwRepeats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwRepeats)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwRepeats == %08Xh",
                *pdwRepeats);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetRepeats()



//===========================================================================
// CtIDirectMusicSegment::SetRepeats()
//
// Encapsulates calls to SetRepeats
//
// History:
//  12/31/1997 - a-llucar - created
//  03/16/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetRepeats(DWORD dwRepeats)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwRepeats == %08Xh",
            dwRepeats);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetRepeats(dwRepeats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetRepeats()



//===========================================================================
// CtIDirectMusicSegment::GetLength()
//
// Encapsulates calls to GetLength
//
// History:
//  12/31/1997 - a-llucar - created
//  03/12/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetLength(MUSIC_TIME* pmtLength)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pmtLength    = TRUE;
    
    // validate pmtLength
    if(!helpIsValidPtr((void*)pmtLength, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtLength	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtLength == %p   %s",
            pmtLength,
            fValid_pmtLength ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetLength(pmtLength);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtLength)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtLength == %08Xh",
                *pmtLength);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetLength()

//===========================================================================
// CtIDirectMusicSegment::GetClockTimeLength()
//
// History:
//  04/23/2001- danhaff - created.
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetClockTimeLength(REFERENCE_TIME * prtLength, BOOL *pfClockTime)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_prtLength    = TRUE;
    BOOL    fValid_pfClockTime  = TRUE;
    
    // validate prtLength
    if(!helpIsValidPtr((void*)prtLength, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtLength	= FALSE;
    }
    // validate prtLength
    if(!helpIsValidPtr((void*)pfClockTime, sizeof(BOOL), FALSE))
    {
        fValid_prtLength	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtLength == %p   %s",
            prtLength,
            fValid_prtLength ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pfClockTime == %p   %s",
            pfClockTime,
            fValid_prtLength ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetClockTimeLength(prtLength, pfClockTime);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtLength)
    {
        fnsLog(PARAMLOGLEVEL, "*prtLength == %08Xh",
                *prtLength);
    }

    if (fValid_pfClockTime)
    {
        fnsLog(PARAMLOGLEVEL, "*pfClockTime == %08Xh",
                *pfClockTime);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetLength()


//===========================================================================
// CtIDirectMusicSegment::SetLength()
//
// Encapsulates calls to SetLength
//
// History:
//  12/31/1997 - a-llucar - created
//  03/12/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetLength(MUSIC_TIME mtLength)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtLength == %08Xh",
            mtLength);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetLength(mtLength);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetLength()

//===========================================================================
// CtIDirectMusicSegment::SetClockTimeLength()
//
// History:
//  04/23/2001- danhaff - created.
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetClockTimeLength(REFERENCE_TIME rtLength, BOOL fClockTime)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtLength == %I64Xh",
            rtLength);
    fnsLog(PARAMLOGLEVEL, "fClockTime == %08Xh",
            fClockTime);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetClockTimeLength(rtLength, fClockTime);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetLength()



//===========================================================================
// CtIDirectMusicSegment::SetClockTimeLoopPoints()
//
// Encapsulates calls to SetClockTimeLoopPoints
//
// History:
//  10/05/01    danhaff     created
//  
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetClockTimeLoopPoints(REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetClockTimeLoopPoints()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtStart == %I64X",
            rtStart);
    fnsLog(PARAMLOGLEVEL, "rtEnd == %I64X",
            rtEnd);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetClockTimeLoopPoints(rtStart, rtEnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetClockTimeLoopPoints()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetClockTimeLoopPoints()



//===========================================================================
// CtIDirectMusicSegment::GetClockTimeLoopPoints()
//
// History:
//  10/05/2001- danhaff - created.
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetClockTimeLoopPoints(REFERENCE_TIME * prtStart, REFERENCE_TIME * prtEnd)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_prtStart    = TRUE;
    BOOL    fValid_prtEnd  = TRUE;
    
    // validate prtStart
    if(!helpIsValidPtr((void*)prtStart, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtStart	= FALSE;
    }

    // validate prtStart
    if(!helpIsValidPtr((void*)prtEnd, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtEnd	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtStart == %I64u   %s",
            prtStart,
            fValid_prtStart ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "prtEnd == %I64u   %s",
            prtEnd,
            fValid_prtEnd ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetClockTimeLoopPoints(prtStart, prtEnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtStart)
    {
        fnsLog(PARAMLOGLEVEL, "*prtStart == %I64d",
                *prtStart);
    }

    if(fValid_prtEnd)
    {
        fnsLog(PARAMLOGLEVEL, "*prtEnd == %I64d",
                *prtEnd);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetClockTimeLoopPoints()

*/


//===========================================================================
// CtIDirectMusicSegment::SetLoopPoints()
//
// Encapsulates calls to SetLoopPoints
//
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetLoopPoints(MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetLoopPoints()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtStart == %08X",
            mtStart);
    fnsLog(PARAMLOGLEVEL, "mtEnd == %08X",
            mtEnd);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetLoopPoints(mtStart, mtEnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetLoopPoints()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetLoopPoints()


//===========================================================================
// CtIDirectMusicSegment::GetLoopPoints()
//
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetLoopPoints(MUSIC_TIME * pmtStart, MUSIC_TIME * pmtEnd)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pmtStart    = TRUE;
    BOOL    fValid_pmtEnd  = TRUE;
    
    // validate pmtStart
    if(!helpIsValidPtr((void*)pmtStart, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtStart	= FALSE;
    }

    // validate pmtStart
    if(!helpIsValidPtr((void*)pmtEnd, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtEnd	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtStart == %u   %s",
            pmtStart,
            fValid_pmtStart ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pmtEnd == %u   %s",
            pmtEnd,
            fValid_pmtEnd ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetLoopPoints(pmtStart, pmtEnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtStart)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtStart == %d",
                *pmtStart);
    }

    if(fValid_pmtEnd)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtEnd == %d",
                *pmtEnd);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetLoopPoints()







//===========================================================================
// CtIDirectMusicSegment::SetStartPoint()
//
// Encapsulates calls to SetStartPoint
//
// History:
//  10/05/2001 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetStartPoint(MUSIC_TIME mtStart)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtStart == %08Xh",
            mtStart);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetStartPoint(mtStart);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetStartPoint()


//===========================================================================
// CtIDirectMusicSegment::GetStartPoint()
//
// Encapsulates calls to GetStartPoint
//
// History:
//  10/05/01    danhaff     created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetStartPoint(MUSIC_TIME* pmtStart)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pmtStart    = TRUE;
    
    // validate pmtStart
    if(!helpIsValidPtr((void*)pmtStart, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtStart	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtStart == %p   %s",
            pmtStart,
            fValid_pmtStart ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->GetStartPoint(pmtStart);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtStart)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtStart == %08Xh",
                *pmtStart);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::GetStartPoint()



//===========================================================================
// CtIDirectMusicSegment::SetWavePlaybackParams()
//
// Encapsulates calls to SetWavePlaybackParams
//
// History:
//  10/05/2001 - danhaff  - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetWavePlaybackParams(DWORD dwFlags, DWORD dwReadAhead)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetWavePlaybackParams()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "dwReadAhead == %08Xh",
            dwReadAhead);

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->SetWavePlaybackParams(dwFlags, dwReadAhead);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetWavePlaybackParams()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment::SetWavePlaybackParams()


//===========================================================================
// CtIDirectMusicSegment8::AddNotificationType()
//
// Encapsulates calls to AddNotificationType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/03/1998 - davidkl - renamed to AddNotificationType, fixed logging bug
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicSegment8::AddNotificationType(REFGUID rguidNotificationType)
{
    HRESULT     hRes						    = E_NOTIMPL;
    char        szGuid[MAX_LOGSTRING];
    

    dmthGUIDtoString(rguidNotificationType, szGuid);
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
        szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->AddNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment8::AddNotificationType()


//===========================================================================
// CtIDirectMusicSegment8::RemoveNotificationType()
//
// Encapsulates calls to RemoveNotificationType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/03/1988 - davidkl - renamed to RemoveNotificationType, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicSegment8::RemoveNotificationType(REFGUID rguidNotificationType)
{
    HRESULT     hRes						    = E_NOTIMPL;
    char        szGuid[MAX_LOGSTRING];
    
    dmthGUIDtoString(rguidNotificationType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
        szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicSegment*)m_pUnk)->RemoveNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSegment8::RemoveNotificationType()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\ctsegst8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctsegst.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsegst8.cpp
//
// Test harness implementation of IDirectMusicSegmentState8
//
// Functions:
//    IUnknown
//      CtIDirectMusicSegmentState8::QueryInterface()
//      CtIDirectMusicSegmentState8::AddRef()
//      CtIDirectMusicSegmentState8::Release()
//
//    IDirectMusicSegmentState
//      CtIDirectMusicSegmentState8::GetRepeats()
//      CtIDirectMusicSegmentState8::GetSegment()
//      CtIDirectMusicSegmentState8::GetStartTime()
//      CtIDirectMusicSegmentState8::GetSeek()
//      CtIDirectMusicSegmentState8::GetStartPoint()
//
//    IDirectMusicSegmentState8
//      CtIDirectMusicSegmentState8::SetTrackConfig()
//      CtIDirectMusicSegmentState8::GetTrackConfig()
//      CtIDirectMusicSegmentState8::GetObjectInPath()
//      CtIDirectMusicSegmentState8::Transition()
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================

#include "globals.h"
//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicSegmentState8::CtIDirectMusicSegmentState()
//
// Default constructor
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegmentState8::CtIDirectMusicSegmentState8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSegmentState8";

} // *** end CtIDirectMusicSegmentState8::CtIDirectMusicSegmentState8()


//===========================================================================
// CtIDirectMusicSegmentState8::~CtIDirectMusicSegmentState8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegmentState8::~CtIDirectMusicSegmentState8(void)
{
    // nothing to do

} // *** end CtIDirectMusicSegmentState8::~CtIDirectMusicSegmentState8()


//===========================================================================
// CtIDirectMusicSegmentState8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmSegmentState - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::InitTestClass(IDirectMusicSegmentState8 *pdmSegmentState8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSegmentState8, sizeof(IDirectMusicSegmentState8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSegmentState8));

} // *** end CtIDirectMusicSegmentState8::InitTestClass()


//===========================================================================
// CtIDirectMusicSegmentState8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSegmentState8 **ppdmSegmentState - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetRealObjPtr(IDirectMusicSegmentState8 **ppdmSegmentState8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSegmentState8, sizeof(IDirectMusicSegmentState8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSegmentState8));

} // *** end CtIDirectMusicSegmentState8::GetRealObjPtr()

/*
//===========================================================================
// CtIDirectMusicSegmentState8::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::QueryInterface(REFIID riid,
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::QueryInterface


//===========================================================================
// CtIDirectMusicSegmentState8::GetRepeats()
//
// Encapsulates calls to GetRepeats
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetRepeats(DWORD* pdwRepeats)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pdwRepeats			= TRUE;

    // validate pGraph
    if(!helpIsValidPtr((void*)pdwRepeats, sizeof(DWORD), FALSE))
    {
        fValid_pdwRepeats	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwRepeats == %p   %s",
            pdwRepeats,
            fValid_pdwRepeats ? "" : "BAD");

    // call the real function
    hRes = ((CtIDirectMusicSegmentState8*)m_pUnk)->GetRepeats(pdwRepeats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRepeats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwRepeats)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwRepeats == %08Xh",
                *pdwRepeats);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetRepeats()

*/
//===========================================================================
// CtIDirectMusicSegmentState::GetSegment()
//
// Encapsulates calls to GetSegment
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetSegment(CtIDirectMusicSegment** pptdmSegment)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL		        fValid_pptdmSegment	= TRUE;
    IDirectMusicSegment *pdmSeg             = NULL;
    IDirectMusicSegment **ppdmSeg           = NULL;

    // validate pptdmSegment
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicSegmentState8::GetSegment().  Otherwise, we are to create and
    //  return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSegment, sizeof(CtIDirectMusicSegment*),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSegment = FALSE;
        ppdmSeg = (IDirectMusicSegment**)pptdmSegment;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSeg = &pdmSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSegment = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppSegment == %p   %s",
            ppdmSeg,
            fValid_pptdmSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetSegment(ppdmSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
                pdmSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSeg, pptdmSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmSegment && pdmSeg)
    {
        pdmSeg->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetSegment()


//===========================================================================
// CtIDirectMusicSegmentState8::GetStartTime()
//
// Encapsulates calls to GetStartTime
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetStartTime(MUSIC_TIME* pmtOffset)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pmtOffset			= TRUE;

    // validate pmtOffset
    if(!helpIsValidPtr((void*)pmtOffset,
                        sizeof(MUSIC_TIME),
                        FALSE))
    {
        fValid_pmtOffset	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtOffset == %p   %s",
            pmtOffset,
            fValid_pmtOffset ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetStartTime(pmtOffset);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtOffset)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtOffset == %08Xh",
                *pmtOffset);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetStartTime()

/*


//===========================================================================
// CtIDirectMusicSegmentState::GetSeek()
//
// Encapsulates calls to GetSeek
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetSeek(MUSIC_TIME* pmtSeek)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pmtSeek				= TRUE;

    // validate pmtOffset
    if(!helpIsValidPtr((void*)pmtSeek, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtSeek	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetSeek()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtSeek == %p   %s",
            pmtSeek,
            fValid_pmtSeek ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetSeek(pmtSeek);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetSeek()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtSeek)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtSeek == %08Xh",
                *pmtSeek);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetSeek()


//===========================================================================
// CtIDirectMusicSegmentState8::GetStartPoint()
//
// Encapsulates calls to GetStartPoint
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetStartPoint(MUSIC_TIME *pmtStart)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pmtStart = TRUE;

    // validate pmtStart
    if(!helpIsValidPtr((void*)pmtStart, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtStart = FALSE;
    }

	fnsIncrementIndent();

	// log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pmtStart == %p   %s",
            pmtStart,
            fValid_pmtStart ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetStartPoint(pmtStart);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetStartPoint()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);
    if(fValid_pmtStart)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtStart == %08Xh",
                *pmtStart);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetStartPoint()


*/

//===========================================================================
// CtIDirectMusicSegmentState8::SetTrackConfig()
//
// Encapsulates calls to SetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//  03/17/2000 - kcraven - fixed to match dmusic change
//===========================================================================
/*
HRESULT CtIDirectMusicSegmentState8::SetTrackConfig(
	REFGUID rguidTrackClassID,
    DWORD dwGroup,
    DWORD dwIndex,
    DWORD dwFlagsOn,
    DWORD dwFlagsOff)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID  = TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup    == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex    == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOn  == %08Xh",
            dwFlagsOn);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOff == %08Xh",
            dwFlagsOff);

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->SetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			dwFlagsOn,
    			dwFlagsOff
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::SetTrackConfig()




//===========================================================================
// CtIDirectMusicSegmentState8::GetTrackConfig()
//
// Encapsulates calls to GetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegmentState8::GetTrackConfig(
	REFGUID rguidTrackClassID,
	DWORD dwGroup,
	DWORD dwIndex,
	DWORD *pdwFlags)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID  = TRUE;
    BOOL    fValid_pdwFlags  = TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

    // validate pdwFlags
    if(!helpIsValidPtr((void*)pdwFlags, sizeof(DWORD), FALSE))
    {
        fValid_pdwFlags = FALSE;
    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pdwFlags == %p",
            pdwFlags);

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			pdwFlags
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);
    if(fValid_pdwFlags)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwFlags == %08Xh",
                *pdwFlags);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetTrackConfig()
*/



//===========================================================================
// CtIDirectMusicSegmentState8::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::GetObjectInPath(
    DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void** ppObject)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_guidObject		= TRUE;
    BOOL    fValid_iidInterface		= TRUE;
    BOOL    fValid_ppObject			= TRUE;
    char    szGuidObj[MAX_LOGSTRING];
    char    szGuidIID[MAX_LOGSTRING];

    dmthGUIDtoString(guidObject, szGuidObj);
    dmthGUIDtoString(iidInterface, szGuidIID);

    // validate ppObject
    if(!helpIsValidPtr((void*)ppObject,1, FALSE))
    {
        fValid_ppObject = FALSE;
    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwPChannel   == %08Xh%s",
            dwPChannel,
            dwPChannel==DMUS_PCHANNEL_ALL ? " (DMUS_PCHANNEL_ALL)":"");
    fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
            dwStage, dmthXlatDMUS_STAGE(dwStage));
    fnsLog(PARAMLOGLEVEL, "dwBuffer     == %08Xh",
            dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject   == %s (%s)",
            szGuidObj, dmthXlatGUID(guidObject));
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
            szGuidIID, dmthXlatGUID(iidInterface));
    fnsLog(PARAMLOGLEVEL, "ppObject     == %p   %s",
            ppObject,
            (fValid_ppObject) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->GetObjectInPath(
		dwPChannel,
		dwStage,
		dwBuffer,
		guidObject,
		dwIndex,
		iidInterface,
		ppObject
		);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::GetObjectInPath()





//===========================================================================
// CtIDirectMusicSegmentState8::SetVolume()
//
// Encapsulates calls to SetVolume
//
// Parameters:
//  
//  lVolume:   Gain, in 100ths of a dB.
//  dwDuration Duration of volume ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::SetVolume(long lVolume, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVolume()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lVolume == %d", lVolume);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->SetVolume(lVolume, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVolume()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}


//===========================================================================
// CtIDirectMusicSegmentState8::SetPitch()
//
// Encapsulates calls to SetPitch
//
// Parameters:
//  
//  lPitch:    Pitch bend, in 100ths of a semitone.
//  dwDuration Duration of Pitch ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicSegmentState8::SetPitch(long lPitch, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetPitch()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lPitch == %d", lPitch);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->SetPitch(lPitch, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetPitch()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}



//===========================================================================
// CtIDirectMusicSegmentState8::Transition()
//
// Encapsulates calls to Transition
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegmentState8::Transition(DWORD dwDestinationSegment)
{
    HRESULT hRes            = E_NOTIMPL;

	fnsIncrementIndent();

	// log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Transition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwDestinationSegment == %08Xh",
            dwDestinationSegment);

    // call the real function
    hRes = ((IDirectMusicSegmentState8*)m_pUnk)->Transition(dwDestinationSegment);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Transition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::Transition()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\dmth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmth.h
//
//--------------------------------------------------------------------------

//===========================================================================
// dmth.h
//
// DirectMusic test harness class descriptions
//
// History:
//  10/14/1997 - davidkl - created
//  01/09/1998 - a-llucar - added method to dmloader.h
//  01/13/1998 - a-llucar - added IDMDownload (from dmusic.h)
//  03/02/1998 - davidkl - ported to latest dmusic architecture changes
//  03/25/1998 - davidkl - removed all non-class goop, renamed to dmthcls
//  05/11/1998 - a-trevg - added explicit _stdcall to exported functions
//  07/31/1998 - a-llucar - added GetResolvedTime method
//  10/13/1998 - kcraven - added Loader::SetObject method
//  10/12/1999 - kcraven - started adding DX8 wmethods
//  01/24/2000 - kcraven - continued adding DX8 methods
//  01/25/2000 - kcraven - start moving dhthCreate Helpers to common file
//  02/18/2000 - kcraven - added loader8 LoadObjectFromFile commented out
//  02/26/2000 - danhaff - Added Port8::SetSink and GetSink methods.
//  03/17/2000 - kcraven - changed Seg8 and SegSt8 to match changes in dmusic.
//  03/29/2000 - kcraven - attempting to sync to dmusic again.
//  04/04/2000 - kcraven - changing to use the SD dmusic headers and
//                         removing dependencies on private checked-in headers
//  04/06/2000 - danhaff-  Removd certain wrapper objects as per dmusic
//                         header changes.
//  04/12/2000 - danhaff-  Added logging functions for DSFX
//  05/01/2000 - kcraven-  Added wrapper for idirectmusic8
//  01/01/2001 - danhaff-  Ported to XBox.
//===========================================================================

#pragma once

//===========================================================================


// included headers
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdlib.h>
#include <float.h>

#include <dsound.h>
#include <dmusici.h>

#include "dmthhelp.h"
#include "memptr.h"
//#include "dmStress.h"  //So the wrapper definitions can know about their object stressor objects.
//#include "dmStressControl.h" //So the app may control which interfaces are stressed.

// symbolic constants
#ifndef MAX_LOGSTRING
#define MAX_LOGSTRING       127
#endif
// logging level for tracking method calls
#ifndef CALLLOGLEVEL
#define CALLLOGLEVEL        3
#endif
// logging level for parameter data
#ifndef PARAMLOGLEVEL
#define PARAMLOGLEVEL       5
#endif
// logging level for structure contents
#ifndef STRUCTLOGLEVEL
#define STRUCTLOGLEVEL      6
#endif
// MINimum logging level
#ifndef MINLOGLEVEL
#define MINLOGLEVEL         0
#endif
// MAXimum logging level
#ifndef MAXLOGLEVEL
#define MAXLOGLEVEL         10
#endif


//---------------------------------------------------------------------------

// forward definitions for test classes
class CtIUnknown;

//---------------------------------------------------------------------------
class CtIDirectMusicObject8;      
typedef CtIDirectMusicObject8 CtIDirectMusicObject;


class CtIDirectMusicLoader8;      
typedef CtIDirectMusicLoader8 CtIDirectMusicLoader;

class CtIDirectMusicSegment8;     
typedef CtIDirectMusicSegment8 CtIDirectMusicSegment;


class CtIDirectMusicAudioPath;    

class CtIDirectMusicSegmentState8;
typedef CtIDirectMusicSegmentState8 CtIDirectMusicSegmentState;

class CtIDirectMusicPerformance8;
typedef CtIDirectMusicPerformance8 CtIDirectMusicPerformance;

class CtIDirectMusicScript;       

class CtIDirectMusicTool;

//===========================================================================
// CtIUnknown
//
// Wrapper class for IUnknown.
//    This is the base class for all other dmusic test harness classes
//
//===========================================================================
class CtIUnknown
{
    public:
    // constructor / destructor
    CtIUnknown();
    virtual ~CtIUnknown();
    // test class helpers
    virtual HRESULT InitTestClass(IUnknown *pUnk);
    virtual HRESULT GetRealObjPtr(IUnknown **ppUnk);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    //danhaff - snuck this out so template functions could print what interface they're using.
    LPSTR       m_szInterfaceName;

    protected:
    IUnknown            *m_pUnk;
    DWORD               m_dwRefCount;
//    DMOBJECTSTRESSOR    *m_pDMObjectStressor;

}; // ** end CtIUnknown


//===========================================================================
// CtIDirectMusicObject8
//
// Wrapper class for IDirectMusicObject8
//
// Inherits from CtIDirectMusicObject
//===========================================================================
class CtIDirectMusicObject8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicObject8();
    ~CtIDirectMusicObject8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicObject8 *pdmObject8);
    virtual HRESULT GetRealObjPtr(IDirectMusicObject8 **ppdmObject8);

    virtual HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IDirectMusicObject8
//    virtual void Zombie(void);

    protected:
//    BOOL    m_bZombie; //special BOOL for testing Zombie

}; // ** end CtIDirectMusicObject8


//===========================================================================
// CtIDirectMusicLoader8
//
// Wrapper class for IDirectMusicLoader8
//
// Inherits from CtIDirectMusicLoader
//===========================================================================
class CtIDirectMusicLoader8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicLoader8();
    ~CtIDirectMusicLoader8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicLoader8 *pdmLoader8);
    virtual HRESULT GetRealObjPtr(IDirectMusicLoader8 **ppdmLoader8);


    //Loader1
    virtual HRESULT GetObject(LPDMUS_OBJECTDESC pDesc,
                            REFIID riid,
                            void** ppv);
    virtual HRESULT SetObject(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT SetSearchDirectory(GUID idClass,
                                        CHAR *pzPath,
                                        BOOL fClear);
    
    //Loader8
    virtual HRESULT ClearCache(GUID idClass);

/*
    virtual HRESULT ScanDirectory(GUID idClass,
                                WCHAR *pwzFileExtension,
                                WCHAR *pwzCacheFileName);
    virtual HRESULT ReleaseObject(CtIDirectMusicObject *pObject);
    virtual HRESULT EnableCache(GUID idClass,
                                BOOL fEnable);
    virtual HRESULT CacheObject(CtIDirectMusicObject *pObject);
    virtual HRESULT EnumObject(GUID idClass,
                                DWORD dwIndex,
                                LPDMUS_OBJECTDESC pDesc);




  virtual HRESULT EnableGarbageCollector(BOOL fEnable);
*/

    virtual void CollectGarbage(void);
    virtual HRESULT ReleaseObjectByUnknown(CtIUnknown *pObject);

//  virtual HRESULT GetDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           LPDMUS_OBJECTDESC pDesc,
//                                                           REFIID riid,
//                                                           LPVOID FAR *ppv);
//  virtual HRESULT ReportDynamicallyReferencedObject(CtIDirectMusicObject *pSourceObject,
//                                                           CtIUnknown *pReferencedObject);
    virtual HRESULT LoadObjectFromFile(REFGUID rguidClassID,
                                        REFIID iidInterfaceID,
                                        const CHAR *pzFilePath,
                                        void ** ppObject);

}; // ** end CtIDirectMusicLoader8


//===========================================================================
// CtIDirectMusicSegment8
//
// Wrapper class for IDirectMusicSegment8
//
// Inherits from CtIDirectMusicSegment
//===========================================================================
class CtIDirectMusicSegment8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegment8();
    ~CtIDirectMusicSegment8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegment8 *pdmSegment8);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegment8 **ppdmSegment8);

    virtual HRESULT SetRepeats(DWORD dwRepeats);
    virtual HRESULT GetRepeats(DWORD *pdwRepeats);

    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);


/*
    // IDirectMusicSegment8
    virtual HRESULT SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex,DWORD dwFlagsOn,DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags);
//  virtual HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
//  virtual HRESULT GetClockTimeDuration(REFERENCE_TIME *prtDuration);
//  virtual HRESULT SetFlags(DWORD dwFlags);
//  virtual HRESULT GetFlags(DWORD *pdwFlags);
//  virtual HRESULT GetObjectInPath(DWORD dwPChannel,DWORD dwStage, DWORD dwBuffer,
//                          REFGUID guidObject,DWORD dwIndex,REFGUID iidInterface,void ** ppObject);
    virtual HRESULT GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig);
*/


    virtual HRESULT Compose(MUSIC_TIME mtTime,CtIDirectMusicSegment* pFromSegment,
                            CtIDirectMusicSegment* pToSegment,CtIDirectMusicSegment** ppComposedSegment);

//    virtual HRESULT Download(CtIUnknown *pAudioPath);
//    virtual HRESULT Unload(CtIUnknown *pAudioPath);


    virtual HRESULT GetLength(MUSIC_TIME* pmtLength);
    virtual HRESULT SetLength(MUSIC_TIME mtLength);

    virtual HRESULT SetClockTimeLength(REFERENCE_TIME rtLength, BOOL fClockTime);
    virtual HRESULT GetClockTimeLength(REFERENCE_TIME * prtLength, BOOL *pfClockTime);
//    virtual HRESULT SetClockTimeLoopPoints(REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd);
//    virtual HRESULT GetClockTimeLoopPoints(REFERENCE_TIME * prtStart, REFERENCE_TIME * prtEnd);
    virtual HRESULT SetLoopPoints(MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    virtual HRESULT GetLoopPoints(MUSIC_TIME * pmtStart, MUSIC_TIME * pmtEnd);
    virtual HRESULT SetStartPoint(MUSIC_TIME mtStart);
    virtual HRESULT GetStartPoint(MUSIC_TIME* pmtStart);
    virtual HRESULT SetWavePlaybackParams(DWORD dwFlags, DWORD dwReadAhead);

};

//===========================================================================
// CtIDirectMusicAudioPath
//
// Wrapper class for IDirectMusicAudioPath
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicAudioPath : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicAudioPath();
    ~CtIDirectMusicAudioPath();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicAudioPath *pdmAudioPath);
    virtual HRESULT GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicAudioPath methods
    virtual HRESULT GetObjectInPath(DWORD dwPChannel,
                                           DWORD dwStage,
                                             DWORD dwBuffer,
                                           REFGUID guidObject,
                                           DWORD dwIndex,
                                           REFGUID iidInterface,
                                           void ** ppObject);
    virtual HRESULT Activate(BOOL fActivate);
    virtual HRESULT SetVolume(long lVolume, DWORD dwDuration);
    virtual HRESULT SetPitch (long lPitch,  DWORD dwDuration);

//    virtual HRESULT ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut);

};



//===========================================================================
// CtIDirectMusicSegmentState8
//
// Wrapper class for IDirectMusicSegmentState8
//
// Inherits from CtIDirectMusicSegmentState
//===========================================================================
class CtIDirectMusicSegmentState8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSegmentState8();
    ~CtIDirectMusicSegmentState8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSegmentState8 *pdmSegmentState);
    virtual HRESULT GetRealObjPtr(IDirectMusicSegmentState8 **ppdmSegmentState);
    // the IDirectMusicSegmentState8 methods
/*
    virtual HRESULT SetTrackConfig(
                            REFGUID rguidTrackClassID,
                            DWORD dwGroup,
                            DWORD dwIndex,
                            DWORD dwFlagsOn,
                            DWORD dwFlagsOff);
//PHOOPHOO
//  virtual HRESULT GetTrackConfig(
//                          REFGUID rguidTrackClassID,
//                          DWORD dwGroup,
//                          DWORD dwIndex,
//                          DWORD *pdwFlags);
*/
    virtual HRESULT GetObjectInPath(
                            DWORD dwPChannel,
                            DWORD dwStage,
                            DWORD dwBuffer,
                            REFGUID guidObject,
                            DWORD dwIndex,
                            REFGUID iidInterface,
                            void ** ppObject);

    virtual HRESULT GetSegment(CtIDirectMusicSegment** pptdmSegment);
    virtual HRESULT GetStartTime(MUSIC_TIME* pmtOffset);
    virtual HRESULT SetVolume(long lVolume, DWORD dwDuration);
    virtual HRESULT SetPitch (long lPitch,  DWORD dwDuration);



};



//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    ~CtIDirectMusicPerformance8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPerformance8 *pdmPerformance);
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);

    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    // the IDirectMusicPerformance methods
/*
    virtual HRESULT Init(CtIDirectMusic** pptdm,
                        LPDIRECTSOUND pDirectSound,
                        HWND hWnd);
    virtual HRESULT PlaySegment(CtIDirectMusicSegment* ptdmSegment,
                            DWORD dwFlags, REFERENCE_TIME rtStartTime,
                            CtIDirectMusicSegmentState** pptdmSegmentState);
    virtual HRESULT Stop(CtIDirectMusicSegment* ptdmSegment,
                        CtIDirectMusicSegmentState* ptdmSegmentState,
                        MUSIC_TIME mtTime, DWORD dwFlags);
*/
    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
/*
    virtual HRESULT SetPrepareTime(DWORD dwMilliSeconds);
    virtual HRESULT GetPrepareTime(DWORD* pdwMilliSeconds);
    virtual HRESULT SetBumperLength(DWORD dwMilliSeconds);
    virtual HRESULT GetBumperLength(DWORD* pdwMilliSeconds);
*/
    virtual HRESULT MusicToReferenceTime(MUSIC_TIME mtTime,
                                            REFERENCE_TIME* prtTime);
    virtual HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime,
                                            MUSIC_TIME* pmtTime);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment8* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
/*
    virtual HRESULT GetGraph(CtIDirectMusicGraph** pptdmGraph);
    virtual HRESULT SetGraph(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT SetNotificationHandle(HANDLE hNotification,
                                        REFERENCE_TIME rtMinimum);
*/
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
/*
    virtual HRESULT AddPort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT RemovePort(CtIDirectMusicPort* ptdmPort);
    virtual HRESULT AssignPChannelBlock(DWORD dwBlockNum,
                                        CtIDirectMusicPort* ptdmPort,
                                        DWORD dwGroup);
    virtual HRESULT AssignPChannel(DWORD dwPChannel,
                                    CtIDirectMusicPort* ptdmPort,
                                    DWORD dwGroup, DWORD dwMChannel);
    virtual HRESULT PChannelInfo(DWORD dwPChannel,
                                    CtIDirectMusicPort** pptdmPort,
                                    DWORD* pdwGroup, DWORD* pdwMChannel);
    virtual HRESULT DownloadInstrument( CtIDirectMusicInstrument* ptdmInst,
                                        DWORD dwPChannel,
                                        CtIDirectMusicDownloadedInstrument** pptdmDownInst,
                                        DMUS_NOTERANGE* pNoteRanges,
                                        DWORD dwNumNoteRanges,
                                        CtIDirectMusicPort** pptdmPort,
                                        DWORD* pdwGroup,
                                        DWORD* pdwMChannel);
*/
    virtual HRESULT Invalidate(MUSIC_TIME mtTime, DWORD dwFlags);
/*
    virtual HRESULT GetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            MUSIC_TIME* pmtNext, void* pData);
    virtual HRESULT SetParam(REFGUID rguidType, DWORD dwGroupBits,
                            DWORD dwIndex, MUSIC_TIME mtTime,
                            void* pData);
*/
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT CloseDown(void);
/*
    virtual HRESULT GetLatencyTime(REFERENCE_TIME*);
    virtual HRESULT GetQueueTime(REFERENCE_TIME* prtTime);
    virtual HRESULT AdjustTime(REFERENCE_TIME rtAmount);
    virtual HRESULT GetResolvedTime(REFERENCE_TIME rtTime, REFERENCE_TIME* prtResolved, DWORD dwFlags);
    virtual HRESULT MIDIToMusic(BYTE bMIDIValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    WORD *pwMusicValue);
    virtual HRESULT MusicToMIDI(WORD wMusicValue,
                                    DMUS_CHORD_KEY* pChord,
                                    BYTE bPlayMode,
                                    BYTE bChordLevel,
                                    BYTE *pbMIDIValue);
    virtual HRESULT TimeToRhythm(MUSIC_TIME mtTime,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    WORD *pwMeasure,
                                    BYTE *pbBeat,
                                    BYTE *pbGrid,
                                    short *pnOffset);
    virtual HRESULT RhythmToTime(WORD wMeasure,
                                    BYTE bBeat,
                                    BYTE bGrid,
                                    short nOffset,
                                    DMUS_TIMESIGNATURE *pTimeSig,
                                    MUSIC_TIME *pmtTime);
*/






    // IDirectMusicPerformance8

    virtual HRESULT InitAudioX(DWORD dwDefaultPathType,  // Requested default audio path type, also optional.
	                           DWORD dwPChannelCount,    // Number of PChannels, if default audio path to be created.
                               DWORD dwVoiceCount,       // Number of Voices (DSoundBuffers) allocated by synth.
                               DWORD dwFlags);           // 0=DMusic will run DoWork() thread, 1=App will do it.

    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            CHAR *pzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState8** ppSegmentState8, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
    virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT ClonePMsg(DMUS_PMSG* pSourcePMSG,
                                            DMUS_PMSG** ppCopyPMSG);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
    virtual HRESULT GetDefaultAudioPath(CtIDirectMusicAudioPath **ppAudioPath);
//PHOOPHOO
//  virtual HRESULT SetParamHook(CtIDirectMusicParamHook *pIHook);
    virtual HRESULT GetParamEx(REFGUID rguidType,   // GetParam command ID.
                                DWORD dwTrackID,        // Virtual track ID of caller.
                                DWORD dwGroupBits,      // Group bits of caller.
                                DWORD dwIndex,          // Index to Nth parameter.
                                MUSIC_TIME mtTime,      // Time of requested parameter.
                                MUSIC_TIME* pmtNext,    // Returned delta to next parameter.
                                void* pParam);          // Data structure to fill with parameter.

};

//===========================================================================
// CtIDirectMusicScript
//
// Wrapper class for IDirectMusicScript
//
// Inherits from CtIUnknown
//
// NOTE:  We're using IUnknown instead of CtIUnknown for the Get/SetVariableObject
//        methods, since it will simplify testing code and it's really another
//        variable like BOOL or LONG, for which we do not wrap. - Jimmo
//===========================================================================
class CtIDirectMusicScript : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicScript();
    ~CtIDirectMusicScript();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicScript  *pdmScript);
    virtual HRESULT GetRealObjPtr(IDirectMusicScript **ppdmScript);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicScript methods
    virtual HRESULT Init(CtIDirectMusicPerformance *pPerformance, DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT CallRoutine(CHAR *pszRoutineName, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
/*
    virtual HRESULT SetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT varValue,
                                               BOOL fSetRef,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableVariant(WCHAR *pwszVariableName,
                                               VARIANT *pvarValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
*/
    virtual HRESULT SetVariableNumber(CHAR *pszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableNumber(CHAR *pszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT SetVariableObject(CHAR *pszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
    virtual HRESULT GetVariableObject(CHAR *pszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo);
//  virtual HRESULT GetVariableObject(WCHAR *pwszVariableName,
//                                               IUnknown **ppunkValue,
//                                               DMUS_SCRIPT_ERRORINFO* pdmScriptErrorInfo);
/*
    virtual HRESULT EnumRoutine(DWORD dwIndex,WCHAR *pwszName);
    virtual HRESULT EnumVariable(DWORD dwIndex,WCHAR *pwszName);
*/

    virtual HRESULT GetVariableString
    (
        CHAR                   *pszVariableName,
        CHAR                   *pszValue,
        LONG                    lLength,
        LONG                   *plConverted,
        DMUS_SCRIPT_ERRORINFO  *pdmScriptErrorInfo
    );


    virtual HRESULT SetVariableString
    (
        CHAR                   *pszVariableName,
        CHAR                   *pszValue,
        DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
    );

};


//===========================================================================
// CtIDirectMusicGraph
//
// Wrapper class for IDirectMusicGraph
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicGraph : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicGraph();
    ~CtIDirectMusicGraph();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicGraph *pdmGraph);
    virtual HRESULT GetRealObjPtr(IDirectMusicGraph **ppdmGraph);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicGraph methods
    virtual HRESULT StampPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT InsertTool(CtIDirectMusicTool* ptdmTool,
                                        DWORD* pdwPChannels,
                                        DWORD cPChannel,
                                        LONG lIndex);
    virtual HRESULT GetTool(DWORD dwIndex,
                            CtIDirectMusicTool **pptdmTool);
    virtual HRESULT RemoveTool(CtIDirectMusicTool *ptdmTool);

}; // ** end CtIDirectMusicGraph



//===========================================================================
// CtIDirectMusicTool
//
// Wrapper class for IDirectMusicTool
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicTool : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicTool();
    ~CtIDirectMusicTool();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicTool *pdmTool);
    virtual HRESULT GetRealObjPtr(IDirectMusicTool **ppdmTool);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicTool methods
    virtual HRESULT Init(CtIDirectMusicGraph* ptdmGraph);
    virtual HRESULT GetMsgDeliveryType(DWORD* pdwDeliveryType);
    virtual HRESULT GetMediaTypeArraySize(DWORD* pdwNumElements);
    virtual HRESULT GetMediaTypes(DWORD** padwMediaTypes,
                                DWORD dwNumElements);
    virtual HRESULT ProcessPMsg(CtIDirectMusicPerformance* ptdmPerf,
                                DMUS_PMSG* pPMSG);
    virtual HRESULT Flush(CtIDirectMusicPerformance* ptdmPerf,
                            DMUS_PMSG* pPMSG,
                            REFERENCE_TIME rtTime);


}; // ** end CtIDirectMusicTool



//===========================================================================
// test class GUIDs.
//
// These allow us to mascquerade as the real interfaces
//===========================================================================

DEFINE_GUID(CTIID_IUnknown,                             0x88e62400, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicSegment8,                 0xf65da357, 0x7cfb, 0x4cc7, 0xbe, 0x9d, 0x6, 0x25, 0x14, 0xd5, 0xcf, 0x18);
DEFINE_GUID(CTIID_IDirectMusicLoader8,                  0xb48f6473, 0x759f, 0x472d, 0x8c, 0xa0, 0x47, 0x90, 0x7a, 0xe3, 0x6f, 0x87);
DEFINE_GUID(CTIID_IDirectMusicObject8,                    0xe92c35c, 0x4980, 0x40af, 0x99, 0x9f, 0x64, 0x65, 0x99, 0xcd, 0x8d, 0x1c);
DEFINE_GUID(CTIID_IDirectMusicPerformance8,             0x5cffd8de, 0x3d40, 0x4020, 0xac, 0x3e, 0x6d, 0xd2, 0x7, 0x92, 0x98, 0x1d);
DEFINE_GUID(CTIID_IDirectMusicSegmentState8,            0x7af67385, 0x94db, 0x4f5e, 0x99, 0xe4, 0xec, 0xdd, 0xb2, 0x67, 0x76, 0x5b);
DEFINE_GUID(CTIID_IDirectMusicScript,                   0x8aa10b67, 0x1894, 0x46dc, 0xb5, 0xa0, 0x50, 0x6d, 0x3, 0xf5, 0x50, 0x1f);
DEFINE_GUID(CTIID_IDirectMusicAudioPath,                0x50a0078d, 0x687e, 0x4a26, 0x8b, 0x83, 0x1d, 0x16, 0x3b, 0x5c, 0xd2, 0xf6);
//DEFINE_GUID(CTIID_IDirectMusicLoader,                   0x88e6240B, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicObject,                   0x88e6240C, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicPerformance,              0x88e6240D, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicSegment,                  0x88e62411, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicSegmentState,             0x88e62412, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusic,                         0x88e62401, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicBand,                     0x88e62402, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicBuffer,                   0x88e62403, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicCollection,               0x88e62404, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicComposer,                 0x88e62405, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicDownload,                 0x88e62406, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicDownloadedInstrument,     0x88e62407, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
DEFINE_GUID(CTIID_IDirectMusicGraph,                    0x88e62408, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicInstrument,               0x88e6240A, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicChordMap,                 0x88e6240E, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicPort,                     0x88e6240F, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicPortDownload,             0x88e62410, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicStyle,                    0x88e62413, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicSynth,                    0x88e62414, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicSynthSink,                0x88e62415, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicTool,                     0x88e62416, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicTrack,                    0x88e62417, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IReferenceClock,                      0x88e62418, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);
//DEFINE_GUID(CTIID_IDirectMusicGetLoader,                0x88e62420, 0xc41b, 0x11d1, 0x8a, 0xfb, 0x0, 0xaa, 0x0, 0x44, 0x36, 0xf9);

//dx7
//DEFINE_GUID(CTIID_IDirectMusicPerformance2,             0x7153d4c9, 0x5d74, 0x45dc, 0x8d, 0xef, 0x64, 0xc1, 0x3c, 0xb7, 0xed, 0xa1);
//DEFINE_GUID(CTIID_IDirectMusicSegment2,                 0x224c56e7, 0xdee, 0x49c7, 0xa5, 0x4e, 0x95, 0xf9, 0xfe, 0x7b, 0xdb, 0xfc);

//dx8
//DEFINE_GUID(CTIID_IDirectMusic8,                        0xb0ee2a0c, 0x152a, 0x4729, 0x8b, 0xfb, 0x3d, 0xd4, 0x8a, 0xd2, 0x5d, 0x3a);
//DEFINE_GUID(CTIID_IDirectMusicBand8,                  0x8da34241, 0x365d, 0x4865, 0x83, 0x1a, 0x57, 0x2d, 0x33, 0x7, 0x6a, 0x56);
//DEFINE_GUID(CTIID_IDirectMusicVoice,                  0xc06836cc, 0xeefe, 0x42da, 0xa2, 0xaa, 0xc5, 0xfc, 0xcd, 0x90, 0x4e, 0xfd);
//PHOOPHOO
//DEFINE_GUID(CTIID_IDirectMusicParamHook,              0xd639af13, 0xede6, 0x4258, 0xb3, 0x13, 0xfb, 0x85, 0xf9, 0x98, 0x6f, 0xa6);
//DEFINE_GUID(CTIID_IDirectMusicPatternTrack,             0xb30e0e2b, 0x5347, 0x4d4a, 0x9c, 0xcb, 0xcd, 0x7e, 0xba, 0x28, 0x9c, 0x33);
//DEFINE_GUID(CTIID_IDirectSoundDownloadedWave,         0xb491d035, 0x559b, 0x42c9, 0xbf, 0xa2, 0x23, 0xca, 0xf6, 0xf1, 0xec, 0x7d);
//DEFINE_GUID(CTIID_IDirectSoundWave,                     0x0c3145e8, 0x9b0c, 0x447a, 0x8f, 0xda, 0x58, 0xff, 0x74, 0x6c, 0xca, 0xb7);

//DEFINE_GUID(CTIID_IDirectMusicTool8,                    0xaa534b4d, 0xf3b4, 0x4bf9, 0x9c, 0x50, 0x3e, 0x4c, 0x76, 0x79, 0x62, 0x36);
//DEFINE_GUID(CTIID_IDirectMusicStyle8,                   0x29af2285, 0x4eeb, 0x4227, 0x93, 0x6e, 0x26, 0xfc, 0x2f, 0x91, 0xc, 0x4d);
//DEFINE_GUID(CTIID_IDirectMusicComposer8,              0x31149e2a, 0xe60c, 0x4557, 0x9c, 0xe2, 0x1f, 0xb5, 0x83, 0xfa, 0x82, 0x4e);
//DEFINE_GUID(CTIID_IDirectMusicPort8,                  0x89ea06d2, 0x10d1, 0x4d7e, 0x8d, 0x80, 0x2, 0x4b, 0xf6, 0xc9, 0x45, 0x9a);
//DEFINE_GUID(CTIID_IDirectMusicSynth8,                   0xbfe8d92d, 0xc522, 0x4279, 0xb3, 0x48, 0xe8, 0x73, 0x2d, 0xb6, 0xab, 0xc3);
//DEFINE_GUID(CTIID_IDirectMusicTrack8,                   0x689dc439, 0xfdfd, 0x4691, 0xb1, 0xe9, 0xcb, 0xda, 0x73, 0xcd, 0x68, 0x6f);
//DEFINE_GUID(CTIID_IDirectMusicContainer,                0x727c098a, 0xf55e, 0x4450, 0xbd, 0xf5, 0xb5, 0x29, 0x14, 0xdf, 0x4a, 0xc2);
//DEFINE_GUID(CTIID_IDirectMusicSong,                     0xfcba94e2, 0xfe1f, 0x4dfa, 0x8a, 0xbc, 0x5b, 0xf, 0x98, 0xdb, 0x46, 0xf5);
//DEFINE_GUID(CTIID_IDirectMusicScriptError,              0xfb8c07db, 0x80f5, 0x4f32, 0xbd, 0xce, 0x80, 0xcc, 0x75, 0x35, 0xb9, 0x60);



// ======================================================================================
//
//   ALIASES FOR INTERFACES THAT HAVE NO DX8 EQUIVALENT
//
// ======================================================================================
#define CTIID_IDirectMusicLoader CTIID_IDirectMusicLoader8
#define CTIID_IDirectMusicSegment CTIID_IDirectMusicSegment8
#define CTIID_IDirectMusicSegmentState CTIID_IDirectMusicSegmentState8
#define CTIID_IDirectMusicPerformance CTIID_IDirectMusicPerformance8
#define CTIID_IDirectMusicObject CTIID_IDirectMusicObject8


// ======================================================================================
//    LOG STRUCTURE HELPERS
// ======================================================================================
void _stdcall dmthLogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC  Desc);
void _stdcall dmthLogDMUS_SCRIPT_ERRORINFO(UINT uLogLevel, DMUS_SCRIPT_ERRORINFO *pdmScriptErrorInfo);
void _stdcall dmthLogWAVEFORMATEX(UINT uLogLevel, LPWAVEFORMATEX lpwfx);
void _stdcall dmthLogFormatTag(UINT uLogLevel, WORD wFmt);
void _stdcall dmthLogRawGUID(UINT uLogLevel, REFGUID rguid);
//PHOOPHOO
//void _stdcall dmthLogDMUS_WAVEART(UINT uLogLevel, LPDMUS_WAVEART pArticulation);

// ======================================================================================//
//    LEGACY DEFINES
// ======================================================================================
#define dmthLogDMUS_OBJECTDESCS dmthLogDMUS_OBJECTDESCStruct


// ======================================================================================
//
//    DSOUND LOGGING FUNCTIONS!!!
//
// ======================================================================================
void _stdcall Log_DS3DAlgorithm (int, LPGUID);
void _stdcall Log_DSErr (TCHAR *, HRESULT, int);
void _stdcall Log_DSCooperativeLevel (int, DWORD);
void _stdcall Log_GUID (int, LPGUID);
void _stdcall Log_GUID (int, REFGUID);
void _stdcall Log_DSCaps (int, LPDSCAPS);
void _stdcall Log_SpeakerConfig (int, DWORD);
void _stdcall Log_WaveFormatEx(int, LPCWAVEFORMATEX);
void _stdcall Log_DSBufferDesc(int, LPCDSBUFFERDESC);
void _stdcall Log_DSBLockFlags(int, DWORD);
void _stdcall Log_DSCBLockFlags(int, DWORD);
void _stdcall Log_DSBPlayFlags(int, DWORD);
void _stdcall Log_DS3DLAllParameters(int, LPCDS3DLISTENER);
void _stdcall Log_DS3DApplyMode (int, DWORD);
void _stdcall Log_DS3DBMode (int, DWORD);
void _stdcall Log_D3DVector(int, const struct _D3DVECTOR *);
void _stdcall Log_DS3DBAllParameters(int, LPCDS3DBUFFER);
void _stdcall Log_DSBStatus (int, DWORD);
void _stdcall Log_DSCBStatus (int, DWORD);
void _stdcall Log_DSNPositionNotifies (int, DWORD, LPCDSBPOSITIONNOTIFY);
void _stdcall Log_DSBCapsFlags(int, DWORD);
void _stdcall Log_DSCBCapsFlags(int, DWORD);
void _stdcall Log_wFormatTag (int, WORD);
DWORD _stdcall GetRandomDWORD(DWORD dwModulus);
FLOAT _stdcall GetRandomD3DVALUE(FLOAT flLower, FLOAT flUpper, FLOAT flResolution);
//void _stdcall Log_DSCBStartFlags (int, DWORD);
//void _stdcall Log_DSCCaps (int, LPDSCCAPS);
//void _stdcall Log_DSCBufferDesc (int, LPCDSCBUFFERDESC);
//void _stdcall Log_DSBCaps (int, LPDSBCAPS);
//void _stdcall Log_DSCBCaps (int, LPDSCBCAPS);



// ======================================================================================
//
//    DSOUND8 LOGGING FUNCTIONS!!!
//
// ======================================================================================
/*TODO: Put these back in!!!
void _stdcall Log_Chorus_Params( int nLogLvl, LPCDSFXChorus lpDSFXC );
void _stdcall Log_Flanger_Params( int nLogLvl, LPCDSFXFlanger lpDSFXF );
//void _stdcall Log_Send_Params( int nLogLvl, LPCDSFXSend lpDSFXS );
void _stdcall Log_Echo_Params( int nLogLvl, LPCDSFXEcho lpDSFXE );
void _stdcall Log_Distortion_Params( int nLogLvl, LPCDSFXDistortion lpDSFXD );
void _stdcall Log_Compressor_Params( int nLogLvl, LPCDSFXCompressor lpDSFXCP );
void _stdcall Log_I3DL2Reverb_Params( int nLogLvl, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall Log_WavesReverb_Params( int nLogLvl, LPCDSFXWavesReverb lpDSFXWR );
void _stdcall Log_Gargle_Params( int nLogLvl, LPCDSFXGargle lpDSFXG );
void _stdcall Log_ParamEq_Params( int nLogLvl, LPCDSFXParamEq lpDSFXP );
void _stdcall String_Chorus_Params( char *szMessage, char* szPrompt, LPCDSFXChorus lpDSFXC );
void _stdcall String_Flanger_Params( char *szMessage, char* szPrompt, LPCDSFXFlanger lpDSFXF );
//void _stdcall String_Send_Params( char *szMessage, char* szPrompt, LPCDSFXSend lpDSFXS );
void _stdcall String_Echo_Params( char *szMessage, char* szPrompt, LPCDSFXEcho lpDSFXE );
void _stdcall String_Distortion_Params( char *szMessage, char* szPrompt, LPCDSFXDistortion lpDSFXD );
void _stdcall String_Compressor_Params( char *szMessage, char* szPrompt, LPCDSFXCompressor lpDSFXCP );
void _stdcall String_I3DL2Reverberation_Params( char *szMessage, char* szPrompt, LPCDSFXI3DL2Reverb lpDSFX3R );
void _stdcall String_Gargle_Params( char *szMessage, char* szPrompt, LPCDSFXGargle lpDSFXG );
void _stdcall String_ParamEq_Params( char *szMessage, char* szPrompt, LPCDSFXParamEq lpDSFXP );
char*_stdcall String_Source_Preset( DWORD dwPreset );
char*_stdcall String_Room_Preset( DWORD dwPreset );

//BOOL _stdcall Equal_Send_Params( LPCDSFXSend lpDSFXS1, LPCDSFXSend lpDSFXS2 );

BOOL _stdcall Equal_Chorus_Params( LPCDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
BOOL _stdcall Equal_Flanger_Params( LPCDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
BOOL _stdcall Equal_Echo_Params( LPCDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
BOOL _stdcall Equal_Distortion_Params( LPCDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
BOOL _stdcall Equal_Compressor_Params( LPCDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
BOOL _stdcall Equal_Gargle_Params( LPCDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
BOOL _stdcall Equal_I3DL2Reverb_Params( LPCDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
BOOL _stdcall Equal_ParamEq_Params( LPCDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
BOOL _stdcall Equal_WavesReverb_Params( LPCDSFXWavesReverb lpDSFX3W1, LPCDSFXWavesReverb lpDSFX3W2 );
*/


//Eventually move all the "equal" param-checkers to this method.
#define EXPECT_EQUALITY   0x2345
#define EXPECT_INEQUALITY 0x3456
HRESULT _stdcall Compare_DS3DBUFFER(int iLogLevel, DS3DBUFFER *p1, DS3DBUFFER *p2, DWORD dwExpected);
HRESULT _stdcall Compare_DS3DLISTENER(int iLogLevel, DS3DLISTENER *p1, DS3DLISTENER *p2, DWORD dwExpected);

/*

void _stdcall Copy_Chorus_Params( LPDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 );
void _stdcall Copy_Flanger_Params( LPDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 );
void _stdcall Copy_Echo_Params( LPDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 );
void _stdcall Copy_Distortion_Params( LPDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 );
void _stdcall Copy_Compressor_Params( LPDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 );
void _stdcall Copy_Gargle_Params( LPDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 );
void _stdcall Copy_I3DL2Reverb_Params( LPDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 );
void _stdcall Copy_ParamEq_Params( LPDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 );
void _stdcall GetRandomEchoParams( LPDSFXEcho lpDSFXE );
void _stdcall GetRandomChorusParams( LPDSFXChorus lpDSFXC );
void _stdcall GetRandomFlangerParams( LPDSFXFlanger lpDSFXF );
void _stdcall GetRandomDistortionParams( LPDSFXDistortion lpDSFXD );
void _stdcall GetRandomCompressorParams( LPDSFXCompressor lpDSFXCP );
void _stdcall GetRandomGargleParams( LPDSFXGargle lpDSFXG );
void _stdcall GetRandomI3DL2ReverbParams( LPDSFXI3DL2Reverb lpDSFX3R );
void _stdcall GetRandomParamEqParams( LPDSFXParamEq lpDSFXP );
*/

#define DSFX_WETDRYMIX_MIN              -100
#define DSFX_WETDRYMIX_MAX              100

#define DSFX_ECHO_LEFTDELAY_MIN         1
#define DSFX_ECHO_LEFTDELAY_MAX         2000
#define DSFX_ECHO_RIGHTDELAY_MIN        1
#define DSFX_ECHO_RIGHTDELAY_MAX        2000
#define DSFX_ECHO_FEEDBACK_MIN          0
#define DSFX_ECHO_FEEDBACK_MAX          10000
#define DSFX_ECHO_PANSWAP_MIN           0
#define DSFX_ECHO_PANSWAP_MAX           1

#define DSFX_CHORUS_DEPTH_MIN           0
#define DSFX_CHORUS_DEPTH_MAX           10000
#define DSFX_CHORUS_FEEDBACK_MIN        -100
#define DSFX_CHORUS_FEEDBACK_MAX        100
#define DSFX_CHORUS_FREQUENCY_MIN       0
#define DSFX_CHORUS_FREQUENCY_MAX       20
#define DSFX_CHORUS_WAVEFORM_MIN        0
#define DSFX_CHORUS_WAVEFORM_MAX        1
#define DSFX_CHORUS_DELAY_MIN           0
#define DSFX_CHORUS_DELAY_MAX           20
#define DSFX_CHORUS_PHASE_MIN           -180
#define DSFX_CHORUS_PHASE_MAX           180

#define DSFX_FLANGER_DEPTH_MIN           0
#define DSFX_FLANGER_DEPTH_MAX           10000
#define DSFX_FLANGER_FEEDBACK_MIN        -100
#define DSFX_FLANGER_FEEDBACK_MAX        100
#define DSFX_FLANGER_FREQUENCY_MIN       0
#define DSFX_FLANGER_FREQUENCY_MAX       20
#define DSFX_FLANGER_WAVEFORM_MIN        0
#define DSFX_FLANGER_WAVEFORM_MAX        1
#define DSFX_FLANGER_DELAY_MIN           0
#define DSFX_FLANGER_DELAY_MAX           20
#define DSFX_FLANGER_PHASE_MIN           -180
#define DSFX_FLANGER_PHASE_MAX           180

#define DSFX_COMPRESSOR_RATIO_MIN           1
#define DSFX_COMPRESSOR_RATIO_MAX           100
#define DSFX_COMPRESSOR_GAIN_MIN            -20
#define DSFX_COMPRESSOR_GAIN_MAX            20
#define DSFX_COMPRESSOR_ATTACK_MIN          0
#define DSFX_COMPRESSOR_ATTACK_MAX          500
#define DSFX_COMPRESSOR_RELEASE_MIN         50
#define DSFX_COMPRESSOR_RELEASE_MAX         3000
#define DSFX_COMPRESSOR_THRESHOLD_MIN       -60
#define DSFX_COMPRESSOR_THRESHOLD_MAX       0
#define DSFX_COMPRESSOR_PREDELAY_MIN        0
#define DSFX_COMPRESSOR_PREDELAY_MAX        500
#define DSFX_COMPRESSOR_COMPGAINMETER_MAX   1000
#define DSFX_COMPRESSOR_COMPGAINMETER_MIN   100
#define DSFX_COMPRESSOR_COMPINPUTMETER_MAX  1000
#define DSFX_COMPRESSOR_COMPINPUTMETER_MIN  100
#define DSFX_COMPRESSOR_COMPMETERRESET_MAX  1000
#define DSFX_COMPRESSOR_COMPMETERRESET_MIN  100

#define DSFX_DISTORTION_GAIN_MIN                        -60
#define DSFX_DISTORTION_GAIN_MAX                        0
#define DSFX_DISTORTION_EDGE_MIN                        0
#define DSFX_DISTORTION_EDGE_MAX                        100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MIN       100
#define DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MAX       8000
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MIN             100
#define DSFX_DISTORTION_POSTEQBANDWIDTH_MAX             8000
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MIN            100
#define DSFX_DISTORTION_PRELOWPASSCUTOFF_MAX            8000

#define DSFX_GARGLE_RATEHZ_MIN                          1
#define DSFX_GARGLE_RATEHZ_MAX                          1000
#define DSFX_GARGLE_WAVESHAPE_MIN                       0
#define DSFX_GARGLE_WAVESHAPE_MAX                       1

#define DSFX_PARAMEQ_CENTER_MIN                         10.0f
#define DSFX_PARAMEQ_CENTER_MAX                         10000.0f
#define DSFX_PARAMEQ_BANDWIDTH_MIN                      10.0f
#define DSFX_PARAMEQ_BANDWIDTH_MAX                      10000.0f
#define DSFX_PARAMEQ_GAIN_MIN                           0.1f
#define DSFX_PARAMEQ_GAIN_MAX                           100.0f



void tstLof(int, TCHAR *, double);
LRESULT _cdecl DummyLog (DWORD, LPSTR, ...);
bool IsEqual(float f1, float f2);


#define SAFE_RELEASE( px )  if( px )                            \
                            {                                   \
                            px->Release();                      \
                            px = NULL;                          \
                            }

#define D3DVAL(val) ((float)(val))




DEFINE_GUID(GUID_NULL,                     0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x0, 0x00, 0x0, 0x00, 0x00, 0x00);


#define fnsLog Log
/*
//So the test logging will still work.  Grrr.
HRESULT fnsLog
(
    DWORD                   dwLevel,
    DWORD                   dwDestinationFlags, 
    LPSTR                   szFormat,
    ...
);

HRESULT Log
(
    DWORD                   dwLevel,
    LPSTR                   szFormat,
    ...
);

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\dmthhelp.H ===
//===========================================================================
// dmthhelp.h
//
// DirectMusic test harness helper functions
//
// History:
//  03/24/1998 - davidkl - created
//===========================================================================

#pragma once
//---------------------------------------------------------------------------

LPSTR dmthXlatHRESULT(HRESULT hRes);
LPSTR dmthXlatGUID(REFGUID rguid);
LPSTR dmthXlatDMUS_APATH(DWORD dwStandardPath);
LPSTR dmthXlatDMUS_STAGE(DWORD dwStage);
void dmthGUIDtoString(REFGUID rguid, LPSTR szBuf);
LPWSTR dmth_lstrcpyW(LPWSTR pwszDest, LPCWSTR pcwszSrc);
LPSTR Log_DMUS_SEGF(DWORD dwFlags);

// allow the old names to continue to work...
LPSTR tdmXlatHRESULT(HRESULT hRes);
LPSTR tdmXlatGUID(REFGUID rguid);
LPSTR tdmXlatDMUS_APATH(DWORD dwStandardPath);
void tdmGUIDtoString(REFGUID rguid, LPSTR szBuf);


//One COM helper function.
HRESULT dmthDirectMusicCreateInstance(REFCLSID rclsid, 
                            LPUNKNOWN pUnkOuter,
                            REFIID riid,
                            LPVOID *ppv);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\memptr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       memptr.h
//
//--------------------------------------------------------------------------

//===========================================================================
// memptr.h
//
// History:
//  09/12/1997 - davidkl - created
//===========================================================================

#pragma once


#ifdef __cplusplus
extern "C"
{
#endif

//---------------------------------------------------------------------------

// BUGBUG - what is the "int 3" for alphas?
#define MEMJUNK                         0xCC

// Prototypes
HRESULT _stdcall helpMalloc(void **ppv, UINT uSize);
HRESULT _stdcall helpFree(void *pv);
BOOL _stdcall helpIsValidPtr(LPVOID ptr, UINT cb, BOOL fAllowNull);
BOOL _stdcall helpIsValidReadPtr(LPVOID ptr, UINT cb, BOOL fAllowNull);
BOOL _stdcall helpIsValidWritePtr(LPVOID ptr, UINT cb, BOOL fAllowNull);
LPVOID _stdcall helpGetBogusPointer(void);
void _stdcall helpFreeBogusPointer(LPVOID lpv);

//---------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\dmthhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmthhelp.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// dmthhelp.cpp
//
// Helper functions provided by DMTH
//
// Functions:
//  dmthXlatHRESULT()
//  dmthXlatGUID()
//  dmthGUIDtoString()
//
// History:
//  04/03/1998 - davidkl - created
//  10/31/1998 - jimmo   - see //JIMMO section below.
//  05/13/1999 - jimmo   - Added CLSID_DirectMusicAuditionTrack to the glGuids[] array.
//  05/25/1999 - kcraven   - Removed CLSID_DirectMusicAuditionTrack to the glGuids[] array.
//  01/25/2000 - kcraven   - start moving dmthCreate helper functions to a common file
//  02/10/2000 - danhaff   - added dsound.h GUIDs and IIDs.
//  03/28/2000 - danhaff   - added dsound.h HRESULTS
//  02/07/2000 - danhaff   - Ported to XBox, removed unused stuff.
//
//===========================================================================

#include "globals.h"

//---------------------------------------------------------------------------

// HRESULT error list (used by dmthXlatHRESULT)
typedef struct
{
    HRESULT rval;
    LPSTR   sz;
} ERRLIST;

static ERRLIST elErrors[] =
{
    { S_OK,                                   "S_OK" },
    { S_FALSE,                                "S_FALSE" },
    { E_FAIL,                                 "E_FAIL" },
    { E_ACCESSDENIED,                         "E_ACCESSDENIED" },
    { E_HANDLE,                               "E_HANDLE" },
    { E_POINTER,                              "E_POINTER" },
    { E_NOTIMPL,                              "E_NOTIMPL" },
    { E_INVALIDARG,                           "E_INVALIDARG" },
    { E_NOINTERFACE,                          "E_NOINTERFACE" },
    { OLE_E_BLANK,                            "OLE_E_BLANK" },
    { CLASS_E_CLASSNOTAVAILABLE,              "CLASS_E_CLASSNOTAVAILABLE" },
    { REGDB_E_CLASSNOTREG,                    "REGDB_E_CLASSNOTREG" },

//    { DMUS_S_PARTIALLOAD,                     "DMUS_S_PARTIALLOAD" },
//    { DMUS_S_PARTIALDOWNLOAD,                 "DMUS_S_PARTIALDOWNLOAD" },

    { DMUS_S_REQUEUE,                         "DMUS_S_REQUEUE" },
    { DMUS_S_FREE,                            "DMUS_S_FREE" },
    { DMUS_S_END,                             "DMUS_S_END" },

//    { DMUS_S_STRING_TRUNCATED,                "DMUS_S_STRING_TRUNCATED" },
    { DMUS_S_LAST_TOOL,                       "DMUS_S_LAST_TOOL" },
    { DMUS_S_OVER_CHORD,                      "DMUS_S_OVER_CHORD" },
    { DMUS_S_UP_OCTAVE,                       "DMUS_S_UP_OCTAVE" },
    { DMUS_S_DOWN_OCTAVE,                     "DMUS_S_DOWN_OCTAVE" },
//    { DMUS_S_NOBUFFERCONTROL,                 "DMUS_S_NOBUFFERCONTROL" },
    { DMUS_S_GARBAGE_COLLECTED,               "DMUS_S_GARBAGE_COLLECTED" },

//    { DMUS_E_DRIVER_FAILED,                   "DMUS_E_DRIVER_FAILED" },
//    { DMUS_E_PORTS_OPEN,                      "DMUS_E_PORTS_OPEN" },
//    { DMUS_E_DEVICE_IN_USE,                   "DMUS_E_DEVICE_IN_USE" },
//    { DMUS_E_INSUFFICIENTBUFFER,              "DMUS_E_INSUFFICIENTBUFFER" },
//    { DMUS_E_BUFFERNOTSET,                    "DMUS_E_BUFFERNOTSET" },
//    { DMUS_E_BUFFERNOTAVAILABLE,              "DMUS_E_BUFFERNOTAVAILABLE" },

//    { DMUS_E_NOTADLSCOL,                      "DMUS_E_NOTADLSCOL" },
//    { DMUS_E_INVALIDOFFSET,                   "DMUS_E_INVALIDOFFSET" },

//    { DMUS_E_ALREADY_LOADED,                  "DMUS_E_ALREADY_LOADED" },

//    { DMUS_E_INVALIDPOS,                      "DMUS_E_INVALIDPOS" },
//    { DMUS_E_INVALIDPATCH,                    "DMUS_E_INVALIDPATCH" },
//    { DMUS_E_CANNOTSEEK,                      "DMUS_E_CANNOTSEEK" },
//    { DMUS_E_CANNOTWRITE,                     "DMUS_E_CANNOTWRITE" },
//    { DMUS_E_CHUNKNOTFOUND,                   "DMUS_E_CHUNKNOTFOUND" },
//    { DMUS_E_INVALID_DOWNLOADID,              "DMUS_E_INVALID_DOWNLOADID" },
//    { DMUS_E_NOT_DOWNLOADED_TO_PORT,          "DMUS_E_NOT_DOWNLOADED_TO_PORT" },
//    { DMUS_E_ALREADY_DOWNLOADED,              "DMUS_E_ALREADY_DOWNLOADED" },
//    { DMUS_E_UNKNOWN_PROPERTY,                "DMUS_E_UNKNOWN_PROPERTY" },
    { DMUS_E_SET_UNSUPPORTED,                 "DMUS_E_SET_UNSUPPORTED" },
    { DMUS_E_GET_UNSUPPORTED,                 "DMUS_E_GET_UNSUPPORTED" },
//    { DMUS_E_NOTMONO,                         "DMUS_E_NOTMONO" },
//    { DMUS_E_BADARTICULATION,                 "DMUS_E_BADARTICULATION" },
//    { DMUS_E_BADINSTRUMENT,                   "DMUS_E_BADINSTRUMENT" },
//    { DMUS_E_BADWAVELINK,                     "DMUS_E_BADWAVELINK" },
//    { DMUS_E_NOARTICULATION,                  "DMUS_E_NOARTICULATION" },
//    { DMUS_E_NOTPCM,                          "DMUS_E_NOTPCM" },
//    { DMUS_E_BADWAVE,                         "DMUS_E_BADWAVE" },
//    { DMUS_E_BADOFFSETTABLE,                  "DMUS_E_BADOFFSETTABLE" },
//    { DMUS_E_UNKNOWNDOWNLOAD,                 "DMUS_E_UNKNOWNDOWNLOAD" },
//    { DMUS_E_NOSYNTHSINK,                     "DMUS_E_NOSYNTHSINK" },
//    { DMUS_E_ALREADYOPEN,                     "DMUS_E_ALREADYOPEN" },
//    { DMUS_E_ALREADYCLOSED,                   "DMUS_E_ALREADYCLOSED" },
//    { DMUS_E_SYNTHNOTCONFIGURED,              "DMUS_E_SYNTHNOTCONFIGURED" },
//    { DMUS_E_SYNTHACTIVE,                     "DMUS_E_SYNTHACTIVE" },
//    { DMUS_E_CANNOTREAD,                      "DMUS_E_CANNOTREAD" },
//    { DMUS_E_DMUSIC_RELEASED,                 "DMUS_E_DMUSIC_RELEASED" },
//    { DMUS_E_BUFFER_EMPTY,                    "DMUS_E_BUFFER_EMPTY" },
//    { DMUS_E_BUFFER_FULL,                     "DMUS_E_BUFFER_FULL" },
//    { DMUS_E_PORT_NOT_CAPTURE,                "DMUS_E_PORT_NOT_CAPTURE" },
//    { DMUS_E_PORT_NOT_RENDER,                 "DMUS_E_PORT_NOT_RENDER" },
//    { DMUS_E_DSOUND_NOT_SET,                  "DMUS_E_DSOUND_NOT_SET" },
//    { DMUS_E_ALREADY_ACTIVATED,               "DMUS_E_ALREADY_ACTIVATED" },
//    { DMUS_E_INVALIDBUFFER,                   "DMUS_E_INVALIDBUFFER" },
//    { DMUS_E_WAVEFORMATNOTSUPPORTED,          "DMUS_E_WAVEFORMATNOTSUPPORTED" },
//    { DMUS_E_SYNTHINACTIVE,                   "DMUS_E_SYNTHINACTIVE" },
//    { DMUS_E_DSOUND_ALREADY_SET,              "DMUS_E_DSOUND_ALREADY_SET" },
//    { DMUS_E_INVALID_EVENT,                   "DMUS_E_INVALID_EVENT" },

//    { DMUS_E_UNSUPPORTED_STREAM,              "DMUS_E_UNSUPPORTED_STREAM" },
//    { DMUS_E_ALREADY_INITED,                  "DMUS_E_ALREADY_INITED" },
//    { DMUS_E_INVALID_BAND,                    "DMUS_E_INVALID_BAND" },

//    { DMUS_E_TRACK_HDR_NOT_FIRST_CK,          "DMUS_E_TRACK_HDR_NOT_FIRST_CK" },
//    { DMUS_E_TOOL_HDR_NOT_FIRST_CK,           "DMUS_E_TOOL_HDR_NOT_FIRST_CK" },
//    { DMUS_E_INVALID_TRACK_HDR,               "DMUS_E_INVALID_TRACK_HDR" },
//    { DMUS_E_INVALID_TOOL_HDR,                "DMUS_E_INVALID_TOOL_HDR" },
//    { DMUS_E_ALL_TOOLS_FAILED,                "DMUS_E_ALL_TOOLS_FAILED" },
//    { DMUS_E_ALL_TRACKS_FAILED,               "DMUS_E_ALL_TRACKS_FAILED" },
    { DMUS_E_NOT_FOUND,                       "DMUS_E_NOT_FOUND" },
    { DMUS_E_NOT_INIT,                        "DMUS_E_NOT_INIT" },
//    { DMUS_E_TYPE_DISABLED,                   "DMUS_E_TYPE_DISABLED" },
//    { DMUS_E_TYPE_UNSUPPORTED,                "DMUS_E_TYPE_UNSUPPORTED" },
    { DMUS_E_TIME_PAST,                       "DMUS_E_TIME_PAST" },
//    { DMUS_E_TRACK_NOT_FOUND,                 "DMUS_E_TRACK_NOT_FOUND" },
//    { DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT,      "DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT" },

//    { DMUS_E_NO_MASTER_CLOCK,                 "DMUS_E_NO_MASTER_CLOCK" },

//    { DMUS_E_LOADER_NOCLASSID,                "DMUS_E_LOADER_NOCLASSID" },
//    { DMUS_E_LOADER_BADPATH,                  "DMUS_E_LOADER_BADPATH" },
//    { DMUS_E_LOADER_FAILEDOPEN,               "DMUS_E_LOADER_FAILEDOPEN" },
//    { DMUS_E_LOADER_FORMATNOTSUPPORTED,       "DMUS_E_LOADER_FORMATNOTSUPPORTED" },
    { DMUS_E_LOADER_FAILEDCREATE,             "DMUS_E_LOADER_FAILEDCREATE" },
    { DMUS_E_LOADER_OBJECTNOTFOUND,           "DMUS_E_LOADER_OBJECTNOTFOUND" },
//    { DMUS_E_LOADER_NOFILENAME,               "DMUS_E_LOADER_NOFILENAME" },

    { DMUS_E_INVALIDFILE,                     "DMUS_E_INVALIDFILE" },
//    { DMUS_E_ALREADY_EXISTS,                  "DMUS_E_ALREADY_EXISTS" },
//    { DMUS_E_OUT_OF_RANGE,                    "DMUS_E_OUT_OF_RANGE" },
//    { DMUS_E_SEGMENT_INIT_FAILED,             "DMUS_E_SEGMENT_INIT_FAILED" },
//    { DMUS_E_ALREADY_SENT,                    "DMUS_E_ALREADY_SENT" },
//    { DMUS_E_CANNOT_FREE,                     "DMUS_E_CANNOT_FREE" },
//    { DMUS_E_CANNOT_OPEN_PORT,                "DMUS_E_CANNOT_OPEN_PORT" },
    { DMUS_E_CANNOT_CONVERT,                  "DMUS_E_CANNOT_CONVERT" },
//    { DMUS_E_DESCEND_CHUNK_FAIL,              "DMUS_E_DESCEND_CHUNK_FAIL" },
//    { DMUS_E_NOT_LOADED,                      "DMUS_E_NOT_LOADED" },
//    { DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE,    "DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE" },
//    { DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE,      "DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE" },
    { DMUS_E_SCRIPT_ERROR_IN_SCRIPT,          "DMUS_E_SCRIPT_ERROR_IN_SCRIPT" },
    { DMUS_E_SCRIPT_VARIABLE_NOT_FOUND,       "DMUS_E_SCRIPT_VARIABLE_NOT_FOUND"},
    { DMUS_E_SCRIPT_ROUTINE_NOT_FOUND,        "DMUS_E_SCRIPT_ROUTINE_NOT_FOUND"},
    { DMUS_E_SCRIPT_CONTENT_READONLY,         "DMUS_E_SCRIPT_CONTENT_READONLY"},
    { DMUS_E_SCRIPT_NOT_A_REFERENCE,          "DMUS_E_SCRIPT_NOT_A_REFERENCE"},
    { DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED,      "DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED"},
    { DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR,       "DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR"},
    { DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR,      "DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR"},
    { DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE,  "DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE"},
//    { DMUS_E_SCRIPT_CANTLOAD_OLEAUT32,        "DMUS_E_SCRIPT_CANTLOAD_OLEAUT32" },
//    { DMUS_E_SCRIPT_LOADSCRIPT_ERROR,         "DMUS_E_SCRIPT_LOADSCRIPT_ERROR" },
//    { DMUS_E_SCRIPT_INVALID_FILE,             "DMUS_E_SCRIPT_INVALID_FILE" },
//    { DMUS_E_INVALID_SCRIPTTRACK,             "DMUS_E_INVALID_SCRIPTTRACK" },
//    { DMUS_E_INVALID_SEGMENTTRIGGERTRACK,     "DMUS_E_INVALID_SEGMENTTRIGGERTRACK" },
//    { DMUS_E_INVALID_LYRICSTRACK,             "DMUS_E_INVALID_LYRICSTRACK" },
//    { DMUS_E_INVALID_PARAMCONTROLTRACK,       "DMUS_E_INVALID_PARAMCONTROLTRACK" },
    { DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR,       "DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR" },
    { DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR,      "DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR" },
    { DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE,  "DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE" },
//    { DMUS_E_AUDIOPATHS_NOT_VALID,            "DMUS_E_AUDIOPATHS_NOT_VALID" },
//    { DMUS_E_AUDIOPATHS_IN_USE,               "DMUS_E_AUDIOPATHS_IN_USE" },
    { DMUS_E_NO_AUDIOPATH_CONFIG,             "DMUS_E_NO_AUDIOPATH_CONFIG" },
//    { DMUS_E_AUDIOPATH_INACTIVE,              "DMUS_E_AUDIOPATH_INACTIVE"},
//    { DMUS_E_AUDIOPATH_NOPORT,                "DMUS_E_AUDIOPATH_NOPORT"},
//    { DMUS_E_NO_AUDIOPATH,                    "DMUS_E_NO_AUDIOPATH" },
//    { DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER,      "DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER"},
//    { DMUS_E_INVALIDCHUNK,                    "DMUS_E_INVALIDCHUNK"},
//    { DMUS_E_INVALID_CONTAINER_OBJECT,        "DMUS_E_INVALID_CONTAINER_OBJECT"},         
    { DS_OK,                                  "DS_OK"},
//    { DS_NO_VIRTUALIZATION ,                  "DS_NO_VIRTUALIZATION"},
//    { DS_INCOMPLETE ,                         "DS_INCOMPLETE"},
//    { DSERR_ACCESSDENIED ,                    "DSERR_ACCESSDENIED"},
//    { DSERR_ALLOCATED ,                       "DSERR_ALLOCATED"},
//    { DSERR_ALREADYINITIALIZED ,              "DSERR_ALREADYINITIALIZED"},
//    { DSERR_BADFORMAT ,                       "DSERR_BADFORMAT"},
//    { DSERR_BADSENDBUFFERGUID,                "DSERR_BADSENDBUFFERGUID"},
//    { DSERR_BUFFERLOST ,                      "DSERR_BUFFERLOST"},
    { DSERR_CONTROLUNAVAIL ,                  "DSERR_CONTROLUNAVAIL"},
//    { DSERR_DS8_REQUIRED,                     "DSERR_DS8_REQUIRED"},
    { DSERR_GENERIC ,                         "DSERR_GENERIC"},
//    { DSERR_HWUNAVAIL ,                       "DSERR_HWUNAVAIL"},
    { DSERR_INVALIDCALL ,                     "DSERR_INVALIDCALL"},
//    { DSERR_INVALIDPARAM ,                    "DSERR_INVALIDPARAM"},
    { DSERR_NOAGGREGATION ,                   "DSERR_NOAGGREGATION"},
    { DSERR_NODRIVER ,                        "DSERR_NODRIVER"},
//    { DSERR_NOINTERFACE ,                     "DSERR_NOINTERFACE"},
//    { DSERR_OTHERAPPHASPRIO ,                 "DSERR_OTHERAPPHASPRIO"},
    { DSERR_OUTOFMEMORY ,                     "DSERR_OUTOFMEMORY"},
//  { DSERR_PROPS_DISABLED ,                  "DSERR_PROPS_DISABLED"},
//    { DSERR_PRIOLEVELNEEDED ,                 "DSERR_PRIOLEVELNEEDED"},
//    { DSERR_UNINITIALIZED ,                   "DSERR_UNINITIALIZED"},
    { DSERR_UNSUPPORTED ,                     "DSERR_UNSUPPORTED"}

};


// GUID / IID / CLSID list (used by dmthXlatGUID)
typedef struct
{
    GUID *pguid;
    LPSTR   sz;
} GUIDLIST;

static GUIDLIST glGuids[]=
{
    //** class IDs
    // dmusics.h
//    { (GUID*)&CLSID_DirectMusicSynthSink,             "CLSID_DirectMusicSynthSink" },

    // dmusici.h
/*
    { (GUID*)&CLSID_DirectMusicPerformance,           "CLSID_DirectMusicPerformance" },
    { (GUID*)&CLSID_DirectMusicSegment,               "CLSID_DirectMusicSegment" },
    { (GUID*)&CLSID_DirectMusicSegmentState,          "CLSID_DirectMusicSegmentState" },
    { (GUID*)&CLSID_DirectMusicGraph,                 "CLSID_DirectMusicGraph" },
    { (GUID*)&CLSID_DirectMusicTempoTrack,            "CLSID_DirectMusicTempoTrack" },
    { (GUID*)&CLSID_DirectMusicSeqTrack,              "CLSID_DirectMusicSeqTrack" },
    { (GUID*)&CLSID_DirectMusicSysExTrack,            "CLSID_DirectMusicSysExTrack" },
    { (GUID*)&CLSID_DirectMusicTimeSigTrack,          "CLSID_DirectMusicTimeSigTrack" },
    { (GUID*)&CLSID_DirectMusicStyle,                 "CLSID_DirectMusicStyle" },
    { (GUID*)&CLSID_DirectMusicChordTrack,            "CLSID_DirectMusicChordTrack" },
   { (GUID*)&CLSID_DirectMusicCommandTrack,          "CLSID_DirectMusicCommandTrack" },
    { (GUID*)&CLSID_DirectMusicStyleTrack,            "CLSID_DirectMusicStyleTrack" },
    { (GUID*)&CLSID_DirectMusicMotifTrack,            "CLSID_DirectMusicMotifTrack" },
    { (GUID*)&CLSID_DirectMusicChordMap,              "CLSID_DirectMusicChordMap" },
    { (GUID*)&CLSID_DirectMusicComposer,              "CLSID_DirectMusicComposer" },
    { (GUID*)&CLSID_DirectMusicSignPostTrack,         "CLSID_DirectMusicSignPostTrack" },
    { (GUID*)&CLSID_DirectMusicLoader,                "CLSID_DirectMusicLoader" },
    { (GUID*)&CLSID_DirectMusicBandTrack,             "CLSID_DirectMusicBandTrack" },
    { (GUID*)&CLSID_DirectMusicBand,                  "CLSID_DirectMusicBand" },
    { (GUID*)&CLSID_DirectMusicChordMapTrack,         "CLSID_DirectMusicChordMapTrack" },
    { (GUID*)&CLSID_DirectMusicMuteTrack,             "CLSID_DirectMusicMuteTrack" },

    { (GUID*)&CLSID_DirectMusicPatternTrack,          "CLSID_DirectMusicPatternTrack" },
    { (GUID*)&CLSID_DirectMusicScript,                "CLSID_DirectMusicScript" },
    { (GUID*)&CLSID_DirectMusicScriptTrack,           "CLSID_DirectMusicScriptTrack" },
    { (GUID*)&CLSID_DirectMusicContainer,             "CLSID_DirectMusicContainer" },
    { (GUID*)&CLSID_DirectMusicMarkerTrack,           "CLSID_DirectMusicMarkerTrack" },
    { (GUID*)&CLSID_DirectSoundWave,                  "CLSID_DirectSoundWave" },
    { (GUID*)&CLSID_DirectMusicSegmentTriggerTrack,   "CLSID_DirectMusicSegmentTriggerTrack" },
    { (GUID*)&CLSID_DirectMusicLyricsTrack,           "CLSID_DirectMusicLyricsTrack" },
    { (GUID*)&CLSID_DirectMusicParamControlTrack,     "CLSID_DirectMusicParamControlTrack" },
    { (GUID*)&CLSID_DirectMusicSong,                  "CLSID_DirectMusicSong" },
    { (GUID*)&CLSID_DirectMusicMelodyFormulationTrack,"CLSID_DirectMusicMelodyFormulationTrack" },
    { (GUID*)&CLSID_DirectMusicWaveTrack,             "CLSID_DirectMusicWaveTrack" },
    { (GUID*)&CLSID_DirectMusicAudioPathConfig,       "CLSID_DirectMusicAudioPathConfig" },

    //** GUIDs
    // dmusics.h
    { (GUID*)&GUID_DMUS_PROP_SetSynthSink,            "GUID_DMUS_PROP_SetSynthSink" },
    { (GUID*)&GUID_DMUS_PROP_SinkUsesDSound,          "GUID_DMUS_PROP_SinkUsesDSound" },
*/


    // dmusici.h
    { (GUID*)&GUID_DirectMusicAllTypes,               "GUID_DirectMusicAllTypes" },
    { (GUID*)&GUID_NOTIFICATION_SEGMENT,              "GUID_NOTIFICATION_SEGMENT" },
    { (GUID*)&GUID_NOTIFICATION_MEASUREANDBEAT,       "GUID_NOTIFICATION_MEASUREANDBEAT" },
    { (GUID*)&GUID_NOTIFICATION_CHORD,                "GUID_NOTIFICATION_CHORD" },
    { (GUID*)&GUID_NOTIFICATION_COMMAND,              "GUID_NOTIFICATION_COMMAND" },
    { (GUID*)&GUID_NOTIFICATION_RECOMPOSE,            "GUID_NOTIFICATION_RECOMPOSE" },
//    { (GUID*)&GUID_CommandParam,                      "GUID_CommandParam" },
    { (GUID*)&GUID_CommandParam2,                     "GUID_CommandParam2" },
    { (GUID*)&GUID_CommandParamNext,                  "GUID_CommandParamNext" },
    { (GUID*)&GUID_ChordParam,                        "GUID_ChordParam" },
    { (GUID*)&GUID_RhythmParam,                       "GUID_RhythmParam" },
    { (GUID*)&GUID_IDirectMusicStyle,                 "GUID_IDirectMusicStyle" },
    { (GUID*)&GUID_TimeSignature,                     "GUID_TimeSignature" },
//    { (GUID*)&GUID_CueTimeSignature,                  "GUID_CueTimeSignature" }, // removed from dx8
    { (GUID*)&GUID_TempoParam,                        "GUID_TempoParam" },
    { (GUID*)&GUID_Valid_Start_Time,                  "GUID_Valid_Start_Time" },
    { (GUID*)&GUID_Play_Marker,                       "GUID_Play_Marker" },
//    { (GUID*)&GUID_BandParam,                         "GUID_BandParam" },
//    { (GUID*)&GUID_IDirectMusicBand,                  "GUID_IDirectMusicBand" },
//    { (GUID*)&GUID_IDirectMusicChordMap,              "GUID_IDirectMusicChordMap" },
    { (GUID*)&GUID_MuteParam,                         "GUID_MuteParam" },
//    { (GUID*)&GUID_Download,                          "GUID_Download" },
//    { (GUID*)&GUID_Unload,                            "GUID_Unload" },
//    { (GUID*)&GUID_ConnectToDLSCollection,            "GUID_ConnectToDLSCollection" },
//    { (GUID*)&GUID_Enable_Auto_Download,              "GUID_Enable_Auto_Download" },
//    { (GUID*)&GUID_Disable_Auto_Download,             "GUID_Disable_Auto_Download" },
//    { (GUID*)&GUID_Clear_All_Bands,                   "GUID_Clear_All_Bands" },
//    { (GUID*)&GUID_StandardMIDIFile,                  "GUID_StandardMIDIFile" },

//    { (GUID*)&GUID_DisableTimeSig,                    "GUID_DisableTimeSig" },
//    { (GUID*)&GUID_EnableTimeSig,                     "GUID_EnableTimeSig" },
//    { (GUID*)&GUID_DisableTempo,                      "GUID_DisableTempo" },
//    { (GUID*)&GUID_EnableTempo,                       "GUID_EnableTempo" },
//    { (GUID*)&GUID_SeedVariations,                    "GUID_SeedVariations" },
//    { (GUID*)&GUID_MelodyFragment,                    "GUID_MelodyFragment" },
//    { (GUID*)&GUID_MelodyPlaymode,                    "GUID_MelodyPlaymode" },
//    { (GUID*)&GUID_Clear_All_MelodyFragments,         "GUID_Clear_All_MelodyFragments" },
//    { (GUID*)&GUID_Variations,                        "GUID_Variations" },
//    { (GUID*)&GUID_DownloadToAudioPath,               "GUID_DownloadToAudioPath" },
////    { (GUID*)&GUID_UnloadFromAudioPath,               "GUID_UnloadFromAudioPath" },
    { (GUID*)&GUID_PerfMasterTempo,                   "GUID_PerfMasterTempo" },
    { (GUID*)&GUID_PerfMasterVolume,                  "GUID_PerfMasterVolume" },
    { (GUID*)&GUID_PerfMasterGrooveLevel,             "GUID_PerfMasterGrooveLevel" },
//    { (GUID*)&GUID_PerfAutoDownload,                  "GUID_PerfAutoDownload" },
    { (GUID*)&GUID_DefaultGMCollection,               "GUID_DefaultGMCollection" },
    // dsound.h
//    { (GUID*)&GUID_DSFX_SEND,                         "GUID_DSFX_SEND" },
//    { (GUID*)&GUID_DSFX_STANDARD_CHORUS,              "GUID_DSFX_STANDARD_CHORUS" },
//    { (GUID*)&GUID_DSFX_STANDARD_FLANGER,             "GUID_DSFX_STANDARD_FLANGER" },
//    { (GUID*)&GUID_DSFX_STANDARD_GARGLE,              "GUID_DSFX_STANDARD_GARGLE" },
//    { (GUID*)&GUID_DSFX_STANDARD_ECHO,                "GUID_DSFX_STANDARD_ECHO" },
//    { (GUID*)&GUID_DSFX_STANDARD_DISTORTION,          "GUID_DSFX_STANDARD_DISTORTION" },
//    { (GUID*)&GUID_DSFX_STANDARD_COMPRESSOR,          "GUID_DSFX_STANDARD_COMPRESSOR" },
//    { (GUID*)&GUID_DSFX_STANDARD_I3DL2REVERB,         "GUID_DSFX_STANDARD_I3DL2REVERB" },
//    { (GUID*)&GUID_DSFX_STANDARD_PARAMEQ,             "GUID_DSFX_STANDARD_PARAMEQ"},
//    { (GUID*)&GUID_DSFX_WAVES_REVERB,                 "GUID_DSFX_WAVES_REVERB"},

    

    //** interface IDs
    // dmusics.h
/*
    { (GUID*)&IID_IDirectMusicSynth,                  "IID_IDirectMusicSynth" },
    { (GUID*)&IID_IDirectMusicSynth8,                 "IID_IDirectMusicSynth8" },
    { (GUID*)&IID_IDirectMusicSynthSink,              "IID_IDirectMusicSynthSink" },

*/

    // dmusici.h
    { (GUID*)&IID_IDirectMusicLoader,                 "IID_IDirectMusicLoader" },
//    { (GUID*)&IID_IDirectMusicGetLoader,              "IID_IDirectMusicLoader" },
//    { (GUID*)&IID_IDirectMusicObject,                 "IID_IDirectMusicObject" },
    { (GUID*)&IID_IDirectMusicSegment,                "IID_IDirectMusicSegment" },
    { (GUID*)&IID_IDirectMusicSegmentState,           "IID_IDirectMusicSegmentState" },
//    { (GUID*)&IID_IDirectMusicTrack,                  "IID_IDirectMusicTrack" },
    { (GUID*)&IID_IDirectMusicPerformance,            "IID_IDirectMusicPerformance" },
//    { (GUID*)&IID_IDirectMusicTool,                   "IID_IDirectMusicTool" },
//    { (GUID*)&IID_IDirectMusicGraph,                  "IID_IDirectMusicGraph" },
//    { (GUID*)&IID_IDirectMusicStyle,                  "IID_IDirectMusicStyle" },
//    { (GUID*)&IID_IDirectMusicChordMap,               "IID_IDirectMusicChordMap" },
//    { (GUID*)&IID_IDirectMusicComposer,               "IID_IDirectMusicComposer" },
//    { (GUID*)&IID_IDirectMusicBand,                   "IID_IDirectMusicBand" },

//    { (GUID*)&IID_IDirectMusicPerformance2,           "IID_IDirectMusicPerformance2" },
//    { (GUID*)&IID_IDirectMusicSegment2,               "IID_IDirectMusicSegment2" },

    { (GUID*)&IID_IDirectMusicLoader8,                "IID_IDirectMusicLoader8" },
//    { (GUID*)&IID_IDirectMusicObject8,                "IID_IDirectMusicObject8" },
    { (GUID*)&IID_IDirectMusicPerformance8,           "IID_IDirectMusicPerformance8" },
    { (GUID*)&IID_IDirectMusicSegment8,               "IID_IDirectMusicSegment8" },
    { (GUID*)&IID_IDirectMusicSegmentState8,          "IID_IDirectMusicSegmentState8" },
//    { (GUID*)&IID_IDirectMusicTool8,                  "IID_IDirectMusicTool8" },
//    { (GUID*)&IID_IDirectMusicGraph8,                 "IID_IDirectMusicGraph8" },
//    { (GUID*)&IID_IDirectMusicTrack8,                 "IID_IDirectMusicTrack8" },
//    { (GUID*)&IID_IDirectMusicStyle8,                 "IID_IDirectMusicStyle8" },
//    { (GUID*)&IID_IDirectMusicComposer8,              "IID_IDirectMusicComposer8" },
//    { (GUID*)&IID_IDirectMusicBand8,                  "IID_IDirectMusicBand8" },
//    { (GUID*)&IID_IDirectMusicParamHook,              "IID_IDirectMusicParamHook" },
//    { (GUID*)&IID_IDirectMusicPatternTrack,           "IID_IDirectMusicPatternTrack" },
    { (GUID*)&IID_IDirectMusicScript,                 "IID_IDirectMusicScript" },
    //{ (GUID*)&IID_IDirectMusicContainer,              "IID_IDirectMusicContainer" },
    //{ (GUID*)&IID_IDirectMusicSong,                   "IID_IDirectMusicSong" },
    { (GUID*)&IID_IDirectMusicAudioPath,              "IID_IDirectMusicAudioPath" },

    // dsound.h
//    { (GUID*)&IID_IDirectSoundSink,                   "IID_IDirectSoundSink"   },
//    { (GUID*)&IID_IDirectSoundSink8,                  "IID_IDirectSoundSink8" },
//    { (GUID*)&IID_IDirectSoundBuffer,                 "IID_IDirectSoundBuffer"   },
//    { (GUID*)&IID_IDirectSoundBuffer8,                "IID_IDirectSoundBuffer8" },
//    { (GUID*)&IID_IDirectSound3DListener,             "IID_IDirectSound3DListener" },
//    { (GUID*)&IID_IDirectSoundNotify,                 "IID_IDirectSoundNotify" },
//    { (GUID*)&IID_IKsPropertySet,                     "IID_IKsPropertySet" },
//    { (GUID*)&IID_IDirectSound3DBuffer,               "IID_IDirectSound3DBuffer" },
//    { (GUID*)&IID_IDirectSoundFXSend,                 "IID_IDirectSoundFXSend"},
//    { (GUID*)&IID_IDirectSoundFXChorus,               "IID_IDirectSoundFXChorus"},
//    { (GUID*)&IID_IDirectSoundFXCompressor,           "IID_IDirectSoundFXCompressor"},
//    { (GUID*)&IID_IDirectSoundFXDistortion,           "IID_IDirectSoundFXDistortion"},
//    { (GUID*)&IID_IDirectSoundFXEcho,                 "IID_IDirectSoundFXEcho"},
//    { (GUID*)&IID_IDirectSoundFXFlanger,              "IID_IDirectSoundFXFlanger"},
//    { (GUID*)&IID_IDirectSoundFXGargle,               "IID_IDirectSoundFXGargle"},
//    { (GUID*)&IID_IDirectSoundFXI3DL2Reverb,          "IID_IDirectSoundFXI3DL2Reverb"},
//    { (GUID*)&IID_IDirectSoundFXParamEq,              "IID_IDirectSoundFXParamEq"},
//    { (GUID*)&IID_IDirectSoundFXWavesReverb,          "IID_IDirectSoundFXWavesReverb"},
    { (GUID*)&GUID_All_Objects,                       "GUID_All_Objects"},

// misc GUIDs (>not< part of DirectMusic)
    { (GUID*)&IID_IUnknown,                           "IID_IUnknown"},
    { (GUID*)&GUID_NULL,                              "GUID_NULL" },


// test wrapper guids
    { (GUID*)&CTIID_IUnknown,                         "CTIID_IUnknown" },
    /*
    { (GUID*)&CTIID_IDirectMusic,                       "CTIID_IDirectMusic" },
    { (GUID*)&CTIID_IDirectMusicBand,                 "CTIID_IDirectMusicBand" },
    { (GUID*)&CTIID_IDirectMusicBuffer,               "CTIID_IDirectMusicBuffer" },
    { (GUID*)&CTIID_IDirectMusicCollection,             "CTIID_IDirectMusicCollection" },
    { (GUID*)&CTIID_IDirectMusicComposer,             "CTIID_IDirectMusicComposer" },
    { (GUID*)&CTIID_IDirectMusicDownload,             "CTIID_IDirectMusicDownload" },
    { (GUID*)&CTIID_IDirectMusicDownloadedInstrument, "CTIID_IDirectMusicDownloadedInstrument" },
    { (GUID*)&CTIID_IDirectMusicGraph,                  "CTIID_IDirectMusicGraph" },
    { (GUID*)&CTIID_IDirectMusicInstrument,             "CTIID_IDirectMusicInstrument" },
*/
    { (GUID*)&CTIID_IDirectMusicLoader,               "CTIID_IDirectMusicLoader" },
/*
    { (GUID*)&CTIID_IDirectMusicObject,               "CTIID_IDirectMusicObject" },
    { (GUID*)&CTIID_IDirectMusicPerformance,            "CTIID_IDirectMusicPerformance" },
    { (GUID*)&CTIID_IDirectMusicChordMap,             "CTIID_IDirectMusicChordMap" },
    { (GUID*)&CTIID_IDirectMusicPort,                 "CTIID_IDirectMusicPort" },
    { (GUID*)&CTIID_IDirectMusicPortDownload,         "CTIID_IDirectMusicPortDownload" },
*/
    { (GUID*)&CTIID_IDirectMusicSegment,              "CTIID_IDirectMusicSegment" },
    { (GUID*)&CTIID_IDirectMusicSegmentState,         "CTIID_IDirectMusicSegmentState" },
/*
    { (GUID*)&CTIID_IDirectMusicStyle,                  "CTIID_IDirectMusicStyle" },
    { (GUID*)&CTIID_IDirectMusicSynth,                  "CTIID_IDirectMusicSynth" },
    { (GUID*)&CTIID_IDirectMusicSynthSink,            "CTIID_IDirectMusicSynthSink" },
    { (GUID*)&CTIID_IDirectMusicTool,                 "CTIID_IDirectMusicTool" },
    { (GUID*)&CTIID_IDirectMusicTrack,                  "CTIID_IDirectMusicTrack" },
    { (GUID*)&CTIID_IReferenceClock,                  "CTIID_IReferenceClock" },
    { (GUID*)&CTIID_IDirectMusicGetLoader,            "CTIID_IDirectMusicGetLoader" },

//dx7
    { (GUID*)&CTIID_IDirectMusicPerformance2,         "CTIID_IDirectMusicPerformance2" },
    { (GUID*)&CTIID_IDirectMusicSegment2,             "CTIID_IDirectMusicSegment2" },

//dx8
    { (GUID*)&CTIID_IDirectMusic8,                    "CTIID_IDirectMusic8" },
    { (GUID*)&CTIID_IDirectMusicPatternTrack,         "CTIID_IDirectMusicPatternTrack" },
*/
    { (GUID*)&CTIID_IDirectMusicSegment8,            "CTIID_IDirectMusicSegment8" },
    { (GUID*)&CTIID_IDirectMusicLoader8,              "CTIID_IDirectMusicLoader8" },
    { (GUID*)&CTIID_IDirectMusicPerformance8,         "CTIID_IDirectMusicPerformance8" },
/*
    { (GUID*)&CTIID_IDirectMusicTool8,                  "CTIID_IDirectMusicTool8" },
    { (GUID*)&CTIID_IDirectMusicStyle8,               "CTIID_IDirectMusicStyle8" },
    { (GUID*)&CTIID_IDirectMusicComposer8,              "CTIID_IDirectMusicComposer8" },
    */
    { (GUID*)&CTIID_IDirectMusicSegmentState8,        "CTIID_IDirectMusicSegmentState8" },
/*
    { (GUID*)&CTIID_IDirectMusicSynth8,               "CTIID_IDirectMusicSynth8" },
    { (GUID*)&CTIID_IDirectMusicTrack8,               "CTIID_IDirectMusicTrack8" },
    { (GUID*)&CTIID_IDirectMusicContainer,            "CTIID_IDirectMusicContainer" },
    { (GUID*)&CTIID_IDirectMusicSong,                 "CTIID_IDirectMusicSong" },
*/
    { (GUID*)&CTIID_IDirectMusicScript,               "CTIID_IDirectMusicScript" },
/*
    { (GUID*)&CTIID_IDirectMusicScriptError,            "CTIID_IDirectMusicScriptError" },
*/
    { (GUID*)&CTIID_IDirectMusicAudioPath,            "CTIID_IDirectMusicAudioPath" }

};


//---------------------------------------------------------------------------

// DMUS_APATH list (used by dmthXlatDMUS_APATH)
typedef struct
{
    DWORD dwAPathType;
    LPSTR   sz;
} DMUS_APATH_LIST;



static DMUS_APATH_LIST glAPathList[]=
{
    // dmusici.h
    { DMUS_APATH_SHARED_STEREOPLUSREVERB,   "DMUS_APATH_SHARED_STEREOPLUSREVERB" },
    { DMUS_APATH_DYNAMIC_3D,                "DMUS_APATH_DYNAMIC_3D" },
    { DMUS_APATH_DYNAMIC_MONO,              "DMUS_APATH_DYNAMIC_MONO" },
    { DMUS_APATH_SHARED_STEREO,             "DMUS_APATH_SHARED_STEREO" },
    
    { DMUS_APATH_MIXBIN_QUAD          , "DMUS_APATH_MIXBIN_QUAD"},
    { DMUS_APATH_MIXBIN_QUAD_ENV      , "DMUS_APATH_MIXBIN_QUAD_ENV"},
    { DMUS_APATH_MIXBIN_QUAD_MUSIC    , "DMUS_APATH_MIXBIN_QUAD_MUSIC"},
    { DMUS_APATH_MIXBIN_5DOT1         , "DMUS_APATH_MIXBIN_5DOT1"},
    { DMUS_APATH_MIXBIN_5DOT1_ENV     , "DMUS_APATH_MIXBIN_5DOT1_ENV"},
    { DMUS_APATH_MIXBIN_5DOT1_MUSIC   , "DMUS_APATH_MIXBIN_5DOT1_MUSIC"},
    { DMUS_APATH_MIXBIN_STEREO_EFFECTS, "DMUS_APATH_MIXBIN_STEREO_EFFECTS"},
    { 0,                                    "NULL" }



};

//---------------------------------------------------------------------------

// DMUS_STAGE list (used by dmthXlatDMUS_STAGE)
typedef struct
{
    DWORD dwStageType;
    LPSTR   sz;
} DMUS_STAGE_LIST;


static DMUS_STAGE_LIST glStageList[]=
{
    // dmusics.h
     {DMUS_PATH_SEGMENT            ,"DMUS_PATH_SEGMENT"},
//     {DMUS_PATH_SEGMENT_TRACK      ,"DMUS_PATH_SEGMENT_TRACK"},
//     {DMUS_PATH_SEGMENT_GRAPH      ,"DMUS_PATH_SEGMENT_GRAPH"},
//     {DMUS_PATH_SEGMENT_TOOL       ,"DMUS_PATH_SEGMENT_TOOL"},
     {DMUS_PATH_AUDIOPATH          ,"DMUS_PATH_AUDIOPATH"},
//     {DMUS_PATH_AUDIOPATH_GRAPH    ,"DMUS_PATH_AUDIOPATH_GRAPH"},
//     {DMUS_PATH_AUDIOPATH_TOOL     ,"DMUS_PATH_AUDIOPATH_TOOL"},
     {DMUS_PATH_PERFORMANCE        ,"DMUS_PATH_PERFORMANCE"},
//     {DMUS_PATH_PERFORMANCE_GRAPH  ,"DMUS_PATH_PERFORMANCE_GRAPH"},
//     {DMUS_PATH_PERFORMANCE_TOOL   ,"DMUS_PATH_PERFORMANCE_TOOL"},
//     {DMUS_PATH_PORT               ,"DMUS_PATH_PORT"},
     {DMUS_PATH_BUFFER             ,"DMUS_PATH_BUFFER"},
//     {DMUS_PATH_BUFFER_DMO         ,"DMUS_PATH_BUFFER_DMO"},
//     {DMUS_PATH_MIXIN_BUFFER       ,"DMUS_PATH_MIXIN_BUFFER"},
//     {DMUS_PATH_MIXIN_BUFFER_DMO   ,"DMUS_PATH_MIXIN_BUFFER_DMO"},
//     {DMUS_PATH_PRIMARY_BUFFER     ,"DMUS_PATH_PRIMARY_BUFFER"},
     {0                            ,"NULL" }

};


//===========================================================================
// dmthXlatHRESULT
//
// Translates HRESULT codes into human readable form.
//
// Parameters:
//
// Returns:
//
// History:
//  10/17/1997 - davidkl - created (adapted from tdinput sources)
//  04/03/1998 - davidkl - renamed (old name still works)
//===========================================================================
LPSTR dmthXlatHRESULT(HRESULT hRes)
{
    int i;

    for( i=0;i<sizeof( elErrors )/sizeof( elErrors[0] );i++ )
    {
        if( hRes == elErrors[i].rval )
        {
            return elErrors[i].sz;
        }
    }

    return "Unknown HRESULT";

} //*** end dmthXlatHRESULT()


//===========================================================================
// dmthXlatGUID
//
// Translates GUIDs into what you would type into your source
//
// Parameters:
//
// Returns:
//
// History:
//  03/23/1998 - davidkl - created (adapted from tdmXlatHRESULT)
//  04/03/1998 - davidkl - renamed
//===========================================================================
LPSTR dmthXlatGUID(REFGUID rguid)
{
    int i;

    for( i=0;i<sizeof( glGuids )/sizeof( glGuids[0] );i++ )
    {
        if( IsEqualGUID(rguid, *(glGuids[i].pguid)))
        {
            return glGuids[i].sz;
        }
    }

    return "Unknown GUID";

} //*** end dmthXlatGUID()


//===========================================================================
// tdmGUIDtoString
//
// converts refguid to a string
//
// Parameters:
//
// Returns: nothing
//
// History:
//  02/27/1998 - davidkl - stole this fn from tdinput
//  04/03/1998 - davidkl - renamed
//===========================================================================
void dmthGUIDtoString(REFGUID rguid, LPSTR szBuf)
{

    sprintf(szBuf, "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1], rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5], rguid.Data4[6], rguid.Data4[7]);

} //*** end dmthGUIDtoString()

//===========================================================================
// Logs a GUID as data.
//
// Parameters:
//
// Returns: nothing
//
// History:
// 02/23/00 - danhaff - created.
//===========================================================================
void dmthLogRawGUID(UINT uLogLevel, REFGUID rguid)
{
    char szString[512] = {0};
    dmthGUIDtoString(rguid, szString);
    fnsLog(uLogLevel, szString);
}


//===========================================================================
// dmthXlatDMUS_APATH
//
// Translates DMUS_APATH codes into human readable form.
//
// Parameters:
//
// Returns:
//
// History:
//   02/09/2000 - danhaff - created.
//===========================================================================
LPSTR dmthXlatDMUS_APATH(DWORD dwAPath)
{
    int i;

    for( i=0;i<sizeof( glAPathList)/sizeof( glAPathList[0] );i++ )
    {
        if( dwAPath == glAPathList[i].dwAPathType)
        {
            return glAPathList[i].sz;
        }
    }

    return "Unknown DMUS_APATH";

} //*** end dmthXlatSTANDARD_PATH()

//===========================================================================
// dmthXlatDMUS_STAGE
//
// Translates DMUS_STAGE codes into human readable form.
//
// Parameters:
//
// Returns:
//
// History:
//   02/09/2000 - danhaff - created.
//===========================================================================
LPSTR dmthXlatDMUS_STAGE(DWORD dwStage)
{
    int i;

    for( i=0;i<sizeof( glStageList)/sizeof( glStageList[0] );i++ )
    {
        if( dwStage == glStageList[i].dwStageType)
        {
            return glStageList[i].sz;
        }
    }

    return "Unknown stage";

} //*** end dmthXlatDMUS_STAGE()







//===========================================================================
// dmth_lstrcpyW
//
// Copies a unicode string.
//
// Parameters:
//  LPWSTR  pszDest - destination buffer
//  LPCWSTR pcszSrc - source buffer
//
// Returns:
//  LPWSTR - ptr to dest buffer
//
// History:
//  04/16/1998 - davidkl - stolen from tdinput code
//===========================================================================
LPWSTR dmth_lstrcpyW(LPWSTR pwszDest, LPCWSTR pcwszSrc)
{
    int i = 0;

    // validate pointers
    if(!helpIsValidPtr((void *)pwszDest, sizeof(WCHAR), FALSE) ||
        !helpIsValidPtr((void *)pcwszSrc, sizeof(WCHAR), FALSE))
    {
        *pwszDest = NULL;
        return (LPWSTR)NULL;
    }

    // BUGBUG how to tell if we are about to overrun pwszDest??

    while(pcwszSrc[i] != L'\0')
    {
        pwszDest[i] = (WCHAR)pcwszSrc[i];
        i++;
    }
    pwszDest[i] = L'\0';

    return pwszDest;

} //*** end dmth_lstrcpyW()




/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//
//
//    LOG STRUCTURE HELPERS
//
//
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////




//===========================================================================
// dmthLogDMUS_OBJECTDESCStruct()
//
// Uses fnslog to output contents of a DMUS_OBJECTDESC structure
//
// Parameters:
// DMUS_OBJECTDESC  Desc
//
//  DWORD           dwSize;                         /* Size of this structure. */
//  DWORD           dwValidData;                    /* Flags indicating which fields below are valid. */
//  GUID            guidObject;                     /* Unique ID for this object. */
//  GUID            guidClass;                      /* GUID for the class of object. */
//  FILETIME        ftDate;                         /* Last edited date of object. */
//  DMUS_VERSION    vVersion;                       /* Version. */
//  WCHAR           wszName[DMUS_MAX_NAME];         /* Name of object.  Should we support Unicode? How? */
//  WCHAR           wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
//  WCHAR           wszFileName[DMUS_MAX_FILENAME]; /* File path. */
//
// History:
//  03/17/1998 - jimmo - created
//  03/29/1998 - davidkl - no need to return a value
//  04/01/1998 - davidkl - kelly verified that we do not need to convert
//                         strings for logging
//===========================================================================
void dmthLogDMUS_OBJECTDESCStruct(DMUS_OBJECTDESC Desc)
{
    char     szIID[MAX_LOGSTRING];

    fnsIncrementIndent();

    fnsLog(STRUCTLOGLEVEL,		"DMUS_OBJECTDESC");
    fnsLog(STRUCTLOGLEVEL,		"===============");

    /* Size of this structure. */
    fnsLog(STRUCTLOGLEVEL,		"dwSize                == %d",
            Desc.dwSize);
    /* Flags indicating which fields below are valid. */
    fnsLog(STRUCTLOGLEVEL,		"dwValidData           == %08Xh",
            Desc.dwValidData);

    /* Unique ID for this object. */
    if (Desc.dwValidData & DMUS_OBJ_OBJECT)
    {
         tdmGUIDtoString((REFGUID)Desc.guidObject, szIID);
        fnsLog(STRUCTLOGLEVEL,	"guidObject            == %s (%s)",
                szIID, tdmXlatGUID((REFGUID)Desc.guidObject));
    }

    /* GUID for the class of object. */
    if (Desc.dwValidData & DMUS_OBJ_CLASS)
    {
         tdmGUIDtoString((REFGUID)Desc.guidClass, szIID);
        fnsLog(STRUCTLOGLEVEL,	"guidClass             == %s (%s)",
                szIID, tdmXlatGUID((REFGUID)Desc.guidClass));
    }

    /* Last edited date of object. */
    fnsLog(STRUCTLOGLEVEL,		"ftDate.LowDateTime    == %d",
            Desc.ftDate.dwLowDateTime);
    fnsLog(STRUCTLOGLEVEL,		"ftDate.HighDateTime   == %d",
            Desc.ftDate.dwHighDateTime);

    //BUGBUG  MS DWORD needs to be shifted.  -jimmo
    /* Version. */
    if (Desc.dwValidData & DMUS_OBJ_VERSION)
    {
        fnsLog(STRUCTLOGLEVEL,	"Version               == %d.%d",
                Desc.vVersion.dwVersionMS, Desc.vVersion.dwVersionLS);
    }

    /* Name of object. */
    if (Desc.dwValidData & DMUS_OBJ_NAME){
        fnsLog(STRUCTLOGLEVEL,	"Name                  == %ls",
                Desc.wszName);
    }

    /* Category for object (optional). */
    if (Desc.dwValidData & DMUS_OBJ_CATEGORY){
        fnsLog(STRUCTLOGLEVEL,	"Category              == %ls",
                Desc.wszCategory);
    }

    /* File path. */
    if (Desc.dwValidData & DMUS_OBJ_FULLPATH){
        fnsLog(STRUCTLOGLEVEL,	"FileName (fullpath)   == %ls",
                Desc.wszFileName);
    }
    else if (Desc.dwValidData & DMUS_OBJ_FILENAME){
        fnsLog(STRUCTLOGLEVEL,	"FileName              == %ls",
                Desc.wszFileName);
    }

    fnsDecrementIndent();

} //*** end dmthLogDMUS_OBJECTDESCStruct()


//===========================================================================
// dmthLogDMUS_SCRIPT_ERRORINFO
//
// Logs the contents of DMUS_SCRIPT_ERRORINFO structure
//
// Parameters:
//  UINT                    uLogLevel   - fnshell logging level
//  DMUS_SCRIPT_ERRORINFO*  pdmpc      - pointer to DMUS_SCRIPT_ERRORINFO
//
// Returns: nothing
//
// History:
//  02/17/2000 - jimmo - created
//===========================================================================
void
dmthLogDMUS_SCRIPT_ERRORINFO
(
    UINT                    uLogLevel,
    DMUS_SCRIPT_ERRORINFO*  pdmScriptErrorInfo
)
{
    //////////////////////////////////////////////////////////////////
    // validate pdmScriptErrorInfo
    //////////////////////////////////////////////////////////////////
    if(!helpIsValidPtr((void*)pdmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO), FALSE))
    {
        fnsLog(uLogLevel, "Invalid DMUS_SCRIPT_ERRORINFO pointer (%p)..."
                "Unable to log structure contents", pdmScriptErrorInfo);
        return;
    }

    //////////////////////////////////////////////////////////////////
    // log the contents of pdmScriptErrorInfo
    //////////////////////////////////////////////////////////////////
    fnsLog(uLogLevel, "DMUS_SCRIPT_ERRORINFO structure");
    fnsLog(uLogLevel, "===============================");
    fnsLog(uLogLevel, "dwSize             == %08Xh(%08d)",  pdmScriptErrorInfo->dwSize,pdmScriptErrorInfo->dwSize);
    fnsLog(uLogLevel, "hr                 == %08Xh",        pdmScriptErrorInfo->hr);
    fnsLog(uLogLevel, "ulLineNumber       == %d",           pdmScriptErrorInfo->ulLineNumber);
    fnsLog(uLogLevel, "ichCharPosition    == %d",           pdmScriptErrorInfo->ichCharPosition);
    fnsLog(uLogLevel, "wszSourceFile      == %s",          pdmScriptErrorInfo->wszSourceFile);
    fnsLog(uLogLevel, "wszSourceComponent == %s",          pdmScriptErrorInfo->wszSourceComponent);
    fnsLog(uLogLevel, "wszDescription     == %s",          pdmScriptErrorInfo->wszDescription);
    fnsLog(uLogLevel, "wszSourceLineText  == %s",          pdmScriptErrorInfo->wszSourceLineText);

} //*** end tdmLogDMUS_SCRIPT_ERRORINFO()





struct PAIR
{
DWORD dwFlag;
CHAR *szString;
};

PAIR Flags[] =
            {
            {DMUS_SEGF_REFTIME             ,"DMUS_SEGF_REFTIME "},
            {DMUS_SEGF_SECONDARY           ,"DMUS_SEGF_SECONDARY "},
            {DMUS_SEGF_QUEUE               ,"DMUS_SEGF_QUEUE "},
            {DMUS_SEGF_CONTROL             ,"DMUS_SEGF_CONTROL "},
            {DMUS_SEGF_AFTERPREPARETIME    ,"DMUS_SEGF_AFTERPREPARETIME "},
            {DMUS_SEGF_GRID                ,"DMUS_SEGF_GRID "},
            {DMUS_SEGF_BEAT                ,"DMUS_SEGF_BEAT "},
            {DMUS_SEGF_MEASURE             ,"DMUS_SEGF_MEASURE "},
            {DMUS_SEGF_DEFAULT             ,"DMUS_SEGF_DEFAULT "},
            {DMUS_SEGF_NOINVALIDATE        ,"DMUS_SEGF_NOINVALIDATE "},
            {DMUS_SEGF_ALIGN               ,"DMUS_SEGF_ALIGN "},
            {DMUS_SEGF_VALID_START_BEAT    ,"DMUS_SEGF_VALID_START_BEAT "},
            {DMUS_SEGF_VALID_START_GRID    ,"DMUS_SEGF_VALID_START_GRID "},
            {DMUS_SEGF_VALID_START_TICK    ,"DMUS_SEGF_VALID_START_TICK "},
            {DMUS_SEGF_AUTOTRANSITION      ,"DMUS_SEGF_AUTOTRANSITION "},
            {DMUS_SEGF_AFTERQUEUETIME      ,"DMUS_SEGF_AFTERQUEUETIME "},
            {DMUS_SEGF_AFTERLATENCYTIME    ,"DMUS_SEGF_AFTERLATENCYTIME  "},
            {DMUS_SEGF_SEGMENTEND          ,"DMUS_SEGF_SEGMENTEND "},
            {DMUS_SEGF_MARKER              ,"DMUS_SEGF_MARKER "},
            {DMUS_SEGF_TIMESIG_ALWAYS      ,"DMUS_SEGF_TIMESIG_ALWAYS "},
            {DMUS_SEGF_USE_AUDIOPATH       ,"DMUS_SEGF_USE_AUDIOPATH "},
            {DMUS_SEGF_VALID_START_MEASURE ,"DMUS_SEGF_VALID_START_MEASURE "}
            };


LPSTR Log_DMUS_SEGF(DWORD dwFlags)
{
static CHAR szString[300];
static CHAR szString2 [300];
ZeroMemory(szString, 300);
int i;
BOOL bFirst = TRUE;

for  (i=0; i<AMOUNT(Flags); i++)
{
    if (dwFlags & Flags[i].dwFlag)
    {
        strcat(szString, Flags[i].szString);

        if (bFirst)
            bFirst = FALSE;
        else
        {
            //strcat(szString, "| ");
            sprintf(szString2, "| %s", szString);
            strcpy(szString, szString2);
        }

        
    }
}
 
return szString;

};





//===========================================================================
// dmthCoCreateInstance
//
// Wraps CoCreateInstance, if passed a test IID will return a test object
//
// History:
//  03/29/1998 - davidkl - created
//===========================================================================
HRESULT dmthDirectMusicCreateInstance(REFCLSID rclsid, 
                            LPUNKNOWN pUnkOuter,
                            REFIID riid,
                            LPVOID *ppv)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_pUnkOuter    = TRUE;
    BOOL    fValid_ppv          = TRUE;
    void    **ppvTemp           = NULL;
    char    szCLSID[MAX_LOGSTRING];
    char    szIID[MAX_LOGSTRING];
    BOOL    fMatchFound         = FALSE;

    // validate pUnkOuter
    if(!helpIsValidPtr((void*)pUnkOuter, sizeof(IUnknown), TRUE))
    {
        fValid_pUnkOuter = FALSE;
    }

    // validate ppv
    if(!helpIsValidPtr((void*)ppv, sizeof(IUnknown), FALSE))
    {
        fValid_ppv = FALSE;
    }

    fnsIncrementIndent();

    tdmGUIDtoString(rclsid, szCLSID);
    tdmGUIDtoString(riid, szIID);

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling CoCreateInstance()");
    fnsLog(PARAMLOGLEVEL, "rclsid       == %s (%s)",
            szCLSID, tdmXlatGUID(rclsid));

    fnsLog(PARAMLOGLEVEL, "riid         == %s (%s)",
            szIID, tdmXlatGUID(riid));
    fnsLog(PARAMLOGLEVEL, "ppv          == %p   %s",
            ppv,
            fValid_ppv ? "" : "BAD");

    // call the real function
    hRes = DirectMusicCreateInstance(rclsid, 
                            NULL,
                            riid,
                            ppv);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from CoCreateInstance()");
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppv)
    {
        fnsLog(PARAMLOGLEVEL, "*ppv == %p",
                *ppv);
    }

    // BUGBUG - iff harness IID, wrap the interface returned
    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end dmthCoCreateInstance()



LPSTR tdmXlatHRESULT(HRESULT hRes)
{
    return dmthXlatHRESULT(hRes);
};

LPSTR tdmXlatGUID(REFGUID rguid)
{
    return dmthXlatGUID(rguid);
};

LPSTR tdmXlatDMUS_APATH(DWORD dwStandardPath)
{
    return dmthXlatDMUS_APATH(dwStandardPath);
};


void tdmGUIDtoString(REFGUID rguid, LPSTR szBuf)
{
    dmthGUIDtoString(rguid, szBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\MEMPTR.CPP ===
//===========================================================================
// memptr.cpp
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
// Mempory and pointer functions.
//
// Functions:
//  helpMalloc()
//  helpFree()
//  helpIsValidPtr()
//  helpGetBogusPointer()
//  helpFreeBogusPointer()
//
// History:
//  08/21/1997 - davidkl - created
//  09/12/1997 - davidkl - renamed to memptr.cpp.  moved to sep project
//	10/02/1997 - brianhar - fixed error in dihelpIsValidPtr()
//===========================================================================

#include "globals.h"

//---------------------------------------------------------------------------

//===========================================================================
// helpMalloc
//
// Wraps malloc() to make life a little easier/safer.
//
// Parameters:
//
// Returns: HRESULT
//
// History:
//	03/31/1997 - davidkl - created
//  08/22/1997 - davidkl - snaked from didevsim
//  09/12/1997 - davidkl - changed failure code to outofmemory
//===========================================================================
HRESULT _stdcall helpMalloc(void **ppv, UINT uSize)
{
	BYTE **ppb = (BYTE **)ppv;

	// validate pv
	if(!helpIsValidPtr(ppv, 1, FALSE))
	{
		return E_POINTER;
	}

	// validate uSize
	if(!uSize)
	{
		return E_INVALIDARG;
	}

	// allocate the requested memory block
	*ppb = (BYTE *)malloc(uSize);
	
    if(NULL == *ppb)
    {
        return E_OUTOFMEMORY;
    }

	#ifdef DEBUG
	// pre-fill the memory with junk
	memset(*ppb, MEMJUNK, uSize);
	#endif

	// done
	return S_OK;
		
} //*** end helpMalloc()


//===========================================================================
// helpFree
//
// Wraps free() to make life a little easier/safer.
//
// Parameters:
//
// Returns:
//
// History:
//	03/31/1997 - davidkl - created
//  08/22/1997 - davidkl - snaked from didevsim
//===========================================================================
HRESULT _stdcall helpFree(void *pv)
{
	// validate pv
	if(!helpIsValidPtr(pv, 1, FALSE))
	{
		return E_POINTER;
	}

	#ifdef DEBUG
	// fill the memory block with junk
	memset(pv, MEMJUNK, _msize(pv));
	#endif

	// free the block
	free(pv);
	
	// if we get here, all is well
	return S_OK;

} //*** end helpFree()


//===========================================================================
// helpIsValidPtr
//
// Checks to see if a pointer is valid.
//
// Parameters:
//	[in]  LPVOID ptr	    - pointer to validate
//	[in]  UINT   cb			- number of bytes that ptr points to
//	[in]  BOOL   fAllowNull - should we consider NULL a valid pointer?
//
// Returns: BOOL
//
// History:
//	02/25/1997 - davidkl - created
//  08/22/1997 - davidkl - snaked from didevsim.
//	10/02/1997 - brianhar - fixed inverted logic problem
//===========================================================================
BOOL _stdcall helpIsValidPtr(LPVOID ptr, UINT cb, BOOL fAllowNull)
{

    if(IsBadReadPtr(ptr, cb) ||
        IsBadWritePtr(ptr, cb))
    {
		if (fAllowNull && (ptr==NULL))	
		{
			return TRUE;	// Only way out from here is having a NULL when NULL is OK
		}
		return FALSE;
    }

    // if we get here, we have a valid pointer
    return TRUE;

} //*** end helpIsValidPtr()


//===========================================================================
// helpIsValidWritePtr
//
// Checks to see if a pointer is a valid write ptr.
//
// Parameters:
//	[in]  LPVOID ptr	    - pointer to validate
//	[in]  UINT   cb			- number of bytes that ptr points to
//	[in]  BOOL   fAllowNull - should we consider NULL a valid pointer?
//
// Returns: BOOL
//
// History:
//	02/25/1997 - davidkl - created
//  08/22/1997 - davidkl - snaked from didevsim.
//	10/02/1997 - brianhar - fixed inverted logic problem
//  03/08/2000 - danhaff - copied from helpIsValidPtr
//===========================================================================
BOOL _stdcall helpIsValidWritePtr(LPVOID ptr, UINT cb, BOOL fAllowNull)
{

    if (IsBadWritePtr(ptr, cb))
    {
		if (fAllowNull && (ptr==NULL))	
		{
			return TRUE;	// Only way out from here is having a NULL when NULL is OK
		}
		return FALSE;
    }

    // if we get here, we have a valid pointer
    return TRUE;

} //*** end helpIsValidPtr()



//===========================================================================
// helpIsValidReadPtr
//
// Checks to see if a pointer is a valid write ptr.
//
// Parameters:
//	[in]  LPVOID ptr	    - pointer to validate
//	[in]  UINT   cb			- number of bytes that ptr points to
//	[in]  BOOL   fAllowNull - should we consider NULL a valid pointer?
//
// Returns: BOOL
//
// History:
//	02/25/1997 - davidkl - created
//  08/22/1997 - davidkl - snaked from didevsim.
//	10/02/1997 - brianhar - fixed inverted logic problem
//  03/08/2000 - danhaff - copied from helpIsValidPtr
//===========================================================================
BOOL _stdcall helpIsValidReadPtr(LPVOID ptr, UINT cb, BOOL fAllowNull)
{

    if (IsBadReadPtr(ptr, cb))
    {
		if (fAllowNull && (ptr==NULL))	
		{
			return TRUE;	// Only way out from here is having a NULL when NULL is OK
		}
		return FALSE;
    }

    // if we get here, we have a valid pointer
    return TRUE;

} //*** end helpIsValidPtr()



//===========================================================================
// helpGetBogusPointer
//
// Creates a bad pointer.
//
// Parameters: none
//
// Returns: LPVOID
//
// History:
//  09/12/1997 - davidkl - taken from tdinput sources
//===========================================================================
LPVOID _stdcall helpGetBogusPointer(void)
{

	// allocate some memory and mark it not accessable
	return VirtualAlloc(NULL, 8, MEM_COMMIT, PAGE_NOACCESS);

} //*** end helpGetBogusPointer()


//===========================================================================
// helpFreeBogusPointer
//
// Frees bad pointer created by helpGetBogusPointer.
//
// Parameters:
//  LPVOID lpv  - pointer to free
//
// Returns: nothing
//
// History:
//  09/12/1997 - davidkl - taken from tdinput sources
//  03/23/1998 - a-kellyc - Added VirtualProtect function call
//===========================================================================
void _stdcall helpFreeBogusPointer(LPVOID lpv)
{
	DWORD   dwOld;

	if (lpv)
	{
		// set the access rights back to read/write
		if (VirtualProtect(lpv, 8, PAGE_READWRITE, &dwOld))
		{
			// release memory pointed to by lpv
			VirtualFree(lpv, 0, MEM_RELEASE);
		}
	}

} //*** end helpFreeBogusPointer()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================










=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctbuffer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctbuffer.cpp
//
//--------------------------------------------------------------------------

//==========================================================================
// ctbuffer.cpp
//
// Test harness implementation of IDirectMusicBuffer
//
// Functions:
//  CtIDirectMusicBuffer::CtIDirectMusicBuffer()
//  CtIDirectMusicBuffer::~CtIDirectMusicBuffer()
//  CtIDirectMusicBuffer::InitTestClass()
//  CtIDirectMusicBuffer::GetRealObjPtr()
//  CtIDirectMusicBuffer::QueryInterface()
//  CtIDirectMusicBuffer::Flush()
//  CtIDirectMusicBuffer::TotalTime()
//  CtIDirectMusicBuffer::PackStructured()
//  CtIDirectMusicBuffer::PackUnstructured()
//  CtIDirectMusicBuffer::ResetReadPtr()
//  CtIDirectMusicBuffer::GetNextEvent()
//  CtIDirectMusicBuffer::GetRawBufferPtr()
//  CtIDirectMusicBuffer::GetStartTime()
//  CtIDirectMusicBuffer::GetUsedBytes()
//  CtIDirectMusicBuffer::GetMaxBytes()
//  CtIDirectMusicBuffer::SetStartTime()
//  CtIDirectMusicBuffer::SetUsedBytes()
//  CtIDirectMusicBuffer::GetBufferFormat()
//
// History:
//  10/17/1997 - davidkl - created
//  11/14/1997 - davidkl - changed in response to new dmusic.h
//	01/19/1998 - a-llucar - changed to latest core changes
//  03/24/1998 - davidkl - brave new world...  now a derived class
//  04/01/1998 - davidkl - minor tweaks
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicBuffer::CtIDirectMusicBuffer
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicBuffer::CtIDirectMusicBuffer(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicBuffer";

} //*** end CtIDirectMusicBuffer::CtIDirectMusicBuffer()


//===========================================================================
// CtIDirectMusicBuffer::~CtIDirectMusicBuffer
//
// Default destructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicBuffer::~CtIDirectMusicBuffer(void)
{
    // nothing to do

} //*** end CtIDirectMusicBuffer::~CtIDirectMusicBuffer()


//===========================================================================
// CtIDirectMusicBuffer::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicBuffer object pointer for future use.
//
// Parameters:
//  IDirectMusicBuffer  *pdmBuf - pointer to real IDirectMusicBuffer object
//
// Returns: 
//
// History:
//  10/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::InitTestClass(IDirectMusicBuffer *pdmBuf)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmBuf, sizeof(IDirectMusicBuffer), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmBuf));

} //*** end CtIDirectMusicBuffer::InitTestClass()


//===========================================================================
// CtIDirectMusicBuffer::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicBuffer **ppdmBuf - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	10/17/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetRealObjPtr(IDirectMusicBuffer **ppdmBuf)
{

	// validate ppdmBuf
	if(!helpIsValidPtr(ppdmBuf, sizeof(IDirectMusicBuffer*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmBuf));

} //*** end CtIDirectMusicBuffer::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicBuffer::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//  HRESULT - return code from real QueryInterface
//
// History:
//  10/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::QueryInterface()


//===========================================================================
// CtIDirectMusicBuffer::Flush
//
// Encapsulates calls to Flush
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real Flush
//
// History:
//  10/20/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::Flush(void)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Flush()",
            m_szInterfaceName);

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->Flush();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Flush()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    //done
    return hRes;

} //*** end CtIDirectMusicBuffer::Flush()


//===========================================================================
// CtIDirectMusicBuffer::TotalTime
//
// Encapsulates calls to TotalTime
//
// Parameters:
//
// Returns:
//  HRESULT - return code from real TotalTime
//
// History:
//  10/20/1997 - davidkl - created
//  11/14/1997 - davidkl - changed in response to new dmusic.h
//===========================================================================
HRESULT CtIDirectMusicBuffer::TotalTime(LPREFERENCE_TIME prtTime)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_prtTime  = TRUE;

    // validate pdwTime
    if(!helpIsValidPtr((void*)prtTime, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtTime = FALSE;
    }
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::TotalTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtTime == %p   %s",
            prtTime,
            fValid_prtTime ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->TotalTime(prtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::TotalTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtTime)
    {
        fnsLog(PARAMLOGLEVEL, "*prtTime == %016Xh",
                *prtTime);
    }

    fnsDecrementIndent();

    //done
    return hRes;

} //*** end CtIDirectMusicBuffer::TotalTime()


//===========================================================================
// CtIDirectMusicBuffer::PackStructured
//
// Encapsulates calls to PackStructured
//
// Parameters:
//
// Returns:
//  HRESULT - return code from real PackStructured
//
// History:
//  10/24/1997 - davidkl - created
//  11/14/1997 - davidkl - changed in response to new dmusic.h
//===========================================================================
HRESULT CtIDirectMusicBuffer::PackStructured(REFERENCE_TIME rt, 
                                            DWORD dwChannelGroup,
                                            DWORD dwMsg)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PackStructured()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt             == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwMsg          == %08Xh",
            dwMsg);

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->PackStructured(rt, dwChannelGroup, dwMsg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PackStructured()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::PackStructured()


//===========================================================================
// CtIDirectMusicBuffer::PackUnstructured
//
// Encapsulates calls to PackUnstructured
//
// Parameters:
//
// Returns:
//  HRESULT - return code from real PackUnstructured
//
// History:
//  10/24/1997 - davidkl - created
//  11/14/1997 - davidkl - changed in response to new dmusic.h
//===========================================================================
HRESULT CtIDirectMusicBuffer::PackUnstructured(REFERENCE_TIME rt, 
                                        DWORD dwChannelGroup,
                                        DWORD cb, 
                                        LPBYTE lpb)
{
    HRESULT hRes        = E_NOTIMPL;
    BOOL    fValid_lpb  = TRUE;

    // validate lpb
    if(!helpIsValidPtr((void*)lpb, sizeof(BYTE) * cb, FALSE))
    {
        fValid_lpb = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PackUnstructured()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt             == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "cb             == %08Xh",
            cb);
    fnsLog(PARAMLOGLEVEL, "lpb            == %p   %s",
            lpb,
            fValid_lpb ? "" : "BAD");
    // BUGBUG log contents of lpb?

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->PackUnstructured(rt, dwChannelGroup, cb, lpb);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PackUnstructured)",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::PackUnstructured()


//===========================================================================
// CtIDirectMusicBuffer::ResetReadPtr
//
// Encapsulates calls to ResetReadPtr
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real ResetReadPtr
//
// History:
//  10/20/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::ResetReadPtr(void)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ResetReadPtr()",
            m_szInterfaceName);

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->ResetReadPtr();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ResetReadPtr()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    //done
    return hRes;

} //*** end CtIDirectMusicBuffer::ResetReadPtr()


//===========================================================================
// CtIDirectMusicBuffer::GetNextEvent
//
// Encapsulates calls to GetNextEvent
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetNextEvent
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetNextEvent(LPREFERENCE_TIME prt, 
                                            LPDWORD pdwChannelGroup,
                                            LPDWORD pdwLength, 
                                            LPBYTE *ppData)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_prt              = TRUE;
    BOOL    fValid_pdwChannelGroup  = TRUE;
    BOOL    fValid_pdwLength        = TRUE;
    BOOL    fValid_ppData           = TRUE;

    // validate prt
    if(!helpIsValidPtr((void*)prt, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prt = FALSE;
    }
    // validate pdwChannelGroup
    if(!helpIsValidPtr((void*)pdwChannelGroup, sizeof(DWORD), FALSE))
    {
        fValid_pdwChannelGroup = FALSE;
    }
    // validate pdwLength
    if(!helpIsValidPtr((void*)pdwLength, sizeof(DWORD), FALSE))
    {
        fValid_pdwLength = FALSE;
    }
    // validate ppData
    if(!helpIsValidPtr((void*)ppData, sizeof(LPBYTE), FALSE))
    {
        fValid_ppData = FALSE;       
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetNextEvent()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prt             == %p   %s",
            prt,
            fValid_prt ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwChannelGroup == %p   %s",
            pdwChannelGroup,
            fValid_pdwChannelGroup ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwLength       == %p   %s",
            pdwLength,
            fValid_pdwLength ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppData          == %p   %s",
            ppData,
            fValid_ppData ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetNextEvent(prt, pdwChannelGroup, pdwLength, ppData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetNextEvent()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes             == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prt)
    {
        fnsLog(PARAMLOGLEVEL, "*prt             == %016Xh",
                *prt);
    }
    if(fValid_pdwChannelGroup)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwChannelGroup == %08Xh",
                *pdwChannelGroup);
    }
    if(fValid_pdwLength)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwLength       == %08Xh",
                *pdwLength);
    }
//    if(fValid_ppData)
//    {
// BUGBUG - need to use length to log all data correctly
//        fnsLog(PARAMLOGLEVEL, "*ppData          == %08Xh",
//                *ppData);
//    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::GetNextEvent()


//===========================================================================
// CtIDirectMusicBuffer::GetRawBufferPtr
//
// Encapsulates calls to GetRawBufferPtr
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetRawBufferPtr
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetRawBufferPtr(LPBYTE *ppData)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_ppData   = TRUE;

    // validate ppData
    if(!helpIsValidPtr((void*)ppData, sizeof(LPBYTE), FALSE))
    {
        fValid_ppData = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRawBufferPtr()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppData == %p   %s",
            ppData,
            fValid_ppData ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetRawBufferPtr(ppData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRawBufferPtr()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
//    if(fValid_ppData)
//    {
//        fnsLog(PARAMLOGLEVEL, "*ppData == %08Xh",
//                *ppData);
        // BUGBUG log contents of buffer pointed to by *ppData??
//    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::GetRawBufferPtr()


//===========================================================================
// CtIDirectMusicBuffer::GetStartTime
//
// Encapsulates calls to GetStartTime
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetStartTime
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetStartTime(LPREFERENCE_TIME prt)
{
    HRESULT hRes        = E_NOTIMPL;
    BOOL    fValid_prt  = TRUE;

    // validate prt
    if(!helpIsValidPtr((void*)prt, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prt = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prt == %p   %s",
            prt,
            fValid_prt ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetStartTime(prt);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prt)
    {
        fnsLog(PARAMLOGLEVEL, "*prt == %016Xh",
                *prt);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::GetStartTime()


//===========================================================================
// CtIDirectMusicBuffer::GetUsedBytes
//
// Encapsulates calls to GetUsedBytes
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetUsedBytes
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetUsedBytes(LPDWORD pcb)
{
    HRESULT hRes        = E_NOTIMPL;
    BOOL    fValid_pcb  = TRUE;

    // validate pcb
    if(!helpIsValidPtr((void*)pcb, sizeof(DWORD), FALSE))
    {
        fValid_pcb = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetUsedBytes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pcb == %p   %s",
            pcb,
            fValid_pcb ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetUsedBytes(pcb);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pcb)
    {
        fnsLog(PARAMLOGLEVEL, "*pcb == %08Xh",
                *pcb);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::GetUsedBytes()


//===========================================================================
// CtIDirectMusicBuffer::GetMaxBytes
//
// Encapsulates calls to GetMaxBytes
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetMaxBytes
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetMaxBytes(LPDWORD pcb)
{
    HRESULT hRes    = E_NOTIMPL;
    BOOL    fValid_pcb  = TRUE;

    // validate pcb
    if(!helpIsValidPtr((void*)pcb, sizeof(DWORD), FALSE))
    {
        fValid_pcb = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMaxBytes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pcb == %08Xh   %s",
            pcb,
            fValid_pcb ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetMaxBytes(pcb);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMaxBytes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pcb)
    {
        fnsLog(PARAMLOGLEVEL, "*pcb == %08Xh",
                *pcb);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::GetMaxBytes()


//===========================================================================
// CtIDirectMusicBuffer::SetStartTime
//
// Encapsulates calls to SetStartTime
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real SetStartTime
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::SetStartTime(REFERENCE_TIME rt)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt == %016Xh",
            rt);

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->SetStartTime(rt);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetStartTime()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::SetStartTime()


//===========================================================================
// CtIDirectMusicBuffer::SetUsedBytes
//
// Encapsulates calls to SetUsedBytes
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real SetUsedBytes
//
// History:
//  11/14/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::SetUsedBytes(DWORD cb)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetUsedBytes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "cb == %08Xh",
            cb);

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->SetUsedBytes(cb);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetUsedBytes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicBuffer::SetUsedBytes()


//===========================================================================
// CtIDirectMusicBuffer::GetBufferFormat
//
// Encapsulates calls to GetBufferFormat
//
// Parameters: nothing
//
// Returns:
//  HRESULT - return code from real GetBufferFormat
//
// History:
//  03/02/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicBuffer::GetBufferFormat(LPGUID pGuidFormat)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_pGuidFormat  = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pGuidFormat
    if(!helpIsValidPtr((void*)pGuidFormat, sizeof(GUID), FALSE))
    {
        fValid_pGuidFormat = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetBufferFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGuidFormat == %p   %s",
            pGuidFormat,
            (fValid_pGuidFormat) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicBuffer*)m_pUnk)->GetBufferFormat(pGuidFormat);
    
    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetBufferFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes         == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pGuidFormat)
    {
        tdmGUIDtoString(*pGuidFormat, szGuid);
        fnsLog(PARAMLOGLEVEL, "*pGuidFormat == %s (%s)",
                szGuid, tdmXlatGUID(*pGuidFormat));
    }

    fnsDecrementIndent();

    // done
    return hRes;
   
} //*** end CtIDirectMusicBuffer::GetBufferFormat()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\globals.h ===
#pragma once


#undef UNICODE  //Ugh, UNICODE on XBox is like tar on pancakes.
#define INITGUID

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <float.h>
#include <dmusici.h>

#include <dmth.h>

#ifdef NOLOG
    #include "nakedmacros.h"
#else
    #include <macros.h>
#endif 

#include "logging.h"
#include "fakestuff.h"
#pragma warning( disable : 4056 4756 4005)

#include "helpers.h"

extern  HANDLE g_hLog;
extern  LPSTR g_szComponent;
extern  LPSTR g_szSubComp;
extern  LPSTR g_szFunction;
extern  LPSTR g_szVariation;

// Disable warning messages about floating point overflow.
#pragma warning( disable : 4056 4756)
#define INFINITY (FLT_MAX * FLT_MAX)       
#define ALMOST_FLT_MAX (FLT_MAX * 0.99f) //so we don't run up against MAXDISTANCE.

extern CHAR *g_szDefaultMedia;  //defined in DMTEST1.CPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctclock.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctclock.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctclock.cpp
//
// Test harness implementation of IReferenceClock
//
// Functions:
//  CtIReferenceClock::CtIReferenceClock()
//  CtIReferenceClock::~CtIReferenceClock()
//  CtIReferenceClock::InitTestClass()
//  CtIReferenceClock::GetRealObjPtr()
//  CtIReferenceClock::QueryInterface()
//  CtIReferenceClock::GetTime()
//  CtIReferenceClock::AdviseTime()
//  CtIReferenceClock::AdvisePeriodic()
//  CtIReferenceClock::Unadvise()
//
// History:
//  11/17/1997 - davidkl - created
//  03/24/1998 - davidkl - brave new world...  now a derived class
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIReferenceClock::CtIReferenceClock()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIReferenceClock::CtIReferenceClock()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = TEXT("IReferenceClock");

} //*** end CtIReferenceClock::CtIReferenceClock()


//===========================================================================
// CtIReferenceClock::~CtIReferenceClock
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIReferenceClock::~CtIReferenceClock()
{
    // nothing to do

} //*** end CtIReferenceClock::~CtIReferenceClock()



//===========================================================================
// CtIReferenceClock::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IReferenceClock object pointer for future use.
//
// Parameters:
//  CtIReferenceClock *pRefCount - pointer to real object
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::InitTestClass(IReferenceClock *pRefClock)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pRefClock, sizeof(IReferenceClock), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pRefClock));

} //*** end CtIReferenceClock::InitTestClass()


//===========================================================================
// CtIReferenceClock::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IReferenceClock **ppRefClock - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	11/17/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIReferenceClock::GetRealObjPtr(IReferenceClock **ppRefClock)
{

	// validate ppdm
	if(!helpIsValidPtr(ppRefClock, sizeof(IReferenceClock*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppRefClock));

} //*** end CtIReferenceClock::GetRealObjPtr()


//===========================================================================
// CtIReferenceClock::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to QueryInterface
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIReferenceClock::QueryInterface()


//===========================================================================
// CtIReferenceClock::GetTime
//
// Encapsulates calls to GetTime
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to GetTime
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::GetTime(REFERENCE_TIME *pTime)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pTime    = TRUE;

    // validate pTime
    if(!helpIsValidPtr((void*)pTime, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_pTime = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, TEXT("--- Calling %s::GetTime()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("pTime == %p   %s"),
            pTime,
            fValid_pTime ? TEXT("") : TEXT("BAD"));

    // call the real function
    hRes = ((IReferenceClock*)m_pUnk)->GetTime(pTime);

    // log results
    fnsLog(CALLLOGLEVEL, TEXT("--- Returned from %s::GetTime()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes   == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pTime)
    {
        fnsLog(PARAMLOGLEVEL, TEXT("*pTime == %016Xh"),
                *pTime);         
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIReferenceClock::GetTime()


//===========================================================================
// CtIReferenceClock::AdviseTime
//
// Encapsulates calls to AdviseTime
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to AdviseTime
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::AdviseTime(REFERENCE_TIME baseTime,
                                REFERENCE_TIME streamTime,
                                HANDLE hEvent, DWORD *pdwAdviseCookie)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwAdviseCookie  = TRUE;

    // validate pdwAdviseCookie
    if(!helpIsValidPtr((void*)pdwAdviseCookie, sizeof(DWORD), FALSE))
    {
        fValid_pdwAdviseCookie = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, TEXT("--- Calling %s::AdviseTime()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("baseTime        == %016Xh"),
            baseTime);
    fnsLog(PARAMLOGLEVEL, TEXT("streamTime      == %016Xh"),
            streamTime);
    fnsLog(PARAMLOGLEVEL, TEXT("hEvent          == %08Xh"),
            hEvent);
    fnsLog(PARAMLOGLEVEL, TEXT("pdwAdviseCookie == %p   %s"),
            pdwAdviseCookie,
            fValid_pdwAdviseCookie ? TEXT("") : TEXT("BAD"));

    // call the real function
    hRes = ((IReferenceClock*)m_pUnk)->AdviseTime(baseTime, streamTime, hEvent,
                                    pdwAdviseCookie);

    // log results
    fnsLog(CALLLOGLEVEL, TEXT("--- Returned from %s::AdviseTime()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes             == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwAdviseCookie)
    {
	    fnsLog(PARAMLOGLEVEL, TEXT("*pdwAdviseCookie == %08Xh   %s"),
            *pdwAdviseCookie);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIReferenceClock::AdviseTime()


//===========================================================================
// CtIReferenceClock::AdvisePeriodic
//
// Encapsulates calls to AdvisePeriodic
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to AdvisePeriodic
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::AdvisePeriodic(REFERENCE_TIME startTime,
                                    REFERENCE_TIME periodTime,
                                    HANDLE hSemaphore,
                                    DWORD * pdwAdviseCookie)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwAdviseCookie  = TRUE;

    // validate pdwAdviseCookie
    if(!helpIsValidPtr((void*)pdwAdviseCookie, sizeof(DWORD), FALSE))
    {
        fValid_pdwAdviseCookie = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, TEXT("--- Calling %s::AdvisePeriodic()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("startTime       == %016Xh"),
            startTime);
    fnsLog(PARAMLOGLEVEL, TEXT("periodTime      == %016Xh"),
            periodTime);
    fnsLog(PARAMLOGLEVEL, TEXT("hSemaphore      == %08Xh"),
            hSemaphore);
    fnsLog(PARAMLOGLEVEL, TEXT("pdwAdviseCookie == %p   %s"),
            pdwAdviseCookie,
            fValid_pdwAdviseCookie ? TEXT("") : TEXT("BAD"));

    // call the real function
    hRes = ((IReferenceClock*)m_pUnk)->AdvisePeriodic(startTime, periodTime, hSemaphore,
                                    pdwAdviseCookie);

    // log results
    fnsLog(CALLLOGLEVEL, TEXT("--- Returned from %s::AdvisePeriodic()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes             == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwAdviseCookie)
    {
    fnsLog(PARAMLOGLEVEL, TEXT("*pdwAdviseCookie == %08Xh   %s"),
            *pdwAdviseCookie);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIReferenceClock::AdvisePeriodic()


//===========================================================================
// CtIReferenceClock::Unadvise
//
// Encapsulates calls to Unadvise
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to Unadvise
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIReferenceClock::Unadvise(DWORD dwAdviseCookie)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, TEXT("--- Calling %s::Unadvise()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("dwAdviseCookie == %08Xh"),
            dwAdviseCookie);

    // call the real function
    hRes = ((IReferenceClock*)m_pUnk)->Unadvise(dwAdviseCookie);

    // log results
    fnsLog(CALLLOGLEVEL, TEXT("--- Returned from %s::Unadvise()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIReferenceClock::Unadvise()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctcmpos8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctcmpos8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctcmpos8.cpp
//
// Test harness implementation of IDirectMusicComposer8 IUnknown
//
// Functions:
//    CtIDirectMusicComposer8::ComposeSegmentFromTemplateEx() 
//    CtIDirectMusicComposer8::ComposeTemplateFromShapeEx() 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicComposer8::CtIDirectMusicComposer8()
//
// Default constructor
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicComposer8::CtIDirectMusicComposer8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicComposer8";

} // *** end CtIDirectMusicComposer8::CtIDirectMusicComposer8()


//===========================================================================
// CtIDirectMusicComposer8::~CtIDirectMusicComposer8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicComposer8::~CtIDirectMusicComposer8(void)
{
    // nothing to do

} // *** end CtIDirectMusicComposer8::~CtIDirectMusicComposer8()


//===========================================================================
// CtIDirectMusicComposer8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicComposer8 *pdmComposer8 - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicComposer8::InitTestClass(IDirectMusicComposer8 *pdmComposer8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmComposer8, sizeof(IDirectMusicComposer8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmComposer8));

} // *** end CtIDirectMusicComposer8::InitTestClass()


//===========================================================================
// CtIDirectMusicComposer8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicComposer **ppdmComposer8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicComposer8::GetRealObjPtr(IDirectMusicComposer8 **ppdmComposer8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmComposer8, sizeof(IDirectMusicComposer8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmComposer8));

} // *** end CtIDirectMusicComposer8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicComposer8::ComposeSegmentFromTemplateEx()
//
// Encapsulates calls to ComposeSegmentFromTemplateEx
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicComposer8::ComposeSegmentFromTemplateEx
(
	CtIDirectMusicStyle* ptdmStyle,
	CtIDirectMusicSegment* ptdmTempSeg,
	DWORD dwFlags,
	DWORD dwActivity,
	CtIDirectMusicChordMap* ptdmChordMap,
	CtIDirectMusicSegment** pptdmSectionSeg
)
{
    HRESULT                 hRes					= E_NOTIMPL;
	BOOL				    fValid_ptdmStyle		= TRUE;
    BOOL				    fValid_ptdmTempSeg		= TRUE;
	BOOL				    fValid_ptdmChordMap	= TRUE;
	BOOL				    fValid_pptdmSectionSeg	= TRUE;
    IDirectMusicStyle       *pdmStyle               = NULL;
    IDirectMusicSegment     *pdmTempSeg             = NULL;
    IDirectMusicChordMap	*pdmPers                = NULL;
    IDirectMusicSegment     *pdmSectionSeg          = NULL;
    IDirectMusicSegment     **ppdmSectionSeg        = NULL;

    // validate ptdmStyle
    if(!helpIsValidPtr((void*)ptdmStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)ptdmStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmTempSeg
    if(!helpIsValidPtr((void*)ptdmTempSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTempSeg = FALSE;
        pdmTempSeg = (IDirectMusicSegment*)ptdmTempSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTempSeg->GetRealObjPtr(&pdmTempSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmSectionSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:ComposeSegmentFromTemplate().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSectionSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSectionSeg = FALSE;
        ppdmSectionSeg = (IDirectMusicSegment**)pptdmSectionSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSectionSeg = &pdmSectionSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSectionSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeSegmentFromTemplateEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStyle       == %p   %s",
            pdmStyle,
            fValid_ptdmStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pTempSeg     == %p   %s",
            pdmTempSeg,
            fValid_ptdmTempSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwFlags    == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "dwActivity    == %08Xh",
            dwActivity);
    fnsLog(PARAMLOGLEVEL, "pChordMap == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSectionSeg == %p   %s",
            ppdmSectionSeg,
            fValid_pptdmSectionSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer8*)m_pUnk)->ComposeSegmentFromTemplateEx(pdmStyle, pdmTempSeg, 
                                        dwFlags,dwActivity, pdmPers, ppdmSectionSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeSegmentFromTemplateEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSectionSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSectionSeg == %p",
                pdmSectionSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes) && fValid_pptdmSectionSeg && pdmSectionSeg)
    {
        hRes = dmthCreateTestWrappedObject(pdmSectionSeg, pptdmSectionSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_ptdmTempSeg && pdmTempSeg)
    {
        pdmTempSeg->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    if(fValid_pptdmSectionSeg && pdmSectionSeg)
    {
        pdmSectionSeg->Release();
    }
    return hRes;

} // *** end CtIDirectMusicComposer8::ComposeSegmentFromTemplateEx()




//===========================================================================
// CtIDirectMusicComposer8::ComposeTemplateFromShapeEx()
//
// Encapsulates calls to ComposeTemplateFromShapeEx
//
// History:
//  10/14/1999 - kcraven - created
//  04/06/2000 - danhaff - removed as per API change.
//===========================================================================
/*
HRESULT CtIDirectMusicComposer8::ComposeTemplateFromShapeEx
(
	WORD wNumMeasures,
	WORD wShape,
	BOOL fIntro, 
	BOOL fEnd,
    CtIDirectMusicStyle* pStyle, 
	CtIDirectMusicSegment** pptdmTempSeg
)
{        
    HRESULT					hRes				= E_NOTIMPL;
	BOOL					fValid_pStyle		= TRUE;
	BOOL					fValid_pptdmTempSeg	= TRUE;
    IDirectMusicStyle*		pdmStyle			= NULL; 
    IDirectMusicSegment*	pdmTempSeg			= NULL;
    IDirectMusicSegment**	ppdmTempSeg			= NULL;

    // validate ptdmStyle
    if(!helpIsValidPtr((void*)pStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)pStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = pStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmTempSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer::ComposeTemplateFromShape().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmTempSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTempSeg = FALSE;
        ppdmTempSeg = (IDirectMusicSegment**)pptdmTempSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTempSeg = &pdmTempSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmTempSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeTemplateFromShapeEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "wNumMeasures == %04Xh",
            wNumMeasures);
    fnsLog(PARAMLOGLEVEL, "wShape       == %04Xh",
            wShape);
    fnsLog(PARAMLOGLEVEL, "fIntro       == %d",
            fIntro);
    fnsLog(PARAMLOGLEVEL, "fEnd         == %d",
            fEnd);
    fnsLog(PARAMLOGLEVEL, "pStyle       == %p   %s",
            pdmStyle,
            fValid_pStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppTempSeg    == %p   %s",
            ppdmTempSeg,
            fValid_pptdmTempSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer8*)m_pUnk)->ComposeTemplateFromShapeEx(
					wNumMeasures,
					wShape,
					fIntro, 
					fEnd,
					pdmStyle,
					ppdmTempSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeTemplateFromShapeEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmTempSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTempSeg == %p",
                pdmTempSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTempSeg, pptdmTempSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();
END:
    // done
    if(fValid_pStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_pptdmTempSeg && pdmTempSeg)
    {
        pdmTempSeg->Release();
    }
    return hRes;

} // *** end CtIDirectMusicComposer8::ComposeTemplateFromShapeEx()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctcont.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctcont.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctcont.cpp
//
// Test harness implementation of IDirectMusicContainer
//
// Functions:
//  CtIDirectMusicContainer::CtIDirectMusicContainer()
//  CtIDirectMusicContainer::~CtIDirectMusicContainer()
//  CtIDirectMusicContainer::InitTestClass()
//  CtIDirectMusicContainer::GetRealObjPtr()
//  CtIDirectMusicContainer::QueryInterface()
//  CtIDirectMusicContainer::GetParam()
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicContainer::CtIDirectMusicContainer()
//
// Default constructor
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicContainer::CtIDirectMusicContainer(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicContainer";

} //*** end CtIDirectMusicContainer::CtIDirectMusicContainer()


//===========================================================================
// CtIDirectMusicContainer::~CtIDirectMusicContainer()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicContainer::~CtIDirectMusicContainer(void)
{
    // nothing to do

} //*** end CtIDirectMusicContainer::~CtIDirectMusicContainer()


//===========================================================================
// CtIDirectMusicContainer::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicContainer *pdmContainer - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicContainer::InitTestClass(IDirectMusicContainer *pdmContainer)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmContainer, sizeof(IDirectMusicContainer), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmContainer));

} //*** end CtIDirectMusicContainer::InitTestClass()


//===========================================================================
// CtIDirectMusicContainer::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicContainer **ppdmContainer - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicContainer::GetRealObjPtr(IDirectMusicContainer **ppdmContainer)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmContainer, sizeof(IDirectMusicContainer*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmContainer));

} //*** end CtIDirectMusicContainer::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicContainer::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicContainer::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicContainer::QueryInterface()


//===========================================================================
// CtIDirectMusicContainer::EnumObject()
//
// Encapsulates calls to EnumObject
//
// History:
//  10/22/1999 - kcraven - created
//  01/21/2000 - kcraven - modified to use new parameters
//===========================================================================
HRESULT CtIDirectMusicContainer::EnumObject
(
	REFGUID rguidClass,
	DWORD dwIndex, 
	LPDMUS_OBJECTDESC pDesc,
	WCHAR *pwszAlias
)
{
    HRESULT hRes					= E_NOTIMPL;
	BOOL	fValid_pDesc			= TRUE;
    BOOL    fValid_pwszAlias		= TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidClass, szGuid);
    
	// validate pDesc
	if(!helpIsValidPtr(pDesc, sizeof(DMUS_OBJECTDESC), FALSE))
    {
		fValid_pDesc = FALSE;
    }
	// validate pwszAlias
	if(!helpIsValidPtr(pwszAlias, sizeof(WCHAR), FALSE))
    {
		fValid_pwszAlias = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumObject()",
			m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidClass == %s (%s)",
            szGuid, dmthXlatGUID(rguidClass));
	fnsLog(PARAMLOGLEVEL, "dwIndex    == %08Xh",
			dwIndex);
	fnsLog(PARAMLOGLEVEL, "pDesc      == %p   %s",
			pDesc, fValid_pDesc ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "pwszAlias  == %p   %s",
			pwszAlias, fValid_pwszAlias ? "" : "BAD");
	
  // call the real function
    hRes = ((IDirectMusicContainer*)m_pUnk)->EnumObject(
				rguidClass,
				dwIndex, 
				pDesc,
				pwszAlias
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumObject()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicContainer::EnumObject()

//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctcurhlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctcurhlp.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctcurhlp.cpp
//
// Test harness implementation of IDirectMusicMediaParamsCurveHelper
//
// Functions:
//    CtIDirectMusicMediaParamsCurveHelper::CtIDirectMusicMediaParamsCurveHelper()
//    CtIDirectMusicMediaParamsCurveHelper::~CtIDirectMusicMediaParamsCurveHelper()
//    CtIDirectMusicMediaParamsCurveHelper::InitTestClass()
//    CtIDirectMusicMediaParamsCurveHelper::GetRealObjPtr()
//  IUnknown
//    CtIDirectMusicMediaParamsCurveHelper::QueryInterface()
//  DX8
//    CtIDirectMusicMediaParamsCurveHelper::Init()
//    CtIDirectMusicMediaParamsCurveHelper::GetValue()
//    CtIDirectMusicMediaParamsCurveHelper::Clone()
//
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::CtIDirectMusicMediaParamsCurveHelper()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
CtIDirectMusicMediaParamsCurveHelper::CtIDirectMusicMediaParamsCurveHelper()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicMediaParamsCurveHelper";

} //*** end CtIDirectMusicMediaParamsCurveHelper::CtIDirectMusicMediaParamsCurveHelper()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::~CtIDirectMusicMediaParamsCurveHelper()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
CtIDirectMusicMediaParamsCurveHelper::~CtIDirectMusicMediaParamsCurveHelper(void)
{
    // nothing to do

} //*** emd CtIDirectMusicMediaParamsCurveHelper::~CtIDirectMusicMediaParamsCurveHelper()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicMediaParamsCurveHelper object pointer for future use.
//
// Parameters:
//  CtIDirectMusicMediaParamsCurveHelper    *pdmHelper    - pointer to real IDirectMusicMediaParamsCurveHelper object
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::InitTestClass(IDirectMusicMediaParamsCurveHelper *pdmHelper)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmHelper, sizeof(IDirectMusicMediaParamsCurveHelper), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmHelper));

} //*** end CtIDirectMusicMediaParamsCurveHelper::InitTestClass()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicMediaParamsCurveHelper **ppdmHelper - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::GetRealObjPtr(IDirectMusicMediaParamsCurveHelper **ppdmHelper)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmHelper, sizeof(IDirectMusicMediaParamsCurveHelper*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmHelper));

} //*** end CtIDirectMusicMediaParamsCurveHelper::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicMediaParamsCurveHelper::QueryInterface()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::Init()
//
// Encapsulates calls to Init
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::Init
(
	DWORD cParams,
	DMUS_MEDIAPARAM *prgParamInfo
)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL	fValid_prgParamInfo    = TRUE;
    
    // validate prgParamInfo
    if(!helpIsValidPtr((void*)prgParamInfo, sizeof(DMUS_MEDIAPARAM), FALSE))
    {
        fValid_prgParamInfo	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "cParams      == %08Xh",
            cParams);
    fnsLog(PARAMLOGLEVEL, "prgParamInfo == %p   %s",
            prgParamInfo,
            fValid_prgParamInfo ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicMediaParamsCurveHelper*)m_pUnk)->Init(cParams,prgParamInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicMediaParamsCurveHelper::Init()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::GetValue()
//
// Encapsulates calls to GetValue
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::GetValue(DWORD dwParamIndex,REFERENCE_TIME rt,float *pval)
{
    HRESULT	hRes		= E_NOTIMPL;
    BOOL	fValid_pval = TRUE;
    
    // validate pval
    if(!helpIsValidPtr((void*)pval, sizeof(float), FALSE))
    {
        fValid_pval	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetValue()",
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwParamIndex == %08Xh",
            dwParamIndex);
    fnsLog(PARAMLOGLEVEL, "rt           == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "pval         == %p   %s",
            pval,
            fValid_pval? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicMediaParamsCurveHelper*)m_pUnk)->GetValue(dwParamIndex,rt,pval);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetValue()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicMediaParamsCurveHelper::GetValue()




//===========================================================================
// CtIDirectMusicMediaParamsCurveHelper::Clone()
//
// Encapsulates calls to Clone
//
// History:
//  12/01/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicMediaParamsCurveHelper::Clone(CtIDirectMusicMediaParamsCurveHelper **ppCopy)
{
    HRESULT	hRes		= E_NOTIMPL;
    BOOL	fValid_ppCopy	= TRUE;
    IDirectMusicMediaParamsCurveHelper*		pdwCopy		= NULL;
    IDirectMusicMediaParamsCurveHelper**	ppdwCopy	= NULL;
    
    // validate ppCopy
    if(!helpIsValidPtr((void*)ppCopy, sizeof(CtIDirectMusicMediaParamsCurveHelper*),FALSE))
    {
        // bogus pointer, use as such
        fValid_ppCopy = FALSE;
        ppdwCopy = (IDirectMusicMediaParamsCurveHelper**)ppCopy;

    }
    else
    {
        // valid pointer, create a real object
        ppdwCopy = &pdwCopy;

        // just in case we fail, init test object ptr to NULL
        *ppCopy = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppCopy         == %p   %s",
            ppdwCopy,
            fValid_ppCopy? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicMediaParamsCurveHelper*)m_pUnk)->Clone(ppdwCopy);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppCopy)
    {
        fnsLog(PARAMLOGLEVEL, "*ppCopy == %p",
                *ppdwCopy);
		// create the test object
		if(SUCCEEDED(hRes))
		{
			hRes = dmthCreateTestWrappedObject(*ppdwCopy,ppCopy);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
			}
		}
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicMediaParamsCurveHelper::Clone()

//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctdmusi8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       ctdmusi8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctdmusi8.cpp
//
// Test harness implementation of IDirectMusic8
//
// Functions:
//  CtIDirectMusic::CtIDirectMusic8()
//  CtIDirectMusic::~CtIDirectMusic8()
//  CtIDirectMusic::InitTestClass()
//  CtIDirectMusic::GetRealObjPtr()
//  CtIDirectMusic::QueryInterface()
//
// History:
//  10/15/1997 - davidkl - created
//  05/01/2000 - kcraven - converted to dx8
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusic::CtIDirectMusic8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
CtIDirectMusic8::CtIDirectMusic8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusic8";

} // ** emd CtIDirectMusic8::CtIDirectMusic8()


//===========================================================================
// CtIDirectMusic8::~CtIDirectMusic8()
//
// Default destructor
//
// Parameters: none
//
// Returns:
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
CtIDirectMusic8::~CtIDirectMusic8(void)
{
    // nothing to do

} // ** end CtIDirectMusic8::~CtIDirectMusic8()


//===========================================================================
// CtIDirectMusic8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusic8 object pointer for future use.
//
// Parameters:
//  IDirectMusic8    *pdm    - pointer to real IDirectMusic8 object
//
// Returns:
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusic8::InitTestClass(IDirectMusic8 *pdm)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdm, sizeof(IDirectMusic8), FALSE))
	{
        m_pUnk = NULL;
        return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdm));

} // ** end CtIDirectMusic8::InitTestClass()


//===========================================================================
// CtIDirectMusic8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusic8 **ppdm - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusic8::GetRealObjPtr(IDirectMusic8 **ppdm)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdm, sizeof(IDirectMusic8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdm));

} // ** end CtIDirectMusic8::GetRealObjPtr()


//===========================================================================
// CtIDirectMusic8::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusic8::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // done
    return hRes;

} // ** end CtIDirectMusic8::QueryInterface()






//===========================================================================
// CtIDirectMusic8::SetExternalMasterClock
//
// Encapsulates calls to IDirectMusic8::SetExternalMasterClock
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real SetExternalMasterClock
//
// History:
//  05/01/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusic8::SetExternalMasterClock
(
	IReferenceClock* pClock
)
{
    HRESULT         hRes            = E_NOTIMPL;
	BOOL	        fValid_pClock	= TRUE;

    // validate pClock
    if(!helpIsValidPtr((void*)pClock, sizeof(IReferenceClock), FALSE))
    {
        fValid_pClock = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetExternalMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pClock == %p   %s",
            pClock,
            fValid_pClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic8*)m_pUnk)->SetExternalMasterClock(pClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetExternalMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} // ** end CtIDirectMusic8::SetExternalMasterClock()






//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctdlinst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctdlinst.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctdlinst.cpp
//
// Test harness implementation of IDirectMusicDownloadedInstrument
//
// Functions:
//  CtIDirectMusicDownloadedInstrument::CtIDirectMusicDownloadedInstrument()
//  CtIDirectMusicDownloadedInstrument::~CtIDirectMusicDownloadedInstrument()
//  CtIDirectMusicDownloadedInstrument::InitTestClass()
//  CtIDirectMusicDownloadedInstrument::GetRealObjPtr()
//  CtIDirectMusicDownloadedInstrument::QueryInterface()
//
// History:
//  10/24/1997 - davidkl - created
//  11/17/1997 - davidkl - changed to downloadedinstrument
//  03/30/1998 - davidkl - brave new world of inheritance
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicDownloadedInstrument::CtIDirectMusicDownloadedInstrument()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicDownloadedInstrument::CtIDirectMusicDownloadedInstrument()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicDownloadedInstrument";

} //*** end CtIDirectMusicDownloadedInstrument::CtIDirectMusicDownloadedInstrument()


//===========================================================================
// CtIDirectMusicDownloadedInstrument::~CtIDirectMusicDownloadedInstrument
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicDownloadedInstrument::~CtIDirectMusicDownloadedInstrument()
{
    // nothing to do

} //*** end CtIDirectMusicDownloadedInstrument::~CtIDirectMusicDownloadedInstrument()



//===========================================================================
// CtIDirectMusicDownloadedInstrument::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicDownloadedInstrument object pointer for future use.
//
// Parameters:
//  CtIDirectMusicDownloadedInstrument *pdmDlInst - pointer to real object
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//  11/17/1997 - davidkl - changed to DownloadedInstrument class
//===========================================================================
HRESULT CtIDirectMusicDownloadedInstrument::InitTestClass(IDirectMusicDownloadedInstrument *pdmDlInst)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmDlInst, 
                        sizeof(IDirectMusicDownloadedInstrument), 
                        FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmDlInst));

} //*** end CtIDirectMusicDownloadedInstrument::InitTestClass()


//===========================================================================
// CtIDirectMusicDownloadedInstrument::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicDownloadedInstrument **ppdmDlInst - ptr used to return 
//                                                  real object ptr
//
// Returns: HRESULT
//
// History:
//	10/24/1997 - davidkl - created
//  11/17/1997 - davidkl - changed to DownloadedInstrument class
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicDownloadedInstrument::GetRealObjPtr(IDirectMusicDownloadedInstrument **ppdmDlInst)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmDlInst, 
                        sizeof(IDirectMusicDownloadedInstrument*), 
                        FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmDlInst));

} //*** end CtIDirectMusicDownloadedInstrument::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicDownloadedInstrument::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to QueryInterface
//
// History:
//  10/24/1997 - davidkl - created
//  11/17/1997 - davidkl - changed to DownloadedInstrument class
//===========================================================================
HRESULT CtIDirectMusicDownloadedInstrument::QueryInterface(REFIID riid, 
                                                            LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicDownloadedInstrument::QueryInterface()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctcompos.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctcompos.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// tdmobj49.cpp
//
// Test harness implementation of IDirectMusicComposer IUnknown
//
// Functions:
//  CtIDirectMusicComposer::CtIDirectMusicComposer()
//  CtIDirectMusicComposer::~CtIDirectMusicComposer()
//  CtIDirectMusicComposer::InitTestClass()
//  CtIDirectMusicComposer::GetRealObjPtr()
//  CtIDirectMusicComposer::QueryInterface()
//  CtIDirectMusicComposer::ComposeSegmentFromTemplate()
//  CtIDirectMusicComposer::ComposeSegmentFromShape()
//  CtIDirectMusicComposer::AutoTransition()
//  CtIDirectMusicComposer::ComposeTransition()
//  CtIDirectMusicComposer::ComposeTemplateFromShape()
//  CtIDirectMusicComposer::ChangeChordMap()
//
// History:
//  01/02/1998 - a-llucar - created
//  01/15/1998 - a-llucar - added AutoTransition()
//  03/31/1998 - davidkl - inheritance update
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicComposer::CtIDirectMusicComposer()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicComposer::CtIDirectMusicComposer(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicComposer";

} //*** end CtIDirectMusicComposer::CtIDirectMusicComposer()


//===========================================================================
// CtIDirectMusicComposer::~CtIDirectMusicComposer()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicComposer::~CtIDirectMusicComposer(void)
{
    // nothing to do

} //*** end CtIDirectMusicComposer::~CtIDirectMusicComposer()


//===========================================================================
// CtIDirectMusicComposer::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmComposer - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicComposer::InitTestClass(IDirectMusicComposer *pdmComposer)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmComposer, sizeof(IDirectMusicComposer), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmComposer));

} //*** end CtIDirectMusicComposer::InitTestClass()


//===========================================================================
// CtIDirectMusicComposer::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicComposer **ppdmComposer - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicComposer::GetRealObjPtr(IDirectMusicComposer **ppdmComposer)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmComposer, sizeof(IDirectMusicComposer*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmComposer));

} //*** end CtIDirectMusicComposer::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicComposer::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicComposer::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicComposer::QueryInterface


//===========================================================================
// CtIDirectMusicComposer::ComposeSegmentFromTemplate()
//
// Encapsulates calls to ComposeSegmentFromTemplate
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::ComposeSegmentFromTemplate
                                            (CtIDirectMusicStyle* ptdmStyle,
											CtIDirectMusicSegment* ptdmTempSeg,
											WORD wActivity, 
											CtIDirectMusicChordMap* ptdmChordMap,
											CtIDirectMusicSegment** pptdmSectionSeg)
{
    HRESULT                 hRes					= E_NOTIMPL;
	BOOL				    fValid_ptdmStyle		= TRUE;
    BOOL				    fValid_ptdmTempSeg		= TRUE;
	BOOL				    fValid_ptdmChordMap	= TRUE;
	BOOL				    fValid_pptdmSectionSeg	= TRUE;
    IDirectMusicStyle       *pdmStyle               = NULL;
    IDirectMusicSegment     *pdmTempSeg             = NULL;
    IDirectMusicChordMap *pdmPers                = NULL;
    IDirectMusicSegment     *pdmSectionSeg          = NULL;
    IDirectMusicSegment     **ppdmSectionSeg        = NULL;

    // validate ptdmStyle
    if(!helpIsValidPtr((void*)ptdmStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)ptdmStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmTempSeg
    if(!helpIsValidPtr((void*)ptdmTempSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTempSeg = FALSE;
        pdmTempSeg = (IDirectMusicSegment*)ptdmTempSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTempSeg->GetRealObjPtr(&pdmTempSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmSectionSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:ComposeSegmentFromTemplate().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSectionSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSectionSeg = FALSE;
        ppdmSectionSeg = (IDirectMusicSegment**)pptdmSectionSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSectionSeg = &pdmSectionSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSectionSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeSegmentFromTemplate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStyle       == %p   %s",
            pdmStyle,
            fValid_ptdmStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pTempSeg     == %p   %s",
            pdmTempSeg,
            fValid_ptdmTempSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "wActivity    == %04Xh",
            wActivity);
    fnsLog(PARAMLOGLEVEL, "pChordMap == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSectionSeg == %p   %s",
            ppdmSectionSeg,
            fValid_pptdmSectionSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->ComposeSegmentFromTemplate(pdmStyle, pdmTempSeg, 
                                        wActivity, pdmPers, ppdmSectionSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeSegmentFromTemplate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSectionSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSectionSeg == %p",
                pdmSectionSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSectionSeg, pptdmSectionSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_ptdmTempSeg && pdmTempSeg)
    {
        pdmTempSeg->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    if(fValid_pptdmSectionSeg && pdmSectionSeg)
    {
        pdmSectionSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::ComposeSegmentFromTemplate()


//===========================================================================
// CtIDirectMusicComposer::ComposeSegmentFromShape()
//
// Encapsulates calls to ComposeSegmentFromShape
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::ComposeSegmentFromShape
                                    (CtIDirectMusicStyle* ptdmStyle,
									WORD wNumMeasures,
									WORD wShape, WORD wActivity,
									BOOL fIntro, BOOL fEnd,
									CtIDirectMusicChordMap* ptdmChordMap,
									CtIDirectMusicSegment** pptdmSectionSeg)
{
    HRESULT                 hRes					= E_NOTIMPL;
	BOOL				    fValid_ptdmStyle		= TRUE;
	BOOL				    fValid_ptdmChordMap	= TRUE;
	BOOL				    fValid_pptdmSectionSeg	= TRUE;
    IDirectMusicStyle       *pdmStyle               = NULL;
    IDirectMusicChordMap *pdmPers                = NULL;
    IDirectMusicSegment     *pdmSectionSeg          = NULL;
    IDirectMusicSegment     **ppdmSectionSeg        = NULL;

    // validate ptdmStyle
    if(!helpIsValidPtr((void*)ptdmStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)ptdmStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmSectionSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:ComposeSegmentFromShape().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSectionSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSectionSeg = FALSE;
        ppdmSectionSeg = (IDirectMusicSegment**)pptdmSectionSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSectionSeg = &pdmSectionSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSectionSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeSegmentFromShape()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStyle == %p   %s",
            pdmStyle,
            fValid_ptdmStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "wNumMeasures == %04Xh",
            wNumMeasures);
    fnsLog(PARAMLOGLEVEL, "wShape       == %04Xh",
            wShape);
    fnsLog(PARAMLOGLEVEL, "wActivity    == %04Xh",
            wActivity);
    fnsLog(PARAMLOGLEVEL, "fIntro       == %d",
            fIntro);
    fnsLog(PARAMLOGLEVEL, "fEnd         == %d",
            fEnd);
    fnsLog(PARAMLOGLEVEL, "pChordMap == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSectionSeg == %p   %s",
            ppdmSectionSeg,
            fValid_pptdmSectionSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->ComposeSegmentFromShape(pdmStyle, wNumMeasures, 
                                                wShape, wActivity,
												fIntro, fEnd, 
                                                pdmPers, ppdmSectionSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeSegmentFromShape()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSectionSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSectionSeg == %p",
                pdmSectionSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSectionSeg, pptdmSectionSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    if(fValid_pptdmSectionSeg && pdmSectionSeg)
    {
        pdmSectionSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::ComposeSegmentFromShape()


//===========================================================================
// CtIDirectMusicComposer::ComposeTransition()
//
// Encapsulates calls to ComposeTransition
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::ComposeTransition
                                    (CtIDirectMusicSegment* ptdmFromSeg,
									CtIDirectMusicSegment* ptdmToSeg,
									WORD wMeasureNum, WORD wCommand,
									DWORD dwFlags,
									CtIDirectMusicChordMap* ptdmChordMap,
									CtIDirectMusicSegment** pptdmSectionSeg)
{
    HRESULT                 hRes					= E_NOTIMPL;
	BOOL				    fValid_ptdmFromSeg		= TRUE;
	BOOL				    fValid_ptdmToSeg		= TRUE;
	BOOL				    fValid_ptdmChordMap	= TRUE;
	BOOL				    fValid_pptdmSectionSeg	= TRUE;
    IDirectMusicChordMap *pdmPers                = NULL;
    IDirectMusicSegment     *pdmFromSeg             = NULL;
    IDirectMusicSegment     *pdmToSeg               = NULL;
    IDirectMusicSegment     *pdmSectionSeg          = NULL;
    IDirectMusicSegment     **ppdmSectionSeg        = NULL;

    // validate ptdmFromSeg
    if(!helpIsValidPtr((void*)ptdmFromSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmFromSeg = FALSE;
        pdmFromSeg = (IDirectMusicSegment*)ptdmFromSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmFromSeg->GetRealObjPtr(&pdmFromSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmToSeg
    if(!helpIsValidPtr((void*)ptdmToSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmToSeg = FALSE;
        pdmToSeg = (IDirectMusicSegment*)ptdmToSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmToSeg->GetRealObjPtr(&pdmToSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmSectionSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:ComposeTransition().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSectionSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSectionSeg = FALSE;
        ppdmSectionSeg = (IDirectMusicSegment**)pptdmSectionSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSectionSeg = &pdmSectionSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSectionSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeTransition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pFromSeg     == %p   %s",
            pdmFromSeg,
            fValid_ptdmFromSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pToSeg       == %p   %s",
            pdmToSeg,
            fValid_ptdmToSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "wMeasureNum  == %04Xh",
            wMeasureNum);
    fnsLog(PARAMLOGLEVEL, "wCommand     == %04Xh",
            wCommand);
    fnsLog(PARAMLOGLEVEL, "dwFlags      == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "pChordMap == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSectionSeg == %p   %s",
            ppdmSectionSeg,
            fValid_pptdmSectionSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->ComposeTransition(pdmFromSeg, pdmToSeg, 
                                            wMeasureNum, wCommand,
											dwFlags, pdmPers, 
                                            ppdmSectionSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeTransition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSectionSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSectionSeg == %p",
                pdmSectionSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSectionSeg, pptdmSectionSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmFromSeg && pdmFromSeg)
    {
        pdmFromSeg->Release();
    }
    if(fValid_ptdmToSeg && pdmToSeg)
    {
        pdmToSeg->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    if(fValid_pptdmSectionSeg && pdmSectionSeg)
    {
        pdmSectionSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::ComposeTransition()


//===========================================================================
// CtIDirectMusicComposer::AutoTransition()
//
// Encapsulates calls to AutoTransition
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::AutoTransition
                                    (CtIDirectMusicPerformance*	ptdmPerformance,
									CtIDirectMusicSegment* ptdmToSeg, 
									WORD wCommand, DWORD dwFlags, 
									CtIDirectMusicChordMap* ptdmChordMap, 
									CtIDirectMusicSegment** pptdmTransSeg, 
									CtIDirectMusicSegmentState** pptdmToSegState, 
									CtIDirectMusicSegmentState** pptdmTransSegState)
{
    HRESULT                     hRes					    = E_NOTIMPL;
	BOOL				        fValid_ptdmPerformance	    = TRUE;
	BOOL				        fValid_ptdmToSeg		    = TRUE;
	BOOL				        fValid_ptdmChordMap	    = TRUE;
	BOOL                        fValid_pptdmTransSeg        = TRUE;
    BOOL				        fValid_pptdmTransSegState	= TRUE;
	BOOL				        fValid_pptdmToSegState	    = TRUE;
    IDirectMusicPerformance     *pdmPerf                    = NULL;
    IDirectMusicChordMap     *pdmPers                    = NULL;
    IDirectMusicSegment         *pdmToSeg                   = NULL;
    IDirectMusicSegment         *pdmTransSeg                = NULL; 
    IDirectMusicSegment         **ppdmTransSeg              = NULL;
    IDirectMusicSegmentState    *pdmToSegSt                 = NULL;
    IDirectMusicSegmentState    **ppdmToSegSt               = NULL;
    IDirectMusicSegmentState    *pdmTransSegSt              = NULL;
    IDirectMusicSegmentState    **ppdmTransSegSt            = NULL;

    // validate ptdmPerformance
    if(!helpIsValidPtr((void*)ptdmPerformance, 
                    sizeof(CtIDirectMusicPerformance), FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerformance = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerformance;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerformance->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmToSeg
    if(!helpIsValidPtr((void*)ptdmToSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmToSeg = FALSE;
        pdmToSeg = (IDirectMusicSegment*)ptdmToSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmToSeg->GetRealObjPtr(&pdmToSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pptdmTransSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:AutoTransition().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmTransSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTransSeg = FALSE;
        ppdmTransSeg = (IDirectMusicSegment**)pptdmTransSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTransSeg = &pdmTransSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmTransSeg = NULL;
    }

    // validate pptdmToSegState
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegmentState pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:AutoTransition().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegmentState object
    if(!helpIsValidPtr((void*)pptdmToSegState, 
                    sizeof(CtIDirectMusicSegmentState*), TRUE))
    {
        // bogus pointer, use as such
        fValid_pptdmToSegState = FALSE;
        ppdmToSegSt = (IDirectMusicSegmentState**)pptdmToSegState;

    }
    else
    {
        if(pptdmToSegState)
		{
			// valid pointer, create a real object
			ppdmToSegSt = &pdmToSegSt;
		}
		else
		{
	        ppdmToSegSt = (IDirectMusicSegmentState**)pptdmToSegState;
		}

        // just in case we fail, init test object ptr to NULL
        if (pptdmToSegState) *pptdmToSegState = NULL;
    }

    // validate pptdmTransSegState
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegmentState pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer:AutoTransition().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegmentState object
    if(!helpIsValidPtr((void*)pptdmTransSegState, 
                    sizeof(CtIDirectMusicSegmentState*), TRUE))
    {
        // bogus pointer, use as such
        fValid_pptdmTransSegState = FALSE;
        ppdmTransSegSt = (IDirectMusicSegmentState**)pptdmTransSegState;

    }
    else
    {
		if(pptdmTransSegState)
		{
			// valid pointer, create a real object
			ppdmTransSegSt = &pdmTransSegSt;
		}
		else
		{
	        ppdmTransSegSt = (IDirectMusicSegmentState**)pptdmTransSegState;
		}
        // just in case we fail, init test object ptr to NULL
        if (pptdmTransSegState) *pptdmTransSegState = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AutoTransition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerformance    == %p   %s",
            pdmPerf,
            fValid_ptdmPerformance ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pToSeg          == %p   %s",
            pdmToSeg,
            fValid_ptdmToSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "wCommand        == %04Xh",
            wCommand);
    fnsLog(PARAMLOGLEVEL, "dwFlags         == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "pChordMap    == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppTransSeg      == %p   %s",
            ppdmTransSeg,
            fValid_pptdmTransSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppToSegState    == %p   %s",
            ppdmToSegSt,
            fValid_pptdmToSegState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppTransSegState == %p   %s",
            ppdmTransSegSt,
            fValid_pptdmTransSegState ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->AutoTransition(pdmPerf, pdmToSeg, wCommand,
                                    dwFlags, pdmPers, ppdmTransSeg, 
                                    ppdmToSegSt, ppdmTransSegSt);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AutoTransition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes             == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmTransSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTransSeg      == %p",
            pdmTransSeg);
    }
    if(fValid_pptdmToSegState)
    {
        fnsLog(PARAMLOGLEVEL, "*ppToSegState    == %p",
                pdmToSegSt);
    }
    if(fValid_pptdmTransSegState)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTransSegState == %p",
                pdmTransSegSt);
    }

    // create test objects
    // NOTE: if we fail to create any object, we will not attempt 
    //  any further object creation
    // UGH - do this better soon....
    if(SUCCEEDED(hRes) && pptdmTransSeg && pdmTransSeg)
    {
        hRes = dmthCreateTestWrappedObject(pdmTransSeg, pptdmTransSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    if(SUCCEEDED(hRes) && pptdmToSegState && pdmToSegSt)
    {
        hRes = dmthCreateTestWrappedObject(pdmToSegSt, pptdmToSegState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
  //      else
 //       {
            // cleanup previously created objects
//            if(pptdmTransSeg)
//            {
//                (*pptdmTransSeg)->Release();
//                *pptdmTransSeg = NULL;
//            }
 //       }
    }

    if(SUCCEEDED(hRes) && pptdmTransSegState && pdmTransSegSt)
    {
        hRes = dmthCreateTestWrappedObject(pdmTransSegSt, pptdmTransSegState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
 //       else
 //       {
            // cleanup previously created objects
			//BUGBUG - removed by Lou because we have an invalid test that's incorrectly returning
			//S_OK, and this is causing a GPF.  It seems it should be released in the actual test, not 
			// the wrapper.
//            if(pptdmTransSeg)
//            {
//              (*pptdmTransSeg)->Release();
//              *pptdmTransSeg = NULL;
//            }
//            if(pptdmToSegState)
//            {
//              (*pptdmToSegState)->Release();
//              *pptdmToSegState = NULL;
//            }
 //       }
    }
    
    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerformance && pdmPerf)
    {
        pdmPerf->Release();
    }
    if(fValid_ptdmToSeg && pdmToSeg)
    {
        pdmToSeg->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    if(fValid_pptdmTransSeg && pdmTransSeg)
    {
        pdmTransSeg->Release();
    }
    if(fValid_pptdmToSegState && pdmToSegSt)
    {
        pdmToSegSt->Release();
    }
    if(fValid_pptdmTransSegState && pdmTransSegSt)
    {
        pdmTransSegSt->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::AutoTransition()


//===========================================================================
// CtIDirectMusicComposer::ComposeTemplateFromShape()
//
// Encapsulates calls to ComposeTemplateFromShape
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::ComposeTemplateFromShape
                                        (WORD wNumMeasures,
										WORD wShape,
										BOOL fIntro, BOOL fEnd,
										WORD wEndLength,
										CtIDirectMusicSegment** pptdmTempSeg)
{        
    HRESULT             hRes				= E_NOTIMPL;
	BOOL				fValid_pptdmTempSeg	= TRUE;
    IDirectMusicSegment *pdmTempSeg         = NULL;
    IDirectMusicSegment **ppdmTempSeg       = NULL;

    // validate pptdmTempSeg
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicComposer::ComposeTemplateFromShape().  
    //  Otherwise, we are to create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmTempSeg, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTempSeg = FALSE;
        ppdmTempSeg = (IDirectMusicSegment**)pptdmTempSeg;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTempSeg = &pdmTempSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmTempSeg = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeTemplateFromShape()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "wNumMeasures == %04Xh",
            wNumMeasures);
    fnsLog(PARAMLOGLEVEL, "wShape       == %04Xh",
            wShape);
    fnsLog(PARAMLOGLEVEL, "fIntro       == %d",
            fIntro);
    fnsLog(PARAMLOGLEVEL, "fEnd         == %d",
            fEnd);
    fnsLog(PARAMLOGLEVEL, "wEndLength   == %04Xh",
            wEndLength);
    fnsLog(PARAMLOGLEVEL, "ppTempSeg    == %p   %s",
            ppdmTempSeg,
            fValid_pptdmTempSeg ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->ComposeTemplateFromShape(wNumMeasures, wShape, 
                                                    fIntro, fEnd,
													wEndLength, ppdmTempSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeTemplateFromShape()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmTempSeg)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTempSeg == %p",
                pdmTempSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTempSeg, pptdmTempSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmTempSeg && pdmTempSeg)
    {
        pdmTempSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::ComposeTemplateFromShape()


//===========================================================================
// CtIDirectMusicComposer::ChangeChordMap()
//
// Encapsulates calls to ChangeChordMap
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicComposer::ChangeChordMap
                                        (CtIDirectMusicSegment* ptdmSectionSeg,
										BOOL fTrackScale, 
										CtIDirectMusicChordMap* ptdmChordMap)
{
    HRESULT                 hRes					= E_NOTIMPL;
	BOOL				    fValid_ptdmSectionSeg	= TRUE;
	BOOL				    fValid_ptdmChordMap	= TRUE;
    IDirectMusicSegment     *pdmSectionSeg          = NULL;
    IDirectMusicChordMap *pdmPers                = NULL;

    // validate ptdmSectionSeg
    if(!helpIsValidPtr((void*)ptdmSectionSeg, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmSectionSeg = FALSE;
        pdmSectionSeg = (IDirectMusicSegment*)ptdmSectionSeg;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSectionSeg->GetRealObjPtr(&pdmSectionSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmChordMap
    if(!helpIsValidPtr((void*)ptdmChordMap, sizeof(CtIDirectMusicChordMap), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmChordMap = FALSE;
        pdmPers = (IDirectMusicChordMap*)ptdmChordMap;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmChordMap->GetRealObjPtr(&pdmPers);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ChangeChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSectionSeg  == %p   %s",
            pdmSectionSeg,
            fValid_ptdmSectionSeg ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fTrackScale  == %d",
            fTrackScale);
    fnsLog(PARAMLOGLEVEL, "pChordMap == %p   %s",
            pdmPers,
            fValid_ptdmChordMap ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicComposer*)m_pUnk)->ChangeChordMap(pdmSectionSeg, 
                                            fTrackScale, 
                                            pdmPers);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ChangeChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSectionSeg && pdmSectionSeg)
    {
        pdmSectionSeg->Release();
    }
    if(fValid_ptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    return hRes;

} //*** end CtIDirectMusicComposer::ChangeChordMap()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctdnload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctdnload.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctdnload.cpp
//
// Test harness implementation of IDirectMusicDownload
//
// Functions:
//  CtIDirectMusicDownload::CtIDirectMusicDownload()
//  CtIDirectMusicDownload::~CtIDirectMusicDownload()
//  CtIDirectMusicDownload::InitTestClass()
//  CtIDirectMusicDownload::GetRealObjPtr()
//  CtIDirectMusicDownload::GetId()
//
// History:
//  01/13/1998 - a-llucar - created
//  01/13/1998 - a-llucar - removed GetBuffer()
//  03/30/1998 - davidkl - brave new world of inheritance
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicDownload::CtIDirectMusicDownload()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/13/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicDownload::CtIDirectMusicDownload()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicDownload";

} //*** end CtIDirectMusicDownload::CtIDirectMusicDownload()


//===========================================================================
// CtIDirectMusicDownload::~CtIDirectMusicDownload()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/13/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicDownload::~CtIDirectMusicDownload()
{
    // nothing to do

} //*** emd CtIDirectMusicDownload::~CtIDirectMusicDownload()


//===========================================================================
// CtIDirectMusicDownload::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicDownload object pointer for future use.
//
// Parameters:
//  IDirectMusicDownload *pdmDownload - pointer to real object
//
// Returns: 
//
// History:
//  01/13/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicDownload::InitTestClass(IDirectMusicDownload *pdmDownload)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmDownload, sizeof(IDirectMusicDownload), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmDownload));

} //*** end CtIDirectMusicDownload::InitTestClass()


//===========================================================================
// CtIDirectMusicDownload::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicDownload **ppdmDownload - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	01/13/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicDownload::GetRealObjPtr(IDirectMusicDownload **ppdmDownload)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmDownload, sizeof(IDirectMusicDownload*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmDownload));

} //*** end CtIDirectMusicDownload::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicDownload::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to QueryInterface
//
// History:
//  01/13/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicDownload::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicDownload::QueryInterface()


//===========================================================================
// CtIDirectMusicDownload::GetBuffer
//
// Encapsulates calls to GetBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetBuffer
//
// History:
//  01/13/1998 - a-llucar - created
//  03/03/1998 - davidkl - added parameter validation and fixed logging bugs
//===========================================================================
HRESULT CtIDirectMusicDownload::GetBuffer(void** ppvBuffer, DWORD* dwSize)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_ppvBuffer    = TRUE;
    BOOL    fValid_dwSize		= TRUE;

    // validate dwSize
    if(!helpIsValidPtr(ppvBuffer, 1, FALSE))
    {
        fValid_ppvBuffer = FALSE;
    }

    // validate dwSize
    if(!helpIsValidPtr(dwSize, sizeof(DWORD), FALSE))
    {
        fValid_dwSize = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppvBuffer == %p   %s",
            ppvBuffer,
            (fValid_ppvBuffer) ? "" : "BAD");
    // NOTE: dwSize is really a *
    fnsLog(PARAMLOGLEVEL, "dwSize    == %08Xh   %s",
            dwSize,
            fValid_dwSize ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicDownload*)m_pUnk)->GetBuffer(ppvBuffer, dwSize);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes   == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppvBuffer)
    {
        // BUGBUG log returned ppvBuffer data (@ MAXLOGLEVEL)
        // in banks of bytes like so:
        // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    }
    if(fValid_dwSize)
    {
        // NOTE: dwSize is really a *
        fnsLog(PARAMLOGLEVEL, "*dwSize == %08Xh",
                *dwSize);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicDownload::GetBuffer()




//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctdmusic.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctdmusic.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctdmusic.cpp
//
// Test harness implementation of IDirectMusic
//
// Functions:
//  CtIDirectMusic::CtIDirectMusic()
//  CtIDirectMusic::~CtIDirectMusic()
//  CtIDirectMusic::InitTestClass()
//  CtIDirectMusic::GetRealObjPtr()
//  CtIDirectMusic::QueryInterface()
//  CtIDirectMusic::EnumPort()
//  CtIDirectMusic::CreateMusicBuffer()
//  CtIDirectMusic::CreatePort()
//  CtIDirectMusic::EnumMasterClock()
//  CtIDirectMusic::GetMasterClock()
//  CtIDirectMusic::SetMasterClock()
//  CtIDirectMusic::Activate()
//  CtIDirectMusic::GetDefaultPort()
//  CtIDirectMusic::SetDirectSound
//
// History:
//  10/15/1997 - davidkl - created
//  12/22/1997 - bthomas and a-llucar - added methods to CtIDirectMusic
//  12/23/1997 - a-llucar - added methods to CtIDirectMusic
//	01/19/1998 - a-llucar - latest Core changes fixed
//  02/25/1998 - davidkl - removed AllocateEventClass and FreeEventClass.
//                          added CreatePort
//  03/02/1998 - davidkl - ported to latest dmusic architecture changes
//  04/01/1998 - davidkl - a little maintenance
//	07/22/1998 - a-trevg - removed GetPortProperty
//  08/21/1998 - davidkl - added SetDirectSound()
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusic::CtIDirectMusic()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/15/1997 - davidkl - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//===========================================================================
CtIDirectMusic::CtIDirectMusic(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusic";

} //*** emd CtIDirectMusic::CtIDirectMusic()


//===========================================================================
// CtIDirectMusic::~CtIDirectMusic()
//
// Default destructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/15/1997 - davidkl - created
//===========================================================================
CtIDirectMusic::~CtIDirectMusic(void)
{
    // nothing to do

} //*** end CtIDirectMusic::~CtIDirectMusic()


//===========================================================================
// CtIDirectMusic::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusic object pointer for future use.
//
// Parameters:
//  IDirectMusic    *pdm    - pointer to real IDirectMusic object
//
// Returns:
//
// History:
//  10/16/1997 - davidkl - created
//  03/18/1998 - davidkl - reimplemented as overloaded version
//===========================================================================
HRESULT CtIDirectMusic::InitTestClass(IDirectMusic *pdm)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdm, sizeof(IDirectMusic), FALSE))
	{
        m_pUnk = NULL;
        return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdm));

} //*** end CtIDirectMusic::InitTestClass()


//===========================================================================
// CtIDirectMusic::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusic **ppdm - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	10/16/1997 - davidkl - created
//  10/17/1997 - davidkl - cleaned up
//  1/15/98 - bthomas - made it more COM-like
//  03/18/1998 - davidkl - reimplemented as overloaded version
//===========================================================================
HRESULT CtIDirectMusic::GetRealObjPtr(IDirectMusic **ppdm)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdm, sizeof(IDirectMusic*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdm));

} //*** end CtIDirectMusic::GetRealObjPtr()


//===========================================================================
// CtIDirectMusic::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/16/1997 - davidkl - created
//  03/18/1998 - davidkl - reimplemented as replacement version
//===========================================================================
HRESULT CtIDirectMusic::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusic::QueryInterface()


//===========================================================================
// CtIDirectMusic::EnumPort
//
// Encapsulates calls to IDirectMusic::EnumPort
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real EnumPort
//
// History:
//  10/16/1997 - davidkl - created
//  12/04/1997 - davidkl - realized I forgot to implement this
//  12/23/1997 - a-llucar - updating to latest dmusic.h
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  04/01/1998 - davidkl - fixed param validation bug
//===========================================================================
HRESULT CtIDirectMusic::EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps)
{
    HRESULT                 hRes                    = E_NOTIMPL;
	BOOL					fValid_lpPortCaps		= TRUE;

    // validate lpPortCaps
    if(!helpIsValidPtr(lpPortCaps, sizeof(DMUS_PORTCAPS), FALSE))
    {
        fValid_lpPortCaps = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumPort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIdx      == %08Xh",
            dwIdx);
    fnsLog(PARAMLOGLEVEL, "lpPortCaps == %p   %s",
            lpPortCaps,
            fValid_lpPortCaps ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->EnumPort(dwIdx, lpPortCaps);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumPort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_lpPortCaps)
    {
        tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL, lpPortCaps);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::EnumPort()


//===========================================================================
// CtIDirectMusic::CreateMusicBuffer
//
// Encapsulates calls to IDirectMusic::CreateMusicBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real CreateMusicBuffer
//
// History:
//  10/16/1997 - davidkl - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  03/25/1998 - davidkl - fixed refcounting bug, simplified obj creation
//===========================================================================
HRESULT CtIDirectMusic::CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc,
                                    CtIDirectMusicBuffer **pptdmBuffer,
                                    IUnknown *punk)
{
    HRESULT             hRes                = E_NOTIMPL;
    IDirectMusicBuffer  *pdmBuf             = NULL;
    IDirectMusicBuffer  **ppdmBuf           = NULL;
    BOOL                fValid_punk         = TRUE;
    BOOL                fValid_pptdmBuffer  = TRUE;
	BOOL				fValid_pBufferDesc	= TRUE;

	// validate pBufferDesc
    if(!helpIsValidPtr(pBufferDesc, sizeof(DMUS_BUFFERDESC), FALSE))
    {
        fValid_pBufferDesc = FALSE;
    }

	// validate punk
    // NOTE: NULL is valid for this parameter.  It indicates that aggregation
    //  is not desired.
    if(!helpIsValidPtr(punk, sizeof(IUnknown), TRUE))
    {
        fValid_punk = FALSE;
    }

    // validate pptdmBuffer
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicBuffer pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusic::CreateMusicBuffer().  Otherwise, we are to create and
    //  return a CtIDirectMusicBuffer object
    if(!helpIsValidPtr((void*)pptdmBuffer, sizeof(CtIDirectMusicBuffer*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmBuffer = FALSE;
        ppdmBuf = (IDirectMusicBuffer**)pptdmBuffer;

    }
    else
    {
        // valid pointer, create a real object
        ppdmBuf = &pdmBuf;

        // just in case we fail, init test object ptr to NULL
        *pptdmBuffer = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreateMusicBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pBufferDesc == %p   %s",
            pBufferDesc,
			fValid_pBufferDesc ? "" : "BAD");
    // BUGBUG log pBufferDesc contents (if valid) @ level MAXLOGLEVEL
    fnsLog(PARAMLOGLEVEL, "ppdmBuffer  == %p   %s",
            ppdmBuf,
            fValid_pptdmBuffer ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "punk        == %p   %s",
            punk,
            fValid_punk ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->CreateMusicBuffer(pBufferDesc, ppdmBuf, punk);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CreateMusicBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmBuffer)
    {
        fnsLog(PARAMLOGLEVEL, "*ppdmBuffer == %p",
                pdmBuf);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmBuf, pptdmBuffer);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmBuffer && pdmBuf)
    {
        pdmBuf->Release();
    }
    return hRes;

} //*** end CtIDirectMusic::CreateMusicBuffer()


//===========================================================================
// CtIDirectMusic::CreatePort
//
// Encapsulates calls to IDirectMusic::CreatePort
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real CreatePort
//
// History:
//  02/25/1998 - davidkl - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  03/25/1998 - davidkl - fixed refcounting bug, simplified obj creation
//  04/01/1998 - davidkl - fixed param validation, enhanced GUID logging
//  08/21/1998 - davidkl - removed rguidSink
//===========================================================================
HRESULT CtIDirectMusic::CreatePort(REFGUID rguidPort,
                                   LPDMUS_PORTPARAMS pPortParams,
                                   CtIDirectMusicPort **pptdmPort,
                                   IUnknown *punk)
{
	HRESULT				hRes						= E_NOTIMPL;
	IDirectMusicPort    *pdmPort					= NULL;
    IDirectMusicPort    **ppdmPort					= NULL;
    BOOL                fValid_punk					= TRUE;
    BOOL                fValid_pPortParams			= TRUE;
	BOOL				fValid_pptdmPort			= TRUE;
    char                szguidPort[MAX_LOGSTRING];
	HRESULT				hResCreate					= E_FAIL;

	// validate pPortParams
    // NOTE: NULL is ok here... be careful later in the fn!
    if(!helpIsValidPtr(pPortParams, sizeof(DMUS_PORTPARAMS), TRUE))
    {
        fValid_pPortParams = FALSE;
    }

	// validate punk
    if(!helpIsValidPtr(punk, sizeof(IUnknown), TRUE))
    {
        fValid_punk = FALSE;
    }

    // validate pptdmPort
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicPort pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusic::CreatePort().  Otherwise, we are to create and
    //  return a CtIDirectMusic object
    if(!helpIsValidPtr((void*)pptdmPort, sizeof(CtIDirectMusicPort*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmPort = FALSE;
        ppdmPort = (IDirectMusicPort**)pptdmPort;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPort = &pdmPort;

        // just in case we fail, init test object ptr to NULL
        *pptdmPort = NULL;
    }

    // convert GUIDs to readable strings
    tdmGUIDtoString(rguidPort, szguidPort);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreatePort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidPort   == %s (%s)",
            szguidPort, tdmXlatGUID(rguidPort));
    fnsLog(PARAMLOGLEVEL, "pPortParams == %p   %s",
            pPortParams,
            fValid_pPortParams ? "" : "BAD");
    if(fValid_pPortParams && pPortParams)
    {
        // log pPortParams contents
        tdmLogDMUS_PORTPARAMS(STRUCTLOGLEVEL, pPortParams);
    }
    fnsLog(PARAMLOGLEVEL, "ppdmPort    == %p   %s",
            ppdmPort,
            fValid_pptdmPort ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "punk        == %p   %s",
            punk,
            fValid_punk ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->CreatePort(rguidPort, 
                                            pPortParams, 
                                            ppdmPort, 
                                            punk);

    // log results
    fnsLog(PARAMLOGLEVEL, "--- Returned from %s::CreatePort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmPort)
    {
        fnsLog(CALLLOGLEVEL, "*ppdmPort == %p",
                pdmPort);
    }
    if(fValid_pPortParams && pPortParams)
    {
        // log pPortParams contents
        tdmLogDMUS_PORTPARAMS(STRUCTLOGLEVEL, pPortParams);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hResCreate = dmthCreateTestWrappedObject(pdmPort, pptdmPort);
        if(FAILED(hResCreate))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hResCreate);
			hRes = hResCreate;
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmPort && pdmPort)
    {
        pdmPort->Release();
    }
    return hRes;

} //*** end CtIDirectMusic::CreatePort()




//===========================================================================
// CtIDirectMusic::EnumMasterClock
//
// Encapsulates calls to IDirectMusic::EnumMasterClock
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real EnumMasterClock
//
// History:
//  12/22/1997 - bthomas and a-llucar - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  04/01/1998 - davidkl - fixed param validation
//===========================================================================
HRESULT CtIDirectMusic::EnumMasterClock(DWORD dwIdx, LPDMUS_CLOCKINFO lpClockCaps)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_lpClockCaps		= TRUE;

    // validate lpClockCaps
    if(!helpIsValidPtr(lpClockCaps, sizeof(DMUS_CLOCKINFO), FALSE))
    {
        fValid_lpClockCaps = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIdx       == %08Xh",
            dwIdx);
    fnsLog(PARAMLOGLEVEL, "lpClockCaps == %p",
            lpClockCaps);

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->EnumMasterClock(dwIdx, lpClockCaps);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_lpClockCaps)
    {
        // BUGBUG log lpClockCaps contents @ level STRUCTLOGLEVEL
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::EnumMasterClock()


//===========================================================================
// CtIDirectMusic::GetMasterClock
//
// Encapsulates calls to IDirectMusic::GetMasterClock
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real GetMasterClock
//
// History:
//  12/23/1997 - a-llucar - created
//  03/06/1998 - now uses wrapper classes, enhanced logging
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  04/01/1998 - davidkl - enhanced GUID logging
//===========================================================================
HRESULT CtIDirectMusic::GetMasterClock(GUID *guidClock,
									   CtIReferenceClock **pptReferenceClock)
{
    HRESULT         hRes                        = E_NOTIMPL;
    BOOL            fValid_guidClock		    = TRUE;
	BOOL	        fValid_pptReferenceClock	= TRUE;
    char            szGuid[MAX_LOGSTRING];
    IReferenceClock *pRefClock                  = NULL;
    IReferenceClock **ppRefClock                = NULL;

    // validate guidClock
    // guidClock is allowed to be NULL! be careful here!!
    if(!helpIsValidPtr(guidClock, sizeof(GUID), TRUE))
    {
        fValid_guidClock = FALSE;
    }

    // validate pptReferenceClock
    // NOTE:
    //	If we are passed an invalid CtIReferenceClock pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusic:GetMasterClock().  
    //  Otherwise, we are to create and return a CtIReferenceClock object
    if(!helpIsValidPtr((void*)pptReferenceClock, sizeof(CtIReferenceClock*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptReferenceClock = FALSE;
        ppRefClock = (IReferenceClock**)pptReferenceClock;

    }
    else
    {
        // valid pointer, create a real object
        ppRefClock = &pRefClock;

        // just in case we fail, init test object ptr to NULL
        *pptReferenceClock = NULL;
    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "guidClock        == %p   %s",
            // NOTE: guidClock is really a *
            guidClock,
            fValid_guidClock ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppReferenceClock == %p   %s",
            ppRefClock,
            (fValid_pptReferenceClock) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->GetMasterClock(guidClock, ppRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes              == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(SUCCEEDED(hRes))
    {
        if(fValid_guidClock && guidClock) 
        {
            tdmGUIDtoString(*guidClock, szGuid);
            fnsLog(PARAMLOGLEVEL, "*guidClock        == %s (%s)",
                szGuid, tdmXlatGUID(*guidClock));
        }
        if(fValid_pptReferenceClock)
        {
            fnsLog(PARAMLOGLEVEL, "*ppReferenceClock == %p",
                *pRefClock);
        }
    }

    // create the test object
    if(SUCCEEDED(hRes) && fValid_pptReferenceClock)
    {
        hRes = dmthCreateTestWrappedObject(pRefClock, pptReferenceClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptReferenceClock && pRefClock)
    {
        pRefClock->Release();

    }
    return hRes;

} //*** end CtIDirectMusic::GetMasterClock()


//===========================================================================
// CtIDirectMusic::SetMasterClock
//
// Encapsulates calls to IDirectMusic::SetMasterClock
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real SetMasterClock
//
// History:
//  12/23/1997 - a-llucar - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  04/01/1998 - davidkl - enhanced GUID logging
//===========================================================================
HRESULT CtIDirectMusic::SetMasterClock(REFGUID guidClock)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_guidClock		= TRUE;
    char    szGuid[MAX_LOGSTRING];

	tdmGUIDtoString(guidClock, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "guidClock == %s (%s)",
            szGuid, tdmXlatGUID(guidClock));

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->SetMasterClock(guidClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::SetMasterClock()


//===========================================================================
// CtIDirectMusic::Activate
//
// Encapsulates calls to IDirectMusic::Activate
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real Activate
//
// History:
//  12/23/1997 - a-llucar - created
//  03/18/1998 - davidkl - now inherits from CtIUnknown
//  04/01/1998 - davidkl - enhanced logging
//  08/21/1998 - davidkl - removed hWnd
//===========================================================================
HRESULT CtIDirectMusic::Activate(BOOL fEnable)
{
    HRESULT hRes                    = E_NOTIMPL;

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "fEnable == %s",
            fEnable ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->Activate(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::Activate()


//===========================================================================
// CtIDirectMusic::GetDefaultPort
//
// Encapsulates calls to IDirectMusic::GetDefaultPort
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real GetDefaultPort
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusic::GetDefaultPort(GUID *pguidPort)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_pguidPort    = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pguidPort
    if(!helpIsValidPtr((void*)pguidPort, sizeof(GUID), FALSE))
    {
        fValid_pguidPort = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDefaultPort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pguidPort == %p   %s",
            pguidPort,
            fValid_pguidPort ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->GetDefaultPort(pguidPort);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDefaultPort()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pguidPort)
    {
        tdmGUIDtoString(*pguidPort, szGuid);
        fnsLog(PARAMLOGLEVEL, "*pguidPort == %s (%s)",
                szGuid, tdmXlatGUID(*pguidPort));
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::GetDefaultPort()



//===========================================================================
// CtIDirectMusic::SetDirectSound
//
// Encapsulates calls to IDirectMusic::SetDirectSound
//
// Parameters:
//
// Returns:
//  HRESULT - return code from the real SetDirectSound
//
// History:
//  08/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusic::SetDirectSound(LPDIRECTSOUND pDirectSound,
                                        HWND hWnd)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_pDirectSound =TRUE;

    // validate lpPortCaps
    if(!helpIsValidPtr(pDirectSound, sizeof(IDirectSound), TRUE))
    {
        fValid_pDirectSound = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetDirectSound()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDirectSound == %p   %s",
            pDirectSound,
            fValid_pDirectSound ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "hWnd         == %08Xh",
            hWnd);

    // call the real function
    hRes = ((IDirectMusic*)m_pUnk)->SetDirectSound(pDirectSound, hWnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetDirectSound()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusic::SetDirectSound()


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctDSWave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctDSWave.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsegst8.cpp
//
// Test harness implementation of IDirectSoundWave
//
// Functions:
//    IUnknown
//      CtIDirectSoundWave::QueryInterface()
//      CtIDirectSoundWave::AddRef()
//      CtIDirectSoundWave::Release()
//
//    IDirectSoundWave
//      CtIDirectSoundWave::CreateSource
//      CtIDirectSoundWave::GetFormat
//      CtIDirectSoundWave::GetWaveArticulation
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectSoundWave::CtIDirectSoundWave()
//
// Default constructor
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
CtIDirectSoundWave::CtIDirectSoundWave(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectSoundWave";

} // *** end CtIDirectSoundWave::CtIDirectSoundWave()


//===========================================================================
// CtIDirectSoundWave::~CtIDirectSoundWave()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
CtIDirectSoundWave::~CtIDirectSoundWave(void)
{
    // nothing to do

} // *** end CtIDirectSoundWave::~CtIDirectSoundWave()


//===========================================================================
// CtIDirectSoundWave::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectSoundWave *pDirectSoundWave- pointer to real IDirectSoundWave object
//
// Returns:
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
HRESULT CtIDirectSoundWave::InitTestClass(IDirectSoundWave *pDirectSoundWave)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pDirectSoundWave, sizeof(IDirectSoundWave), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pDirectSoundWave));

} // *** end CtIDirectSoundWave::InitTestClass()



//===========================================================================
// CtIDirectSoundWave::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectSoundWave **ppDirectSoundWave- ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
HRESULT CtIDirectSoundWave::GetRealObjPtr(IDirectSoundWave **ppDirectSoundWave)
{

	// validate ppdm
	if(!helpIsValidPtr(ppDirectSoundWave, sizeof(IDirectSoundWave*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppDirectSoundWave));

} // *** end CtIDirectSoundWave::GetRealObjPtr()


//===========================================================================
// CtIDirectSoundWave::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
HRESULT CtIDirectSoundWave::QueryInterface(REFIID riid,
                                            LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    
    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} // *** end CtIDirectMusicSegmentState8::QueryInterface




//===========================================================================
// CtIDirectSoundWave::GetFormat
//
// Encapsulates calls to GetFormat
//
// Parameters:
//    pWfx:
//          holds the returned waveformat.
//    pcbSize:
//          if pWfx NULL, pcbSize will contain the # of bytes needed
//    to hold the wave format on return.  If not NULL, the value in
//    pcbSize should be set to the size of the pWfx buffer before
//    calling this function.
//
// Returns:
//  HRESULT - return code from actual call to GetFormat
//
// History:
//  02/23/00 - danhaff - created
//  03/29/00 - kcraven - mangled to be in sync
//===========================================================================
HRESULT CtIDirectSoundWave::GetFormat
(
	LPWAVEFORMATEX pwfxFormat, 
	DWORD dwSizeAllocated, 
	LPDWORD pdwSizeWritten
)
//BUGBUG
//PHOOPHOO
//HRESULT CtIDirectSoundWave::GetFormat
//(
//    OUT LPWAVEFORMATEX  pWfx,
//    OUT LPDWORD         pcbSize
//)
{
    HRESULT	hRes			= E_FAIL;
    BOOL fValid_pWfx        = TRUE;
//    BOOL fValid_dwSizeAlloc     = TRUE;
    BOOL fValid_pcbSizeWritt     = TRUE;


    fnsIncrementIndent();

    // validate pWfx - we can only guarantee that it is the size of
    //  a PCMWAVEFORMAT (16) w/o checking wFormatTag.
    if(!helpIsValidPtr((void*)pwfxFormat, sizeof(PCMWAVEFORMAT), FALSE))
        fValid_pWfx = FALSE;
//    if(!helpIsValidPtr((void*)dwSizeAllocated, sizeof(DWORD), FALSE))
//        fValid_dwSizeAlloc = FALSE;
    if(!helpIsValidPtr((void*)pdwSizeWritten, sizeof(DWORD), FALSE))
        fValid_pcbSizeWritt = FALSE;

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL,     "pwfxFormat       == %08Xh %s", pwfxFormat,    fValid_pWfx    ? "" : "(BAD)");
//    fnsLog(PARAMLOGLEVEL, "dwSizeAllocated  == %08Xh %s", dwSizeAllocated, fValid_dwSizeAlloc ? "" : "(BAD)");
    fnsLog(PARAMLOGLEVEL,     "dwSizeAllocated  == %08Xh", dwSizeAllocated);
    fnsLog(PARAMLOGLEVEL,     "pdwSizeWritten   == %08Xh %s", pdwSizeWritten, fValid_pcbSizeWritt ? "" : "(BAD)");
  //  if (fValid_dwSizeAlloc)
  //      fnsLog(PARAMLOGLEVEL, "*dwSizeAllocated  == %08Xh", *dwSizeAllocated);
    if (fValid_pcbSizeWritt)
        fnsLog(PARAMLOGLEVEL, "*pdwSizeWritten  == %08Xh", *pdwSizeWritten);
        

    // call the real function
    hRes = ((IDirectSoundWave*)m_pUnk)->GetFormat(pwfxFormat, dwSizeAllocated, pdwSizeWritten);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    
    if (fValid_pWfx)
        dmthLogWAVEFORMATEX(PARAMLOGLEVEL, pwfxFormat);
//    if (fValid_dwSizeAlloc)
//        fnsLog(PARAMLOGLEVEL, "*dwSizeAllocated  == %08Xh", *dwSizeAllocated);
    if (fValid_pcbSizeWritt)
        fnsLog(PARAMLOGLEVEL, "*pdwSizeWritten  == %08Xh", *pdwSizeWritten);

    fnsDecrementIndent();
    return hRes;

} // *** end CtIDirectSoundWave::GetFormat()




//===========================================================================
// CtIDirectSoundWave::CreateSource
//
// Encapsulates calls to CreateSource
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to CreateSource
//
// History:
//  02/23/00 - danhaff - created
//===========================================================================
HRESULT CtIDirectSoundWave::CreateSource
(
    OUT IDirectSoundSource **ppSource,
    IN  LPWAVEFORMATEX pWfx,
    DWORD dwFlags
)
{
    HRESULT	hRes			= E_FAIL;
    BOOL fValid_pWfx        = TRUE;
    BOOL fValid_ppSource    = TRUE;

    fnsIncrementIndent();

    // validate pWfx - we can only guarantee that it is the size of
    //  a PCMWAVEFORMAT (16) w/o checking wFormatTag.
    if(!helpIsValidPtr((void*)pWfx, sizeof(PCMWAVEFORMAT), FALSE))
        fValid_pWfx = FALSE;

    //validate ppSource.
    if(!helpIsValidPtr((void*)ppSource, sizeof(IDirectSoundSource *), FALSE))
        fValid_ppSource= FALSE;


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreateSource()",
            m_szInterfaceName);

    fnsLog(PARAMLOGLEVEL, "ppSource == %08Xh %s", ppSource, fValid_ppSource ? "" : "(BAD)");
    fnsLog(PARAMLOGLEVEL, "pWfx     == %08Xh %s", pWfx,     fValid_pWfx     ? "" : "(BAD)");
    if (fValid_pWfx)
        dmthLogWAVEFORMATEX(PARAMLOGLEVEL, pWfx);
    fnsLog(PARAMLOGLEVEL, "dwFlags  == %08Xh", dwFlags);
        

    // call the real function
    hRes = ((IDirectSoundWave*)m_pUnk)->CreateSource(ppSource, pWfx, dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CreateSource()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    
    if (fValid_ppSource)
        fnsLog(PARAMLOGLEVEL, "*ppSource  == %08Xh", *ppSource);
    fnsDecrementIndent();


    return hRes;

} // *** end CtIDirectSoundWave::GetFormat()



//===========================================================================
// CtIDirectSoundWave::GetWaveArticulation
//
// Encapsulates calls to GetWaveArticulation
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetWaveArticulation
//
// History:
//  02/23/00 - danhaff - created
//  03/29/00 - danhaff - commented out - it's removed from API.
//  03/29/00 - kcraven - removed --- mee too -- mee merged
//===========================================================================
/*
HRESULT CtIDirectSoundWave::GetWaveArticulation
(
    OUT LPDMUS_WAVEART pArticulation
)
{
    HRESULT	hRes			= E_FAIL;
    BOOL fValid_pArticulation = TRUE;


    fnsIncrementIndent();

    // validate params.
    if(!helpIsValidPtr((void*)pArticulation, sizeof(DMUS_WAVEART), FALSE))
        fValid_pArticulation= FALSE;


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreateSource()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pArticulation == %08Xh %s", pArticulation, fValid_pArticulation ? "" : "(BAD)");
        

    // call the real function
    hRes = ((IDirectSoundWave*)m_pUnk)->GetWaveArticulation(pArticulation);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CreateSource()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    
    
    if (fValid_pArticulation)
        dmthLogDMUS_WAVEART(PARAMLOGLEVEL, pArticulation);

    fnsDecrementIndent();
    return hRes;

} // *** end CtIDirectSoundWave::GetFormat()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctenvmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctenvmgr.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctenvmgr.cpp
//
// Test harness implementation of IDirectMusicEnvelopeManager
//
// Functions:
//    CtIDirectMusicEnvelopeManager::CtIDirectMusicEnvelopeManager()
//    CtIDirectMusicEnvelopeManager::~CtIDirectMusicEnvelopeManager()
//    CtIDirectMusicEnvelopeManager::InitTestClass()
//    CtIDirectMusicEnvelopeManager::GetRealObjPtr()
//  IUnknown
//    CtIDirectMusicEnvelopeManager::QueryInterface()
//  DX8
//    CtIDirectMusicEnvelopeManager::Init()
//    CtIDirectMusicEnvelopeManager::GetValue()
//
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicEnvelopeManager::CtIDirectMusicEnvelopeManager()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
CtIDirectMusicEnvelopeManager::CtIDirectMusicEnvelopeManager()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicEnvelopeManager";

} //*** end CtIDirectMusicEnvelopeManager::CtIDirectMusicEnvelopeManager()




//===========================================================================
// CtIDirectMusicEnvelopeManager::~CtIDirectMusicEnvelopeManager()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
CtIDirectMusicEnvelopeManager::~CtIDirectMusicEnvelopeManager(void)
{
    // nothing to do

} //*** emd CtIDirectMusicEnvelopeManager::~CtIDirectMusicEnvelopeManager()




//===========================================================================
// CtIDirectMusicEnvelopeManager::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicEnvelopeManager object pointer for future use.
//
// Parameters:
//  CtIDirectMusicEnvelopeManager    *pdmManager    - pointer to real IDirectMusicEnvelopeManager object
//
// Returns: 
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicEnvelopeManager::InitTestClass(IDirectMusicEnvelopeManager *pdmManager)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmManager, sizeof(IDirectMusicEnvelopeManager), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmManager));

} //*** end CtIDirectMusicEnvelopeManager::InitTestClass()




//===========================================================================
// CtIDirectMusicEnvelopeManager::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicEnvelopeManager **ppdmManager - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicEnvelopeManager::GetRealObjPtr(IDirectMusicEnvelopeManager **ppdmManager)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmManager, sizeof(IDirectMusicEnvelopeManager*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmManager));

} //*** end CtIDirectMusicEnvelopeManager::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicEnvelopeManager::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicEnvelopeManager::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicEnvelopeManager::QueryInterface()




//===========================================================================
// CtIDirectMusicEnvelopeManager::Init()
//
// Encapsulates calls to Init
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicEnvelopeManager::Init(DWORD dwNumParams)
{
    HRESULT     hRes						= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwNumParams  == %08Xh",
            dwNumParams);
    
    // call the real function
    hRes = ((IDirectMusicEnvelopeManager*)m_pUnk)->Init(dwNumParams);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicEnvelopeManager::Init()




//===========================================================================
// CtIDirectMusicEnvelopeManager::GetValue()
//
// Encapsulates calls to GetValue
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicEnvelopeManager::GetValue
(
	DWORD dwIndex,
	REFERENCE_TIME refTime,
	long *pValue, 
	REFERENCE_TIME *prefNextPoint
)
{
    HRESULT	hRes					= E_NOTIMPL;
    BOOL	fValid_pValue			= TRUE;
    BOOL	fValid_prefNextPoint	= TRUE;
    
    // validate pValue
    if(!helpIsValidPtr((void*)pValue, sizeof(long), FALSE))
    {
        fValid_pValue	= FALSE;
    }

    // validate prefNextPoint
    if(!helpIsValidPtr((void*)prefNextPoint, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prefNextPoint	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetValue()",
            m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwIndex       == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "refTime       == %016Xh",
            refTime);
    fnsLog(PARAMLOGLEVEL, "pValue        == %p   %s",
            pValue,
            fValid_pValue? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "prefNextPoint == %p   %s",
            prefNextPoint,
            fValid_prefNextPoint? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicEnvelopeManager*)m_pUnk)->GetValue(dwIndex,refTime,pValue,prefNextPoint);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetValue()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicEnvelopeManager::Stop()


//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctgetldr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctgetldr.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctgetldr.cpp
//
// Test harness implementation of IDirectMusicGetLoader
//
// Functions:
//  CtIDirectMusicGetLoader::CtIDirectMusicGetLoader()
//  CtIDirectMusicGetLoader::~CtIDirectMusicGetLoader()
//  CtIDirectMusicGetLoader::InitTestClass()
//  CtIDirectMusicGetLoader::GetRealObjPtr()
//  CtIDirectMusicGetLoader::QueryInterface()
//  CtIDirectMusicGetLoader::GetLoader()
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//---------------------------------------------------------------------------

//===========================================================================
// CtIDirectMusicGetLoader::CtIDirectMusicGetLoader()
//
// Default constructor
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
CtIDirectMusicGetLoader::CtIDirectMusicGetLoader(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicGetLoader";

} //*** end CtIDirectMusicGetLoader::CtIDirectMusicGetLoader()


//===========================================================================
// CtIDirectMusicGetLoader::~CtIDirectMusicGetLoader()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
CtIDirectMusicGetLoader::~CtIDirectMusicGetLoader(void)
{
    // nothing to do

} //*** end CtIDirectMusicGetLoader::~CtIDirectMusicGetLoader()


//===========================================================================
// CtIDirectMusicLoader::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmLoader - pointer to real object
//
// Returns: 
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGetLoader::InitTestClass(IDirectMusicGetLoader *pGetLdr)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pGetLdr, sizeof(IDirectMusicGetLoader), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pGetLdr));

} //*** end CtIDirectMusicGetLoader::InitTestClass()


//===========================================================================
// CtIDirectMusicGetLoader::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicGetLoader **ppGetLdr - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGetLoader::GetRealObjPtr(IDirectMusicGetLoader **ppGetLdr)
{

	// validate ppdm
	if(!helpIsValidPtr(ppGetLdr, sizeof(IDirectMusicGetLoader*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppGetLdr));

} //*** end CtIDirectMusicGetLoader::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicGetLoader::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGetLoader::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicGetLoader::QueryInterface


//===========================================================================
// CtIDirectMusicGetLoader::GetLoader()
//
// Encapsulates calls to GetLoader()
//
// History:
//  04/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGetLoader::GetLoader(CtIDirectMusicLoader **pptdmLoader)
{
    HRESULT             hRes                = E_NOTIMPL;
    IDirectMusicLoader  *pLoader            = NULL;
    IDirectMusicLoader  **ppLoader          = NULL;
    BOOL                fValid_pptdmLoader  = TRUE;

	// validate pptdmLoader
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicLoader pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicGetLoader::GetLoader().  Otherwise, we are to create and
    //  return a CtIDirectLoader object
    if(!helpIsValidPtr((void*)pptdmLoader, sizeof(CtIDirectMusicLoader*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmLoader = FALSE;
        ppLoader = (IDirectMusicLoader**)pptdmLoader;
    }
    else
    {
        // valid pointer, create a real object
        ppLoader = &pLoader;

        // just in case we fail, init test object ptr to NULL
        *ppLoader = NULL;
    }

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLoader()", 
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppLoader == %p   %s",
			ppLoader,
			fValid_pptdmLoader ? "" : "BAD");

	// Get a real IDirectMusicObject
	hRes = ((IDirectMusicGetLoader*)m_pUnk)->GetLoader(ppLoader);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLoader()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
			tdmXlatHRESULT(hRes), hRes);
	if(fValid_pptdmLoader)
	{
        fnsLog(PARAMLOGLEVEL, "*ppLoader == %p",
				pLoader);
	}
    
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pLoader, pptdmLoader);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

	fnsDecrementIndent();

    // done
    if(fValid_pptdmLoader && pLoader)
    {
        pLoader->Release();
    }
    return hRes;

} //*** end CtIDirectMusicGetLoader::GetLoader()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctgraph.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctgraph.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctgraph.cpp
//
// Test harness implementation of IDirectMusicGraph
//
// Functions:
//  CtIDirectMusicGraph::CtIDirectMusicGraph()
//  CtIDirectMusicGraph::~CtIDirectMusicGraph()
//  CtIDirectMusicGraph::InitTestClass()
//  CtIDirectMusicGraph::GetRealObjPtr()
//  CtIDirectMusicGraph::QueryInterface()
//  CtIDirectMusicGraph::StampPMsg()
//  CtIDirectMusicGraph::InsertTool()
//  CtIDirectMusicGraph::GetTool()
//  CtIDirectMusicGraph::RemoveTool()
//
// History:
//  01/02/1998 - a-llucar - created
//  02/11/1998 - a-llucar - added InsertTool(), Shutdown() 
//  03/31/1998 - davidkl - inheritance update
//  09/26/1998 - a-llucar - removed Shutdown()
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicGraph::CtIDirectMusicGraph()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicGraph::CtIDirectMusicGraph(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicGraph";

} //*** end CtIDirectMusicGraph::CtIDirectMusicGraph()


//===========================================================================
// CtIDirectMusicGraph::~CtIDirectMusicGraph()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicGraph::~CtIDirectMusicGraph(void)
{
    // nothing to do

} //*** end CtIDirectMusicGraph::~CtIDirectMusicGraph()


//===========================================================================
// CtIDirectMusicGraph::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmGraph - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicGraph::InitTestClass(IDirectMusicGraph *pdmGraph)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmGraph, sizeof(IDirectMusicGraph), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmGraph));

} //*** end CtIDirectMusicGraph::InitTestClass()


//===========================================================================
// CtIDirectMusicGraph::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicGraph **ppdmGraph - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicGraph::GetRealObjPtr(IDirectMusicGraph **ppdmGraph)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmGraph, sizeof(IDirectMusicGraph*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmGraph));

} //*** end CtIDirectMusicGraph::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicGraph::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicGraph::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicGraph::QueryInterface


//===========================================================================
// CtIDirectMusicGraph::StampPMsg()
//
// Encapsulates calls to StampPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicGraph::StampPMsg(DMUS_PMSG* pPMSG)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_pPMSG    = TRUE;
    
    // validate pPipelineEvent
    if(!helpIsValidPtr((void*)pPMSG, sizeof(DMUS_PMSG), FALSE))
    {
        fValid_pPMSG	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::StampPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }

    // call the real function
    hRes = ((IDirectMusicGraph*)m_pUnk)->StampPMsg(pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::StampPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicGraph::StampPMsg()


//===========================================================================
// CtIDirectMusicGraph::InsertTool()
//
// Encapsulates calls to InsertTool
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicGraph::InsertTool(CtIDirectMusicTool* ptdmTool,
									    DWORD* pdwPChannels, 
                                        DWORD cPChannel,
										LONG lIndex)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL				fValid_ptdmTool		= TRUE;
    BOOL				fValid_pdwPChannels	= TRUE;
    IDirectMusicTool    *pdmTool            = NULL;

    // validate ptdmTool
    if(!helpIsValidPtr((void*)ptdmTool, sizeof(CtIDirectMusicTool), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTool = FALSE;
        pdmTool = (IDirectMusicTool*)ptdmTool;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTool->GetRealObjPtr(&pdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pdwPChannels
    if(!helpIsValidPtr((void*)pdwPChannels, sizeof(DWORD), FALSE))
    {
        fValid_pdwPChannels	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::InsertTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTool        == %p   %s",
            pdmTool,
            fValid_ptdmTool ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwPChannels == %p   %s",
            pdwPChannels,
            fValid_pdwPChannels ? "" : "BAD");
    if(fValid_pdwPChannels)
    {
        // BUGBUG log contents of pdwPChannels array @ MAXLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "cPChannel    == %08Xh",
            cPChannel);
    fnsLog(PARAMLOGLEVEL, "lIndex       == %08Xh",
            lIndex);

    // call the real function
    hRes = ((IDirectMusicGraph*)m_pUnk)->InsertTool(pdmTool, pdwPChannels, 
                                cPChannel, lIndex);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::InsertTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmTool && pdmTool)
    {
        pdmTool->Release();
    }    
    return hRes;

}
//*** end CtIDirectMusicGraph::InsertTool()


//===========================================================================
// CtIDirectMusicGraph::GetTool()
//
// Encapsulates calls to GetTool
//
// History:
//  04/03/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGraph::GetTool(DWORD dwIndex, 
                                    CtIDirectMusicTool **pptdmTool)
{
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_pptdmTool    = TRUE;
    IDirectMusicTool    *pdmTool            = NULL;
    IDirectMusicTool    **ppdmTool          = NULL;

    //validate pptdmTool
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicTool pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicGraph::GetTool().  Otherwise, we are to create and
    //  return a CtIDirectMusicTool object
    if(!helpIsValidPtr((void*)pptdmTool, sizeof(CtIDirectMusicTool*),
        FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTool = FALSE;
        ppdmTool = (IDirectMusicTool**)pptdmTool;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTool = &pdmTool;

        // just in case we fail, init test object ptr to NULL
        *pptdmTool = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "ppTool  == %p   %s",
            ppdmTool,
            fValid_pptdmTool ? "" : "BAD");

    // call the real thing
    hRes = ((IDirectMusicGraph*)m_pUnk)->GetTool(dwIndex, ppdmTool);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(pptdmTool)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTool == %08Xh",
                pdmTool);
    }

    //create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTool, pptdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    //done
    if(fValid_pptdmTool && pdmTool)
    {
        pdmTool->Release();
    }
    return hRes;

} //*** end CtIDirectMusicGraph::GetTool()


//===========================================================================
// CtIDirectMusicGraph::RemoveTool()
//
// Encapsulates calls to RemoveTool
//
// History:
//  04/03/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicGraph::RemoveTool(CtIDirectMusicTool *ptdmTool)
{
    HRESULT             hRes            = E_NOTIMPL;
    BOOL                fValid_ptdmTool = TRUE;
    IDirectMusicTool    *pdmTool        = NULL;

    // validate ptdmTool
    if(!helpIsValidPtr((void*)ptdmTool, sizeof(CtIDirectMusicTool), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmTool = FALSE;
        pdmTool = (IDirectMusicTool*)ptdmTool;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmTool->GetRealObjPtr(&pdmTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::RemoveTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTool == %p   %s",
            pdmTool,
            fValid_ptdmTool ? "" : "BAD");

    // call the real thing
    hRes = ((IDirectMusicGraph*)m_pUnk)->RemoveTool(pdmTool);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::RemoveTool()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    //done
END:
    if(fValid_ptdmTool && pdmTool)
    {
        pdmTool->Release();
    }
    return hRes;

} //*** end CtIDirectMusicGraph::RemoveTool()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctksprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctksprop.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctksprop.cpp
//
// Test harness implementation of IKsPropertySet
//
// Functions:
//  CtIKsPropertySet::CtIKsPropertySet()
//  CtIKsPropertySet::~CtIKsPropertySet()
//  CtIKsPropertySet::InitTestClass()
//  CtIKsPropertySet::GetRealObjPtr()
//  CtIKsPropertySet::QueryInterface()
//  CtIKsPropertySet::Set()
//  CtIKsPropertySet::Get()
//  CtIKsPropertySet::QuerySupported()
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIKsPropertySet::CtIKsPropertySet
//
// Default constructor
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
CtIKsPropertySet::CtIKsPropertySet(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IKsPropertySet";
    
} //*** end CtIKsPropertySet::CtIKsPropertySet()


//===========================================================================
// CtIKsPropertySet::~CtIKsPropertySet
//
// Default destructor
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
CtIKsPropertySet::~CtIKsPropertySet(void)
{
    // nothing to do
        
} //*** end CtIKsPropertySet::~CtIKsPropertySet()


//===========================================================================
// CtIKsPropertySet::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IKsPropertySet pointer for future use.
//
// Parameters:
//  IKsPropertySet *pPropSet - pointer to real object
//
// Returns: 
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::InitTestClass(IKsPropertySet *pPropSet)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pPropSet, sizeof(IKsPropertySet), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pPropSet));

} //*** end CtIKsPropertySet::InitTestClass()


//===========================================================================
// CtIKsPropertySet::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IKsPropertySet **ppPropSet - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::GetRealObjPtr(IKsPropertySet **ppPropSet)
{
	// validate ppdm
	if(!helpIsValidPtr(ppPropSet, sizeof(IKsPropertySet*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppPropSet));

} //*** end CtIKsPropertySet::GetRealObjPtr()


//===========================================================================
// CtIKsPropertySet::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIKsPropertySet::QueryInterface


//===========================================================================
// CtIKsPropertySet::Set
//
// Encapsulates calls to Set
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::Set(REFGUID  rguidPropSet,
                                ULONG    ulId,
                                LPVOID   pInstanceData,
                                ULONG    ulInstanceLength,
                                LPVOID   pPropertyData,
                                ULONG    ulDataLength)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pInstanceData    = TRUE;
    BOOL    fValid_pPropertyData    = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pInstanceData
    if(!helpIsValidPtr(pInstanceData, ulInstanceLength, FALSE))
    {
        fValid_pInstanceData = FALSE;
    }

    // validate pPropertyData
    if(!helpIsValidPtr(pPropertyData, ulDataLength, FALSE))
    {
        fValid_pInstanceData = FALSE;
    }

    fnsIncrementIndent();

    tdmGUIDtoString(rguidPropSet, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Set()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidPropSet     == %s (%s)",
            szGuid, tdmXlatGUID(rguidPropSet));
    fnsLog(PARAMLOGLEVEL, "ulId             == %08Xh",
            ulId);
    fnsLog(PARAMLOGLEVEL, "pInstanceData    == %p   %s",
            pInstanceData,
            fValid_pInstanceData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ulInstanceLength == %08Xh",
            ulInstanceLength);
    fnsLog(PARAMLOGLEVEL, "pPropertyData    == %p   %s",
            pPropertyData,
            fValid_pPropertyData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ulDataLength     == %08Xh",
            ulDataLength);
    if(fValid_pInstanceData)
    {
        // BUGBUG log instance data as a string of bytes
        // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    }
    if(fValid_pPropertyData)
    {
        // BUGBUG log property data as a string of bytes
        // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    }

    // call the real function
    hRes = ((IKsPropertySet*)m_pUnk)->Set(rguidPropSet,
                                        ulId,
                                        pInstanceData,
                                        ulInstanceLength,
                                        pPropertyData,
                                        ulDataLength);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Set()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIKsPropertySet::Set()


//===========================================================================
// CtIKsPropertySet::Get
//
// Encapsulates calls to Get
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::Get(REFGUID  rguidPropSet,
                        ULONG    ulId,
                        LPVOID   pInstanceData,
                        ULONG    ulInstanceLength,
                        LPVOID   pPropertyData,
                        ULONG    ulDataLength,
                        ULONG*   pulBytesReturned)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pInstanceData    = TRUE;
    BOOL    fValid_pPropertyData    = TRUE;
    BOOL    fValid_pulBytesReturned = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pInstanceData
    if(!helpIsValidPtr(pInstanceData, ulInstanceLength, FALSE))
    {
        fValid_pInstanceData = FALSE;
    }

    // validate pPropertyData
    if(!helpIsValidPtr(pPropertyData, ulDataLength, FALSE))
    {
        fValid_pInstanceData = FALSE;
    }

    // validate pPropertyData
    if(!helpIsValidPtr(pulBytesReturned, sizeof(ULONG), FALSE))
    {
        fValid_pulBytesReturned = FALSE;
    }

    fnsIncrementIndent();

    tdmGUIDtoString(rguidPropSet, szGuid);

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Get()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidPropSet     == %s (%s)",
            szGuid, tdmXlatGUID(rguidPropSet));
    fnsLog(PARAMLOGLEVEL, "ulId             == %08Xh",
            ulId);
    fnsLog(PARAMLOGLEVEL, "pInstanceData    == %p   %s",
            pInstanceData,
            fValid_pInstanceData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ulInstanceLength == %08Xh",
            ulInstanceLength);
    fnsLog(PARAMLOGLEVEL, "pPropertyData    == %p   %s",
            pPropertyData,
            fValid_pPropertyData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ulDataLength     == %08Xh",
            ulDataLength);
    fnsLog(PARAMLOGLEVEL, "pulBytesReturned == %p   %s",
            pulBytesReturned,
            fValid_pulBytesReturned ? "" : "BAD");
    if(fValid_pInstanceData)
    {
        // BUGBUG log instance data as a string of bytes
        // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    }

    // call the real function
    hRes = ((IKsPropertySet*)m_pUnk)->Get(rguidPropSet,
                                        ulId,
                                        pInstanceData,
                                        ulInstanceLength,
                                        pPropertyData,
                                        ulDataLength,
                                        pulBytesReturned);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Get()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes              == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pPropertyData)
    {
        // BUGBUG log property data as a string of bytes
        // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    }
    if(fValid_pulBytesReturned)
    {
        fnsLog(PARAMLOGLEVEL, "*pulBytesReturned == %08Xh   %s",
                *pulBytesReturned);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIKsPropertySet::Get()


//===========================================================================
// CtIKsPropertySet::QuerySupported
//
// Encapsulates calls to QuerySupported
//
// History:
//  03/27/1998 - davidkl - created
//===========================================================================
HRESULT CtIKsPropertySet::QuerySupported(REFGUID  rguidPropSet,
                                          ULONG    ulId,
                                          ULONG*   pulTypeSupport)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pulTypeSupport   = TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pulTypeSupport
    if(!helpIsValidPtr((void*)pulTypeSupport, sizeof(ULONG), FALSE))
    {
        fValid_pulTypeSupport = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::QuerySupported()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidPropSet   == %s (%s)",
            szGuid, tdmXlatGUID(rguidPropSet));
    fnsLog(PARAMLOGLEVEL, "ulId           == %08Xh",
            ulId);
    fnsLog(PARAMLOGLEVEL, "pulTypeSupport == %p   %s",
            pulTypeSupport,
            fValid_pulTypeSupport ? "" : "BAD");

    // call the real function
    hRes = ((IKsPropertySet*)m_pUnk)->QuerySupported(rguidPropSet, 
                                                    ulId,
                                                    pulTypeSupport);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::QuerySupported()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pulTypeSupport)
    {
        fnsLog(PARAMLOGLEVEL, "*pulTypeSupport == %08Xh",
                *pulTypeSupport);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIKsPropertySet::QuerySupported()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctpattrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctpattrk.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctpattrk.cpp
//
// Test harness implementation of IDirectMusicPatternTrack
//
// Functions:
//  CtIDirectMusicPatternTrack::CtIDirectMusicPatternTrack()
//  CtIDirectMusicPatternTrack::~CtIDirectMusicPatternTrack()
//  CtIDirectMusicPatternTrack::InitTestClass()
//  CtIDirectMusicPatternTrack::GetRealObjPtr()
//  CtIDirectMusicPatternTrack::QueryInterface()
// IDirectMusicPatternTrack methods
//  CtIDirectMusicPatternTrack::CreateSegment()
//  CtIDirectMusicPatternTrack::etVariation()
//  CtIDirectMusicPatternTrack::SetPatternByName()
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicPatternTrack::CtIDirectMusicPatternTrack()
//
// Default constructor
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPatternTrack::CtIDirectMusicPatternTrack(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicPatternTrack";

} //*** end CtIDirectMusicPatternTrack::CtIDirectMusicPatternTrack()


//===========================================================================
// CtIDirectMusicPatternTrack::~CtIDirectMusicPatternTrack()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPatternTrack::~CtIDirectMusicPatternTrack(void)
{
    // nothing to do

} //*** end CtIDirectMusicPatternTrack::~CtIDirectMusicPatternTrack()


//===========================================================================
// CtIDirectMusicPatternTrack::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPatternTrack *pdmPatternTrack - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::InitTestClass(IDirectMusicPatternTrack *pdmPatternTrack)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmPatternTrack, sizeof(IDirectMusicPatternTrack), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmPatternTrack));

} //*** end CtIDirectMusicPatternTrack::InitTestClass()


//===========================================================================
// CtIDirectMusicPatternTrack::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicPatternTrack **ppdmPatternTrack - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::GetRealObjPtr(IDirectMusicPatternTrack **ppdmPatternTrack)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmPatternTrack, sizeof(IDirectMusicPatternTrack*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmPatternTrack));

} //*** end CtIDirectMusicPatternTrack::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicPatternTrack::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicPatternTrack::QueryInterface()




//===========================================================================
// CtIDirectMusicPatternTrack::CreateSegment()
//
// Encapsulates calls to CreateSegment
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::CreateSegment
(
	CtIDirectMusicStyle* pStyle,
	CtIDirectMusicSegment** ppSegment
)
{        
    HRESULT					hRes				= E_NOTIMPL;
	BOOL					fValid_pStyle		= TRUE;
	BOOL					fValid_ppSegment	= TRUE;
    IDirectMusicStyle*		pdmStyle			= NULL; 
    IDirectMusicSegment*	pdmSegment			= NULL;
    IDirectMusicSegment**	ppdmSegment			= NULL;

    // validate pStyle
    if(!helpIsValidPtr((void*)pStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)pStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = pStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppSegment
    if(!helpIsValidPtr((void*)ppSegment, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppSegment = FALSE;
        ppdmSegment = (IDirectMusicSegment**)ppSegment;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSegment = &pdmSegment;

        // just in case we fail, init test object ptr to NULL
        *ppSegment = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::CreateSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStyle       == %p   %s",
            pdmStyle,
            fValid_pStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSegment    == %p   %s",
            ppdmSegment,
            fValid_ppSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPatternTrack*)m_pUnk)->CreateSegment(
				pdmStyle,
				ppdmSegment
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::CreateSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
                pdmSegment);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSegment, ppSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();
END:
    // done
    if(fValid_pStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_ppSegment && pdmSegment)
    {
        pdmSegment->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPatternTrack::CreateSegment()





//===========================================================================
// CtIDirectMusicPatternTrack::SetVariation()
//
// Encapsulates calls to SetVariation
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::SetVariation
(
	CtIDirectMusicSegmentState* pSegState,
	DWORD dwVariationFlags,
	DWORD dwPart
)
{        
    HRESULT						hRes				= E_NOTIMPL;
	BOOL						fValid_pSegState	= TRUE;
    IDirectMusicSegmentState*	pdmSegState			= NULL; 

    // validate pSegState
    if(!helpIsValidPtr((void*)pSegState, sizeof(CtIDirectMusicSegmentState), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pSegState = FALSE;
        pdmSegState = (IDirectMusicSegmentState*)pSegState;

    }
    else
    {
        // good pointer, get the real object
        hRes = pSegState->GetRealObjPtr(&pdmSegState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVariation()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSegState        == %p   %s",
            pdmSegState,
            fValid_pSegState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwVariationFlags == %08Xh",
            dwVariationFlags);
    fnsLog(PARAMLOGLEVEL, "dwPart         == %08Xh",
            dwPart);

    // call the real function
    hRes = ((IDirectMusicPatternTrack*)m_pUnk)->SetVariation(pdmSegState,dwVariationFlags,dwPart);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVariation()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();
END:
    // done
    if(fValid_pSegState && pdmSegState)
    {
        pdmSegState->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPatternTrack::SetVariation()




//===========================================================================
// CtIDirectMusicPatternTrack::SetPatternByName()
//
// Encapsulates calls to SetPatternByName
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPatternTrack::SetPatternByName
(
	CtIDirectMusicSegmentState* pSegState,
	WCHAR* wszName,
	CtIDirectMusicStyle* pStyle,
	DWORD dwPatternType,
	DWORD* pdwLength
)
{        
    HRESULT						hRes				= E_NOTIMPL;
	BOOL						fValid_pSegState	= TRUE;
    BOOL						fValid_wszName		= TRUE;
	BOOL						fValid_pStyle		= TRUE;
    BOOL						fValid_pdwLength	= TRUE;
    IDirectMusicSegmentState*	pdmSegState			= NULL; 
    IDirectMusicStyle*			pdmStyle			= NULL; 

    // validate pSegState
    if(!helpIsValidPtr((void*)pSegState, sizeof(CtIDirectMusicSegmentState), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pSegState = FALSE;
        pdmSegState = (IDirectMusicSegmentState*)pSegState;

    }
    else
    {
        // good pointer, get the real object
        hRes = pSegState->GetRealObjPtr(&pdmSegState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate wszName
    if(!helpIsValidPtr((void*)wszName, sizeof(WCHAR), FALSE))
    {
        fValid_wszName	= FALSE;
    }

    // validate pStyle
    if(!helpIsValidPtr((void*)pStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)pStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = pStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pdwLength
    if(!helpIsValidPtr((void*)pdwLength, sizeof(DWORD), FALSE))
    {
        fValid_pdwLength	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetPatternByName()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSegState     == %p   %s",
            pdmSegState,
            fValid_pSegState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "wszName       == %p   %s",
            wszName,
            fValid_wszName ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pStyle        == %p   %s",
            pdmStyle,
            fValid_pStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwPatternType == %08Xh",
            dwPatternType);
    fnsLog(PARAMLOGLEVEL, "pdwLength     == %p   %s",
            pdwLength,
            fValid_pdwLength ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPatternTrack*)m_pUnk)->SetPatternByName(
													pdmSegState,
													wszName,
													pdmStyle,
													dwPatternType,
													pdwLength
													);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetPatternByName()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwLength)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwLength == %p",
                pdwLength);
    }

    fnsDecrementIndent();
END:
    // done
    if(fValid_pSegState && pdmSegState)
    {
        pdmSegState->Release();
    }
    if(fValid_pStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPatternTrack::SetPatternByName()



//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctperson.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctperson.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctperson.cpp
//
// Test harness implementation of IDirectMusicChordMap
//
// Functions:
//  CtIDirectMusicChordMap::CtIDirectMusicChordMap()
//  CtIDirectMusicChordMap::~CtIDirectMusicChordMap()
//  CtIDirectMusicChordMap::InitTestClass()
//  CtIDirectMusicChordMap::GetRealObjPtr()
//  CtIDirectMusicChordMap::QueryInterface()
//  CtIDirectMusicChordMap::GetScale()
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - updated to latest dmusic arch
//  03/31/1998 - davidkl - inheritance update
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicChordMap::CtIDirectMusicChordMap()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicChordMap::CtIDirectMusicChordMap(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicChordMap";

} //*** end CtIDirectMusicChordMap::CtIDirectMusicChordMap()


//===========================================================================
// CtIDirectMusicChordMap::~CtIDirectMusicChordMap()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicChordMap::~CtIDirectMusicChordMap(void)
{
    // nothing to do

} //*** end CtIDirectMusicChordMap::~CtIDirectMusicChordMap()


//===========================================================================
// CtIDirectMusicChordMap::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmChordMap - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicChordMap::InitTestClass(IDirectMusicChordMap *pdmChordMap)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmChordMap, sizeof(IDirectMusicChordMap), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmChordMap));

} //*** end CtIDirectMusicChordMap::InitTestClass()


//===========================================================================
// CtIDirectMusicChordMap::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicChordMap **ppdmChordMap - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicChordMap::GetRealObjPtr(IDirectMusicChordMap **ppdmChordMap)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmChordMap, sizeof(IDirectMusicChordMap*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmChordMap));

} //*** end CtIDirectMusicChordMap::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicChordMap::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicChordMap::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicChordMap::QueryInterface


//===========================================================================
// CtIDirectMusicChordMap::GetScale()
//
// Encapsulates calls to GetScale
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicChordMap::GetScale(DWORD* pdwScale)
{
    HRESULT hRes			= E_NOTIMPL;
	BOOL	fValid_pdwScale	= TRUE;
    
    // validate pdwScale
    if(!helpIsValidPtr((void*)pdwScale, sizeof(DWORD), FALSE))
    {
        fValid_pdwScale = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetScale()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwScale == %08Xh   %s",
            pdwScale,
            fValid_pdwScale ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicChordMap*)m_pUnk)->GetScale(pdwScale);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetScale()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwScale)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwScale == %08Xh",
                *pdwScale);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicChordMap::GetScale()


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctinstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctinstr.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctinstr.cpp
//
// Test harness implementation of IDirectMusicInstrument
//
// Functions:
//  CtIDirectMusicInstrument::CtIDirectMusicInstrument()
//  CtIDirectMusicInstrument::~CtIDirectMusicInstrument()
//  CtIDirectMusicInstrument::InitTestClass()
//  CtIDirectMusicInstrument::GetRealObjPtr()
//  CtIDirectMusicInstrument::GetPatch()
//  CtIDirectMusicInstrument::SetPatch()
//
// History:
//  10/24/1997 - davidkl - created
//  03/30/1998 - davidkl - brave new world of inheritance
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicInstrument::CtIDirectMusicInstrument()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
CtIDirectMusicInstrument::CtIDirectMusicInstrument()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicInstrument";

} //*** end CtIDirectMusicInstrument::CtIDirectMusicInstrument()


//===========================================================================
// CtIDirectMusicInstrument::~CtIDirectMusicInstrument()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
CtIDirectMusicInstrument::~CtIDirectMusicInstrument()
{
    // nothing to do

} //*** emd CtIDirectMusicInstrument::~CtIDirectMusicInstrument()


//===========================================================================
// CtIDirectMusicInstrument::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicInstrument object pointer for future use.
//
// Parameters:
//  IDirectMusicInstrument *pdmInstr - pointer to real object
//
// Returns: 
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicInstrument::InitTestClass(IDirectMusicInstrument *pdmInstr)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmInstr, sizeof(IDirectMusicInstrument), FALSE))
	{
        m_pUnk = NULL;
        return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmInstr));

} //*** end CtIDirectMusicInstrument::InitTestClass()


//===========================================================================
// CtIDirectMusicInstrument::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicInstrument **ppdmInstr - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	10/24/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicInstrument::GetRealObjPtr(IDirectMusicInstrument **ppdmInstr)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmInstr, sizeof(IDirectMusicInstrument*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmInstr));

} //*** end CtIDirectMusicInstrument::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicInstrument::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//  HRESULT - return value from actual call to QueryInterface
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicInstrument::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicInstrument::QueryInterface()


//===========================================================================
// CtIDirectMusicInstrument::GetPatch
//
// Encapsulates calls to GetPatch
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetPatch
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicInstrument::GetPatch(DWORD* pdwPatch)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pdwPatch = TRUE;

    // validate pdwPatch
    if(!helpIsValidPtr(pdwPatch, sizeof(DWORD), FALSE))
    {
        fValid_pdwPatch = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetPatch()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwPatch == %p   %s",
            pdwPatch,
            fValid_pdwPatch ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicInstrument*)m_pUnk)->GetPatch(pdwPatch);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetPatch()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwPatch)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwPatch == %08Xh",
                *pdwPatch);
    }       

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicInstrument::GetPatch()


//===========================================================================
// CtIDirectMusicInstrument::SetPatch
//
// Encapsulates calls to SetPatch
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to SetPatch
//
// History:
//  10/24/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicInstrument::SetPatch(DWORD dwPatch)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetPatch()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwPatch == %08Xh",
            dwPatch);

    // call the real function
    hRes = ((IDirectMusicInstrument*)m_pUnk)->SetPatch(dwPatch);

    // log results
    fnsLog(PARAMLOGLEVEL, "--- Returned from %s::SetPatch()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicInstrument::SetPatch()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctphook.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctphook.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctphook.cpp
//
// Test harness implementation of IDirectMusicParamHook
//
// Functions:
//  CtIDirectMusicParamHook::CtIDirectMusicParamHook()
//  CtIDirectMusicParamHook::~CtIDirectMusicParamHook()
//  CtIDirectMusicParamHook::InitTestClass()
//  CtIDirectMusicParamHook::GetRealObjPtr()
//  CtIDirectMusicParamHook::QueryInterface()
//  CtIDirectMusicParamHook::GetParam()
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicParamHook::CtIDirectMusicParamHook()
//
// Default constructor
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicParamHook::CtIDirectMusicParamHook(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicParamHook";

} //*** end CtIDirectMusicParamHook::CtIDirectMusicParamHook()


//===========================================================================
// CtIDirectMusicParamHook::~CtIDirectMusicParamHook()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicParamHook::~CtIDirectMusicParamHook(void)
{
    // nothing to do

} //*** end CtIDirectMusicParamHook::~CtIDirectMusicParamHook()


//===========================================================================
// CtIDirectMusicParamHook::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicParamHook *pdmParamHook - pointer to real 
//                                      IDirectMusicParamHook object
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicParamHook::InitTestClass(IDirectMusicParamHook *pdmParamHook)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmParamHook, sizeof(IDirectMusicParamHook), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmParamHook));

} //*** end CtIDirectMusicParamHook::InitTestClass()


//===========================================================================
// CtIDirectMusicParamHook::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicParamHook **ppdmParamHook - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicParamHook::GetRealObjPtr(IDirectMusicParamHook **ppdmParamHook)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmParamHook, sizeof(IDirectMusicParamHook*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmParamHook));

} //*** end CtIDirectMusicParamHook::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicParamHook::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicParamHook::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicParamHook::QueryInterface()


//===========================================================================
// CtIDirectMusicParamHook::GetParam()
//
// Encapsulates calls to GetParam
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicParamHook::GetParam
(
	REFGUID rguidType, 
	DWORD dwGroupBits, 
	DWORD dwIndex, 
	MUSIC_TIME mtTime, 
	MUSIC_TIME* pmtNext, 
	void* pData,
	CtIDirectMusicSegmentState *pSegState,
	DWORD dwTrackFlags,
	HRESULT hr
)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL	fValid_pmtNext		= TRUE;
    BOOL	fValid_pData		= TRUE;
    BOOL	fValid_pSegState    = TRUE;
	IDirectMusicSegmentState*	pdmSegState = NULL;
    
    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME*), FALSE))
    {
        fValid_pmtNext	= FALSE;
    }

    // validate pData
    if(!helpIsValidPtr((void*)pData, sizeof(void*), FALSE))
    {
        fValid_pData	= FALSE;
    }

    // validate pSegState
    if(!helpIsValidPtr((void*)pSegState, sizeof(CtIDirectMusicSegmentState*), FALSE))
    {
        fValid_pSegState	= FALSE;
		pdmSegState = (IDirectMusicSegmentState*)pSegState;
    }
	else
	{
        // good pointer, get the real object
        hRes = pSegState->GetRealObjPtr(&pdmSegState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
	}

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetParam()",
		m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwGroupBits  == %08Xh",
		dwGroupBits);
	fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
		dwIndex);
	fnsLog(PARAMLOGLEVEL, "mtTime       == %016Xh",
		mtTime);
	fnsLog(PARAMLOGLEVEL, "pmtNext      == %p   %s",
		pmtNext,fValid_pmtNext ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "pSegState  == %p   %s",
		pdmSegState,fValid_pSegState ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwTrackFlags == %08Xh",
		dwTrackFlags);
	fnsLog(PARAMLOGLEVEL, "hr           == %08Xh (%s)",
		hr,tdmXlatHRESULT(hr));
	
    // call the real function
    hRes = ((IDirectMusicParamHook*)m_pUnk)->GetParam(
				rguidType, 
				dwGroupBits, 
				dwIndex, 
				mtTime, 
				pmtNext, 
				pData,
				pdmSegState,
				dwTrackFlags,
				hr);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

END:
    if(fValid_pSegState && pdmSegState)
    {
        pdmSegState->Release();
    }
    // done
    return hRes;

} //*** end CtIDirectMusicParamHook::GetParam()

//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctport8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctport8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctport8.cpp
//
// Test harness implementation of IDirectMusicPort8
//
// Functions:
//    CtIDirectMusicPort8::DownloadWave()
//    CtIDirectMusicPort8::UnloadWave()
//    CtIDirectMusicPort8::AllocVoice()
//    CtIDirectMusicPort8::AssignChannelToBuses()
//
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"


//===========================================================================
// CtIDirectMusicPort8::CtIDirectMusicPort8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPort8::CtIDirectMusicPort8()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicPort8";

} // *** end CtIDirectMusicPort8::CtIDirectMusicPort8()


//===========================================================================
// CtIDirectMusicPort8::~CtIDirectMusicPort8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicPort8::~CtIDirectMusicPort8(void)
{
    // nothing to do

} // *** emd CtIDirectMusicPort8::~CtIDirectMusicPort8()


//===========================================================================
// CtIDirectMusicPort8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicPort8 object pointer for future use.
//
// Parameters:
//  IDirectMusicPort8    *pdmPort8    - pointer to real IDirectMusicPort8 object
//
// Returns:
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPort8::InitTestClass(IDirectMusicPort8 *pdmPort8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmPort8, sizeof(IDirectMusicPort8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmPort8));

} // *** end CtIDirectMusicPort8::InitTestClass()


//===========================================================================
// CtIDirectMusicPort8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicPort8 **ppdmPort8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPort8::GetRealObjPtr(IDirectMusicPort8 **ppdmPort8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmPort8, sizeof(IDirectMusicPort8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmPort8));

} // *** end CtIDirectMusicPort8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicPort8::DownloadWave
//
// Encapsulates calls to DownloadWave
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to DownloadWave
//
// History:
//  10/14/1999 - kcraven - created
//  02/25/2000 - danhaff - filled out.
//===========================================================================
HRESULT CtIDirectMusicPort8::DownloadWave
(
	IN  CtIDirectSoundWave *ptWave,
	OUT CtIDirectSoundDownloadedWave **pptDLWave
)
{
    HRESULT hRes = E_FAIL;
    BOOL	fValid_ptWave	= TRUE;
    BOOL	fValid_pptDLWave= TRUE;

    IDirectSoundWave *pWave               = NULL;
    IDirectSoundDownloadedWave **ppDLWave = NULL;
    IDirectSoundDownloadedWave * pDLWave  = NULL;
    

  // validate ptWave
    if(!helpIsValidPtr((void*)ptWave, sizeof(CtIDirectSoundWave), FALSE))
    {
        // bogus pointer, use as such
        fValid_ptWave = FALSE;
        pWave = (IDirectSoundWave*)ptWave;

    }
    else
    {
        // valid pointer, create a real object
        hRes = ptWave->GetRealObjPtr(&pWave);
        if(FAILED(hRes))
        {
        fnsLog(PARAMLOGLEVEL, "Couldn't GetRealObjPtr from CtIDirectSoundWave hr=%s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
            goto TEST_END;
        }
    }


    // validate pptDLWave
    if(!helpIsValidPtr((void*)pptDLWave, sizeof(CtIDirectSoundDownloadedWave *), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptDLWave = FALSE;
        ppDLWave = (IDirectSoundDownloadedWave**)pptDLWave;
    }
    else
    {
        // valid pointer, create a real object (later)
        ppDLWave = &pDLWave;

    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::DownloadWave()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWave == %p   %s",
            ptWave,
            (fValid_ptWave) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL,
            "ppDLWave == %p   %s",
            pptDLWave,
            (fValid_pptDLWave) ? "" : "BAD");

    hRes = ((IDirectMusicPort8*)m_pUnk)->DownloadWave(pWave,ppDLWave);

   // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::DownloadWave()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    
    if (fValid_pptDLWave)
        fnsLog(PARAMLOGLEVEL, "*pDLWave == %p", *ppDLWave);

	fnsDecrementIndent();


    //Wrap the returned downloaded wave.
    if (SUCCEEDED(hRes))
    {
        HRESULT hResWrap;
        hResWrap = dmthCreateTestWrappedObject(pDLWave, pptDLWave);
        if(FAILED(hResWrap))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hResWrap);
            hRes = hResWrap;
        }
    }


TEST_END:
    //Release the real objects we've created, if they exist.
    SAFE_RELEASE(pDLWave);
    SAFE_RELEASE(pWave);
    return hRes;
} // *** end CtIDirectMusicPort8::DownloadWave()




//===========================================================================
// CtIDirectMusicPort8::UnloadWave
//
// Encapsulates calls to UnloadWave
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to UnloadWave
//
// History:
//  10/14/1999 - kcraven - created
//  02/25/2000 - danhaff - filled out.
//===========================================================================
HRESULT CtIDirectMusicPort8::UnloadWave
(
	IN CtIDirectSoundDownloadedWave *ptWave
)
{
IDirectSoundDownloadedWave *pWave = NULL;
BOOL fValid_ptWave                = TRUE;
HRESULT hRes                      = E_FAIL;

  // validate ptWave
    if(!helpIsValidPtr((void*)ptWave, sizeof(CtIDirectSoundWave), FALSE))
    {
        // bogus pointer, use as such
        fValid_ptWave = FALSE;
        pWave = (IDirectSoundDownloadedWave*)ptWave;

    }
    else
    {
        // valid pointer, create a real object
        hRes = ptWave->GetRealObjPtr(&pWave);
        if(FAILED(hRes))
        {
        fnsLog(PARAMLOGLEVEL, "Couldn't GetRealObjPtr from CtIDirectSoundWave hr=%s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // log inputs
	fnsIncrementIndent();
    fnsLog(CALLLOGLEVEL, "--- Calling %s::UnloadWave()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWave == %p   %s",
            ptWave,
            (fValid_ptWave) ? "" : "BAD");	

    //Call function.
    hRes = ((IDirectMusicPort8*)m_pUnk)->UnloadWave(pWave);

   // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::UnloadWave()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    

	fnsDecrementIndent();


END:
    //Release real object obtained from wrapper.
    SAFE_RELEASE(pWave);
    return hRes;
} // *** end CtIDirectMusicPort8::UnloadWave()




//===========================================================================
// CtIDirectMusicPort8::AllocVoice
//
// Encapsulates calls to AllocVoice
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to AllocVoice
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPort8::AllocVoice
        (
         IN CtIDirectSoundDownloadedWave *pWave,    // Wave to play on this voice
         IN DWORD dwChannel,                        // Channel and channel group
         IN DWORD dwChannelGroup,                   //  this voice will play on
         IN REFERENCE_TIME rtStart,                 // Start position (stream only)
         IN SAMPLE_TIME stLoopStart,                // Loop start (one-shot only)
         IN SAMPLE_TIME stLoopEnd,                  // Loop end (one-shot only)
         OUT CtIDirectMusicVoice **ppVoice          // Returned voice
        )        
//HRESULT CtIDirectMusicPort8::AllocVoice
//    (
//     IN CtIDirectSoundDownloadedWave *pWave,      /* Wave to play on this voice */
//     IN DWORD dwChannel,                        /* Channel and channel group */
//     IN DWORD dwChannelGroup,                   /*  this voice will play on */
//     IN REFERENCE_TIME rtStart,                 /* Start position (stream only) */
//     IN REFERENCE_TIME rtReadahead,             /* How much to read ahead (stream only) */
//     IN SAMPLE_TIME stLoopStart,                /* Loop start (one-shot only) */
//     IN SAMPLE_TIME stLoopEnd,                  /* Loop end (one-shot only) */
//     OUT CtIDirectMusicVoice **ppVoice            /* Returned voice */
//    )
//HRESULT CtIDirectMusicPort8::AllocVoice
//(
//	IN CtIDirectSoundDownloadedWave *pWave,
//	IN DWORD dwChannel,
//	IN DWORD dwChannelGroup,
//	IN REFERENCE_TIME rtStart,
//	IN REFERENCE_TIME rtReadahead,
//	OUT CtIDirectMusicVoice **ppVoice
//)
{
    HRESULT	hRes			= E_FAIL;
    BOOL	fValid_pWave	= TRUE;
    BOOL	fValid_ppVoice	= TRUE;
	IDirectSoundDownloadedWave*	pdmWave		= NULL;
	IDirectMusicVoice*			pdmVoice	= NULL;
	IDirectMusicVoice**			ppdmVoice	= NULL;


    // validate pWave
    if(!helpIsValidPtr((void*)pWave,sizeof(CtIDirectSoundDownloadedWave),FALSE))
    {
        // bogus pointer, use as such
        fValid_pWave = FALSE;
        pdmWave = (IDirectSoundDownloadedWave*)pWave;
    }
    else
    {
        // valid pointer, create a real object
        hRes = pWave->GetRealObjPtr(&pdmWave);
        if(FAILED(hRes))
        {
            fnsLog(PARAMLOGLEVEL, "Couldn't GetRealObjPtr from CtIDirectSoundDownloadedWave hr=%s (%08Xh)",
                tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppVoice
    if(!helpIsValidPtr((void*)ppVoice,sizeof(CtIDirectMusicVoice*),FALSE))
    {
        fValid_ppVoice = FALSE;

        // we have a bogus pointer, use as the real thing
        ppdmVoice = (IDirectMusicVoice**)ppVoice;

    }
    else
    {
        // valid pointer, use a real object
        ppdmVoice = &pdmVoice;

        // just in case we fail, init test object ptr to NULL
        *ppVoice = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AllocVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWave          == %p   %s",
            pdmWave,fValid_pWave ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwChannel      == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "rtStart        == %016Xh",
            rtStart);
//    fnsLog(PARAMLOGLEVEL, "rtReadahead      == %016Xh",
//            rtReadahead);
    fnsLog(PARAMLOGLEVEL, "stLoopStart    == %016Xh",
            stLoopStart);
    fnsLog(PARAMLOGLEVEL, "stLoopEnd      == %016Xh",
            stLoopEnd);
    fnsLog(PARAMLOGLEVEL, "ppVoice        == %p   %s",
            ppdmVoice,
            fValid_ppVoice ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort8*)m_pUnk)->AllocVoice(pdmWave,dwChannel,dwChannelGroup,rtStart,stLoopStart,stLoopEnd,ppdmVoice);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AllocVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppVoice)
    {
        fnsLog(PARAMLOGLEVEL, "*ppVoice == %p",ppdmVoice);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmVoice,ppVoice);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();
END:
    if(fValid_pWave && pdmWave)
    {
        pdmWave->Release();
    }
    if(fValid_ppVoice && pdmVoice)
    {
        pdmVoice->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPort8::AllocVoice()




//===========================================================================
// CtIDirectMusicPort8::AssignChannelToBuses
//
// Encapsulates calls to AssignChannelToBuses
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to AssignChannelToBuses
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPort8::AssignChannelToBuses
(
	IN DWORD dwChannelGroup,
	IN DWORD dwChannel,
	IN LPDWORD pdwBusses,
	IN DWORD cBussCount
)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pdwBusses	= TRUE;


    // validate pdwBusses
    if(!helpIsValidPtr((void*)pdwBusses, sizeof(DWORD*), FALSE))
    {
        // bogus pointer
        fValid_pdwBusses = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AssignChannelToBuses()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel      == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "pdwBusses      == %p   %s",
            pdwBusses,
            fValid_pdwBusses ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "cBussCount     == %08Xh",
            cBussCount);

    // call the real function
    hRes = ((IDirectMusicPort8*)m_pUnk)->AssignChannelToBuses(dwChannelGroup,dwChannel,pdwBusses,cBussCount);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AssignChannelToBuses()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicPort8::AssignChannelToBuses()




//===========================================================================
// CtIDirectMusicPort8::SetSink
//
// Encapsulates calls to SetSink
//
// Parameters:
//  pSink: IDirectSoundSink to attach port to.
//      
//
// Returns:
//  HRESULT - return code from actual call to SetSink
//
// History:
//  02/26/2000 - created
//===========================================================================
HRESULT CtIDirectMusicPort8::SetSink
(
	IN IDirectSoundSink *pSink
)
{
	HRESULT hRes			= E_FAIL;
    BOOL    fValid_pSink	= TRUE;

    // validate pSink
    if(!helpIsValidPtr((void*)pSink, sizeof(IDirectSoundSink*), FALSE))
    {
        // bogus pointer
        fValid_pSink = FALSE;
    }

    // log inputs
	fnsIncrementIndent();
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSink == %p   %s",
            pSink,
            fValid_pSink ? "" : "BAD");

    //Call function.
    hRes = ((IDirectMusicPort8*)m_pUnk)->SetSink(pSink);

   // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    

	fnsDecrementIndent();

    return hRes;

} // *** end CtIDirectMusicPort8::SetSink()






//===========================================================================
// CtIDirectMusicPort8::GetSink
//
// Encapsulates calls to GetSink
//
// Parameters:
//  pSink: IDirectSoundSink to attach port to.
//      
//
// Returns:
//  HRESULT - return code from actual call to GetSink
//
// History:
//  02/26/2000 - created
//===========================================================================
HRESULT CtIDirectMusicPort8::GetSink
(
	OUT IDirectSoundSink **ppSink
)
{
HRESULT hRes                      = E_FAIL;
BOOL fValid_ppSink                = TRUE;


    //Validate ptr.
    if(!helpIsValidPtr((void*)ppSink, sizeof(IDirectSoundSink *), FALSE))
    {
        fValid_ppSink = FALSE;
    }

    // log inputs
	fnsIncrementIndent();
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppSink == %p %s", ppSink, fValid_ppSink ? "" : "(BAD)");	

    //Call function.
    hRes = ((IDirectMusicPort8*)m_pUnk)->GetSink(ppSink);

   // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);    
    if (fValid_ppSink)
        fnsLog(PARAMLOGLEVEL, "*ppSink == (%08Xh)", *ppSink);    

	fnsDecrementIndent();

    return hRes;

} // *** end CtIDirectMusicPort8::GetSink()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctport.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctport.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctport.cpp
//
// Test harness implementation of IDirectMusicPort
//
// Functions:
//  CtIDirectMusicPort::CtIDirectMusicPort()
//  CtIDirectMusicPort::~CtIDirectMusicPort()
//  CtIDirectMusicPort::InitTestClass()
//  CtIDirectMusicPort::GetRealObjPtr()
//  CtIDirectMusicPort::QueryInterface()
//  CtIDirectMusicPort::PlayBuffer()
//  CtIDirectMusicPort::SetReadNotificationHandle()
//  CtIDirectMusicPort::Read()
//  CtIDirectMusicPort::DownloadInstrument()
//  CtIDirectMusicPort::UnloadInstrument()
//  CtIDirectMusicPort::GetLatencyClock()
//  CtIDirectMusicPort::GetRunningStats()
//	CtIDirectMusicPort::SetNumChannelGroups()
//  CtIDirectMusicPort::GetCaps()
//  CtIDirectMusicPort::DeviceIoControl()
//  CtIDirectMusicPort::Compact()
//  CtIDirectMusicPort::GetNumChannelGroups()
//  CtIDirectMusicPort::Activate()
//  CtIDirectMusicPort::SetChannelPriority()
//  CtIDirectMusicPort::GetChannelPriority()
//  CtIDirectMusicPort::SetDirectSound()
//
// History:
//  10/21/1997 - davidkl - created
//  12/23/1997 - a-llucar - Added methods to reflect new dmusic.h
//	01/19/1998 - a-llucar - Updated to latest changes in dmusic.h
//	01/30/1998 - a-llucar - added methods Compact(), GetCaps(), 
//                          GetHandle(), IsBufferFormatSupported()
//  03/03/1998 - davidkl - updated to latest dm arch
//  03/25/1998 - davidkl - renamed file.  added GetNumChannelGroups.
//                         Brave new world... inherits from CtIUnknown
//  03/27/1998 - davidkl - removed property set functions (now part of 
//                         IKsPropertySet.  updated to latest dmusicc.h
//  04/01/1998 - davidkl - minor tweaking
//	08/04/1998 - a-trevg - New Activate method
//	08/20/1998 - a-trevg - New Get-/Set- ChannelPriority methods
//  08/21/1998 - davidkl - removed GetInterfaces() / Added SetDirectSound()
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicPort::CtIDirectMusicPort()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/21/1997 - davidkl - created
//===========================================================================
CtIDirectMusicPort::CtIDirectMusicPort()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicPort";

} //*** end CtIDirectMusicPort::CtIDirectMusicPort()


//===========================================================================
// CtIDirectMusicPort::~CtIDirectMusicPort()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/21/1997 - davidkl - created
//===========================================================================
CtIDirectMusicPort::~CtIDirectMusicPort(void)
{
    // nothing to do

} //*** emd CtIDirectMusicPort::~CtIDirectMusicPort()


//===========================================================================
// CtIDirectMusicPort::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicPort object pointer for future use.
//
// Parameters:
//  IDirectMusicPort    *pdmPort    - pointer to real IDirectMusicPort object
//
// Returns: 
//
// History:
//  10/21/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::InitTestClass(IDirectMusicPort *pdmPort)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmPort, sizeof(IDirectMusicPort), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmPort));

} //*** end CtIDirectMusicPort::InitTestClass()


//===========================================================================
// CtIDirectMusicPort::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicPort **ppdmPort - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//	10/21/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicPort::GetRealObjPtr(IDirectMusicPort **ppdmPort)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmPort, sizeof(IDirectMusicPort*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmPort));

} //*** end CtIDirectMusicPort::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicPort::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/21/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicPort::QueryInterface()


//===========================================================================
// CtIDirectMusicPort::PlayBuffer
//
// Encapsulates calls to PlayBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to PlayBuffer
//
// History:
//  10/21/1997 - davidkl - created
//  11/15/1997 - davidkl - implemented test class version
//  03/03/1998 - davidkl - renamed to PlayBuffer
//===========================================================================
HRESULT CtIDirectMusicPort::PlayBuffer(CtIDirectMusicBuffer *ptdmBuf)
{
    HRESULT             hRes            = E_NOTIMPL;
    BOOL                fValid_ptdmBuf  = TRUE;
    IDirectMusicBuffer  *pdmBuffer      = NULL;

    // validate ptdmBuf
    if(!helpIsValidPtr((void*)ptdmBuf, sizeof(CtIDirectMusicBuffer), FALSE))
    {
        fValid_ptdmBuf = FALSE;

        // we have an invalid pointer, use it as the real thing
        pdmBuffer = (IDirectMusicBuffer *)ptdmBuf;
    }
    else
    {
        // we passed in a valid pointer, get the real buffer ptr
        //  that is stored in our test class
        hRes = ptdmBuf->GetRealObjPtr(&pdmBuffer);
        if(FAILED(hRes))
        {
            // BUGBUG
			// add logging
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdmBuffer == %p   %s",
            pdmBuffer,
            fValid_ptdmBuf ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->PlayBuffer(pdmBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmBuf && pdmBuffer)
    {
        pdmBuffer->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPort::PlayBuffer()


//===========================================================================
// CtIDirectMusicPort::SetReadNotificationHandle
//
// Encapsulates calls to SetReadNotificationHandle
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to SetReadNotificationHandle
//
// History:
//  11/16/1997 - davidkl - created
//  03/03/1998 - davidkl - renamed to SetNotificationHandle
//  03/27/1998 - davidkl - renamed again
//===========================================================================
HRESULT CtIDirectMusicPort::SetReadNotificationHandle(HANDLE hEvent)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetReadNotificationHandle()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hEvent == %08Xh",
            hEvent);

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->SetReadNotificationHandle(hEvent);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetReadNotificationHandle()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;
    
} //*** end CtIDirectMusicPort::SetReadNotificationHandle()


//===========================================================================
// CtIDirectMusicPort::Read
//
// Encapsulates calls to Read
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Read
//
// History:
//  11/16/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::Read(CtIDirectMusicBuffer *ptdmBuf)
{
    HRESULT             hRes            = E_NOTIMPL;
    BOOL                fValid_ptdmBuf  = TRUE;
    IDirectMusicBuffer  *pdmBuffer      = NULL;

    // validate ptdmBuf
    if(!helpIsValidPtr((void*)ptdmBuf, sizeof(CtIDirectMusicBuffer), FALSE))
    {
        fValid_ptdmBuf = FALSE;

        // we have a bogus pointer, use it as the real thing
        pdmBuffer = (IDirectMusicBuffer*)ptdmBuf;
    }
    else
    {
        // we have a valid pointer, get the real one from our test class
        hRes = ptdmBuf->GetRealObjPtr(&pdmBuffer);
        if(FAILED(hRes))
        {   
            // BUGBUG
			// add logging
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Read()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdmBuffer == %p   %s",
            pdmBuffer,
            fValid_ptdmBuf ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->Read(pdmBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Read()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmBuf && pdmBuffer)
    {
        pdmBuffer->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPort::Read()


//===========================================================================
// CtIDirectMusicPort::DownloadInstrument
//
// Encapsulates calls to DownloadInstrument
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to DownloadInstrument
//
// History:
//  11/17/1997 - davidkl - created
//  03/03/1998 - davidkl - renamed to DownloadInstrument
//  04/01/1998 - davidkl - pay attention to pdmNoteRange iff dwNumRanges != 0
//===========================================================================
HRESULT CtIDirectMusicPort::DownloadInstrument(CtIDirectMusicInstrument *ptdmInst, 
					            CtIDirectMusicDownloadedInstrument **pptdmDlInst,
						        DMUS_NOTERANGE* pdmNoteRange,
						        DWORD dwNumRanges)
{
    HRESULT                             hRes                = E_NOTIMPL;
    BOOL                                fValid_ptdmInst     = TRUE;
    BOOL                                fValid_pptdmDlInst  = TRUE;
    BOOL                                fValid_pdmNoteRange = TRUE;
    IDirectMusicInstrument              *pdmInstrument      = NULL;
    IDirectMusicDownloadedInstrument    *pdmDlInstrument    = NULL;
    IDirectMusicDownloadedInstrument    **ppdmDlInstrument  = NULL;

    // validate ptdmInst
    if(!helpIsValidPtr((void*)ptdmInst, 
                        sizeof(CtIDirectMusicInstrument),
                        FALSE))
    {
        fValid_ptdmInst = FALSE;

        // we have a bogus pointer, use as the real thing   
        pdmInstrument = (IDirectMusicInstrument*)ptdmInst;
    }
    else
    {
        // we have a valid pointer, get the real thing from our test object
        hRes = ptdmInst->GetRealObjPtr(&pdmInstrument);
        if(FAILED(hRes))
        {
            // BUGBUG
			// add logging
            goto END;
        }
    }

    // validate pptdmDlInst
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicDownloadedInstrument pointer, 
    //  we assume that we are to perform an invalid parameter test on 
    //  IDirectMusicPort::Download().  Otherwise, we are to create and
    //  return a CtIDirectMusicDownloadedInstrument object
    if(!helpIsValidPtr((void*)pptdmDlInst,
                        sizeof(CtIDirectMusicDownloadedInstrument*),
                        FALSE))
    { 
        fValid_pptdmDlInst = FALSE;

        // we have a bogus pointer, use as the real thing
        ppdmDlInstrument = (IDirectMusicDownloadedInstrument**)pptdmDlInst;

    }
    else
    {
        // valid pointer, create a real object
        ppdmDlInstrument = &pdmDlInstrument;

        // just in case we fail, init test object ptr to NULL
        *pptdmDlInst = NULL;
    }

    // validate pdmNoteRange iff dwNumRanges != 0
    if(dwNumRanges)
    {
        if(!helpIsValidPtr((void*)pdmNoteRange, sizeof(DMUS_NOTERANGE), FALSE))
        {
            fValid_pdmNoteRange = FALSE;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::DownloadInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdmInstrument    == %p   %s",
            pdmInstrument,
            fValid_ptdmInst ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppdmDlInstrument == %p   %s",
            ppdmDlInstrument,
            fValid_pptdmDlInst ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdmNoteRange     == %p   %s",
            pdmNoteRange,
            fValid_pdmNoteRange ? "" : "BAD");
    if(fValid_pdmNoteRange && dwNumRanges)
    {
        // BUGBUG - log contents of pdmNoteRange?? (loglevel == 10)
    }
    fnsLog(PARAMLOGLEVEL, "dwNumRanges      == %08Xh",
            dwNumRanges);

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->DownloadInstrument(pdmInstrument,
                                ppdmDlInstrument,
                                pdmNoteRange,
                                dwNumRanges);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::DownloadInstrument",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes              == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmDlInst)
    {
        fnsLog(PARAMLOGLEVEL, "*ppdmDlInstrument == %p",
                pdmDlInstrument);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmDlInstrument, pptdmDlInst);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmInst && pdmInstrument)
    {
        pdmInstrument->Release();
    }
    if(fValid_pptdmDlInst && pdmDlInstrument)
    {
        pdmDlInstrument->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPort::DownloadInstrument()


//===========================================================================
// CtIDirectMusicPort::UnloadInstrument
//
// Encapsulates calls to UnloadInstrument
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Unload
//
// History:
//  11/16/1997 - davidkl - created
//  03/03/1998 - davidkl - renamed to UnloadInstrument
//===========================================================================
HRESULT CtIDirectMusicPort::UnloadInstrument(CtIDirectMusicDownloadedInstrument *ptdmDlInst)
{
    HRESULT                             hRes                = E_NOTIMPL;
    BOOL                                fValid_ptdmDlInst   = TRUE;
    IDirectMusicDownloadedInstrument    *pdmDlInstrument    = NULL;

    // validate ptdmDlInst
    if(!helpIsValidPtr((void*)ptdmDlInst, 
                        sizeof(CtIDirectMusicDownloadedInstrument),
                        FALSE))
    {
        fValid_ptdmDlInst   = FALSE;

        // we have a bogus pointer, use it as the real thing
        pdmDlInstrument = (IDirectMusicDownloadedInstrument*)ptdmDlInst;

    }
    else
    {
        // we have a valid pointer, get the real one from our test object
        hRes = ptdmDlInst->GetRealObjPtr(&pdmDlInstrument);
        if(FAILED(hRes))
        {
            // BUGBUG
			// add logging
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::UnloadInstrument()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdmDlInstrument == %p   %s",
            pdmDlInstrument,
            fValid_ptdmDlInst ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->UnloadInstrument(pdmDlInstrument);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::UnloadInstrument()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmDlInst && pdmDlInstrument)
    {
        pdmDlInstrument->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPort::UnloadInstrument()


//===========================================================================
// CtIDirectMusicPort::GetLatencyClock
//
// Encapsulates calls to GetLatencyClock
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetLatencyClock
//
// History:
//  12/23/1997 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicPort::GetLatencyClock(CtIReferenceClock **pptClock)
{
    HRESULT         hRes            = E_NOTIMPL;
    BOOL            fValid_pptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;
    IReferenceClock **ppRefClock    = NULL;
    
    // validate pptClock
    // NOTE:
    //	If we are passed an invalid CtIReferenceClock pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPort::GetLatencyClock().  
    //  Otherwise, we are to create and return a CtIReferenceClock object
    if(!helpIsValidPtr((void*)pptClock, sizeof(CtIReferenceClock*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptClock = FALSE;
        ppRefClock = (IReferenceClock**)pptClock;

    }
    else
    {
        // valid pointer, create a real object
        ppRefClock = &pRefClock;

        // just in case we fail, init test object ptr to NULL
        *pptClock = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppClock == %p   %s",
            ppRefClock,
            fValid_pptClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->GetLatencyClock(ppRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptClock)
    {
        fnsLog(PARAMLOGLEVEL, "*ppClock == %p",
            *pRefClock);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pRefClock, pptClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPort::GetLatencyClock()


//===========================================================================
// CtIDirectMusicPort::GetRunningStats
//
// Encapsulates calls to GetRunningStats
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetRunningStats
//
// History:
//  12/23/1997 - a-llucar - created
//  03/25/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicPort::GetRunningStats(LPDMUS_SYNTHSTATS pStats)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL    fValid_pStats	= TRUE;
    
    // validate pdwCPUUsagePerVoice
    if(!helpIsValidPtr((void*)pStats, sizeof(DMUS_SYNTHSTATS), FALSE))
    {
        fValid_pStats   = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStats == %p   %s",
            pStats,
            fValid_pStats ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->GetRunningStats(pStats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pStats)
    {
        // BUGBUG - log contents of DMUS_SYNTHSTATS
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::GetRunningStats()


//===========================================================================
// CtIDirectMusicPort::SetNumChannelGroups
//
// Encapsulates calls to SetNumChannelGroups
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to SetNumChannelGroups
//
// History:
//  12/23/1997 - a-llucar - created
//  03/25/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicPort::SetNumChannelGroups(DWORD dwChannelGroups)
{
    HRESULT hRes    = E_NOTIMPL;
    
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroups == %08Xh",
            dwChannelGroups);

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->SetNumChannelGroups(dwChannelGroups);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::SetNumChannelGroups()


//===========================================================================
// CtIDirectMusicPort::GetCaps
//
// Encapsulates calls to GetCaps
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetCaps
//
// History:
//  12/23/1997 - a-llucar - created
//  03/25/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicPort::GetCaps(LPDMUS_PORTCAPS pPortCaps)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pPortCaps	= TRUE;
    
    // validate pPortCaps
    if(!helpIsValidPtr((void*)pPortCaps, sizeof(DMUS_PORTCAPS), FALSE))
    {
        fValid_pPortCaps   = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetCaps()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPortCaps == %p   %s",
            pPortCaps,
            fValid_pPortCaps ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->GetCaps(pPortCaps);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetCaps()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pPortCaps)
    {
        tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL, pPortCaps);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::GetCaps()


//===========================================================================
// CtIDirectMusicPort::DeviceIoControl
//
// Encapsulates calls to DeviceIoControl
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to DeviceIoControl
//
// History:
//  12/23/1997 - a-llucar - created
//  03/25/1998 - davidkl - fixed logging
//  03/27/1998 - davidkl - renamed, added params
//===========================================================================
HRESULT CtIDirectMusicPort::DeviceIoControl(DWORD dwIoControlCode, 
                                            LPVOID lpInBuffer, 
                                            DWORD nInBufferSize, 
                                            LPVOID lpOutBuffer, 
                                            DWORD nOutBufferSize, 
                                            LPDWORD lpBytesReturned, 
                                            LPOVERLAPPED lpOverlapped)
{
    HRESULT hRes			        = E_NOTIMPL;
    BOOL    fValid_lpInBuffer       = TRUE;
    BOOL    fValid_lpOutBuffer      = TRUE;
    BOOL    fValid_lpBytesReturned  = TRUE;
    BOOL    fValid_lpOverlapped     = TRUE;
    
    // validate lpInBuffer
    if(!helpIsValidPtr((void*)lpInBuffer, nInBufferSize, FALSE))
    {
        fValid_lpInBuffer = FALSE;
    }

    // validate lpOutBuffer
    if(!helpIsValidPtr((void*)lpOutBuffer, nOutBufferSize, FALSE))
    {
        fValid_lpOutBuffer = FALSE;
    }

    // validate lpBytesReturned
    if(!helpIsValidPtr((void*)lpBytesReturned, sizeof(DWORD), FALSE))
    {
        fValid_lpBytesReturned = FALSE;
    }

    // validate lpOverlapped
    if(!helpIsValidPtr((void*)lpOverlapped, sizeof(OVERLAPPED), FALSE))
    {
        fValid_lpOverlapped = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::DeviceIoControl()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIoControlCode == %08Xh",
            dwIoControlCode);
    fnsLog(PARAMLOGLEVEL, "lpInBuffer      == %p   %s",
            lpInBuffer,
            fValid_lpInBuffer ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "nInBufferSize   == %08Xh",
            nInBufferSize);
    fnsLog(PARAMLOGLEVEL, "lpOutBuffer     == %p   %s",
            lpOutBuffer,
            fValid_lpOutBuffer ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "nOutBufferSize  == %08Xh",
            nOutBufferSize);
    fnsLog(PARAMLOGLEVEL, "lpBytesReturned == %p   %s",
            lpBytesReturned,
            fValid_lpBytesReturned ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "lpOverlapped    == %p   %s",
            lpOverlapped,
            fValid_lpOverlapped ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->DeviceIoControl(dwIoControlCode, 
                                                        lpInBuffer, 
                                                        nInBufferSize, 
                                                        lpOutBuffer, 
                                                        nOutBufferSize, 
                                                        lpBytesReturned, 
                                                        lpOverlapped);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::DeviceIoControl()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::DeviceIoControl()


//===========================================================================
// CtIDirectMusicPort::Compact
//
// Encapsulates calls to Compact
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Compact
//
// History:
//  03/03/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::Compact(void)
{
    HRESULT	hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Compact()",
            m_szInterfaceName);

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->Compact();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Compact()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::Compact()


//===========================================================================
// CtIDirectMusicPort::GetNumChannelGroups
//
// Encapsulates calls to GetNumChannelGroups
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetNumChannelGroups
//
// History:
//  03/25/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::GetNumChannelGroups(LPDWORD pdwGroups)
{
    HRESULT hRes                = E_NOTIMPL;
    BOOL    fValid_pdwGroups    = TRUE;

    // validate pdwGroups
    if(!helpIsValidPtr((void*)pdwGroups, sizeof(DWORD), FALSE))
    {
        fValid_pdwGroups = FALSE;
    }
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwGroups == %p   %s",
            pdwGroups,
            fValid_pdwGroups ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->GetNumChannelGroups(pdwGroups);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwGroups)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwGroups == %08Xh",
                *pdwGroups);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::GetNumChannelGroups()


//===========================================================================
// CtIDirectMusicPort::Activate
//
// Encapsulates calls to Activate
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Activate
//
// History:
//  08/04/1998 - a-trevg - created
//  08/21/1998 - davidkl - removed hWnd
//===========================================================================
HRESULT CtIDirectMusicPort::Activate(BOOL fEnable)
{
    HRESULT	hr			= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()", 
		m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "fEnable == %s", 
		fEnable ? "TRUE" : "FALSE");

    // call the real function
    hr = ((IDirectMusicPort*)m_pUnk)->Activate(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()", 
		m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hr          == %s (%08Xh)", 
		tdmXlatHRESULT(hr), hr);
    
    fnsDecrementIndent();

    // done
    return hr;

} //*** end CtIDirectMusicPort::Activate()


//===========================================================================
// CtIDirectMusicPort::SetChannelPriority
//
// Encapsulates calls to SetChannelPriority
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to SetChannelPriority
//
// History:
//  08/20/1998 - a-trevg - created
//===========================================================================
HRESULT CtIDirectMusicPort::SetChannelPriority(DWORD dwChannelGroup, 
											   DWORD dwChannel, 
											   DWORD dwPriority)
{
	HRESULT	hr	= E_NOTIMPL;

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::SetChannelPriority()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh", dwChannelGroup);
	fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh", dwChannel);
	fnsLog(PARAMLOGLEVEL, "dwPriority == %08Xh", dwPriority);

	// call the real function
	hr = ((IDirectMusicPort*)m_pUnk)->SetChannelPriority(dwChannelGroup, dwChannel, 
		dwPriority);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetChannelPriority()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hr == %s (%08Xh)", tdmXlatHRESULT(hr), hr);

	fnsDecrementIndent();

	// done
	return hr;

} //*** end CtIDirectMusicPort::SetChannelPriority()


//===========================================================================
// CtIDirectMusicPort::GetChannelPriority
//
// Encapsulates calls to GetChannelPriority
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetChannelPriority
//
// History:
//  08/20/1998 - a-trevg - created
//===========================================================================
HRESULT CtIDirectMusicPort::GetChannelPriority(DWORD dwChannelGroup, 
											   DWORD dwChannel, 
											   LPDWORD pdwPriority)
{
	HRESULT	hr					= E_NOTIMPL;
    BOOL    fValid_pdwPriority	= TRUE;

    // validate pdwGroups
    if(!helpIsValidPtr((void *) pdwPriority, sizeof(DWORD), FALSE))
        fValid_pdwPriority = FALSE;

	fnsIncrementIndent();

	// log inputs
	fnsLog(CALLLOGLEVEL, "--- Calling %s::GetChannelPriority()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh", dwChannelGroup);
	fnsLog(PARAMLOGLEVEL, "dwChannel      == %08Xh", dwChannel);
	fnsLog(PARAMLOGLEVEL, "pdwPriority    == %p", pdwPriority);

	// call the real function
	hr = ((IDirectMusicPort*)m_pUnk)->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);

	// log results
	fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetChannelPriority()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "hr == %s (%08Xh)", tdmXlatHRESULT(hr), hr);

    if(fValid_pdwPriority)
        fnsLog(PARAMLOGLEVEL, "*pdwPriority == %08Xh", *pdwPriority);

	fnsDecrementIndent();

	// done
	return hr;

} //*** end CtIDirectMusicPort::GetChannelPriority()




//===========================================================================
// CtIDirectMusicPort::SetDirectSound
//
// Encapsulates calls to SetDirectSound
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to SetDirectSound
//
// History:
//  08/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::SetDirectSound(LPDIRECTSOUND pDirectSound, 
                                        LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    HRESULT hRes                        = E_NOTIMPL;
    BOOL    fValid_pDirectSound         = TRUE;
    BOOL    fValid_pDirectSoundBuffer   = TRUE;

    // validate pDirectSound
    if(!helpIsValidPtr((void*)pDirectSound, sizeof(IDirectSound), TRUE))
    {
        // bogus pointer
        fValid_pDirectSound = FALSE;
    }

    // validate pDirectSoundBuffer
    if(!helpIsValidPtr((void*)pDirectSoundBuffer, sizeof(IDirectSoundBuffer), TRUE))
    {
        // bogus pointer
        fValid_pDirectSoundBuffer = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetDirectSound()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDirectSound       == %p   %s",
            pDirectSound,
            fValid_pDirectSound ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pDirectSoundBuffer == %p   %s",
            pDirectSoundBuffer,
            fValid_pDirectSoundBuffer ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->SetDirectSound(pDirectSound,
                                                        pDirectSoundBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetDirectSound()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::SetDirectSound()


//===========================================================================
// CtIDirectMusicPort::GetFormat
//
// Encapsulates calls to GetFormat
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetFormat
//
// History:
//  08/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPort::GetFormat(LPWAVEFORMATEX pWaveFormatEx,
                                    LPDWORD pdwWaveFormatExSize,
                                    LPDWORD pdwBufferSize)
{
    HRESULT hRes                        = E_NOTIMPL;
    BOOL    fValid_pWaveFormatEx        = TRUE;
    BOOL    fValid_pdwWaveFormatExSize  = TRUE;
    BOOL    fValid_pdwBufferSize        = TRUE;

    // validate pWaveFormatEx
    if(!helpIsValidPtr((void*)pWaveFormatEx, sizeof(LPWAVEFORMATEX), TRUE))
    {
        // bogus pointer
        fValid_pWaveFormatEx = FALSE;
    }

    // validate pdwWaveFormatExSize
    if(!helpIsValidPtr((void*)pdwWaveFormatExSize, sizeof(DWORD), FALSE))
    {
        // bogus pointer
        fValid_pdwWaveFormatExSize = FALSE;
    }

    // validate pdwWaveFormatExSize
    if(!helpIsValidPtr((void*)pdwBufferSize, sizeof(DWORD), FALSE))
    {
        // bogus pointer
        fValid_pdwBufferSize = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWaveFormatEx       == %p   %s",
            pWaveFormatEx,
            fValid_pWaveFormatEx ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwWaveFormatExSize == %p   %s",
            pdwWaveFormatExSize,
            fValid_pdwWaveFormatExSize ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwBufferSize       == %p   %s",
            pdwBufferSize,
            fValid_pdwBufferSize ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPort*)m_pUnk)->GetFormat(pWaveFormatEx,
                                                  pdwWaveFormatExSize,
                                                  pdwBufferSize);

    //Log contents of WAVEFORMATEX, don't care about anything extra, since we don't know what that might be. -jimmo
    if (SUCCEEDED( hRes ))
    {
        if (NULL != pWaveFormatEx)
        {
            fnsLog(PARAMLOGLEVEL, "========= WFX Contents From GetFormat() call  ============");
            fnsLog(PARAMLOGLEVEL, "    WFX.wFormatTag      == %08Xh ",  pWaveFormatEx->wFormatTag);
            fnsLog(PARAMLOGLEVEL, "    WFX.nChannels       == %08Xh ",  pWaveFormatEx->nChannels);
            fnsLog(PARAMLOGLEVEL, "    WFX.nSamplesPerSec  == %08Xh ",  pWaveFormatEx->nSamplesPerSec);
            fnsLog(PARAMLOGLEVEL, "    WFX.nAvgBytesPerSec == %08Xh ",  pWaveFormatEx->nAvgBytesPerSec);
            fnsLog(PARAMLOGLEVEL, "    WFX.nBlockAlign     == %08Xh ",  pWaveFormatEx->nBlockAlign);
            fnsLog(PARAMLOGLEVEL, "    WFX.wBitsPerSample  == %08Xh ",  pWaveFormatEx->wBitsPerSample);
            fnsLog(PARAMLOGLEVEL, "    WFX.cbSize          == %08Xh ",  pWaveFormatEx->cbSize);
        }
    }

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPort::GetFormat()


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctportdl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctportdl.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctportdl.cpp
//
// Test harness implementation of IDirectMusicPortDownload
//
// Functions:
//  CtIDirectMusicPortDownload::CtIDirectMusicPortDownload()
//  CtIDirectMusicPortDownload::~CtIDirectMusicPortDownload()
//  CtIDirectMusicPortDownload::InitTestClass()
//  CtIDirectMusicPortDownload::GetRealObjPtr()
//  CtIDirectMusicPortDownload::QueryInterface()
//  CtIDirectMusicPortDownload::GetBuffer()
//  CtIDirectMusicPortDownload::AllocateBuffer()
//  CtIDirectMusicPortDownload::GetDLId()
//  CtIDirectMusicPortDownload::Append()
//  CtIDirectMusicPortDownload::Download()
//  CtIDirectMusicPortDownload::Unload()
//
// History:
//  11/17/1997 - davidkl - created
//	12/23/1997 - a-llucar - Added new methods
//  03/30/1998 - davidkl - welcome to the brave new world of inheritance
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicPortDownload::CtIDirectMusicPortDownload()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicPortDownload::CtIDirectMusicPortDownload()
{
    // initialize our member variables
	m_pUnk = NULL;
//	m_pdmPortDl = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicPortDownload";

} //*** end CtIDirectMusicPortDownload::CtIDirectMusicPortDownload()


//===========================================================================
// CtIDirectMusicPortDownload::~CtIDirectMusicPortDownload()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
CtIDirectMusicPortDownload::~CtIDirectMusicPortDownload(void)
{
    // nothing to do

} //*** emd CtIDirectMusicPortDownload::~CtIDirectMusicPortDownload()


//===========================================================================
// CtIDirectMusicPortDownload::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicPortDownload object pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmPortDl - pointer to real 
//                                      IDirectMusicPortDownload object
//
// Returns: 
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPortDownload::InitTestClass(IDirectMusicPortDownload *pdmPortDl)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmPortDl, sizeof(IDirectMusicPortDownload), FALSE))
	{
        m_pUnk = NULL;
//        m_pdmPortDl = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmPortDl));

/*
	// if we get here, we succeeded
	pdmPortDl->AddRef();
    m_pdmPortDl = pdmPortDl;
	return  S_OK;
*/
} //*** end CtIDirectMusicPortDownload::InitTestClass()


//===========================================================================
// CtIDirectMusicPortDownload::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicPortDownload **ppdmPortDl - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  11/17/1997 - davidkl - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicPortDownload::GetRealObjPtr(IDirectMusicPortDownload **ppdmPortDl)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmPortDl, sizeof(IDirectMusicPortDownload*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmPortDl));

/*
	// if we get here, return m_pdm
    *ppdmPortDl = m_pdmPortDl;
	((IDirectMusicPortDownload*)m_pUnk)->AddRef();
    return S_OK;
*/
} //*** end CtIDirectMusicPortDownload::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicPortDownload::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicPortDownload::QueryInterface(REFIID riid, 
                                                    LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

/*
    return tdmQueryInterface((IUnknown*)m_pdmPortDl,
                            (LPCTSTR)m_szInterfaceName,
                            riid,
                            ppvObj);
*/
} //*** end CtIDirectMusicPortDownload::QueryInterface()


//===========================================================================
// CtIDirectMusicPortDownload::AddRef
//
// Encapsulates calls to AddRef
//
// Parameters:
//
// Returns:
//  DWORD - new reference count
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
/*
DWORD CtIDirectMusicPortDownload::AddRef(void)
{

    // increment our object's refcount
    m_dwRefCount++;

    // call the real AddRef
    tdmAddRef((IUnknown*)m_pdmPortDl, (LPCTSTR)m_szInterfaceName);

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicPortDownload::AddRef()
*/

//===========================================================================
// CtIDirectMusicPortDownload::Release
//
// Encapsulates calls to Release
//
// Parameters:
//
// Returns:
//  DWORD - new reference count
//
// History:
//  11/17/1997 - davidkl - created
//===========================================================================
/*
DWORD CtIDirectMusicPortDownload::Release(void)
{

    // decrement our object's refcount
    m_dwRefCount--;

    // call the real Release
    tdmRelease((IUnknown*)m_pdmPortDl, (LPCTSTR)m_szInterfaceName);

    // clean ourselves up
    if(0 >= m_dwRefCount)
    {
        delete this;
    }

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicPortDl::Release()
*/


//===========================================================================
// CtIDirectMusicPortDownload::GetBuffer
//
// Encapsulates calls to CtIDirectMusicPortDownload::GetBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetBuffer
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - modified to pass a wrapped version of IDMDownload
//  03/30/1998 - davidkl - fixed logging
//===========================================================================
DWORD CtIDirectMusicPortDownload::GetBuffer(DWORD dwId, 
                                    CtIDirectMusicDownload **pptdmDownload)
{
    HRESULT                 hRes					= E_NOTIMPL;
    BOOL                    fValid_pptdmDownload    = TRUE;
    IDirectMusicDownload    *pdmDL                  = NULL;
    IDirectMusicDownload    **ppdmDL                = NULL;
    
    // validate pptdmDownload
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicDownload pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPortDownload::GetBuffer().  Otherwise, we are to create and
    //  return a CtIDirectMusicDownload object
    if(!helpIsValidPtr((void*)pptdmDownload, sizeof(CtIDirectMusicDownload*),
                        FALSE))
    {
        fValid_pptdmDownload   = FALSE;

        // we have a bogus pointer, use it as such
        ppdmDL = (IDirectMusicDownload**)pptdmDownload;
    }
    else
    {
        // valid pointer, we need to use a real object
        ppdmDL = &pdmDL;

        // just in case we fail, init test object ptr to NULL
        *pptdmDownload = NULL;

    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwId         == %08Xh",
			dwId);
	// note, pIDMDownload is really a **
    fnsLog(PARAMLOGLEVEL, "pIDMDownload == %p   %s",
            ppdmDL,
            (fValid_pptdmDownload) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->GetBuffer(dwId, ppdmDL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmDownload)
    {
    	// note, pIDMDownload is really a **
        fnsLog(PARAMLOGLEVEL, "*pIDMDownload == %p",
            pdmDL);       
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmDL, pptdmDownload);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmDownload && pdmDL)
    {
        pdmDL->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPortDownload::GetBuffer()


//===========================================================================
// CtIDirectMusicPortDownload::AllocateBuffer
//
// Encapsulates calls to CtIDirectMusicPortDownload::AllocateBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to AllocateBuffer
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - modified to pass a wrapped version of IDMDownload
//  03/30/1998 - davidkl - fixed logging
//===========================================================================
DWORD CtIDirectMusicPortDownload::AllocateBuffer(DWORD dwSize, 
                                        CtIDirectMusicDownload **pptdmDownload)
{
    HRESULT                 hRes					= E_NOTIMPL;
    BOOL                    fValid_pptdmDownload    = TRUE;
    IDirectMusicDownload    *pdmDL                  = NULL;
    IDirectMusicDownload    **ppdmDL                = NULL;
    
    // validate pptdmDownload
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicDownload pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPortDownload::AllocateBuffer().  Otherwise, we are to 
    //  create and return a CtIDirectMusicDownload object
    if(!helpIsValidPtr((void*)pptdmDownload, sizeof(CtIDirectMusicDownload*),
                        FALSE))
    {
        fValid_pptdmDownload   = FALSE;

        // we have a bogus pointer, use it as such
        ppdmDL = (IDirectMusicDownload**)pptdmDownload;
    }
    else
    {
        // valid pointer, we need to use a real object
        ppdmDL = &pdmDL;

        // just in case we fail, init test object ptr to NULL
        *pptdmDownload = NULL;

    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AllocateBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwSize == %08Xh",
            dwSize);
	// note, pIDMDownload is really a **
    fnsLog(PARAMLOGLEVEL, "pIDMDownload == %p   %s",
            ppdmDL,
            (fValid_pptdmDownload) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->AllocateBuffer(dwSize, ppdmDL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AllocateBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmDownload)
    {
    	// note, pIDMDownload is really a **
        fnsLog(PARAMLOGLEVEL, "*pIDMDownload == %p",
            pdmDL);       
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmDL, pptdmDownload);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmDownload && pdmDL)
    {
        pdmDL->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPortDownload::AllocateBuffer()


//===========================================================================
// CtIDirectMusicPortDownload::FreeBuffer
//
// Encapsulates calls to CtIDirectMusicPortDownload::FreeBuffer
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to FreeBuffer
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - modified to pass a wrapped version of IDMDownload
//  03/30/1998 - davidkl - fixed logging
//  05/11/1998 - davidkl - Removed to reflect interface change
//===========================================================================
/* 
DWORD CtIDirectMusicPortDownload::FreeBuffer(CtIDirectMusicDownload *ptdmDownload)
{
    HRESULT                 hRes				= E_NOTIMPL;
    BOOL                    fValid_ptdmDownload	= TRUE;
    IDirectMusicDownload    *pdmDL              = NULL;
    
    // validate ptdmDownload
    if(!helpIsValidPtr((void*)ptdmDownload, sizeof(CtIDirectMusicDownload),
                        FALSE))
    {
        fValid_ptdmDownload   = FALSE;

        // we have a bogus pointer, use it as such
        pdmDL = (IDirectMusicDownload*)ptdmDownload;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = ptdmDownload->GetRealObjPtr(&pdmDL);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::FreeBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pIDMDownload == %p   %s",
            pdmDL,
            fValid_ptdmDownload ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->FreeBuffer(pdmDL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::FreeBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(pdmDL)
    {
        pdmDL->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPortDownload::FreeBuffer()
*/


//===========================================================================
// CtIDirectMusicPortDownload::GetDLId
//
// Encapsulates calls to CtIDirectMusicPortDownload::GetDLId
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetDLId
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - fixed logging bugs and added pointer validation
//  03/30/1998 - davidkl - fixed logging (for real this time :)
//===========================================================================
DWORD CtIDirectMusicPortDownload::GetDLId(DWORD *pdwStartDLId, DWORD dwCount)
{
    HRESULT hRes				= E_NOTIMPL;   
    BOOL    fValid_dwStartDLId	= TRUE;
 
    // validate dwStartDLId
    if(!helpIsValidPtr((void*)pdwStartDLId, sizeof(DWORD),
                        FALSE))
    {
        fValid_dwStartDLId  = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDLId()",
            m_szInterfaceName);
    // NOTE dwStartDLId is a *
    fnsLog(PARAMLOGLEVEL, "pdwStartDLId == %p   %s",
            pdwStartDLId,
            (fValid_dwStartDLId) ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwCount == %08Xh",
            dwCount);

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->GetDLId(pdwStartDLId, dwCount);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDLId()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes         == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_dwStartDLId)
    {
        // NOTE dwStartDLId is a *
        fnsLog(PARAMLOGLEVEL, "*pdwStartDLId == %08Xh",
                *pdwStartDLId);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPortDownload::GetDLId()


//===========================================================================
// CtIDirectMusicPortDownload::GetAppend
//
// Encapsulates calls to CtIDirectMusicPortDownload::GetAppend
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to GetAppend
//
// History:
//	10/13/1998 - a-trevg - created
//===========================================================================
DWORD CtIDirectMusicPortDownload::GetAppend(DWORD* pdwAppend)
{
    HRESULT	hRes	= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwAppend == %08Xh",
            pdwAppend);

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->GetAppend(pdwAppend);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	fnsLog(PARAMLOGLEVEL, "*pdwAppend == %08Xh",
            *pdwAppend);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPortDownload::Download()


//===========================================================================
// CtIDirectMusicPortDownload::Download
//
// Encapsulates calls to CtIDirectMusicPortDownload::Download
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Download
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - modified to pass a wrapped version of IDMDownload
//  03/30/1998 - davidkl - fixed logging
//===========================================================================
DWORD CtIDirectMusicPortDownload::Download(CtIDirectMusicDownload* ptdmDownload)
{
    HRESULT                 hRes				= E_NOTIMPL;
    BOOL                    fValid_ptdmDownload	= TRUE;
    IDirectMusicDownload    *pdmDL              = NULL;
    
    // validate ptdmDownload
    if(!helpIsValidPtr((void*)ptdmDownload, sizeof(CtIDirectMusicDownload),
                        FALSE))
    {
        fValid_ptdmDownload   = FALSE;

        // we have a bogus pointer, use it as such
        pdmDL = (IDirectMusicDownload*)ptdmDownload;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = ptdmDownload->GetRealObjPtr(&pdmDL);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pIDMDownload == %p   %s",
            pdmDL,
            fValid_ptdmDownload ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->Download(pdmDL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmDownload && pdmDL)
    {
        pdmDL->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPortDownload::Download()


//===========================================================================
// CtIDirectMusicPortDownload::Unload
//
// Encapsulates calls to CtIDirectMusicPortDownload::Unload
//
// Parameters:
//
// Returns:
//  HRESULT - return code from actual call to Unload
//
// History:
//  12/23/1997 - a-llucar - created
//  03/03/1998 - davidkl - modified to pass a wrapped version of IDMDownload
//  03/30/1998 - davidkl - fixed logging
//===========================================================================
DWORD CtIDirectMusicPortDownload::Unload(CtIDirectMusicDownload* ptdmDownload)
{
    HRESULT                 hRes				= E_NOTIMPL;
    BOOL                    fValid_ptdmDownload	= TRUE;
    IDirectMusicDownload    *pdmDL              = NULL;
    
    // validate ptdmDownload
    if(!helpIsValidPtr((void*)ptdmDownload, sizeof(CtIDirectMusicDownload),
                        FALSE))
    {
        fValid_ptdmDownload   = FALSE;

        // we have a bogus pointer, use it as such
        pdmDL = (IDirectMusicDownload*)ptdmDownload;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = ptdmDownload->GetRealObjPtr(&pdmDL);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pIDMDownload == %p   %s",
            pdmDL,
            fValid_ptdmDownload ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPortDownload*)m_pUnk)->Unload(pdmDL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmDownload && pdmDL)
    {
        pdmDL->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPortDownload::Unload()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctscripterr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctscripterr.cpp
//
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
// ctscripterr.cpp
//
// Test harness implementation of IDirectMusicScriptError
//
// Functions:
//    CtIDirectMusicScriptError::CtIDirectMusicScriptError()
//    CtIDirectMusicScriptError::~CtIDirectMusicScriptError()
//    CtIDirectMusicScriptError::InitTestClass()
//    CtIDirectMusicScriptError::GetRealObjPtr()
//  IUnknown
//    CtIDirectMusicScriptError::QueryInterface()
//
//    CtIDirectMusicScriptError::GetError()
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================


#if 0 //  Removed will clean up later

#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicScriptError::CtIDirectMusicScriptError()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
CtIDirectMusicScriptError::CtIDirectMusicScriptError()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicScriptError";

} //*** end CtIDirectMusicScriptError::CtIDirectMusicScriptError()




//===========================================================================
// CtIDirectMusicScriptError::~CtIDirectMusicScriptError()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
CtIDirectMusicScriptError::~CtIDirectMusicScriptError(void)
{
    // nothing to do

} //*** emd CtIDirectMusicScriptError::~CtIDirectMusicScriptError()




//===========================================================================
// CtIDirectMusicScriptError::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicScriptError object pointer for future use.
//
// Parameters:
//  CtIDirectMusicScriptError    *pdmScriptError    - pointer to real IDirectMusicScriptError object
//
// Returns: 
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScriptError::InitTestClass(IDirectMusicScriptError *pdmScriptError)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmScriptError, sizeof(IDirectMusicScriptError), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmScriptError));

} //*** end CtIDirectMusicScriptError::InitTestClass()




//===========================================================================
// CtIDirectMusicScriptError::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicScriptError **ppdmScriptError - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScriptError::GetRealObjPtr(IDirectMusicScriptError **ppdmScriptError)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmScriptError, sizeof(IDirectMusicScriptError*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmScriptError));

} //*** end CtIDirectMusicScriptError::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicScriptError::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScriptError::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicScriptError::QueryInterface()




//===========================================================================
// CtIDirectMusicScript::GetError()
//
// Encapsulates calls to Init
//
// History:
//  10/26/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicScriptError::GetError(DMUS_SCRIPT_ERRORINFO *pErrorInfo)
{
    HRESULT                 hRes				= E_NOTIMPL;
    BOOL				    fValid_pErrorInfo	= TRUE;

    // validate pPMSG
    if(!helpIsValidPtr((void*)pErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO), FALSE))
    {
        fValid_pErrorInfo = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetError()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pErrorInfo == %p   %s",
            pErrorInfo,
            fValid_pErrorInfo ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicScriptError*)m_pUnk)->GetError(pErrorInfo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetError()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicScriptError::GetError()






#endif // #if 0


//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctstyle.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctstyle.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctstyle.cpp
//
// Test harness implementation of IDirectMusicStyle
//
// Functions:
//  CtIDirectMusicStyle::CtIDirectMusicStyle()
//  CtIDirectMusicStyle::~CtIDirectMusicStyle()
//  CtIDirectMusicStyle::InitTestClass()
//  CtIDirectMusicStyle::GetRealObjPtr()
//  CtIDirectMusicStyle::QueryInterface()
//  CtIDirectMusicStyle::GetBand()
//  CtIDirectMusicStyle::GetBandName()
//  CtIDirectMusicStyle::GetDefaultBand()
//  CtIDirectMusicStyle::GetMotifName()
//  CtIDirectMusicStyle::GetMotif()
//  CtIDirectMusicStyle::GetDefaultChordMap()
//  CtIDirectMusicStyle::GetChordMapName()
//  CtIDirectMusicStyle::GetChordMap()
//  CtIDirectMusicStyle::GetTimeSignature()
//  CtIDirectMusicStyle::GetEmbellishmentLength()
//  CtIDirectMusicStyle::GetTempo()
//
// History:
//  01/02/1998 - a-llucar - created
//  01/10/1998 - a-llucar - updated GetBand()
//	01/10/1998 - a-llucar - added GetBandName(), GetDefaultChordMap(),
//							GetChordMapName(), GetChordMap()
//  03/31/1998 - davidkl - inheritance update
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicStyle::CtIDirectMusicStyle()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicStyle::CtIDirectMusicStyle(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicStyle";

} //*** end CtIDirectMusicStyle::CtIDirectMusicStyle()


//===========================================================================
// CtIDirectMusicStyle::~CtIDirectMusicStyle()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicStyle::~CtIDirectMusicStyle(void)
{
    // nothing to do

} //*** end CtIDirectMusicStyle::~CtIDirectMusicStyle()


//===========================================================================
// CtIDirectMusicStyle::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmStyle - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicStyle::InitTestClass(IDirectMusicStyle *pdmStyle)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmStyle, sizeof(IDirectMusicStyle), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmStyle));

} //*** end CtIDirectMusicStyle::InitTestClass()


//===========================================================================
// CtIDirectMusicStyle::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicStyle **ppdmStyle - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicStyle::GetRealObjPtr(IDirectMusicStyle **ppdmStyle)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmStyle, sizeof(IDirectMusicStyle*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmStyle));

} //*** end CtIDirectMusicStyle::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicStyle::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicStyle::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::QueryInterface


//===========================================================================
// CtIDirectMusicStyle::GetBand()
//
// Encapsulates calls to GetBand
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetBand(WCHAR *pwszName, 
                                    CtIDirectMusicBand** pptdmBand)
{
    HRESULT             hRes			    = E_NOTIMPL;
    BOOL				fValid_pptdmBand	= TRUE;
    BOOL                fValid_pwszName     = TRUE;
    IDirectMusicBand    *pdmBand            = NULL;
    IDirectMusicBand    **ppdmBand          = NULL;
    
    // validate pptdmBand
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicBand pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicStyle::GetBand().  Otherwise, we are to create and
    //  return a CtIDirectMusicBand object
    if(!helpIsValidPtr((void*)pptdmBand, sizeof(CtIDirectMusicBand*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmBand = FALSE;
        ppdmBand = (IDirectMusicBand**)pptdmBand;

    }
    else
    {
        // valid pointer, create a real object
        ppdmBand = &pdmBand;

        // just in case we fail, init test object ptr to NULL
        *pptdmBand = NULL;
    }

    // validate wszName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszName == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");
    if(fValid_pwszName)
    {
        // BUGBUG - convert and log string
    }
    fnsLog(PARAMLOGLEVEL, "ppBand   == %p   %s",
            ppdmBand,
            fValid_pptdmBand ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetBand(pwszName, ppdmBand);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmBand)
    {
        fnsLog(PARAMLOGLEVEL, "*ppBand == %p",
            pdmBand);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmBand, pptdmBand);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmBand && pdmBand)
    {
        pdmBand->Release();
    }
    return hRes;

} //*** end CtIDirectMusicStyle::GetBand()


//===========================================================================
// CtIDirectMusicStyle::EnumBand()
//
// Encapsulates calls to EnumBand
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - dvaidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::EnumBand(DWORD dwIndex, WCHAR *pwszName)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL    fValid_pwszName = TRUE;
    
    // validate bstrName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex  == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pwszName == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->EnumBand(dwIndex, pwszName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pwszName)
    {
        // BUGBUG - convert and log string
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::EnumBand()


//===========================================================================
// CtIDirectMusicStyle::GetDefaultBand()
//
// Encapsulates calls to GetDefaultBand
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetDefaultBand(CtIDirectMusicBand** pptdmBand)
{
    HRESULT             hRes						= E_NOTIMPL;
    BOOL				fValid_pptdmBand	= TRUE;
    IDirectMusicBand    *pdmBand            = NULL;
    IDirectMusicBand    **ppdmBand          = NULL;
    
    // validate pptdmBand
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicBand pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicStyle::GetBand().  Otherwise, we are to create and
    //  return a CtIDirectMusicBand object
    if(!helpIsValidPtr((void*)pptdmBand, sizeof(CtIDirectMusicBand*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmBand = FALSE;
        ppdmBand = (IDirectMusicBand**)pptdmBand;

    }
    else
    {
        // valid pointer, create a real object
        ppdmBand = &pdmBand;

        // just in case we fail, init test object ptr to NULL
        *pptdmBand = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDefaultBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppBand == %p   %s",
            ppdmBand,
            fValid_pptdmBand ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetDefaultBand(ppdmBand);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDefaultBand()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes    == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmBand)
    {
        fnsLog(PARAMLOGLEVEL, "*ppBand == %p",
                pdmBand);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmBand, pptdmBand);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmBand && pdmBand)
    {
        pdmBand->Release();
    }
    return hRes;

} //*** end CtIDirectMusicStyle::GetDefaultBand()


//===========================================================================
// CtIDirectMusicStyle::EnumMotif()
//
// Encapsulates calls to EnumMotif
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - dvaidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::EnumMotif(DWORD dwIndex, WCHAR *pwszName)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL    fValid_pwszName	= TRUE;
    
    // validate pwszName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumMotif()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex  == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pwszName == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->EnumMotif(dwIndex, pwszName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumMotif()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pwszName)
    {
        // BUGBUG - convert and log string
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::EnumMotif()


//===========================================================================
// CtIDirectMusicStyle::GetMotif()
//
// Encapsulates calls to GetMotif
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetMotif(WCHAR *pwszName, 
							CtIDirectMusicSegment** pptdmSegment)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL				fValid_pptdmSegment	= TRUE;
    BOOL                fValid_pwszName	    = TRUE;
    IDirectMusicSegment *pdmSeg             = NULL;
    IDirectMusicSegment **ppdmSeg           = NULL;
    
    // validate pptdmSegment
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegment pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicStyle::GetMotif().  Otherwise, we are to create and
    //  return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmSegment, sizeof(CtIDirectMusicSegment*), 
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmSegment = FALSE;
        ppdmSeg = (IDirectMusicSegment**)pptdmSegment;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSeg = &pdmSeg;

        // just in case we fail, init test object ptr to NULL
        *pptdmSegment = NULL;
    }
   
    // validate pwszName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMotif()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszName  == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");
    if(fValid_pwszName)
    {
        // BUGBUG convert and log string
    }
    fnsLog(PARAMLOGLEVEL, "ppSegment == %p   %s",
            ppdmSeg,
            fValid_pptdmSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetMotif(pwszName, ppdmSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMotif()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
                pdmSeg);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSeg, pptdmSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmSegment && pdmSeg)
    {
        pdmSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicStyle::GetMotif()


//===========================================================================
// CtIDirectMusicStyle::GetDefaultChordMap()
//
// Encapsulates calls to GetDefaultChordMap
//
// History:
//  01/11/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetDefaultChordMap
                                (CtIDirectMusicChordMap** pptdmChordMap)
{
    HRESULT                 hRes					= E_NOTIMPL;
    BOOL				    fValid_pptdmChordMap	= TRUE;
    IDirectMusicChordMap *pdmPers                = NULL;
    IDirectMusicChordMap **ppdmPers              = NULL;
    
    // validate pptdmChordMap
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicChordMap pointer, 
    //  we assume that we are to perform an invalid parameter test on
    //  IDirectMusicStyle::GetDefaultChordMap().  Otherwise, we are to 
    //  create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmChordMap, 
                        sizeof(CtIDirectMusicChordMap*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmChordMap = FALSE;
        ppdmPers = (IDirectMusicChordMap**)pptdmChordMap;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPers = &pdmPers;

        // just in case we fail, init test object ptr to NULL
        *pptdmChordMap = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetDefaultChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppChordMap == %p   %s",
            ppdmPers,
            fValid_pptdmChordMap ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetDefaultChordMap(ppdmPers);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetDefaultChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmChordMap)
    {
        fnsLog(PARAMLOGLEVEL, "*ppChordMap == %p",
                pdmPers);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmPers, pptdmChordMap);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }


    fnsDecrementIndent();

    // done
    if(fValid_pptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    return hRes;

} //*** end CtIDirectMusicStyle::GetDefaultChordMap()


//===========================================================================
// CtIDirectMusicStyle::EnumChordMap()
//
// Encapsulates calls to EnumChordMap
//
// History:
//  01/11/1998 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::EnumChordMap(DWORD dwIndex, WCHAR *pwszName)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL    fValid_pwszName	= TRUE;
    
    // validate pwszName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex  == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pwszName == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->EnumChordMap(dwIndex, pwszName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pwszName)
    {
        // BUGBUG convert and log string
    }

    fnsDecrementIndent();

    // done
    return hRes;


} //*** end CtIDirectMusicStyle::EnumChordMap()


//===========================================================================
// CtIDirectMusicStyle::GetChordMap()
//
// Encapsulates calls to GetChordMap
//
// History:
//  01/11/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetChordMap(WCHAR *pwszName, 
								    CtIDirectMusicChordMap** pptdmChordMap)
{
    HRESULT                 hRes					= E_NOTIMPL;
    BOOL				    fValid_pptdmChordMap	= TRUE;
    BOOL                    fValid_pwszName	        = TRUE;
    IDirectMusicChordMap *pdmPers                = NULL;
    IDirectMusicChordMap **ppdmPers              = NULL;
    
    // validate pwszName
    if(!helpIsValidPtr((void*)pwszName, sizeof(WCHAR), FALSE))
    {
        fValid_pwszName	= FALSE;
    }
    
    // validate pptdmChordMap
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicChordMap pointer, 
    //  we assume that we are to perform an invalid parameter test on
    //  IDirectMusicStyle::GetDefaultChordMap().  Otherwise, we are to 
    //  create and return a CtIDirectMusicSegment object
    if(!helpIsValidPtr((void*)pptdmChordMap, 
                        sizeof(CtIDirectMusicChordMap*), FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmChordMap = FALSE;
        ppdmPers = (IDirectMusicChordMap**)pptdmChordMap;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPers = &pdmPers;

        // just in case we fail, init test object ptr to NULL
        *pptdmChordMap = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pwszName      == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");
    if(fValid_pwszName)
    {
        // BUGBUG convert and log string
    }
    fnsLog(PARAMLOGLEVEL, "ppChordMap == %p   %s",
            ppdmPers,
            fValid_pptdmChordMap ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetChordMap(pwszName, ppdmPers);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetChordMap()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmChordMap)
    {
        fnsLog(PARAMLOGLEVEL, "*ppChordMap == %p",
                pdmPers);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmPers, pptdmChordMap);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmChordMap && pdmPers)
    {
        pdmPers->Release();
    }
    return hRes;


} //*** end CtIDirectMusicStyle::GetChordMap()


//===========================================================================
// CtIDirectMusicStyle::GetTimeSignature()
//
// Encapsulates calls to GetTimeSignature
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - updated to new dm, fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetTimeSignature(DMUS_TIMESIGNATURE* pTimeSig)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pTimeSig = TRUE;

    // validate pTimeSig
    if(!helpIsValidPtr((void*)pTimeSig, sizeof(DMUS_TIMESIGNATURE), FALSE))
    {
        fValid_pTimeSig = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTimeSignature()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTimeSig == %p   %s",
            pTimeSig,
            fValid_pTimeSig ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetTimeSignature(pTimeSig);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTimeSignature()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pTimeSig)
    {
        // BUGBUG log contents of pTimeSig @ STRUCTLOGLEVEL
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::GetTimeSignature()


//===========================================================================
// CtIDirectMusicStyle::GetEmbellishmentLength()
//
// Encapsulates calls to GetEmbellishmentLength
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetEmbellishmentLength(BYTE bType, BYTE bLevel,
                                                DWORD* pdwMin, DWORD* pdwMax)
{
    HRESULT hRes			= E_NOTIMPL;
    BOOL	fValid_pdwMin   = TRUE;
	BOOL	fValid_pdwMax	= TRUE;
    
    // validate pdwMin
    if(!helpIsValidPtr((void*)pdwMin, sizeof(DWORD), FALSE))
    {
        fValid_pdwMin = FALSE;
    }

    // validate pwMax
    if(!helpIsValidPtr((void*)pdwMax, sizeof(DWORD), FALSE))
    {
        fValid_pdwMax = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetEmbellishmentLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "bType  == %08Xh",
            bType);
    fnsLog(PARAMLOGLEVEL, "bLevel == %08Xh",
            bLevel);
    fnsLog(PARAMLOGLEVEL, "pdwMin == %p   %s",
            pdwMin,
            fValid_pdwMin ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwMax == %p   %s",
            pdwMax,
            fValid_pdwMax ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetEmbellishmentLength(bType, bLevel, pdwMin, pdwMax);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetEmbellishmentLength()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes   == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwMin)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwMin == %08Xh",
                *pdwMin);
    }
    if(fValid_pdwMax)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwMax == %08Xh",
                *pdwMax);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::GetEmbellishmentLength()


//===========================================================================
// CtIDirectMusicStyle::GetTempo()
//
// Encapsulates calls to GetTempo
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicStyle::GetTempo(double* pTempo)
{
    HRESULT hRes			= E_NOTIMPL;
	BOOL	fValid_pTempo	= TRUE;
    
    // validate pTempo
    if(!helpIsValidPtr((void*)pTempo, sizeof(double), FALSE))
    {
        fValid_pTempo = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTempo()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pTempo == %p   %s",
            pTempo,
            fValid_pTempo ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle*)m_pUnk)->GetTempo(pTempo);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTempo()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pTempo)
    {
        // BUGBUG log *pTempo
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicStyle::GetTempo()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctstyle8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctstyle8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctstyle8.cpp
//
// Test harness implementation of IDirectMusicStyle8
//
// Functions:
//  CtIDirectMusicStyle8::EnumPattern()
//	CtIDirectMusicStyle8::ComposeMelodyFromTemplate()
//
//
// History:
//  10/15/1999 - kcraven - created
//  04/06/2000 - danhaff - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicStyle8::CtIDirectMusicStyle8()
//
// Default constructor
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
CtIDirectMusicStyle8::CtIDirectMusicStyle8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicStyle8";

} // *** end CtIDirectMusicStyle8::CtIDirectMusicStyle8()




//===========================================================================
// CtIDirectMusicStyle8::~CtIDirectMusicStyle8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
CtIDirectMusicStyle8::~CtIDirectMusicStyle8(void)
{
    // nothing to do

} // *** end CtIDirectMusicStyle8::~CtIDirectMusicStyle8()




//===========================================================================
// CtIDirectMusicStyle8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicStyle8 pointer for future use.
//
// Parameters:
//  IDirectMusicStyle8 *pdmStyle8 - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicStyle8::InitTestClass(IDirectMusicStyle8 *pdmStyle8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmStyle8, sizeof(IDirectMusicStyle8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmStyle8));

} // *** end CtIDirectMusicStyle8::InitTestClass()




//===========================================================================
// CtIDirectMusicStyle8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicStyle8 **ppdmStyle8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicStyle8::GetRealObjPtr(IDirectMusicStyle8 **ppdmStyle8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmStyle8, sizeof(IDirectMusicStyle8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmStyle8));

} // *** end CtIDirectMusicStyle8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicStyle8::EnumPattern()
//
// Encapsulates calls to EnumPattern
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicStyle8::EnumPattern(DWORD dwIndex,DWORD dwPatternType,WCHAR* pwszName)
{
    HRESULT hRes			= E_NOTIMPL;
	BOOL	fValid_pwszName	= TRUE;
    
    // validate pTempo
    if(!helpIsValidPtr((void*)pwszName, sizeof(double), FALSE))
    {
        fValid_pwszName = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumPattern()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwIndex        == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "dwPatternType  == %08Xh",
            dwPatternType);
    fnsLog(PARAMLOGLEVEL, "pwszName       == %p   %s",
            pwszName,
            fValid_pwszName ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle8*)m_pUnk)->EnumPattern(dwIndex,dwPatternType,pwszName);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumPattern()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(SUCCEEDED(hRes) && fValid_pwszName && (hRes != S_FALSE) && (wcslen(pwszName) > 0))
	{
	    fnsLog(PARAMLOGLEVEL, "pwszName == %ls",pwszName);
	}

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicStyle8::EnumPattern()




//===========================================================================
// CtIDirectMusicStyle8::ComposeMelodyFromTemplate()
//
// Encapsulates calls to ComposeMelodyFromTemplate
//
// History:
//  01/02/1998 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//===========================================================================
/*
HRESULT CtIDirectMusicStyle8::ComposeMelodyFromTemplate
(
	CtIDirectMusicStyle* pStyle, 
	CtIDirectMusicSegment* pTemplate, 
	CtIDirectMusicSegment** ppSegment
)
{
    HRESULT                 hRes				= E_NOTIMPL;
	BOOL				    fValid_pStyle		= TRUE;
    BOOL				    fValid_pTemplate	= TRUE;
	BOOL				    fValid_ppSegment	= TRUE;
    IDirectMusicStyle*		pdmStyle			= NULL;
    IDirectMusicSegment*	pdmTemplate			= NULL;
    IDirectMusicSegment*	pdmSegment			= NULL;
    IDirectMusicSegment**	ppdmSegment			= NULL;

    // validate pStyle
    if(!helpIsValidPtr((void*)pStyle, sizeof(CtIDirectMusicStyle), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pStyle = FALSE;
        pdmStyle = (IDirectMusicStyle*)pStyle;

    }
    else
    {
        // good pointer, get the real object
        hRes = pStyle->GetRealObjPtr(&pdmStyle);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pTemplate
    if(!helpIsValidPtr((void*)pTemplate, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pTemplate = FALSE;
        pdmTemplate = (IDirectMusicSegment*)pTemplate;

    }
    else
    {
        // good pointer, get the real object
        hRes = pTemplate->GetRealObjPtr(&pdmTemplate);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppSegment
    if(!helpIsValidPtr((void*)ppSegment, sizeof(CtIDirectMusicSegment*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppSegment = FALSE;
        ppdmSegment = (IDirectMusicSegment**)ppSegment;

    }
    else
    {
        // valid pointer, create a real object
        ppdmSegment = &pdmSegment;

        // just in case we fail, init test object ptr to NULL
        *ppSegment = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ComposeMelodyFromTemplate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStyle    == %p   %s",
            pdmStyle,
            fValid_pStyle ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pTemplate == %p   %s",
            pdmTemplate,
            fValid_pTemplate ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppSegment == %p   %s",
            ppdmSegment,
            fValid_ppSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicStyle8*)m_pUnk)->ComposeMelodyFromTemplate(pdmStyle,pdmTemplate,ppdmSegment);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ComposeMelodyFromTemplate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
                pdmSegment);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSegment, ppSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_pStyle && pdmStyle)
    {
        pdmStyle->Release();
    }
    if(fValid_pTemplate && pdmTemplate)
    {
        pdmTemplate->Release();
    }
    if(fValid_ppSegment && pdmSegment)
    {
        pdmSegment->Release();
    }
    return hRes;

} // *** end CtIDirectMusicStyle8::ComposeMelodyFromTemplate()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctsong.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctsong.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsong.cpp
//
// Test harness implementation of IDirectMusicSong
//
// Functions:
//  CtIDirectMusicSong::CtIDirectMusicSong()
//  CtIDirectMusicSong::~CtIDirectMusicSong()
//  CtIDirectMusicSong::InitTestClass()
//  CtIDirectMusicSong::GetRealObjPtr()
//  CtIDirectMusicSong::QueryInterface()
//  CtIDirectMusicSong::Compose() 
//  CtIDirectMusicSong::GetParam() 
//  CtIDirectMusicSong::EnumSegment()
//  CtIDirectMusicSong::Clone()
//  CtIDirectMusicSong::GetAudioPathConfig()
//  CtIDirectMusicSong::Download()
//  CtIDirectMusicSong::Unload()
//
// History:
//  10/25/1999 - kcraven - created
//  04/06/2000 - danhaff - removed EnumSegment as per dmusic header changes.
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicSong::CtIDirectMusicSong()
//
// Default constructor
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSong::CtIDirectMusicSong(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSong";

} //*** end CtIDirectMusicSong::CtIDirectMusicSong()


//===========================================================================
// CtIDirectMusicSong::~CtIDirectMusicSong()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSong::~CtIDirectMusicSong(void)
{
    // nothing to do

} //*** end CtIDirectMusicSong::~CtIDirectMusicSong()


//===========================================================================
// CtIDirectMusicSong::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicSong *pdmSong - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::InitTestClass(IDirectMusicSong *pdmSong)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSong, sizeof(IDirectMusicSong), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSong));

} //*** end CtIDirectMusicSong::InitTestClass()


//===========================================================================
// CtIDirectMusicSong::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicSong **ppdmSong - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::GetRealObjPtr(IDirectMusicSong **ppdmSong)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSong, sizeof(IDirectMusicSong*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSong));

} //*** end CtIDirectMusicSong::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicSong::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicSong::QueryInterface()




//===========================================================================
// CtIDirectMusicSong::Compose()
//
// Encapsulates calls to Compose
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::Compose(void)
{
    HRESULT		hRes				= E_NOTIMPL;
 
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Compose()",
			m_szInterfaceName);
	
    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->Compose();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} //*** end CtIDirectMusicSong::Compose()




//===========================================================================
// CtIDirectMusicSong::GetParam()
//
// Encapsulates calls to GetParam
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::GetParam
(
	REFGUID rguidType, 
	DWORD dwGroupBits, 
	DWORD dwIndex, 
	MUSIC_TIME mtTime, 
	MUSIC_TIME* pmtNext, 
	void* pParam
)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL	fValid_pmtNext		= TRUE;
    BOOL	fValid_pParam		= TRUE;
    char    szGuid[MAX_LOGSTRING];


    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtNext = FALSE;
    }

    // validate pData
    if(!helpIsValidPtr((void*)pParam, 1, FALSE))
    {
        fValid_pParam = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType   == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
	fnsLog(PARAMLOGLEVEL, "dwGroupBits == %08Xh",
			dwGroupBits);
	fnsLog(PARAMLOGLEVEL, "dwIndex     == %08Xh",
			dwIndex);
    fnsLog(PARAMLOGLEVEL, "mtTime      == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "pmtNext     == %p   %s",
            pmtNext,
            fValid_pmtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pParam      == %p   %s",
            pParam,
            fValid_pParam ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->GetParam(
											rguidType, 
											dwGroupBits, 
											dwIndex, 
											mtTime, 
											pmtNext, 
											pParam
										);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    // BUGBUG want to log out params

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSong::GetParam()





//===========================================================================
// CtIDirectMusicSong::EnumSegment()
//
// Encapsulates calls to EnumSegment
//
// History:
//  10/25/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSong::EnumSegment
(
	DWORD dwIndex, 
	CtIDirectMusicSegment **ppSegment
)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_ppSegment		= TRUE;
	IDirectMusicSegment*	pdmSegment	= NULL;
	IDirectMusicSegment**	ppdmSegment = NULL;
    char    szGuid[MAX_LOGSTRING];

    if(!helpIsValidPtr((void*)ppSegment, sizeof(CtIDirectMusicSegment*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppSegment = FALSE;
        ppdmSegment = (IDirectMusicSegment**)ppSegment;
    }
    else
    {
        // valid pointer, create a real object
        ppdmSegment = &pdmSegment;

        // just in case we fail, init test object ptr to NULL
        *ppSegment = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EnumSegment()",
			m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
			dwIndex);
    fnsLog(PARAMLOGLEVEL, "ppSegment    == %p   %s",
            ppdmSegment,
            (fValid_ppSegment) ? "" : "BAD");
	
    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->EnumSegment(
				dwIndex, 
				ppdmSegment
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EnumSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppSegment)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppSegment == %p",
				pdmSegment);
	}
  
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSegment, ppSegment);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_ppSegment && pdmSegment)
    {
        pdmSegment->Release();
    }

    return hRes;

} //*** end CtIDirectMusicSong::EnumSegment()
*/

//===========================================================================
// CtIDirectMusicSong::Clone()
//
// Encapsulates calls to Clone
//
// History:
//  11/15/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSong::Clone(CtIDirectMusicSong **ppSong)
{
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_ppSong		= TRUE;
	IDirectMusicSong*	pdmSong		= NULL;
	IDirectMusicSong**	ppdmSong	= NULL;
 
    if(!helpIsValidPtr((void*)ppSong, sizeof(CtIDirectMusicSong*), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppSong = FALSE;
        ppdmSong = (IDirectMusicSong**)ppSong;
    }
    else
    {
        // valid pointer, create a real object
        ppdmSong = &pdmSong;

        // just in case we fail, init test object ptr to NULL
        *ppSong = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Clone()",
			m_szInterfaceName);
   fnsLog(PARAMLOGLEVEL, "ppSong == %p   %s",
            ppdmSong,
            (fValid_ppSong) ? "" : "BAD");
	
    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->Clone(ppdmSong);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppSong)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppdmSong == %p",
				pdmSong);
	}
  
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmSong, ppSong);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_ppSong && pdmSong)
    {
        pdmSong->Release();
    }

    return hRes;

} //*** end CtIDirectMusicSong::Clone()
*/



//===========================================================================
// CtIDirectMusicSong::GetAudioPathConfig()
//
// Encapsulates calls to GetAudioPathConfig
//
// History:
//  01/25/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig)
{
    HRESULT		hRes						= E_NOTIMPL;
    BOOL		fValid_ppIAudioPathConfig	= TRUE;
    IUnknown	*pdmIAudioPathConfig		= NULL;
    IUnknown	**ppdmIAudioPathConfig		= NULL;

    // validate ppIAudioPathConfig
    if(!helpIsValidPtr((void*)ppIAudioPathConfig, sizeof(CtIUnknown*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppIAudioPathConfig = FALSE;
        ppdmIAudioPathConfig = (IUnknown**)ppIAudioPathConfig;

    }
    else
    {
        // valid pointer, create a real object
        ppdmIAudioPathConfig = &pdmIAudioPathConfig;

        // just in case we fail, init test object ptr to NULL
        *ppIAudioPathConfig = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppIAudioPathConfig == %p   %s",
            ppdmIAudioPathConfig,
            (fValid_ppIAudioPathConfig) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->GetAudioPathConfig(ppdmIAudioPathConfig);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppIAudioPathConfig)
    {
        fnsLog(PARAMLOGLEVEL, "*ppIAudioPathConfig == %p",
                pdmIAudioPathConfig);
		// create the test object
		if(SUCCEEDED(hRes) && pdmIAudioPathConfig)
		{
			hRes = dmthCreateTestWrappedObject(pdmIAudioPathConfig, ppIAudioPathConfig);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
			}
		}
    }

    fnsDecrementIndent();

    // done
    if(fValid_ppIAudioPathConfig && pdmIAudioPathConfig)
    {
        pdmIAudioPathConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSong::GetAudioPathConfig()




//===========================================================================
// CtIDirectMusicSong::Download()
//
// Encapsulates calls to Download()
//
// History:
//  01/31/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::Download(CtIUnknown *pAudioPath)
{                                           
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IUnknown*	pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath,sizeof(CtIUnknown), FALSE))
    {
        fValid_pAudioPath = FALSE;
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->Download(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSong::Download()




//===========================================================================
// CtIDirectMusicSong::Unload()
//
// Encapsulates calls to Unload()
//
// History:
//  01/31/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSong::Unload(CtIUnknown *pAudioPath)
{                                           
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IUnknown*	pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, 
                    sizeof(CtIUnknown), FALSE))
    {
        fValid_pAudioPath = FALSE;
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->Unload(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL,  "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSong::Unload()


/*-----------------------------------------------------------------------------
|	Function:	
|	Purpose:	
|	Arguments:	
|	Returns:	
|	Notes:		
|	History:
|	04/28/2000 - ruswoods - created
\----------------------------------------------------------------------------*/
HRESULT CtIDirectMusicSong::GetSegment (WCHAR* pwzName, CtIDirectMusicSegment **ppSegment)
{
    HRESULT					hRes				= E_NOTIMPL;
    BOOL					fValid_ppSegment	= TRUE;
    IDirectMusicSegment*	pdmSegment			= NULL;

    // validate ppSegment
    if(!helpIsValidPtr((void*)ppSegment,sizeof(CtIDirectMusicSegment *), FALSE))
    {
        fValid_ppSegment = FALSE;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppSegment == %p   %s",
            ppSegment,
            fValid_ppSegment ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSong*)m_pUnk)->GetSegment(pwzName, ppSegment ? &pdmSegment : NULL);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetSegment()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

	if (pdmSegment)
	{
		hRes = dmthCreateTestWrappedObject (pdmSegment, ppSegment);
		if (FAILED (hRes))
		{
			fnsLog(CALLLOGLEVEL, TEXT("**** dmthCreateTestWrappedObject (pdmSegmentfailed! (%s == %08Xh)"),
				tdmXlatHRESULT(hRes), hRes);
			goto END;
		}

		pdmSegment->Release ();
	}

	hRes = S_OK;

    // done
END:
    return hRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctsynth8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctsynth8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsynth8.cpp
//
// Test harness implementation of IDirectMusicSynth8
//
// Functions:
//  CtIDirectMusicSynth8::CtIDirectMusicSynth8()
//  CtIDirectMusicSynth8::~CtIDirectMusicSynth8()
//  CtIDirectMusicSynth8::InitTestClass()
//  CtIDirectMusicSynth8::GetRealObjPtr()
//  CtIDirectMusicSynth8::QueryInterface()
//  CtIDirectMusicSynth8::Open()
//  CtIDirectMusicSynth8::Close()
//  CtIDirectMusicSynth8::SetNumChannelGroups()
//  CtIDirectMusicSynth8::Download()
//  CtIDirectMusicSynth8::Unload()
//  CtIDirectMusicSynth8::PlayBuffer()
//  CtIDirectMusicSynth8::GetRunningStats()
//  CtIDirectMusicSynth8::GetPortCaps()
//  CtIDirectMusicSynth8::SetMasterClock()
//  CtIDirectMusicSynth8::GetLatencyClock()
//  CtIDirectMusicSynth8::Activate()
//  CtIDirectMusicSynth8::Render()
//  CtIDirectMusicSynth8::SetSynthSink()
// DX8
//  CtIDirectMusicSynth8::PlayVoice()
//  CtIDirectMusicSynth8::StopVoice()
//  CtIDirectMusicSynth8::GetVoicePosition()
//  CtIDirectMusicSynth8::Refresh()
//  CtIDirectMusicSynth8::AssignChannelToBuses()

// History:
//  10/18/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicSynth8::CtIDirectMusicSynth8()
//
// Default constructor
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSynth8::CtIDirectMusicSynth8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSynth8";

} // *** end CtIDirectMusicSynth8::CtIDirectMusicSynth8()


//===========================================================================
// CtIDirectMusicSynth8::~CtIDirectMusicSynth8()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSynth8::~CtIDirectMusicSynth8(void)
{
    // nothing to do

} // *** end CtIDirectMusicSynth8::~CtIDirectMusicSynth8()


//===========================================================================
// CtIDirectMusicSynth8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmSynth - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::InitTestClass(IDirectMusicSynth8 *pdmSynth8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSynth8, sizeof(IDirectMusicSynth8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSynth8));

} // *** end CtIDirectMusicSynth8::InitTestClass()


//===========================================================================
// CtIDirectMusicSynth8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSynth8 **ppdmSynth - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetRealObjPtr(IDirectMusicSynth8 **ppdmSynth8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSynth8, sizeof(IDirectMusicSynth8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSynth8));

} // *** end CtIDirectMusicSynth8::GetRealObjPtr()

/*

//===========================================================================
// CtIDirectMusicSynth8::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::QueryInterface(REFIID riid,
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::QueryInterface


//===========================================================================
// CtIDirectMusicSynth8::Open()
//
// Encapsulates calls to Open()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Open(LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pPortParams	= TRUE;

    // validate pPortParams
    if(!helpIsValidPtr((void*)pPortParams, sizeof(DMUS_PORTPARAMS), TRUE))
    {
        fValid_pPortParams = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Open()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPortParams == %08Xh   %s",
            pPortParams,
            fValid_pPortParams ? "" : "BAD");
    if(fValid_pPortParams)
    {
        if(!pPortParams)
        {
	        // BUGBUG
            // log default port parameters
        }
        else
        {
	        // BUGBUG
            // log actual port parameters passed in
        }
    }

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Open(pPortParams);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Open()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Open()


//===========================================================================
// CtIDirectMusicSynth8::Close()
//
// Encapsulates calls to Close()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Close(void)
{
    HRESULT hRes     = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Close()",
            m_szInterfaceName);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Close();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Close()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Close()


//===========================================================================
// CtIDirectMusicSynth8::SetNumChannelGroups()
//
// Encapsulates calls to SetNumChannelGroups()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::SetNumChannelGroups(DWORD dwGroups)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwGroups == %08Xh",
            dwGroups);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->SetNumChannelGroups(dwGroups);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::SetNumChannelGroups()


//===========================================================================
// CtIDirectMusicSynth8::Download()
//
// Encapsulates calls to Download()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Download(LPHANDLE phDownload,
									  LPVOID pvData, LPBOOL pbFree)
{
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_phDownload	= TRUE;
    BOOL                fValid_pvData	    = TRUE;
	BOOL				fValid_pbFree		= TRUE;

    // validate phDownload
    if(!helpIsValidPtr((void*)phDownload, sizeof(LPHANDLE), FALSE))
    {
        fValid_phDownload = FALSE;
    }

	// validate pvData
    if(!helpIsValidPtr(pvData, sizeof(LPVOID), FALSE))
    {
        fValid_pvData = FALSE;
    }

	// validate pbFree
    if(!helpIsValidPtr(pbFree, sizeof(LPBOOL), FALSE))
    {
        fValid_pbFree = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "phDownload == %p   %s",
            phDownload,
            fValid_phDownload ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pvData == %p   %s",
            pvData,
            fValid_pvData ? "" : "BAD");
    if(fValid_pvData)
    {
        // BUGBUG - log contents of pvData @ MAX_LOGLEVEL (in byte format)
    }
	fnsLog(PARAMLOGLEVEL, "pbFree == %p   %s",
            pbFree,
            fValid_pbFree ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Download(phDownload, pvData, pbFree);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_phDownload)
    {
        fnsLog(PARAMLOGLEVEL, "*phDownload == %08Xh",
                *phDownload);
    }
    if(fValid_pbFree)
    {
        fnsLog(PARAMLOGLEVEL, "*pbFree     == %s",
                (*pbFree) ? "TRUE" : "FALSE");
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Download()


//===========================================================================
// CtIDirectMusicSynth8::Unload()
//
// Encapsulates calls to Unload()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Unload(HANDLE hDownload,
									HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
									HANDLE hUserData)
{
    HRESULT hRes = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hDownload == %08Xh",
            hDownload);
    // BUGBUG how to properly validate this??
    fnsLog(PARAMLOGLEVEL, "lpFreeHandle == %p",
            lpFreeHandle);
	fnsLog(PARAMLOGLEVEL, "hUserData == %08Xh",
            hUserData);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Unload(hDownload, lpFreeHandle, hUserData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Unload()


//===========================================================================
// CtIDirectMusicSynth8::PlayBuffer()
//
// Encapsulates calls to PlayBuffer()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::PlayBuffer(REFERENCE_TIME rt,
								  LPBYTE pbBuffer, DWORD cbBuffer)
{
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pbBuffer		= TRUE;

    // validate pbBuffer
    if(!helpIsValidPtr((void*)pbBuffer, cbBuffer, FALSE))
    {
        fValid_pbBuffer = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "pbBuffer == %p   %s",
            pbBuffer,
            fValid_pbBuffer ? "" : "BAD");
    if(fValid_pbBuffer)
    {
        // BUGBUG log contents of pbBuffer @ MAXLOGLEVEL (as bytes)
    }
    fnsLog(PARAMLOGLEVEL, "cbBuffer == %08Xh",
            cbBuffer);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->PlayBuffer(rt, pbBuffer, cbBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::PlayBuffer()


//===========================================================================
// CtIDirectMusicSynth8::GetRunningStats()
//
// Encapsulates calls to GetRunningStats()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetRunningStats(LPDMUS_SYNTHSTATS pStats)
{
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pStats		= TRUE;

    // validate pStats
    if(!helpIsValidPtr((void*)pStats, sizeof(DMUS_SYNTHSTATS), FALSE))
    {
        fValid_pStats = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStats == %p   %s",
            pStats,
            fValid_pStats ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetRunningStats(pStats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pStats)
    {
        // BUGBUG log contents of pStats (STRUCTLOGLEVEL)
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::GetRunningStats()


//===========================================================================
// CtIDirectMusicSynth8::GetPortCaps()
//
// Encapsulates calls to GetPortCaps()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetPortCaps(LPDMUS_PORTCAPS pCaps)
{
    HRESULT hRes            = E_NOTIMPL;
	BOOL	fValid_pCaps    = TRUE;

    // validate pCaps
    if(!helpIsValidPtr((void*)pCaps, sizeof(DMUS_PORTCAPS), FALSE))
    {
        fValid_pCaps = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(PARAMLOGLEVEL, TEXT("--- Calling %s::GetPortCaps()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("pCaps == %p   %s"),
            pCaps,
            fValid_pCaps ? TEXT("") : TEXT("BAD"));

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetPortCaps(pCaps);

    // log results
    fnsLog(PARAMLOGLEVEL, TEXT("--- Returned from %s::GetPortCaps()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pCaps)
    {
        tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL, pCaps);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::GetPortCaps()


//===========================================================================
// CtIDirectMusicSynth8::SetMasterClock()
//
// Encapsulates calls to SetMasterClock()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::SetMasterClock(CtIReferenceClock *ptClock)
{
    HRESULT         hRes            = E_NOTIMPL;
	BOOL	        fValid_ptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;

    // validate pClock
    if(!helpIsValidPtr((void*)ptClock, sizeof(CtIReferenceClock), FALSE))
    {
        fValid_ptClock = FALSE;
        pRefClock = (IReferenceClock*)ptClock;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptClock->GetRealObjPtr(&pRefClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pClock == %p   %s",
            pRefClock,
            fValid_ptClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->SetMasterClock(pRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSynth8::SetMasterClock()


//===========================================================================
// CtIDirectMusicSynth8::GetLatencyClock()
//
// Encapsulates calls to GetLatencyClock()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetLatencyClock(CtIReferenceClock **pptClock)
{
    HRESULT         hRes            = E_NOTIMPL;
	BOOL			fValid_pptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;
    IReferenceClock **ppRefClock    = NULL;

    // validate pptClock
    // NOTE:
    //	If we are passed an invalid CtIReferenceClock pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicSynth8:GetLatencyClock().
    //  Otherwise, we are to create and return a CtIReferenceClock object
    if(!helpIsValidPtr((void*)pptClock, sizeof(CtIReferenceClock*),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptClock = FALSE;
        ppRefClock = (IReferenceClock**)pptClock;

    }
    else
    {
        // valid pointer, create a real object
        ppRefClock = &pRefClock;

        // just in case we fail, init test object ptr to NULL
        *pptClock = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppClock == %p   %s",
            ppRefClock,
            fValid_pptClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetLatencyClock(ppRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptClock)
    {
        fnsLog(PARAMLOGLEVEL, "*ppClock == %p",
                pRefClock);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pRefClock, pptClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSynth8::GetLatencyClock()


//===========================================================================
// CtIDirectMusicSynth8::Activate()
//
// Encapsulates calls to Activate()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Activate(BOOL fEnable)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "fEnable == %d",
            fEnable);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Activate(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Activate()


//===========================================================================
// CtIDirectMusicSynth8::Render()
//
// Encapsulates calls to Render()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Render(short *pBuffer, DWORD dwLength,
                                DWORD dwPosition)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pBuffer  = TRUE;

    // validate pBuffer
    if(!helpIsValidPtr((void*)pBuffer, sizeof(short), FALSE))
    {
        fValid_pBuffer = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Render()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pBuffer   == %p   %s",
            pBuffer,
            fValid_pBuffer ? "" : "BAD");
    if(fValid_pBuffer)
    {
        // BUGBUG log contents of pBuffer @ MAXLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "dwLength   == %08Xh",
            dwLength);
    fnsLog(PARAMLOGLEVEL, "dwPosition == %08Xh",
            dwPosition);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Render(pBuffer, dwLength, dwPosition);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Render()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Render()


//===========================================================================
// CtIDirectMusicSynth8::SetSynthSink
//
// Encapsulates calls to SetSynthSink()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::SetSynthSink(CtIDirectMusicSynthSink *ptdmSynSnk)
{
    HRESULT                 hRes                = E_NOTIMPL;
    BOOL                    fValid_ptdmSynSnk   = TRUE;
    IDirectMusicSynthSink   *pdmSink            = NULL;

    // validate ptdmSynSnk
    if(!helpIsValidPtr((void*)ptdmSynSnk, sizeof(CtIDirectMusicSynthSink),
                        FALSE))
    {
        fValid_ptdmSynSnk = FALSE;
        pdmSink = (IDirectMusicSynthSink*)ptdmSynSnk;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSynSnk->GetRealObjPtr(&pdmSink);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetSynthSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSynthSink == %p   %s",
            pdmSink,
            fValid_ptdmSynSnk ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->SetSynthSink(pdmSink);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetSynthSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSynSnk && pdmSink)
    {
        pdmSink->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSynth8::SetSynthSink()


//===========================================================================
// CtIDirectMusicSynth8::SetChannelPriority()
//
// Encapsulates calls to SetChannelPriority()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::SetChannelPriority(
	DWORD dwChannelGroup,
	DWORD dwChannel,
	DWORD dwPriority)
{
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "dwPriority == %08Xh",
            dwPriority);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->SetChannelPriority(
		dwChannelGroup,
		dwChannel,
		dwPriority);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::SetChannelPriority()


//===========================================================================
// CtIDirectMusicSynth8::GetChannelPriority()
//
// Encapsulates calls to GetChannelPriority()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetChannelPriority(
	DWORD dwChannelGroup,
	DWORD dwChannel,
	LPDWORD pdwPriority)
{
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pdwPriority	= TRUE;

    fnsIncrementIndent();

    // validate pdwPriority
    if(!helpIsValidPtr((void*)pdwPriority, sizeof(LPDWORD), FALSE))
    {
        fValid_pdwPriority = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "pdwPriority == %p   %s",
            pdwPriority,
            fValid_pdwPriority ?  "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetChannelPriority(
		dwChannelGroup,
		dwChannel,
		pdwPriority);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pdwPriority)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwPriority == %08Xh",
                *pdwPriority);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::SetChannelPriority()


//===========================================================================
// CtIDirectMusicSynth8::GetFormat()
//
// Encapsulates calls to GetFormat()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetFormat(
	LPWAVEFORMATEX pWaveFormatEx,
	LPDWORD pdwWaveFormatExSize)
{
    HRESULT hRes						= E_NOTIMPL;
	BOOL	fValid_pWaveFormatEx		= TRUE;
	BOOL	fValid_pdwWaveFormatExSize	= TRUE;

    fnsIncrementIndent();

    // validate pWaveFormatEx
    if(!helpIsValidPtr((void*)pWaveFormatEx, sizeof(LPWAVEFORMATEX), FALSE))
    {
        fValid_pWaveFormatEx = FALSE;
    }
    // validate pdwWaveFormatExSize
    if(!helpIsValidPtr((void*)pdwWaveFormatExSize, sizeof(LPDWORD), FALSE))
    {
        fValid_pdwWaveFormatExSize = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWaveFormatEx == %p   %s",
            pWaveFormatEx,
            fValid_pWaveFormatEx ?  "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwWaveFormatExSize == %p   %s",
            pdwWaveFormatExSize,
            fValid_pdwWaveFormatExSize ?  "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetFormat(
		pWaveFormatEx,
		pdwWaveFormatExSize);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pWaveFormatEx)
    {
        fnsLog(PARAMLOGLEVEL, "*pWaveFormatEx == %08Xh",
                *pWaveFormatEx);
    }
    if(fValid_pdwWaveFormatExSize)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwWaveFormatExSize == %08Xh",
                *pdwWaveFormatExSize);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::GetFormat()


//===========================================================================
// CtIDirectMusicSynth8::GetAppend()
//
// Encapsulates calls to GetAppend()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::GetAppend(
	DWORD* pdwAppend)
{
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pdwAppend	= TRUE;

    fnsIncrementIndent();

    // validate pdwAppend
    if(!helpIsValidPtr((void*)pdwAppend, sizeof(DWORD*), FALSE))
    {
        fValid_pdwAppend = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwAppend == %p   %s",
            pdwAppend,
            fValid_pdwAppend ?  "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetAppend(
		pdwAppend);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pdwAppend)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwAppend == %08Xh",
                *pdwAppend);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::GetAppend()


*/

//===========================================================================
// CtIDirectMusicSynth8::PlayVoice()
//
// Encapsulates calls to PlayVoice()
//
// History:
//  10/18/1999 - kcraven - created
//  04/20/2000 - kcraven - changed to match dx8 headers
//===========================================================================
HRESULT CtIDirectMusicSynth8::PlayVoice
(
	REFERENCE_TIME rt, 
	DWORD dwVoiceId, 
	DWORD dwChannelGroup, 
	DWORD dwChannel, 
	DWORD dwDLId, 
	long prPitch,			//PREL not defined here
	long vrVolume,          //VREL not defined here 
	SAMPLE_TIME stVoiceStart,
	SAMPLE_TIME stLoopStart,
	SAMPLE_TIME stLoopEnd)
{
    HRESULT             hRes                = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PlayVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt             == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "dwVoiceId      == %08Xh",
            dwVoiceId);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel      == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "dwDLId         == %08Xh",
            dwDLId);
    fnsLog(PARAMLOGLEVEL, "prPitch        == %ld",
            prPitch);
    fnsLog(PARAMLOGLEVEL, "vrVolume       == %ld",
            vrVolume);
    fnsLog(PARAMLOGLEVEL, "stVoiceStart   == %016Xh",
            stVoiceStart);
    fnsLog(PARAMLOGLEVEL, "stLoopStart    == %016Xh",
            stLoopStart);
    fnsLog(PARAMLOGLEVEL, "stLoopEnd      == %016Xh",
            stLoopEnd);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->PlayVoice(
												rt,
												dwVoiceId,
												dwChannelGroup,
												dwChannel,
												dwDLId,
												prPitch,
												vrVolume,
												stVoiceStart,
												stLoopStart,
												stLoopEnd);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PlayVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::PlayVoice()




//===========================================================================
// CtIDirectMusicSynth8::StopVoice()
//
// Encapsulates calls to StopVoice()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::StopVoice
(
	REFERENCE_TIME rt,
	DWORD dwVoiceId
)
{
    HRESULT             hRes                = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::StopVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "dwVoiceId == %08Xh",
            dwVoiceId);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->StopVoice(rt,dwVoiceId);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::StopVoice()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::StopVoice()




//===========================================================================
// CtIDirectMusicSynth8::GetVoicePosition()
//
// Encapsulates calls to GetVoicePosition()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
//PHOOPHOO
/*
HRESULT CtIDirectMusicSynth8::GetVoicePosition
(
	DWORD dwVoice[],
	DWORD cbVoice,
	SAMPLE_POSITION dwVoicePos[]
)
{
    HRESULT hRes                = E_NOTIMPL;
	BOOL	fValid_dwVoice		= TRUE;
	BOOL	fValid_dwVoicePos	= TRUE;

    fnsIncrementIndent();

    // validate pdwAppend
    if(!helpIsValidPtr((void*)dwVoice, sizeof(DWORD*), FALSE))
    {
        fValid_dwVoice = FALSE;
    }
    // validate pdwAppend
    if(!helpIsValidPtr((void*)dwVoicePos, sizeof(SAMPLE_POSITION*), FALSE))
    {
        fValid_dwVoicePos = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetVoicePosition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwVoice == %08Xh   %s",
            dwVoice,
            fValid_dwVoice ?  "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "cbVoice == %08Xh",
            cbVoice);
    fnsLog(PARAMLOGLEVEL, "dwVoicePos == %08Xh   %s",
            dwVoicePos,
            fValid_dwVoicePos ?  "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->GetVoicePosition(dwVoice,cbVoice,dwVoicePos);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetVoicePosition()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::GetVoicePosition()
*/



//===========================================================================
// CtIDirectMusicSynth8::Refresh()
//
// Encapsulates calls to Refresh()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::Refresh
(
	DWORD dwDownloadID,
	DWORD dwFlags
)
{
    HRESULT             hRes                = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Refresh()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwDownloadID == %08Xh",
            dwDownloadID);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->Refresh(dwDownloadID,dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Refresh()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::Refresh()




//===========================================================================
// CtIDirectMusicSynth8::AssignChannelToBuses()
//
// Encapsulates calls to AssignChannelToBuses()
//
// History:
//  10/18/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynth8::AssignChannelToBuses
(
	DWORD dwChannelGroup,
	DWORD dwChannel,
	LPDWORD pdwBusses,
	DWORD cBusses
)
{
    HRESULT             hRes                = E_NOTIMPL;
	BOOL	fValid_pdwBusses		= TRUE;

    fnsIncrementIndent();

    // validate pdwAppend
    if(!helpIsValidPtr((void*)pdwBusses, sizeof(LPDWORD), FALSE))
    {
        fValid_pdwBusses = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AssignChannelToBuses()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "pdwBusses == %p   %s",
            pdwBusses,
            fValid_pdwBusses ?  "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "cBusses == %08Xh",
            cBusses);

    // call the real function
    hRes = ((IDirectMusicSynth8*)m_pUnk)->AssignChannelToBuses(dwChannelGroup,dwChannel,pdwBusses,cBusses);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AssignChannelToBuses()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSynth8::AssignChannelToBuses()




//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\cttool8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cttool8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// cttool8.cpp
//
// Test harness implementation of IDirectMusicTool8
//
// Functions:
//  CtIDirectMusicTool8::Clone()
//
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicTool8::CtIDirectMusicTool8()
//
// Default constructor
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
CtIDirectMusicTool8::CtIDirectMusicTool8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicTool8";

} // *** end CtIDirectMusicTool8::CtIDirectMusicTool8()


//===========================================================================
// CtIDirectMusicTool8::~CtIDirectMusicTool8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
CtIDirectMusicTool8::~CtIDirectMusicTool8(void)
{
    // nothing to do

} // *** end CtIDirectMusicTool8::~CtIDirectMusicTool8()


//===========================================================================
// CtIDirectMusicTool8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicTool8 *pdmTool8 - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTool8::InitTestClass(IDirectMusicTool8 *pdmTool8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmTool8, sizeof(IDirectMusicTool8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmTool8));

} // *** end CtIDirectMusicTool8::InitTestClass()


//===========================================================================
// CtIDirectMusicTool8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicTool8 **ppdmTool8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTool8::GetRealObjPtr(IDirectMusicTool8 **ppdmTool8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmTool8, sizeof(IDirectMusicTool8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmTool8));

} // *** end CtIDirectMusicTool8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicTool8::Clone()
//
// Encapsulates calls to Clone
//
// History:
//  10/15/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTool8::Clone(CtIDirectMusicTool** ppTool)
{
    HRESULT				hRes			= E_NOTIMPL;
	BOOL				fValid_ppTool	= TRUE;
    IDirectMusicTool*	pdmTool			= NULL;
	IDirectMusicTool**	ppdmTool		= NULL;

    // validate padwMediaTypes
    if(!helpIsValidPtr((void*)ppTool, sizeof(DWORD*), FALSE))
    {
        fValid_ppTool = FALSE;
		ppdmTool = (IDirectMusicTool**)ppTool;
    }
	else
	{
		//use real object pointer
		ppdmTool = &pdmTool;
		*ppTool = NULL;
	}

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppTool == %p   %s",
            ppdmTool,
            fValid_ppTool);

    // call the real function
    hRes = ((IDirectMusicTool8*)m_pUnk)->Clone(ppdmTool);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTool, ppTool);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    if(fValid_ppTool && pdmTool)
    {
        pdmTool->Release();
    }

    return hRes;

} // *** end CtIDirectMusicTool8::Clone()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctsynth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctsynth.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsynth.cpp
//
// Test harness implementation of IDirectMusicSynth
//
// Functions:
//  CtIDirectMusicSynth::CtIDirectMusicSynth()
//  CtIDirectMusicSynth::~CtIDirectMusicSynth()
//  CtIDirectMusicSynth::InitTestClass()
//  CtIDirectMusicSynth::GetRealObjPtr()
//  CtIDirectMusicSynth::QueryInterface()
//  CtIDirectMusicSynth::Open()
//  CtIDirectMusicSynth::Close()
//  CtIDirectMusicSynth::SetNumChannelGroups()
//  CtIDirectMusicSynth::Download()
//  CtIDirectMusicSynth::Unload()
//  CtIDirectMusicSynth::PlayBuffer()
//  CtIDirectMusicSynth::GetRunningStats()
//  CtIDirectMusicSynth::GetPortCaps()
//  CtIDirectMusicSynth::SetMasterClock()
//  CtIDirectMusicSynth::GetLatencyClock()
//  CtIDirectMusicSynth::Activate()
//  CtIDirectMusicSynth::Render() 
//  CtIDirectMusicSynth::SetSynthSink()
//
// History:
//  01/05/1998 - a-llucar - created
//	02/25/1998 - a-llucar - Changed Open(), Close(), SetNumChannelGroups(), 
//							Download(), Unload(), QueueBuffer(),
//							GetRunningStats(), GetLatencyClock().
//  03/05/1998 - davidkl - updated to latest dm arch
//  03/26/1998 - davidkl - implemented SetSynthSink.
//                         Brave new world... now a derived class
//  04/01/1998 - davidkl - minor cleanup
//===========================================================================
 
#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicSynth::CtIDirectMusicSynth()
//
// Default constructor
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicSynth::CtIDirectMusicSynth(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSynth";

} //*** end CtIDirectMusicSynth::CtIDirectMusicSynth()


//===========================================================================
// CtIDirectMusicSynth::~CtIDirectMusicSynth()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicSynth::~CtIDirectMusicSynth(void)
{
    // nothing to do

} //*** end CtIDirectMusicSynth::~CtIDirectMusicSynth()


//===========================================================================
// CtIDirectMusicSynth::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmSynth - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicSynth::InitTestClass(IDirectMusicSynth *pdmSynth)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSynth, sizeof(IDirectMusicSynth), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSynth));

} //*** end CtIDirectMusicSynth::InitTestClass()


//===========================================================================
// CtIDirectMusicSynth::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSynth **ppdmSynth - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/05/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicSynth::GetRealObjPtr(IDirectMusicSynth **ppdmSynth)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSynth, sizeof(IDirectMusicSynth*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSynth));

} //*** end CtIDirectMusicSynth::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicSynth::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicSynth::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::QueryInterface


//===========================================================================
// CtIDirectMusicSynth::Open()
//
// Encapsulates calls to Open()
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicSynth::Open(LPDMUS_PORTPARAMS pPortParams)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pPortParams	= TRUE;

    // validate pPortParams
    if(!helpIsValidPtr((void*)pPortParams, sizeof(DMUS_PORTPARAMS), TRUE))
    {
        fValid_pPortParams = FALSE;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Open()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPortParams == %p   %s",
            pPortParams,
            fValid_pPortParams ? "" : "BAD");
    if(fValid_pPortParams)
    {
        if(!pPortParams)
        {
	        // BUGBUG
            // log default port parameters
        }
        else
        {
	        // BUGBUG
            // log actual port parameters passed in
        }
    }
 
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Open(pPortParams);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Open()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Open()
 

//===========================================================================
// CtIDirectMusicSynth::Close()
//
// Encapsulates calls to Close()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/05/1998 - davidkl - minor tweaks
//===========================================================================
HRESULT CtIDirectMusicSynth::Close(void)
{                                           
    HRESULT hRes     = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Close()",
            m_szInterfaceName);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Close();

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Close()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Close()
 

//===========================================================================
// CtIDirectMusicSynth::SetNumChannelGroups()
//
// Encapsulates calls to SetNumChannelGroups()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/05/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSynth::SetNumChannelGroups(DWORD dwGroups)
{                                           
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwGroups == %08Xh",
            dwGroups);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->SetNumChannelGroups(dwGroups);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetNumChannelGroups()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::SetNumChannelGroups()
 

//===========================================================================
// CtIDirectMusicSynth::Download()
//
// Encapsulates calls to Download()
//
// History:
//  01/05/1998 - a-llucar - created
//  04/01/1998 - davidkl - enhanced logging
//===========================================================================
HRESULT CtIDirectMusicSynth::Download(LPHANDLE phDownload, 
									  LPVOID pvData, LPBOOL pbFree)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_phDownload	= TRUE;
    BOOL                fValid_pvData	    = TRUE;
	BOOL				fValid_pbFree		= TRUE;

    // validate phDownload
    if(!helpIsValidPtr((void*)phDownload, sizeof(LPHANDLE), FALSE))
    {
        fValid_phDownload = FALSE;
    }
	
	// validate pvData
    if(!helpIsValidPtr(pvData, sizeof(LPVOID), FALSE))
    {
        fValid_pvData = FALSE;
    }

	// validate pbFree
    if(!helpIsValidPtr(pbFree, sizeof(LPBOOL), FALSE))
    {
        fValid_pbFree = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "phDownload == %p   %s",
            phDownload,
            fValid_phDownload ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pvData == %p   %s",
            pvData,
            fValid_pvData ? "" : "BAD");
    if(fValid_pvData)
    {
        // BUGBUG - log contents of pvData @ MAX_LOGLEVEL (in byte format)
    }
	fnsLog(PARAMLOGLEVEL, "pbFree == %p   %s",
            pbFree,
            fValid_pbFree ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Download(phDownload, pvData, pbFree);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_phDownload)
    {
        fnsLog(PARAMLOGLEVEL, "*phDownload == %08Xh",
                *phDownload);
    }
    if(fValid_pbFree)
    {
        fnsLog(PARAMLOGLEVEL, "*pbFree     == %s",
                (*pbFree) ? "TRUE" : "FALSE");
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Download()


//===========================================================================
// CtIDirectMusicSynth::Unload()
//
// Encapsulates calls to Unload()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/05/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicSynth::Unload(HANDLE hDownload, 
									HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
									HANDLE hUserData)
{                                           
    HRESULT hRes = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hDownload == %08Xh",
            hDownload);
    // BUGBUG how to properly validate this??
    fnsLog(PARAMLOGLEVEL, "lpFreeHandle == %p",
            lpFreeHandle);
	fnsLog(PARAMLOGLEVEL, "hUserData == %08Xh",
            hUserData);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Unload(hDownload, lpFreeHandle, hUserData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Unload()


//===========================================================================
// CtIDirectMusicSynth::PlayBuffer()
//
// Encapsulates calls to PlayBuffer()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicSynth::PlayBuffer(REFERENCE_TIME rt, 
								  LPBYTE pbBuffer, DWORD cbBuffer)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pbBuffer		= TRUE;

    // validate pbBuffer
    if(!helpIsValidPtr((void*)pbBuffer, cbBuffer, FALSE))
    {
        fValid_pbBuffer = FALSE;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rt == %016Xh",
            rt);
    fnsLog(PARAMLOGLEVEL, "pbBuffer == %p   %s",
            pbBuffer,
            fValid_pbBuffer ? "" : "BAD");
    if(fValid_pbBuffer)
    {
        // BUGBUG log contents of pbBuffer @ MAXLOGLEVEL (as bytes)
    }
    fnsLog(PARAMLOGLEVEL, "cbBuffer == %08Xh",
            cbBuffer);

    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->PlayBuffer(rt, pbBuffer, cbBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::PlayBuffer()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::PlayBuffer()


//===========================================================================
// CtIDirectMusicSynth::GetRunningStats()
//
// Encapsulates calls to GetRunningStats()
//
// History:
//  01/05/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicSynth::GetRunningStats(LPDMUS_SYNTHSTATS pStats)
{                                           
    HRESULT             hRes                = E_NOTIMPL;
	BOOL				fValid_pStats		= TRUE;

    // validate pStats
    if(!helpIsValidPtr((void*)pStats, sizeof(DMUS_SYNTHSTATS), FALSE))
    {
        fValid_pStats = FALSE;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStats == %p   %s",
            pStats,
            fValid_pStats ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetRunningStats(pStats);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetRunningStats()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pStats)
    {
        // BUGBUG log contents of pStats (STRUCTLOGLEVEL)
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::GetRunningStats()


//===========================================================================
// CtIDirectMusicSynth::GetPortCaps()
//
// Encapsulates calls to GetPortCaps()
//
// History:
//  01/05/1998 - a-llucar - created
//  04/01/1998 - davidkl - enhanced logging
//===========================================================================
HRESULT CtIDirectMusicSynth::GetPortCaps(LPDMUS_PORTCAPS pCaps)
{                                           
    HRESULT hRes            = E_NOTIMPL;
	BOOL	fValid_pCaps    = TRUE;

    // validate pCaps
    if(!helpIsValidPtr((void*)pCaps, sizeof(DMUS_PORTCAPS), FALSE))
    {
        fValid_pCaps = FALSE;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(PARAMLOGLEVEL, TEXT("--- Calling %s::GetPortCaps()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("pCaps == %p   %s"),
            pCaps,
            fValid_pCaps ? TEXT("") : TEXT("BAD"));
    
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetPortCaps(pCaps);

    // log results
    fnsLog(PARAMLOGLEVEL, TEXT("--- Returned from %s::GetPortCaps()"),
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, TEXT("hRes == %s (%08Xh)"),
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pCaps)
    {
        tdmLogDMUS_PORTCAPS(STRUCTLOGLEVEL, pCaps);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::GetPortCaps()


//===========================================================================
// CtIDirectMusicSynth::SetMasterClock()
//
// Encapsulates calls to SetMasterClock()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes
//===========================================================================
HRESULT CtIDirectMusicSynth::SetMasterClock(CtIReferenceClock *ptClock)
{                                           
    HRESULT         hRes            = E_NOTIMPL;
	BOOL	        fValid_ptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;

    // validate pClock
    if(!helpIsValidPtr((void*)ptClock, sizeof(CtIReferenceClock), FALSE))
    {
        fValid_ptClock = FALSE;
        pRefClock = (IReferenceClock*)ptClock;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptClock->GetRealObjPtr(&pRefClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pClock == %p   %s",
            pRefClock,
            fValid_ptClock ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->SetMasterClock(pRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetMasterClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynth::SetMasterClock()


//===========================================================================
// CtIDirectMusicSynth::GetLatencyClock()
//
// Encapsulates calls to GetLatencyClock()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/06/1998 - davidkl - now uses wrapper classes, enhanced logging
//===========================================================================
HRESULT CtIDirectMusicSynth::GetLatencyClock(CtIReferenceClock **pptClock)
{                                           
    HRESULT         hRes            = E_NOTIMPL;
	BOOL			fValid_pptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;
    IReferenceClock **ppRefClock    = NULL;  

    // validate pptClock
    // NOTE:
    //	If we are passed an invalid CtIReferenceClock pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicSynth:GetLatencyClock().  
    //  Otherwise, we are to create and return a CtIReferenceClock object
    if(!helpIsValidPtr((void*)pptClock, sizeof(CtIReferenceClock*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptClock = FALSE;
        ppRefClock = (IReferenceClock**)pptClock;

    }
    else
    {
        // valid pointer, create a real object
        ppRefClock = &pRefClock;

        // just in case we fail, init test object ptr to NULL
        *pptClock = NULL;
    }
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppClock == %p   %s",
            ppRefClock,
            fValid_pptClock ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetLatencyClock(ppRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptClock)
    {
        fnsLog(PARAMLOGLEVEL, "*ppClock == %p",
                pRefClock);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pRefClock, pptClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynth::GetLatencyClock()


//===========================================================================
// CtIDirectMusicSynth::Activate()
//
// Encapsulates calls to Activate()
//
// History:
//  01/05/1998 - a-llucar - created
//  03/06/1998 - davidkl - fixed logging
//  08/21/1998 - dvaidkl - removed hWnd
//===========================================================================
HRESULT CtIDirectMusicSynth::Activate(BOOL fEnable)
{                                           
    HRESULT hRes    = E_NOTIMPL;
	
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "fEnable == %d",
            fEnable);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Activate(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Activate()


//===========================================================================
// CtIDirectMusicSynth::Render()
//
// Encapsulates calls to Render()
//
// History:
//  03/06/1998 - davidkl - created
//  03/18/1998 - davidkl - renamed due to changes in dmusicc.h
//===========================================================================
HRESULT CtIDirectMusicSynth::Render(short *pBuffer, DWORD dwLength, 
                                DWORD dwPosition)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_pBuffer  = TRUE;
	
    // validate pBuffer
    if(!helpIsValidPtr((void*)pBuffer, sizeof(short), FALSE))
    {
        fValid_pBuffer = FALSE;
    }
        
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Render()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pBuffer   == %p   %s",
            pBuffer,
            fValid_pBuffer ? "" : "BAD");
    if(fValid_pBuffer)
    {
        // BUGBUG log contents of pBuffer @ MAXLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "dwLength   == %08Xh",
            dwLength);
    fnsLog(PARAMLOGLEVEL, "dwPosition == %08Xh",
            dwPosition);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->Render(pBuffer, dwLength, dwPosition);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Render()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::Render()


//===========================================================================
// CtIDirectMusicSynth::SetSynthSink
//
// Encapsulates calls to SetSynthSink()
//
// History:
//  03/26/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicSynth::SetSynthSink(CtIDirectMusicSynthSink *ptdmSynSnk)
{
    HRESULT                 hRes                = E_NOTIMPL;
    BOOL                    fValid_ptdmSynSnk   = TRUE;
    IDirectMusicSynthSink   *pdmSink            = NULL;

    // validate ptdmSynSnk
    if(!helpIsValidPtr((void*)ptdmSynSnk, sizeof(CtIDirectMusicSynthSink), 
                        FALSE))
    {
        fValid_ptdmSynSnk = FALSE;
        pdmSink = (IDirectMusicSynthSink*)ptdmSynSnk;
    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSynSnk->GetRealObjPtr(&pdmSink);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetSynthSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSynthSink == %p   %s",
            pdmSink,
            fValid_ptdmSynSnk ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->SetSynthSink(pdmSink);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetSynthSink()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSynSnk && pdmSink)
    {
        pdmSink->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynth::SetSynthSink()


//===========================================================================
// CtIDirectMusicSynth::SetChannelPriority()
//
// Encapsulates calls to SetChannelPriority()
//
// History:
//  08/05/1998 - a-kellyc - created
//===========================================================================
HRESULT CtIDirectMusicSynth::SetChannelPriority(
	DWORD dwChannelGroup,
	DWORD dwChannel,
	DWORD dwPriority)
{                                           
    HRESULT hRes    = E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "dwPriority == %08Xh",
            dwPriority);
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->SetChannelPriority(
		dwChannelGroup,
		dwChannel,
		dwPriority);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::SetChannelPriority()


//===========================================================================
// CtIDirectMusicSynth::GetChannelPriority()
//
// Encapsulates calls to GetChannelPriority()
//
// History:
//  08/05/1998 - a-kellyc - created
//===========================================================================
HRESULT CtIDirectMusicSynth::GetChannelPriority(
	DWORD dwChannelGroup,
	DWORD dwChannel,
	LPDWORD pdwPriority)
{                                           
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pdwPriority	= TRUE;

    fnsIncrementIndent();

    // validate pdwPriority
    if(!helpIsValidPtr((void*)pdwPriority, sizeof(LPDWORD), FALSE))
    {
        fValid_pdwPriority = FALSE;
    }
	
    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwChannelGroup == %08Xh",
            dwChannelGroup);
    fnsLog(PARAMLOGLEVEL, "dwChannel == %08Xh",
            dwChannel);
    fnsLog(PARAMLOGLEVEL, "pdwPriority == %p   %s",
            pdwPriority,
            fValid_pdwPriority ?  "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetChannelPriority(
		dwChannelGroup,
		dwChannel,
		pdwPriority);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetChannelPriority()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pdwPriority)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwPriority == %08Xh",
                *pdwPriority);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::SetChannelPriority()
 

//===========================================================================
// CtIDirectMusicSynth::GetFormat()
//
// Encapsulates calls to GetFormat()
//
// History:
//  09/30/1998 - a-kellyc - created
//===========================================================================
HRESULT CtIDirectMusicSynth::GetFormat(
	LPWAVEFORMATEX pWaveFormatEx,
	LPDWORD pdwWaveFormatExSize)
{                                           
    HRESULT hRes						= E_NOTIMPL;
	BOOL	fValid_pWaveFormatEx		= TRUE;
	BOOL	fValid_pdwWaveFormatExSize	= TRUE;

    fnsIncrementIndent();

    // validate pWaveFormatEx
    if(!helpIsValidPtr((void*)pWaveFormatEx, sizeof(LPWAVEFORMATEX), FALSE))
    {
        fValid_pWaveFormatEx = FALSE;
    }
    // validate pdwWaveFormatExSize
    if(!helpIsValidPtr((void*)pdwWaveFormatExSize, sizeof(LPDWORD), FALSE))
    {
        fValid_pdwWaveFormatExSize = FALSE;
    }
	
    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pWaveFormatEx == %p   %s",
            pWaveFormatEx,
            fValid_pWaveFormatEx ?  "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pdwWaveFormatExSize == %p   %s",
            pdwWaveFormatExSize,
            fValid_pdwWaveFormatExSize ?  "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetFormat(
		pWaveFormatEx,
		pdwWaveFormatExSize);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetFormat()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pWaveFormatEx)
    {
        fnsLog(PARAMLOGLEVEL, "*pWaveFormatEx == %08Xh",
                *pWaveFormatEx);
    }
    if(fValid_pdwWaveFormatExSize)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwWaveFormatExSize == %08Xh",
                *pdwWaveFormatExSize);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::GetFormat()
 

//===========================================================================
// CtIDirectMusicSynth::GetAppend()
//
// Encapsulates calls to GetAppend()
//
// History:
//  09/30/1998 - a-kellyc - created
//===========================================================================
HRESULT CtIDirectMusicSynth::GetAppend(
	DWORD* pdwAppend)
{                                           
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pdwAppend	= TRUE;

    fnsIncrementIndent();

    // validate pdwAppend
    if(!helpIsValidPtr((void*)pdwAppend, sizeof(DWORD*), FALSE))
    {
        fValid_pdwAppend = FALSE;
    }
	
    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwAppend == %p   %s",
            pdwAppend,
            fValid_pdwAppend ?  "" : "BAD");
            
    // call the real function
    hRes = ((IDirectMusicSynth*)m_pUnk)->GetAppend(
		pdwAppend);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAppend()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_pdwAppend)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwAppend == %08Xh",
                *pdwAppend);
    }
    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicSynth::GetAppend()
 

//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\cttool.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cttool.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// cttool.cpp
//
// Test harness implementation of IDirectMusicTool
//
// Functions:
//  CtIDirectMusicTool::CtIDirectMusicTool()
//  CtIDirectMusicTool::~CtIDirectMusicTool()
//  CtIDirectMusicTool::InitTestClass()
//  CtIDirectMusicTool::GetRealObjPtr()
//  CtIDirectMusicTool::QueryInterface()
//  CtIDirectMusicTool::Init()
//  CtIDirectMusicTool::GetMsgDeliveryType()
//  CtIDirectMusicTool::GetMediaTypeArraySize()
//  CtIDirectMusicTool::GetMediaTypes()
//  CtIDirectMusicTool::ProcessPMsg()
//  CtIDirectMusicTool::Flush()
//
// History:
//  01/02/1998 - a-llucar - created
//  01/09/1998 - a-llucar - adapted ProcessEvent(), Flush(), Start(), 
//                          and Stop() to latest header
//  01/10/1998 - a-llucar - added GetQueueType(), GetMediaTypeArraySize(), 
//                          GetMediaTypeArray()
//  03/05/1998 - davidkl - updated to latest dmusic architecture
//  03/31/1998 - davidkl - inheritance update
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicTool::CtIDirectMusicTool()
//
// Default constructor
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicTool::CtIDirectMusicTool(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicTool";

} //*** end CtIDirectMusicTool::CtIDirectMusicTool()


//===========================================================================
// CtIDirectMusicTool::~CtIDirectMusicTool()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
CtIDirectMusicTool::~CtIDirectMusicTool(void)
{
    // nothing to do

} //*** end CtIDirectMusicTool::~CtIDirectMusicTool()


//===========================================================================
// CtIDirectMusicTool::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmTool - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTool::InitTestClass(IDirectMusicTool *pdmTool)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmTool, sizeof(IDirectMusicTool), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmTool));

} //*** end CtIDirectMusicTool::InitTestClass()


//===========================================================================
// CtIDirectMusicTool::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicTool **ppdmTool - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  01/02/1998 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicTool::GetRealObjPtr(IDirectMusicTool **ppdmTool)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmTool, sizeof(IDirectMusicTool*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmTool));

} //*** end CtIDirectMusicTool::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicTool::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTool::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicTool::QueryInterface


//===========================================================================
// CtIDirectMusicTool::AddRef()
//
// Encapsulates calls to AddRef
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
/*
DWORD CtIDirectMusicTool::AddRef(void)
{

    // increment our object's refcount
    m_dwRefCount++;

    // call the real AddRef
    tdmAddRef((IUnknown*)m_pdmTool, (LPCTSTR)m_szInterfaceName);

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicTool::AddRef()
*/	

//===========================================================================
// CtIDirectMusicTool::Release()
//
// Encapsulates calls to Release
//
// History:
//  01/02/1998 - a-llucar - created
//===========================================================================
/*
DWORD CtIDirectMusicTool::Release(void)
{

    // decrement our object's refcount
    m_dwRefCount--;

    // call the real Release
    tdmRelease((IUnknown*)m_pdmTool, (LPCTSTR)m_szInterfaceName);

    // clean ourselves up
    if(0 >= m_dwRefCount)
    {
        delete this;
    }

    // return >our< refcount
    return m_dwRefCount;

} //*** end CtIDirectMusicTool::Release()
*/

 
//===========================================================================
// CtIDirectMusicTool::Init()
//
// Encapsulates calls to Init
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - modified to use wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::Init(CtIDirectMusicGraph* ptdmGraph)
{
    HRESULT             hRes			    = E_NOTIMPL;
    BOOL                fValid_ptdmGraph    = TRUE;
    IDirectMusicGraph   *pdmGraph           = NULL;
    
    // validate ptdmGraph
    if(!helpIsValidPtr((void*)ptdmGraph, sizeof(CtIDirectMusicGraph), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmGraph = FALSE;
        pdmGraph = (IDirectMusicGraph*)ptdmGraph;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmGraph->GetRealObjPtr(&pdmGraph);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGraph == %p   %s",
            pdmGraph,
            fValid_ptdmGraph ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->Init(pdmGraph);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmGraph && pdmGraph)
    {
        pdmGraph->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::Init()


//===========================================================================
// CtIDirectMusicTool::GetMsgDeliveryType()
//
// Encapsulates calls to GetMsgDeliveryType
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::GetMsgDeliveryType(DWORD* pdwDeliveryType)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwDeliveryType	= TRUE;
    
    // validate pdwQueueType
    if(!helpIsValidPtr((void*)pdwDeliveryType, sizeof(DWORD), FALSE))
    {
        fValid_pdwDeliveryType	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMsgDeliveryType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwDeliveryType == %p   %s",
            pdwDeliveryType,
            fValid_pdwDeliveryType ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMsgDeliveryType(pdwDeliveryType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMsgDeliveryType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes             == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwDeliveryType)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwDeliveryType == %08Xh",
                *pdwDeliveryType);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMsgDeliveryType()


//===========================================================================
// CtIDirectMusicTool::GetMediaTypeArraySize()
//
// Encapsulates calls to GetMediaTypeArraySize
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicTool::GetMediaTypeArraySize(DWORD* pdwNumElements)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL	fValid_pdwNumElements	= TRUE;
    
    // validate pdwNumElements
    if(!helpIsValidPtr((void*)pdwNumElements, sizeof(DWORD), FALSE))
    {
        fValid_pdwNumElements = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMediaTypeArraySize()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwNumElements == %p   %s",
            pdwNumElements,
            fValid_pdwNumElements ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMediaTypeArraySize(pdwNumElements);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMediaTypeArraySize()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwNumElements)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwNumElements == %08Xh",
                *pdwNumElements);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMediaTypeArraySize()


//===========================================================================
// CtIDirectMusicTool::GetMediaTypes()
//
// Encapsulates calls to GetMediaTypes
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/2998 - davidkl - renamed, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::GetMediaTypes(DWORD** padwMediaTypes, 
                                        DWORD dwNumElements)
{
    HRESULT hRes					= E_NOTIMPL;
	BOOL	fValid_padwMediaTypes	= TRUE;
    
    // validate padwMediaTypes
    if(!helpIsValidPtr((void*)padwMediaTypes, sizeof(DWORD*), FALSE))
    {
        fValid_padwMediaTypes = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetMediaTypes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "padwMediaTypes == %p   %s",
            padwMediaTypes,
            fValid_padwMediaTypes ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwNumElements == %08Xh",
            dwNumElements);

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->GetMediaTypes(padwMediaTypes, dwNumElements);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetMediaTypes()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_padwMediaTypes)
    {
        // BUGBUG - log contents of padwMediaTypes @ MAXLOGLEVEL
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTool::GetMediaTypes()


//===========================================================================
// CtIDirectMusicTool::ProcessPMsg()
//
// Encapsulates calls to ProcessPMsg
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - renamed, now uses wrapper classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTool::ProcessPMsg(CtIDirectMusicPerformance* ptdmPerf, 
                                        DMUS_PMSG* pPMSG)
{
    HRESULT                 hRes			= E_NOTIMPL;
    BOOL				    fValid_ptdmPerf	= TRUE;
	BOOL				    fValid_pPMSG	= TRUE;
    IDirectMusicPerformance *pdmPerf        = NULL;
    
    // validate ptdmPerf
    if(!helpIsValidPtr((void*)ptdmPerf, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerf;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pPMSG
    if(!helpIsValidPtr((void*)pPMSG, sizeof(pPMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ProcessPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerf == %p   %s",
            pdmPerf,
            fValid_ptdmPerf ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pPMSG == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->ProcessPMsg(pdmPerf, pPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ProcessPMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::ProcessPMsg()


//===========================================================================
// CtIDirectMusicTool::Flush()
//
// Encapsulates calls to Flush
//
// History:
//  12/31/1997 - a-llucar - created
//  03/05/1998 - davidkl - now uses wrapper classes, fixed logging
//  04/10/1998 - davidkl - added rtTime param
//===========================================================================
HRESULT CtIDirectMusicTool::Flush(CtIDirectMusicPerformance* ptdmPerf, 
                                    DMUS_PMSG* pPMSG,
                                    REFERENCE_TIME rtTime)
{
    HRESULT                 hRes			= E_NOTIMPL;
    BOOL				    fValid_ptdmPerf	= TRUE;
	BOOL				    fValid_pPMSG	= TRUE;
    IDirectMusicPerformance *pdmPerf        = NULL;
    
    // validate ptdmPerf
    if(!helpIsValidPtr((void*)ptdmPerf, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerf;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pPipelineEvent
    if(!helpIsValidPtr((void*)pPMSG, sizeof(pPMSG), FALSE))
    {
        fValid_pPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Flush()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pPerf  == %p   %s",
            pdmPerf,
            fValid_ptdmPerf ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pPMSG  == %p   %s",
            pPMSG,
            fValid_pPMSG ? "" : "BAD");
    if(fValid_pPMSG)
    {
        // BUGBUG - log contents of pPMSG @ STRUCTLOGLEVEL
    }
    fnsLog(PARAMLOGLEVEL, "rtTime == %016Xh",
            rtTime);

    // call the real function
    hRes = ((IDirectMusicTool*)m_pUnk)->Flush(pdmPerf, pPMSG, rtTime);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Flush()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTool::Flush()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctsynsnk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctsynsnk.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctsynsnk.cpp
//
// Test harness implementation of IDirectMusicSynthSink
//
// Functions:
//  CtIDirectMusicSynthSink::CtIDirectMusicSynthSink()
//  CtIDirectMusicSynthSink::~CtIDirectMusicSynthSink()
//  CtIDirectMusicSynthSink::InitTestClass()
//  CtIDirectMusicSynthSink::GetRealObjPtr()
//  CtIDirectMusicSynthSink::QueryInterface()
//  CtIDirectMusicSynthSink::Init()
//  CtIDirectMusicSynthSink::SetFormat()
//  CtIDirectMusicSynthSink::SetMasterClock()
//  CtIDirectMusicSynthSink::GetLatencyClock()
//  CtIDirectMusicSynthSink::Activate()
//  CtIDirectMusicSynthSink::SampleToRefTime()
//  CtIDirectMusicSynthSink::RefTimeToSample()
//  CtIDirectMusicSynthSink::SetDirectSound()
//  CtIDirectMusicSynthSink::GetDesiredBufferSize()
//
// History:
//  03/16/1998 - davidkl - created
//  08/21/1998 - davidkl - added SetDirectSound() / removed SetFormat
//  09/24/1998 - kcraven - added GetDesiredBufferSize()
//===========================================================================

#include "dmth.h"
#include "dmthp.h"

//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicSynthSink::CtIDirectMusicSynthSink()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//  03/17/1998 - davidkl - now inherits from CtIUnknown
//===========================================================================
CtIDirectMusicSynthSink::CtIDirectMusicSynthSink(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSynthSink";
} //*** emd CtIDirectMusicSynthSink::CtIDirectMusicSynthSink()


//===========================================================================
// CtIDirectMusicSynthSink::~CtIDirectMusicSynthSink()
//
// Default destructor
//
// Parameters: none
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//===========================================================================
CtIDirectMusicSynthSink::~CtIDirectMusicSynthSink(void)
{
    // nothing to do

} //*** end CtIDirectMusicSynthSink::~CtIDirectMusicSynthSink()


//===========================================================================
// CtIDirectMusicSynthSink::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicSynthSink object pointer for future use.
//
// Parameters:
//  IDirectMusicSynthSink *pdmSink - pointer to real object
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//  03/17/1998 - davidkl - reimplemented as overloaded version
//===========================================================================
HRESULT CtIDirectMusicSynthSink::InitTestClass(IDirectMusicSynthSink *pdmSink)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSink, sizeof(IDirectMusicSynthSink), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSink));

} //*** end CtIDirectMusicSynthSink::InitTestClass()


//===========================================================================
// CtIDirectMusicSynthSink::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSynthSink **ppdmSink - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  03/16/1998 - davidkl - created
//  03/17/1998 - davidkl - reimplemented as overloaded version
//===========================================================================
HRESULT CtIDirectMusicSynthSink::GetRealObjPtr(IDirectMusicSynthSink **ppdmSink)
{
	// validate ppdm
	if(!helpIsValidPtr(ppdmSink, sizeof(IDirectMusicSynthSink*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSink));

} //*** end CtIDirectMusicSynthSink::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicSynthSink::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  03/16/1998 - davidkl - created
//  03/17/1998 - davidkl - reimplemented as replacement version
//===========================================================================
HRESULT CtIDirectMusicSynthSink::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::QueryInterface()


//===========================================================================
// CtIDirectMusicSynthSink::Init
//
// Encapsulates calls to Init
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//  03/25/1998 - davidkl - implemented
//===========================================================================
HRESULT CtIDirectMusicSynthSink::Init(CtIDirectMusicSynth *ptdmSynth)
{
    HRESULT             hRes                = E_NOTIMPL;
    BOOL                fValid_ptdmSynth    = TRUE;
    IDirectMusicSynth   *pdmSynth           = NULL;

    // validate ptClock
    if(!helpIsValidPtr((void*)ptdmSynth, sizeof(CtIDirectMusicSynth),
                        FALSE))
    {
        fValid_ptdmSynth   = FALSE;

        // we have a bogus pointer, use it as the real thing
        pdmSynth = (IDirectMusicSynth*)ptdmSynth;

    }
    else
    {
        // we have a valid pointer, get the real one from our test object
        hRes = ptdmSynth->GetRealObjPtr(&pdmSynth);
        if(FAILED(hRes))
        {
            // BUGBUG
			// add logging
            goto END;
        }
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Init()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSynth == %p   %s",
            pdmSynth,
            fValid_ptdmSynth ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->Init(pdmSynth);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Init()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // done
END:
    if(fValid_ptdmSynth && pdmSynth)
    {
        pdmSynth->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynthSink::Init()


//===========================================================================
// CtIDirectMusicSynthSink::SetMasterClock
//
// Encapsulates calls to SetMasterClock
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//  03/25/1998 - davidkl - implemented
//===========================================================================
HRESULT CtIDirectMusicSynthSink::SetMasterClock(CtIReferenceClock *ptClock)
{
    HRESULT         hRes            = E_NOTIMPL;
    BOOL            fValid_ptClock  = TRUE;
    IReferenceClock *pRefClock      = NULL;

    // validate ptClock
    if(!helpIsValidPtr((void*)ptClock, sizeof(CtIReferenceClock),
                        FALSE))
    {
        fValid_ptClock   = FALSE;

        // we have a bogus pointer, use it as the real thing
        pRefClock = (IReferenceClock*)ptClock;

    }
    else
    {
        // we have a valid pointer, get the real one from our test object
        hRes = ptClock->GetRealObjPtr(&pRefClock);
        if(FAILED(hRes))
        {
            // BUGBUG
			// add logging
            goto END;
        }
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetMasterClock()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pClock == %p   %s",
            pRefClock,
            fValid_ptClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->SetMasterClock(pRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetMasterClock()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // done
END:
    if(fValid_ptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynthSink::SetMasterClock()


//===========================================================================
// CtIDirectMusicSynthSink::GetLatencyClock
//
// Encapsulates calls to GetLatencyClock
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//  03/25/1998 - davidkl - implemented
//===========================================================================
HRESULT CtIDirectMusicSynthSink::GetLatencyClock(CtIReferenceClock **pptClock)
{
    HRESULT         hRes            = E_NOTIMPL;
    BOOL            fValid_pptClock	= TRUE;
    IReferenceClock *pRefClock      = NULL;
    IReferenceClock **ppRefClock    = NULL;
    
    // validate pptClock
    // NOTE:
    //	If we are passed an invalid CtIReferenceClock pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPort::GetLatencyClock().  
    //  Otherwise, we are to create and return a CtIReferenceClock object
    if(!helpIsValidPtr((void*)pptClock, sizeof(CtIReferenceClock*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptClock = FALSE;
        ppRefClock = (IReferenceClock**)pptClock;

    }
    else
    {
        // valid pointer, create a real object
        ppRefClock = &pRefClock;

        // just in case we fail, init test object ptr to NULL
        *pptClock = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppClock == %p   %s",
            ppRefClock,
            fValid_pptClock ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->GetLatencyClock(ppRefClock);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetLatencyClock()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptClock)
    {
        fnsLog(PARAMLOGLEVEL, "*ppClock == %p",
            *pRefClock);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pRefClock, pptClock);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptClock && pRefClock)
    {
        pRefClock->Release();
    }
    return hRes;

} //*** end CtIDirectMusicSynthSink::GetLatencyClock()


//===========================================================================
// CtIDirectMusicSynthSink::Activate
//
// Encapsulates calls to Activate
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//  03/18/1998 - davidkl - implemented
//  08/21/1998 - davidkl - removed hWnd
//===========================================================================
HRESULT CtIDirectMusicSynthSink::Activate(BOOL fEnable)
{
    HRESULT hRes    = E_NOTIMPL;

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s:Activate()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "fEnable == %s",
            fEnable ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->Activate(fEnable);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s:Activate()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::Activate()


//===========================================================================
// CtIDirectMusicSynthSink::SampleToRefTime
//
// Encapsulates calls to SampleToRefTime
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//===========================================================================
HRESULT CtIDirectMusicSynthSink::SampleToRefTime(DWORD dwSampleTime,
                                                REFERENCE_TIME *prfTime)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_prfTime  = TRUE;

    // validate prfTime
    if(!helpIsValidPtr((void*)prfTime, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prfTime = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s:SampleToRefTime()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwSampleTime == %08Xh",
            dwSampleTime);
    fnsLog(PARAMLOGLEVEL, "prfTime      == %p   %s",
            prfTime,
            fValid_prfTime ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->SampleToRefTime(dwSampleTime,
                                                            prfTime);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s:SampleToRefTime()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prfTime)
    {
        fnsLog(PARAMLOGLEVEL, "*prfTime == %016Xh",
                *prfTime);
    }

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::SampleToRefTime()


//===========================================================================
// CtIDirectMusicSynthSink::RefTimeToSample
//
// Encapsulates calls to RefTimeToSample
//
// Parameters:
//
// Returns:
//
// History:
//  03/17/1998 - davidkl - stubbed
//===========================================================================
HRESULT CtIDirectMusicSynthSink::RefTimeToSample(REFERENCE_TIME rfTime, 
                                                REFERENCE_TIME *prtSampleTime)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwSampleTime    = TRUE;

    // validate pdwSampleTime
    if(!helpIsValidPtr((void*)prtSampleTime, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_pdwSampleTime = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s:RefTimeToSample()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rfTime        == %016Xh",
            rfTime);
    fnsLog(PARAMLOGLEVEL, "pdwSampleTime == %p   %s",
            prtSampleTime,
            fValid_pdwSampleTime ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->RefTimeToSample(rfTime,
                                                            prtSampleTime);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s:RefTimeToSample()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes           == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwSampleTime)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwSampleTime == %016Xh",
                *prtSampleTime);
    }

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::RefTimeToSample()


//===========================================================================
// CtIDirectMusicSynthSink::SetDirectSound
//
// Encapsulates calls to SetDirectSound
//
// Parameters:
//
// Returns:
//
// History:
//  08/21/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicSynthSink::SetDirectSound(LPDIRECTSOUND pDirectSound,
                                        LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    HRESULT hRes                        = E_NOTIMPL;
    BOOL    fValid_pDirectSound         = TRUE;
    BOOL    fValid_pDirectSoundBuffer   = TRUE;

    // validate pDirectSound
    if(!helpIsValidPtr((void*)pDirectSound, sizeof(IDirectSound), TRUE))
    {
        fValid_pDirectSound = FALSE;
    }

    // validate pDirectSoundBuffer
    if(!helpIsValidPtr((void*)pDirectSoundBuffer, sizeof(IDirectSoundBuffer), TRUE))
    {
        fValid_pDirectSoundBuffer = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s:SetDirectSound()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pDirectSound       == %p   %s",
            pDirectSound,
            fValid_pDirectSound ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pDirectSoundBuffer == %p   %s",
            pDirectSoundBuffer,
            fValid_pDirectSoundBuffer ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->SetDirectSound(pDirectSound,
                                                            pDirectSoundBuffer);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s:SetDirectSound()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::SetDirectSound()


//===========================================================================
//===========================================================================
//===========================================================================
// CtIDirectMusicSynthSink::GetDesiredBufferSize
//
// Encapsulates calls to GetDesiredBufferSize
//
// Parameters:
//
// Returns:
//
// History:
//  08/21/1998 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSynthSink::GetDesiredBufferSize(LPDWORD pdwBufferSizeInSamples)
{
    HRESULT hRes                        = E_NOTIMPL;
    BOOL    fValid_pdwBufferSizeInSamples    = TRUE;

    // validate pdwBufferSizeInSamples
    if(!helpIsValidPtr((void*)pdwBufferSizeInSamples, sizeof(DWORD), FALSE))
    {
        fValid_pdwBufferSizeInSamples = FALSE;
    }

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s:GetDesiredBufferSize()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwBufferSizeInSamples       == %p   %s",
            pdwBufferSizeInSamples,
            fValid_pdwBufferSizeInSamples ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSynthSink*)m_pUnk)->GetDesiredBufferSize(pdwBufferSizeInSamples);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s:GetDesiredBufferSize()",
        m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // done
    return hRes;

} //*** end CtIDirectMusicSynthSink::GetDesiredBufferSize()


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\cttrack.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cttrack.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// cttrack.cpp
//
// Test harness implementation of IDirectMusicTrack
//
// Functions:
//  CtIDirectMusicTrack::CtIDirectMusicTrack()
//  CtIDirectMusicTrack::~CtIDirectMusicTrack()
//  CtIDirectMusicTrack::InitTestClass()
//  CtIDirectMusicTrack::GetRealObjPtr()
//  CtIDirectMusicTrack::QueryInterface()
//  CtIDirectMusicTrack::Init()
//  CtIDirectMusicTrack::InitPlay()
//  CtIDirectMusicTrack::EndPlay()
//  CtIDirectMusicTrack::Play()
//  CtIDirectMusicTrack::GetData()
//  CtIDirectMusicTrack::SetData()
//  CtIDirectMusicTrack::TypeSupported()
//  CtIDirectMusicTrack::AddNotify()
//  CtIDirectMusicTrack::RemoveNotify()
//
// History:
//  12/31/1997 - a-llucar - created
//  01/09/1998 - a-llucar - changed Play(), TypeSupported()
//	01/16/1998 - markburt - modified GetData()
//  03/30/1998 - davidkl - implemented inheritance
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"


//---------------------------------------------------------------------------


//===========================================================================
// CtIDirectMusicTrack::CtIDirectMusicTrack()
//
// Default constructor
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicTrack::CtIDirectMusicTrack(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicTrack";

} //*** end CtIDirectMusicTrack::CtIDirectMusicTrack()


//===========================================================================
// CtIDirectMusicTrack::~CtIDirectMusicTrack()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
CtIDirectMusicTrack::~CtIDirectMusicTrack(void)
{
    // nothing to do

} //*** end CtIDirectMusicTrack::~CtIDirectMusicTrack()


//===========================================================================
// CtIDirectMusicTrack::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicPortDownload *pdmTrack - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTrack::InitTestClass(IDirectMusicTrack *pdmTrack)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmTrack, sizeof(IDirectMusicTrack), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmTrack));

} //*** end CtIDirectMusicTrack::InitTestClass()


//===========================================================================
// CtIDirectMusicTrack::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicTrack **ppdmTrack - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/29/1997 - a-llucar - created
//  1/15/98 - bthomas - made it more COM-like
//===========================================================================
HRESULT CtIDirectMusicTrack::GetRealObjPtr(IDirectMusicTrack **ppdmTrack)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmTrack, sizeof(IDirectMusicTrack*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmTrack));

} //*** end CtIDirectMusicTrack::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicTrack::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/29/1997 - a-llucar - created
//===========================================================================
HRESULT CtIDirectMusicTrack::QueryInterface(REFIID riid, 
												LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::QueryInterface


//===========================================================================
// CtIDirectMusicTrack::Init()
//
// Encapsulates calls to Init
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - modified to use wrapped classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTrack::Init(CtIDirectMusicSegment* ptdmSegment)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL		        fValid_ptdmSegment	= TRUE;
    IDirectMusicSegment *pdmSeg             = NULL;
    
    // validate pSegment
    if(!helpIsValidPtr((void*)ptdmSegment, sizeof(CtIDirectMusicSegment), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmSegment = FALSE;
        pdmSeg = (IDirectMusicSegment*)ptdmSegment;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSegment->GetRealObjPtr(&pdmSeg);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSegment == %p   %s",
            pdmSeg,
            (fValid_ptdmSegment) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->Init(pdmSeg);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Init()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSegment && pdmSeg)
    {
        pdmSeg->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTrack::Init()


//===========================================================================
// CtIDirectMusicTrack::InitPlay()
//
// Encapsulates calls to InitPlay
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - modified to use wrapped classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTrack::InitPlay(CtIDirectMusicSegmentState* ptdmSegmentState,
							        CtIDirectMusicPerformance* ptdmPerformance,
									void** ppStateData, DWORD dwVirtualTrackID, 
									DWORD dwFlags)
{
    HRESULT                     hRes					= E_NOTIMPL;
    BOOL		                fValid_ptdmSegmentState	= TRUE;
	BOOL		                fValid_ptdmPerformance	= TRUE;
	BOOL		                fValid_ppStateData  	= TRUE;
    IDirectMusicSegmentState    *pdmSegSt               = NULL;
    IDirectMusicPerformance     *pdmPerf                = NULL;
    
    // validate pSegmentState
    if(!helpIsValidPtr((void*)ptdmSegmentState, sizeof(CtIDirectMusicSegmentState), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmSegmentState = FALSE;
        pdmSegSt = (IDirectMusicSegmentState*)ptdmSegmentState;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSegmentState->GetRealObjPtr(&pdmSegSt);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pPerformance
    if(!helpIsValidPtr((void*)ptdmPerformance, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerformance = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerformance;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerformance->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppStateData
    if(!helpIsValidPtr((void*)ppStateData, 1, FALSE))
    {
        fValid_ppStateData = FALSE;

    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::InitPlay()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSegmentState == %p   %s",
            pdmSegSt,
            fValid_ptdmSegmentState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pPerformance == %p   %s",
            pdmPerf,
            fValid_ptdmPerformance ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppStateData == %p   %s",
            ppStateData,
            fValid_ppStateData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwVirtualTrackID == %08Xh",
            dwVirtualTrackID);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->InitPlay(pdmSegSt, pdmPerf, 
                                ppStateData, dwVirtualTrackID, dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::InitPlay()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    // BUGBUG - log contents of ppStateData?

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSegmentState && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    if(fValid_ptdmPerformance && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTrack::InitPlay()


//===========================================================================
// CtIDirectMusicTrack::EndPlay()
//
// Encapsulates calls to EndPlay
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - fixed logging
//===========================================================================
HRESULT CtIDirectMusicTrack::EndPlay(void* pStateData)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pStateData   = TRUE;

    // validate pStateData
    if(!helpIsValidPtr((void*)pStateData, 1, FALSE))
    {
        fValid_pStateData = FALSE;

    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::EndPlay()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStateData == %p   %s",
            pStateData,
            fValid_pStateData ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->EndPlay(pStateData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::EndPlay()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::EndPlay()


//===========================================================================
// CtIDirectMusicTrack::Play()
//
// Encapsulates calls to Play
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - modified to use wrapped classes, fixed logging
//===========================================================================
HRESULT CtIDirectMusicTrack::Play(void* pStateData, MUSIC_TIME mtStart, 
                                MUSIC_TIME mtEnd, MUSIC_TIME mtOffset, 
                                DWORD dwFlags, 
                                CtIDirectMusicPerformance* ptdmPerf, 
                                CtIDirectMusicSegmentState* ptdmSegSt, 
                                DWORD dwVirtualID)
{
    HRESULT                     hRes				= E_NOTIMPL;
	BOOL		                fValid_ptdmPerf		= TRUE;
    BOOL		                fValid_ptdmSegSt    = TRUE;
    BOOL                        fValid_pStateData   = TRUE;
    IDirectMusicPerformance     *pdmPerf            = NULL;
    IDirectMusicSegmentState    *pdmSegSt           = NULL;

    // validate ptdmSegSt
    if(!helpIsValidPtr((void*)ptdmSegSt, sizeof(CtIDirectMusicSegmentState), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmSegSt = FALSE;
        pdmSegSt = (IDirectMusicSegmentState*)ptdmSegSt;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmSegSt->GetRealObjPtr(&pdmSegSt);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ptdmPerf
    if(!helpIsValidPtr((void*)ptdmPerf, sizeof(CtIDirectMusicPerformance), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ptdmPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)ptdmPerf;

    }
    else
    {
        // good pointer, get the real object
        hRes = ptdmPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pStateData
    if(!helpIsValidPtr((void*)pStateData, 1, FALSE))
    {
        fValid_pStateData = FALSE;

    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Play()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStateData  == %p   %s",
            pStateData,
            fValid_pStateData ? "" : "BAD");
    // BUGBUG log contents of pStateData?
	fnsLog(PARAMLOGLEVEL, "mtStart     == %08Xh",
            mtStart);
	fnsLog(PARAMLOGLEVEL, "mtEnd       == %08Xh",
            mtEnd);
	fnsLog(PARAMLOGLEVEL, "mtOffset    == %08Xh",
            mtOffset);
	fnsLog(PARAMLOGLEVEL, "dwFlags     == %08Xh",
            dwFlags);
	fnsLog(PARAMLOGLEVEL, "pPerf       == %p   %s",
			pdmPerf,
            fValid_ptdmPerf ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "pSegSt      == %p   %s",
            pdmSegSt,
            fValid_ptdmSegSt ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwVirtualID == %08Xh",
            dwVirtualID);

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->Play(pStateData,
                                            mtStart, 
                                            mtEnd, 
                                            mtOffset,
                                            dwFlags, 
                                            pdmPerf, 
                                            pdmSegSt, 
                                            dwVirtualID);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Play()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_ptdmSegSt && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    if(fValid_ptdmPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTrack::Play()


//===========================================================================
// CtIDirectMusicTrack::GetData()
//
// Encapsulates calls to GetData
//
// History:
//  12/29/1997 - a-llucar - created
//	01/16/1998 - markburt - modified
//  03/04/1998 - davidkl - renamed to GetParam, fixed logging
//  03/30/1998 - davidkl - fixed logging (for real this time)
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicTrack::GetParam(REFGUID rguidType, MUSIC_TIME mtTime, 
									 MUSIC_TIME* pmtNext, void* pData)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL	fValid_pmtNext		= TRUE;
    BOOL	fValid_pData		= TRUE;
    char    szGuid[MAX_LOGSTRING];


    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtNext = FALSE;
    }

    // validate pData
    if(!helpIsValidPtr((void*)pData, 1, FALSE))
    {
        fValid_pData = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType  == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "mtTime     == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "pmtNext    == %p   %s",
            pmtNext,
            fValid_pmtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pData      == %p   %s",
            pData,
            fValid_pData ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->GetParam(rguidType, mtTime, pmtNext, pData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetData()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    // BUGBUG want to log out params

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::GetParam()


//===========================================================================
// CtIDirectMusicTrack::SetParam()
//
// Encapsulates calls to SetParam
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed to SetParam, fixed logging
//  03/30/1998 - davidkl - fixed logging (for real this time :)
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicTrack::SetParam(REFGUID rguidType, MUSIC_TIME mtTime, 
										void* pData)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL	fValid_pData		= TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pData
    if(!helpIsValidPtr((void*)pData, 1, FALSE))
    {
        fValid_pData = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType  == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "mtTime     == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "pData      == %p   %s",
            pData,
            fValid_pData ? "" : "BAD");
    // BUGBUG log contents of pData?

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->SetParam(rguidType, mtTime, pData);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetParam()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::SetParam()


//===========================================================================
// CtIDirectMusicTrack::IsParamSupported()
//
// Encapsulates calls to IsParamSupported
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed to IsParamSupported, fixed logging
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicTrack::IsParamSupported(REFGUID rguidType)
{
    HRESULT hRes				= E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];
    
    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::IsParamSupported()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->IsParamSupported(rguidType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::IsParamSupported()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::IsParamSupported()


//===========================================================================
// CtIDirectMusicTrack::AddNotificationType()
//
// Encapsulates calls to AddNotificationType
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//  03/30/1998 - davidkl - fixed logging bug
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicTrack::AddNotificationType(REFGUID rguidNotificationType)
{
    HRESULT hRes						    = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];
    
    dmthGUIDtoString(rguidNotificationType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
            szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->AddNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::AddNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::AddNotificationType()


//===========================================================================
// CtIDirectMusicTrack::RemoveNotificationType()
//
// Encapsulates calls to RemoveNotificationType
//
// History:
//  12/29/1997 - a-llucar - created
//  03/04/1998 - davidkl - renamed, fixed logging
//  03/30/1998 - davidkl - fixed GUID logging bug
//  04/13/1997 - davidkl - changed GUID* to REFGUID
//===========================================================================
HRESULT CtIDirectMusicTrack::RemoveNotificationType(REFGUID rguidNotificationType)
{
    HRESULT hRes						    = E_NOTIMPL;
    char    szGuid[MAX_LOGSTRING];
    
    dmthGUIDtoString(rguidNotificationType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidNotificationType == %s (%s)",
            szGuid, dmthXlatGUID(rguidNotificationType));

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->RemoveNotificationType(rguidNotificationType);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::RemoveNotificationType()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicTrack::RemoveNotify()


//===========================================================================
// CtIDirectMusicTrack::Clone()
//
// Encapsulates calls to Clone
//
// History:
//  03/04/1998 - davidkl - created
//===========================================================================
HRESULT CtIDirectMusicTrack::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, 
                                CtIDirectMusicTrack** pptdmTrack)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL	            fValid_pptdmTrack	= TRUE;
    IDirectMusicTrack   *pdmTrack           = NULL;
    IDirectMusicTrack   **ppdmTrack         = NULL;
    
    // validate pptdmTrack
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicTrack pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicTrack::Clone().  Otherwise, we are to create and
    //  return a CtIDirectMusicTrack object
    if(!helpIsValidPtr((void*)pptdmTrack, sizeof(CtIDirectMusicTrack*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pptdmTrack = FALSE;
        ppdmTrack = (IDirectMusicTrack**)pptdmTrack;

    }
    else
    {
        // valid pointer, create a real object
        ppdmTrack = &pdmTrack;

        // just in case we fail, init test object ptr to NULL
        *pptdmTrack = NULL;
    }
    
	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtStart   == %08Xh",
            mtStart);
    fnsLog(PARAMLOGLEVEL, "mtEnd     == %08Xh",
            mtEnd);
    fnsLog(PARAMLOGLEVEL, "ppTrack   == %p   %s",
            ppdmTrack,
            (fValid_pptdmTrack) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack*)m_pUnk)->Clone(mtStart, mtEnd, ppdmTrack);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Clone()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pptdmTrack)
    {
        fnsLog(PARAMLOGLEVEL, "*ppTrack == %p",
                pdmTrack);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmTrack, pptdmTrack);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
    if(fValid_pptdmTrack && pdmTrack)
    {
        pdmTrack->Release();
    }
    return hRes;

} //*** end CtIDirectMusicTrack::Clone()



//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================


//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\cttrack8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cttrack8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// cttrack.cpp
//
// Test harness implementation of IDirectMusicTrack8
//
// Functions:
//  CtIDirectMusicTrack8::CtIDirectMusicTrack()
//  CtIDirectMusicTrack8::~CtIDirectMusicTrack()
//  CtIDirectMusicTrack8::InitTestClass()
//  CtIDirectMusicTrack8::GetRealObjPtr()
//  CtIDirectMusicTrack8::QueryInterface()
//  CtIDirectMusicTrack8::PlayEx()
//  CtIDirectMusicTrack8::GetParamEx()
//  CtIDirectMusicTrack8::SetParamEx()
//  CtIDirectMusicTrack8::Compose()
//  CtIDirectMusicTrack8::Join()
//
//
// History:
//  10/22/1999 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================


#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"


//===========================================================================
// CtIDirectMusicTrack8::CtIDirectMusicTrack8()
//
// Default constructor
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicTrack8::CtIDirectMusicTrack8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicTrack8";

} // *** end CtIDirectMusicTrack8::CtIDirectMusicTrack8()


//===========================================================================
// CtIDirectMusicTrack8::~CtIDirectMusicTrack8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
CtIDirectMusicTrack8::~CtIDirectMusicTrack8(void)
{
    // nothing to do

} // *** end CtIDirectMusicTrack8::~CtIDirectMusicTrack8()


//===========================================================================
// CtIDirectMusicTrack8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicTrack8 *pdmTrack8 - pointer to real 
//                                      IDirectMusic object
//
// Returns: 
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::InitTestClass(IDirectMusicTrack8 *pdmTrack8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmTrack8, sizeof(IDirectMusicTrack8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmTrack8));

} // *** end CtIDirectMusicTrack8::InitTestClass()


//===========================================================================
// CtIDirectMusicTrack8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicTrack8 **ppdmTrack8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::GetRealObjPtr(IDirectMusicTrack8 **ppdmTrack8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmTrack8, sizeof(IDirectMusicTrack8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmTrack8));

} // *** end CtIDirectMusicTrack8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicTrack8::PlayEx()
//
// Encapsulates calls to PlayEx
//
// History:
//  10/13/1999 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================
HRESULT CtIDirectMusicTrack8::PlayEx
(
	void* pStateData, 
	REFERENCE_TIME rtStart, 
	REFERENCE_TIME rtEnd, 
	REFERENCE_TIME rtOffset, 
	DWORD dwFlags, 
	CtIDirectMusicPerformance* pPerf, 
	CtIDirectMusicSegmentState* pSegSt, 
	DWORD dwVirtualID
)
{
    HRESULT                     hRes					= E_NOTIMPL;
    BOOL		                fValid_pStateData		= TRUE;
    BOOL		                fValid_pPerf			= TRUE;
    BOOL		                fValid_pSegSt			= TRUE;
    IDirectMusicPerformance*	pdmPerf					= NULL;
    IDirectMusicSegmentState*	pdmSegSt                = NULL;

    // validate pStateData
    if(!helpIsValidPtr((void*)pStateData,1, FALSE))
    {
        fValid_pStateData = FALSE;
    }

    // validate pPerf
    if(!helpIsValidPtr((void*)pPerf,sizeof(CtIDirectMusicPerformance*), TRUE))
    {
        // bogus pointer, use as such
        fValid_pPerf = FALSE;
        pdmPerf = (IDirectMusicPerformance*)pPerf;
    }
    else
    {
        // good pointer, get the real object
        hRes = pPerf->GetRealObjPtr(&pdmPerf);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pSegSt
    if(!helpIsValidPtr((void*)pSegSt, sizeof(CtIDirectMusicSegmentState*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pSegSt = FALSE;
        pdmSegSt = (IDirectMusicSegmentState*)pSegSt;

    }
    else
    {
        // good pointer, get the real object
        hRes = pSegSt->GetRealObjPtr(&pdmSegSt);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL,  "---- Calling %s::PlayEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pStateData == %p   %s",
            pStateData,
            fValid_pStateData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "rtStart     == %08X%08Xh",
            (DWORD)(rtStart >> 32), (DWORD)rtStart);
    fnsLog(PARAMLOGLEVEL, "rtEnd       == %08X%08Xh", 
            (DWORD)(rtEnd >> 32), (DWORD)rtEnd);
    fnsLog(PARAMLOGLEVEL, "rtOffset    == %08X%08Xh", 
            (DWORD)(rtOffset >> 32), (DWORD)rtOffset);
    fnsLog(PARAMLOGLEVEL, "dwFlags     == %08Xh", 
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "pPerf       == %p   %s",
            pdmPerf,
            fValid_pPerf ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pSegSt      == %p   %s",
            pdmSegSt,
            fValid_pSegSt ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwVirtualID == %08Xh",
            dwVirtualID);

    // call the real function
    hRes = ((IDirectMusicTrack8*)m_pUnk)->PlayEx(
				pStateData, 
				rtStart, 
				rtEnd, 
				rtOffset, 
				dwFlags, 
				pdmPerf, 
				pdmSegSt, 
				dwVirtualID
				);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::PlayEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pPerf && pdmPerf)
    {
        pdmPerf->Release();
    }
    if(fValid_pSegSt && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    return hRes;

} // *** end CtIDirectMusicTrack8::PlayEx()




//===========================================================================
// CtIDirectMusicTrack8::GetParamEx()
//
// Encapsulates calls to GetParamEx
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::GetParamEx
(
	REFGUID rguidType,
	REFERENCE_TIME rtTime,
	REFERENCE_TIME* prtNext,
	void* pParam,
	void* pStateData,
	DWORD dwFlags
)
{
    HRESULT                     hRes					= E_NOTIMPL;
    BOOL		                fValid_prtNext			= TRUE;
    BOOL		                fValid_pParam			= TRUE;
    BOOL		                fValid_pStateData		= TRUE;
     char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidType, szGuid);

    // validate pmtNext
    if(!helpIsValidPtr((void*)prtNext, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtNext = FALSE;
    }
    // validate pStateData
    if(!helpIsValidPtr((void*)pParam,1, FALSE))
    {
        fValid_pParam = FALSE;
    }
    // validate pStateData
    if(!helpIsValidPtr((void*)pStateData,1, FALSE))
    {
        fValid_pStateData = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL,  "---- Calling %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType  == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "rtTime     == %08X%08Xh",
            (DWORD)(rtTime >> 32), (DWORD)rtTime);
    fnsLog(PARAMLOGLEVEL, "prtNext    == %p   %s",
            prtNext,
            fValid_prtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pParam     == %p   %s",
            pParam,
            fValid_pParam ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pStateData == %p   %s",
            pStateData,
            fValid_pStateData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwFlags    == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicTrack8*)m_pUnk)->GetParamEx(
				rguidType,
				rtTime,
				prtNext,
				pParam,
				pStateData,
				dwFlags
				);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} // *** end CtIDirectMusicTrack8::GetParamEx()




//===========================================================================
// CtIDirectMusicTrack8::SetParamEx()
//
// Encapsulates calls to SetParamEx
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::SetParamEx
(
	REFGUID rguidType,
	REFERENCE_TIME rtTime,
	void* pParam,
	void* pStateData,
	DWORD dwFlags
)
{
    HRESULT	hRes					= E_NOTIMPL;
    BOOL	fValid_pParam			= TRUE;
    BOOL	fValid_pStateData		= TRUE;
	char		szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidType, szGuid);

    // validate pStateData
    if(!helpIsValidPtr((void*)pParam,1, FALSE))
    {
        fValid_pParam = FALSE;
    }
    // validate pStateData
    if(!helpIsValidPtr((void*)pStateData,1, FALSE))
    {
        fValid_pStateData = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL,  "---- Calling %s::SetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType  == %s (%s)",
            szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "rtTime     == %08X%08Xh",
            (DWORD)(rtTime >> 32), (DWORD)rtTime);
    fnsLog(PARAMLOGLEVEL, "pParam     == %p   %s",
            pParam,
            fValid_pParam ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pStateData == %p   %s",
            pStateData,
            fValid_pStateData ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwFlags    == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicTrack8*)m_pUnk)->SetParamEx(
				rguidType,
				rtTime,
				pParam,
				pStateData,
				dwFlags
				);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done

    return hRes;

} // *** end CtIDirectMusicTrack8::SetParamEx()




//===========================================================================
// CtIDirectMusicTrack8::Compose()
//
// Encapsulates calls to Compose
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::Compose
(
	CtIUnknown* pContext,
	DWORD dwTrackGroup,
	CtIDirectMusicTrack** ppResultTrack
)
{
    HRESULT					hRes					= E_NOTIMPL;
    BOOL				    fValid_pContext			= TRUE;
    BOOL				    fValid_ppResultTrack	= TRUE;
    IUnknown*				pdmContext				= NULL;
    IDirectMusicTrack*		pdmResultTrack			= NULL;
    IDirectMusicTrack**		ppdmResultTrack			= NULL;

    // validate pSong
    if(!helpIsValidPtr((void*)pContext,sizeof(CtIUnknown*),TRUE))
    {
        // bogus pointer, use as such
        fValid_pContext = FALSE;
        pdmContext = (IUnknown*)pContext;
    }
    else
    {
        // good pointer, get the real object
        hRes = pContext->GetRealObjPtr(&pdmContext);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppResultTrack
    if(!helpIsValidPtr((void*)ppResultTrack, sizeof(CtIDirectMusicTrack*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppResultTrack = FALSE;
        ppdmResultTrack = (IDirectMusicTrack**)ppResultTrack;

    }
    else
    {
        // valid pointer, create a real object
        ppdmResultTrack = &pdmResultTrack;

        // just in case we fail, init test object ptr to NULL
        *ppResultTrack = NULL;
    }
    
	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pContext      == %p   %s",
            pdmContext,
            (fValid_pContext) ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwTrackGroup  == %08Xh",
            dwTrackGroup);
    fnsLog(PARAMLOGLEVEL, "ppResultTrack == %p   %s",
            ppdmResultTrack,
            (fValid_ppResultTrack) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack8*)m_pUnk)->Compose(pdmContext,dwTrackGroup,ppdmResultTrack);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppResultTrack)
    {
        fnsLog(PARAMLOGLEVEL, "*ppResultTrack == %p",
                pdmResultTrack);
    }

    // create the test object
    if(SUCCEEDED(hRes))
    {
        hRes = dmthCreateTestWrappedObject(pdmResultTrack, ppResultTrack);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_pContext && pdmContext)
    {
        pdmContext->Release();
    }
    if(fValid_ppResultTrack && pdmResultTrack)
    {
        pdmResultTrack->Release();
    }
    return hRes;

} // *** end CtIDirectMusicTrack8::Compose()




//===========================================================================
// CtIDirectMusicTrack8::Join()
//
// Encapsulates calls to Join
//
// History:
//  10/22/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicTrack8::Join
(
	CtIDirectMusicTrack* pNewTrack,
	MUSIC_TIME mtJoin,
    CtIUnknown* pContext,
    DWORD dwTrackGroup,
	CtIDirectMusicTrack** ppResultTrack
)
{
    HRESULT             hRes					= E_NOTIMPL;
    BOOL		        fValid_pNewTrack		= TRUE;
    BOOL				fValid_pContext			= TRUE;
    BOOL	            fValid_ppResultTrack	= TRUE;
    IDirectMusicTrack*	pdmNewTrack				= NULL;
    IUnknown*			pdmContext				= NULL;
    IDirectMusicTrack*	pdmResultTrack			= NULL;
    IDirectMusicTrack**	ppdmResultTrack			= NULL;

    // validate pNewTrack
    if(!helpIsValidPtr((void*)pNewTrack,sizeof(CtIDirectMusicTrack*),TRUE))
    {
        // bogus pointer, use as such
        fValid_pNewTrack = FALSE;
        pdmNewTrack = (IDirectMusicTrack*)pNewTrack;
    }
    else
    {
        // good pointer, get the real object
        hRes = pNewTrack->GetRealObjPtr(&pdmNewTrack);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }
    // validate pContext
    if(!helpIsValidPtr((void*)pContext,sizeof(CtIUnknown*),TRUE))
    {
        // bogus pointer, use as such
        fValid_pContext = FALSE;
        pdmContext = (IUnknown*)pContext;
    }
    else
    {
        // good pointer, get the real object
        hRes = pContext->GetRealObjPtr(&pdmContext);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppResultTrack
    if(!helpIsValidPtr((void*)ppResultTrack, sizeof(CtIDirectMusicTrack*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppResultTrack = FALSE;
        ppdmResultTrack = (IDirectMusicTrack**)ppResultTrack;

    }
    else
    {
        // valid pointer, create a real object
        ppdmResultTrack = &pdmResultTrack;

        // just in case we fail, init test object ptr to NULL
        *ppResultTrack = NULL;
    }
    
	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Join()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pNewTrack     == %p   %s",
            pdmNewTrack,
            (fValid_pNewTrack) ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "mtJoin        == %08Xh",
            mtJoin);
    fnsLog(PARAMLOGLEVEL, "pContext      == %p   %s",
            pdmContext,
            (fValid_pContext) ? "" : "BAD");
	fnsLog(PARAMLOGLEVEL, "dwTrackGroup  == %08Xh",
            dwTrackGroup);
    fnsLog(PARAMLOGLEVEL, "ppResultTrack == %p   %s",
            ppdmResultTrack,
            (fValid_ppResultTrack) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicTrack8*)m_pUnk)->Join(pdmNewTrack,mtJoin,pdmContext,dwTrackGroup,ppdmResultTrack);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Join()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes          == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    // create the test object
    if(SUCCEEDED(hRes) && fValid_ppResultTrack)
    {
        fnsLog(PARAMLOGLEVEL, "*ppResultTrack == %p",
                pdmResultTrack);
        hRes = dmthCreateTestWrappedObject(pdmResultTrack, ppResultTrack);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_pNewTrack && pdmNewTrack)
    {
        pdmNewTrack->Release();
    }
    if(fValid_pContext && pdmContext)
    {
        pdmContext->Release();
    }
    if(fValid_ppResultTrack && pdmResultTrack)
    {
        pdmResultTrack->Release();
    }
    return hRes;

} // *** end CtIDirectMusicTrack8::Join()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctvoice.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctvoice.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctvoice.cpp
//
// Test harness implementation of IDirectMusicVoice
//
// Functions:
//    CtIDirectMusicVoice::CtIDirectMusicVoice()
//    CtIDirectMusicVoice::~CtIDirectMusicVoice()
//    CtIDirectMusicVoice::InitTestClass()
//    CtIDirectMusicVoice::GetRealObjPtr()
//  IUnknown
//    CtIDirectMusicVoice::QueryInterface()
//    CtIDirectMusicVoice::Play()
//  DX8
//    CtIDirectMusicVoice::Stop()
//
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicVoice::CtIDirectMusicVoice()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicVoice::CtIDirectMusicVoice()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicVoice";

} //*** end CtIDirectMusicVoice::CtIDirectMusicVoice()




//===========================================================================
// CtIDirectMusicVoice::~CtIDirectMusicVoice()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectMusicVoice::~CtIDirectMusicVoice(void)
{
    // nothing to do

} //*** emd CtIDirectMusicVoice::~CtIDirectMusicVoice()




//===========================================================================
// CtIDirectMusicVoice::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicVoice object pointer for future use.
//
// Parameters:
//  CtIDirectMusicVoice    *pdmDSDLWave    - pointer to real IDirectMusicVoice object
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicVoice::InitTestClass(IDirectMusicVoice *pdmVoice)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmVoice, sizeof(IDirectMusicVoice), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmVoice));

} //*** end CtIDirectMusicVoice::InitTestClass()




//===========================================================================
// CtIDirectMusicVoice::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicVoice **ppdmVoice - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicVoice::GetRealObjPtr(IDirectMusicVoice **ppdmVoice)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmVoice, sizeof(IDirectMusicVoice*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmVoice));

} //*** end CtIDirectMusicVoice::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicVoice::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicVoice::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicVoice::QueryInterface()




//===========================================================================
// CtIDirectMusicVoice::Play()
//
// Encapsulates calls to Play
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicVoice::Play
(
	REFERENCE_TIME rtStart,
	LONG prPitch,
	LONG vrVolume
)
{
    HRESULT     hRes						= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Play()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtStart == %016Xh",
            rtStart);
    fnsLog(PARAMLOGLEVEL, "prPitch == %ld",
            prPitch);
    fnsLog(PARAMLOGLEVEL, "vrVolume == %ld",
            vrVolume);
    
    // call the real function
    hRes = ((IDirectMusicVoice*)m_pUnk)->Play(rtStart,prPitch,vrVolume);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Play()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicVoice::Play()




//===========================================================================
// CtIDirectMusicVoice::Stop()
//
// Encapsulates calls to Stop
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicVoice::Stop(REFERENCE_TIME rtStop)
{
    HRESULT     hRes						= E_NOTIMPL;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::Stop()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtStop == %016Xh",
            rtStop);
    
    // call the real function
    hRes = ((IDirectMusicVoice*)m_pUnk)->Stop(rtStop);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::Stop()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicVoice::Stop()


//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\ctwave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctwave.cpp
//
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
// ctwave.cpp
//
// Test harness implementation of IDirectSoundDownloadedWave
//
// Functions:
//    CtIDirectSoundDownloadedWave::CtIDirectSoundDownloadedWave()
//    CtIDirectSoundDownloadedWave::~CtIDirectSoundDownloadedWave()
//    CtIDirectSoundDownloadedWave::InitTestClass()
//    CtIDirectSoundDownloadedWave::GetRealObjPtr()
//  IUnknown
//    CtIDirectSoundDownloadedWave::QueryInterface()
//
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectSoundDownloadedWave::CtIDirectSoundDownloadedWave()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectSoundDownloadedWave::CtIDirectSoundDownloadedWave()
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectSoundDownloadedWave";

} //*** end CtIDirectSoundDownloadedWave::CtIDirectSoundDownloadedWave()




//===========================================================================
// CtIDirectSoundDownloadedWave::~CtIDirectSoundDownloadedWave()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
CtIDirectSoundDownloadedWave::~CtIDirectSoundDownloadedWave(void)
{
    // nothing to do

} //*** emd CtIDirectSoundDownloadedWave::~CtIDirectSoundDownloadedWave()




//===========================================================================
// CtIDirectSoundDownloadedWave::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectSoundDownloadedWave object pointer for future use.
//
// Parameters:
//  CtIDirectSoundDownloadedWave    *pdmDSDLWave    - pointer to real CtIDirectSoundDownloadedWave object
//
// Returns: 
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectSoundDownloadedWave::InitTestClass(IDirectSoundDownloadedWave *pdmDSDLWave)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmDSDLWave, sizeof(IDirectSoundDownloadedWave), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmDSDLWave));

} //*** end CtIDirectSoundDownloadedWave::InitTestClass()




//===========================================================================
// CtIDirectSoundDownloadedWave::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectSoundDownloadedWave **ppdmDSDLWave - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectSoundDownloadedWave::GetRealObjPtr(IDirectSoundDownloadedWave **ppdmDSDLWave)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmDSDLWave, sizeof(IDirectSoundDownloadedWave*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmDSDLWave));

} //*** end CtIDirectSoundDownloadedWave::GetRealObjPtr()




//===========================================================================
// CtIDirectSoundDownloadedWave::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// Parameters:
//
// Returns:
//
// History:
//  10/14/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectSoundDownloadedWave::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectSoundDownloadedWave::QueryInterface()
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
//===========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\DS_Log.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  utils.h
//
//  Description:
//		header file for the utilities used by tDSound
//
//	History:
//		12/08/97	MTang			Started it
//==========================================================================;
#pragma once

void Log_DS3DAlgorithm (int, LPGUID);
void Log_DSErr (TCHAR *, HRESULT, int);
void Log_DSCooperativeLevel (int, DWORD);
void Log_GUID (int, LPGUID);
void Log_GUID (int, REFGUID);
void Log_DSCaps (int, LPDSCAPS);
void Log_DSBCaps (int, LPDSBCAPS);
void Log_DSCBCaps (int, LPDSCBCAPS);
void Log_SpeakerConfig (int, DWORD);
void Log_WaveFormatEx(int, LPCWAVEFORMATEX);
void Log_DSBufferDesc(int, LPCDSBUFFERDESC);
void Log_DSBLockFlags(int, DWORD);
void Log_DSCBLockFlags(int, DWORD);
void Log_DSBPlayFlags(int, DWORD);
void Log_DS3DLAllParameters(int, LPCDS3DLISTENER);
void Log_DS3DApplyMode (int, DWORD);
void Log_DS3DBMode (int, DWORD);
void Log_D3DVector(int, const struct _D3DVECTOR *);
void Log_DS3DBAllParameters(int, LPCDS3DBUFFER);
void Log_DSCCaps (int, LPDSCCAPS);
void Log_DSCBufferDesc (int, LPCDSCBUFFERDESC);
void Log_DSBStatus (int, DWORD);
void Log_DSCBStatus (int, DWORD);
void Log_DSCBStartFlags (int, DWORD);
void Log_DSNPositionNotifies (int, DWORD, LPCDSBPOSITIONNOTIFY);
void Log_DSBCapsFlags(int, DWORD);
void Log_DSCBCapsFlags(int, DWORD);
void Log_wFormatTag (int, WORD);

void tstLof(int, TCHAR *, double);		

void DPF_DS3DAlgorithm (int, LPGUID);
void DPF_DSErr (TCHAR *, HRESULT, int);
void DPF_DSCooperativeLevel (int, DWORD);
void DPF_GUID (int, LPGUID);
void DPF_GUID (int, REFGUID);
void DPF_DSCaps (int, LPDSCAPS);
void DPF_DSBCaps (int, LPDSBCAPS);
void DPF_DSCBCaps (int, LPDSCBCAPS);
void DPF_SpeakerConfig (int, DWORD);
void DPF_WaveFormatEx(int, LPCWAVEFORMATEX);
void DPF_DSBufferDesc(int, LPCDSBUFFERDESC);
void DPF_DSBLockFlags(int, DWORD);
void DPF_DSCBLockFlags(int, DWORD);
void DPF_DSBPlayFlags(int, DWORD);
void DPF_DS3DLAllParameters(int, LPCDS3DLISTENER);
void DPF_DS3DApplyMode (int, DWORD);
void DPF_DS3DBMode (int, DWORD);
void DPF_D3DVector(int, const struct _D3DVECTOR *);
void DPF_DS3DBAllParameters(int, LPCDS3DBUFFER);
void DPF_DSCCaps (int, LPDSCCAPS);
void DPF_DSCBufferDesc (int, LPCDSCBUFFERDESC);
void DPF_DSBStatus (int, DWORD);
void DPF_DSCBStatus (int, DWORD);
void DPF_DSCBStartFlags (int, DWORD);
void DPF_DSNPositionNotifies (int, DWORD, LPCDSBPOSITIONNOTIFY);
void DPF_DSBCapsFlags(int, DWORD);
void DPF_DSCBCapsFlags(int, DWORD);
void DPF_wFormatTag (int, WORD);

void DPF_tstLof(int, TCHAR *, double);	

LRESULT _cdecl DummyLog (DWORD, LPSTR, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\diffInfo.cpp ===
#include "diffInfo.h"
#include <assert.h>
#include <stdio.h>

using namespace structDiff;

static ReportFn         report = printf;
static LevelReportFn    levelReport;        // Default is NULL
static DWORD            currentReportLevel;

//////////////////////////////////////////////////////////////////////////
//
//  Compare
//
//  This function compares two structures, given as pPMsg1 and pPMsg2
//  
//  Return Value:
//      E_FAIL   if Error occurred or invalid params
//      S_FALSE  if pPMsg1 != pPMsg2
//      S_OK     if pPMsg1 == pPMsg2
//
//////////////////////////////////////////////////////////////////////////
HRESULT structDiff::CompareImpl (LPVOID pPMsg1, LPVOID pPMsg2, Info* pDiffInfo, int nFields, int size)
{
    HRESULT hr = S_OK;  // Default to equivalency, modify only if something doesn't match.

    if (!memcmp (pPMsg1, pPMsg2, size))
    {
        return hr;
    }

    LPCSTR pLhs = ((LPCSTR) pPMsg1);
    LPCSTR pRhs = ((LPCSTR) pPMsg2);

    for (int i=0;i < size;i++, pLhs++, pRhs++)
    {
        if (*pLhs == *pRhs)
        {
            continue;
        }

        for (int j=0;j<nFields;j++)
        {
            char    value1[16];
            char    value2[16];
            long    iValue1;
            long    iValue2;

            if (i >= pDiffInfo[j].baseOffset && (i - pDiffInfo[j].baseOffset) < pDiffInfo[j].size)
            {
                iValue1 = 0;
                iValue2 = 0;

                assert (pDiffInfo[j].size <= sizeof (long));
    
                memcpy (&iValue1, ((LPCSTR) pPMsg1) + pDiffInfo[j].baseOffset, pDiffInfo[j].size);
                memcpy (&iValue2, ((LPCSTR) pPMsg2) + pDiffInfo[j].baseOffset, pDiffInfo[j].size);

                sprintf (value1, pDiffInfo[j].pszFieldFormat, iValue1);
                sprintf (value2, pDiffInfo[j].pszFieldFormat, iValue2);

                if (levelReport)
                {
                    levelReport (currentReportLevel, "PMsg1->%s = %s, pPMsg2->%s = %s\n",
                        pDiffInfo[j].pszFieldName, value1, pDiffInfo[j].pszFieldName, value2);
                }
                else
                {
                    report("PMsg1->%s = %s, pPMsg2->%s = %s\n",
                        pDiffInfo[j].pszFieldName, value1, pDiffInfo[j].pszFieldName, value2);
                }

                // Offset both sides so we don't find this element again
                int elementRemain = pDiffInfo[j].size - (i - pDiffInfo[j].baseOffset);
                pLhs += elementRemain - 1;
                pRhs += elementRemain - 1;
                i += elementRemain - 1;

                hr = S_FALSE;
                break;
            }
        }
    }


    return hr;
}

void structDiff::SetReportFn (ReportFn reportFn)
{
    if (reportFn)
    {
        report = reportFn;
    }
    else
    {
        report = printf;
    }
}

void structDiff::SetReportFn (LevelReportFn reportFn)
{
    levelReport = reportFn;
}

DWORD structDiff::SetReportLevel (DWORD level)
{
    DWORD retv = currentReportLevel;
    currentReportLevel = level;
    
    return (retv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\DS8_Log.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  DS8_Log.cpp
//
//  Description:
//      Utilities used by DSound 8 interfaces
//
//  History:
//      04/10/00    danhaff         Copied from DSAPI8
//      04/12/00    danhaff         Made everything _stdcall
//                                  moved protos into dmth.h
//      04/14/00    danhaff         Added comparision funx for Send,
//                                  WavesReverb, and DS3DBUFFERs.
//==========================================================================;
#include "dmth.h"
//#include "dmthcom.h"
#include "dmthhelp.h"
//#include <mmreg.h>
//#include <ks.h>
//#include <ksmedia.h>
#include <dsound.h>
#include <stdio.h>
#include <tchar.h>
#include <math.h>
#include <assert.h>

#define ASSERT assert

bool IsfEqual(float f1, float f2)
{
    if (fabs(f1 - f2) < FLT_EPSILON)
        return true;
    else
        return false;

};


bool operator == (D3DVECTOR &v1, D3DVECTOR &v2)
{
    if (
        ( IsfEqual(v1.x, v2.x)) &&
        ( IsfEqual(v1.y, v2.y)) &&
        ( IsfEqual(v1.z, v2.z))
       )
        return true;
    else
        return false;

};


void _stdcall Log_Chorus_Params( int nLogLvl, LPCDSFXChorus lpDSFXC )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXChorus.fWetDryMix  = %g", lpDSFXC->fWetDryMix );
    tstLof( nLogLvl, "DSFXChorus.fDepth      = %g", lpDSFXC->fDepth );
    tstLof( nLogLvl, "DSFXChorus.fFeedback   = %g", lpDSFXC->fFeedback );
    tstLof( nLogLvl, "DSFXChorus.fFrequency  = %g", lpDSFXC->fFrequency );
    fnsLog( nLogLvl, "DSFXChorus.lWaveform   = %ld", lpDSFXC->lWaveform );
    tstLof( nLogLvl, "DSFXChorus.fDelay      = %g", lpDSFXC->fDelay );
    fnsLog( nLogLvl, "DSFXChorus.lPhase      = %ld", lpDSFXC->lPhase );
    fnsDecrementIndent();
}

void _stdcall Log_Flanger_Params( int nLogLvl, LPCDSFXFlanger lpDSFXF )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXFlanger.fWetDryMix = %g", lpDSFXF->fWetDryMix );
    tstLof( nLogLvl, "DSFXFlanger.fDepth     = %g", lpDSFXF->fDepth );
    tstLof( nLogLvl, "DSFXFlanger.fFeedback  = %g", lpDSFXF->fFeedback );
    tstLof( nLogLvl, "DSFXFlanger.fFrequency = %g", lpDSFXF->fFrequency );
    fnsLog( nLogLvl, "DSFXFlanger.lWaveform  = %ld",lpDSFXF->lWaveform );
    tstLof( nLogLvl, "DSFXFlanger.fDelay     = %g", lpDSFXF->fDelay );
    fnsLog( nLogLvl, "DSFXFlanger.lPhase     = %ld",lpDSFXF->lPhase );
    fnsDecrementIndent();
}

/*
void _stdcall Log_Send_Params( int nLogLvl, LPCDSFXSend lpDSFXS )
{
    fnsIncrementIndent();
    fnsLog( nLogLvl, "DSFXSend.lSendLevel     = %ld", lpDSFXS->lSendLevel );
    fnsDecrementIndent();
}
*/

void _stdcall Log_Echo_Params( int nLogLvl, LPCDSFXEcho lpDSFXE )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXEcho.fWetDryMix        = %g", lpDSFXE->fWetDryMix );
    tstLof( nLogLvl, "DSFXEcho.fLeftDelay        = %g", lpDSFXE->fLeftDelay );
    tstLof( nLogLvl, "DSFXEcho.fRightDelay       = %g", lpDSFXE->fRightDelay );
    tstLof( nLogLvl, "DSFXEcho.fFeedback         = %g", lpDSFXE->fFeedback );
    tstLof( nLogLvl, "DSFXEcho.lPanDelay         = %g", lpDSFXE->lPanDelay );
    fnsDecrementIndent();
}

void _stdcall Log_Distortion_Params( int nLogLvl, LPCDSFXDistortion lpDSFXD )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXDistortion.fGain                   = %g", lpDSFXD->fGain );
    tstLof( nLogLvl, "DSFXDistortion.fEdge                   = %g", lpDSFXD->fEdge );
    tstLof( nLogLvl, "DSFXDistortion.fPostEQCenterFrequency  = %g", lpDSFXD->fPostEQCenterFrequency );
    tstLof( nLogLvl, "DSFXDistortion.fPostEQBandwidth        = %g", lpDSFXD->fPostEQBandwidth );
    tstLof( nLogLvl, "DSFXDistortion.fPreLowpassCutoff       = %g", lpDSFXD->fPreLowpassCutoff );
    fnsDecrementIndent();
}

void _stdcall Log_Compressor_Params( int nLogLvl, LPCDSFXCompressor lpDSFXCP )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXCompressor.fGain               = %g", lpDSFXCP->fGain );
    tstLof( nLogLvl, "DSFXCompressor.fAttack             = %g", lpDSFXCP->fAttack );
    tstLof( nLogLvl, "DSFXCompressor.fRelease            = %g", lpDSFXCP->fRelease );
    tstLof( nLogLvl, "DSFXCompressor.fThreshold          = %g", lpDSFXCP->fThreshold );
    tstLof( nLogLvl, "DSFXCompressor.fRatio              = %g", lpDSFXCP->fRatio );
    tstLof( nLogLvl, "DSFXCompressor.fPredelay           = %g", lpDSFXCP->fPredelay );
    fnsDecrementIndent();
}

void _stdcall Log_I3DL2Reverb_Params( int nLogLvl, LPCDSFXI3DL2Reverb lpDSFX3R )
{
    fnsIncrementIndent();
    fnsLog( nLogLvl, "DSFX_I3DL2Reverb.lRoom                  = %ld",    lpDSFX3R->lRoom );
    fnsLog( nLogLvl, "DSFX_I3DL2Reverb.lRoomHF                = %ld",    lpDSFX3R->lRoomHF );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flRoomRolloffFactor    = %g",     lpDSFX3R->flRoomRolloffFactor );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flDecayTime            = %g",     lpDSFX3R->flDecayTime );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flDecayHFRatio         = %g",     lpDSFX3R->flDecayHFRatio );
    fnsLog( nLogLvl, "DSFX_I3DL2Reverb.lReflections           = %ld",    lpDSFX3R->lReflections );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flReflectionsDelay     = %g",     lpDSFX3R->flReflectionsDelay );
    fnsLog( nLogLvl, "DSFX_I3DL2Reverb.lReverb                = %ld",    lpDSFX3R->lReverb );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flReverbDelay          = %g",     lpDSFX3R->flReverbDelay );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flDiffusion            = %g",     lpDSFX3R->flDiffusion );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flDensity              = %g",     lpDSFX3R->flDensity );
    tstLof( nLogLvl, "DSFX_I3DL2Reverb.flHFReference          = %g",     lpDSFX3R->flHFReference );
    fnsDecrementIndent();
}

void _stdcall Log_WavesReverb_Params( int nLogLvl, LPCDSFXWavesReverb lpDSFXWR )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFX_WavesReverb.fInGain                = %g",     lpDSFXWR->fInGain);
    tstLof( nLogLvl, "DSFX_WavesReverb.fReverbMix             = %g",     lpDSFXWR->fReverbMix);
    tstLof( nLogLvl, "DSFX_WavesReverb.fReverbTime            = %g",     lpDSFXWR->fReverbTime);
    tstLof( nLogLvl, "DSFX_WavesReverb.fHighFreqRTRatio       = %g",     lpDSFXWR->fHighFreqRTRatio);
    fnsDecrementIndent();
};


void _stdcall Log_Gargle_Params( int nLogLvl, LPCDSFXGargle lpDSFXG )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXGargle.dwRateHz        = %g", lpDSFXG->dwRateHz );
    tstLof( nLogLvl, "DSFXGargle.dwWaveShape     = %g", lpDSFXG->dwWaveShape );
    fnsDecrementIndent();
}

void _stdcall Log_ParamEq_Params( int nLogLvl, LPCDSFXParamEq lpDSFXP )
{
    fnsIncrementIndent();
    tstLof( nLogLvl, "DSFXParamEq.fCenter        = %g", lpDSFXP->fCenter );
    tstLof( nLogLvl, "DSFXParamEq.fBandwidth     = %g", lpDSFXP->fBandwidth );
    tstLof( nLogLvl, "DSFXParamEq.fGain          = %g", lpDSFXP->fGain );
    fnsDecrementIndent();
}

void _stdcall String_Chorus_Params( char *szMessage, char* szPrompt, LPCDSFXChorus lpDSFXC )
{
    sprintf( szMessage,
        "%s\n    \
DSFXChorus.fWetDryMix   = %g\n    \
DSFXChorus.fDepth       = %g\n    \
DSFXChorus.fFeedback    = %g\n    \
DSFXChorus.fFrequency   = %g\n    \
DSFXChorus.lWaveform    = %ld\n    \
DSFXChorus.fDelay       = %g\n    \
DSFXChorus.lPhase       = %ld\n",
        szPrompt,
        lpDSFXC->fWetDryMix,
        lpDSFXC->fDepth,
        lpDSFXC->fFeedback,
        lpDSFXC->fFrequency,
        lpDSFXC->lWaveform,
        lpDSFXC->fDelay,
        lpDSFXC->lPhase );
}

void _stdcall String_Flanger_Params( char *szMessage, char* szPrompt, LPCDSFXFlanger lpDSFXF )
{
    sprintf( szMessage,
        "%s\n    DSFXFlanger.fDepth      = %g\n    \
DSFXFlanger.fWetDryMix  = %g\n    \
DSFXFlanger.fFeedback   = %g\n    \
DSFXFlanger.fFrequency  = %g\n    \
DSFXFlanger.lWaveform   = %ld\n    \
DSFXFlanger.fDelay      = %g\n    \
DSFXFlanger.lPhase      = %ld\n",
        szPrompt,
        lpDSFXF->fWetDryMix,
        lpDSFXF->fDepth,
        lpDSFXF->fFeedback,
        lpDSFXF->fFrequency,
        lpDSFXF->lWaveform,
        lpDSFXF->fDelay,
        lpDSFXF->lPhase );
}

/*
void _stdcall String_Send_Params( char *szMessage, char* szPrompt, LPCDSFXSend lpDSFXS )
{
    sprintf( szMessage,
        "%s\n    DSFXSend.lSendLevel     = %ld\n",
        szPrompt,
        lpDSFXS->lSendLevel );
}
*/

void _stdcall String_Echo_Params( char *szMessage, char* szPrompt, LPCDSFXEcho lpDSFXE )
{
    sprintf( szMessage,
        "%s\n    \
DSFXEcho.fWetDryMix       = %g\n    \
DSFXEcho.fLeftDelay       = %g\n    \
DSFXEcho.fRightDelay      = %g\n    \
DSFXEcho.fFeedback        = %g\n    \
DSFXEcho.lPanDelay        = %ld\n",
        szPrompt,
        lpDSFXE->fWetDryMix,
        lpDSFXE->fLeftDelay,
        lpDSFXE->fRightDelay,
        lpDSFXE->fFeedback,
        lpDSFXE->lPanDelay );
}

void _stdcall String_Distortion_Params( char *szMessage, char* szPrompt, LPCDSFXDistortion lpDSFXD )
{
    sprintf( szMessage,
        "%s\n    \
DSFXDistortion.fGain                  = %g\n    \
DSFXDistortion.fEdge                  = %g\n    \
DSFXDistortion.fPostEQCenterFrequency = %g\n    \
DSFXDistortion.fPostEQBandwidth       = %g\n    \
DSFXDistortion.fPreLowpassCutoff      = %g\n",
        szPrompt,
        lpDSFXD->fGain,
        lpDSFXD->fEdge,
        lpDSFXD->fPostEQCenterFrequency,
        lpDSFXD->fPostEQBandwidth,
        lpDSFXD->fPreLowpassCutoff );
}

void _stdcall String_Compressor_Params( char *szMessage, char* szPrompt, LPCDSFXCompressor lpDSFXCP )
{
    sprintf( szMessage,
        "%s\n    \
DSFXCompressor.fGain            = %g\n    \
DSFXCompressor.fAttack          = %g\n    \
DSFXCompressor.fRelease         = %g\n    \
DSFXCompressor.fThreshold       = %g\n    \
DSFXCompressor.fRatio           = %g\n    \
DSFXCompressor.fPredelay        = %g\n",
        szPrompt,
        lpDSFXCP->fGain,
        lpDSFXCP->fAttack,
        lpDSFXCP->fRelease,
        lpDSFXCP->fThreshold,
        lpDSFXCP->fRatio,
        lpDSFXCP->fPredelay);
}

void _stdcall String_I3DL2Reverberation_Params( char *szMessage, char* szPrompt, LPCDSFXI3DL2Reverb lpDSFX3R )
{
    sprintf( szMessage,
        "%s\n    DSFX_I3DL2Reverberation.lRoom                  = %g\n\
    DSFX_I3DL2Reverberation.lRoomHF                = %g\n\
    DSFX_I3DL2Reverberation.flRoomRolloffFactor    = %g\n\
    DSFX_I3DL2Reverberation.flDecayTime            = %g\n\
    DSFX_I3DL2Reverberation.flDecayHFRatio         = %g\n\
    DSFX_I3DL2Reverberation.lReflections           = %g\n\
    DSFX_I3DL2Reverberation.flReflectionsDelay     = %g\n\
    DSFX_I3DL2Reverberation.lReverb                = %g\n\
    DSFX_I3DL2Reverberation.flReverbDelay          = %g\n\
    DSFX_I3DL2Reverberation.flDiffusion            = %g\n\
    DSFX_I3DL2Reverberation.flDensity              = %g\n\
    DSFX_I3DL2Reverberation.flHFReference          = %g\n",
        szPrompt,
        lpDSFX3R->lRoom,
        lpDSFX3R->lRoomHF,
        lpDSFX3R->flRoomRolloffFactor,
        lpDSFX3R->flDecayTime,
        lpDSFX3R->flDecayHFRatio,
        lpDSFX3R->lReflections,
        lpDSFX3R->flReflectionsDelay,
        lpDSFX3R->lReverb,
        lpDSFX3R->flReverbDelay,
        lpDSFX3R->flDiffusion,
        lpDSFX3R->flDensity,
        lpDSFX3R->flHFReference );
}

void _stdcall String_Gargle_Params( char *szMessage, char* szPrompt, LPCDSFXGargle lpDSFXG )
{
    sprintf( szMessage,
        "%s\n    DSFXGargle.dwRateHz        = %g\n    DSFXGargle.dwWaveShape     = %g\n",
        szPrompt,
        lpDSFXG->dwRateHz,
        lpDSFXG->dwWaveShape );
}

void _stdcall String_ParamEq_Params( char *szMessage, char* szPrompt, LPCDSFXParamEq lpDSFXP )
{
    sprintf( szMessage,
        "%s\n    DSFXParamEq.fCenter        = %g\n    DSFXParamEq.fBandwidth     = %g\n    DSFXParamEq.fGain          = %g\n",
        szPrompt,
        lpDSFXP->fCenter,
        lpDSFXP->fBandwidth,
        lpDSFXP->fGain );
}

char *_stdcall String_Source_Preset( DWORD dwPreset )
{
    switch (dwPreset)
    {
    case DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW:
        return "DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW";
    case DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW:
        return "DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW";
    case DSFX_I3DL2_MATERIAL_PRESET_THINDOOR:
        return "DSFX_I3DL2_MATERIAL_PRESET_THINDOOR";
    case DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR:
        return "DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR";
    case DSFX_I3DL2_MATERIAL_PRESET_WOODWALL:
        return "DSFX_I3DL2_MATERIAL_PRESET_WOODWALL";
    case DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL:
        return "DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL";
    case DSFX_I3DL2_MATERIAL_PRESET_STONEWALL:
        return "DSFX_I3DL2_MATERIAL_PRESET_STONEWALL";
    case DSFX_I3DL2_MATERIAL_PRESET_CURTAIN:
        return "DSFX_I3DL2_MATERIAL_PRESET_CURTAIN";
    default:
        return "unknown";
    }
}

char * _stdcall String_Room_Preset( DWORD dwPreset )
{
    switch (dwPreset)
    {
    case DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_CITY:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_CITY";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL";
    case DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE:
        return "DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE";
    default:
        return "unknown";
    }
}


/*
BOOL _stdcall Equal_Send_Params( LPCDSFXSend lpDSFXS1, LPCDSFXSend lpDSFXS2 )
{
    ASSERT(lpDSFXS1);
    ASSERT(lpDSFXS2);
    return (lpDSFXS1->lSendLevel == lpDSFXS2->lSendLevel);
}
*/


BOOL _stdcall Equal_Chorus_Params( LPCDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 )
{
    ASSERT(lpDSFXC1);
    ASSERT(lpDSFXC2);

    return ( (fabs(lpDSFXC1->fWetDryMix - lpDSFXC2->fWetDryMix) < FLT_EPSILON) &&
             (fabs(lpDSFXC1->fDepth - lpDSFXC2->fDepth) < FLT_EPSILON) &&
             (fabs(lpDSFXC1->fFeedback - lpDSFXC2->fFeedback) < FLT_EPSILON) &&
             (fabs(lpDSFXC1->fFrequency -lpDSFXC2->fFrequency) < FLT_EPSILON) &&
             (lpDSFXC1->lWaveform == lpDSFXC2->lWaveform) &&
             (fabs(lpDSFXC1->fDelay - lpDSFXC2->fDelay) < FLT_EPSILON) &&
             (lpDSFXC1->lPhase == lpDSFXC2->lPhase) );
}

BOOL _stdcall Equal_Flanger_Params( LPCDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 )
{
    ASSERT(lpDSFXF1);
    ASSERT(lpDSFXF2);

    return ( (fabs(lpDSFXF1->fWetDryMix - lpDSFXF2->fWetDryMix) < FLT_EPSILON) &&
             (fabs(lpDSFXF1->fDepth - lpDSFXF2->fDepth) < FLT_EPSILON) &&
             (fabs(lpDSFXF1->fFeedback - lpDSFXF2->fFeedback) < FLT_EPSILON) &&
             (fabs(lpDSFXF1->fFrequency - lpDSFXF2->fFrequency) < FLT_EPSILON) &&
             (lpDSFXF1->lWaveform == lpDSFXF2->lWaveform) &&
             (fabs(lpDSFXF1->fDelay - lpDSFXF2->fDelay) < FLT_EPSILON) &&
             (lpDSFXF1->lPhase == lpDSFXF2->lPhase) );
}

BOOL _stdcall Equal_Echo_Params( LPCDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 )
{
    ASSERT(lpDSFXE1);
    ASSERT(lpDSFXE2);

    return ( (fabs(lpDSFXE1->fWetDryMix - lpDSFXE2->fWetDryMix) < FLT_EPSILON) &&
             (fabs(lpDSFXE1->fLeftDelay - lpDSFXE2->fLeftDelay) < FLT_EPSILON) &&
             (fabs(lpDSFXE1->fRightDelay - lpDSFXE2->fRightDelay) < FLT_EPSILON) &&
             (fabs(lpDSFXE1->fFeedback - lpDSFXE2->fFeedback) < FLT_EPSILON) &&
             (lpDSFXE1->lPanDelay == lpDSFXE2->lPanDelay) );
}

BOOL _stdcall Equal_Distortion_Params( LPCDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 )
{
    ASSERT(lpDSFXD1);
    ASSERT(lpDSFXD2);

    return ( (fabs(lpDSFXD1->fGain - lpDSFXD2->fGain) < FLT_EPSILON) &&
             (fabs(lpDSFXD1->fEdge - lpDSFXD2->fEdge) < FLT_EPSILON) &&
             (fabs(lpDSFXD1->fPostEQCenterFrequency - lpDSFXD2->fPostEQCenterFrequency) < FLT_EPSILON) &&
             (fabs(lpDSFXD1->fPostEQBandwidth - lpDSFXD2->fPostEQBandwidth) < FLT_EPSILON) &&
             (fabs(lpDSFXD1->fPreLowpassCutoff - lpDSFXD2->fPreLowpassCutoff) < FLT_EPSILON) );
}

BOOL _stdcall Equal_Compressor_Params( LPCDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 )
{
    ASSERT(lpDSFXCP1);
    ASSERT(lpDSFXCP2);

    return ( (fabs(lpDSFXCP1->fRatio - lpDSFXCP2->fRatio) < FLT_EPSILON) &&
             (fabs(lpDSFXCP1->fGain - lpDSFXCP2->fGain) < FLT_EPSILON) &&
             (fabs(lpDSFXCP1->fAttack - lpDSFXCP2->fAttack) < FLT_EPSILON) &&
             (fabs(lpDSFXCP1->fRelease - lpDSFXCP2->fRelease) < FLT_EPSILON) &&
             (fabs(lpDSFXCP1->fThreshold - lpDSFXCP2->fThreshold) < FLT_EPSILON) &&
             (fabs(lpDSFXCP1->fPredelay - lpDSFXCP2->fPredelay) < FLT_EPSILON));
}

BOOL _stdcall Equal_Gargle_Params( LPCDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 )
{
    ASSERT(lpDSFXG1);
    ASSERT(lpDSFXG2);

    return ( (lpDSFXG1->dwRateHz        == lpDSFXG2->dwRateHz) &&
             (lpDSFXG1->dwWaveShape     == lpDSFXG2->dwWaveShape) );
}

BOOL _stdcall Equal_ParamEq_Params( LPCDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 )
{
    ASSERT(lpDSFXP1);
    ASSERT(lpDSFXP2);

    return ( (fabs(lpDSFXP1->fCenter - lpDSFXP2->fCenter) < FLT_EPSILON) &&
             (fabs(lpDSFXP1->fBandwidth - lpDSFXP2->fBandwidth) < FLT_EPSILON) &&
             (fabs(lpDSFXP1->fGain - lpDSFXP2->fGain) < FLT_EPSILON) );
}


BOOL _stdcall Equal_I3DL2Reverb_Params( LPCDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 )
{
    ASSERT(lpDSFX3R1);
    ASSERT(lpDSFX3R2);

    return ( (lpDSFX3R1->lRoom                == lpDSFX3R2->lRoom) &&
             (lpDSFX3R1->lRoomHF              == lpDSFX3R2->lRoomHF) &&
             (fabs(lpDSFX3R1->flRoomRolloffFactor - lpDSFX3R2->flRoomRolloffFactor) < FLT_EPSILON) &&
             (fabs(lpDSFX3R1->flDecayTime - lpDSFX3R2->flDecayTime) < FLT_EPSILON) &&
             (fabs(lpDSFX3R1->flDecayHFRatio - lpDSFX3R2->flDecayHFRatio) < FLT_EPSILON) &&
             (lpDSFX3R1->lReflections         == lpDSFX3R2->lReflections) &&
             (fabs(lpDSFX3R1->flReflectionsDelay - lpDSFX3R2->flReflectionsDelay) < FLT_EPSILON) &&
             (lpDSFX3R1->lReverb              == lpDSFX3R2->lReverb) &&
             (fabs(lpDSFX3R1->flReverbDelay - lpDSFX3R2->flReverbDelay) < FLT_EPSILON) &&
             (fabs(lpDSFX3R1->flDiffusion - lpDSFX3R2->flDiffusion) < FLT_EPSILON) &&
             (fabs(lpDSFX3R1->flDensity - lpDSFX3R2->flDensity) < FLT_EPSILON) &&
             (fabs(lpDSFX3R1->flHFReference - lpDSFX3R2->flHFReference) < FLT_EPSILON) );
}

BOOL _stdcall Equal_WavesReverb_Params( LPCDSFXWavesReverb lpDSFX3W1, LPCDSFXWavesReverb lpDSFX3W2 )
{
    ASSERT(lpDSFX3W1);
    ASSERT(lpDSFX3W2);
    return ( (fabs(lpDSFX3W1->fInGain - lpDSFX3W2->fInGain ) < FLT_EPSILON) &&
             (fabs(lpDSFX3W1->fReverbMix - lpDSFX3W2->fReverbMix) < FLT_EPSILON) &&
             (fabs(lpDSFX3W1->fReverbTime - lpDSFX3W2->fReverbTime) < FLT_EPSILON) &&
             (fabs(lpDSFX3W1->fHighFreqRTRatio - lpDSFX3W2->fHighFreqRTRatio) < FLT_EPSILON));
}


static char g_szErrorEqual[]     = "unexpectedly equal";
static char g_szErrorUnequal []  = "unexpectedly unequal";

/********************************************************************************
HELPER FUNCTION

HISTORY:
    Created 04/14/00      danhaff

DESCRIPTION:
    Prints any unexpectency between two different DS3DBUFFER structs.

    #define EXPECT_EQUALITY   0x2345
    #define EXPECT_INEQUALITY 0x3456

    We need weird numbers to prevent people from passing TRUE and/or FALSE here.
    those values detract from readability.

    The equality of each field of both structs must match the dwExpected value
    passed in.
********************************************************************************/
HRESULT _stdcall Compare_DS3DBUFFER(int iLogLevel, DS3DBUFFER *p1, DS3DBUFFER *p2, DWORD dwExpected)
{
    HRESULT hr = S_OK;
    char *szError;
    bool bExpectedEquality;

    //Depending on what we expect, we'll print different output.
    if (EXPECT_EQUALITY == dwExpected)
    {
        szError = g_szErrorUnequal;
        bExpectedEquality = true;
    }
    else if (EXPECT_INEQUALITY == dwExpected)
    {
        szError = g_szErrorEqual;
        bExpectedEquality = false;
    }
    else
    {
        fnsLog(iLogLevel, "TEST_APP error: someone passed Compare_DS3DBUFFER dwExpected = %d", dwExpected);
        return E_FAIL;
    }

    //check vPosition
    if ( bool(p1->vPosition == p2->vPosition) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffers' positions are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vPosition);
        Log_D3DVector(iLogLevel, &p2->vPosition);
        hr = E_FAIL;
    }

    //check vVelocity
    if (bool( p1->vVelocity == p2->vVelocity) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffers' velocities are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vVelocity);
        Log_D3DVector(iLogLevel, &p2->vVelocity);
        hr = E_FAIL;
    }

    //check dwInsideConeAngle
    if (bool(p1->dwInsideConeAngle == p2->dwInsideConeAngle) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffer's dwInsideConeAngles are %s: %d and %d", szError, p1->dwInsideConeAngle, p2->dwInsideConeAngle);
        hr = E_FAIL;
    }

    //check dwOutsideConeAngle
    if (bool(p1->dwOutsideConeAngle == p2->dwOutsideConeAngle) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffer's dwOutsideConeAngles are %s: %d and %d", szError, p1->dwOutsideConeAngle, p2->dwOutsideConeAngle);
        hr = E_FAIL;
    }

    //check vConeOrientation
    if (bool( p1->vConeOrientation == p2->vConeOrientation) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffers' vConeOrientations are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vConeOrientation);
        Log_D3DVector(iLogLevel, &p2->vConeOrientation);
        hr = E_FAIL;
    }

    //check lConeOutsideVolume
    if (bool(p1->lConeOutsideVolume == p2->lConeOutsideVolume) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffer's lConeOutsideVolumes are %s: %d and %d", szError, p1->lConeOutsideVolume, p2->lConeOutsideVolume);
        hr = E_FAIL;
    }

    //check flMinDistance
    if ( IsfEqual(p1->flMinDistance, p2->flMinDistance) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffer's flMinDistances are %s:", szError);
        tstLof(iLogLevel, "  %g" , p1->flMinDistance);
        tstLof(iLogLevel, "  %g" , p2->flMinDistance);
        hr = E_FAIL;
    }

    //check flMaxDistance
    if (IsfEqual(p1->flMaxDistance, p2->flMaxDistance) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffer's flMaxDistances are %s:", szError);
        tstLof(iLogLevel, "  %g" , p1->flMaxDistance);
        tstLof(iLogLevel, "  %g" , p2->flMaxDistance);
        hr = E_FAIL;
    }

    //check dwMode
    if (bool(p1->dwMode == p2->dwMode) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Buffers' dwModes are %s:", szError);
        Log_DS3DBMode(iLogLevel, p1->dwMode);
        Log_DS3DBMode(iLogLevel, p2->dwMode);
        hr = E_FAIL;
    }

    return hr;
};




/********************************************************************************
HELPER FUNCTION

HISTORY:
    Created 04/14/00      danhaff

DESCRIPTION:
    Prints any unexpectency between two different DS3DLISTENER structs.

    #define EXPECT_EQUALITY   0x2345
    #define EXPECT_INEQUALITY 0x3456
    We need weird numbers to prevent people from passing TRUE and/or FALSE here.
    those values detract from readability.

    The equality of each field of both structs must match the dwExpected value
    passed in.
********************************************************************************/
HRESULT _stdcall Compare_DS3DLISTENER(int iLogLevel, DS3DLISTENER *p1, DS3DLISTENER *p2, DWORD dwExpected)
{
    HRESULT hr = S_OK;
    char *szError;
    bool bExpectedEquality;

    //Depending on what we expect, we'll print different output.
    if (EXPECT_EQUALITY == dwExpected)
    {
        szError = g_szErrorUnequal;
        bExpectedEquality = true;
    }
    else if (EXPECT_INEQUALITY == dwExpected)
    {
        szError = g_szErrorEqual;
        bExpectedEquality = false;
    }
    else
    {
        fnsLog(iLogLevel, "TEST_APP error: someone passed Compare_DS3DLISTENER dwExpected = %d", dwExpected);
        return E_FAIL;
    }

    //check vPosition
    if ( bool(p1->vPosition == p2->vPosition) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listeners' positions are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vPosition);
        Log_D3DVector(iLogLevel, &p2->vPosition);
        hr = E_FAIL;
    }

    //check vVelocity
    if (bool( p1->vVelocity == p2->vVelocity) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listeners' velocities are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vVelocity);
        Log_D3DVector(iLogLevel, &p2->vVelocity);
        hr = E_FAIL;
    }


    //check vOrientFront
    if (bool( p1->vOrientFront == p2->vOrientFront) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listeners' vOrientFront are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vOrientFront);
        Log_D3DVector(iLogLevel, &p2->vOrientFront);
        hr = E_FAIL;
    }

    //check vOrientTop
    if (bool( p1->vOrientTop == p2->vOrientTop) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listeners' vOrientTop are %s:", szError);
        Log_D3DVector(iLogLevel, &p1->vOrientTop);
        Log_D3DVector(iLogLevel, &p2->vOrientTop);
        hr = E_FAIL;
    }

    //check flDistanceFactor
    if ( IsfEqual(p1->flDistanceFactor, p2->flDistanceFactor) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listener's flDistanceFactors are %s:", szError);
        tstLof(iLogLevel, "  %g" , p1->flDistanceFactor);
        tstLof(iLogLevel, "  %g" , p2->flDistanceFactor);
        hr = E_FAIL;
    }

    //check flRolloffFactor
    if ( IsfEqual(p1->flRolloffFactor, p2->flRolloffFactor) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listener's flRolloffFactors are %s:", szError);
        tstLof(iLogLevel, "  %g" , p1->flRolloffFactor);
        tstLof(iLogLevel, "  %g" , p2->flRolloffFactor);
        hr = E_FAIL;
    }

    //check flDopplerFactor
    if ( IsfEqual(p1->flDopplerFactor, p2->flDopplerFactor) != bExpectedEquality)
    {
        fnsLog(iLogLevel, "The 3D Listener's flDopplerFactors are %s:", szError);
        tstLof(iLogLevel, "  %g" , p1->flDopplerFactor);
        tstLof(iLogLevel, "  %g" , p2->flDopplerFactor);
        hr = E_FAIL;
    }


return hr;
};


void _stdcall Copy_Chorus_Params( LPDSFXChorus lpDSFXC1, LPCDSFXChorus lpDSFXC2 )
{
    ASSERT(lpDSFXC1);
    ASSERT(lpDSFXC2);

    lpDSFXC1->fWetDryMix    = lpDSFXC2->fWetDryMix;
    lpDSFXC1->fDepth        = lpDSFXC2->fDepth;
    lpDSFXC1->fFeedback     = lpDSFXC2->fFeedback;
    lpDSFXC1->fFrequency    = lpDSFXC2->fFrequency;
    lpDSFXC1->lWaveform     = lpDSFXC2->lWaveform;
    lpDSFXC1->fDelay        = lpDSFXC2->fDelay;
    lpDSFXC1->lPhase        = lpDSFXC2->lPhase;
}

void _stdcall Copy_Flanger_Params( LPDSFXFlanger lpDSFXF1, LPCDSFXFlanger lpDSFXF2 )
{
    ASSERT(lpDSFXF1);
    ASSERT(lpDSFXF2);

    lpDSFXF1->fWetDryMix    = lpDSFXF2->fWetDryMix;
    lpDSFXF1->fDepth        = lpDSFXF2->fDepth;
    lpDSFXF1->fFeedback     = lpDSFXF2->fFeedback;
    lpDSFXF1->fFrequency    = lpDSFXF2->fFrequency;
    lpDSFXF1->lWaveform     = lpDSFXF2->lWaveform;
    lpDSFXF1->fDelay        = lpDSFXF2->fDelay;
    lpDSFXF1->lPhase        = lpDSFXF2->lPhase;
}

void _stdcall Copy_Echo_Params( LPDSFXEcho lpDSFXE1, LPCDSFXEcho lpDSFXE2 )
{
    ASSERT(lpDSFXE1);
    ASSERT(lpDSFXE2);

    lpDSFXE1->fWetDryMix    = lpDSFXE2->fWetDryMix;
    lpDSFXE1->fLeftDelay    = lpDSFXE2->fLeftDelay;
    lpDSFXE1->fRightDelay   = lpDSFXE2->fRightDelay;
    lpDSFXE1->fFeedback     = lpDSFXE2->fFeedback;
    lpDSFXE1->lPanDelay     = lpDSFXE2->lPanDelay;
}

void _stdcall Copy_Distortion_Params( LPDSFXDistortion lpDSFXD1, LPCDSFXDistortion lpDSFXD2 )
{
    ASSERT(lpDSFXD1);
    ASSERT(lpDSFXD2);

    lpDSFXD1->fGain                  = lpDSFXD2->fGain;
    lpDSFXD1->fEdge                  = lpDSFXD2->fEdge;
    lpDSFXD1->fPostEQCenterFrequency = lpDSFXD2->fPostEQCenterFrequency;
    lpDSFXD1->fPostEQBandwidth       = lpDSFXD2->fPostEQBandwidth;
    lpDSFXD1->fPreLowpassCutoff      = lpDSFXD2->fPreLowpassCutoff;
}

void _stdcall Copy_Compressor_Params( LPDSFXCompressor lpDSFXCP1, LPCDSFXCompressor lpDSFXCP2 )
{
    ASSERT(lpDSFXCP1);
    ASSERT(lpDSFXCP2);

    lpDSFXCP1->fRatio           = lpDSFXCP2->fRatio;
    lpDSFXCP1->fGain            = lpDSFXCP2->fGain;
    lpDSFXCP1->fAttack          = lpDSFXCP2->fAttack;
    lpDSFXCP1->fRelease         = lpDSFXCP2->fRelease;
    lpDSFXCP1->fThreshold       = lpDSFXCP2->fThreshold;
    lpDSFXCP1->fPredelay        = lpDSFXCP2->fPredelay;
}

void _stdcall Copy_Gargle_Params( LPDSFXGargle lpDSFXG1, LPCDSFXGargle lpDSFXG2 )
{
    ASSERT(lpDSFXG1);
    ASSERT(lpDSFXG2);

    lpDSFXG1->dwRateHz        = lpDSFXG2->dwRateHz;
    lpDSFXG1->dwWaveShape     = lpDSFXG2->dwWaveShape;
}

void _stdcall Copy_ParamEq_Params( LPDSFXParamEq lpDSFXP1, LPCDSFXParamEq lpDSFXP2 )
{
    ASSERT(lpDSFXP1);
    ASSERT(lpDSFXP2);

    lpDSFXP1->fCenter           = lpDSFXP2->fCenter;
    lpDSFXP1->fBandwidth        = lpDSFXP2->fBandwidth;
    lpDSFXP1->fGain             = lpDSFXP2->fGain;
}

void _stdcall Copy_I3DL2Reverb_Params( LPDSFXI3DL2Reverb lpDSFX3R1, LPCDSFXI3DL2Reverb lpDSFX3R2 )
{
    ASSERT(lpDSFX3R1);
    ASSERT(lpDSFX3R2);

    lpDSFX3R1->lRoom                    = lpDSFX3R2->lRoom;
    lpDSFX3R1->lRoomHF                  = lpDSFX3R2->lRoomHF;
    lpDSFX3R1->flRoomRolloffFactor      = lpDSFX3R2->flRoomRolloffFactor;
    lpDSFX3R1->flDecayTime              = lpDSFX3R2->flDecayTime;
    lpDSFX3R1->flDecayHFRatio           = lpDSFX3R2->flDecayHFRatio;
    lpDSFX3R1->lReflections             = lpDSFX3R2->lReflections;
    lpDSFX3R1->flReflectionsDelay       = lpDSFX3R2->flReflectionsDelay;
    lpDSFX3R1->lReverb                  = lpDSFX3R2->lReverb;
    lpDSFX3R1->flReverbDelay            = lpDSFX3R2->flReverbDelay;
    lpDSFX3R1->flDiffusion              = lpDSFX3R2->flDiffusion;
    lpDSFX3R1->flDensity                = lpDSFX3R2->flDensity;
    lpDSFX3R1->flHFReference            = lpDSFX3R2->flHFReference;
}

float _stdcall GetRandomFloatVal(float fltMax, float fltMin)
{
    return ( ((float)GetRandomDWORD((DWORD)((fltMax-fltMin)*10000)) + fltMin*10000) / 10000.0f );
}

DWORD _stdcall GetRandomDwordVal(DWORD dwMax, DWORD dwMin)
{
    return GetRandomDWORD(dwMax-dwMin+1) + dwMin;
}

void _stdcall GetRandomEchoParams( LPDSFXEcho lpDSFXE )
{
    ASSERT(lpDSFXE);

    lpDSFXE->fWetDryMix     = GetRandomFloatVal(DSFX_WETDRYMIX_MAX, DSFX_WETDRYMIX_MIN);
    lpDSFXE->fLeftDelay     = GetRandomFloatVal(DSFX_ECHO_LEFTDELAY_MAX, DSFX_ECHO_LEFTDELAY_MIN);
    lpDSFXE->fRightDelay    = GetRandomFloatVal(DSFX_ECHO_RIGHTDELAY_MAX, DSFX_ECHO_RIGHTDELAY_MIN);
    lpDSFXE->fFeedback      = GetRandomFloatVal(DSFX_ECHO_FEEDBACK_MAX, DSFX_ECHO_FEEDBACK_MIN);
    lpDSFXE->lPanDelay      = GetRandomDWORD(  2 );
}

void _stdcall GetRandomChorusParams( LPDSFXChorus lpDSFXC )
{
    ASSERT(lpDSFXC);

    lpDSFXC->fWetDryMix     = GetRandomFloatVal(DSFX_WETDRYMIX_MAX, DSFX_WETDRYMIX_MIN);
    lpDSFXC->fDepth         = GetRandomFloatVal(DSFX_CHORUS_DEPTH_MAX, DSFX_CHORUS_DEPTH_MIN);
    lpDSFXC->fFeedback      = GetRandomFloatVal(DSFX_CHORUS_FEEDBACK_MAX, DSFX_CHORUS_FEEDBACK_MIN);
    lpDSFXC->fFrequency     = GetRandomFloatVal(DSFX_CHORUS_FREQUENCY_MAX, DSFX_CHORUS_FREQUENCY_MIN);
    lpDSFXC->lWaveform      = GetRandomDWORD(  2 );
    lpDSFXC->fDelay         = GetRandomFloatVal(DSFX_CHORUS_DELAY_MAX, DSFX_CHORUS_DELAY_MIN);
    lpDSFXC->lPhase         = ( (int)GetRandomDWORD(  5 ) - 2 ) * 90;
}

void _stdcall GetRandomFlangerParams( LPDSFXFlanger lpDSFXF )
{
    ASSERT(lpDSFXF);

    lpDSFXF->fWetDryMix     = GetRandomFloatVal(DSFX_WETDRYMIX_MAX, DSFX_WETDRYMIX_MIN);
    lpDSFXF->fDepth         = GetRandomFloatVal(DSFX_FLANGER_DEPTH_MAX, DSFX_FLANGER_DEPTH_MIN);
    lpDSFXF->fFeedback      = GetRandomFloatVal(DSFX_FLANGER_FEEDBACK_MAX, DSFX_FLANGER_FEEDBACK_MIN);
    lpDSFXF->fFrequency     = GetRandomFloatVal(DSFX_FLANGER_FREQUENCY_MAX, DSFX_FLANGER_FREQUENCY_MIN);
    lpDSFXF->lWaveform      = GetRandomDWORD(  2 );
    lpDSFXF->fDelay         = GetRandomFloatVal(DSFX_FLANGER_DELAY_MAX, DSFX_FLANGER_DELAY_MIN);
    lpDSFXF->lPhase         = ( (int)GetRandomDWORD(  5 ) - 2 ) * 90;
}

void _stdcall GetRandomDistortionParams( LPDSFXDistortion lpDSFXD )
{
    ASSERT(lpDSFXD);

    lpDSFXD->fGain                     = GetRandomFloatVal(DSFX_DISTORTION_GAIN_MAX, DSFX_DISTORTION_GAIN_MIN);
    lpDSFXD->fEdge                     = GetRandomFloatVal(DSFX_DISTORTION_EDGE_MAX, DSFX_DISTORTION_EDGE_MIN);
    lpDSFXD->fPostEQCenterFrequency    = GetRandomFloatVal(DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MAX, DSFX_DISTORTION_POSTEQCENTERFREQUENCY_MIN);
    lpDSFXD->fPostEQBandwidth          = GetRandomFloatVal(DSFX_DISTORTION_POSTEQBANDWIDTH_MAX, DSFX_DISTORTION_POSTEQBANDWIDTH_MIN);
    lpDSFXD->fPreLowpassCutoff         = GetRandomFloatVal(DSFX_DISTORTION_PRELOWPASSCUTOFF_MAX, DSFX_DISTORTION_PRELOWPASSCUTOFF_MIN);
}

void _stdcall GetRandomCompressorParams( LPDSFXCompressor lpDSFXCP )
{
    ASSERT(lpDSFXCP);

    lpDSFXCP->fRatio            = GetRandomFloatVal(DSFX_COMPRESSOR_RATIO_MAX, DSFX_COMPRESSOR_RATIO_MIN);
    lpDSFXCP->fGain             = GetRandomFloatVal(DSFX_COMPRESSOR_GAIN_MAX, DSFX_COMPRESSOR_GAIN_MIN);
    lpDSFXCP->fAttack           = GetRandomFloatVal(DSFX_COMPRESSOR_ATTACK_MAX, DSFX_COMPRESSOR_ATTACK_MIN);
    lpDSFXCP->fRelease          = GetRandomFloatVal(DSFX_COMPRESSOR_RELEASE_MAX, DSFX_COMPRESSOR_RELEASE_MIN);
    lpDSFXCP->fThreshold        = GetRandomFloatVal(DSFX_COMPRESSOR_THRESHOLD_MAX, DSFX_COMPRESSOR_THRESHOLD_MIN);
    lpDSFXCP->fPredelay         = GetRandomFloatVal(DSFX_COMPRESSOR_PREDELAY_MAX, DSFX_COMPRESSOR_PREDELAY_MIN);
}

void _stdcall GetRandomGargleParams( LPDSFXGargle lpDSFXG )
{
    ASSERT(lpDSFXG);

    lpDSFXG->dwRateHz       =
        GetRandomDWORD(  DSFX_GARGLE_RATEHZ_MAX-DSFX_GARGLE_RATEHZ_MIN+1 ) + DSFX_COMPRESSOR_RATIO_MIN;
    lpDSFXG->dwWaveShape    =
        GetRandomDWORD(  2 ) ? DSFXGARGLE_WAVE_TRIANGLE : DSFXGARGLE_WAVE_SQUARE;
}

void _stdcall GetRandomParamEqParams( LPDSFXParamEq lpDSFXP )
{
    ASSERT(lpDSFXP);

    lpDSFXP->fCenter        =
        (float)(GetRandomDWORD(  (DWORD) (DSFX_PARAMEQ_CENTER_MAX-DSFX_PARAMEQ_CENTER_MIN) ) + DSFX_PARAMEQ_CENTER_MIN);
    lpDSFXP->fBandwidth     =
        (float)(GetRandomDWORD(  (DWORD) (DSFX_PARAMEQ_BANDWIDTH_MAX-DSFX_PARAMEQ_BANDWIDTH_MIN) ) + DSFX_PARAMEQ_BANDWIDTH_MIN);
    lpDSFXP->fGain          =
        (float)(GetRandomDWORD(  (DWORD) (DSFX_PARAMEQ_GAIN_MAX-DSFX_PARAMEQ_GAIN_MIN) ) + DSFX_PARAMEQ_GAIN_MIN);
}

void _stdcall GetRandomI3DL2ReverbParams( LPDSFXI3DL2Reverb lpDSFX3R )
{
    ASSERT(lpDSFX3R);

    lpDSFX3R->lRoom                     =
        GetRandomDWORD(  DSFX_I3DL2REVERB_ROOM_MAX-DSFX_I3DL2REVERB_ROOM_MIN+1 ) + DSFX_I3DL2REVERB_ROOM_MIN;
    lpDSFX3R->lRoomHF                   =
        GetRandomDWORD(  DSFX_I3DL2REVERB_ROOMHF_MAX-DSFX_I3DL2REVERB_ROOMHF_MIN+1 ) + DSFX_I3DL2REVERB_ROOMHF_MIN;
    lpDSFX3R->flRoomRolloffFactor       =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX-DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN)*10000) ) + DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN*10000) / 10000.0f;
    lpDSFX3R->flDecayTime               =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_DECAYTIME_MAX-DSFX_I3DL2REVERB_DECAYTIME_MIN)*10000) ) + DSFX_I3DL2REVERB_DECAYTIME_MIN*10000) / 10000.0f;
    lpDSFX3R->flDecayHFRatio            =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_DECAYHFRATIO_MAX-DSFX_I3DL2REVERB_DECAYHFRATIO_MIN)*10000) ) + DSFX_I3DL2REVERB_DECAYHFRATIO_MIN*10000) / 10000.0f;
    lpDSFX3R->lReflections              =
        GetRandomDWORD(  DSFX_I3DL2REVERB_REFLECTIONS_MAX-DSFX_I3DL2REVERB_REFLECTIONS_MIN+1 ) + DSFX_I3DL2REVERB_REFLECTIONS_MIN;
    lpDSFX3R->flReflectionsDelay        =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX-DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN)*10000) ) + DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN*10000) / 10000.0f;
    lpDSFX3R->lReverb                   =
        GetRandomDWORD(  DSFX_I3DL2REVERB_REVERB_MAX-DSFX_I3DL2REVERB_REVERB_MIN+1 ) + DSFX_I3DL2REVERB_REVERB_MIN;
    lpDSFX3R->flReverbDelay             =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_REVERBDELAY_MAX-DSFX_I3DL2REVERB_REVERBDELAY_MIN)*10000) ) + DSFX_I3DL2REVERB_REVERBDELAY_MIN*10000) / 10000.0f;
    lpDSFX3R->flDiffusion               =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_DIFFUSION_MAX-DSFX_I3DL2REVERB_DIFFUSION_MIN)*10000) ) + DSFX_I3DL2REVERB_DIFFUSION_MIN*10000) / 10000.0f;
    lpDSFX3R->flDensity                 =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_DENSITY_MAX-DSFX_I3DL2REVERB_DENSITY_MIN)*10000) ) + DSFX_I3DL2REVERB_DENSITY_MIN*10000) / 10000.0f;
    lpDSFX3R->flHFReference             =
        (float)(GetRandomDWORD(  (DWORD)((DSFX_I3DL2REVERB_HFREFERENCE_MAX-DSFX_I3DL2REVERB_HFREFERENCE_MIN)*10000) ) + DSFX_I3DL2REVERB_HFREFERENCE_MIN*10000) / 10000.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\RecTake.cpp ===
// RecTake.cpp: implementation of the CRecTake class.
//
//////////////////////////////////////////////////////////////////////
#pragma warning (disable : 4786)

#include "RecTake.h"
#include <assert.h>
#include "diffInfo.h"


static structDiff::Info PMsgInfo[] =
{
	DIFF_INFO (DMUS_PMSG, dwSize, "%08Xh"),
//	  DIFF_INFO (DMUS_PMSG, rtTime, "%I64"),			// This will change in each run, so is not a valid comparason
//	  DIFF_INFO (DMUS_PMSG, mtTime, "%I64"),			// This will change in each run, so is not a valid comparason
	DIFF_INFO (DMUS_PMSG, dwFlags, "%08Xh"),
	DIFF_INFO (DMUS_PMSG, dwPChannel, "%08Xh"),
	DIFF_INFO (DMUS_PMSG, dwVirtualTrackID, "%08Xh"),
//	  DIFF_INFO (DMUS_PMSG, pTool, "%08Xh"),			// This will change in each run, so is not a valid comparason
//	  DIFF_INFO (DMUS_PMSG, pGraph, "%08Xh"),			// This will change in each run, so is not a valid comparason
	DIFF_INFO (DMUS_PMSG, dwType, "%08Xh"),
	DIFF_INFO (DMUS_PMSG, dwVoiceID, "%08Xh"),
	DIFF_INFO (DMUS_PMSG, dwGroupID, "%08Xh"),
	DIFF_INFO (DMUS_PMSG, punkUser, "%08Xh"),
};

// DMUS_NOTE_PMSG
static structDiff::Info notePMsgInfo[] =
{
	DIFF_INFO (DMUS_NOTE_PMSG, mtDuration, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, wMusicValue, "%I64"),
	DIFF_INFO (DMUS_NOTE_PMSG, wMeasure, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, nOffset, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bBeat, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bGrid, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bVelocity, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bFlags, "%08Xh"),
	DIFF_INFO (DMUS_NOTE_PMSG, bTimeRange, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bDurRange, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bVelRange, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bPlayModeFlags, "%08Xh"),
	DIFF_INFO (DMUS_NOTE_PMSG, bSubChordLevel, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, bMidiValue, "%d"),
	DIFF_INFO (DMUS_NOTE_PMSG, cTranspose, "%d"),
};

// DMUS_CURVE_PMSG
static structDiff::Info curvePMsgInfo[] =
{
	DIFF_INFO (DMUS_CURVE_PMSG, mtDuration, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, mtOriginalStart, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, mtResetDuration, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, nStartValue, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, nEndValue, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, nResetValue, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, wMeasure, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, nOffset, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bBeat, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bGrid, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bType, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bCurveShape, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bCCData, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, bFlags, "%08Xh"),
	DIFF_INFO (DMUS_CURVE_PMSG, wParamType, "%d"),
	DIFF_INFO (DMUS_CURVE_PMSG, wMergeIndex, "%d"),
};

// DMUS_MIDI_PMSG				DMUS_PMSGT_MIDI:
static structDiff::Info midiPMsgInfo[] =
{
	DIFF_INFO (DMUS_MIDI_PMSG, bStatus, "%d"),
	DIFF_INFO (DMUS_MIDI_PMSG, bByte1, "%d"),
	DIFF_INFO (DMUS_MIDI_PMSG, bByte2, "%d"),
//BUGBUG
//	  DIFF_INFO (DMUS_MIDI_PMSG, bPad[1], "%d"),
};

// DMUS_NOTIFICATION_PMSG		DMUS_PMSGT_NOTIFICATION:
static structDiff::Info notificationPMsgInfo[] =
{
//BUGBUG
//	  GUID	  guidNotificationType;
	DIFF_INFO (DMUS_NOTIFICATION_PMSG, dwNotificationOption, "%08Xh"),
	DIFF_INFO (DMUS_NOTIFICATION_PMSG, dwField1, "%08Xh"),
	DIFF_INFO (DMUS_NOTIFICATION_PMSG, dwField2, "%08Xh"),
};

// DMUS_PATCH_PMSG				DMUS_PMSGT_PATCH:
static structDiff::Info patchPMsgInfo[] =
{
	DIFF_INFO (DMUS_PATCH_PMSG, byInstrument, "%d"),
	DIFF_INFO (DMUS_PATCH_PMSG, byMSB, "%d"),
	DIFF_INFO (DMUS_PATCH_PMSG, byLSB, "%d"),
//BUGBUG
//	  DIFF_INFO (DMUS_PATCH_PMSG, byPad[1], "%d"),
};

// DMUS_SYSEX_PMSG				DMUS_PMSGT_SYSEX:
static structDiff::Info sysexPMsgInfo[] =
{
	DIFF_INFO (DMUS_SYSEX_PMSG, dwLen, "%08Xh"),
//BUGBUG
//	  DIFF_INFO (DMUS_PATCH_PMSG, abData[1], "%d"),
};

// DMUS_TEMPO_PMSG				DMUS_PMSGT_TEMPO:
static structDiff::Info tempoPMsgInfo[] =
{
	DIFF_INFO (DMUS_TEMPO_PMSG, dblTempo, "%f"),
};

// DMUS_TIMESIG_PMSG			DMUS_PMSGT_TIMESIG:
static structDiff::Info timesigPMsgInfo[] =
{
	DIFF_INFO (DMUS_TIMESIG_PMSG, bBeatsPerMeasure, "%d"),
	DIFF_INFO (DMUS_TIMESIG_PMSG, bBeat, "%d"),
	DIFF_INFO (DMUS_TIMESIG_PMSG, wGridsPerBeat, "%d"),
};

// DMUS_TRANSPOSE_PMSG			DMUS_PMSGT_TRANSPOSE:
static structDiff::Info transposePMsgInfo[] =
{
	DIFF_INFO (DMUS_TRANSPOSE_PMSG, nTranspose, "%d"),
	DIFF_INFO (DMUS_TRANSPOSE_PMSG, wMergeIndex, "%d"),
};

// DMUS_CHANNEL_PRIORITY_PMSG	DMUS_PMSGT_CHANNEL_PRIORITY:
static structDiff::Info channelpriorityPMsgInfo[] =
{
	DIFF_INFO (DMUS_CHANNEL_PRIORITY_PMSG, dwChannelPriority, "%08Xh"),
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRecTake::CRecTake() : m_Count (0)
{

}

CRecTake::~CRecTake()
{
	Erase ();
}

CRecTake* CRecTake::Create()
{
	return (new CRecTake);
}

void CRecTake::AddMsg(DMUS_PMSG const* pPMsg)
{
	AddMsg (m_Count, pPMsg);
}

CRecTake::list CRecTake::GetMessages() const
{
	return (m_MsgList);
}

CRecTake::list CRecTake::GetMessages(DWORD dwType) const
{
	list retv;

	for (const_iterator itt = m_MsgList.begin ();itt != m_MsgList.end ();itt++)
	{
		if (itt->pPMsg->dwType == dwType)
		{
			retv.push_back (*itt);
		}
	}

	return (retv);
}

int CRecTake::GetMessageCount() const
{
	assert (m_MsgList.size () == m_Count);
	return (m_Count);
}

void CRecTake::Erase()
{
	for (iterator itt = m_MsgList.begin ();itt != m_MsgList.end ();itt++)
	{
		// Since this was allocated as a char array, it must be deleted as one
		// See AddMsg
		delete [] reinterpret_cast <char*> (itt->pPMsg);
	}

	m_MsgList.clear ();
	m_Count = 0;
}

HRESULT  CRecTake::Compare(const CRecTake *pTake, ComparePMsgsFn compare) const
{
	if (m_Count != pTake->m_Count)
	{
		return (S_FALSE);
	}

	// Check for internal consistency
	if (m_MsgList.size () != pTake->m_MsgList.size ())
	{
		// BUGBUG: if we EVER get here, we have an internal bug
		return (S_FALSE);
	}

	const_iterator lhs (m_MsgList.begin ());
	const_iterator rhs (pTake->m_MsgList.begin ());
	for (;lhs != m_MsgList.end ();lhs++, rhs++)
	{
		HRESULT hr = compare (lhs->pPMsg, rhs->pPMsg);
		if (hr != S_OK)
		{
			return (hr);
		}
	}

	return (S_OK);
}

HRESULT CRecTake::CompareTwoPMsgs(DMUS_PMSG *pPMsg1, DMUS_PMSG *pPMsg2)
{
	HRESULT hRes = S_FALSE;

	if (pPMsg1->dwType != pPMsg2->dwType)
	{
		return (hRes);
	}

	structDiff::Compare (pPMsg1, pPMsg2, PMsgInfo, sizeof (PMsgInfo) /
					sizeof (PMsgInfo[0]));

	if (!hRes)
	{
		return (hRes);
	}

	switch (pPMsg1->dwType)
	{
		case DMUS_PMSGT_NOTE :
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_NOTE_PMSG* pLhs = reinterpret_cast<DMUS_NOTE_PMSG*> (pPMsg1);
				DMUS_NOTE_PMSG* pRhs = reinterpret_cast<DMUS_NOTE_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, notePMsgInfo, sizeof (notePMsgInfo) /
					sizeof (notePMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_CURVE :
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_CURVE_PMSG* pLhs = reinterpret_cast<DMUS_CURVE_PMSG*> (pPMsg1);
				DMUS_CURVE_PMSG* pRhs = reinterpret_cast<DMUS_CURVE_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, curvePMsgInfo, sizeof (curvePMsgInfo) /
					sizeof (curvePMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_MIDI:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_MIDI_PMSG* pLhs = reinterpret_cast<DMUS_MIDI_PMSG*> (pPMsg1);
				DMUS_MIDI_PMSG* pRhs = reinterpret_cast<DMUS_MIDI_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, midiPMsgInfo, sizeof (midiPMsgInfo) /
					sizeof (midiPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_NOTIFICATION:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_NOTIFICATION_PMSG* pLhs = reinterpret_cast<DMUS_NOTIFICATION_PMSG*> (pPMsg1);
				DMUS_NOTIFICATION_PMSG* pRhs = reinterpret_cast<DMUS_NOTIFICATION_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, notificationPMsgInfo, sizeof (notificationPMsgInfo) /
					sizeof (notificationPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_PATCH:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_PATCH_PMSG* pLhs = reinterpret_cast<DMUS_PATCH_PMSG*> (pPMsg1);
				DMUS_PATCH_PMSG* pRhs = reinterpret_cast<DMUS_PATCH_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, patchPMsgInfo, sizeof (patchPMsgInfo) /
					sizeof (patchPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_SYSEX:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_SYSEX_PMSG* pLhs = reinterpret_cast<DMUS_SYSEX_PMSG*> (pPMsg1);
				DMUS_SYSEX_PMSG* pRhs = reinterpret_cast<DMUS_SYSEX_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, sysexPMsgInfo, sizeof (sysexPMsgInfo) /
					sizeof (sysexPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_TEMPO:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TEMPO_PMSG* pLhs = reinterpret_cast<DMUS_TEMPO_PMSG*> (pPMsg1);
				DMUS_TEMPO_PMSG* pRhs = reinterpret_cast<DMUS_TEMPO_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, tempoPMsgInfo, sizeof (tempoPMsgInfo) /
					sizeof (tempoPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_TIMESIG:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TIMESIG_PMSG* pLhs = reinterpret_cast<DMUS_TIMESIG_PMSG*> (pPMsg1);
				DMUS_TIMESIG_PMSG* pRhs = reinterpret_cast<DMUS_TIMESIG_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, timesigPMsgInfo, sizeof (timesigPMsgInfo) /
					sizeof (timesigPMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_TRANSPOSE:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TRANSPOSE_PMSG* pLhs = reinterpret_cast<DMUS_TRANSPOSE_PMSG*> (pPMsg1);
				DMUS_TRANSPOSE_PMSG* pRhs = reinterpret_cast<DMUS_TRANSPOSE_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, transposePMsgInfo, sizeof (transposePMsgInfo) /
					sizeof (transposePMsgInfo[0])));
			}
			break;

		case DMUS_PMSGT_CHANNEL_PRIORITY:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_CHANNEL_PRIORITY_PMSG* pLhs = reinterpret_cast<DMUS_CHANNEL_PRIORITY_PMSG*> (pPMsg1);
				DMUS_CHANNEL_PRIORITY_PMSG* pRhs = reinterpret_cast<DMUS_CHANNEL_PRIORITY_PMSG*> (pPMsg2);

				return (structDiff::Compare (pLhs, pRhs, channelpriorityPMsgInfo, sizeof (channelpriorityPMsgInfo) /
					sizeof (channelpriorityPMsgInfo[0])));
			}
			break;

		//default:
		//	unsuppored at the moment but don't fail
		 // return (S_FALSE);
	}

	return (E_INVALIDARG);
}

HRESULT CRecTake::ReadTake(int resource)
{
	Erase ();

	HRSRC hResInfo = FindResource (NULL, MAKEINTRESOURCE (resource), "TAKE");
	if (!hResInfo)
	{
		return (E_INVALIDARG);
	}

	HGLOBAL hRes = LoadResource (NULL, hResInfo);
	if (!hRes)
	{
		return (E_INVALIDARG);
	}

	LPVOID pRes = LockResource (hRes);
	if (!pRes)
	{
		return (E_INVALIDARG);
	}

	// Note the extensive use of reinterpret_cast is simply because
	// we are converting raw memory into data
	int nElements = reinterpret_cast<DWORD*> (pRes)[0];
	pRes = reinterpret_cast <char*> (pRes) + sizeof (nElements);

	for (int i=0;i<nElements;i++)
	{
		DWORD dwIndex  = reinterpret_cast<DWORD*> (pRes)[0];
		pRes = reinterpret_cast <char*> (pRes) + sizeof (dwIndex);
		DMUS_PMSG const* pPMsg = reinterpret_cast <DMUS_PMSG*> (pRes);
		DWORD size = pPMsg->dwSize;

		HRESULT hr = AddMsg (dwIndex, pPMsg);

		if (FAILED (hr))
		{
			return (hr);
		}

		pRes = ((char*)pRes) + size;
	}

	return (S_OK);
}

HRESULT CRecTake::AddMsg(DWORD dwIndex, DMUS_PMSG const* pPMsg)
{
	if (!pPMsg)
	{
		return (E_INVALIDARG);
	}

	RECTOOL_PMSG msg;
	msg.dwIndex = dwIndex;

	assert (pPMsg->dwSize >= sizeof (DMUS_PMSG));

	// use reinterpret_cast to allow us to allocate a variable size
	// DMUS_PMSG object; see Erase
	msg.pPMsg = reinterpret_cast <DMUS_PMSG*> (new char[pPMsg->dwSize]);

	// Fail gracefully
	if (!msg.pPMsg)
	{
		return (E_OUTOFMEMORY);
	}

	memcpy (msg.pPMsg, pPMsg, pPMsg->dwSize);

	try
	{
		m_MsgList.push_back (msg);
		m_Count ++;
	}
	catch (...)
	{
		return (E_OUTOFMEMORY);
	}


	return (S_OK);
}

static void PrintMsg (LPVOID pPMsg1, structDiff::Info* pDiffInfo, int nFields, int size)
{
	LPCSTR pLhs = ((LPCSTR) pPMsg1);

	for (int i=0;i < size;i++, pLhs++)
	{
		for (int j=0;j<nFields;j++)
		{
			char		value1[16];
			LONGLONG	iValue1;

			if (i >= pDiffInfo[j].baseOffset && (i - pDiffInfo[j].baseOffset) < pDiffInfo[j].size)
			{
				iValue1 = 0;

				assert (pDiffInfo[j].size <= sizeof (iValue1));

				memcpy (&iValue1, ((LPCSTR) pPMsg1) + pDiffInfo[j].baseOffset, pDiffInfo[j].size);

				sprintf (value1, pDiffInfo[j].pszFieldFormat, iValue1);

				printf ("PMsg->%s = %s\n", pDiffInfo[j].pszFieldName, value1);

				// Offset both sides so we don't find this element again
				int elementRemain = pDiffInfo[j].size - (i - pDiffInfo[j].baseOffset);
				pLhs += elementRemain - 1;
				i += elementRemain - 1;
				break;
			}
		}
	}
}

template <typename T>
static void PrintMsg (T* pPMsg, structDiff::Info* pDiffInfo, int nFields)
{
	PrintMsg (static_cast <void*> (pPMsg), pDiffInfo, nFields, sizeof (*pPMsg));
}


void CRecTake::PrintPMsg (DMUS_PMSG *pPMsg1)
{
	HRESULT hRes = S_FALSE;

	PrintMsg (pPMsg1, PMsgInfo, sizeof (PMsgInfo) / sizeof (PMsgInfo[0]));

	switch (pPMsg1->dwType)
	{
		case DMUS_PMSGT_NOTE :
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_NOTE_PMSG* pLhs = reinterpret_cast<DMUS_NOTE_PMSG*> (pPMsg1);

				PrintMsg (pLhs, notePMsgInfo, sizeof (notePMsgInfo) /
					sizeof (notePMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_CURVE :
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_CURVE_PMSG* pLhs = reinterpret_cast<DMUS_CURVE_PMSG*> (pPMsg1);

				PrintMsg (pLhs, curvePMsgInfo, sizeof (curvePMsgInfo) /
					sizeof (curvePMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_MIDI:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_MIDI_PMSG* pLhs = reinterpret_cast<DMUS_MIDI_PMSG*> (pPMsg1);

				PrintMsg (pLhs, midiPMsgInfo, sizeof (midiPMsgInfo) /
					sizeof (midiPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_NOTIFICATION:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_NOTIFICATION_PMSG* pLhs = reinterpret_cast<DMUS_NOTIFICATION_PMSG*> (pPMsg1);

				PrintMsg (pLhs, notificationPMsgInfo, sizeof (notificationPMsgInfo) /
					sizeof (notificationPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_PATCH:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_PATCH_PMSG* pLhs = reinterpret_cast<DMUS_PATCH_PMSG*> (pPMsg1);

				PrintMsg (pLhs, patchPMsgInfo, sizeof (patchPMsgInfo) /
					sizeof (patchPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_SYSEX:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_SYSEX_PMSG* pLhs = reinterpret_cast<DMUS_SYSEX_PMSG*> (pPMsg1);

				PrintMsg (pLhs, sysexPMsgInfo, sizeof (sysexPMsgInfo) /
					sizeof (sysexPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_TEMPO:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TEMPO_PMSG* pLhs = reinterpret_cast<DMUS_TEMPO_PMSG*> (pPMsg1);

				PrintMsg (pLhs, tempoPMsgInfo, sizeof (tempoPMsgInfo) /
					sizeof (tempoPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_TIMESIG:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TIMESIG_PMSG* pLhs = reinterpret_cast<DMUS_TIMESIG_PMSG*> (pPMsg1);

				PrintMsg (pLhs, timesigPMsgInfo, sizeof (timesigPMsgInfo) /
					sizeof (timesigPMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_TRANSPOSE:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_TRANSPOSE_PMSG* pLhs = reinterpret_cast<DMUS_TRANSPOSE_PMSG*> (pPMsg1);

				PrintMsg (pLhs, transposePMsgInfo, sizeof (transposePMsgInfo) /
					sizeof (transposePMsgInfo[0]));
			}
			break;

		case DMUS_PMSGT_CHANNEL_PRIORITY:
			{
				// Use reinterpret_cast because a static cast would fail
				DMUS_CHANNEL_PRIORITY_PMSG* pLhs = reinterpret_cast<DMUS_CHANNEL_PRIORITY_PMSG*> (pPMsg1);

				PrintMsg (pLhs, channelpriorityPMsgInfo, sizeof (channelpriorityPMsgInfo) /
					sizeof (channelpriorityPMsgInfo[0]));
			}
			break;

		//default:
		//	unsuppored at the moment but don't fail
		 // return (S_FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\DS_Log.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1994, 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  DS_LOG.cpp
//
//  Description:
//      Utilities used by tDSound
//
//  History:
//      12/11/97    MTang           Started it
//      03/29/00    DanHaff         Copied from TDSOUND's utils.cpp
//==========================================================================;
#include "globals.h"


#define FLAG_BUFFER_LENGTH 1024
//#define ASSERT assert

void Log_wFormatTag (int nLevel, WORD wFmt);
void Log_tstLof(int nLevel, CHAR * szFormat, double flNumber);

#define WARNLOGLEVEL 1

void __inline AppendFlag (int * pnPos, CHAR * szFlagBuffer, CHAR * szFlag, BOOL * pbFirst)
{
    if (pnPos == NULL)
    {
        Log(WARNLOGLEVEL, "AppendFlag: NULL POS pointer");
        return;
    }
    if (pbFirst == NULL)
    {
        Log(WARNLOGLEVEL, "AppendFlag: NULL BOOL pointer : pbFirst");
        return;
    }
    if (szFlagBuffer == NULL)
    {
        Log(WARNLOGLEVEL, "AppendFlag: NULL flag buffer");
        return;
    }
    if (strlen(szFlag)+(*pnPos) >= FLAG_BUFFER_LENGTH)
    {
       Log(WARNLOGLEVEL, "AppendFlag: Flag buffer overflow");
       return;
    }

    if (szFlag == NULL)
      return;

    if (*pbFirst)
    {
        *pbFirst = FALSE;
        (*pnPos)+= sprintf(szFlagBuffer+(*pnPos), "%s", szFlag);
    }
    else
        (*pnPos)+= sprintf(szFlagBuffer+(*pnPos), TEXT(" | %s"), szFlag);

}

#define APPEND_FLAG(flag) AppendFlag(&nPos, szFlagBuffer, flag, &bFirst)

/*
void _stdcall Log_DS3DAlgorithm (int nLog, LPGUID lpGuid)
{
    if (NULL == lpGuid)
        return;

    if (IsEqualGUID(DS3DALG_DEFAULT, *lpGuid))
        fnsLog (nLog, "guid3DAlgorithm = DS3DALG_DEFAULT");
    else if (IsEqualGUID(DS3DALG_NO_VIRTUALIZATION, *lpGuid))
        fnsLog (nLog, "guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION");
    else if (IsEqualGUID(DS3DALG_HRTF_FULL, *lpGuid))
        fnsLog (nLog, "guid3DAlgorithm = DS3DALG_HRTF_FULL");
    else if (IsEqualGUID(DS3DALG_HRTF_LIGHT, *lpGuid))
        fnsLog (nLog, "guid3DAlgorithm = DS3DALG_HRTF_LIGHT");
//  else if (IsEqualGUID(DS3DALG_ITD, *lpGuid))
//      fnsLog (nLog, "guid3DAlgorithm = DS3DALG_ITD");
    else
        fnsLog (nLog, "guid3DAlgorithm = (Unknown algorithm)");

}
*/
void _stdcall Log_DSErr (CHAR *szPrompt, HRESULT result, int nLog)
{
    CHAR szErrorString[255];

    ZeroMemory (szErrorString, sizeof (szErrorString));

    switch(result)
    {
//    case DSERR_ALLOCATED:
//        sprintf(szErrorString, "%s returned DSERR_ALLOCATED", szPrompt);
//        break;

    case DSERR_CONTROLUNAVAIL:
        sprintf(szErrorString, "%s returned DSERR_CONTROLUNAVAIL", szPrompt);
        break;

//    case DSERR_INVALIDPARAM:
//        sprintf(szErrorString, "%s returned DSERR_INVALIDPARAM", szPrompt);
//        break;

    case DSERR_INVALIDCALL:
        sprintf(szErrorString, "%s returned DSERR_INVALIDCALL", szPrompt);
        break;

    case DSERR_GENERIC:
        sprintf(szErrorString, "%s returned DSERR_GENERIC", szPrompt);
        break;

//    case DSERR_PRIOLEVELNEEDED:
//        sprintf(szErrorString, "%s returned DSERR_PRIOLEVELNEEDED", szPrompt);
//        break;

    case DSERR_OUTOFMEMORY:
        sprintf(szErrorString, "%s returned DSERR_OUTOFMEMORY", szPrompt);
        break;

//    case DSERR_BADFORMAT:
//        sprintf(szErrorString, "%s returned DSERR_BADFORMAT", szPrompt);
//        break;

    case DSERR_UNSUPPORTED:
        sprintf(szErrorString, "%s returned DSERR_UNSUPPORTED", szPrompt);
        break;

    case DSERR_NODRIVER:
        sprintf(szErrorString, "%s returned DSERR_NODRIVER", szPrompt);
        break;

//    case DSERR_ALREADYINITIALIZED:
//        sprintf(szErrorString, "%s returned DSERR_ALREADYINITIALIZED", szPrompt);
//        break;

    case DSERR_NOAGGREGATION:
        sprintf(szErrorString, "%s returned DSERR_NOAGGREGATION", szPrompt);
        break;

//    case DSERR_BUFFERLOST:
//        sprintf(szErrorString, "%s returned DSERR_BUFFERLOST", szPrompt);
//        break;

//    case DSERR_OTHERAPPHASPRIO:
//        sprintf(szErrorString, "%s returned DSERR_OTHERAPPHASPRIO", szPrompt);
//        break;

//    case DSERR_UNINITIALIZED:
//        sprintf(szErrorString, "%s returned DSERR_UNINITIALIZED", szPrompt);
//        break;

//    case DSERR_NOINTERFACE:
//        sprintf(szErrorString, "%s returned DSERR_NOINTERFACE", szPrompt);
//        break;
/*
    case DSERR_HWUNAVAIL:
        sprintf(szErrorString, "%s returned DSERR_HWUNAVAIL", szPrompt);
        break;
*/
    default:
        sprintf(szErrorString, "%s returned unknown error code (0x%08x)", szPrompt, result);
        break;
    }

    fnsLog( nLog, szErrorString );
}

void _stdcall Log_DSCooperativeLevel (int nLog, DWORD dwLevel)
{
    CHAR szTemp[64];

    strcpy(szTemp, "Cooperative Level: ");

    switch (dwLevel) {
    case DSSCL_EXCLUSIVE:
        strcat(szTemp, "DSSCL_EXCLUSIVE ");
        break;

    case DSSCL_NORMAL:
        strcat(szTemp, "DSSCL_NORMAL ");
        break;

    case DSSCL_PRIORITY:
        strcat(szTemp, "DSSCL_PRIORITY  ");
        break;

    case DSSCL_WRITEPRIMARY:
        strcat(szTemp, "DSSCL_WRITEPRIMARY ");
        break;
    }

    fnsLog(nLog, szTemp);
}

void _stdcall Log_GUID (int nLog, LPGUID lpGuid)
{
    OLECHAR     wszGuid[256];

    if (lpGuid == NULL)
    {
        fnsLog(nLog, "  NULL GUID Pointer");
        return;
    }
    StringFromGUID2(*lpGuid, wszGuid, 256);
    fnsLog(nLog, "  GUID: %ws", wszGuid);
}

void _stdcall Log_GUID (int nLog, REFGUID Guid)
{
    OLECHAR     wszGuid[256];

    StringFromGUID2(Guid, wszGuid, 256);
    fnsLog(nLog, "  GUID: %ws", wszGuid);
}
/*


void _stdcall Log_DSCaps (int nLog, LPDSCAPS lpdscaps)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof(szFlagBuffer));

    if (lpdscaps == NULL)
    {
        fnsLog(nLog, "DSCAPS : NULL pointer");
        return;
    }

    fnsLog(nLog, "DSCAPS:");
    fnsLog(nLog,
            "  dwSize                   = %lu", lpdscaps->dwSize);

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (lpdscaps->dwFlags & DSCAPS_CERTIFIED)
    {
        APPEND_FLAG(" DSCAPS_CERTIFIED");
    }
    if (lpdscaps->dwFlags & DSCAPS_CONTINUOUSRATE)
    {
        APPEND_FLAG(" DSCAPS_CONTINUOUSRATE");
    }
    if (lpdscaps->dwFlags & DSCAPS_EMULDRIVER)
    {
        APPEND_FLAG(" DSCAPS_EMULDRIVER");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARY16BIT)
    {
        APPEND_FLAG(" DSCAPS_PRIMARY16BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARY8BIT)
    {
        APPEND_FLAG(" DSCAPS_PRIMARY8BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARYMONO)
    {
        APPEND_FLAG(" DSCAPS_PRIMARYMONO");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARYSTEREO)
    {
        APPEND_FLAG(" DSCAPS_PRIMARYSTEREO");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARY16BIT)
    {
        APPEND_FLAG(" DSCAPS_SECONDARY16BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARY8BIT)
    {
        APPEND_FLAG(" DSCAPS_SECONDARY8BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARYMONO)
    {
        APPEND_FLAG(" DSCAPS_SECONDARYMONO");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARYSTEREO)
    {
        APPEND_FLAG(" DSCAPS_SECONDARYSTEREO");
    }
    fnsLog(nLog, szFlagBuffer);
//    fnsLog(nLog, "  dwMinSecondarySampleRate          = %lu",
//            lpdscaps->dwMinSecondarySampleRate);
//    fnsLog(nLog, "  dwMaxSecondarySampleRate          = %lu",
//            lpdscaps->dwMaxSecondarySampleRate);
    fnsLog(nLog, "  dwPrimaryBuffers                  = %lu",
            lpdscaps->dwPrimaryBuffers);
    fnsLog(nLog, "  dwMaxHwMixingAllBuffers           = %lu",
            lpdscaps->dwMaxHwMixingAllBuffers);
    fnsLog(nLog, "  dwMaxHwMixingStaticBuffers        = %lu",
            lpdscaps->dwMaxHwMixingStaticBuffers);
    fnsLog(nLog, "  dwMaxHwMixingStreamingBuffers     = %lu",
            lpdscaps->dwMaxHwMixingStreamingBuffers);
    fnsLog(nLog, "  dwFreeHwMixingAllBuffers          = %lu",
            lpdscaps->dwFreeHwMixingAllBuffers);
    fnsLog(nLog, "  dwFreeHwMixingStaticBuffers       = %lu",
            lpdscaps->dwFreeHwMixingStaticBuffers);
    fnsLog(nLog, "  dwFreeHwMixingStreamingBuffers    = %lu",
            lpdscaps->dwFreeHwMixingStreamingBuffers);
    fnsLog(nLog, "  dwMaxHw3DAllBuffers               = %lu",
            lpdscaps->dwMaxHw3DAllBuffers);
    fnsLog(nLog, "  dwMaxHw3DStaticBuffers            = %lu",
            lpdscaps->dwMaxHw3DStaticBuffers);
    fnsLog(nLog, "  dwMaxHw3DStreamingBuffers         = %lu",
            lpdscaps->dwMaxHw3DStreamingBuffers);
    fnsLog(nLog, "  dwTotalHwMemBytes                 = %lu",
            lpdscaps->dwTotalHwMemBytes);
    fnsLog(nLog, "  dwFreeHwMemBytes                  = %lu",
            lpdscaps->dwFreeHwMemBytes);
    fnsLog(nLog, "  dwMaxContigFreeHwMemBytes         = %lu",
            lpdscaps->dwMaxContigFreeHwMemBytes);
    fnsLog(nLog, "  dwUnlockTransferRateHwBuffers     = %lu",
            lpdscaps->dwUnlockTransferRateHwBuffers);
    fnsLog(nLog, "  dwPlayCpuOverheadSwBuffers        = %lu",
            lpdscaps->dwPlayCpuOverheadSwBuffers);
    fnsLog(nLog, "  dwReserved1                       = 0x%08x",
            lpdscaps->dwReserved1);
    fnsLog(nLog, "  dwReserved2                       = 0x%08x",
            lpdscaps->dwReserved2);

}

*/


void _stdcall Log_DSBCapsFlags(int nLog, DWORD dwFlags)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof (szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags               = ");
    if (dwFlags & DSBCAPS_CTRL3D)
    {
        APPEND_FLAG (" DSBCAPS_CTRL3D");
    }
//  if (dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
//  {
//      APPEND_FLAG (" DSBCAPS_CTRLCHANNELVOLUME");
//  }
    if (dwFlags & DSBCAPS_CTRLFREQUENCY)
    {
        APPEND_FLAG (" DSBCAPS_CTRLFREQUENCY");
    }
    if (dwFlags & DSBCAPS_CTRLFX)
    {
        APPEND_FLAG (" DSBCAPS_CTRLFX");
    }
//    if (dwFlags & DSBCAPS_CTRLPAN)
//    {
//        APPEND_FLAG (" DSBCAPS_CTRLPAN");
//    }
    if (dwFlags & DSBCAPS_CTRLVOLUME)
    {
        APPEND_FLAG (" DSBCAPS_CTRLVOLUME");
    }
    if (dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
    {
        APPEND_FLAG (" DSBCAPS_CTRLPOSITIONNOTIFY");
    }
//    if (dwFlags & DSBCAPS_GETCURRENTPOSITION2)
//    {
        //APPEND_FLAG (" DSBCAPS_GETCURRENTPOSITION2");
//    }
//    if (dwFlags & DSBCAPS_GLOBALFOCUS)
//    {
//        APPEND_FLAG (" DSBCAPS_GLOBALFOCUS");
//    }
    if (dwFlags & DSBCAPS_LOCDEFER)
    {
        APPEND_FLAG (" DSBCAPS_LOCDEFER");
    }
    if (dwFlags & DSBCAPS_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBCAPS_LOCHARDWARE");
    }
    if (dwFlags & DSBCAPS_LOCSOFTWARE)
    {
        APPEND_FLAG (" DSBCAPS_LOCSOFTWARE");
    }

/*
    if (dwFlags & DSBCAPS_MIXIN)
    {
        APPEND_FLAG (" DSBCAPS_MIXIN");
    }
*/
//    if (dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE)
//    {
//        APPEND_FLAG (" DSBCAPS_MUTE3DATMAXDISTANCE");
//    }
//    if (dwFlags & DSBCAPS_PRIMARYBUFFER)
//    {
//        APPEND_FLAG (" DSBCAPS_PRIMARYBUFFER");
//    }
//    if (dwFlags & DSBCAPS_STATIC)
//    {
//        APPEND_FLAG (" DSBCAPS_STATIC");
    //}
//    if (dwFlags & DSBCAPS_STICKYFOCUS)
//    {
//        APPEND_FLAG (" DSBCAPS_STIKYFOCUS");
//    }

    fnsLog(nLog, szFlagBuffer);
}


/*
void _stdcall Log_DSBCaps (int nLog, LPDSBCAPS lpdsbcaps)
{
    if (lpdsbcaps == NULL)
    {
        fnsLog(nLog, "DSBCAPS : NULL pointer");
        return;
    }

    fnsLog(nLog, "DSBCAPS :");
    fnsLog(nLog,
            "  dwSize                            = %lu", lpdsbcaps->dwSize);
    Log_DSBCapsFlags(nLog, lpdsbcaps->dwFlags);
    fnsLog(nLog, "  dwBufferBytes           = %lu", lpdsbcaps->dwBufferBytes);
    fnsLog(nLog, "  dwUnlockTransferRate    = %lu", lpdsbcaps->dwUnlockTransferRate);
    fnsLog(nLog, "  dwPlayCpuOverhead       = %lu", lpdsbcaps->dwPlayCpuOverhead);
}

void _stdcall Log_DSCCaps (int nLog, LPDSCCAPS lpdsccaps)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof(szFlagBuffer));

    if (lpdsccaps == NULL)
    {
        fnsLog(nLog, "DSCCAPS : NULL pointer");
        return;
    }

    fnsLog(nLog, "DSCCAPS :");
    fnsLog(nLog,
        "  dwSize                            = %lu", lpdsccaps->dwSize);

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (lpdsccaps->dwFlags & DSCCAPS_EMULDRIVER)
    {
        APPEND_FLAG(" DSCCAPS_EMULDRIVER");
    }

    fnsLog(nLog, szFlagBuffer);
    fnsLog(nLog, "  dwFormats    = 0x%08x", lpdsccaps->dwFormats);
    fnsLog(nLog, "  dwChannels   = 0x%08x", lpdsccaps->dwChannels);
}

void _stdcall Log_DSCBCapsFlags(int nLog, DWORD dwFlags)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;


    ZeroMemory (szFlagBuffer, sizeof(szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (dwFlags & DSCBCAPS_WAVEMAPPED)
    {
        APPEND_FLAG (" DSCBCAPS_WAVEMAPPED");
    }

    fnsLog(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBCaps (int nLog, LPDSCBCAPS lpdscbcaps)
{
    if (lpdscbcaps == NULL)
    {
        fnsLog(nLog, "DSCBCAPS : NULL pointer");
        return;
    }

    fnsLog(nLog, "DSCBCAPS :");
    fnsLog(nLog,
            "  dwSize                            = %lu", lpdscbcaps->dwSize);
    Log_DSCBCapsFlags(nLog, lpdscbcaps->dwFlags);
    fnsLog(nLog, "  dwBufferBytes    = %lu", lpdscbcaps->dwBufferBytes);
    fnsLog(nLog, "  dwReserved       = 0x%08x", lpdscbcaps->dwReserved);
}
*/
void _stdcall Log_SpeakerConfig (int nLog, DWORD dwSpkrCfg)
{
    CHAR szConfiguration[255];

    ZeroMemory (szConfiguration, sizeof(szConfiguration));

    fnsLog(nLog, "Speaker configuration:");

    if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_HEADPHONE)
    {
        sprintf(szConfiguration, "  DSSPEAKER_HEADPHONE");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_MONO)
    {
        sprintf(szConfiguration, "  DSSPEAKER_MONO");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_QUAD)
    {
        sprintf(szConfiguration, "  DSSPEAKER_QUAD");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_SURROUND)
    {
        sprintf(szConfiguration, "  DSSPEAKER_SURROUND");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_STEREO)
    {
        if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_WIDE)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_WIDE");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_NARROW)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_NARROW");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_MIN)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_MIN");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_MAX)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_MAX");
        else
            sprintf(szConfiguration, "  DSSPEAKER_STEREO");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_5POINT1)
    {
        sprintf(szConfiguration, "  DSSPEAKER_5POINT1");
    }
    else
    {
        sprintf(szConfiguration, "  Unknown configuration");
    }

    fnsLog(nLog, szConfiguration);
}



/********************************************************************************
HISTORY:
    danhaff         01/11/00        Made aware of DRM wave formats.
********************************************************************************/
void _stdcall Log_WaveFormatEx(int nLevel, LPCWAVEFORMATEX lpwfx)
{
    if(!lpwfx)
    {
        fnsLog(nLevel, "LPWAVEFORMATEX:  0x%p", lpwfx);
    }
    else
    {
        Log_wFormatTag(nLevel, lpwfx->wFormatTag);

        //Should we log the original WFX in this case?  I am not, for now.
        if (WAVE_FORMAT_DRM == lpwfx->wFormatTag)
        {
            DRMWAVEFORMAT * p = (DRMWAVEFORMAT *)lpwfx;
            fnsLog(nLevel, "WFX                           ");
            fnsLog(nLevel, "  nChannels:                  %d", p->wfx.nChannels);
            fnsLog(nLevel, "  nSamplesPerSec:             %d", p->wfx.nSamplesPerSec);
            fnsLog(nLevel, "  nAvgBytesPerSec:            %d", p->wfx.nAvgBytesPerSec);
            fnsLog(nLevel, "  nBlockAlign:                %d", p->wfx.nBlockAlign);
            fnsLog(nLevel, "  wBitsPerSample:             %d", p->wfx.wBitsPerSample);
            fnsLog(nLevel, "  cbSize:                     %d", p->wfx.cbSize);
            fnsLog(nLevel, "");
            fnsLog(nLevel, "  wReserved:                  %d", p->wReserved);
            fnsLog(nLevel, "  ulContentId:                %d", p->ulContentId);
            fnsLog(nLevel, "WFXSECURE                     ");
            Log_WaveFormatEx(nLevel, &p->wfxSecure);
        }
        else if (WAVE_FORMAT_EXTENSIBLE == lpwfx->wFormatTag)
        {
            WAVEFORMATEXTENSIBLE *  p = (WAVEFORMATEXTENSIBLE *)lpwfx;
            fnsLog(nLevel, "  nChannels:                  %d", p->Format.nChannels);
            fnsLog(nLevel, "  nSamplesPerSec:             %d", p->Format.nSamplesPerSec);
            fnsLog(nLevel, "  nAvgBytesPerSec:            %d", p->Format.nAvgBytesPerSec);
            fnsLog(nLevel, "  nBlockAlign:                %d", p->Format.nBlockAlign);
            fnsLog(nLevel, "  wBitsPerSample:             %d", p->Format.wBitsPerSample);
            fnsLog(nLevel, "  cbSize:                     %d", p->Format.cbSize);

            fnsLog(nLevel, "  wValidBitsPerSample:        %d", p->Samples.wValidBitsPerSample);
            fnsLog(nLevel, "  dwChannelMask:              0x%08x", p->dwChannelMask);
            if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))
            {
                fnsLog (nLevel, "  SubFormat:                  KSDATAFORMAT_SUBTYPE_PCM");
            }
            else if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_ADPCM))
            {
                fnsLog (nLevel, "  SubFormat:                  KSDATAFORMAT_SUBTYPE_ADPCM");
            }
            else if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
            {
                fnsLog (nLevel, "  SubFormat:                  KSDATAFORMAT_SUBTYPE_IEEE_FLOAT");
            }
            else
            {
                fnsLog (nLevel, "  SubFormat:                  UNKNOWN");
                Log_GUID (nLevel, p->SubFormat);
            }
        }
        else //go with default PCM-style data.
        {
            fnsLog(nLevel, "  nChannels:        %d", lpwfx->nChannels);
            fnsLog(nLevel, "  nSamplesPerSec:   %d", lpwfx->nSamplesPerSec);
            fnsLog(nLevel, "  nAvgBytesPerSec:  %d", lpwfx->nAvgBytesPerSec);
            fnsLog(nLevel, "  nBlockAlign:      %d", lpwfx->nBlockAlign);
            fnsLog(nLevel, "  wBitsPerSample:   %d", lpwfx->wBitsPerSample);

            //Can't depend on cbSize being valid if we're only PCM.
            if (WAVE_FORMAT_PCM != lpwfx->wFormatTag)
                fnsLog(nLevel, "  cbSize        :   %d", lpwfx->cbSize);
        }

    }
}

void _stdcall Log_wFormatTag(int nLevel, WORD wFmt)
{
    CHAR    szFormat[FLAG_BUFFER_LENGTH] = " ";

    ZeroMemory (szFormat, sizeof(szFormat));

    fnsLog(nLevel, "wFormatTag:       0x%04x", wFmt);

    Log(nLevel, "wFormatTag:       0x%04x", wFmt);

    switch(wFmt)
    {
        case WAVE_FORMAT_DRM:
            sprintf(szFormat, "WAVE_FORMAT_DRM");
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            sprintf(szFormat, "WAVE_FORMAT_EXTENSIBLE");
            break;

        case WAVE_FORMAT_PCM:
            sprintf(szFormat, "WAVE_FORMAT_PCM");
            break;

        case WAVE_FORMAT_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_ADPCM");
            break;

        case WAVE_FORMAT_IBM_CVSD   :
            sprintf (szFormat, "WAVE_FORMAT_IBM_CVSD   ");
            break;

        case WAVE_FORMAT_ALAW       :
            sprintf (szFormat, "WAVE_FORMAT_ALAW       ");
            break;

        case WAVE_FORMAT_MULAW      :
            sprintf (szFormat, "WAVE_FORMAT_MULAW      ");
            break;

        case WAVE_FORMAT_OKI_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_OKI_ADPCM  ");
            break;

        case WAVE_FORMAT_IMA_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_IMA_ADPCM  ");
            break;

        case WAVE_FORMAT_MEDIASPACE_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_MEDIASPACE_ADPCM");
            break;

        case WAVE_FORMAT_SIERRA_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_SIERRA_ADPCM");
            break;

        case WAVE_FORMAT_G723_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G723_ADPCM ");
            break;

        case WAVE_FORMAT_DIGISTD    :
            sprintf (szFormat, "WAVE_FORMAT_DIGISTD    ");
            break;

        case WAVE_FORMAT_DIGIFIX    :
            sprintf (szFormat, "WAVE_FORMAT_DIGIFIX    ");
            break;

        case WAVE_FORMAT_DIALOGIC_OKI_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM ");
            break;

        case WAVE_FORMAT_YAMAHA_ADPCM       :
            sprintf (szFormat, "WAVE_FORMAT_YAMAHA_ADPCM       ");
            break;

        case WAVE_FORMAT_SONARC :
            sprintf (szFormat, "WAVE_FORMAT_SONARC ");
            break;

        case WAVE_FORMAT_DSPGROUP_TRUESPEECH  :
            sprintf (szFormat, "WAVE_FORMAT_DSPGROUP_TRUESPEECH  ");
            break;

        case WAVE_FORMAT_ECHOSC1 :
            sprintf (szFormat, "WAVE_FORMAT_ECHOSC1 ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF36:
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF36");
            break;

        case WAVE_FORMAT_APTX :
            sprintf (szFormat, "WAVE_FORMAT_APTX ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF10    :
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF10    ");
            break;

        case WAVE_FORMAT_DOLBY_AC2 :
            sprintf (szFormat, "WAVE_FORMAT_DOLBY_AC2 ");
            break;

        case WAVE_FORMAT_GSM610    :
            sprintf (szFormat, "WAVE_FORMAT_GSM610    ");
            break;

        case WAVE_FORMAT_ANTEX_ADPCME      :
            sprintf (szFormat, "WAVE_FORMAT_ANTEX_ADPCME      ");
            break;

        case WAVE_FORMAT_CONTROL_RES_VQLPC :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_VQLPC ");
            break;

        case WAVE_FORMAT_DIGIREAL   :
            sprintf (szFormat, "WAVE_FORMAT_DIGIREAL   ");
            break;

        case WAVE_FORMAT_DIGIADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_DIGIADPCM  ");
            break;

        case WAVE_FORMAT_CONTROL_RES_CR10  :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_CR10  ");
            break;

        case WAVE_FORMAT_NMS_VBXADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_NMS_VBXADPCM  ");
            break;

        case WAVE_FORMAT_CS_IMAADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CS_IMAADPCM ");
            break;

        case WAVE_FORMAT_G721_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G721_ADPCM ");
            break;

        case WAVE_FORMAT_MPEG       :
            sprintf (szFormat, "WAVE_FORMAT_MPEG       ");
            break;

        case WAVE_FORMAT_CREATIVE_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_ADPCM ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH8 :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH8 ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH10:
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH10");
            break;

        case WAVE_FORMAT_FM_TOWNS_SND :
            sprintf (szFormat, "WAVE_FORMAT_FM_TOWNS_SND ");
            break;

        case WAVE_FORMAT_OLIGSM   :
            sprintf (szFormat, "WAVE_FORMAT_OLIGSM   ");
            break;

        case WAVE_FORMAT_OLIADPCM :
            sprintf (szFormat, "WAVE_FORMAT_OLIADPCM ");
            break;

        case WAVE_FORMAT_OLICELP  :
            sprintf (szFormat, "WAVE_FORMAT_OLICELP");
            break;

        case WAVE_FORMAT_OLISBC   :
            sprintf (szFormat, "WAVE_FORMAT_OLISBC");
            break;

        case WAVE_FORMAT_OLIOPR   :
            sprintf (szFormat, "WAVE_FORMAT_OLIOPR");
            break;

        case WAVE_FORMAT_DEVELOPMENT:
            sprintf (szFormat, "WAVE_FORMAT_DEVELOPMENT");
            break;

        default :
            sprintf (szFormat, "Unknown Wave Format");
     }

     fnsLog(nLevel, "  wFormatTag:       %s", szFormat);
}

void _stdcall Log_DSBufferDesc(int nLevel, LPCDSBUFFERDESC lpdsbd)
{
    if (NULL == lpdsbd)
        return;

    // for the compatibility with old DSBUFFERDESC before dx7
    if (!IsBadReadPtr(lpdsbd, lpdsbd->dwSize))
    {
        fnsLog(nLevel, "  dwSize: %lu", lpdsbd->dwSize);
        Log_DSBCapsFlags(nLevel, lpdsbd->dwFlags);
        fnsLog(nLevel, "  dwBufferBytes:  %lu", lpdsbd->dwBufferBytes);
        fnsLog(nLevel, "  dwReserved:  %lu", lpdsbd->dwReserved);
        Log_WaveFormatEx(nLevel, lpdsbd->lpwfxFormat);
        Log_DS3DAlgorithm(nLevel, (LPGUID) &(lpdsbd->guid3DAlgorithm));
    }
}

void _stdcall Log_DSCBufferDesc (int nLevel, LPCDSCBUFFERDESC lpdscbd)
{
    if (NULL == lpdscbd)
        return;

//    if (!IsBadReadPtr(lpdscbd, sizeof(DSCBUFFERDESC)))
    // for the compatibility with old DSCBUFFERDESC before dx7
    if (!IsBadReadPtr(lpdscbd, lpdscbd->dwSize))
    {
        fnsLog(nLevel, "  dwSize:           %lu", lpdscbd->dwSize);
        Log_DSCBCapsFlags(nLevel, lpdscbd->dwFlags);
        fnsLog(nLevel, "  dwBufferBytes:    %lu", lpdscbd->dwBufferBytes);
        fnsLog(nLevel, "  dwReserved:       %lu", lpdscbd->dwReserved);
        fnsLog(nLevel, "  LPWAVEFORMATEX: 0x%p", lpdscbd->lpwfxFormat);
        Log_WaveFormatEx(nLevel, lpdscbd->lpwfxFormat);
    }
}

void _stdcall Log_DSBLockFlags(int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];

    ZeroMemory (szFlags, sizeof(szFlags));

    fnsLog(nLog, "Lock flags:");

    if (dwFlags & DSBLOCK_FROMWRITECURSOR)
        sprintf(szFlags, "  DSBLOCK_FROMWRITECURSOR");
    else if (dwFlags & DSBLOCK_ENTIREBUFFER)
        sprintf(szFlags, "  DSBLOCK_ENTIREBUFFER");

    fnsLog(nLog, szFlags);
}

void _stdcall Log_DSCBLockFlags(int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];

    ZeroMemory (szFlags, sizeof(szFlags));

    fnsLog(nLog, "Lock flags:");

    if (dwFlags & DSCBLOCK_ENTIREBUFFER)
        sprintf(szFlags, "  DSCBLOCK_ENTIREBUFFER");

    fnsLog(nLog, szFlags);
}

void _stdcall Log_DSBPlayFlags(int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof (szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags  = ");
    if (dwFlags & DSBPLAY_LOOPING)
    {
        APPEND_FLAG (" DSBPLAY_LOOPING");
    }


    if (dwFlags & DSBPLAY_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBPLAY_LOCHARDWARE");
    }

    if (dwFlags & DSBPLAY_LOCSOFTWARE)
    {
        APPEND_FLAG (" DSBPLAY_LOCSOFTWARE");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_TIME)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_TIME");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_DISTANCE");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_PRIORITY)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_PRIORITY");
    }

    fnsLog(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBStartFlags (int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];

    ZeroMemory (szFlags, sizeof(szFlags));

    fnsLog(nLog, "Start flags:");

    if (dwFlags & DSCBSTART_LOOPING)
        sprintf(szFlags, "  DSCBSTART_LOOPING");

    fnsLog(nLog, szFlags);
}

void _stdcall Log_DSBStatus (int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof (szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwStatus  = ");
    if (dwFlags & DSBSTATUS_PLAYING)
    {
        APPEND_FLAG (" DSBSTATUS_PLAYING");
    }

    if (dwFlags & DSBSTATUS_LOOPING)
    {
        APPEND_FLAG (" DSBSTATUS_LOOPING");
    }

    if (dwFlags & DSBSTATUS_BUFFERLOST)
    {
        APPEND_FLAG (" DSBSTATUS_BUFFERLOST");
    }

    if (dwFlags & DSBSTATUS_LOCSOFTWARE)
    {
        APPEND_FLAG (" DSBSTATUS_LOCSOFTWARE");
    }

    if (dwFlags & DSBSTATUS_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBSTATUS_LOCHARDWARE");
    }
    if (dwFlags & DSBSTATUS_TERMINATED)
    {
        APPEND_FLAG (" DSBSTATUS_TERMINATED");
    }


    fnsLog(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBStatus (int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof(szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwStatus  = ");
    if (dwFlags & DSCBSTATUS_CAPTURING)
    {
        APPEND_FLAG (" DSCBSTATUS_CAPTURING");
    }
    if (dwFlags & DSCBSTATUS_LOOPING)
    {
        APPEND_FLAG (" DSCBSTATUS_LOOPING");
    }

    fnsLog(nLog, szFlagBuffer);
}

void _stdcall Log_DS3DApplyMode (int nLog, DWORD dwMode)
{
    CHAR szMode[255];

    ZeroMemory (szMode, sizeof(szMode));

    if (dwMode == DS3D_DEFERRED)
        sprintf(szMode, "  DS3D_DEFERRED");
    else if (dwMode == DS3D_IMMEDIATE)
        sprintf(szMode, "  DS3D_IMMEDIATE");

    fnsLog(nLog, szMode);
}

void _stdcall Log_DS3DBMode (int nLog, DWORD dwMode)
{
    CHAR szMode[255];

    ZeroMemory (szMode, sizeof(szMode));

    switch (dwMode)
    {
    case DS3DMODE_DISABLE:
        sprintf(szMode, "  DS3DMODE_DISABLE");
        break;

    case DS3DMODE_HEADRELATIVE:
        sprintf(szMode, "  DS3DMODE_HEADRELATIVE");
        break;

    case DS3DMODE_NORMAL:
        sprintf(szMode, "  DS3DMODE_NORMAL");
        break;

    default:
        sprintf(szMode, "  Unknown mode");
        break;
    }

    fnsLog(nLog, szMode);
}

void _stdcall Log_D3DVector(int nLog, const struct _D3DVECTOR * lpv)
{
    if (lpv == NULL)
        return;

    tstLof(nLog, "    %19.9g", lpv->x);
    tstLof(nLog, "    %19.9g", lpv->y);
    tstLof(nLog, "    %19.9g", lpv->z);
}

void _stdcall Log_DS3DLAllParameters(int nLog, LPCDS3DLISTENER lpl)
{
    if (lpl == NULL)
        return;

    fnsLog(nLog, "  dwSize               = %lu", lpl->dwSize);
    fnsLog(nLog, "  vPosition:");
    Log_D3DVector(nLog, &(lpl->vPosition));
    fnsLog(nLog, "  vVelocity:");
    Log_D3DVector(nLog, &(lpl->vVelocity));
    fnsLog(nLog, "  vOrientFront:");
    Log_D3DVector(nLog, &(lpl->vOrientFront));
    fnsLog(nLog, "  vOrientTop:");
    Log_D3DVector(nLog, &(lpl->vOrientTop));

    tstLof(nLog,  "  flDistanceFactor     = %19.9g", lpl->flDistanceFactor);
    tstLof(nLog,  "  flRolloffFactor      = %19.9g", lpl->flRolloffFactor);
    tstLof(nLog,  "  flDopplerFactor      = %19.9g", lpl->flDopplerFactor);
}

void _stdcall Log_DS3DBAllParameters(int nLog, LPCDS3DBUFFER lpb)
{
    if (lpb == NULL)
        return;

    fnsLog(nLog, "  dwSize               = %lu", lpb->dwSize);
    fnsLog(nLog, "  vPosition:");
    Log_D3DVector(nLog, &(lpb->vPosition));
    fnsLog(nLog, "  vVelocity:");
    Log_D3DVector(nLog, &(lpb->vVelocity));
    fnsLog(nLog, "  dwInsideConeAngle    = %lu", lpb->dwInsideConeAngle);
    fnsLog(nLog, "  dwOutsideConeAngle   = %lu", lpb->dwOutsideConeAngle);
    fnsLog(nLog, "  vConeOrientation:");
    Log_D3DVector(nLog, &(lpb->vConeOrientation));
    fnsLog(nLog, "  lConeOutsideVolume   = %ld", lpb->lConeOutsideVolume);

    tstLof(nLog,  "  flMinDistance        = %19.9g", lpb->flMinDistance);
    tstLof(nLog,  "  flMaxDistance        = %19.9g", lpb->flMaxDistance);

    fnsLog(nLog, "  dwMode :");
    Log_DS3DBMode(nLog, lpb->dwMode);
}

void _stdcall Log_DSNPositionNotifies (int nLog, DWORD dwNum, LPCDSBPOSITIONNOTIFY notifies)
{
    ULONG i;

    if (notifies == NULL)
        return;

    fnsLog(nLog, "  %lu notification positions:", dwNum);

    for(i=0;i<(ULONG) dwNum;i++)
    {
        fnsLog(nLog, "  Notification %lu:", i);
        fnsLog(nLog, "      dwOffset      =       0x%08x", notifies[i].dwOffset);
        fnsLog(nLog, "      hEventNotify  =       0x%p", notifies[i].hEventNotify);
    }
}

void tstLof(int nLevel, CHAR * szFormat, double flNumber)
{
    //BUGBUG, assuming the printout never exceeds 255 characters
    CHAR szBuffer[256];
    assert(szFormat);
    _stprintf(szBuffer, szFormat, flNumber);
    fnsLog(nLevel, szBuffer);
}

void _stdcall Log_DS3DAlgorithm (int nLog, LPGUID lpGuid)
{

    if (NULL == lpGuid)
        return;

    if (IsEqualGUID(DS3DALG_DEFAULT, *lpGuid))
        Log (nLog, "guid3DAlgorithm = DS3DALG_DEFAULT");
    else if (IsEqualGUID(DS3DALG_NO_VIRTUALIZATION, *lpGuid))
        Log (nLog, "guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION");
    else if (IsEqualGUID(DS3DALG_HRTF_FULL, *lpGuid))
        Log (nLog, "guid3DAlgorithm = DS3DALG_HRTF_FULL");
    else if (IsEqualGUID(DS3DALG_HRTF_LIGHT, *lpGuid))
        Log (nLog, "guid3DAlgorithm = DS3DALG_HRTF_LIGHT");
    else
        Log (nLog, "guid3DAlgorithm = (Unknown algorithm)");
}

void _stdcall Log_DSErr (CHAR *szPrompt, HRESULT result, int nLog)
{
    CHAR szErrorString[255];

    switch(result)
    {
    case DSERR_ALLOCATED:
        sprintf(szErrorString, "%s returned DSERR_ALLOCATED", szPrompt);
        break;

    case DSERR_CONTROLUNAVAIL:
        sprintf(szErrorString, "%s returned DSERR_CONTROLUNAVAIL", szPrompt);
        break;

    case DSERR_INVALIDPARAM:
        sprintf(szErrorString, "%s returned DSERR_INVALIDPARAM", szPrompt);
        break;

    case DSERR_INVALIDCALL:
        sprintf(szErrorString, "%s returned DSERR_INVALIDCALL", szPrompt);
        break;

    case DSERR_GENERIC:
        sprintf(szErrorString, "%s returned DSERR_GENERIC", szPrompt);
        break;

    case DSERR_PRIOLEVELNEEDED:
        sprintf(szErrorString, "%s returned DSERR_PRIOLEVELNEEDED", szPrompt);
        break;

    case DSERR_OUTOFMEMORY:
        sprintf(szErrorString, "%s returned DSERR_OUTOFMEMORY", szPrompt);
        break;

    case DSERR_BADFORMAT:
        sprintf(szErrorString, "%s returned DSERR_BADFORMAT", szPrompt);
        break;

    case DSERR_UNSUPPORTED:
        sprintf(szErrorString, "%s returned DSERR_UNSUPPORTED", szPrompt);
        break;

    case DSERR_NODRIVER:
        sprintf(szErrorString, "%s returned DSERR_NODRIVER", szPrompt);
        break;

    case DSERR_ALREADYINITIALIZED:
        sprintf(szErrorString, "%s returned DSERR_ALREADYINITIALIZED", szPrompt);
        break;

    case DSERR_NOAGGREGATION:
        sprintf(szErrorString, "%s returned DSERR_NOAGGREGATION", szPrompt);
        break;

    case DSERR_BUFFERLOST:
        sprintf(szErrorString, "%s returned DSERR_BUFFERLOST", szPrompt);
        break;

    case DSERR_OTHERAPPHASPRIO:
        sprintf(szErrorString, "%s returned DSERR_OTHERAPPHASPRIO", szPrompt);
        break;

    case DSERR_UNINITIALIZED:
        sprintf(szErrorString, "%s returned DSERR_UNINITIALIZED", szPrompt);
        break;

    case DSERR_NOINTERFACE:
        sprintf(szErrorString, "%s returned DSERR_NOINTERFACE", szPrompt);
        break;

/*
    case DSERR_HWUNAVAIL:
        sprintf(szErrorString, "%s returned DSERR_HWUNAVAIL", szPrompt);
        break;
*/
    default:
        sprintf(szErrorString, "%s returned unknown error code (0x%08x)", szPrompt, result);
        break;
    }

    Log( nLog, szErrorString );
}

void _stdcall Log_DSCooperativeLevel (int nLog, DWORD dwLevel)
{
    CHAR szTemp[64];

    strcpy(szTemp, "Cooperative Level: ");

    switch (dwLevel) {
    case DSSCL_EXCLUSIVE:
        strcat(szTemp, "DSSCL_EXCLUSIVE ");
        break;

    case DSSCL_NORMAL:
        strcat(szTemp, "DSSCL_NORMAL ");
        break;

    case DSSCL_PRIORITY:
        strcat(szTemp, "DSSCL_PRIORITY  ");
        break;

    case DSSCL_WRITEPRIMARY:
        strcat(szTemp, "DSSCL_WRITEPRIMARY ");
        break;
    }

    Log(nLog, szTemp);
}

void _stdcall Log_GUID (int nLog, LPGUID lpGuid)
{
    OLECHAR     wszGuid[256];

    if (lpGuid == NULL)
    {
        Log(nLog, "  NULL GUID Pointer");
    }
    else
    {
        StringFromGUID2(*lpGuid, wszGuid, 256);
        Log(nLog, "  GUID: %ws", wszGuid);
    }
}

void _stdcall Log_GUID (int nLog, REFGUID Guid)
{
    OLECHAR     wszGuid[256];
    StringFromGUID2(Guid, wszGuid, 256);

    Log(nLog, "  GUID: %ws", wszGuid);
}


void Log_DSCaps (int nLog, LPDSCAPS lpdscaps)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    if (lpdscaps == NULL)
    {
        Log(nLog, "DSCAPS : NULL pointer");
        return;
    }

    Log(nLog, "DSCAPS:");
    Log(nLog,
            "  dwSize                   = %lu", lpdscaps->dwSize);

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (lpdscaps->dwFlags & DSCAPS_CERTIFIED)
    {
        APPEND_FLAG(" DSCAPS_CERTIFIED");
    }
    if (lpdscaps->dwFlags & DSCAPS_CONTINUOUSRATE)
    {
        APPEND_FLAG(" DSCAPS_CONTINUOUSRATE");
    }
    if (lpdscaps->dwFlags & DSCAPS_EMULDRIVER)
    {
        APPEND_FLAG(" DSCAPS_EMULDRIVER");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARY16BIT)
    {
        APPEND_FLAG(" DSCAPS_PRIMARY16BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARY8BIT)
    {
        APPEND_FLAG(" DSCAPS_PRIMARY8BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARYMONO)
    {
        APPEND_FLAG(" DSCAPS_PRIMARYMONO");
    }
    if (lpdscaps->dwFlags & DSCAPS_PRIMARYSTEREO)
    {
        APPEND_FLAG(" DSCAPS_PRIMARYSTEREO");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARY16BIT)
    {
        APPEND_FLAG(" DSCAPS_SECONDARY16BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARY8BIT)
    {
        APPEND_FLAG(" DSCAPS_SECONDARY8BIT");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARYMONO)
    {
        APPEND_FLAG(" DSCAPS_SECONDARYMONO");
    }
    if (lpdscaps->dwFlags & DSCAPS_SECONDARYSTEREO)
    {
        APPEND_FLAG(" DSCAPS_SECONDARYSTEREO");
    }

    Log(nLog, szFlagBuffer);
    Log(nLog, "  dwMinSecondarySampleRate          = %lu",
            lpdscaps->dwMinSecondarySampleRate);
    Log(nLog, "  dwMaxSecondarySampleRate          = %lu",
            lpdscaps->dwMaxSecondarySampleRate);
    Log(nLog, "  dwPrimaryBuffers                  = %lu",
            lpdscaps->dwPrimaryBuffers);
    Log(nLog, "  dwMaxHwMixingAllBuffers           = %lu",
            lpdscaps->dwMaxHwMixingAllBuffers);
    Log(nLog, "  dwMaxHwMixingStaticBuffers        = %lu",
            lpdscaps->dwMaxHwMixingStaticBuffers);
    Log(nLog, "  dwMaxHwMixingStreamingBuffers     = %lu",
            lpdscaps->dwMaxHwMixingStreamingBuffers);
    Log(nLog, "  dwFreeHwMixingAllBuffers          = %lu",
            lpdscaps->dwFreeHwMixingAllBuffers);
    Log(nLog, "  dwFreeHwMixingStaticBuffers       = %lu",
            lpdscaps->dwFreeHwMixingStaticBuffers);
    Log(nLog, "  dwFreeHwMixingStreamingBuffers    = %lu",
            lpdscaps->dwFreeHwMixingStreamingBuffers);
    Log(nLog, "  dwMaxHw3DAllBuffers               = %lu",
            lpdscaps->dwMaxHw3DAllBuffers);
    Log(nLog, "  dwMaxHw3DStaticBuffers            = %lu",
            lpdscaps->dwMaxHw3DStaticBuffers);
    Log(nLog, "  dwMaxHw3DStreamingBuffers         = %lu",
            lpdscaps->dwMaxHw3DStreamingBuffers);
    Log(nLog, "  dwTotalHwMemBytes                 = %lu",
            lpdscaps->dwTotalHwMemBytes);
    Log(nLog, "  dwFreeHwMemBytes                  = %lu",
            lpdscaps->dwFreeHwMemBytes);
    Log(nLog, "  dwMaxContigFreeHwMemBytes         = %lu",
            lpdscaps->dwMaxContigFreeHwMemBytes);
    Log(nLog, "  dwUnlockTransferRateHwBuffers     = %lu",
            lpdscaps->dwUnlockTransferRateHwBuffers);
    Log(nLog, "  dwPlayCpuOverheadSwBuffers        = %lu",
            lpdscaps->dwPlayCpuOverheadSwBuffers);
    Log(nLog, "  dwReserved1                       = 0x%08x",
            lpdscaps->dwReserved1);
    Log(nLog, "  dwReserved2                       = 0x%08x",
            lpdscaps->dwReserved2);
}

void _stdcall Log_DSBCapsFlags(int nLog, DWORD dwFlags)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags               = ");
    if (dwFlags & DSBCAPS_CTRL3D)
    {
        APPEND_FLAG (" DSBCAPS_CTRL3D");
    }
    if (dwFlags & DSBCAPS_CTRLFREQUENCY)
    {
        APPEND_FLAG (" DSBCAPS_CTRLFREQUENCY");
    }
    if (dwFlags & DSBCAPS_CTRLPAN)
    {
        APPEND_FLAG (" DSBCAPS_CTRLPAN");
    }
    if (dwFlags & DSBCAPS_CTRLVOLUME)
    {
        APPEND_FLAG (" DSBCAPS_CTRLVOLUME");
    }
    if (dwFlags & DSBCAPS_GETCURRENTPOSITION2)
    {
        APPEND_FLAG (" DSBCAPS_GETCURRENTPOSITION2");
    }
    if (dwFlags & DSBCAPS_GLOBALFOCUS)
    {
        APPEND_FLAG (" DSBCAPS_GLOBALFOCUS");
    }
    if (dwFlags & DSBCAPS_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBCAPS_LOCHARDWARE");
    }
    if (dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE)
    {
        APPEND_FLAG (" DSBCAPS_MUTE3DATMAXDISTANCE");
    }
    if (dwFlags & DSBCAPS_PRIMARYBUFFER)
    {
        APPEND_FLAG (" DSBCAPS_PRIMARYBUFFER");
    }
    if (dwFlags & DSBCAPS_STATIC)
    {
        APPEND_FLAG (" DSBCAPS_STATIC");
    }
    if (dwFlags & DSBCAPS_STICKYFOCUS)
    {
        APPEND_FLAG (" DSBCAPS_STIKYFOCUS");
    }

    if (dwFlags & DSBCAPS_LOCDEFER)
    {
        APPEND_FLAG (" DSBCAPS_LOCDEFER");
    }

    Log(nLog, szFlagBuffer);
}

void _stdcall Log_DSBCaps (int nLog, LPDSBCAPS lpdsbcaps)
{
    if (lpdsbcaps == NULL)
    {
        Log(nLog, "DSBCAPS : NULL pointer");
        return;
    }

    Log(nLog, "DSBCAPS :");
    Log(nLog,
            "  dwSize                            = %lu", lpdsbcaps->dwSize);
    Log_DSBCapsFlags(nLog, lpdsbcaps->dwFlags);
    Log(nLog, "  dwBufferBytes           = %lu", lpdsbcaps->dwBufferBytes);
    Log(nLog, "  dwUnlockTransferRate    = %lu", lpdsbcaps->dwUnlockTransferRate);
    Log(nLog, "  dwPlayCpuOverhead       = %lu", lpdsbcaps->dwPlayCpuOverhead);
}

void _stdcall Log_DSCCaps (int nLog, LPDSCCAPS lpdsccaps)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    if (lpdsccaps == NULL)
    {
        Log(nLog, "DSCCAPS : NULL pointer");
        return;
    }

    Log(nLog, "DSCCAPS :");
    Log(nLog,
        "  dwSize                            = %lu", lpdsccaps->dwSize);

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (lpdsccaps->dwFlags & DSCCAPS_EMULDRIVER)
    {
        APPEND_FLAG(" DSCCAPS_EMULDRIVER");
    }

    Log(nLog, szFlagBuffer);
    Log(nLog, "  dwFormats    = 0x%08x", lpdsccaps->dwFormats);
    Log(nLog, "  dwChannels   = 0x%08x", lpdsccaps->dwChannels);
}

void _stdcall Log_DSCBCapsFlags(int nLog, DWORD dwFlags)
{
    // BUGBUG assuming the flag string will never exceed FLAG_BUFFER_LENGTH
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags                           = ");
    if (dwFlags & DSCBCAPS_WAVEMAPPED)
    {
        APPEND_FLAG (" DSCBCAPS_WAVEMAPPED");
    }

    Log(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBCaps (int nLog, LPDSCBCAPS lpdscbcaps)
{
    if (lpdscbcaps == NULL)
    {
        Log(nLog, "DSCBCAPS : NULL pointer");
        return;
    }

    Log(nLog, "DSCBCAPS :");
    Log(nLog,
            "  dwSize                            = %lu", lpdscbcaps->dwSize);
    Log_DSCBCapsFlags(nLog, lpdscbcaps->dwFlags);
    Log(nLog, "  dwBufferBytes    = %lu", lpdscbcaps->dwBufferBytes);
    Log(nLog, "  dwReserved       = 0x%08x", lpdscbcaps->dwReserved);
}

void _stdcall Log_SpeakerConfig (int nLog, DWORD dwSpkrCfg)
{
    CHAR szConfiguration[255];
    ZeroMemory (szConfiguration, sizeof(szConfiguration));

    Log(nLog, "Speaker configuration:");

    if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_HEADPHONE)
    {
        sprintf(szConfiguration, "  DSSPEAKER_HEADPHONE");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_MONO)
    {
        sprintf(szConfiguration, "  DSSPEAKER_MONO");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_QUAD)
    {
        sprintf(szConfiguration, "  DSSPEAKER_QUAD");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_SURROUND)
    {
        sprintf(szConfiguration, "  DSSPEAKER_SURROUND");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_STEREO)
    {
        if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_WIDE)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_WIDE");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_NARROW)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_NARROW");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_MIN)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_MIN");
        else if (DSSPEAKER_GEOMETRY(dwSpkrCfg) == DSSPEAKER_GEOMETRY_MAX)
            sprintf(szConfiguration, "  DSSPEAKER_STEREO | DSSPEAKER_GEOMETRY_MAX");
        else
            sprintf(szConfiguration, "  DSSPEAKER_STEREO");
    }
    else if (DSSPEAKER_CONFIG(dwSpkrCfg) == DSSPEAKER_5POINT1)
    {
        sprintf(szConfiguration, "  DSSPEAKER_5POINT1");
    }
    else
    {
        sprintf(szConfiguration, "  Unknown configuration");
    }

    Log(nLog, szConfiguration);
}

void _stdcall Log_WaveFormatEx(int nLevel, LPCWAVEFORMATEX lpwfx)
{
    if(!lpwfx)
    {
        Log(nLevel, "LPWAVEFORMATEX:  0x%p", lpwfx);
    }
    else
    {
        Log_wFormatTag(nLevel, lpwfx->wFormatTag);
        Log(nLevel, "  nChannels:        %d", lpwfx->nChannels);
        Log(nLevel, "  nSamplesPerSec:   %d", lpwfx->nSamplesPerSec);
        Log(nLevel, "  nAvgBytesPerSec:  %d", lpwfx->nAvgBytesPerSec);
        Log(nLevel, "  nBlockAlign:      %d", lpwfx->nBlockAlign);
        Log(nLevel, "  wBitsPerSample:   %d", lpwfx->wBitsPerSample);
    }
}

void Log_wFormatTag (int nLevel, WORD wFmt)
{
    CHAR    szFormat[FLAG_BUFFER_LENGTH] = " ";

    Log(nLevel, "wFormatTag:       0x%04x", wFmt);

    switch(wFmt)
    {
        case WAVE_FORMAT_PCM:
            sprintf(szFormat, "WAVE_FORMAT_PCM");
            break;

        case WAVE_FORMAT_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_ADPCM");
            break;

        case WAVE_FORMAT_IBM_CVSD   :
            sprintf (szFormat, "WAVE_FORMAT_IBM_CVSD   ");
            break;

        case WAVE_FORMAT_ALAW       :
            sprintf (szFormat, "WAVE_FORMAT_ALAW       ");
            break;

        case WAVE_FORMAT_MULAW      :
            sprintf (szFormat, "WAVE_FORMAT_MULAW      ");
            break;

        case WAVE_FORMAT_OKI_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_OKI_ADPCM  ");
            break;

        case WAVE_FORMAT_IMA_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_IMA_ADPCM  ");
            break;

        case WAVE_FORMAT_MEDIASPACE_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_MEDIASPACE_ADPCM");
            break;

        case WAVE_FORMAT_SIERRA_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_SIERRA_ADPCM");
            break;

        case WAVE_FORMAT_G723_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G723_ADPCM ");
            break;

        case WAVE_FORMAT_DIGISTD    :
            sprintf (szFormat, "WAVE_FORMAT_DIGISTD    ");
            break;

        case WAVE_FORMAT_DIGIFIX    :
            sprintf (szFormat, "WAVE_FORMAT_DIGIFIX    ");
            break;

        case WAVE_FORMAT_DIALOGIC_OKI_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM ");
            break;

        case WAVE_FORMAT_YAMAHA_ADPCM       :
            sprintf (szFormat, "WAVE_FORMAT_YAMAHA_ADPCM       ");
            break;

        case WAVE_FORMAT_SONARC :
            sprintf (szFormat, "WAVE_FORMAT_SONARC ");
            break;

        case WAVE_FORMAT_DSPGROUP_TRUESPEECH  :
            sprintf (szFormat, "WAVE_FORMAT_DSPGROUP_TRUESPEECH  ");
            break;

        case WAVE_FORMAT_ECHOSC1 :
            sprintf (szFormat, "WAVE_FORMAT_ECHOSC1 ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF36:
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF36");
            break;

        case WAVE_FORMAT_APTX :
            sprintf (szFormat, "WAVE_FORMAT_APTX ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF10    :
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF10    ");
            break;

        case WAVE_FORMAT_DOLBY_AC2 :
            sprintf (szFormat, "WAVE_FORMAT_DOLBY_AC2 ");
            break;

        case WAVE_FORMAT_GSM610    :
            sprintf (szFormat, "WAVE_FORMAT_GSM610    ");
            break;

        case WAVE_FORMAT_ANTEX_ADPCME      :
            sprintf (szFormat, "WAVE_FORMAT_ANTEX_ADPCME      ");
            break;

        case WAVE_FORMAT_CONTROL_RES_VQLPC :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_VQLPC ");
            break;

        case WAVE_FORMAT_DIGIREAL   :
            sprintf (szFormat, "WAVE_FORMAT_DIGIREAL   ");
            break;

        case WAVE_FORMAT_DIGIADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_DIGIADPCM  ");
            break;

        case WAVE_FORMAT_CONTROL_RES_CR10  :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_CR10  ");
            break;

        case WAVE_FORMAT_NMS_VBXADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_NMS_VBXADPCM  ");
            break;

        case WAVE_FORMAT_CS_IMAADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CS_IMAADPCM ");
            break;

        case WAVE_FORMAT_G721_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G721_ADPCM ");
            break;

        case WAVE_FORMAT_MPEG       :
            sprintf (szFormat, "WAVE_FORMAT_MPEG       ");
            break;

        case WAVE_FORMAT_CREATIVE_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_ADPCM ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH8 :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH8 ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH10:
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH10");
            break;

        case WAVE_FORMAT_FM_TOWNS_SND :
            sprintf (szFormat, "WAVE_FORMAT_FM_TOWNS_SND ");
            break;

        case WAVE_FORMAT_OLIGSM   :
            sprintf (szFormat, "WAVE_FORMAT_OLIGSM   ");
            break;

        case WAVE_FORMAT_OLIADPCM :
            sprintf (szFormat, "WAVE_FORMAT_OLIADPCM ");
            break;

        case WAVE_FORMAT_OLICELP  :
            sprintf (szFormat, "WAVE_FORMAT_OLICELP");
            break;

        case WAVE_FORMAT_OLISBC   :
            sprintf (szFormat, "WAVE_FORMAT_OLISBC");
            break;

        case WAVE_FORMAT_OLIOPR   :
            sprintf (szFormat, "WAVE_FORMAT_OLIOPR");
            break;

        case WAVE_FORMAT_DEVELOPMENT:
            sprintf (szFormat, "WAVE_FORMAT_DEVELOPMENT");
            break;

        default :
            sprintf (szFormat, "Unknown Wave Format");
     }

     Log(nLevel, "  wFormatTag:       %s", szFormat);
}

void _stdcall Log_DSBufferDesc(int nLevel, LPCDSBUFFERDESC lpdsbd)
{
    if (NULL == lpdsbd)
        return;

//    if (!IsBadReadPtr(lpdsbd, sizeof(DSBUFFERDESC)))
    if (!IsBadReadPtr(lpdsbd, lpdsbd->dwSize))
    {
        Log(nLevel, "  dwSize: %lu", lpdsbd->dwSize);
        Log_DSBCapsFlags(nLevel, lpdsbd->dwFlags);
        Log(nLevel, "  dwBufferBytes:  %lu", lpdsbd->dwBufferBytes);
        Log(nLevel, "  dwReserved:  %lu", lpdsbd->dwReserved);
        Log_WaveFormatEx(nLevel, lpdsbd->lpwfxFormat);
        if (sizeof(DSBUFFERDESC) <= lpdsbd->dwSize)
        {
            Log_DS3DAlgorithm(nLevel, (LPGUID) &(lpdsbd->guid3DAlgorithm));
        }
    }
}

void _stdcall Log_DSCBufferDesc (int nLevel, LPCDSCBUFFERDESC lpdscbd)
{
    if (!IsBadReadPtr(lpdscbd, sizeof(DSCBUFFERDESC)))
    {
        Log(nLevel, "  dwSize:           %lu", lpdscbd->dwSize);
        Log_DSCBCapsFlags(nLevel, lpdscbd->dwFlags);
        Log(nLevel, "  dwBufferBytes:    %lu", lpdscbd->dwBufferBytes);
        Log(nLevel, "  dwReserved:       %lu", lpdscbd->dwReserved);
        Log(nLevel, "  LPWAVEFORMATEX: 0x%p", lpdscbd->lpwfxFormat);
        Log_WaveFormatEx(nLevel, lpdscbd->lpwfxFormat);
    }
}

void _stdcall Log_DSBLockFlags(int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];

    ZeroMemory (szFlags, sizeof(szFlags));

    Log(nLog, "Lock flags:");

    if (dwFlags & DSBLOCK_FROMWRITECURSOR)
        sprintf(szFlags, "  DSBLOCK_FROMWRITECURSOR");
    else if (dwFlags & DSBLOCK_ENTIREBUFFER)
        sprintf(szFlags, "  DSBLOCK_ENTIREBUFFER");

    Log(nLog, szFlags);
}

void _stdcall Log_DSCBLockFlags(int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];

    Log(nLog, "Lock flags:");
    ZeroMemory (szFlags, sizeof(szFlags));

    if (dwFlags & DSCBLOCK_ENTIREBUFFER)
        sprintf(szFlags, "  DSCBLOCK_ENTIREBUFFER");

    Log(nLog, szFlags);
}

void _stdcall Log_DSBPlayFlags(int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    ZeroMemory (szFlagBuffer, sizeof (szFlagBuffer));

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwFlags  = ");
    if (dwFlags & DSBPLAY_LOOPING)
    {
        APPEND_FLAG (" DSBPLAY_LOOPING");
    }

    if (dwFlags & DSBPLAY_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBPLAY_LOCHARDWARE");
    }

    if (dwFlags & DSBPLAY_LOCSOFTWARE)
    {
        APPEND_FLAG (" DSBPLAY_LOCSOFTWARE");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_TIME)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_TIME");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_DISTANCE");
    }

    if (dwFlags & DSBPLAY_TERMINATEBY_PRIORITY)
    {
        APPEND_FLAG (" DSBPLAY_TERMINATEBY_PRIORITY");
    }

    Log(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBStartFlags (int nLog, DWORD dwFlags)
{
    CHAR szFlags[255];
    ZeroMemory (szFlags, sizeof(szFlags));

    Log(nLog, "Start flags:");

    if (dwFlags & DSCBSTART_LOOPING)
        sprintf(szFlags, "  DSCBSTART_LOOPING");

    Log(nLog, szFlags);
}

void _stdcall Log_DSBStatus (int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwStatus  = ");
    if (dwFlags & DSBSTATUS_PLAYING)
    {
        APPEND_FLAG (" DSBSTATUS_PLAYING");
    }

    if (dwFlags & DSBSTATUS_LOOPING)
    {
        APPEND_FLAG (" DSBSTATUS_LOOPING");
    }

    if (dwFlags & DSBSTATUS_BUFFERLOST)
    {
        APPEND_FLAG (" DSBSTATUS_BUFFERLOST");
    }

    if (dwFlags & DSBSTATUS_LOCSOFTWARE)
    {
        APPEND_FLAG (" DSBSTATUS_LOCSOFTWARE");
    }

    if (dwFlags & DSBSTATUS_LOCHARDWARE)
    {
        APPEND_FLAG (" DSBSTATUS_LOCHARDWARE");
    }
/*
    if (dwFlags & DSBSTATUS_LOCDEFERED)
    {
        APPEND_FLAG (" DSBSTATUS_LOCDEFERED");
    }
*/
    if (dwFlags & DSBSTATUS_TERMINATED)
    {
        APPEND_FLAG (" DSBSTATUS_TERMINATED");
    }



    Log(nLog, szFlagBuffer);
}

void _stdcall Log_DSCBStatus (int nLog, DWORD dwFlags)
{
    CHAR   szFlagBuffer[FLAG_BUFFER_LENGTH];
    int     nPos    = 0;
    BOOL    bFirst  = TRUE;

    nPos += sprintf(szFlagBuffer + nPos,
                    "  dwStatus  = ");
    if (dwFlags & DSCBSTATUS_CAPTURING)
    {
        APPEND_FLAG (" DSCBSTATUS_CAPTURING");
    }
    if (dwFlags & DSCBSTATUS_LOOPING)
    {
        APPEND_FLAG (" DSCBSTATUS_LOOPING");
    }

    Log(nLog, szFlagBuffer);
}

void _stdcall Log_DS3DApplyMode (int nLog, DWORD dwMode)
{
    CHAR szMode[255];
    ZeroMemory (szMode, sizeof(szMode));

    if (dwMode == DS3D_DEFERRED)
        sprintf(szMode, "  DS3D_DEFERRED");
    else if (dwMode == DS3D_IMMEDIATE)
        sprintf(szMode, "  DS3D_IMMEDIATE");

    Log(nLog, szMode);
}

void _stdcall Log_DS3DBMode (int nLog, DWORD dwMode)
{
    CHAR szMode[255];
    ZeroMemory (szMode, sizeof(szMode));

    switch (dwMode)
    {
    case DS3DMODE_DISABLE:
        sprintf(szMode, "  DS3DMODE_DISABLE");
        break;

    case DS3DMODE_HEADRELATIVE:
        sprintf(szMode, "  DS3DMODE_HEADRELATIVE");
        break;

    case DS3DMODE_NORMAL:
        sprintf(szMode, "  DS3DMODE_NORMAL");
        break;

    default:
        sprintf(szMode, "  Unknown mode");
        break;
    }

    Log(nLog, szMode);
}

void Log_D3DVector(int nLog, const struct _D3DVECTOR * lpv)
{
    if (lpv == NULL)
        return;

    Log_tstLof(nLog, "    %19.9g", lpv->x);
    Log_tstLof(nLog, "    %19.9g", lpv->y);
    Log_tstLof(nLog, "    %19.9g", lpv->z);
}

void Log_DS3DLAllParameters(int nLog, LPCDS3DLISTENER lpl)
{
    if (lpl == NULL)
        return;

    Log(nLog, "  dwSize               = %lu", lpl->dwSize);
    Log(nLog, "  vPosition:");
    Log_D3DVector(nLog, &(lpl->vPosition));
    Log(nLog, "  vVelocity:");
    Log_D3DVector(nLog, &(lpl->vVelocity));
    Log(nLog, "  vOrientFront:");
    Log_D3DVector(nLog, &(lpl->vOrientFront));
    Log(nLog, "  vOrientTop:");
    Log_D3DVector(nLog, &(lpl->vOrientTop));

    Log_tstLof(nLog,  "  flDistanceFactor     = %19.9g", lpl->flDistanceFactor);
    Log_tstLof(nLog,  "  flRolloffFactor      = %19.9g", lpl->flRolloffFactor);
    Log_tstLof(nLog,  "  flDopplerFactor      = %19.9g", lpl->flDopplerFactor);
}

void Log_DS3DBAllParameters(int nLog, LPCDS3DBUFFER lpb)
{
    if (lpb == NULL)
        return;

    Log(nLog, "  dwSize               = %lu", lpb->dwSize);
    Log(nLog, "  vPosition:");
    Log_D3DVector(nLog, &(lpb->vPosition));
    Log(nLog, "  vVelocity:");
    Log_D3DVector(nLog, &(lpb->vVelocity));
    Log(nLog, "  dwInsideConeAngle    = %lu", lpb->dwInsideConeAngle);
    Log(nLog, "  dwOutsideConeAngle   = %lu", lpb->dwOutsideConeAngle);
    Log(nLog, "  vConeOrientation:");
    Log_D3DVector(nLog, &(lpb->vConeOrientation));
    Log(nLog, "  lConeOutsideVolume   = %ld", lpb->lConeOutsideVolume);

    Log_tstLof(nLog,  "  flMinDistance        = %19.9g", lpb->flMinDistance);
    Log_tstLof(nLog,  "  flMaxDistance        = %19.9g", lpb->flMaxDistance);

    Log(nLog, "  dwMode :");
    Log_DS3DBMode(nLog, lpb->dwMode);
}

void Log_DSNPositionNotifies (int nLog, DWORD dwNum, LPCDSBPOSITIONNOTIFY notifies)
{
    ULONG i;
    if (notifies == NULL)
        return;

    Log(nLog, "  %lu notification positions:", dwNum);

    for(i=0;i<(ULONG) dwNum;i++)
    {
        Log(nLog, "  Notification %lu:", i);
        Log(nLog, "      dwOffset      =       0x%08x", notifies[i].dwOffset);
        Log(nLog, "      hEventNotify  =       0x%p", notifies[i].hEventNotify);
    }
}

void Log_tstLof(int nLevel, CHAR * szFormat, double flNumber)
{
    //BUGBUG, assuming the printout never exceeds 255 characters
    CHAR szBuffer[256];
    assert(szFormat);
    _stprintf(szBuffer, szFormat, flNumber);

    Log(nLevel, szBuffer);
}


//===========================================================================
// dmthLogWAVEFORMATEX
//
// Logs the contents of WAVEFORMATEX structure
//
// Parameters:
//  UINT                    uLogLevel   - fnshell logging level
//  WAVEFORMATEX *          lpwfx - pointer to DMUS_SCRIPT_ERRORINFO
//
// Returns: nothing
//
// History:
//  02/23/2000 - danhaff - created
//===========================================================================
void _stdcall dmthLogWAVEFORMATEX(UINT uLogLevel, LPWAVEFORMATEX lpwfx)
{
    //////////////////////////////////////////////////////////////////
    // validate lpwfx
    //////////////////////////////////////////////////////////////////
    if(!helpIsValidPtr((void*)lpwfx, sizeof(WAVEFORMATEX), FALSE))
    {
        fnsLog(uLogLevel, "Invalid LPWAVEFORMATEX pointer (%08Xh)..."
                "Unable to log structure contents", lpwfx);
        return;
    }

    if(!lpwfx)
    {
        fnsLog(uLogLevel, "LPWAVEFORMATEX:  0x%p", lpwfx);
    }
    else
    {
        dmthLogFormatTag(uLogLevel, lpwfx->wFormatTag);

        //Should we log the original WFX in this case?  I am not, for now.
        if (WAVE_FORMAT_DRM == lpwfx->wFormatTag)
        {
            DRMWAVEFORMAT * p = (DRMWAVEFORMAT *)lpwfx;
            fnsLog(uLogLevel, "WFX                           ");
            fnsLog(uLogLevel, "  nChannels:                  %d", p->wfx.nChannels);
            fnsLog(uLogLevel, "  nSamplesPerSec:             %d", p->wfx.nSamplesPerSec);
            fnsLog(uLogLevel, "  nAvgBytesPerSec:            %d", p->wfx.nAvgBytesPerSec);
            fnsLog(uLogLevel, "  nBlockAlign:                %d", p->wfx.nBlockAlign);
            fnsLog(uLogLevel, "  wBitsPerSample:             %d", p->wfx.wBitsPerSample);
            fnsLog(uLogLevel, "  cbSize:                     %d", p->wfx.cbSize);
            fnsLog(uLogLevel, "");
            fnsLog(uLogLevel, "  wReserved:                  %d", p->wReserved);
            fnsLog(uLogLevel, "  ulContentId:                %d", p->ulContentId);
            fnsLog(uLogLevel, "WFXSECURE                     ");
            dmthLogWAVEFORMATEX(uLogLevel, &p->wfxSecure);
        }
        else if (WAVE_FORMAT_EXTENSIBLE == lpwfx->wFormatTag)
        {
            WAVEFORMATEXTENSIBLE *  p = (WAVEFORMATEXTENSIBLE *)lpwfx;
            fnsLog(uLogLevel, "  nChannels:                  %d", p->Format.nChannels);
            fnsLog(uLogLevel, "  nSamplesPerSec:             %d", p->Format.nSamplesPerSec);
            fnsLog(uLogLevel, "  nAvgBytesPerSec:            %d", p->Format.nAvgBytesPerSec);
            fnsLog(uLogLevel, "  nBlockAlign:                %d", p->Format.nBlockAlign);
            fnsLog(uLogLevel, "  wBitsPerSample:             %d", p->Format.wBitsPerSample);
            fnsLog(uLogLevel, "  cbSize:                     %d", p->Format.cbSize);

            fnsLog(uLogLevel, "  wValidBitsPerSample:        %d", p->Samples.wValidBitsPerSample);
            fnsLog(uLogLevel, "  dwChannelMask:              0x%08x", p->dwChannelMask);
            if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_PCM))
            {
                fnsLog(uLogLevel, "  SubFormat: KSDATAFORMAT_SUBTYPE_PCM");
            }
            else if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_ADPCM))
            {
                fnsLog(uLogLevel, "  SubFormat:                  KSDATAFORMAT_SUBTYPE_ADPCM");
            }
            else if (IsEqualGUID(p->SubFormat, KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
            {
                fnsLog(uLogLevel, "  SubFormat:                  KSDATAFORMAT_SUBTYPE_IEEE_FLOAT");
            }
            else
            {
                fnsLog(uLogLevel, "  SubFormat:                  UNKNOWN");
                dmthLogRawGUID(uLogLevel, p->SubFormat);
            }
        }
        else //go with default PCM-style data.
        {
            fnsLog(uLogLevel, "  nChannels:        %d", lpwfx->nChannels);
            fnsLog(uLogLevel, "  nSamplesPerSec:   %d", lpwfx->nSamplesPerSec);
            fnsLog(uLogLevel, "  nAvgBytesPerSec:  %d", lpwfx->nAvgBytesPerSec);
            fnsLog(uLogLevel, "  nBlockAlign:      %d", lpwfx->nBlockAlign);
            fnsLog(uLogLevel, "  wBitsPerSample:   %d", lpwfx->wBitsPerSample);

            //If we're WAVE_FORMAT_PCM, then we don't touch cbSize.
            if (WAVE_FORMAT_PCM != lpwfx->wFormatTag)
                fnsLog(uLogLevel, "  cbSize        :   %d", lpwfx->cbSize);
        }

    }
}


//===========================================================================
// dmthLogWAVEFORMATEX
//
// Logs a format tag structure
//
// Parameters:
//  UINT                    uLogLevel   - fnshell logging level
//  WORD                    wFmt        - type of waveformat.
//
// Returns: nothing
//
// History:
//  02/23/2000 - danhaff - created
//===========================================================================
void _stdcall dmthLogFormatTag(UINT uLogLevel, WORD wFmt)
{
    CHAR    szFormat[512] = " ";

    ZeroMemory (szFormat, sizeof(szFormat));
    fnsLog(uLogLevel, "wFormatTag:       0x%04x", wFmt);
    switch(wFmt)
    {
        case WAVE_FORMAT_DRM:
            sprintf(szFormat, "WAVE_FORMAT_DRM");
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            sprintf(szFormat, "WAVE_FORMAT_EXTENSIBLE");
            break;

        case WAVE_FORMAT_PCM:
            sprintf(szFormat, "WAVE_FORMAT_PCM");
            break;

        case WAVE_FORMAT_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_ADPCM");
            break;

        case WAVE_FORMAT_IBM_CVSD   :
            sprintf (szFormat, "WAVE_FORMAT_IBM_CVSD   ");
            break;

        case WAVE_FORMAT_ALAW       :
            sprintf (szFormat, "WAVE_FORMAT_ALAW       ");
            break;

        case WAVE_FORMAT_MULAW      :
            sprintf (szFormat, "WAVE_FORMAT_MULAW      ");
            break;

        case WAVE_FORMAT_OKI_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_OKI_ADPCM  ");
            break;

        case WAVE_FORMAT_IMA_ADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_IMA_ADPCM  ");
            break;

        case WAVE_FORMAT_MEDIASPACE_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_MEDIASPACE_ADPCM");
            break;

        case WAVE_FORMAT_SIERRA_ADPCM:
            sprintf (szFormat, "WAVE_FORMAT_SIERRA_ADPCM");
            break;

        case WAVE_FORMAT_G723_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G723_ADPCM ");
            break;

        case WAVE_FORMAT_DIGISTD    :
            sprintf (szFormat, "WAVE_FORMAT_DIGISTD    ");
            break;

        case WAVE_FORMAT_DIGIFIX    :
            sprintf (szFormat, "WAVE_FORMAT_DIGIFIX    ");
            break;

        case WAVE_FORMAT_DIALOGIC_OKI_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_DIALOGIC_OKI_ADPCM ");
            break;

        case WAVE_FORMAT_YAMAHA_ADPCM       :
            sprintf (szFormat, "WAVE_FORMAT_YAMAHA_ADPCM       ");
            break;

        case WAVE_FORMAT_SONARC :
            sprintf (szFormat, "WAVE_FORMAT_SONARC ");
            break;

        case WAVE_FORMAT_DSPGROUP_TRUESPEECH  :
            sprintf (szFormat, "WAVE_FORMAT_DSPGROUP_TRUESPEECH  ");
            break;

        case WAVE_FORMAT_ECHOSC1 :
            sprintf (szFormat, "WAVE_FORMAT_ECHOSC1 ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF36:
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF36");
            break;

        case WAVE_FORMAT_APTX :
            sprintf (szFormat, "WAVE_FORMAT_APTX ");
            break;

        case WAVE_FORMAT_AUDIOFILE_AF10    :
            sprintf (szFormat, "WAVE_FORMAT_AUDIOFILE_AF10    ");
            break;

        case WAVE_FORMAT_DOLBY_AC2 :
            sprintf (szFormat, "WAVE_FORMAT_DOLBY_AC2 ");
            break;

        case WAVE_FORMAT_GSM610    :
            sprintf (szFormat, "WAVE_FORMAT_GSM610    ");
            break;

        case WAVE_FORMAT_ANTEX_ADPCME      :
            sprintf (szFormat, "WAVE_FORMAT_ANTEX_ADPCME      ");
            break;

        case WAVE_FORMAT_CONTROL_RES_VQLPC :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_VQLPC ");
            break;

        case WAVE_FORMAT_DIGIREAL   :
            sprintf (szFormat, "WAVE_FORMAT_DIGIREAL   ");
            break;

        case WAVE_FORMAT_DIGIADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_DIGIADPCM  ");
            break;

        case WAVE_FORMAT_CONTROL_RES_CR10  :
            sprintf (szFormat, "WAVE_FORMAT_CONTROL_RES_CR10  ");
            break;

        case WAVE_FORMAT_NMS_VBXADPCM  :
            sprintf (szFormat, "WAVE_FORMAT_NMS_VBXADPCM  ");
            break;

        case WAVE_FORMAT_CS_IMAADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CS_IMAADPCM ");
            break;

        case WAVE_FORMAT_G721_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_G721_ADPCM ");
            break;

        case WAVE_FORMAT_MPEG       :
            sprintf (szFormat, "WAVE_FORMAT_MPEG       ");
            break;

        case WAVE_FORMAT_CREATIVE_ADPCM :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_ADPCM ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH8 :
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH8 ");
            break;

        case WAVE_FORMAT_CREATIVE_FASTSPEECH10:
            sprintf (szFormat, "WAVE_FORMAT_CREATIVE_FASTSPEECH10");
            break;

        case WAVE_FORMAT_FM_TOWNS_SND :
            sprintf (szFormat, "WAVE_FORMAT_FM_TOWNS_SND ");
            break;

        case WAVE_FORMAT_OLIGSM   :
            sprintf (szFormat, "WAVE_FORMAT_OLIGSM   ");
            break;

        case WAVE_FORMAT_OLIADPCM :
            sprintf (szFormat, "WAVE_FORMAT_OLIADPCM ");
            break;

        case WAVE_FORMAT_OLICELP  :
            sprintf (szFormat, "WAVE_FORMAT_OLICELP");
            break;

        case WAVE_FORMAT_OLISBC   :
            sprintf (szFormat, "WAVE_FORMAT_OLISBC");
            break;

        case WAVE_FORMAT_OLIOPR   :
            sprintf (szFormat, "WAVE_FORMAT_OLIOPR");
            break;

        case WAVE_FORMAT_DEVELOPMENT:
            sprintf (szFormat, "WAVE_FORMAT_DEVELOPMENT");
            break;

        default :
            sprintf (szFormat, "Unknown Wave Format");
     }

     fnsLog(uLogLevel, "  wFormatTag:       %s", szFormat);
}




LRESULT _cdecl DummyLog (DWORD, LPSTR, ...)
{
    return 0;
}


/**********************************************************************
**********************************************************************/
DWORD _stdcall GetRandomDWORD(DWORD dwModulus)
{
LARGE_INTEGER lint;
BOOL bRet;

    //We should never run this on an OS without QPC available.
    bRet = QueryPerformanceCounter(&lint);
    ASSERT(bRet);


    srand(lint.u.LowPart);
    if (dwModulus)
        return rand() % dwModulus;

    //If our modulus is zero, it's probably because someone got an array of size zero and they're
    //  attempting to pick a random element in it.
    else
    {
        ASSERT(FALSE);
        return 0;
    }


}



/**********************************************************************
**********************************************************************/
D3DVALUE _stdcall GetRandomD3DVALUE
(
 D3DVALUE    flLower,
 D3DVALUE    flUpper,
 D3DVALUE    flResolution
)
{
    DWORD    dwTemp;
    DWORD    dwModulus;

    dwModulus = (DWORD)((flUpper-flLower) / flResolution);
    if (dwModulus == 0)
        dwModulus = 0xffffffff;
    dwTemp = GetRandomDWORD(dwModulus);

    return D3DVAL(dwTemp)*flResolution + flLower;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\Factory.cpp ===
// Factory.cpp: implementation of the CFactory class.
//
//////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4786)

#include "Factory.h"
#include <map>
#include <algorithm>
#include <objbase.h>
#include "guiddef.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


static HRESULT Register (GUID clsid, CFactory::createFn Create);    // Register a CLSID with the factory
static HRESULT Unregister(GUID clsid);                              // Remove this CLSID from the factory

// Typedefs for convience
typedef std::map <GUID, CFactory::createFn> factoryMap;
typedef factoryMap::iterator                itterator;
typedef factoryMap::const_iterator          const_itterator;

static factoryMap* pList;

// Some overloads to allow us to use the std::map features
static bool operator < (GUID const& lhs, GUID const& rhs)
{
    return (memcmp (&lhs, &rhs, sizeof (lhs)) < 0 ? true : false);
}

static bool operator == (factoryMap::value_type const& lhs, GUID const& rhs)
{
    return (memcmp (&lhs.first, &rhs, sizeof (lhs.first)) == 0 ? true : false);
}

HRESULT CFactory::Create(GUID clsid, GUID iid, void** ppv)
{
    // Make sure the map isn't empty and the pointer is valid
    if (!pList || !ppv)
    {
        return (E_INVALIDARG);
    }

    // Search the map 
    itterator itt = pList->find (clsid);
    if (itt == pList->end ())
    {
        return (E_INVALIDARG);
    }

    // Create the object using its registered creation function
    IUnknown* pIUnk = NULL;
    createFn Create = (*itt).second;

    HRESULT hr = Create (&pIUnk);
    if (FAILED (hr))
    {
        return (hr);
    }

    // Ask for the required interface
    hr = pIUnk->QueryInterface (iid, ppv);
    
    if (FAILED (hr))
    {
        *ppv = NULL;
    }

    // Release once to set the refcount back to 1
    pIUnk->Release ();

    return (hr);

}

CFactory::CRegister::CRegister (GUID clsid, createFn Create) : m_clsid (clsid)
{
    HRESULT hr = Register (clsid, Create);
}

CFactory::CRegister::~CRegister()
{
    Unregister (m_clsid);
}

static HRESULT Register(GUID clsid, CFactory::createFn Create)
{
    // Create a map if we don't have one
    if (!pList)
    {
        pList = new factoryMap;
    }

    // Handle out of memory situations
    if (!pList)
    {
        return (E_OUTOFMEMORY); // out of memeory
    }

    // Search for this clsid
    if (pList->find (clsid) != pList->end ())
    {
        return (E_INVALIDARG);
    }

    // Add this to the map
    try
    {
        (*pList)[clsid] = Create;
    }
    catch (...)
    {
        return (S_FALSE);
    }

    return (S_OK);
}


static HRESULT Unregister(GUID clsid)
{
    // If the map is empty, there is nothing to remove
    if (!pList)
    {
        return (E_INVALIDARG);
    }

    // Search the map
    itterator itt = pList->find (clsid);
    if (itt == pList->end ())
    {
        return (E_INVALIDARG);
    }

    // Remove the element from the map
    pList->erase (itt);

    // If the map is empty, clean up
    if (!pList->size ())
    {
        delete pList;
        pList = NULL;
    }

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\dmth8\unused\rectool.cpp ===
//-----------------------------------------------------------------------------
//	File: RecTool.cpp
//
//	Implementation of the Recording Tool.  See RecTool.h for more info and a
//	description of the expected tool behavior.
//
//	History:
//	05/08/1998 - jimmo - Created
//-----------------------------------------------------------------------------


// #include "tdmusic.h"
#include "RecTool.h"
#include <stdio.h>
#include <stddef.h>
#include "assert.h"
#include "diffinfo.h"
#include "RecTake.h"
#include "Factory.h"

HRESULT PrintPMsg (DMUS_PMSG* pPMsg);
class CThreadSafe
{
public :
	CThreadSafe (CRITICAL_SECTION* pCS) : m_pCS (pCS)
	{
		EnterCriticalSection (m_pCS);
	}
	~CThreadSafe ()
	{
		LeaveCriticalSection (m_pCS);
	}

private :
	CRITICAL_SECTION* m_pCS;

};

// {903ACE7E-2EAD-45dc-BD63-38E9C5601C97}
static const GUID IID_ITDMRECTOOL =
{ 0x903ace7e, 0x2ead, 0x45dc, { 0xbd, 0x63, 0x38, 0xe9, 0xc5, 0x60, 0x1c, 0x97 } };

static CFactory::CRegister var (IID_ITDMRECTOOL, CRecordTool::Create);

struct msgType
{
	DMUS_PMSGT_TYPES			type;
	LPCSTR						pName;
};

static const msgType msgTypes[] =
{
	{ DMUS_PMSGT_MIDI,				"DMUS_PMSGT_MIDI",				},	// MIDI short message
	{ DMUS_PMSGT_NOTE,				"DMUS_PMSGT_NOTE",				},	// Interactive Music Note
	{ DMUS_PMSGT_SYSEX,				"DMUS_PMSGT_SYSEX",				},	// MIDI long message (system exclusive message)
	{ DMUS_PMSGT_NOTIFICATION,		"DMUS_PMSGT_NOTIFICATION",		},	// Notification message
	{ DMUS_PMSGT_TEMPO,				"DMUS_PMSGT_TEMPO",				},	// Tempo message
	{ DMUS_PMSGT_CURVE,				"DMUS_PMSGT_CURVE",				},	// Control change / pitch bend, etc. curve
	{ DMUS_PMSGT_TIMESIG,			"DMUS_PMSGT_TIMESIG",			},	// Time signature
	{ DMUS_PMSGT_PATCH,				"DMUS_PMSGT_PATCH",				},	// Patch changes
	{ DMUS_PMSGT_TRANSPOSE,			"DMUS_PMSGT_TRANSPOSE",			},	// Transposition messages
	{ DMUS_PMSGT_CHANNEL_PRIORITY,	"DMUS_PMSGT_CHANNEL_PRIORITY",	},	// Channel priority
	{ DMUS_PMSGT_STOP,				"DMUS_PMSGT_STOP",				},	// Stop message
	{ DMUS_PMSGT_DIRTY,				"DMUS_PMSGT_DIRTY",				},	// Tells Tools that cache GetParam() info to refresh
	{ DMUS_PMSGT_WAVE,				"DMUS_PMSGT_WAVE",				},	// Carries control information for playing a wave.
	{ DMUS_PMSGT_LYRIC,				"DMUS_PMSGT_LYRIC",				},	// Lyric message from lyric track.
	{ DMUS_PMSGT_SCRIPTLYRIC,		"DMUS_PMSGT_SCRIPTLYRIC",		},	// Lyric message sent by a script with the Trace function.
	{ DMUS_PMSGT_USER,				"DMUS_PMSGT_USER",				},	// User message
};

//
//	Basic Constructure
//
CRecordTool::CRecordTool()
{
	m_cRef				= 1;
	m_dwNumElements 	= sizeof (msgTypes) / sizeof (msgTypes[0]);

	m_fRecording		= FALSE;

	m_dwTakeCount		= 0;
	m_dwCurTake			= -1;
	m_pCurTake			= NULL;

	InitializeCriticalSection(&m_CrSec);
}

//
//	Standard Destructor
//
CRecordTool::~CRecordTool()
{
	Erase ();
	DeleteCriticalSection (&m_CrSec);
}


/////////////////////////////////////////////////////////////////
// IUnknown
STDMETHODIMP CRecordTool::QueryInterface
(
	const IID &iid,
	void **ppv
)
{
	if (iid == IID_IUnknown || iid == IID_IDirectMusicTool)
	{
		*ppv = static_cast<IDirectMusicTool*>(this);
	}
	//This IID is useful if you get back the tool as an IDirectMusicTool pointer
	//you can QI for IID_ITESTTOOL to get access to your tools methods
	else if (iid == IID_ITDMRECTOOL)
	{
		*ppv = static_cast<CRecordTool*>(this);
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return S_OK;
}

STDMETHODIMP_(ULONG) CRecordTool::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CRecordTool::Release()
{
	if( 0 == InterlockedDecrement(&m_cRef) )
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

HRESULT STDMETHODCALLTYPE CRecordTool::Init
(
	IDirectMusicGraph* pGraph
)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CRecordTool::GetMsgDeliveryType
(
	DWORD* pdwDeliveryType
)
{
	*pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CRecordTool::GetMediaTypeArraySize
(
	DWORD* pdwNumElements
)
{
	//Number of elements that are retrieved from GetMediaTypes
	*pdwNumElements = m_dwNumElements;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CRecordTool::GetMediaTypes
(
	DWORD** padwMediaTypes,
	DWORD	dwNumElements
)
{
	// Fill in the array padwMediaTypes with the type of
	// messages this tool wants to process. dwNumElements is
	// the number requestes (should be the same as what was handed out
	// in the GetMediaTypeArraySize() method, above.

	if( m_dwNumElements != dwNumElements )
	{
		return E_INVALIDARG;
	}

	// set the elements in the array to DMUS_PMSGT_NOTE,
	// DMUS_PMSGT_MIDI, and DMUS_PMSGT_PATCH
	for (int i=0; i < m_dwNumElements; ++i)
	{
		(*padwMediaTypes)[i] = msgTypes[i].type;
	}


	return S_OK;
}


HRESULT STDMETHODCALLTYPE CRecordTool::ProcessPMsg
(
	IDirectMusicPerformance* pPerf,
	DMUS_PMSG*				 pPMsg
)
{
	HRESULT hr		= E_FAIL;

	if(( NULL == pPMsg->pGraph ) ||
		FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
	{
		return DMUS_S_FREE;
	}

	AddPMsg (pPMsg);

	// return DMUS_S_REQUEUE so the original message is requeued
	return DMUS_S_REQUEUE;
}


HRESULT STDMETHODCALLTYPE CRecordTool::Flush
(
	IDirectMusicPerformance* pPerf,
	DMUS_PMSG*				 pDMUS_PMSG,
	REFERENCE_TIME			 rt
)
{
	return E_NOTIMPL;
}

GUID CRecordTool::GetIID()
{
	return (IID_ITDMRECTOOL);
}

GUID CRecordTool::GetCLSID()
{
	return (IID_ITDMRECTOOL);
}

HRESULT CRecordTool::Create(IUnknown** ppv)
{
	if (!ppv)
	{
		return (E_INVALIDARG);
	}

	*ppv = static_cast <IUnknown*> (new CRecordTool);

	if (!*ppv)
	{
		return (E_OUTOFMEMORY);
	}

	return (S_OK);
}

HRESULT CRecordTool::Erase()
{
	CThreadSafe ts (&m_CrSec);

	try
	{
		for (iterator itt = m_Takes.begin ();itt != m_Takes.end ();itt++)
		{
			delete itt->pTake;
		}

		m_Takes.clear ();
		m_dwTakeCount = 0;
	}
	catch (...)
	{
		return (E_FAIL);
	}

	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////
//
//	SetRecordMode:
//
//	This function is called to set the record mode.
//	If fOnOff == TRUE, a new RECTOOL_TAKE_LIST element is created and
//	added to the list of Takes, pointed to by m_pTakeList.
//
//	History:
//		05.09.1999 - jimmo - Created
//
//////////////////////////////////////////////////////////////////////////
HRESULT CRecordTool::SetRecordMode
(
	BOOL	fOnOff,
	DWORD	dwTake
)
{
	CThreadSafe ts (&m_CrSec);
	m_dwCurTake = dwTake;

	m_pCurTake = NULL;

	if (TRUE == fOnOff)
	{
		// If a take already exists for this Take number, remove it
		if (NULL != GetTake(dwTake))
		{
			RemoveTake(dwTake);
		}

		RECTOOL_TAKE take;
		take.dwIndex = dwTake;
		take.fRecord = MSG_ALL;
		take.pTake = CRecTake::Create ();

		if (NULL == take.pTake)
		{
			printf("!!!! [RecTool::SetRecordMode] Failed to create new Take[%d], Out of Memory?\n", take.dwIndex);
			return E_OUTOFMEMORY;
		}

		m_Takes.push_back (take);
		m_pCurTake = --(m_Takes.end ());

		m_dwTakeCount++;
	}

	m_fRecording = fOnOff;

	return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
//	SetRecordFlags:
//
//	This function is called to control the messages recorded by this tool
//		if the take number does not exist, a new one is created.
//
//	History:
//		08.01.2000 - ruswoods - Created
//
//////////////////////////////////////////////////////////////////////////
HRESULT CRecordTool::SetRecordFlags(MESSAGES_FLAGS fFlags, DWORD dwTake)
{
	HRESULT hr = S_OK;

	if (m_pCurTake == NULL || (m_pCurTake != NULL && 
		m_pCurTake->dwIndex != dwTake))
	{
		SetRecordMode (true, dwTake);
	}

	if (hr != S_OK)
	{
		return (hr);
	}

	m_pCurTake->fRecord = fFlags;

	return (hr);
}

//////////////////////////////////////////////////////////////////////////
//
//	CompareTwoTakes:
//
//	This function compares the two takes, given by dwTake1 and dwTake2
//
//	Return Value:
//	   -1	if Error occurred or invalid params
//		0  if dwTake1 != dwTake2
//		1  if dwTake1 == dwTake2
//
//	History:
//		05.20.1999 - jimmo - Created
//
//////////////////////////////////////////////////////////////////////////
HRESULT CRecordTool::CompareTwoTakes
(
	DWORD	dwTake1,
	DWORD	dwTake2
)
{
	CThreadSafe ts (&m_CrSec);

	HRESULT hr = E_INVALIDARG;

	CRecTake* pLhs = GetTake (dwTake1);
	CRecTake* pRhs = GetTake (dwTake2);

	if (pLhs && pRhs)
	{
		hr = pLhs->Compare (pRhs);
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////
//
//	RemoveTake:
//
//	This function removes a take from the take list.
//
//	Return Value:
//		HRESULT
//
//	Params:
//		DWORD dwTake -- ID of take
//
//	History:
//		06.27.1999 - jimmo - Created
//
/////////////////////////////////////////////////////////////////////////
HRESULT CRecordTool::RemoveTake
(
	DWORD	dwTake
)
{
	CThreadSafe ts (&m_CrSec);

	for (iterator itt = m_Takes.begin ();itt != m_Takes.end ();++itt)
	{
		if (itt->dwIndex == dwTake)
		{
			delete itt->pTake;
			m_Takes.erase (itt);
			--m_dwTakeCount;

			if (dwTake == m_dwCurTake)
			{
				m_pCurTake = NULL;
			}

			return (S_OK);
		}
	}

	// If there was no matching take, return a success code
	return S_FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//	GetTake:
//
//	This function returns a RECTOOL_TAKE_LIST* for the take who's index
//	is given as dwTake
//
//	Return Value:
//		RECTOOL_TAKE_LIST* -- pointer to take or NULL if dwTake not found
//
//	Params:
//		DWORD dwTake -- ID of take
//
//	History:
//		06.22.1999 - jimmo - Created
//
//////////////////////////////////////////////////////////////////////////
CRecTake* CRecordTool::GetTake
(
	DWORD	dwTake
) const
{
	CRecTake* pTake = NULL;

	for (const_iterator itt = m_Takes.begin ();!pTake && itt != m_Takes.end ();++itt)
	{
		if (itt->dwIndex == dwTake)
		{
			pTake = itt->pTake;
		}
	}

	return pTake;
}

void CRecordTool::AddPMsg
(
	DMUS_PMSG *pPMsg
)
{
	BOOL bAdd = false;

	if (m_fRecording && m_pCurTake != NULL)
	{
		// Check to see if the flag for this message is set
		// Since the user message doesn't work with the flags, check it separately
		if (pPMsg->dwType == DMUS_PMSGT_USER)
		{
			bAdd |= m_pCurTake->fRecord & MSG_USER;
		}
		else
		{
			bAdd |= m_pCurTake->fRecord & (1 << pPMsg->dwType);
		}

		// If the type was user and the user flag was set or
		// if the flag was set for any other type, add the message
		if (bAdd)
		{
			CThreadSafe ts (&m_CrSec);

			m_pCurTake->pTake->AddMsg (pPMsg);
		}
	}
}

HRESULT CRecordTool::SaveTake(DWORD dwTake, LPCSTR pFilename)
{
	CRecTake::list	messages;
	FILE*			pFile = NULL;

	if (!pFilename)
	{
		return (E_INVALIDARG);
	}

	CRecTake* pTake = GetTake (dwTake);
	if (!pTake)
	{
		return (E_INVALIDARG);
	}

	// Attempt to open the file
	pFile = fopen (pFilename,"wb");
	if (!pFile)
	{
		return (E_FAIL);
	}

	EnterCriticalSection (&m_CrSec);
	messages = pTake->GetMessages ();
	LeaveCriticalSection (&m_CrSec);

	// File structure -
	// Number of elements
	// each element
	//		PMSG index
	//		PMSG data

	HRESULT hr = E_FAIL;

	do
	{
		int size = 0;
		// Any failure will cause a break
		// This will prevent the return of S_OK
		int nElements = messages.size ();
		if (fwrite (&nElements, sizeof (nElements), 1, pFile) != 1)
		{
			break;
		}
		size += sizeof (nElements);

		for (CRecTake::iterator itt = messages.begin ();itt != messages.end ();++itt)
		{
			CRecTake::RECTOOL_PMSG const& msg = *itt;
			if (fwrite (&msg.dwIndex, sizeof (msg.dwIndex), 1, pFile) != 1)
			{
				break;
			}
			size += sizeof (msg.dwIndex);

			if (fwrite (msg.pPMsg, 1, msg.pPMsg->dwSize, pFile) != msg.pPMsg->dwSize)
			{
				break;
			}

			size += msg.pPMsg->dwSize;
		}

		// If everything was processed, we're OK
		if (itt == messages.end ())
		{
			hr = S_OK;
		}

	} while (0);


	fclose (pFile);

	if (FAILED (hr))
	{
//		unlink (pFilename);
	}

	return (hr);
}

HRESULT CRecordTool::ReadTake(DWORD dwTake, int resource)
{
	// If a take already exists for this Take number, remove it
	if (NULL != GetTake(dwTake))
	{
		RemoveTake(dwTake);
	}

	RECTOOL_TAKE take;
	take.dwIndex = dwTake;
	take.pTake = CRecTake::Create ();

	if (NULL == take.pTake)
	{
		printf("!!!! [RecTool::SetRecordMode] Failed to create new Take[%d], Out of Memory?\n", take.dwIndex);
		return E_OUTOFMEMORY;
	}

	m_Takes.push_back (take);

	++m_dwTakeCount;
	take.pTake->ReadTake (resource);

	return (S_OK);
}

int CRecordTool::GetMessageCount (DWORD type) const
{
	CThreadSafe		ts (&m_CrSec);
	CRecTake::list	messages;
	int 			nMessages = 0;

	CRecTake* pTake = GetTake(m_dwCurTake);


	if (NULL == pTake)
	{
		return (nMessages);
	}

	if (type)
	{
		messages = pTake->GetMessages (type);
		nMessages = messages.size ();
	}
	else
	{
		nMessages = pTake->GetMessageCount ();
	}

	return (nMessages);
}

void CRecordTool::PrintMessages()
{
	CRecTake*					pTake		= NULL;
	CRecTake::list				messages;
	CRecTake::const_iterator	cit;


	// Set this block asside for the critical section
	{
		CThreadSafe		ts (&m_CrSec);
		pTake = GetTake(m_dwCurTake);
		messages = pTake->GetMessages ();
	}

	for (cit = messages.begin (); cit != messages.end (); ++cit)
	{
		CRecTake::PrintPMsg (cit->pPMsg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\Size\All\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>
#include <dmusici.h>

void CallLoaderAPIs(void)
{
    IDirectMusicLoader     *pLoader     = NULL;
    DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&pLoader);
    pLoader->AddRef();
    pLoader->CollectGarbage();
   

};
/*


void CallSegmentAPIs(void)
{
    IDirectMusicSegment     *pSegment     = NULL;
    DirectMusicCreateInstance(CLSID_DirectMusicSegment, NULL, IID_IDirectMusicSegment, (void **)&pSegment);
};

void CallOtherAPIs(void)
{
    IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicScript     *pScript     = NULL;
    DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&pPerformance);
    DirectMusicCreateInstance(CLSID_DirectMusicScript, NULL, IID_IDirectMusicScript, (void **)&pScript);

    pPerformance->InitAudioX(0, 0, 0, 0);
    pPerformance->StopEx(0, 0, 0);
};
*/

int __cdecl main()
{
    //CallLoaderAPIs();
    //CallSegmentAPIs();
    //CallOtherAPIs();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\Size\None\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>
#include <dmusici.h>

void *g_hLog;


int __cdecl main()
{

//    IDirectMusicPerformance *pPerformance = NULL;


//    DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&pPerformance);


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\tutorials\tut2\tutorial2.cpp ===
//-----------------------------------------------------------------------------
// File: tutorial2.cpp
//
// Desc: DirectMusic tutorial to show how to get an object from
//       an audio path, and set the 3D position of a DirectMusic segment
//
// Copyright (c) 2000 Microsoft Corp. All rights reserved.
//-----------------------------------------------------------------------------
#define INITGUID
#include <windows.h>
#include <dmusicc.h>
#include <dmusici.h>
#include <cguid.h>




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
IDirectMusicLoader8*      g_pLoader         = NULL;
IDirectMusicPerformance8* g_pPerformance    = NULL;
IDirectMusicSegment8*     g_pSegment        = NULL;




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Plays a single wave file using DirectMusic on the default audio path.
//-----------------------------------------------------------------------------
INT APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR pCmdLine, 
                      INT nCmdShow )
{
    // Initialize COM
    CoInitialize(NULL);
    
    // Create loader object
    CoCreateInstance( CLSID_DirectMusicLoader, NULL, CLSCTX_INPROC, 
                      IID_IDirectMusicLoader8, (void**)&g_pLoader );

    // Create performance object
    CoCreateInstance( CLSID_DirectMusicPerformance, NULL, CLSCTX_INPROC, 
                      IID_IDirectMusicPerformance8, (void**)&g_pPerformance );

    // Initialize the performance with the 3D audio path.
    // This initializes both DirectMusic and DirectSound and 
    // sets up the synthesizer. 
    g_pPerformance->InitAudio( NULL, NULL, NULL, 
                               DMUS_APATH_DYNAMIC_3D, 64,
                               DMUS_AUDIOF_ALL, NULL );

    CHAR strPath[MAX_PATH];
    GetWindowsDirectory( strPath, MAX_PATH );
    strcat( strPath, "\\media" );

    // Tell DirectMusic where the default search path is
    WCHAR wstrSearchPath[MAX_PATH];
    MultiByteToWideChar( CP_ACP, 0, strPath, -1, 
                         wstrSearchPath, MAX_PATH );

	g_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
	                               wstrSearchPath, FALSE );
    
    // Load the segment from the file
    WCHAR wstrFileName[MAX_PATH] = L"The Microsoft Sound.wav";   
    if( FAILED( g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
                                               IID_IDirectMusicSegment8,
                                               wstrFileName,
                                               (LPVOID*) &g_pSegment ) ) )
    {
        MessageBox( NULL, "Media not found, sample will now quit", 
                          "DirectMusic Tutorial", MB_OK );
        return 0;
    }

    // Download the segment's instruments to the synthesizer
    g_pSegment->Download( g_pPerformance );

    // Tell DirectMusic to repeat this segment forever
    g_pSegment->SetRepeats( DMUS_SEG_REPEAT_INFINITE );

    // Play segment on the default audio path
    g_pPerformance->PlaySegmentEx( g_pSegment, NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );

    // Now DirectMusic will play in the backgroud, 
    // so continue on with our task
    MessageBox( NULL, "The music is now playing in center. " \
                "Click OK to pan music to left.", "DirectMusic Tutorial", MB_OK );

    // Get the default audio path we just created.
    IDirectMusicAudioPath8* pAudioPath = NULL;
    g_pPerformance->GetDefaultAudioPath( &pAudioPath );

    // Get the IDirectSound3DBuffer8 from the 3D audio path
    IDirectSound3DBuffer8* pDSB = NULL;
    pAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, 0, 
                                 GUID_NULL, 0, IID_IDirectSound3DBuffer, 
                                 (LPVOID*) &pDSB );

    // Set the position of sound a little to the left
    pDSB->SetPosition( -0.1f, 0.0f, 0.0f, DS3D_IMMEDIATE );

    // Wait for input
    MessageBox( NULL, "The music is now playing on the left. " \
                "Click OK to pan music to right.", "DirectMusic Tutorial", MB_OK );

    // Set the position of sound a little to the right
    pDSB->SetPosition( 0.1f, 0.0f, 0.0f, DS3D_IMMEDIATE );

    // Wait for input
    MessageBox( NULL, "The music is now playing on the right. " \
                "Click OK to exit.", "DirectMusic Tutorial", MB_OK );

    // Stop the music, and close down 
    g_pPerformance->Stop( NULL, NULL, 0, 0 );
    g_pPerformance->CloseDown();

    // Cleanup all interfaces
    pDSB->Release();
    pAudioPath->Release();
    g_pLoader->Release(); 
    g_pPerformance->Release();
    g_pSegment->Release();

    // Close down COM
    CoUninitialize();
        
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\tutorials\tut1\tutorial1.cpp ===
//-----------------------------------------------------------------------------
// File: play.cpp
//
// Desc: DirectMusic tutorial to show how to play a segment 
//       on the default audio path
//
// Copyright (c) 2000 Microsoft Corp. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <initguid.h>
#include <dmusicc.h>
#include <dmusici.h>


extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);

extern "C" {
HRESULT STDAPICALLTYPE
DirectMusicLoaderCreate(IDirectMusicLoader8 **ppLoader, IUnknown *pUnknownOuter);

HRESULT STDAPICALLTYPE
DirectMusicPerformanceCreate(IDirectMusicPerformance8 **ppLoader, IUnknown *pUnknownOuter);
};


//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
IDirectMusicLoader8*      g_pLoader         = NULL;
IDirectMusicPerformance8* g_pPerformance    = NULL;
IDirectMusicSegment8*     g_pSegment        = NULL;

//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Plays a single wave file using DirectMusic on the default audio path.
//-----------------------------------------------------------------------------
void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) 
{
    DbgPrint("Ready to start testing.  Set breakpoints\n");
    __asm int 3

	// Create loader object
    DirectMusicLoaderCreate( &g_pLoader, NULL );

    // Create performance object
	DirectMusicPerformanceCreate( &g_pPerformance, NULL);

    // Initialize the performance with the standard audio path.
    // This initializes both DirectMusic and DirectSound and 
    // sets up the synthesizer. 
    g_pPerformance->InitAudio( NULL, NULL, NULL, 
                               DMUS_APATH_SHARED_STEREOPLUSREVERB, 64,
                               DMUS_AUDIOF_ALL, NULL );


    // Tell DirectMusic where the default search path is

	g_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
	                               L"T:\\Media\\dmtest", FALSE );
    
    // Load the segment from the file
    WCHAR wstrFileName[MAX_PATH] = L"tmsound.wav";   
    if( FAILED( g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
                                               IID_IDirectMusicSegment8,
                                               wstrFileName,
                                               (LPVOID*) &g_pSegment ) ) )
    {
		DbgPrint("Media not found, sample will now quit. File was: %ls\n", wstrFileName);
        return;
    }

    // Download the segment's instruments to the synthesizer
    g_pSegment->Download( g_pPerformance );

    // Play segment on the default audio path
    g_pPerformance->PlaySegmentEx( g_pSegment, NULL, NULL, 0, 
                                   0, NULL, NULL, NULL );

    // Now DirectMusic will play in the backgroud, 
    // so continue on with our task
    Sleep(5*1000);

    // Stop the music, and close down 
    g_pPerformance->Stop( NULL, NULL, 0, 0 );
    g_pPerformance->CloseDown();

    // Cleanup all interfaces
    g_pLoader->Release(); 
    g_pPerformance->Release();
    g_pSegment->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\Create.h ===
#pragma once

#include "macros.h"
#include "ctperf8.h"
#include "ctseg8.h"

/******************************************************************************************
******************************************************************************************/
template <class T>
CreateInstance(T **pptObject)
{
    HRESULT hr = S_OK;
    T* ptObject = NULL;

    ptObject = new T;
    if (!ptObject)
        hr = E_FAIL;

    //Init our test class.
    ptObject->InitTestClass();
    if (FAILED(hr))
        SAFEDELETE(ptObject);

    *pptObject = ptObject;
    return hr;
};

template <class T>
CreateInstance(LPVOID pObject, T **pptObject)
{
    HRESULT hr = S_OK;
    T* ptObject = NULL;

    ptObject = new T;
    if (!ptObject)
        hr = E_FAIL;

    //Init our test class.
    hr = ptObject->InitTestClass(pObject);
    if (FAILED(hr))
        SAFEDELETE(ptObject);

    *pptObject = ptObject;
    return hr;
}


/*
HRESULT CreateIDirectMusicPerformance8(CtIDirectMusicPerformance8 **pptPerformance8);
HRESULT CreateIDirectMusicSegment8(LPVOID pvXBoxSegment8, CtIDirectMusicSegment8 **pptSegment8);
HRESULT CreateIDirectMusicSegment8(CtIDirectMusicSegment8 **pptSegment8);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\ctaudpth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ctaudpth.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctaudpth.cpp
//
// Test harness implementation of IDirectMusicAudioPath
//
// Functions:
//  CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//  CtIDirectMusicAudioPath::InitTestClass()
//  CtIDirectMusicAudioPath::GetRealObjPtr()
//  CtIDirectMusicAudioPath::QueryInterface()
//  CtIDirectMusicAudioPath::GetObjectInPath()
//  CtIDirectMusicAudioPath::ConvertPChannel()
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================


#include "dmth.h"
#include "dmthp.h"


//===========================================================================
// CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()
//
// Default constructor
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::CtIDirectMusicAudioPath(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicAudioPath";

} //*** end CtIDirectMusicAudioPath::CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()
//
// Default constructor
//
// Parameters: none
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath(void)
{
    // nothing to do

} //*** end CtIDirectMusicAudioPath::~CtIDirectMusicAudioPath()


//===========================================================================
// CtIDirectMusicAudioPath::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicAudioPath *pdmAudioPath - pointer to real
//                                      IDirectMusic object
//
// Returns:
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::InitTestClass(IDirectMusicAudioPath *pdmAudioPath)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmAudioPath, sizeof(IDirectMusicAudioPath), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()

    return (CtIUnknown::InitTestClass((IUnknown*)pdmAudioPath));

} //*** end CtIDirectMusicAudioPath::InitTestClass()


//===========================================================================
// CtIDirectMusicAudioPath::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	CtIDirectMusicAudioPath **ppdmAudioPath - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetRealObjPtr(IDirectMusicAudioPath **ppdmAudioPath)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmAudioPath, sizeof(IDirectMusicAudioPath*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmAudioPath));

} //*** end CtIDirectMusicAudioPath::GetRealObjPtr()


//===========================================================================
// CtIDirectMusicAudioPath::QueryInterface
//
// Encapsulates calls to QueryInterface
//
// History:
//  12/17/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hRes        = E_NOTIMPL;
    LPVOID  *ppvTemp    = NULL;
    BOOL    fMatchFound = FALSE;

    // BUGBUG - validate ppvObj

    // BUGBUG - this will need to do some wrapper class creation
    // based on test harness specific IIDs

    // use the base class to perform the actual QI
    hRes = (CtIUnknown::QueryInterface(riid, ppvObj));

    // BUGBUG - iff harness IID, wrap the interface returned

    // BUGBUG - otherwise, copy ppvTemp to ppvObj

    // done
    return hRes;

} //*** end CtIDirectMusicAudioPath::QueryInterface()


//===========================================================================
// CtIDirectMusicAudioPath::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  12/17/1999 - kcraven - created
//  04/04/200 - kcraven - sync to dmusic changes
//===========================================================================
HRESULT CtIDirectMusicAudioPath::GetObjectInPath(
	DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void ** ppObject)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_ppObject			= TRUE;
    char    szGuidObj[MAX_LOGSTRING];
    char    szGuidIID[MAX_LOGSTRING];

    dmthGUIDtoString(guidObject, szGuidObj);
    dmthGUIDtoString(iidInterface, szGuidIID);

    if(!helpIsValidPtr((void*)ppObject, sizeof(void**), FALSE))
    {
        // bogus pointer, use as such
        fValid_ppObject = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannel      == %08Xh%s",
								dwPChannel,
                                dwPChannel==DMUS_PCHANNEL_ALL ? " (DMUS_PCHANNEL_ALL)":"");
	fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
								dwStage, dmthXlatDMUS_STAGE(dwStage));
	fnsLog(PARAMLOGLEVEL, "dwBuffer      == %08Xh",
								dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject == %s (%s)",
								szGuidObj, dmthXlatGUID(guidObject));
	fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
								dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
								szGuidIID, dmthXlatGUID(iidInterface));
    fnsLog(PARAMLOGLEVEL, "ppObject == %p   %s",
								ppObject,
								(fValid_ppObject) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->GetObjectInPath(
												dwPChannel,
												dwStage,
												dwBuffer,
												guidObject,
												dwIndex,
												iidInterface,
												ppObject
												);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_ppObject)
	{
    	fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
				ppObject);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::GetObjectInPath()


//===========================================================================
// CtIDirectMusicAudioPath::Activate()
//
// Encapsulates calls to Activate
//
// Parameters:
//  fActivate: True to activate, False to deactivate.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::Activate(BOOL fActivate)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Activate()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "fActivate == %s", fActivate ? "TRUE" : "FALSE");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->Activate(fActivate);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Activate()",m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    return hRes;


}

//===========================================================================
// CtIDirectMusicAudioPath::SetVolume()
//
// Encapsulates calls to SetVolume
//
// Parameters:
//  
//  lVolume:   Gain, in 100ths of a dB.
//  dwDuration Duration of volume ramp. Note that 0 is more efficient.
//
// History:
//  04/05/2000 - danhaff - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::SetVolume(long lVolume, DWORD dwDuration)
{
    HRESULT hRes                    = E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut   = TRUE;

    fnsIncrementIndent();


    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetVolume()", m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "lVolume == %d", lVolume);
	fnsLog(PARAMLOGLEVEL, "dwDuration == %u", dwDuration);

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->SetVolume(lVolume, dwDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetVolume()", m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)", tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();


    return hRes;
}
                                           




//===========================================================================
// CtIDirectMusicAudioPath::ConvertPChannel()
//
// Encapsulates calls to ConvertPChannel
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicAudioPath::ConvertPChannel(DWORD dwPChannelIn,DWORD *pdwPChannelOut)
{
    HRESULT hRes					= E_NOTIMPL;
    BOOL    fValid_pdwPChannelOut			= TRUE;

    if(!helpIsValidPtr((void*)pdwPChannelOut, sizeof(DWORD), FALSE))
    {
        // bogus pointer, use as such
        fValid_pdwPChannelOut = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::ConvertPChannel()",
								m_szInterfaceName);
	fnsLog(PARAMLOGLEVEL, "dwPChannelIn   == %08Xh",
								dwPChannelIn);
    fnsLog(PARAMLOGLEVEL, "pdwPChannelOut == %p   %s",
								pdwPChannelOut,
								(fValid_pdwPChannelOut) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicAudioPath*)m_pUnk)->ConvertPChannel(dwPChannelIn,pdwPChannelOut);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::ConvertPChannel()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
	if(fValid_pdwPChannelOut)
	{
    	fnsLog(PARAMLOGLEVEL, "*pdwPChannelOut == %p",
				*pdwPChannelOut);
	}

    fnsDecrementIndent();


    return hRes;

} //*** end CtIDirectMusicAudioPath::ConvertPChannel()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\Create.cpp ===
#include "ctSeg8.h"
#include "ctperf8.h"
#include "ctloader8.h"


/******************************************************************************************
******************************************************************************************/
HRESULT CreateIDirectMusicPerformance8(CtIDirectMusicPerformance8 **pptPerformance8)
{
HRESULT hr = S_OK;

CtIDirectMusicPerformance8 *ptPerformance8 = NULL;
ptPerformance8 = new CtIDirectMusicPerformance8;
if (!ptPerformance8)
    hr = E_FAIL;


//Init our test class.
ptPerformance8->InitTestClass();

*pptPerformance8 = ptPerformance8;
return hr;
};



HRESULT CreateIDirectMusicLoader8(CtIDirectMusicLoader8 **pptLoader8)
{
HRESULT hr = S_OK;

CtIDirectMusicLoader8 *ptLoader8 = NULL;
ptLoader8 = new CtIDirectMusicLoader8;
if (!ptLoader8)
    hr = E_FAIL;


//Init our test class.
ptLoader8->InitTestClass();

*pptLoader8 = ptLoader8;
return hr;
};


/******************************************************************************************
******************************************************************************************/
HRESULT CreateIDirectMusicSegment8(CtIDirectMusicSegment8 **pptSegment8)
{
HRESULT hr = S_OK;

CtIDirectMusicSegment8 *ptSegment8 = NULL;
ptSegment8 = new CtIDirectMusicSegment8;
if (!ptSegment8)
    hr = E_FAIL;


//Init our test class.
ptSegment8->InitTestClass();

*pptSegment8 = ptSegment8;
return hr;
};



/******************************************************************************************
This is the same as the above function, except it creates the wrapper segment based on 
an XBox pointer.  This is needed when an XBox pointer is returned.
******************************************************************************************/
HRESULT CreateIDirectMusicSegment8(LPVOID pvXBoxSegment8, CtIDirectMusicSegment8 **pptSegment8)
{
HRESULT hr = S_OK;

CtIDirectMusicSegment8 *ptSegment8 = NULL;
ptSegment8 = new CtIDirectMusicSegment8;
if (!ptSegment8)
    hr = E_FAIL;


//Init our test class.
ptSegment8->InitTestClass(pvXBoxSegment8);

*pptSegment8 = ptSegment8;
return hr;
};







/*
void __stdcall Hello(void)
{
HRESULT hr = S_OK;
};

void _stdcall Hello(void)
{
HRESULT hr = S_OK;
};
*/

void Hello(void)
{
HRESULT hr = S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\ctperf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctperf8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctperf8.cpp
//
// Test harness implementation of IDirectMusicPerformance8
//
// Functions:
//   CtIDirectMusicPerformance8::InitAudio()
//   CtIDirectMusicPerformance8::PlaySegmentEx()
//   CtIDirectMusicPerformance8::StopEx()
//   CtIDirectMusicPerformance8::ClonePMsg()
//   CtIDirectMusicPerformance8::CreateAudioPath()
//   CtIDirectMusicPerformance8::CreateStandardAudioPath()
//   CtIDirectMusicPerformance8::SetDefaultAudioPath()
//   CtIDirectMusicPerformance8::GetDefaultAudioPath()
//   CtIDirectMusicPerformance8::SetParamHook()
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================

#include "globals.h"
#include "ctperf8.h"
#include "trans.h"
#include "typeinfo.h"

//---------------------------------------------------------------------------




//===========================================================================
// CtIDirectMusicPerformance8::CtIDirectMusicPerformance8()
///
// Default constructor
//===========================================================================
CtIDirectMusicPerformance8::CtIDirectMusicPerformance8(void)

{
    //Say my name!    
    strcpy(m_szClassName, &(typeid(this).name())[8]);
    m_szClassName[strlen(m_szClassName) - 2] = NULL;  //cut off the " *"
} // *** end CtIDirectMusicPerformance8::CtIDirectMusicPerformance8()



/*
//===========================================================================
//===========================================================================
CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8(void)
{






} // *** end CtIDirectMusicPerformance8::~CtIDirectMusicPerformance8()
*/


//===========================================================================
// CtIDirectMusicPerformance8::InitTestClass
//===========================================================================
/*
HRESULT CtIDirectMusicPerformance8::InitTestClass(void)
{

    DWORD dwParameters = 0;
    LPVOID *ppv = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    LPDATABLOCK *ppDataBlocks = NULL;

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //No in parameters, one "out" parameter. No THIS ptr
    CHECKRUN(pTrans->WriteMainBlockHeader(NULL, "Create_IDirectMusicPerformance8", 0));  
    
    //No data chunks, since we're just creating.
    CHECKRUN(pTrans->WriteParamBlockHeader(0));  

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //Get the number of parameters
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (2!=dwParameters)
        Output("IDirectMusicPerformance8 creation didn't returned unexpected number of paramters");

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the XBox pointer and return code here.
    //Parameter         (TYPE)                         [blk]
    //--------------------------------------------------------------------
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;
    m_pvXBoxPointer = *(LPVOID *) ppDataBlocks         [1]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));

    return hrCall;


} // *** end CtIDirectMusicPerformance8::InitTestClass()


*/
//===========================================================================
// CtIDirectMusicPerformance8::InitAudio()
//
// Encapsulates calls to InitAudio
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::InitAudio(
	IDirectMusic** ppDirectMusic,              // Optional DMusic pointer.
	IDirectSound** ppDirectSound,            // Optional DSound pointer.
	HWND hWnd,                               // HWND for DSound.
	DWORD dwDefaultPathType,                 // Requested default audio path type, also optional.
	DWORD dwPChannelCount,                   // Number of PChannels, if default audio path to be created.
	DWORD dwFlags,                           // DMUS_AUDIOF flags, if no pParams structure.
	DMUS_AUDIOPARAMS *pParams)              // Optional initialization structure, defining required voices, buffers, etc.
{
    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    DMUS_AUDIOPARAMS Params = {0};

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //5 In-parameters (we're ignoring the first 3 parameters).
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicPerformance8::InitAudio", 5));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: dwDefaultPathType
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwDefaultPathType), &dwDefaultPathType));  

    //PARAMETER 3: dwPChannelCount
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwPChannelCount), &dwPChannelCount));  

    //PARAMETER 4: dwFlags
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwFlags), &dwFlags));  

    //PARAMETER 5: pParams
    //1 data chunk.
    if (pParams)
        Params = *pParams;
    CHECKRUN(pTrans->WriteParamBlockHeader(2));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue,         NULL, NULL, sizeof(DMUS_AUDIOPARAMS *), &pParams));  
    CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 0, 0,       sizeof(DMUS_AUDIOPARAMS),   &Params));

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramter
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);
    return hrCall;

} // *** end CtIDirectMusicPerformance8::InitAudio()



//===========================================================================
// CtIDirectMusicPerformance8::PlaySegmentEx()
//
// Encapsulates calls to PlaySegmentEx
//
// History:
//  10/13/1999 - kcraven - created
//  01/17/2000 - kcraven - updated
//  02/02/2000 - kcraven - fixed logging string
//===========================================================================
HRESULT CtIDirectMusicPerformance8::PlaySegmentEx(CtIUnknown* pSource,                  // Segment to play. Alternately, could be an IDirectMusicSong.
                                           WCHAR *pwzSegmentName,                       // If song, which segment in the song.
                                           CtIUnknown* pTransition,                     // Optional template segment to compose transition with.
                                           DWORD dwFlags,                               // DMUS_SEGF_ flags.
                                           __int64 i64StartTime,                        // Time to start playback.
                                           CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                           CtIUnknown *pFrom,                           // Optional segmentstate or audiopath to replace.
                                           CtIUnknown *pAudioPath)                      // Optional audioPath to play on.
//HRESULT CtIDirectMusicPerformance8::PlaySegmentEx
//(
//	CtIUnknown* pSource,
//	DWORD dwSegmentID,
//	CtIUnknown* pTransition,						// Optional
//	DWORD dwFlags, 
//	__int64 i64StartTime,
//	CtIDirectMusicSegmentState** ppSegmentState,	// Optional
//	CtIUnknown *pFrom,								// Optional
//	CtIUnknown *pAudioPath							// Optional
//)
{
    HRESULT                     hRes					= E_NOTIMPL;
    BOOL		                fValid_pSource			= TRUE;
    BOOL		                fValid_pTransition		= TRUE;
    BOOL		                fValid_ppSegmentState	= TRUE;
    BOOL		                fValid_pFrom			= TRUE;
    BOOL		                fValid_pAudioPath		= TRUE;
    IUnknown*					pdmSource				= NULL;
    IUnknown*					pdmTransition			= NULL;
    IDirectMusicSegmentState*	pdmSegSt                = NULL;
    IDirectMusicSegmentState**	ppdmSegSt				= NULL;
    IUnknown*					pdmFrom					= NULL;
	IUnknown*					pdmAudioPath			= NULL;


    DWORD dwParameters = 0;
    LPDATABLOCK *ppDataBlocks = NULL;
    HRESULT hr = S_OK;
    HRESULT hrCall = S_OK;
    DMUS_AUDIOPARAMS Params = {0};

    //Write to the file notifying it of this test class's creation.
    TRANS *pTrans = NULL;
    ALLOCATEANDCHECK(pTrans, TRANS);
    CHECKRUN(pTrans->Client_CreateParameterDataFile());
    
    //5 In-parameters (we're ignoring the first 3 parameters).
    CHECKRUN(pTrans->WriteMainBlockHeader(m_pvXBoxPointer, "IDirectMusicPerformance8::InitAudio", 5));  
    
    //PARAMETER 1: THIS!
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(LPVOID), &m_pvXBoxPointer));  

    //PARAMETER 2: dwDefaultPathType
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwDefaultPathType), &dwDefaultPathType));  

    //PARAMETER 3: dwPChannelCount
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwPChannelCount), &dwPChannelCount));  

    //PARAMETER 4: dwFlags
    //1 data chunk.
    CHECKRUN(pTrans->WriteParamBlockHeader(1));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue, NULL, NULL, sizeof(dwFlags), &dwFlags));  

    //PARAMETER 5: pParams
    //1 data chunk.
    if (pParams)
        Params = *pParams;
    CHECKRUN(pTrans->WriteParamBlockHeader(2));  
    CHECKRUN(pTrans->WriteDataBlock(ByValue,         NULL, NULL, sizeof(DMUS_AUDIOPARAMS *), &pParams));  
    CHECKRUN(pTrans->WriteDataBlock(PointerToMemory, 0, 0,       sizeof(DMUS_AUDIOPARAMS),   &Params));

    //Close out the file.  This will cause it to be sent to the XBox.
    CHECKRUN(pTrans->CloseDataFile());

    //Now wait for the returned datafile.
    CHECKRUN(pTrans->Client_ReadReturnedDataFile());    

    //There should be 1 out-paramter
    //  1) Return Value
    CHECKRUN(pTrans->ReadMainBlockHeader(NULL, NULL, &dwParameters));

    if (1!=dwParameters)
        Output("IDirectMusicPerformance8::InitAudio returned %d paramters instead of 1", dwParameters);

    //Get a pointer to all the parameters.
    CHECKRUN(pTrans->ReadParameters(dwParameters, &ppDataBlocks));

    //Store the return code here.
    hrCall          = *(HRESULT *)ppDataBlocks         [0]    [0].pvData;

    CHECKRUN(pTrans->DeleteAllocatedParameterList(dwParameters, ppDataBlocks));
    CHECKRUN(pTrans->CloseDataFile());
    SAFEDELETE(pTrans);
    return hrCall;
/*


    // validate pSource
    if(!helpIsValidPtr((void*)pSource, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pSource = FALSE;
        pdmSource = (IUnknown*)pSource;

    }
    else
    {
        // good pointer, get the real object
        hRes = pSource->GetRealObjPtr(&pdmSource);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate pTransition
    if(!helpIsValidPtr((void*)pTransition, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pTransition != NULL)
		{
			fValid_pTransition = FALSE;
		}
        pdmTransition = (IUnknown*)pTransition;

    }
    else
    {
        // good pointer, get the real object
        hRes = pTransition->GetRealObjPtr(&pdmTransition);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppSegmentState
    // NOTE:
    //	If we are passed an invalid CtIDirectMusicSegmentState pointer, we assume
    //  that we are to perform an invalid parameter test on
    //  IDirectMusicPerformance:PlaySegment().  Otherwise, we are to create and
    //  return a CtIDirectMusicSegmentState object
    // NOTE:
    //  NULL is valid here... be careful!
    if(!helpIsValidPtr((void*)ppSegmentState,
                        sizeof(CtIDirectMusicSegmentState*), TRUE))
    {
        // bogus pointer, use as such
        if(ppSegmentState != NULL)
		{
	        fValid_ppSegmentState = FALSE;
		}
        ppdmSegSt = (IDirectMusicSegmentState**)ppSegmentState;

    }
    else
    {
        if(ppSegmentState)
        {
            // valid pointer, create a real object
            ppdmSegSt = &pdmSegSt;

            // just in case we fail, init test object ptr to NULL
            *ppSegmentState = NULL;
        }

    }

     // validate pFrom
    if(!helpIsValidPtr((void*)pFrom, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pFrom != NULL)
		{
	        fValid_pFrom = FALSE;
		}
        pdmFrom = (IUnknown*)pFrom;

    }
    else
    {
        // good pointer, get the real object
        hRes = pFrom->GetRealObjPtr(&pdmFrom);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

   // validate pdmAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                    FALSE))
    {
        // bogus pointer, use as such
        if(pAudioPath != NULL)
		{
	        fValid_pAudioPath = FALSE;
		}
        pdmAudioPath = (IUnknown*)pAudioPath;

    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::PlaySegmentEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSource        == %p   %s",
            pdmSource,
            fValid_pSource ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pwzSegmentName == %p",
            pwzSegmentName);
    fnsLog(PARAMLOGLEVEL, "pTransition    == %08Xh   %s",
            pdmTransition,
            fValid_pTransition ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "dwFlags        == %08Xh",
            dwFlags);
    fnsLog(PARAMLOGLEVEL, "i64StartTime   == %016Xh", //BUGBUG - can't print 64 bit numbers in fnshell
            i64StartTime);
    fnsLog(PARAMLOGLEVEL, "ppSegmentState == %p   %s",
            ppdmSegSt,
            fValid_ppSegmentState ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pFrom          == %p   %s",
            pdmFrom,
            fValid_pFrom ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pAudioPath     == %p   %s",
            pdmAudioPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->PlaySegmentEx(
				pdmSource,
				pwzSegmentName,
				pdmTransition,
				dwFlags,
				i64StartTime,
				ppdmSegSt,
				pdmFrom,
				pdmAudioPath
				);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::PlaySegmentEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes            == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppSegmentState && ppSegmentState)
    {
        fnsLog(PARAMLOGLEVEL, "*ppSegmentState == %p",
                pdmSegSt);
    }

    // wrap the segment state so we don't return the real object
    if(SUCCEEDED(hRes) && ppSegmentState)
    {
        hRes = dmthCreateTestWrappedObject(pdmSegSt, ppSegmentState);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
        }
    }

    fnsDecrementIndent();

    // done
END:
    if(fValid_pSource && pdmSource)
    {
        pdmSource->Release();
    }
    if(fValid_pTransition && pdmTransition)
    {
        pdmTransition->Release();
    }
    if(fValid_ppSegmentState && pdmSegSt)
    {
        pdmSegSt->Release();
    }
    if(fValid_pFrom && pdmFrom)
    {
        pdmFrom->Release();
    }
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} //*** end CtIDirectMusicPerformance8::PlaySegmentEx()




//===========================================================================
// CtIDirectMusicPerformance8::StopEx()
//
// Encapsulates calls to StopEx
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::StopEx
(
	CtIUnknown *pObjectToStop,
	__int64 i64StopTime,
	DWORD dwFlags
)
{
    HRESULT     hRes					= E_NOTIMPL;
    BOOL		fValid_pObjectToStop	= TRUE;
	IUnknown 	*pdmObjectToStop 		= NULL;

    // validate pObjectToStop
    if(!helpIsValidPtr((void*)pObjectToStop, sizeof(CtIUnknown), FALSE))
    {
        fValid_pObjectToStop = FALSE;
        pdmObjectToStop = (IUnknown*)pObjectToStop;
    }
    else
    {
        // good pointer, get the real object
        hRes = pObjectToStop->GetRealObjPtr(&pdmObjectToStop);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }


    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pObjectToStop == %p   %s",
            pdmObjectToStop,
            fValid_pObjectToStop ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "i64StopTime   == %016Xh", //BUGBUG - can't print 64 bit numbers in fnshell
            i64StopTime);
    fnsLog(PARAMLOGLEVEL, "dwFlags       == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->StopEx(pdmObjectToStop,i64StopTime,dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::StopEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
 END:
    if(fValid_pObjectToStop && pdmObjectToStop)
    {
        pdmObjectToStop->Release();
    }
   return hRes;

} // *** end CtIDirectMusicPerformance8::StopEx()




//===========================================================================
// CtIDirectMusicPerformance8::ClonePMsg()
//
// Encapsulates calls to ClonePMsg
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::ClonePMsg
(
	DMUS_PMSG* pSourcePMSG,
	DMUS_PMSG** ppCopyPMSG
)
{
    HRESULT     hRes						= E_NOTIMPL;
    BOOL		fValid_pSourcePMSG				= TRUE;
    BOOL		fValid_ppCopyPMSG				= TRUE;

    // validate pSourcePMSG
    if(!helpIsValidPtr((void*)pSourcePMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_pSourcePMSG = FALSE;
    }

    // validate ppCopyPMSG
    if(!helpIsValidPtr((void*)ppCopyPMSG, sizeof(DMUS_PMSG*), FALSE))
    {
        fValid_ppCopyPMSG = FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourcePMSG == %p   %s",
            pSourcePMSG,
            fValid_pSourcePMSG ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppCopyPMSG  == %p   %s",
            ppCopyPMSG,
            fValid_ppCopyPMSG ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->ClonePMsg(pSourcePMSG,ppCopyPMSG);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::ClonePMsg()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicPerformance8::ClonePMsg()




//===========================================================================
// CtIDirectMusicPerformance8::CreateAudioPath()
//
// Encapsulates calls to CreateAudioPath
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateAudioPath(
	CtIUnknown *pSourceConfig, 
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath)
{
    HRESULT					hRes					= E_NOTIMPL;
    BOOL					fValid_pSourceConfig	= TRUE;
    BOOL					fValid_ppNewPath		= TRUE;
	IUnknown*				pdmSourceConfig 		= NULL;
    IDirectMusicAudioPath*	pdmNewPath				= NULL;
    IDirectMusicAudioPath**	ppdmNewPath				= NULL;


    // validate pSourceConfig
    if(!helpIsValidPtr((void*)pSourceConfig, sizeof(CtIUnknown), FALSE))
    {
        fValid_pSourceConfig = FALSE;
        pdmSourceConfig = (IUnknown*)pSourceConfig;
    }
    else
    {
        // good pointer, get the real object
        hRes = pSourceConfig->GetRealObjPtr(&pdmSourceConfig);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    // validate ppNewPath
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmNewPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmNewPath = &pdmNewPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pSourceConfig == %p   %s",
            pdmSourceConfig,
            fValid_pSourceConfig ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "fActivate     == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath     == %p   %s",
            ppdmNewPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateAudioPath(pdmSourceConfig,fActivate,ppdmNewPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmNewPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmNewPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmNewPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

END:
    // done
    if(fValid_ppNewPath && pdmNewPath)
    {
        pdmNewPath->Release();
    }

    //Added 7/13/00 - Danhaff
    if (fValid_pSourceConfig && pdmSourceConfig)
    {
        pdmSourceConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::CreateStandardAudioPath()
//
// Encapsulates calls to CreateStandardAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::CreateStandardAudioPath
(
	DWORD dwType,
	DWORD dwPChannelCount,
	BOOL fActivate,
	CtIDirectMusicAudioPath **ppNewPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppNewPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppNewPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppNewPath = FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppNewPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppNewPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwType          == %08Xh (%s)",
            dwType,
            dmthXlatDMUS_APATH(dwType));
    fnsLog(PARAMLOGLEVEL, "dwPChannelCount == %08Xh",
            dwPChannelCount);
    fnsLog(PARAMLOGLEVEL, "fActivate == %d",
            fActivate);
    fnsLog(PARAMLOGLEVEL, "ppNewPath       == %p   %s",
            ppdmPath,
            fValid_ppNewPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->CreateStandardAudioPath(dwType,dwPChannelCount,fActivate,ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::CreateStandardAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppNewPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppNewPath == %p",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppNewPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppNewPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::CreateStandardAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetDefaultAudioPath()
//
// Encapsulates calls to SetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::SetDefaultAudioPath
(
	CtIDirectMusicAudioPath *pAudioPath
)
{
    HRESULT		hRes				= E_NOTIMPL;
    BOOL		fValid_pAudioPath	= TRUE;
    IDirectMusicAudioPath*	pdmPath	= NULL;

    // validate pTemplate
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIDirectMusicAudioPath),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pAudioPath = FALSE;
        pdmPath = (IDirectMusicAudioPath*)pAudioPath;

    }
    else
    {
        // good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath       == %p   %s",
            pdmPath,
            fValid_pAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetDefaultAudioPath(pdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();
END:
    // done
    if(fValid_pAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetDefaultAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::GetDefaultAudioPath()
//
// Encapsulates calls to GetDefaultAudioPath
//
// History:
//  01/17/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetDefaultAudioPath
(
	CtIDirectMusicAudioPath **ppAudioPath
)
{
    HRESULT			hRes				= E_NOTIMPL;
    BOOL			fValid_ppAudioPath	= TRUE;
    IDirectMusicAudioPath	*pdmPath	= NULL;
    IDirectMusicAudioPath	**ppdmPath	= NULL;

    // validate pptdmPort
    if(!helpIsValidPtr((void*)ppAudioPath, sizeof(CtIDirectMusicAudioPath*),
                        FALSE))
    {
        // bogus pointer, use as such
        fValid_ppAudioPath= FALSE;
        ppdmPath = (IDirectMusicAudioPath**)ppAudioPath;

    }
    else
    {
        // valid pointer, create a real object
        ppdmPath = &pdmPath;

        // just in case we fail, init test object ptr to NULL
        *ppAudioPath = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppAudioPath       == %p   %s",
            ppdmPath,
            fValid_ppAudioPath ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetDefaultAudioPath(ppdmPath);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetDefaultAudioPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    if(fValid_ppAudioPath)
    {
        fnsLog(PARAMLOGLEVEL, "*ppAudioPath == %08Xh",
                pdmPath);
		// create the test object
		if(SUCCEEDED(hRes) && pdmPath)
		{
			hRes = dmthCreateTestWrappedObject(pdmPath, ppAudioPath);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}

    fnsDecrementIndent();

    // done
    if(fValid_ppAudioPath && pdmPath)
    {
        pdmPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::GetDefaultAudioPath()




//===========================================================================
// CtIDirectMusicPerformance8::SetParamHook()
//
// Encapsulates calls to SetParamHook
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicPerformance8::SetParamHook(CtIDirectMusicParamHook* pIHook)
{
    HRESULT             hRes				= E_NOTIMPL;
    BOOL		        fValid_pIHook    = TRUE;
    IDirectMusicParamHook   *pdmIHook           = NULL;

    // validate pSegment
    if(!helpIsValidPtr((void*)pIHook, sizeof(CtIDirectMusicGraph),
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_pIHook = FALSE;
        pdmIHook = (IDirectMusicParamHook*)pIHook;

    }
    else
    {
        // good pointer, get the real object
        hRes = pIHook->GetRealObjPtr(&pdmIHook);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pGraph == %p   %s",
            pdmIHook,
            fValid_pIHook ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->SetParamHook(pdmIHook);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::SetParamHook()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pIHook && pdmIHook)
    {
        pdmIHook->Release();
    }
    return hRes;

} // *** end CtIDirectMusicPerformance8::SetParamHook()
*/
/*
//===========================================================================
// CtIDirectMusicPerformance8::GetParamEx()
//
// Encapsulates calls to GetParamEx
//
// History:
//  04/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicPerformance8::GetParamEx(
	REFGUID rguidType, 
	DWORD dwTrackID,
	DWORD dwGroupBits, 
	DWORD dwIndex, 
	MUSIC_TIME mtTime, 
	MUSIC_TIME* pmtNext, 
	void* pData)
{
    HRESULT hRes				= E_NOTIMPL;
	BOOL	fValid_pmtNext		= TRUE;
	BOOL	fValid_pData		= TRUE;
    char    szGuid[MAX_LOGSTRING];

    // validate pmtNext
    if(!helpIsValidPtr((void*)pmtNext, sizeof(MUSIC_TIME), FALSE))
    {
        fValid_pmtNext = FALSE;
    }
    
    // validate pData
    if(!helpIsValidPtr((void*)pData, 1, FALSE))
    {
        fValid_pData = FALSE;
    }

    dmthGUIDtoString(rguidType, szGuid);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "---- Calling %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidType    == %s (%s)",
			szGuid, dmthXlatGUID(rguidType));
    fnsLog(PARAMLOGLEVEL, "dwTrackID    == %08Xh",
            dwTrackID);
    fnsLog(PARAMLOGLEVEL, "dwGroupBits  == %08Xh",
            dwGroupBits);
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
	fnsLog(PARAMLOGLEVEL, "mtTime       == %08Xh",
            mtTime);
	fnsLog(PARAMLOGLEVEL, "pmtNext      == %p   %s",
            pmtNext,
            fValid_pmtNext ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pData        == %p   %s",
            pData,
            fValid_pData ? "" : "BAD");
     
    // call the real function
    hRes = ((IDirectMusicPerformance8*)m_pUnk)->GetParamEx(
		rguidType, 
		dwTrackID,
		dwGroupBits, 
		dwIndex, 
		mtTime, 
		pmtNext, 
		pData);

    // log results
    fnsLog(CALLLOGLEVEL, "---- Returned from %s::GetParamEx()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pmtNext)
    {
        fnsLog(PARAMLOGLEVEL, "*pmtNext   == %08Xh",
                *pmtNext);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} //*** end CtIDirectMusicPerformance8::GetParam()
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\ctseg8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ctseg8.cpp
//
//--------------------------------------------------------------------------

//===========================================================================
// ctseg8.cpp
//
// Test harness implementation of IDirectMusicSegment
//
// Functions:
//    CtIDirectMusicSegment8::SetTrackConfig()
//    CtIDirectMusicSegment8::GetTrackConfig()
//    CtIDirectMusicSegment8::SetClockTimeDuration()
//    CtIDirectMusicSegment8::GetClockTimeDuration()
//    CtIDirectMusicSegment8::SetFlags();
//    CtIDirectMusicSegment8::GetFlags();
//    CtIDirectMusicSegment8::GetObjectInPath()
//    CtIDirectMusicSegment8::GetAudioPathConfig()
//    CtIDirectMusicSegment8::Compose()
//    CtIDirectMusicSegment8::Download()
//    CtIDirectMusicSegment8::Unload()
//
//
// History:
//  10/13/1999 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================

#include "dmth.h"
#include "dmthp.h"
#include "dmthcom.h"

//===========================================================================
// CtIDirectMusicSegment8::CtIDirectMusicSegment8()
//
// Default constructor
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegment8::CtIDirectMusicSegment8(void)
{
    // initialize our member variables
	m_pUnk = NULL;
	m_dwRefCount = 1;
	m_szInterfaceName = "IDirectMusicSegment8";

} // *** end CtIDirectMusicSegment8::CtIDirectMusicSegment8()




//===========================================================================
// CtIDirectMusicSegment8::~CtIDirectMusicSegment8()
//
// Default constructor
//
// Parameters: none
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
CtIDirectMusicSegment8::~CtIDirectMusicSegment8(void)
{
    // nothing to do

} // *** end CtIDirectMusicSegment8::~CtIDirectMusicSegment8()




//===========================================================================
// CtIDirectMusicSegment8::InitTestClass
//
// Internal harness method to initialize the test class.  Stores actual
//  IDirectMusicObject pointer for future use.
//
// Parameters:
//  IDirectMusicSegment8 *pdmSegment8 - pointer to real 
//                                      IDirectMusicSegment8 object
//
// Returns: 
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::InitTestClass(IDirectMusicSegment8 *pdmSegment8)
{
	// validate pointer... if bad, return error
	if(!helpIsValidPtr(pdmSegment8, sizeof(IDirectMusicSegment8), FALSE))
	{
        m_pUnk = NULL;
		return E_POINTER;
	}

    // call the base classes InitTestClass()
    return (CtIUnknown::InitTestClass((IUnknown*)pdmSegment8));

} // *** end CtIDirectMusicSegment8::InitTestClass()




//===========================================================================
// CtIDirectMusicSegment8::GetRealObjPtr
//
// Allows us to tell who is hiding in our test class.
//
// Parameters:
//	IDirectMusicSegment8 **ppdmSegment8 - ptr used to return real object ptr
//
// Returns: HRESULT
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetRealObjPtr(IDirectMusicSegment8 **ppdmSegment8)
{

	// validate ppdm
	if(!helpIsValidPtr(ppdmSegment8, sizeof(IDirectMusicSegment8*), FALSE))
	{
		return E_POINTER;
	}

    // call the base classes GetRealObjPtr()
    return (CtIUnknown::GetRealObjPtr((IUnknown**)ppdmSegment8));

} // *** end CtIDirectMusicSegment8::GetRealObjPtr()




//===========================================================================
// CtIDirectMusicSegment8::SetTrackConfig()
//
// Encapsulates calls to SetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//  03/17/2000 - kcraven - fixedto match dmusic change
//===========================================================================
HRESULT CtIDirectMusicSegment8::SetTrackConfig(
	REFGUID rguidTrackClassID,
    DWORD dwGroup,
    DWORD dwIndex,
    DWORD dwFlagsOn,
    DWORD dwFlagsOff)
{
    HRESULT hRes            = E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID  = TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup    == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex    == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOn  == %08Xh",
            dwFlagsOn);
    fnsLog(PARAMLOGLEVEL, "dwFlagsOff == %08Xh",
            dwFlagsOff);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			dwFlagsOn,
    			dwFlagsOff
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetTrackConfig()




//===========================================================================
// CtIDirectMusicSegment8::GetTrackConfig()
//
// Encapsulates calls to GetTrackConfig
//
// History:
//  10/12/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetTrackConfig(
	REFGUID rguidTrackClassID,
	DWORD dwGroup,
	DWORD dwIndex,
	DWORD *pdwFlags)
{
    HRESULT hRes						= E_NOTIMPL;
    BOOL    fValid_rguidTrackClassID	= TRUE;
    BOOL    fValid_pdwFlags				= TRUE;
    char    szGuid[MAX_LOGSTRING];

    dmthGUIDtoString(rguidTrackClassID, szGuid);

    // validate pdwFlags
    if(!helpIsValidPtr((void*)pdwFlags, sizeof(DWORD), FALSE))
    {
        fValid_pdwFlags = FALSE;
    }

	fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rguidTrackClassID == %s (%s)",
            szGuid, dmthXlatGUID(rguidTrackClassID));
    fnsLog(PARAMLOGLEVEL, "dwGroup == %08Xh",
            dwGroup);
    fnsLog(PARAMLOGLEVEL, "dwIndex == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "pdwFlags == %p",
            pdwFlags);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetTrackConfig(
				rguidTrackClassID,
    			dwGroup,
    			dwIndex,
    			pdwFlags
				);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetTrackConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes      == %s (%08Xh)",
            dmthXlatHRESULT(hRes), hRes);
    if(fValid_pdwFlags)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwFlags == %08Xh",
                *pdwFlags);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetTrackConfig()
*/



//===========================================================================
// CtIDirectMusicSegment8::GetClockTimeDuration()
//
// Encapsulates calls to GetClockTimeDuration
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetClockTimeDuration(REFERENCE_TIME *prtDuration)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_prtDuration    = TRUE;
    
    // validate pmtLength
    if(!helpIsValidPtr((void*)prtDuration, sizeof(REFERENCE_TIME), FALSE))
    {
        fValid_prtDuration	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "prtDuration == %016Xh   %s",
            prtDuration,
            fValid_prtDuration ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetClockTimeDuration(prtDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_prtDuration)
    {
        fnsLog(PARAMLOGLEVEL, "*prtDuration == %016Xh",
                *prtDuration);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetClockTimeDuration()
*/



//===========================================================================
// CtIDirectMusicSegment8::SetClockTimeDuration()
//
// Encapsulates calls to SetClockTimeDuration
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetClockTimeDuration(REFERENCE_TIME rtDuration)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "rtDuration == %016Xh",
            rtDuration);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetClockTimeDuration(rtDuration);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetClockTimeDuration()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetClockTimeDuration()
*/



//===========================================================================
// CtIDirectMusicSegment8::GetFlags()
//
// Encapsulates calls to GetFlags
//
// History:
//  11/02/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetFlags(DWORD *pdwFlags)
{
    HRESULT hRes				= E_NOTIMPL;
    BOOL    fValid_pdwFlags    = TRUE;
    
    // validate pmtLength
    if(!helpIsValidPtr((void*)pdwFlags, sizeof(DWORD), FALSE))
    {
        fValid_pdwFlags	= FALSE;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pdwFlags == %p   %s",
            pdwFlags,
            fValid_pdwFlags ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetFlags(pdwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes       == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_pdwFlags)
    {
        fnsLog(PARAMLOGLEVEL, "*pdwFlags == %08Xh",
                *pdwFlags);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetFlags()
*/



//===========================================================================
// CtIDirectMusicSegment8::SetFlags()
//
// Encapsulates calls to SetFlags
//
// History:
//  10/13/1999 - kcraven - created
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::SetFlags(DWORD dwFlags)
{
    HRESULT hRes    = E_NOTIMPL;
    
    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::SetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwFlags == %08Xh",
            dwFlags);

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->SetFlags(dwFlags);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::SetFlags()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::SetFlags()
*/



//===========================================================================
// CtIDirectMusicSegment8::GetObjectInPath()
//
// Encapsulates calls to GetObjectInPath
//
// History:
//  01/24/2000 - kcraven - created
//  04/06/2000 - danhaff - removed as per dmusic header changes.
//===========================================================================
/*
HRESULT CtIDirectMusicSegment8::GetObjectInPath
(
	DWORD dwPChannel,
	DWORD dwStage,
	DWORD dwBuffer,
	REFGUID guidObject,
	DWORD dwIndex,
	REFGUID iidInterface,
	void ** ppObject
)
{
    HRESULT             hRes					= E_NOTIMPL;
    BOOL	            fValid_ppObject		= TRUE;
    char                szguidObject[MAX_LOGSTRING];
    char                sziidInterface[MAX_LOGSTRING];


    // validate ppObject
    if(!helpIsValidPtr((void*)ppObject, sizeof(void*), FALSE))
    {
        fValid_ppObject = FALSE;
    }

    dmthGUIDtoString(guidObject, szguidObject);
    dmthGUIDtoString(iidInterface, sziidInterface);

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "dwPChannel   == %08Xh",
            dwPChannel);
    fnsLog(PARAMLOGLEVEL, "dwStage      == %08Xh (%s)",
            dwStage, dmthXlatDMUS_PATH(dwStage));
    fnsLog(PARAMLOGLEVEL, "dwBuffer     == %08Xh",
            dwBuffer);
    fnsLog(PARAMLOGLEVEL, "guidObject   == %s (%s)",
            szguidObject, dmthXlatGUID(guidObject));
    fnsLog(PARAMLOGLEVEL, "dwIndex      == %08Xh",
            dwIndex);
    fnsLog(PARAMLOGLEVEL, "iidInterface == %s (%s)",
            sziidInterface, dmthXlatGUID(iidInterface));
	fnsLog(PARAMLOGLEVEL, "ppObject     == %p   %s",
            ppObject,
            fValid_ppObject ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetObjectInPath(
														dwPChannel,
														dwStage,
														dwBuffer,
														guidObject,
														dwIndex,
														iidInterface,
														ppObject);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetObjectInPath()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes     == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppObject && *ppObject)
    {
        fnsLog(PARAMLOGLEVEL, "*ppObject == %p",
                *ppObject);
    }

    fnsDecrementIndent();

    // done
    return hRes;

} // *** end CtIDirectMusicSegment8::GetObjectInPath()

*/


//===========================================================================
// CtIDirectMusicSegment8::GetAudioPathConfig()
//
// Encapsulates calls to GetAudioPathConfig
//
// History:
//  01/24/2000 - kcraven - created
//===========================================================================
HRESULT CtIDirectMusicSegment8::GetAudioPathConfig(CtIUnknown ** ppIAudioPathConfig)
{
    HRESULT		hRes						= E_NOTIMPL;
    BOOL		fValid_ppIAudioPathConfig	= TRUE;
    IUnknown	*pdmIAudioPathConfig		= NULL;
    IUnknown	**ppdmIAudioPathConfig		= NULL;

    // validate ppIAudioPathConfig
    if(!helpIsValidPtr((void*)ppIAudioPathConfig, sizeof(CtIUnknown*), 
                    FALSE))
    {
        // bogus pointer, use as such
        fValid_ppIAudioPathConfig = FALSE;
        ppdmIAudioPathConfig = (IUnknown**)ppIAudioPathConfig;

    }
    else
    {
        // valid pointer, create a real object
        ppdmIAudioPathConfig = &pdmIAudioPathConfig;

        // just in case we fail, init test object ptr to NULL
        *ppIAudioPathConfig = NULL;
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "ppIAudioPathConfig == %p   %s",
            ppdmIAudioPathConfig,
            (fValid_ppIAudioPathConfig) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->GetAudioPathConfig(ppdmIAudioPathConfig);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::GetAudioPathConfig()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppIAudioPathConfig)
    {
        fnsLog(PARAMLOGLEVEL, "*ppIAudioPathConfig == %p",
                pdmIAudioPathConfig);
		// create the test object
		if(SUCCEEDED(hRes) && pdmIAudioPathConfig)
		{
			hRes = dmthCreateTestWrappedObject(pdmIAudioPathConfig, ppIAudioPathConfig);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", hRes);
			}
		}
    }

    fnsDecrementIndent();

    // done
    if(fValid_ppIAudioPathConfig && pdmIAudioPathConfig)
    {
        pdmIAudioPathConfig->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::GetAudioPathConfig()




//===========================================================================
// CtIDirectMusicSegment8::Compose()
//
// Encapsulates calls to Compose
//
// History:
//  01/24/2000 - kcraven - created
//  09/16/2000 - danhaff - fixed leak by not releasing real composed segment.
//===========================================================================
HRESULT CtIDirectMusicSegment8::Compose
(
	MUSIC_TIME mtTime,
	CtIDirectMusicSegment* pFromSegment,
	CtIDirectMusicSegment* pToSegment,
	CtIDirectMusicSegment** ppComposedSegment
)
{
    HRESULT	hRes								= E_NOTIMPL;
    BOOL	fValid_pFromSegment					= TRUE;
	BOOL	fValid_pToSegment					= TRUE;
	BOOL	fValid_ppComposedSegment			= TRUE;
    IDirectMusicSegment*	pdmFromSegment		= NULL;
    IDirectMusicSegment*	pdmToSegment		= NULL;
    IDirectMusicSegment*	pdmComposedSegment	= NULL;
    IDirectMusicSegment**	ppdmComposedSegment	= NULL;

    // validate pFromSegment
    if(!helpIsValidPtr((void*)pFromSegment, sizeof(CtIDirectMusicSegment),
                        TRUE))
    {
        fValid_pFromSegment = FALSE;

        // we have a bogus pointer, use it as such
        pdmFromSegment = (IDirectMusicSegment*)pFromSegment;
    }
    else
    {
        // we have a good pointer, get the real object
		if(pFromSegment) // bug NULL is OK
		{
			hRes = pFromSegment->GetRealObjPtr(&pdmFromSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
						"object pointer (%s == %08Xh)",
						tdmXlatHRESULT(hRes), hRes);
				goto END;
			}
		}
    }
    // validate pToSegment
    if(!helpIsValidPtr((void*)pToSegment, sizeof(CtIDirectMusicSegment),
                        TRUE))
    {
        fValid_pToSegment = FALSE;

        // we have a bogus pointer, use it as such
        pdmToSegment = (IDirectMusicSegment*)pToSegment;
    }
    else
    {
		if(pToSegment)
		{
			// we have a good pointer, get the real object
			hRes = pToSegment->GetRealObjPtr(&pdmToSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
						"object pointer (%s == %08Xh)",
						tdmXlatHRESULT(hRes), hRes);
				goto END;
			}
		}
    }
    // validate ppComposedSegment
    if(!helpIsValidPtr((void*)ppComposedSegment, sizeof(CtIDirectMusicSegment*), 
                    TRUE))
    {
        // bogus pointer, use as such
        fValid_ppComposedSegment = FALSE;
        ppdmComposedSegment = (IDirectMusicSegment**)ppComposedSegment;

    }
    else
    {
		if(ppComposedSegment)
		{
			// valid pointer, create a real object
			ppdmComposedSegment = &pdmComposedSegment;

			// just in case we fail, init test object ptr to NULL
			*ppComposedSegment = NULL;
		}
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "mtTime            == %08Xh",
            mtTime);
    fnsLog(PARAMLOGLEVEL, "pFromSegment      == %p   %s",
            pdmFromSegment,
            (fValid_pFromSegment) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "pToSegment        == %p   %s",
            pdmToSegment,
            (fValid_pToSegment) ? "" : "BAD");
    fnsLog(PARAMLOGLEVEL, "ppComposedSegment == %p   %s",
            ppdmComposedSegment,
            (fValid_ppComposedSegment) ? "" : "BAD");
    
    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Compose(
												mtTime,
												pdmFromSegment,
												pdmToSegment,
												ppdmComposedSegment);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Compose()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes        == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);
    if(fValid_ppComposedSegment)
    {
        fnsLog(PARAMLOGLEVEL, "*ppComposedSegment == %p",
                pdmComposedSegment);
		// create the test object
		if(SUCCEEDED(hRes) && pdmComposedSegment)
		{
			hRes = dmthCreateTestWrappedObject(pdmComposedSegment, ppComposedSegment);
			if(FAILED(hRes))
			{
				fnsLog(MINLOGLEVEL, "**** Unable to create wrapped object %08Xh", 
						hRes);
			}
		}
	}
    fnsDecrementIndent();

    // done
END:
    if(fValid_pFromSegment && pdmFromSegment)
    {
        pdmFromSegment->Release();
    }
    if(fValid_pToSegment && pdmToSegment)
    {
        pdmToSegment->Release();
    }
    
    //danhaff - added 9/16/00
    if (pdmComposedSegment)
    {
        pdmComposedSegment->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Compose()




//===========================================================================
// CtIDirectMusicSegment8::Download()
//
// Encapsulates calls to Download
//
// History:
//  01/24/2000 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================
HRESULT CtIDirectMusicSegment8::Download(CtIUnknown *pAudioPath)
{
    HRESULT					hRes				= E_NOTIMPL;
    BOOL					fValid_pAudioPath	= TRUE;
    IUnknown	*pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                        FALSE))
    {
        fValid_pAudioPath = FALSE;

        // we have a bogus pointer, use it as such
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            (fValid_pAudioPath) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Download(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Download()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Download()




//===========================================================================
// CtIDirectMusicSegment8::Unload()
//
// Encapsulates calls to Unload
//
// History:
//  01/24/2000 - kcraven - created
//  03/03/2000 - kcraven - fixed to match dmusic change
//===========================================================================
HRESULT CtIDirectMusicSegment8::Unload(CtIUnknown *pAudioPath)
{
    HRESULT					hRes				= E_NOTIMPL;
    BOOL					fValid_pAudioPath	= TRUE;
    IUnknown				*pdmAudioPath		= NULL;

    // validate pAudioPath
    if(!helpIsValidPtr((void*)pAudioPath, sizeof(CtIUnknown),
                        FALSE))
    {
        fValid_pAudioPath = FALSE;

        // we have a bogus pointer, use it as such
        pdmAudioPath = (IUnknown*)pAudioPath;
    }
    else
    {
        // we have a good pointer, get the real object
        hRes = pAudioPath->GetRealObjPtr(&pdmAudioPath);
        if(FAILED(hRes))
        {
            fnsLog(MINLOGLEVEL, "**** Unable to retrieve real "
                    "object pointer (%s == %08Xh)",
                    tdmXlatHRESULT(hRes), hRes);
            goto END;
        }
    }

    fnsIncrementIndent();

    // log inputs
    fnsLog(CALLLOGLEVEL, "--- Calling %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "pAudioPath == %p   %s",
            pdmAudioPath,
            (fValid_pAudioPath) ? "" : "BAD");

    // call the real function
    hRes = ((IDirectMusicSegment8*)m_pUnk)->Unload(pdmAudioPath);

    // log results
    fnsLog(CALLLOGLEVEL, "--- Returned from %s::Unload()",
            m_szInterfaceName);
    fnsLog(PARAMLOGLEVEL, "hRes == %s (%08Xh)",
            tdmXlatHRESULT(hRes), hRes);

    fnsDecrementIndent();

    // done
END:
    if(fValid_pAudioPath && pdmAudioPath)
    {
        pdmAudioPath->Release();
    }
    return hRes;

} // *** end CtIDirectMusicSegment8::Unload()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\ctperf8.h ===
#pragma once

#include "dmusici.h"
#include "ctiunk.h"



//===========================================================================
// CtIDirectMusicPerformance
// Wrapper class for IDirectMusicPerformance
// Inherits from CtIUnknown
//===========================================================================
/*
class CtIDirectMusicPerformance// : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance();
    ~CtIDirectMusicPerformance();

    // test class helpers


    virtual HRESULT InitTestClass(IDirectMusicPerformance *pdmPerformance);
/*
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance **ppdmPerformance);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);

    //BUGBUG - DO WE STIL NEED THESE WRAPPED?
    //we don't normally wrap these, but they were needed in a few tests to help track leaks
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    virtual HRESULT GetSegmentState(CtIDirectMusicSegmentState** pptdmSegmentState,
                                    MUSIC_TIME mtTime);
    virtual HRESULT SendPMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT IsPlaying(CtIDirectMusicSegment* ptdmSegment,
                            CtIDirectMusicSegmentState* ptdmSegState);
    virtual HRESULT GetTime(REFERENCE_TIME* prtNow, MUSIC_TIME* pmtNow);
    virtual HRESULT AllocPMsg(ULONG cb, DMUS_PMSG** ppPMSG);
    virtual HRESULT FreePMsg(DMUS_PMSG* pPMSG);
    virtual HRESULT GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    virtual HRESULT AddNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT RemoveNotificationType(REFGUID rguidNotificationType);
    virtual HRESULT GetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT SetGlobalParam(REFGUID rguidType, void* pData,
                                    DWORD dwSize);
    virtual HRESULT CloseDown(void);
*/

//}; // ** end CtIDirectMusicPerformance

//===========================================================================
// CtIDirectMusicPerformance8
//
// Wrapper class for IDirectMusicPerformance8
//
// Inherits from CtIDirectMusicPerformance
//===========================================================================
class CtIDirectMusicPerformance8 : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPerformance8();
    //~CtIDirectMusicPerformance8();
    // test class helpers
    //HRESULT InitTestClass(void);

    virtual HRESULT InitAudio(IDirectMusic** ppDirectMusic,               // Optional DMusic pointer.
                                            IDirectSound** ppDirectSound,           // Optional DSound pointer.
                                            HWND hWnd,                              // HWND for DSound.
                                            DWORD dwDefaultPathType,                // Requested default audio path type, also optional.
                                            DWORD dwPChannelCount,                  // Number of PChannels, if default audio path to be created.
                                            DWORD dwFlags,                          // DMUS_AUDIOF flags, if no pParams structure.
                                            DMUS_AUDIOPARAMS *pParams);             // Optional initialization structure, defining required voices, buffers, etc.

  /*  
    virtual HRESULT GetRealObjPtr(IDirectMusicPerformance8 **ppdmPerformance);


    virtual HRESULT PlaySegmentEx(CtIUnknown* pSource,                             // Segment to play. Alternately, could be an IDirectMusicSong.
                                            WCHAR *pwzSegmentName,                  // If song, which segment in the song.
                                            CtIUnknown* pTransition,                  // Optional template segment to compose transition with.
                                            DWORD dwFlags,                          // DMUS_SEGF_ flags.
                                            __int64 i64StartTime,                   // Time to start playback.
                                            CtIDirectMusicSegmentState** ppSegmentState, // Returned Segment State.
                                            CtIUnknown *pFrom,                        // Optional segmentstate or audiopath to replace.
                                            CtIUnknown *pAudioPath);             // Optional audioPath to play on.
    virtual HRESULT StopEx(CtIUnknown *pObjectToStop,
                                            __int64 i64StopTime,
                                            DWORD dwFlags);
    virtual HRESULT CreateAudioPath(CtIUnknown *pSourceConfig,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount,
                                            BOOL fActivate,
                                            CtIDirectMusicAudioPath **ppNewPath);
    virtual HRESULT SetDefaultAudioPath(CtIDirectMusicAudioPath *pAudioPath);
*/


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\Copy.h ===
#pragma once

HRESULT CopyFileToXBox(char *szSrcFile);
HRESULT CopyDMusicFileToXBox(char *szSrcFile);
HRESULT CopyDMusicFileToXBox(WCHAR *wszSrcFile);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\globals.h ===
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
//#include <waveldr.h>
#include <float.h>
#include <dmusicc.h>
#include <dmusici.h>
#include "..\trans\macros.h"
#include "trans.h"
#include "util.h"
#include <typeinfo.h>

#define RUN( func )                                              \
{                                                                    \
	hr = func;                                                       \
}                                                                    


#define CHECKRUN( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUN(exp);                                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\dmclient\Copy.cpp ===
#include "trans.h"
#include "getrefs.h"

/****************************************************************
Must be called at the beginning of our host app.
****************************************************************/
/*
HRESULT XBoxSendFile(char *szSrcFile)
{
    static char szString[512] = {0};

    sprintf(szString, "xbcp -y %s xt:\\trans\\%s", szSrcFile, szSrcFile);
    system(szString);
    return S_OK;
}
*/



/****************************************************************
This copies a piece of DirectMusic content and all related content
to the XBox

I'm ripping stuff out of DMFILER to put in here.  Hopefully it's easy :)
****************************************************************/
HRESULT CopyDMusicFileToXBox(char *szSrcFile)
{
HRESULT hr = S_OK;
char **ppszFileNames = NULL;
DWORD dwCount = 0;
DWORD i = 0;
char *szFileName = NULL;


    //Copy the original file.  We wait for it, because it had better copy.
    hr = XBoxSendFile(szSrcFile, TRUE);

    //Get a list of the referenced files.
    hr = GetReferencedFileNames(szSrcFile, &ppszFileNames, &dwCount);

    for (i=0; i<dwCount; i++)
    {
        //We're not gonna wait for these since they don't exist.  However we shoul
        //  have a warning mechanism...
        hr = XBoxSendFile(ppszFileNames[i], FALSE);
    }

    hr = DeleteReferenceFileNames(ppszFileNames, dwCount);
    if (FAILED(hr))
    {
        return hr;
    }
    return S_OK;

};




HRESULT CopyDMusicFileToXBox(WCHAR *wszSrcFile)
{
char szSrcFile[MAX_PATH] = {0};
wcstombs(szSrcFile, wszSrcFile, MAX_PATH);
return CopyDMusicFileToXBox(szSrcFile);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\dmusic\wrappers\client\dmth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmth.h
//
//--------------------------------------------------------------------------

//===========================================================================
// dmth.h
//
// DirectMusic test harness class descriptions
//
// History:
//  10/14/1997 - davidkl - created
//  01/09/1998 - a-llucar - added method to dmloader.h
//  01/13/1998 - a-llucar - added IDMDownload (from dmusic.h)
//  03/02/1998 - davidkl - ported to latest dmusic architecture changes
//  03/25/1998 - davidkl - removed all non-class goop, renamed to dmthcls
//  05/11/1998 - a-trevg - added explicit _stdcall to exported functions
//  07/31/1998 - a-llucar - added GetResolvedTime method
//  10/13/1998 - kcraven - added Loader::SetObject method
//  10/12/1999 - kcraven - started adding DX8 wmethods
//  01/24/2000 - kcraven - continued adding DX8 methods
//  01/25/2000 - kcraven - start moving dhthCreate Helpers to common file
//  02/18/2000 - kcraven - added loader8 LoadObjectFromFile commented out
//  02/26/2000 - danhaff - Added Port8::SetSink and GetSink methods.
//  03/17/2000 - kcraven - changed Seg8 and SegSt8 to match changes in dmusic.
//  03/29/2000 - kcraven - attempting to sync to dmusic again.
//  04/04/2000 - kcraven - changing to use the SD dmusic headers and
//                         removing dependencies on private checked-in headers
//  04/06/2000 - danhaff-  Removd certain wrapper objects as per dmusic
//                         header changes.
//  04/12/2000 - danhaff-  Added logging functions for DSFX
//  05/01/2000 - kcraven-  Added wrapper for idirectmusic8
//===========================================================================

#ifndef _DMTHCLS_H
#define _DMTHCLS_H

//===========================================================================

// included headers
#include <windows.h>


#include <dmusicc.h>
#include <dmusici.h>
#include <dmusicf.h>
#include <dmusics.h>


//BUGBUG
//DMusicc.h has lost
//DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);
//and
//DMusics.h has lost
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
//by-design
//we ned them to compile


// we require dsound.h we don't need to include it because dmusic includes it already
// BUT, we must use internal dsoundp.h renamed as dsound.h
// to prevent compiler errors (undefined internal only stuff)
// #include <dsound.h>

#include <fnshell2.h>

#include "dmthhelp.h"
#include "memptr.h"
#include "dmStress.h"  //So the wrapper definitions can know about their object stressor objects.
#include "dmStressControl.h" //So the app may control which interfaces are stressed.

//codecoverage and other special tests
#define TDM_USER_MODE_SYNTH         1
#define TDM_KERNEL_MODE_SYNTH       2
#define TDM_HARDWARE_MODE_SYNTH     4

extern BOOL  g_fSelectingDefaultPort;
extern DWORD g_dwUseThisSynth;


//BUGBUG - WHY NOT USE THE REAL THING?
// Added by a-llucar 8/4/98
#define SOFTWARESYNTH_PORT  DMUS_PC_SOFTWARESYNTH
#define EXTERNAL_PORT       DMUS_PC_EXTERNAL
#define GMINHARDWARE_PORT   DMUS_PC_GMINHARDWARE
#define GSINHARDWARE_PORT   DMUS_PC_GSINHARDWARE

#define WINMM               DMUS_PORT_WINMM_DRIVER
#define USER_MODE           DMUS_PORT_USER_MODE_SYNTH
#define KERNEL_MODE         DMUS_PORT_KERNEL_MODE

// symbolic constants
#ifndef MAX_LOGSTRING
#define MAX_LOGSTRING       127
#endif
// logging level for tracking method calls
#ifndef CALLLOGLEVEL
#define CALLLOGLEVEL        3
#endif
// logging level for parameter data
#ifndef PARAMLOGLEVEL
#define PARAMLOGLEVEL       5
#endif
// logging level for structure contents
#ifndef STRUCTLOGLEVEL
#define STRUCTLOGLEVEL      6
#endif
// MINimum logging level
#ifndef MINLOGLEVEL
#define MINLOGLEVEL         0
#endif
// MAXimum logging level
#ifndef MAXLOGLEVEL
#define MAXLOGLEVEL         10
#endif


//---------------------------------------------------------------------------

// forward definitions for test classes
class CtIUnknown;

//---------------------------------------------------------------------------

// BUGBUG - MUST WRAP
// interface IDirectMusicThru;

// "dmusicc"
class CtIDirectMusic;
class CtIDirectMusic8;              //dx8
class CtIDirectMusicBuffer;
class CtIDirectMusicPort;
//class CtIDirectMusicPort8;            //dx8
//class CtIDirectMusicVoice;            //dx8
class CtIDirectMusicSynthSink;
//class CtIDirectSoundDownloadedWave;   //dx8
class CtIDirectMusicCollection;
class CtIDirectMusicInstrument;
class CtIDirectMusicDownloadedInstrument;
class CtIDirectMusicPortDownload;
class CtIDirectMusicDownload;
class CtIReferenceClock;

// "dmusici"
class CtIDirectMusicObject;
//class CtIDirectMusicObject8;      //dx8
class CtIDirectMusicLoader;
class CtIDirectMusicLoader8;        //dx8
class CtIDirectMusicSegment;
class CtIDirectMusicSegment8;       //dx8
class CtIDirectMusicSegmentState;
class CtIDirectMusicSegmentState8;  //dx8
class CtIDirectMusicAudioPath;      //dx8
class CtIDirectMusicTrack;
class CtIDirectMusicTrack8;         //dx8
class CtIDirectMusicContainer;      //dx8
//PHOOPHOO
//class CtIDirectMusicParamHook;        //dx8
class CtIDirectMusicPerformance;
class CtIDirectMusicPerformance8;   //dx8
class CtIDirectMusicTool;
class CtIDirectMusicTool8;          //dx8
class CtIDirectMusicGraph;
class CtIDirectMusicStyle;
class CtIDirectMusicStyle8;         //dx8
class CtIDirectMusicChordMap;
class CtIDirectMusicComposer;
//class CtIDirectMusicComposer8;        //dx8
class CtIDirectMusicPatternTrack;   //dx8
class CtIDirectMusicSynth;
class CtIDirectMusicSynth8;         //dx8
class CtIDirectMusicBand;
//class CtIDirectMusicBand8;            //dx8
class CtIDirectMusicGetLoader;
// class CtIDirectMusicSong;           //dx8
class CtIDirectMusicScript;         //dx8
//PHOOPHOO
// class CtIDirectSoundWave;            //dx8
// class CtIDirectMusicScriptError; //dx8  REMOVED

// kcraven tdmusic8 unit test helper comments
/*
IDirectMusic;
IDirectMusicBand;
IDirectMusicBuffer;
IDirectMusicChordMap;
IDirectMusicCollection;
IDirectMusicComposer;
IDirectMusicDownload;
IDirectMusicDownloadedInstrument;
IDirectMusicGetLoader;
IDirectMusicGraph;
IDirectMusicInstrument;
IDirectMusicLoader;
IDirectMusicObject;
IDirectMusicPerformance;
IDirectMusicPort;
IDirectMusicPortDownload;
IDirectMusicSegment;
IDirectMusicSegmentState;
IDirectMusicStyle;
IDirectMusicSynth;
IDirectMusicSynthSink;
IDirectMusicTool;                   not in tdmusic8
IDirectMusicTrack;
IReferenceClock;

tdmusic8 dx8 progress

IDirectMusic8;              //dx8   not sure how to do yet - no new methods but new interface
IDirectMusicAudioPath;      //dx8   dummy unit source done
IDirectMusicBand8;          //dx8   dummy unit source done
IDirectMusicComposer8;      //dx8   dummy unit source done
IDirectMusicContainer;      //dx8   dummy unit source done
IDirectMusicLoader8;        //dx8   dummy unit source done
IDirectMusicObject8;        //dx8   not sure how to do yet
IDirectMusicPatternTrack;   //dx8   dummy unit source done
IDirectMusicPerformance8;   //dx8   dummy unit source done
IDirectMusicPort8;          //dx8   dummy unit source done
IDirectMusicScript;         //dx8   not doing in tdmusic8 - jimmo?
IDirectMusicScriptError;    //dx8   not doing in tdmusic8 - jimmo?
IDirectMusicSegment8;       //dx8   dummy unit source done
IDirectMusicSegmentState8;  //dx8   dummy unit source done
IDirectMusicSong;           //dx8   dummy unit source done
IDirectMusicStyle8;         //dx8   dummy unit source done
IDirectMusicSynth8;         //dx8   dummy unit source done
IDirectMusicTool8;          //dx8
IDirectMusicTrack8;         //dx8   dummy unit source done
IDirectMusicVoice;          //dx8   dummy unit source done
IDirectSoundDownloadedWave; //dx8   not doing unit tests - no methods
IDirectSoundWave;           //dx8   not doing unit tests - may be moved to dsound
*/

//===========================================================================
// CtIUnknown
//
// Wrapper class for IUnknown.
//    This is the base class for all other dmusic test harness classes
//
//===========================================================================
class CtIUnknown
{
    public:
    // constructor / destructor
    CtIUnknown();
    ~CtIUnknown();
    // test class helpers
    virtual HRESULT InitTestClass(IUnknown *pUnk);
    virtual HRESULT GetRealObjPtr(IUnknown **ppUnk);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual DWORD AddRef(void);
    virtual DWORD Release(void);

    //danhaff - snuck this out so template functions could print what interface they're using.
    LPSTR       m_szInterfaceName;

    protected:
    IUnknown            *m_pUnk;
    DWORD               m_dwRefCount;
    DMOBJECTSTRESSOR    *m_pDMObjectStressor;

}; // ** end CtIUnknown

//===========================================================================
// CtIDirectMusic
//
// Wrapper class for IDirectMusic
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusic : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusic();
    ~CtIDirectMusic();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusic *pdm);
    virtual HRESULT GetRealObjPtr(IDirectMusic **ppdm);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusic methods
    virtual HRESULT EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);

    virtual HRESULT CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc,
                                CtIDirectMusicBuffer **pptdmBuffer,
                                IUnknown *punk);
    virtual HRESULT CreatePort(REFGUID rguidPort,
                               LPDMUS_PORTPARAMS pPortParams,
                               CtIDirectMusicPort **pptdmPort,
                               IUnknown *punk);
    virtual HRESULT EnumMasterClock(DWORD dwIdx, LPDMUS_CLOCKINFO lpClockCaps);
    virtual HRESULT GetMasterClock(GUID *guidClock,
                                CtIReferenceClock **pptReferenceClock);
    virtual HRESULT SetMasterClock(REFGUID guidClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT GetDefaultPort(GUID *pguidPort);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                   HWND hWnd);

}; // ** end CtIDirectMusic

//===========================================================================
// CtIDirectMusic8
//
// Wrapper class for IDirectMusic8
//
// Inherits from: CtIDirectMusic
//===========================================================================
class CtIDirectMusic8 : public CtIDirectMusic
{
    public:
    // constructor / destructor
    CtIDirectMusic8();
    ~CtIDirectMusic8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusic8 *pdm);
    virtual HRESULT GetRealObjPtr(IDirectMusic8 **ppdm);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusic methods
//  virtual HRESULT EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);

//  virtual HRESULT CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc,
//                                CtIDirectMusicBuffer **pptdmBuffer,
//                                IUnknown *punk);
//  virtual HRESULT CreatePort(REFGUID rguidPort,
//                               LPDMUS_PORTPARAMS pPortParams,
//                               CtIDirectMusicPort **pptdmPort,
//                               IUnknown *punk);
//  virtual HRESULT EnumMasterClock(DWORD dwIdx, LPDMUS_CLOCKINFO lpClockCaps);
//  virtual HRESULT GetMasterClock(GUID *guidClock,
//                                CtIReferenceClock **pptReferenceClock);
//  virtual HRESULT SetMasterClock(REFGUID guidClock);
//  virtual HRESULT Activate(BOOL fEnable);
//  virtual HRESULT GetDefaultPort(GUID *pguidPort);
//  virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
//                                   HWND hWnd);

    //dx8
    virtual HRESULT SetExternalMasterClock(IReferenceClock *pClock); // don't use wrapped clock

}; // ** end CtIDirectMusic8


//===========================================================================
// CtIDirectMusicBuffer
//
// Wrapper class for IDirectMusicBuffer
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicBuffer : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicBuffer();
    ~CtIDirectMusicBuffer();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicBuffer *pdmBuf);
    virtual HRESULT GetRealObjPtr(IDirectMusicBuffer **ppdmBuf);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicBuffer methods
    virtual HRESULT Flush(void);
    virtual HRESULT TotalTime(LPREFERENCE_TIME prtTime);
    virtual HRESULT PackStructured(REFERENCE_TIME rt, DWORD dwChannelGroup,
                                    DWORD dwMsg);
    virtual HRESULT PackUnstructured(REFERENCE_TIME rt, DWORD dwChannelGroup,
                                DWORD cb, LPBYTE lpb);
    virtual HRESULT ResetReadPtr(void);
    virtual HRESULT GetNextEvent(LPREFERENCE_TIME prt, LPDWORD pdwChannelGroup,
                                LPDWORD pdwLength, LPBYTE *ppData);
    virtual HRESULT GetRawBufferPtr(LPBYTE *ppData);
    virtual HRESULT GetStartTime(LPREFERENCE_TIME prt);
    virtual HRESULT GetUsedBytes(LPDWORD pcb);
    virtual HRESULT GetMaxBytes(LPDWORD pcb);
    virtual HRESULT SetStartTime(REFERENCE_TIME rt);
    virtual HRESULT SetUsedBytes(DWORD cb);
    virtual HRESULT GetBufferFormat(LPGUID pGuidFormat);

}; // ** end CtIDirectMusicBuffer

//===========================================================================
// CtIDirectMusicPort
//
// Wrapper class for IDirectMusicPort
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicPort : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPort();
    ~CtIDirectMusicPort();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPort *pdmPort);
    virtual HRESULT GetRealObjPtr(IDirectMusicPort **pdmPort);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicPort methods
    virtual HRESULT PlayBuffer(CtIDirectMusicBuffer *ptdmBuf);
    virtual HRESULT SetReadNotificationHandle(HANDLE hEvent);
    virtual HRESULT Read(CtIDirectMusicBuffer *ptdmBuf);
    virtual HRESULT DownloadInstrument(CtIDirectMusicInstrument *ptdmInst,
                             CtIDirectMusicDownloadedInstrument **pptdmDlInst,
                              DMUS_NOTERANGE* pdmNoteRange,
                            DWORD dwNumRanges);
    virtual HRESULT UnloadInstrument(CtIDirectMusicDownloadedInstrument *ptdmDlInst);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptClock);
    virtual HRESULT GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    virtual HRESULT Compact(void);
    virtual HRESULT GetCaps(LPDMUS_PORTCAPS pPortCaps);
    virtual HRESULT DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer,
                                    DWORD nInBufferSize, LPVOID lpOutBuffer,
                                    DWORD nOutBufferSize, LPDWORD lpBytesReturned,
                                    LPOVERLAPPED lpOverlapped);
    virtual HRESULT GetNumChannelGroups(LPDWORD pdwGroups);
    virtual HRESULT SetNumChannelGroups(DWORD dwChannelGroups);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SetChannelPriority(DWORD dwChannelGroup,
                                      DWORD dwChannel,
                                      DWORD dwPriority);
    virtual HRESULT GetChannelPriority(DWORD dwChannelGroup,
                                      DWORD dwChannel,
                                      LPDWORD pdwPriority);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                    LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual HRESULT GetFormat(LPWAVEFORMATEX pWaveFormatEx,
                                LPDWORD pdwWaveFormatExSize,
                                LPDWORD pdwBufferSize);


}; // *** end CtIDirectMusicPort

//===========================================================================
// CtIDirectMusicPort8
//
// Wrapper class for IDirectMusicPort8
//
// Inherits from: CtIDirectMusicPort
//===========================================================================
/*
class CtIDirectMusicPort8 : public CtIDirectMusicPort
{
    public:
    // constructor / destructor
    CtIDirectMusicPort8();
    ~CtIDirectMusicPort8();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPort8 *pdmPort);
    virtual HRESULT GetRealObjPtr(IDirectMusicPort8 **pdmPort);
    // IDirectMusicPort8
    virtual HRESULT DownloadWave(IN  CtIDirectSoundWave *pWave, OUT CtIDirectSoundDownloadedWave **ppWave);
    virtual HRESULT UnloadWave(IN CtIDirectSoundDownloadedWave *pWave);
//PHOOPHOO
//    virtual HRESULT AllocVoice(IN CtIDirectSoundDownloadedWave *pWave,IN DWORD dwChannel,IN DWORD dwChannelGroup,
//                              IN REFERENCE_TIME rtStart,IN REFERENCE_TIME rtReadahead,OUT CtIDirectMusicVoice **ppVoice);
    virtual HRESULT AllocVoice
        (
         IN CtIDirectSoundDownloadedWave *pWave,    // Wave to play on this voice
         IN DWORD dwChannel,                        // Channel and channel group
         IN DWORD dwChannelGroup,                   //  this voice will play on
         IN REFERENCE_TIME rtStart,                 // Start position (stream only)
         IN SAMPLE_TIME stLoopStart,                // Loop start (one-shot only)
         IN SAMPLE_TIME stLoopEnd,                  // Loop end (one-shot only)
         OUT CtIDirectMusicVoice **ppVoice          // Returned voice
        );
//PHOOPHOO
//    virtual HRESULT AllocVoice
//        (IN CtIDirectSoundDownloadedWave *pWave,IN DWORD dwChannel,IN DWORD dwChannelGroup,IN REFERENCE_TIME rtStart,
//         IN REFERENCE_TIME rtReadahead,IN SAMPLE_TIME stLoopStart,IN SAMPLE_TIME stLoopEnd,OUT CtIDirectMusicVoice **ppVoice);
    virtual HRESULT AssignChannelToBuses(IN DWORD dwChannelGroup,IN DWORD dwChannel,IN LPDWORD pdwBusses,IN DWORD cBussCount);
    virtual HRESULT SetSink(IN  IDirectSoundSink *pSink);
    virtual HRESULT GetSink(OUT IDirectSoundSink **ppSink);
}; // *** end CtIDirectMusicPort8
*/

//===========================================================================
// CtIDirectSoundDownloadedWave
//
// Wrapper class for IDirectSoundDownloadedWave
//
// Inherits from: CtIUnknown
//===========================================================================
/*
class CtIDirectSoundDownloadedWave : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectSoundDownloadedWave();
    ~CtIDirectSoundDownloadedWave();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectSoundDownloadedWave *pdmDSDLWave);
    virtual HRESULT GetRealObjPtr(IDirectSoundDownloadedWave **ppdmDSDLWave);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicDownloadedWave
    // none
};
*/


//===========================================================================
// CtIDirectMusicVoice
//
// Wrapper class for IDirectMusicVoice
//
// Inherits from: CtIUnknown
//===========================================================================
/*
class CtIDirectMusicVoice : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicVoice();
    ~CtIDirectMusicVoice();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectMusicVoice *pdmVoice);
    virtual HRESULT GetRealObjPtr(IDirectMusicVoice **ppdmVoice);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicVoice
    virtual HRESULT Play(REFERENCE_TIME rtStart,LONG prPitch,LONG vrVolume);
    virtual HRESULT Stop(REFERENCE_TIME rtStop);

};
*/
//===========================================================================
// CtIDirectMusicSynthSink
//
// Wrapper class for IDirectMusicSynthSink
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIDirectMusicSynthSink : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicSynthSink();
    ~CtIDirectMusicSynthSink();
    // overloaded versions of test class helpers
    virtual HRESULT InitTestClass(IDirectMusicSynthSink *pdmSink);
    virtual HRESULT GetRealObjPtr(IDirectMusicSynthSink **ppdmSink);
    // replacementversions of the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicSynthSink methods
    virtual HRESULT Init(CtIDirectMusicSynth *ptdmSynth);
    virtual HRESULT SetMasterClock(CtIReferenceClock *ptClock);
    virtual HRESULT GetLatencyClock(CtIReferenceClock **pptClock);
    virtual HRESULT Activate(BOOL fEnable);
    virtual HRESULT SampleToRefTime(DWORD dwSampleTime,REFERENCE_TIME *prfTime);
    virtual HRESULT RefTimeToSample(REFERENCE_TIME rfTime, REFERENCE_TIME *prtSampleTime);
    virtual HRESULT SetDirectSound(LPDIRECTSOUND pDirectSound,
                                   LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    virtual HRESULT GetDesiredBufferSize(LPDWORD pdwBufferSizeInSamples);

}; // ** end CtIDirectMusicSynthSink

//===========================================================================
// CtIDirectMusicCollection
//
// Wrapper class for IDirectMusicCollection
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicCollection : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicCollection();
    ~CtIDirectMusicCollection();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicCollection *pdmCollect);
    virtual HRESULT GetRealObjPtr(IDirectMusicCollection **ppdmCollect);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicCollection methods
    virtual HRESULT GetInstrument(DWORD dwPatch,
                                CtIDirectMusicInstrument** pptdmInst);
    virtual HRESULT EnumInstrument(DWORD dwIndex, DWORD* pdwPatch,
                                 LPWSTR pName, DWORD cwchName);

}; // ** end CtIDirectMusicCollection

//===========================================================================
// CtIDirectMusicInstrument
//
// Wrapper class for IDirectMusicInstrument
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicInstrument : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicInstrument();
    ~CtIDirectMusicInstrument();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicInstrument *pdmInstr);
    virtual HRESULT GetRealObjPtr(IDirectMusicInstrument **ppdmInstr);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IDirectMusicInstrument methods
    virtual HRESULT GetPatch(DWORD *pdwPatch);
    virtual HRESULT SetPatch(DWORD dwPatch);

}; // ** end CtIDirectMusicInstrument

//===========================================================================
// CtIDirectMusicDownloadedInstrument
//
// Wrapper class for IDirectMusicDownloadedInstrument
//
// Code file(s): tdmobj7.cpp
//===========================================================================
class CtIDirectMusicDownloadedInstrument : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicDownloadedInstrument();
    ~CtIDirectMusicDownloadedInstrument();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicDownloadedInstrument *pdmDlInst);
    virtual HRESULT GetRealObjPtr(IDirectMusicDownloadedInstrument **ppdmDlInst);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // IDirectMusicDownloadedInstrument
    // none

}; // ** end CtIDirectMusicDownloadedInstrument

//===========================================================================
// CtIReferenceClock
//
// Wrapper class for IReferenceClock
//
// Inherits from: CtIUnknown
//===========================================================================
class CtIReferenceClock : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIReferenceClock();
    ~CtIReferenceClock();
    // test class helpers
    virtual HRESULT InitTestClass(IReferenceClock *pRefClock);
    virtual HRESULT GetRealObjPtr(IReferenceClock **ppRefClock);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID *ppvObj);
    // the IReferenceClock methods
    virtual HRESULT GetTime(REFERENCE_TIME *pTime);
    virtual HRESULT AdviseTime(REFERENCE_TIME baseTime,
                                REFERENCE_TIME streamTime,
                                HANDLE hEvent, DWORD * pdwAdviseCookie);
    virtual HRESULT AdvisePeriodic(REFERENCE_TIME startTime,
                                    REFERENCE_TIME periodTime,
                                    HANDLE hSemaphore,
                                    DWORD *pdwAdviseCookie);
    virtual HRESULT Unadvise(DWORD dwAdviseCookie);

}; // ** end CtIReferenceClock

//===========================================================================
// CtIDirectMusicPortDownload
//
// Wrapper class for IDirectMusicPortDownload
//
// Inherits from CtIUnknown
//===========================================================================
class CtIDirectMusicPortDownload : public CtIUnknown
{
    public:
    // constructor / destructor
    CtIDirectMusicPortDownload();
    ~CtIDirectMusicPortDownload();
    // test class helpers
    virtual HRESULT InitTestClass(IDirectMusicPortDownload* pdmPortDl);
    virtual HRESULT GetRealObjPtr(IDirectMusicPortDownload** ppdmPortDl);
    // the IUnknown's
    virtual HRESULT QueryInterface(REFIID riid, LPVOID* ppvObj);
    // the IDirectMusicPortDownload methods
    virtual DWORD GetBuffer(DWORD dwId, CtIDirectMusicDownload** pptdmDownload);
    virtual DWORD AllocateBuffer(DWORD dwSize, CtIDirectMusicDownload** pptdmDownload);
    virtual DWORD GetDLId(DWORD* pdwStartDLId, DWORD 